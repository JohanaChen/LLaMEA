{"id": "a244cd3f-eb28-42bf-a32b-4d44f079ed79", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Standard DE population size scaling\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_prob = 0.3  # Probability of performing local search\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):  # Ensure at least one dimension is from mutant\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.01, 0.1)\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:  # Minimize\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                # Local search with a probability\n                if np.random.rand() < self.local_search_prob:\n                    local_candidate = self._local_search(population[i])\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "HybridDifferentialEvolution", "description": "A hybrid algorithm combining Differential Evolution and Local Search to efficiently explore and exploit the search space for global optimization.", "configspace": "", "generation": 0, "fitness": 0.25393070865326867, "feedback": "The algorithm HybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.20.", "error": "", "parent_id": null, "metadata": {"aucs": [0.6114142209551812, 0.5322322411493297, 0.5369430876241068, 0.5774517316626574, 0.6245997861229118, 0.5891266220166977, 0.5593259725735618, 0.5687527748648598, 0.5643102639107673, 0.2951767234354773, 0.28332583043761084, 0.3136726485508349, 0.2846134351364241, 0.27468524779082015, 0.310043333142635, 0.2937624290223284, 0.27684693602465826, 0.30794818865505313, 0.10407272488589892, 0.10033319431780385, 0.10009239577651097, 0.10303142487419081, 0.10309386936535903, 0.10954681769299857, 0.12253752197861634, 0.11597473098381383, 0.10112593172243123, 0.09831000381076516, 0.08069074427506406, 0.09078858930168976, 0.09195246108385913, 0.10267430857204252, 0.09850483621219741, 0.10128327174430729, 0.08648363465045861, 0.09747417917515067, 0.9463491163314116, 0.9662875769733325, 0.923974465445904, 0.9570439027219089, 0.9157223634466837, 0.909676019202163, 0.9507824038002735, 0.9414365082748986, 0.8922644856357849, 0.23600098104952416, 0.25562692907507967, 0.251850449746567, 0.26543290253277696, 0.23823645908929758, 0.2454137075406817, 0.24769549260285872, 0.24580569428346377, 0.2592887473536599, 0.43467215151768235, 0.43108821549305, 0.4760794924471986, 0.5309272496232804, 0.4942420839993594, 0.4390807909423542, 0.5034969086623013, 0.5219839295999721, 0.44856117928123285, 0.16568769782639725, 0.14755223004932827, 0.20103808940388912, 0.1637882525777562, 0.18375768680575588, 0.1748325163379557, 0.14472448241799707, 0.18772423894214085, 0.20193162479565985, 0.13131953398834517, 0.23907010159985453, 0.12079931033724989, 0.19442928884826272, 0.20255234941521294, 0.18157060930266722, 0.16335789440505777, 0.16215947901404448, 0.15218735018551177, 0.11638020765869128, 0.12125454183780238, 0.10178264650076052, 0.14446799564442447, 0.09908843903934395, 0.10033313187855453, 0.1171659177410973, 0.08678438210344486, 0.12336154080100836, 0.23087652220101784, 0.19937685952214745, 0.21803708442057368, 0.23707611924408323, 0.19344852173736382, 0.24093356110615016, 0.2585556077061114, 0.2569764543760681, 0.2346086862458837, 0.016235517896165175, 0.021260391569981385, 0.029522151279046005, 0.03115304130222407, 0.02671315093986759, 0.026411361646530906, 0.023249744779409, 0.03342208652628831, 0.07611626932428917, 0.13151989684412202, 0.14863357016705592, 0.14241429345456658, 0.13817068586448733, 0.1372099540240077, 0.15028044138722185, 0.14537241762247521, 0.16566293464201298, 0.14842889048729213, 0.4307154040973843, 0.4435512946908935, 0.4544819686291335, 0.4509169688197001, 0.4332952709495055, 0.45018515963515526, 0.4758304342537166, 0.44898459084767206, 0.44155560618463807, 0.121286572850276, 0.10797634338112805, 0.10931969495567406, 0.10685386585272139, 0.10221404216583474, 0.11480925422768307, 0.10771029464192072, 0.1041074110216077, 0.10277885498196737, 0.16940512721330814, 0.1770902466938853, 0.18751577350228477, 0.18524137463388657, 0.20091127362963512, 0.2006930587641299, 0.19030574984305637, 0.1805229012941285, 0.18942831193586174, 0.2648939208022024, 0.2592966804266912, 0.25768508164619086, 0.24869150141054996, 0.24748457302135662, 0.25442970690493805, 0.26890176500120133, 0.27723999893500806, 0.26637334928443945, 0.18325860298984697, 0.19328408792366858, 0.18279122305112927, 0.18882838491143694, 0.18273403663408982, 0.19531755438536624, 0.20878598209139376, 0.19955478975440377, 0.20920533156238508, 0.18954026031488647, 0.16950503327630262, 0.1721755213239725, 0.1903538303234118, 0.17859787007795735, 0.16801916539698036, 0.21195355997600085, 0.19391644987895884, 0.17779839576445633, 0.18924414952236768, 0.18645054241676717, 0.1968618257213317, 0.18518795780196373, 0.1937842027148371, 0.18056909257476217, 0.1880484254915471, 0.19847149228289207, 0.1838160764067236, 0.16160912246038228, 0.3660104552596588, 0.1493326816768682, 0.4722973280790971, 0.17217832125491295, 0.6581680159052573, 0.5496119196746718, 0.3918991532919802, 0.4246602383829824, 0.3758155355103515, 0.19365460051212025, 0.18264527555281151, 0.42183405286579745, 0.24457029826311905, 0.2724294640107844, 0.20814834636980495, 0.5723370604968434, 0.20150119516536047, 0.1866217363676207, 0.18568451880804726, 0.18670077451278722, 0.1792453376440517, 0.18899730512256052, 0.2019618411317593, 0.20189933740584765, 0.1766540597467645, 0.19145436674001903, 0.07302006457304555, 0.07894132816754029, 0.06943357686431662, 0.08222309031842434, 0.07659232602949562, 0.07730782134372804, 0.0719982920023895, 0.06668153356818218, 0.07218534638100393]}, "mutation_prompt": null}
{"id": "6b894692-a592-4053-879a-559fa2ff56a7", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Standard DE population size scaling\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_prob = 0.3  # Probability of performing local search\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):  # Ensure at least one dimension is from mutant\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.01, 0.1)\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:  # Minimize\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                # Local search with a probability\n                if np.random.rand() < self.local_search_prob:\n                    local_candidate = self._local_search(population[i])\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "HybridDifferentialEvolution", "description": "A hybrid algorithm combining Differential Evolution and Local Search to efficiently explore and exploit the search space for global optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a244cd3f-eb28-42bf-a32b-4d44f079ed79", "metadata": {"aucs": [0.6114142209551812, 0.5322322411493297, 0.5369430876241068, 0.5774517316626574, 0.6245997861229118, 0.5891266220166977, 0.5593259725735618, 0.5687527748648598, 0.5643102639107673, 0.2951767234354773, 0.28332583043761084, 0.3136726485508349, 0.2846134351364241, 0.27468524779082015, 0.310043333142635, 0.2937624290223284, 0.27684693602465826, 0.30794818865505313, 0.10407272488589892, 0.10033319431780385, 0.10009239577651097, 0.10303142487419081, 0.10309386936535903, 0.10954681769299857, 0.12253752197861634, 0.11597473098381383, 0.10112593172243123, 0.09831000381076516, 0.08069074427506406, 0.09078858930168976, 0.09195246108385913, 0.10267430857204252, 0.09850483621219741, 0.10128327174430729, 0.08648363465045861, 0.09747417917515067, 0.9463491163314116, 0.9662875769733325, 0.923974465445904, 0.9570439027219089, 0.9157223634466837, 0.909676019202163, 0.9507824038002735, 0.9414365082748986, 0.8922644856357849, 0.23600098104952416, 0.25562692907507967, 0.251850449746567, 0.26543290253277696, 0.23823645908929758, 0.2454137075406817, 0.24769549260285872, 0.24580569428346377, 0.2592887473536599, 0.43467215151768235, 0.43108821549305, 0.4760794924471986, 0.5309272496232804, 0.4942420839993594, 0.4390807909423542, 0.5034969086623013, 0.5219839295999721, 0.44856117928123285, 0.16568769782639725, 0.14755223004932827, 0.20103808940388912, 0.1637882525777562, 0.18375768680575588, 0.1748325163379557, 0.14472448241799707, 0.18772423894214085, 0.20193162479565985, 0.13131953398834517, 0.23907010159985453, 0.12079931033724989, 0.19442928884826272, 0.20255234941521294, 0.18157060930266722, 0.16335789440505777, 0.16215947901404448, 0.15218735018551177, 0.11638020765869128, 0.12125454183780238, 0.10178264650076052, 0.14446799564442447, 0.09908843903934395, 0.10033313187855453, 0.1171659177410973, 0.08678438210344486, 0.12336154080100836, 0.23087652220101784, 0.19937685952214745, 0.21803708442057368, 0.23707611924408323, 0.19344852173736382, 0.24093356110615016, 0.2585556077061114, 0.2569764543760681, 0.2346086862458837, 0.016235517896165175, 0.021260391569981385, 0.029522151279046005, 0.03115304130222407, 0.02671315093986759, 0.026411361646530906, 0.023249744779409, 0.03342208652628831, 0.07611626932428917, 0.13151989684412202, 0.14863357016705592, 0.14241429345456658, 0.13817068586448733, 0.1372099540240077, 0.15028044138722185, 0.14537241762247521, 0.16566293464201298, 0.14842889048729213, 0.4307154040973843, 0.4435512946908935, 0.4544819686291335, 0.4509169688197001, 0.4332952709495055, 0.45018515963515526, 0.4758304342537166, 0.44898459084767206, 0.44155560618463807, 0.121286572850276, 0.10797634338112805, 0.10931969495567406, 0.10685386585272139, 0.10221404216583474, 0.11480925422768307, 0.10771029464192072, 0.1041074110216077, 0.10277885498196737, 0.16940512721330814, 0.1770902466938853, 0.18751577350228477, 0.18524137463388657, 0.20091127362963512, 0.2006930587641299, 0.19030574984305637, 0.1805229012941285, 0.18942831193586174, 0.2648939208022024, 0.2592966804266912, 0.25768508164619086, 0.24869150141054996, 0.24748457302135662, 0.25442970690493805, 0.26890176500120133, 0.27723999893500806, 0.26637334928443945, 0.18325860298984697, 0.19328408792366858, 0.18279122305112927, 0.18882838491143694, 0.18273403663408982, 0.19531755438536624, 0.20878598209139376, 0.19955478975440377, 0.20920533156238508, 0.18954026031488647, 0.16950503327630262, 0.1721755213239725, 0.1903538303234118, 0.17859787007795735, 0.16801916539698036, 0.21195355997600085, 0.19391644987895884, 0.17779839576445633, 0.18924414952236768, 0.18645054241676717, 0.1968618257213317, 0.18518795780196373, 0.1937842027148371, 0.18056909257476217, 0.1880484254915471, 0.19847149228289207, 0.1838160764067236, 0.16160912246038228, 0.3660104552596588, 0.1493326816768682, 0.4722973280790971, 0.17217832125491295, 0.6581680159052573, 0.5496119196746718, 0.3918991532919802, 0.4246602383829824, 0.3758155355103515, 0.19365460051212025, 0.18264527555281151, 0.42183405286579745, 0.24457029826311905, 0.2724294640107844, 0.20814834636980495, 0.5723370604968434, 0.20150119516536047, 0.1866217363676207, 0.18568451880804726, 0.18670077451278722, 0.1792453376440517, 0.18899730512256052, 0.2019618411317593, 0.20189933740584765, 0.1766540597467645, 0.19145436674001903, 0.07302006457304555, 0.07894132816754029, 0.06943357686431662, 0.08222309031842434, 0.07659232602949562, 0.07730782134372804, 0.0719982920023895, 0.06668153356818218, 0.07218534638100393]}, "mutation_prompt": null}
{"id": "bc99c0df-359a-4602-a68f-ba8bf335a68f", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.local_search_prob = 0.3\n        self.elite_fraction = 0.1  # Preserve a fraction of the best solutions\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        adaptive_CR = np.tanh(self.CR * np.mean(mutant - target))  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.01, 0.1)\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            elite_count = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_count]  # Keep track of elites\n\n            for i in range(self.population_size):\n                if i in elite_indices:  # Skip mutation for elites\n                    continue\n\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    local_candidate = self._local_search(population[i])\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with adaptive crossover and elite preservation to improve convergence performance.", "configspace": "", "generation": 2, "fitness": 0.2054375861458864, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.20.", "error": "", "parent_id": "a244cd3f-eb28-42bf-a32b-4d44f079ed79", "metadata": {"aucs": [0.6404908181350943, 0.6174398011710924, 0.6361411806720734, 0.6025901679901232, 0.6523821066307709, 0.6375929073198734, 0.6147810473053914, 0.6293130646561896, 0.6318704036647207, 0.3477133665716102, 0.2995063592825046, 0.3400492557765926, 0.2904819545280757, 0.2925084395657014, 0.36134916830881403, 0.32819645428145783, 0.3260948084263475, 0.3450016492121136, 0.2629717745805005, 0.22732753806147354, 0.29381580667314655, 0.28500965333152517, 0.2553227467410466, 0.33211876860041756, 0.2887263030303341, 0.23649380017887667, 0.2531315119085701, 0.23203012734070694, 0.25484058577568347, 0.25644522096705946, 0.24812883575696987, 0.22290967989278987, 0.2613556020827259, 0.2196615819689005, 0.23748105314960777, 0.23802860140453364, 0.9566052653837254, 0.9088941636731512, 0.9247139662802606, 0.9156548161030045, 0.9315725200880038, 0.8904796814980529, 0.907572336551401, 0.9123928690043498, 0.892704766784934, 0.18661317354934503, 0.17846641982577494, 0.17774858348497968, 0.12824667401093337, 0.14167412216527986, 0.15007736152688833, 0.13324435953397984, 0.141016724230549, 0.14493453958482583, 0.1589131639567566, 0.1757497922437673, 0.2072577255775906, 0.17286304426162902, 0.16586859043817692, 0.17551361745427896, 0.16701975044834216, 0.17697382597122902, 0.16719272405295194, 0.1026147192460789, 0.11184363590569446, 0.10381001374758814, 0.10673024335455394, 0.09461187693166162, 0.10345093765836044, 0.125534403715706, 0.10559310030603664, 0.14294630926117502, 0.09743149128063955, 0.07042119021225157, 0.10273086863623226, 0.05735379300092458, 0.014898342586474822, 0.009796886266625005, 0.09153090873458858, 0.09201518482478954, 0.09441543249304507, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04743571788577905, 0.032972650692133176, 0.05507981215019153, 0.06269069120117543, 0.09800750490085464, 0.09874179747259204, 0.020419490893858194, 0.035764501596938114, 0.03878241328643506, 0.004812110002718195, 0.012730602588911233, 0.013554669707295353, 9.999999999998899e-05, 0.0001250407705740697, 9.999999999998899e-05, 9.999999999998899e-05, 0.0038807989811826538, 0.006612068687260053, 0.024936332255644844, 0.024902587420391864, 0.030241638993770747, 0.054475753700492735, 0.07779602640293959, 0.07754261409445384, 0.054214008199391484, 0.050522984087406964, 0.06834617235519602, 0.35432225411670726, 0.35436676486635366, 0.36902117989317806, 0.36712159183768167, 0.3574801524341825, 0.37428642284591473, 0.36206430004845747, 0.35852536221368925, 0.3741722098839647, 0.09377676365282861, 0.0796040212196889, 0.08337130929061987, 0.07360124610253949, 0.06759663719048326, 0.09367257089929704, 0.08175314868215644, 0.07361866924058336, 0.07859671891427222, 0.15481677418144824, 0.15162289097020365, 0.15689533552561719, 0.15440027208854168, 0.1845503487536576, 0.14142175962751613, 0.16865234116810646, 0.15630627421953436, 0.17569705721949191, 0.20228497332009132, 0.20358164544501123, 0.19491551977228905, 0.18362541028642854, 0.18042452099142559, 0.17727045561280086, 0.19377526217376229, 0.18298071560271278, 0.18385486279214647, 0.13444429028065774, 0.14864165619510494, 0.14372419720013663, 0.1448559949143693, 0.12364431948080923, 0.12540632798463958, 0.12635274818241815, 0.13377505244346177, 0.13742236552073228, 0.17440034799209847, 0.1723202449146013, 0.17520196498736262, 0.19236896218932664, 0.18567177084851194, 0.19603101556991942, 0.18434054359528196, 0.18046088520528047, 0.1914855984252376, 0.18755267927577735, 0.1902743134441015, 0.19574425399307127, 0.18775192790431372, 0.18298734055124966, 0.18872953699168094, 0.19340419447827817, 0.18932555996615585, 0.1946242646844465, 0.14536361778299267, 0.1571777924429829, 0.15153516503877473, 0.2030586289499664, 0.16496778254972433, 0.1714476188317523, 0.1680305546437476, 0.16127945985698644, 0.15914862769310567, 0.17966527450283942, 0.1856169986501951, 0.2349247658311735, 0.15171535584672458, 0.1532703798589926, 0.15693985240046515, 0.21707627667200136, 0.24439940106458602, 0.30636955110918185, 0.17380468200021237, 0.19165439269232198, 0.17963683175105905, 0.18761864633660086, 0.18785533548661693, 0.1833071205847715, 0.19231178594235154, 0.19286580050845004, 0.17720020513372325, 0.06769432645563778, 0.07185446926787531, 0.07719592506055417, 0.07837906958100938, 0.07071350454893854, 0.074673360558976, 0.07877820735621122, 0.07013625114051081, 0.0690974399594454]}, "mutation_prompt": null}
{"id": "3cc42b35-28da-4fd8-acb5-7c7c6c1fa636", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.local_search_prob = 0.3\n        self.adaptive_factor = 0.1  # New adaptive factor for tuning\n        self.restart_threshold = 0.1  # Threshold for stagnation to trigger a restart\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.01, 0.1)\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def _adaptive_parameters(self):  # New function for adaptive parameter tuning\n        self.F = np.clip(self.F + self.adaptive_factor * (np.random.rand() - 0.5), 0.5, 1.0)\n        self.CR = np.clip(self.CR + self.adaptive_factor * (np.random.rand() - 0.5), 0.1, 1.0)\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n        best_fitness = np.min(fitness)\n        stagnation_counter = 0\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    stagnation_counter = 0\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    local_candidate = self._local_search(population[i])\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n                        stagnation_counter = 0\n\n                if evals >= self.budget:\n                    break\n\n            if np.min(fitness) >= best_fitness:\n                stagnation_counter += 1\n            else:\n                best_fitness = np.min(fitness)\n                stagnation_counter = 0\n\n            if stagnation_counter > self.population_size * self.restart_threshold:\n                population = self._initialize_population()\n                fitness = np.array([func(ind) for ind in population])\n                evals += self.population_size\n                stagnation_counter = 0\n\n            self._adaptive_parameters()\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "HybridDifferentialEvolution", "description": "Integrate adaptive parameter tuning and restart mechanisms into the hybrid DE to enhance exploration and convergence robustness.", "configspace": "", "generation": 3, "fitness": 0.24226104566121698, "feedback": "The algorithm HybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.20.", "error": "", "parent_id": "a244cd3f-eb28-42bf-a32b-4d44f079ed79", "metadata": {"aucs": [0.5807787628327548, 0.44136202670427616, 0.6434734138148183, 0.6082111170627431, 0.5238996062311729, 0.6790560366612232, 0.6147661585208921, 0.5128896248716435, 0.6823287324097091, 0.34318652042164377, 0.21926826963339818, 0.38704102433023935, 0.3196210763036186, 0.20283030735578256, 0.40697327825959584, 0.32417088434278074, 0.2115766208199037, 0.4134026622387711, 0.15028181981479993, 0.11720449328487215, 0.10728548754370093, 0.16280577705545252, 0.10884126909553582, 0.10508859884513189, 0.1843110355876202, 0.11350456911468387, 0.11342381034992721, 0.12972998551919213, 0.10581409108239836, 0.0939163648458674, 0.12991175979740732, 0.09500762167652088, 0.1085508327073137, 0.12083352317573848, 0.09535774034592137, 0.10031868750418216, 0.906136100037517, 0.9207117385106184, 0.9217680916834519, 0.8861288253040354, 0.9166947636648803, 0.9366010204427487, 0.9036770231366821, 0.945742378834137, 0.9184745270800208, 0.22770089120343928, 0.19235736558775185, 0.2821179984115063, 0.23780920122545968, 0.2124437656316689, 0.318521006732415, 0.2171865286474125, 0.21518891388688877, 0.30467257293567707, 0.26248097414290683, 0.273451603114541, 0.6262362838138282, 0.28301489144354963, 0.37461126810279677, 0.5927776617410851, 0.2860265034377152, 0.40780277911823315, 0.5950466918766919, 0.14773677513540628, 0.1482149442464975, 0.16398561298383052, 0.14735576829888342, 0.13107151780285298, 0.22024468180586998, 0.15592403696203583, 0.12245347793736416, 0.16907045904108586, 0.13538383327624437, 0.1270618788427993, 0.19768434960545023, 0.17478315938521172, 0.11343988696472584, 0.15138907331441154, 0.1288918177149535, 0.12835674486951376, 0.19083345573747168, 0.016872535201858607, 0.035621739819254095, 0.12952098418694336, 0.0001968265825468274, 0.03496860252597633, 0.12632102148850022, 0.017970604113703437, 0.05377661093604924, 0.17472502660637146, 0.1429223724829244, 0.16456622261341558, 0.26540886250134665, 0.13879807359614338, 0.17827352001387353, 0.25272856148675404, 0.12899223153674555, 0.1674636410141357, 0.28371343549746164, 0.0002373809229407886, 0.014986000321580595, 0.05863719200441142, 0.002191662400382821, 0.006857885735190528, 0.06192723061111205, 0.0002896438701908144, 9.999999999998899e-05, 0.04065174361949253, 0.09218285930510606, 0.10213497498156976, 0.15512275893170357, 0.0951319075700412, 0.09563632265905453, 0.19646670664602994, 0.09665721338650513, 0.113032150925225, 0.16256836189035917, 0.3889840105491509, 0.3588126458333878, 0.4608797892890656, 0.4071437255851079, 0.40419788017143243, 0.47658648198951303, 0.416831625803908, 0.37103863586240515, 0.47125519125464854, 0.11061204440646777, 0.08335711859922124, 0.11251080458000084, 0.10454582137669188, 0.12573733072537874, 0.10303256863245425, 0.09810747363386907, 0.08801318003314007, 0.10396929472413663, 0.15054697100364067, 0.220663939195908, 0.16266904778351832, 0.17809725673264054, 0.18009140659364653, 0.22319241885719276, 0.19879389456657337, 0.16789134715335874, 0.15694727940958253, 0.2639409567201274, 0.21757430303431102, 0.27901706030071605, 0.21481319986723546, 0.20388225597265608, 0.28404554581967645, 0.26266294204321905, 0.2520139028628924, 0.2952987961451865, 0.16971140818211627, 0.16638870797494165, 0.2056613403533757, 0.1701677189179318, 0.15721543603926635, 0.2221197655187156, 0.19764051066749333, 0.16315302870872217, 0.22908819076178366, 0.1919181397979376, 0.1747201426995909, 0.19682767744440766, 0.19128877130205135, 0.19019799703661922, 0.17930548287381576, 0.19083328389524745, 0.194759174053176, 0.19616147086313973, 0.19027566190292577, 0.18005733342356578, 0.20179125465395287, 0.21274584173085087, 0.19316800938357026, 0.18964370509180073, 0.19206147140661556, 0.17383186232549908, 0.18732482410939588, 0.25005874579133025, 0.19673319293010372, 0.5865216688295604, 0.24328954214573772, 0.1654352915552676, 0.6391507267623076, 0.24136190761116794, 0.23648159932782675, 0.19785826739712264, 0.29584588630724185, 0.19742783584000712, 0.3724200094186415, 0.22350142601128942, 0.2867817604437819, 0.22426819419442678, 0.20578432049158868, 0.20234299478555984, 0.6213346045349675, 0.1818559772301006, 0.18010148121716596, 0.1898438001758771, 0.20895791559707855, 0.19386113547418127, 0.1818009205168074, 0.20142503076238039, 0.21315431246311756, 0.20284264782164885, 0.07140091582750052, 0.07386990858941078, 0.07939222097687848, 0.08049858092009932, 0.07685604390321876, 0.10399679664641714, 0.06781284553604072, 0.0652495273836079, 0.07911216735443882]}, "mutation_prompt": null}
{"id": "5b8cfbc6-227e-4aee-a6c3-1c1015dbd6f6", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Standard DE population size scaling\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_prob = 0.3  # Probability of performing local search\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):  # Ensure at least one dimension is from mutant\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.01, 0.1)\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:  # Minimize\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                # Local search with a probability\n                if np.random.rand() < self.local_search_prob:\n                    local_candidate = self._local_search(population[i])\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "HybridDifferentialEvolution", "description": "A hybrid algorithm combining Differential Evolution and Local Search to efficiently explore and exploit the search space for global optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a244cd3f-eb28-42bf-a32b-4d44f079ed79", "metadata": {"aucs": [0.6114142209551812, 0.5322322411493297, 0.5369430876241068, 0.5774517316626574, 0.6245997861229118, 0.5891266220166977, 0.5593259725735618, 0.5687527748648598, 0.5643102639107673, 0.2951767234354773, 0.28332583043761084, 0.3136726485508349, 0.2846134351364241, 0.27468524779082015, 0.310043333142635, 0.2937624290223284, 0.27684693602465826, 0.30794818865505313, 0.10407272488589892, 0.10033319431780385, 0.10009239577651097, 0.10303142487419081, 0.10309386936535903, 0.10954681769299857, 0.12253752197861634, 0.11597473098381383, 0.10112593172243123, 0.09831000381076516, 0.08069074427506406, 0.09078858930168976, 0.09195246108385913, 0.10267430857204252, 0.09850483621219741, 0.10128327174430729, 0.08648363465045861, 0.09747417917515067, 0.9463491163314116, 0.9662875769733325, 0.923974465445904, 0.9570439027219089, 0.9157223634466837, 0.909676019202163, 0.9507824038002735, 0.9414365082748986, 0.8922644856357849, 0.23600098104952416, 0.25562692907507967, 0.251850449746567, 0.26543290253277696, 0.23823645908929758, 0.2454137075406817, 0.24769549260285872, 0.24580569428346377, 0.2592887473536599, 0.43467215151768235, 0.43108821549305, 0.4760794924471986, 0.5309272496232804, 0.4942420839993594, 0.4390807909423542, 0.5034969086623013, 0.5219839295999721, 0.44856117928123285, 0.16568769782639725, 0.14755223004932827, 0.20103808940388912, 0.1637882525777562, 0.18375768680575588, 0.1748325163379557, 0.14472448241799707, 0.18772423894214085, 0.20193162479565985, 0.13131953398834517, 0.23907010159985453, 0.12079931033724989, 0.19442928884826272, 0.20255234941521294, 0.18157060930266722, 0.16335789440505777, 0.16215947901404448, 0.15218735018551177, 0.11638020765869128, 0.12125454183780238, 0.10178264650076052, 0.14446799564442447, 0.09908843903934395, 0.10033313187855453, 0.1171659177410973, 0.08678438210344486, 0.12336154080100836, 0.23087652220101784, 0.19937685952214745, 0.21803708442057368, 0.23707611924408323, 0.19344852173736382, 0.24093356110615016, 0.2585556077061114, 0.2569764543760681, 0.2346086862458837, 0.016235517896165175, 0.021260391569981385, 0.029522151279046005, 0.03115304130222407, 0.02671315093986759, 0.026411361646530906, 0.023249744779409, 0.03342208652628831, 0.07611626932428917, 0.13151989684412202, 0.14863357016705592, 0.14241429345456658, 0.13817068586448733, 0.1372099540240077, 0.15028044138722185, 0.14537241762247521, 0.16566293464201298, 0.14842889048729213, 0.4307154040973843, 0.4435512946908935, 0.4544819686291335, 0.4509169688197001, 0.4332952709495055, 0.45018515963515526, 0.4758304342537166, 0.44898459084767206, 0.44155560618463807, 0.121286572850276, 0.10797634338112805, 0.10931969495567406, 0.10685386585272139, 0.10221404216583474, 0.11480925422768307, 0.10771029464192072, 0.1041074110216077, 0.10277885498196737, 0.16940512721330814, 0.1770902466938853, 0.18751577350228477, 0.18524137463388657, 0.20091127362963512, 0.2006930587641299, 0.19030574984305637, 0.1805229012941285, 0.18942831193586174, 0.2648939208022024, 0.2592966804266912, 0.25768508164619086, 0.24869150141054996, 0.24748457302135662, 0.25442970690493805, 0.26890176500120133, 0.27723999893500806, 0.26637334928443945, 0.18325860298984697, 0.19328408792366858, 0.18279122305112927, 0.18882838491143694, 0.18273403663408982, 0.19531755438536624, 0.20878598209139376, 0.19955478975440377, 0.20920533156238508, 0.18954026031488647, 0.16950503327630262, 0.1721755213239725, 0.1903538303234118, 0.17859787007795735, 0.16801916539698036, 0.21195355997600085, 0.19391644987895884, 0.17779839576445633, 0.18924414952236768, 0.18645054241676717, 0.1968618257213317, 0.18518795780196373, 0.1937842027148371, 0.18056909257476217, 0.1880484254915471, 0.19847149228289207, 0.1838160764067236, 0.16160912246038228, 0.3660104552596588, 0.1493326816768682, 0.4722973280790971, 0.17217832125491295, 0.6581680159052573, 0.5496119196746718, 0.3918991532919802, 0.4246602383829824, 0.3758155355103515, 0.19365460051212025, 0.18264527555281151, 0.42183405286579745, 0.24457029826311905, 0.2724294640107844, 0.20814834636980495, 0.5723370604968434, 0.20150119516536047, 0.1866217363676207, 0.18568451880804726, 0.18670077451278722, 0.1792453376440517, 0.18899730512256052, 0.2019618411317593, 0.20189933740584765, 0.1766540597467645, 0.19145436674001903, 0.07302006457304555, 0.07894132816754029, 0.06943357686431662, 0.08222309031842434, 0.07659232602949562, 0.07730782134372804, 0.0719982920023895, 0.06668153356818218, 0.07218534638100393]}, "mutation_prompt": null}
{"id": "27a98c25-829f-4953-8249-c8a22df297ca", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Standard DE population size scaling\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_prob = 0.3  # Probability of performing local search\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):  # Ensure at least one dimension is from mutant\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.01, 0.1)\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:  # Minimize\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                # Local search with a probability\n                if np.random.rand() < self.local_search_prob:\n                    local_candidate = self._local_search(population[i])\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "HybridDifferentialEvolution", "description": "A hybrid algorithm combining Differential Evolution and Local Search to efficiently explore and exploit the search space for global optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a244cd3f-eb28-42bf-a32b-4d44f079ed79", "metadata": {"aucs": [0.6114142209551812, 0.5322322411493297, 0.5369430876241068, 0.5774517316626574, 0.6245997861229118, 0.5891266220166977, 0.5593259725735618, 0.5687527748648598, 0.5643102639107673, 0.2951767234354773, 0.28332583043761084, 0.3136726485508349, 0.2846134351364241, 0.27468524779082015, 0.310043333142635, 0.2937624290223284, 0.27684693602465826, 0.30794818865505313, 0.10407272488589892, 0.10033319431780385, 0.10009239577651097, 0.10303142487419081, 0.10309386936535903, 0.10954681769299857, 0.12253752197861634, 0.11597473098381383, 0.10112593172243123, 0.09831000381076516, 0.08069074427506406, 0.09078858930168976, 0.09195246108385913, 0.10267430857204252, 0.09850483621219741, 0.10128327174430729, 0.08648363465045861, 0.09747417917515067, 0.9463491163314116, 0.9662875769733325, 0.923974465445904, 0.9570439027219089, 0.9157223634466837, 0.909676019202163, 0.9507824038002735, 0.9414365082748986, 0.8922644856357849, 0.23600098104952416, 0.25562692907507967, 0.251850449746567, 0.26543290253277696, 0.23823645908929758, 0.2454137075406817, 0.24769549260285872, 0.24580569428346377, 0.2592887473536599, 0.43467215151768235, 0.43108821549305, 0.4760794924471986, 0.5309272496232804, 0.4942420839993594, 0.4390807909423542, 0.5034969086623013, 0.5219839295999721, 0.44856117928123285, 0.16568769782639725, 0.14755223004932827, 0.20103808940388912, 0.1637882525777562, 0.18375768680575588, 0.1748325163379557, 0.14472448241799707, 0.18772423894214085, 0.20193162479565985, 0.13131953398834517, 0.23907010159985453, 0.12079931033724989, 0.19442928884826272, 0.20255234941521294, 0.18157060930266722, 0.16335789440505777, 0.16215947901404448, 0.15218735018551177, 0.11638020765869128, 0.12125454183780238, 0.10178264650076052, 0.14446799564442447, 0.09908843903934395, 0.10033313187855453, 0.1171659177410973, 0.08678438210344486, 0.12336154080100836, 0.23087652220101784, 0.19937685952214745, 0.21803708442057368, 0.23707611924408323, 0.19344852173736382, 0.24093356110615016, 0.2585556077061114, 0.2569764543760681, 0.2346086862458837, 0.016235517896165175, 0.021260391569981385, 0.029522151279046005, 0.03115304130222407, 0.02671315093986759, 0.026411361646530906, 0.023249744779409, 0.03342208652628831, 0.07611626932428917, 0.13151989684412202, 0.14863357016705592, 0.14241429345456658, 0.13817068586448733, 0.1372099540240077, 0.15028044138722185, 0.14537241762247521, 0.16566293464201298, 0.14842889048729213, 0.4307154040973843, 0.4435512946908935, 0.4544819686291335, 0.4509169688197001, 0.4332952709495055, 0.45018515963515526, 0.4758304342537166, 0.44898459084767206, 0.44155560618463807, 0.121286572850276, 0.10797634338112805, 0.10931969495567406, 0.10685386585272139, 0.10221404216583474, 0.11480925422768307, 0.10771029464192072, 0.1041074110216077, 0.10277885498196737, 0.16940512721330814, 0.1770902466938853, 0.18751577350228477, 0.18524137463388657, 0.20091127362963512, 0.2006930587641299, 0.19030574984305637, 0.1805229012941285, 0.18942831193586174, 0.2648939208022024, 0.2592966804266912, 0.25768508164619086, 0.24869150141054996, 0.24748457302135662, 0.25442970690493805, 0.26890176500120133, 0.27723999893500806, 0.26637334928443945, 0.18325860298984697, 0.19328408792366858, 0.18279122305112927, 0.18882838491143694, 0.18273403663408982, 0.19531755438536624, 0.20878598209139376, 0.19955478975440377, 0.20920533156238508, 0.18954026031488647, 0.16950503327630262, 0.1721755213239725, 0.1903538303234118, 0.17859787007795735, 0.16801916539698036, 0.21195355997600085, 0.19391644987895884, 0.17779839576445633, 0.18924414952236768, 0.18645054241676717, 0.1968618257213317, 0.18518795780196373, 0.1937842027148371, 0.18056909257476217, 0.1880484254915471, 0.19847149228289207, 0.1838160764067236, 0.16160912246038228, 0.3660104552596588, 0.1493326816768682, 0.4722973280790971, 0.17217832125491295, 0.6581680159052573, 0.5496119196746718, 0.3918991532919802, 0.4246602383829824, 0.3758155355103515, 0.19365460051212025, 0.18264527555281151, 0.42183405286579745, 0.24457029826311905, 0.2724294640107844, 0.20814834636980495, 0.5723370604968434, 0.20150119516536047, 0.1866217363676207, 0.18568451880804726, 0.18670077451278722, 0.1792453376440517, 0.18899730512256052, 0.2019618411317593, 0.20189933740584765, 0.1766540597467645, 0.19145436674001903, 0.07302006457304555, 0.07894132816754029, 0.06943357686431662, 0.08222309031842434, 0.07659232602949562, 0.07730782134372804, 0.0719982920023895, 0.06668153356818218, 0.07218534638100393]}, "mutation_prompt": null}
{"id": "fc4caa4e-271d-4210-bf6a-31d446a629a6", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Standard DE population size scaling\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_prob = 0.3  # Probability of performing local search\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):  # Ensure at least one dimension is from mutant\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.01, 0.1)\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:  # Minimize\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                # Local search with a probability\n                if np.random.rand() < self.local_search_prob:\n                    local_candidate = self._local_search(population[i])\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "HybridDifferentialEvolution", "description": "A hybrid algorithm combining Differential Evolution and Local Search to efficiently explore and exploit the search space for global optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a244cd3f-eb28-42bf-a32b-4d44f079ed79", "metadata": {"aucs": [0.6114142209551812, 0.5322322411493297, 0.5369430876241068, 0.5774517316626574, 0.6245997861229118, 0.5891266220166977, 0.5593259725735618, 0.5687527748648598, 0.5643102639107673, 0.2951767234354773, 0.28332583043761084, 0.3136726485508349, 0.2846134351364241, 0.27468524779082015, 0.310043333142635, 0.2937624290223284, 0.27684693602465826, 0.30794818865505313, 0.10407272488589892, 0.10033319431780385, 0.10009239577651097, 0.10303142487419081, 0.10309386936535903, 0.10954681769299857, 0.12253752197861634, 0.11597473098381383, 0.10112593172243123, 0.09831000381076516, 0.08069074427506406, 0.09078858930168976, 0.09195246108385913, 0.10267430857204252, 0.09850483621219741, 0.10128327174430729, 0.08648363465045861, 0.09747417917515067, 0.9463491163314116, 0.9662875769733325, 0.923974465445904, 0.9570439027219089, 0.9157223634466837, 0.909676019202163, 0.9507824038002735, 0.9414365082748986, 0.8922644856357849, 0.23600098104952416, 0.25562692907507967, 0.251850449746567, 0.26543290253277696, 0.23823645908929758, 0.2454137075406817, 0.24769549260285872, 0.24580569428346377, 0.2592887473536599, 0.43467215151768235, 0.43108821549305, 0.4760794924471986, 0.5309272496232804, 0.4942420839993594, 0.4390807909423542, 0.5034969086623013, 0.5219839295999721, 0.44856117928123285, 0.16568769782639725, 0.14755223004932827, 0.20103808940388912, 0.1637882525777562, 0.18375768680575588, 0.1748325163379557, 0.14472448241799707, 0.18772423894214085, 0.20193162479565985, 0.13131953398834517, 0.23907010159985453, 0.12079931033724989, 0.19442928884826272, 0.20255234941521294, 0.18157060930266722, 0.16335789440505777, 0.16215947901404448, 0.15218735018551177, 0.11638020765869128, 0.12125454183780238, 0.10178264650076052, 0.14446799564442447, 0.09908843903934395, 0.10033313187855453, 0.1171659177410973, 0.08678438210344486, 0.12336154080100836, 0.23087652220101784, 0.19937685952214745, 0.21803708442057368, 0.23707611924408323, 0.19344852173736382, 0.24093356110615016, 0.2585556077061114, 0.2569764543760681, 0.2346086862458837, 0.016235517896165175, 0.021260391569981385, 0.029522151279046005, 0.03115304130222407, 0.02671315093986759, 0.026411361646530906, 0.023249744779409, 0.03342208652628831, 0.07611626932428917, 0.13151989684412202, 0.14863357016705592, 0.14241429345456658, 0.13817068586448733, 0.1372099540240077, 0.15028044138722185, 0.14537241762247521, 0.16566293464201298, 0.14842889048729213, 0.4307154040973843, 0.4435512946908935, 0.4544819686291335, 0.4509169688197001, 0.4332952709495055, 0.45018515963515526, 0.4758304342537166, 0.44898459084767206, 0.44155560618463807, 0.121286572850276, 0.10797634338112805, 0.10931969495567406, 0.10685386585272139, 0.10221404216583474, 0.11480925422768307, 0.10771029464192072, 0.1041074110216077, 0.10277885498196737, 0.16940512721330814, 0.1770902466938853, 0.18751577350228477, 0.18524137463388657, 0.20091127362963512, 0.2006930587641299, 0.19030574984305637, 0.1805229012941285, 0.18942831193586174, 0.2648939208022024, 0.2592966804266912, 0.25768508164619086, 0.24869150141054996, 0.24748457302135662, 0.25442970690493805, 0.26890176500120133, 0.27723999893500806, 0.26637334928443945, 0.18325860298984697, 0.19328408792366858, 0.18279122305112927, 0.18882838491143694, 0.18273403663408982, 0.19531755438536624, 0.20878598209139376, 0.19955478975440377, 0.20920533156238508, 0.18954026031488647, 0.16950503327630262, 0.1721755213239725, 0.1903538303234118, 0.17859787007795735, 0.16801916539698036, 0.21195355997600085, 0.19391644987895884, 0.17779839576445633, 0.18924414952236768, 0.18645054241676717, 0.1968618257213317, 0.18518795780196373, 0.1937842027148371, 0.18056909257476217, 0.1880484254915471, 0.19847149228289207, 0.1838160764067236, 0.16160912246038228, 0.3660104552596588, 0.1493326816768682, 0.4722973280790971, 0.17217832125491295, 0.6581680159052573, 0.5496119196746718, 0.3918991532919802, 0.4246602383829824, 0.3758155355103515, 0.19365460051212025, 0.18264527555281151, 0.42183405286579745, 0.24457029826311905, 0.2724294640107844, 0.20814834636980495, 0.5723370604968434, 0.20150119516536047, 0.1866217363676207, 0.18568451880804726, 0.18670077451278722, 0.1792453376440517, 0.18899730512256052, 0.2019618411317593, 0.20189933740584765, 0.1766540597467645, 0.19145436674001903, 0.07302006457304555, 0.07894132816754029, 0.06943357686431662, 0.08222309031842434, 0.07659232602949562, 0.07730782134372804, 0.0719982920023895, 0.06668153356818218, 0.07218534638100393]}, "mutation_prompt": null}
{"id": "2c5f55ed-287f-4db8-b688-0f59d0d52ef2", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Standard DE population size scaling\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_prob = 0.3  # Probability of performing local search\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):  # Ensure at least one dimension is from mutant\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.01, 0.1)\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:  # Minimize\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                # Local search with a probability\n                if np.random.rand() < self.local_search_prob:\n                    local_candidate = self._local_search(population[i])\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "HybridDifferentialEvolution", "description": "A hybrid algorithm combining Differential Evolution and Local Search to efficiently explore and exploit the search space for global optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a244cd3f-eb28-42bf-a32b-4d44f079ed79", "metadata": {"aucs": [0.6114142209551812, 0.5322322411493297, 0.5369430876241068, 0.5774517316626574, 0.6245997861229118, 0.5891266220166977, 0.5593259725735618, 0.5687527748648598, 0.5643102639107673, 0.2951767234354773, 0.28332583043761084, 0.3136726485508349, 0.2846134351364241, 0.27468524779082015, 0.310043333142635, 0.2937624290223284, 0.27684693602465826, 0.30794818865505313, 0.10407272488589892, 0.10033319431780385, 0.10009239577651097, 0.10303142487419081, 0.10309386936535903, 0.10954681769299857, 0.12253752197861634, 0.11597473098381383, 0.10112593172243123, 0.09831000381076516, 0.08069074427506406, 0.09078858930168976, 0.09195246108385913, 0.10267430857204252, 0.09850483621219741, 0.10128327174430729, 0.08648363465045861, 0.09747417917515067, 0.9463491163314116, 0.9662875769733325, 0.923974465445904, 0.9570439027219089, 0.9157223634466837, 0.909676019202163, 0.9507824038002735, 0.9414365082748986, 0.8922644856357849, 0.23600098104952416, 0.25562692907507967, 0.251850449746567, 0.26543290253277696, 0.23823645908929758, 0.2454137075406817, 0.24769549260285872, 0.24580569428346377, 0.2592887473536599, 0.43467215151768235, 0.43108821549305, 0.4760794924471986, 0.5309272496232804, 0.4942420839993594, 0.4390807909423542, 0.5034969086623013, 0.5219839295999721, 0.44856117928123285, 0.16568769782639725, 0.14755223004932827, 0.20103808940388912, 0.1637882525777562, 0.18375768680575588, 0.1748325163379557, 0.14472448241799707, 0.18772423894214085, 0.20193162479565985, 0.13131953398834517, 0.23907010159985453, 0.12079931033724989, 0.19442928884826272, 0.20255234941521294, 0.18157060930266722, 0.16335789440505777, 0.16215947901404448, 0.15218735018551177, 0.11638020765869128, 0.12125454183780238, 0.10178264650076052, 0.14446799564442447, 0.09908843903934395, 0.10033313187855453, 0.1171659177410973, 0.08678438210344486, 0.12336154080100836, 0.23087652220101784, 0.19937685952214745, 0.21803708442057368, 0.23707611924408323, 0.19344852173736382, 0.24093356110615016, 0.2585556077061114, 0.2569764543760681, 0.2346086862458837, 0.016235517896165175, 0.021260391569981385, 0.029522151279046005, 0.03115304130222407, 0.02671315093986759, 0.026411361646530906, 0.023249744779409, 0.03342208652628831, 0.07611626932428917, 0.13151989684412202, 0.14863357016705592, 0.14241429345456658, 0.13817068586448733, 0.1372099540240077, 0.15028044138722185, 0.14537241762247521, 0.16566293464201298, 0.14842889048729213, 0.4307154040973843, 0.4435512946908935, 0.4544819686291335, 0.4509169688197001, 0.4332952709495055, 0.45018515963515526, 0.4758304342537166, 0.44898459084767206, 0.44155560618463807, 0.121286572850276, 0.10797634338112805, 0.10931969495567406, 0.10685386585272139, 0.10221404216583474, 0.11480925422768307, 0.10771029464192072, 0.1041074110216077, 0.10277885498196737, 0.16940512721330814, 0.1770902466938853, 0.18751577350228477, 0.18524137463388657, 0.20091127362963512, 0.2006930587641299, 0.19030574984305637, 0.1805229012941285, 0.18942831193586174, 0.2648939208022024, 0.2592966804266912, 0.25768508164619086, 0.24869150141054996, 0.24748457302135662, 0.25442970690493805, 0.26890176500120133, 0.27723999893500806, 0.26637334928443945, 0.18325860298984697, 0.19328408792366858, 0.18279122305112927, 0.18882838491143694, 0.18273403663408982, 0.19531755438536624, 0.20878598209139376, 0.19955478975440377, 0.20920533156238508, 0.18954026031488647, 0.16950503327630262, 0.1721755213239725, 0.1903538303234118, 0.17859787007795735, 0.16801916539698036, 0.21195355997600085, 0.19391644987895884, 0.17779839576445633, 0.18924414952236768, 0.18645054241676717, 0.1968618257213317, 0.18518795780196373, 0.1937842027148371, 0.18056909257476217, 0.1880484254915471, 0.19847149228289207, 0.1838160764067236, 0.16160912246038228, 0.3660104552596588, 0.1493326816768682, 0.4722973280790971, 0.17217832125491295, 0.6581680159052573, 0.5496119196746718, 0.3918991532919802, 0.4246602383829824, 0.3758155355103515, 0.19365460051212025, 0.18264527555281151, 0.42183405286579745, 0.24457029826311905, 0.2724294640107844, 0.20814834636980495, 0.5723370604968434, 0.20150119516536047, 0.1866217363676207, 0.18568451880804726, 0.18670077451278722, 0.1792453376440517, 0.18899730512256052, 0.2019618411317593, 0.20189933740584765, 0.1766540597467645, 0.19145436674001903, 0.07302006457304555, 0.07894132816754029, 0.06943357686431662, 0.08222309031842434, 0.07659232602949562, 0.07730782134372804, 0.0719982920023895, 0.06668153356818218, 0.07218534638100393]}, "mutation_prompt": null}
{"id": "381ef38d-035b-4650-8a4c-45cdd7bac504", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Standard DE population size scaling\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_prob = 0.3  # Probability of performing local search\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):  # Ensure at least one dimension is from mutant\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.01, 0.1)\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:  # Minimize\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                # Local search with a probability\n                if np.random.rand() < self.local_search_prob:\n                    local_candidate = self._local_search(population[i])\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "HybridDifferentialEvolution", "description": "A hybrid algorithm combining Differential Evolution and Local Search to efficiently explore and exploit the search space for global optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a244cd3f-eb28-42bf-a32b-4d44f079ed79", "metadata": {"aucs": [0.6114142209551812, 0.5322322411493297, 0.5369430876241068, 0.5774517316626574, 0.6245997861229118, 0.5891266220166977, 0.5593259725735618, 0.5687527748648598, 0.5643102639107673, 0.2951767234354773, 0.28332583043761084, 0.3136726485508349, 0.2846134351364241, 0.27468524779082015, 0.310043333142635, 0.2937624290223284, 0.27684693602465826, 0.30794818865505313, 0.10407272488589892, 0.10033319431780385, 0.10009239577651097, 0.10303142487419081, 0.10309386936535903, 0.10954681769299857, 0.12253752197861634, 0.11597473098381383, 0.10112593172243123, 0.09831000381076516, 0.08069074427506406, 0.09078858930168976, 0.09195246108385913, 0.10267430857204252, 0.09850483621219741, 0.10128327174430729, 0.08648363465045861, 0.09747417917515067, 0.9463491163314116, 0.9662875769733325, 0.923974465445904, 0.9570439027219089, 0.9157223634466837, 0.909676019202163, 0.9507824038002735, 0.9414365082748986, 0.8922644856357849, 0.23600098104952416, 0.25562692907507967, 0.251850449746567, 0.26543290253277696, 0.23823645908929758, 0.2454137075406817, 0.24769549260285872, 0.24580569428346377, 0.2592887473536599, 0.43467215151768235, 0.43108821549305, 0.4760794924471986, 0.5309272496232804, 0.4942420839993594, 0.4390807909423542, 0.5034969086623013, 0.5219839295999721, 0.44856117928123285, 0.16568769782639725, 0.14755223004932827, 0.20103808940388912, 0.1637882525777562, 0.18375768680575588, 0.1748325163379557, 0.14472448241799707, 0.18772423894214085, 0.20193162479565985, 0.13131953398834517, 0.23907010159985453, 0.12079931033724989, 0.19442928884826272, 0.20255234941521294, 0.18157060930266722, 0.16335789440505777, 0.16215947901404448, 0.15218735018551177, 0.11638020765869128, 0.12125454183780238, 0.10178264650076052, 0.14446799564442447, 0.09908843903934395, 0.10033313187855453, 0.1171659177410973, 0.08678438210344486, 0.12336154080100836, 0.23087652220101784, 0.19937685952214745, 0.21803708442057368, 0.23707611924408323, 0.19344852173736382, 0.24093356110615016, 0.2585556077061114, 0.2569764543760681, 0.2346086862458837, 0.016235517896165175, 0.021260391569981385, 0.029522151279046005, 0.03115304130222407, 0.02671315093986759, 0.026411361646530906, 0.023249744779409, 0.03342208652628831, 0.07611626932428917, 0.13151989684412202, 0.14863357016705592, 0.14241429345456658, 0.13817068586448733, 0.1372099540240077, 0.15028044138722185, 0.14537241762247521, 0.16566293464201298, 0.14842889048729213, 0.4307154040973843, 0.4435512946908935, 0.4544819686291335, 0.4509169688197001, 0.4332952709495055, 0.45018515963515526, 0.4758304342537166, 0.44898459084767206, 0.44155560618463807, 0.121286572850276, 0.10797634338112805, 0.10931969495567406, 0.10685386585272139, 0.10221404216583474, 0.11480925422768307, 0.10771029464192072, 0.1041074110216077, 0.10277885498196737, 0.16940512721330814, 0.1770902466938853, 0.18751577350228477, 0.18524137463388657, 0.20091127362963512, 0.2006930587641299, 0.19030574984305637, 0.1805229012941285, 0.18942831193586174, 0.2648939208022024, 0.2592966804266912, 0.25768508164619086, 0.24869150141054996, 0.24748457302135662, 0.25442970690493805, 0.26890176500120133, 0.27723999893500806, 0.26637334928443945, 0.18325860298984697, 0.19328408792366858, 0.18279122305112927, 0.18882838491143694, 0.18273403663408982, 0.19531755438536624, 0.20878598209139376, 0.19955478975440377, 0.20920533156238508, 0.18954026031488647, 0.16950503327630262, 0.1721755213239725, 0.1903538303234118, 0.17859787007795735, 0.16801916539698036, 0.21195355997600085, 0.19391644987895884, 0.17779839576445633, 0.18924414952236768, 0.18645054241676717, 0.1968618257213317, 0.18518795780196373, 0.1937842027148371, 0.18056909257476217, 0.1880484254915471, 0.19847149228289207, 0.1838160764067236, 0.16160912246038228, 0.3660104552596588, 0.1493326816768682, 0.4722973280790971, 0.17217832125491295, 0.6581680159052573, 0.5496119196746718, 0.3918991532919802, 0.4246602383829824, 0.3758155355103515, 0.19365460051212025, 0.18264527555281151, 0.42183405286579745, 0.24457029826311905, 0.2724294640107844, 0.20814834636980495, 0.5723370604968434, 0.20150119516536047, 0.1866217363676207, 0.18568451880804726, 0.18670077451278722, 0.1792453376440517, 0.18899730512256052, 0.2019618411317593, 0.20189933740584765, 0.1766540597467645, 0.19145436674001903, 0.07302006457304555, 0.07894132816754029, 0.06943357686431662, 0.08222309031842434, 0.07659232602949562, 0.07730782134372804, 0.0719982920023895, 0.06668153356818218, 0.07218534638100393]}, "mutation_prompt": null}
{"id": "382b9270-8cbb-4f4f-b4d9-faf63423a4a3", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Standard DE population size scaling\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_prob = 0.3  # Probability of performing local search\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):  # Ensure at least one dimension is from mutant\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.01, 0.1)\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:  # Minimize\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                # Local search with a probability\n                if np.random.rand() < self.local_search_prob:\n                    local_candidate = self._local_search(population[i])\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "HybridDifferentialEvolution", "description": "A hybrid algorithm combining Differential Evolution and Local Search to efficiently explore and exploit the search space for global optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a244cd3f-eb28-42bf-a32b-4d44f079ed79", "metadata": {"aucs": [0.6114142209551812, 0.5322322411493297, 0.5369430876241068, 0.5774517316626574, 0.6245997861229118, 0.5891266220166977, 0.5593259725735618, 0.5687527748648598, 0.5643102639107673, 0.2951767234354773, 0.28332583043761084, 0.3136726485508349, 0.2846134351364241, 0.27468524779082015, 0.310043333142635, 0.2937624290223284, 0.27684693602465826, 0.30794818865505313, 0.10407272488589892, 0.10033319431780385, 0.10009239577651097, 0.10303142487419081, 0.10309386936535903, 0.10954681769299857, 0.12253752197861634, 0.11597473098381383, 0.10112593172243123, 0.09831000381076516, 0.08069074427506406, 0.09078858930168976, 0.09195246108385913, 0.10267430857204252, 0.09850483621219741, 0.10128327174430729, 0.08648363465045861, 0.09747417917515067, 0.9463491163314116, 0.9662875769733325, 0.923974465445904, 0.9570439027219089, 0.9157223634466837, 0.909676019202163, 0.9507824038002735, 0.9414365082748986, 0.8922644856357849, 0.23600098104952416, 0.25562692907507967, 0.251850449746567, 0.26543290253277696, 0.23823645908929758, 0.2454137075406817, 0.24769549260285872, 0.24580569428346377, 0.2592887473536599, 0.43467215151768235, 0.43108821549305, 0.4760794924471986, 0.5309272496232804, 0.4942420839993594, 0.4390807909423542, 0.5034969086623013, 0.5219839295999721, 0.44856117928123285, 0.16568769782639725, 0.14755223004932827, 0.20103808940388912, 0.1637882525777562, 0.18375768680575588, 0.1748325163379557, 0.14472448241799707, 0.18772423894214085, 0.20193162479565985, 0.13131953398834517, 0.23907010159985453, 0.12079931033724989, 0.19442928884826272, 0.20255234941521294, 0.18157060930266722, 0.16335789440505777, 0.16215947901404448, 0.15218735018551177, 0.11638020765869128, 0.12125454183780238, 0.10178264650076052, 0.14446799564442447, 0.09908843903934395, 0.10033313187855453, 0.1171659177410973, 0.08678438210344486, 0.12336154080100836, 0.23087652220101784, 0.19937685952214745, 0.21803708442057368, 0.23707611924408323, 0.19344852173736382, 0.24093356110615016, 0.2585556077061114, 0.2569764543760681, 0.2346086862458837, 0.016235517896165175, 0.021260391569981385, 0.029522151279046005, 0.03115304130222407, 0.02671315093986759, 0.026411361646530906, 0.023249744779409, 0.03342208652628831, 0.07611626932428917, 0.13151989684412202, 0.14863357016705592, 0.14241429345456658, 0.13817068586448733, 0.1372099540240077, 0.15028044138722185, 0.14537241762247521, 0.16566293464201298, 0.14842889048729213, 0.4307154040973843, 0.4435512946908935, 0.4544819686291335, 0.4509169688197001, 0.4332952709495055, 0.45018515963515526, 0.4758304342537166, 0.44898459084767206, 0.44155560618463807, 0.121286572850276, 0.10797634338112805, 0.10931969495567406, 0.10685386585272139, 0.10221404216583474, 0.11480925422768307, 0.10771029464192072, 0.1041074110216077, 0.10277885498196737, 0.16940512721330814, 0.1770902466938853, 0.18751577350228477, 0.18524137463388657, 0.20091127362963512, 0.2006930587641299, 0.19030574984305637, 0.1805229012941285, 0.18942831193586174, 0.2648939208022024, 0.2592966804266912, 0.25768508164619086, 0.24869150141054996, 0.24748457302135662, 0.25442970690493805, 0.26890176500120133, 0.27723999893500806, 0.26637334928443945, 0.18325860298984697, 0.19328408792366858, 0.18279122305112927, 0.18882838491143694, 0.18273403663408982, 0.19531755438536624, 0.20878598209139376, 0.19955478975440377, 0.20920533156238508, 0.18954026031488647, 0.16950503327630262, 0.1721755213239725, 0.1903538303234118, 0.17859787007795735, 0.16801916539698036, 0.21195355997600085, 0.19391644987895884, 0.17779839576445633, 0.18924414952236768, 0.18645054241676717, 0.1968618257213317, 0.18518795780196373, 0.1937842027148371, 0.18056909257476217, 0.1880484254915471, 0.19847149228289207, 0.1838160764067236, 0.16160912246038228, 0.3660104552596588, 0.1493326816768682, 0.4722973280790971, 0.17217832125491295, 0.6581680159052573, 0.5496119196746718, 0.3918991532919802, 0.4246602383829824, 0.3758155355103515, 0.19365460051212025, 0.18264527555281151, 0.42183405286579745, 0.24457029826311905, 0.2724294640107844, 0.20814834636980495, 0.5723370604968434, 0.20150119516536047, 0.1866217363676207, 0.18568451880804726, 0.18670077451278722, 0.1792453376440517, 0.18899730512256052, 0.2019618411317593, 0.20189933740584765, 0.1766540597467645, 0.19145436674001903, 0.07302006457304555, 0.07894132816754029, 0.06943357686431662, 0.08222309031842434, 0.07659232602949562, 0.07730782134372804, 0.0719982920023895, 0.06668153356818218, 0.07218534638100393]}, "mutation_prompt": null}
{"id": "1b996a44-8948-4595-b96b-97f5d25efa08", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Standard DE population size scaling\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_prob = 0.3  # Probability of performing local search\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):  # Ensure at least one dimension is from mutant\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.01, 0.1)\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:  # Minimize\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                # Local search with a probability\n                if np.random.rand() < self.local_search_prob:\n                    local_candidate = self._local_search(population[i])\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "HybridDifferentialEvolution", "description": "A hybrid algorithm combining Differential Evolution and Local Search to efficiently explore and exploit the search space for global optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a244cd3f-eb28-42bf-a32b-4d44f079ed79", "metadata": {"aucs": [0.6114142209551812, 0.5322322411493297, 0.5369430876241068, 0.5774517316626574, 0.6245997861229118, 0.5891266220166977, 0.5593259725735618, 0.5687527748648598, 0.5643102639107673, 0.2951767234354773, 0.28332583043761084, 0.3136726485508349, 0.2846134351364241, 0.27468524779082015, 0.310043333142635, 0.2937624290223284, 0.27684693602465826, 0.30794818865505313, 0.10407272488589892, 0.10033319431780385, 0.10009239577651097, 0.10303142487419081, 0.10309386936535903, 0.10954681769299857, 0.12253752197861634, 0.11597473098381383, 0.10112593172243123, 0.09831000381076516, 0.08069074427506406, 0.09078858930168976, 0.09195246108385913, 0.10267430857204252, 0.09850483621219741, 0.10128327174430729, 0.08648363465045861, 0.09747417917515067, 0.9463491163314116, 0.9662875769733325, 0.923974465445904, 0.9570439027219089, 0.9157223634466837, 0.909676019202163, 0.9507824038002735, 0.9414365082748986, 0.8922644856357849, 0.23600098104952416, 0.25562692907507967, 0.251850449746567, 0.26543290253277696, 0.23823645908929758, 0.2454137075406817, 0.24769549260285872, 0.24580569428346377, 0.2592887473536599, 0.43467215151768235, 0.43108821549305, 0.4760794924471986, 0.5309272496232804, 0.4942420839993594, 0.4390807909423542, 0.5034969086623013, 0.5219839295999721, 0.44856117928123285, 0.16568769782639725, 0.14755223004932827, 0.20103808940388912, 0.1637882525777562, 0.18375768680575588, 0.1748325163379557, 0.14472448241799707, 0.18772423894214085, 0.20193162479565985, 0.13131953398834517, 0.23907010159985453, 0.12079931033724989, 0.19442928884826272, 0.20255234941521294, 0.18157060930266722, 0.16335789440505777, 0.16215947901404448, 0.15218735018551177, 0.11638020765869128, 0.12125454183780238, 0.10178264650076052, 0.14446799564442447, 0.09908843903934395, 0.10033313187855453, 0.1171659177410973, 0.08678438210344486, 0.12336154080100836, 0.23087652220101784, 0.19937685952214745, 0.21803708442057368, 0.23707611924408323, 0.19344852173736382, 0.24093356110615016, 0.2585556077061114, 0.2569764543760681, 0.2346086862458837, 0.016235517896165175, 0.021260391569981385, 0.029522151279046005, 0.03115304130222407, 0.02671315093986759, 0.026411361646530906, 0.023249744779409, 0.03342208652628831, 0.07611626932428917, 0.13151989684412202, 0.14863357016705592, 0.14241429345456658, 0.13817068586448733, 0.1372099540240077, 0.15028044138722185, 0.14537241762247521, 0.16566293464201298, 0.14842889048729213, 0.4307154040973843, 0.4435512946908935, 0.4544819686291335, 0.4509169688197001, 0.4332952709495055, 0.45018515963515526, 0.4758304342537166, 0.44898459084767206, 0.44155560618463807, 0.121286572850276, 0.10797634338112805, 0.10931969495567406, 0.10685386585272139, 0.10221404216583474, 0.11480925422768307, 0.10771029464192072, 0.1041074110216077, 0.10277885498196737, 0.16940512721330814, 0.1770902466938853, 0.18751577350228477, 0.18524137463388657, 0.20091127362963512, 0.2006930587641299, 0.19030574984305637, 0.1805229012941285, 0.18942831193586174, 0.2648939208022024, 0.2592966804266912, 0.25768508164619086, 0.24869150141054996, 0.24748457302135662, 0.25442970690493805, 0.26890176500120133, 0.27723999893500806, 0.26637334928443945, 0.18325860298984697, 0.19328408792366858, 0.18279122305112927, 0.18882838491143694, 0.18273403663408982, 0.19531755438536624, 0.20878598209139376, 0.19955478975440377, 0.20920533156238508, 0.18954026031488647, 0.16950503327630262, 0.1721755213239725, 0.1903538303234118, 0.17859787007795735, 0.16801916539698036, 0.21195355997600085, 0.19391644987895884, 0.17779839576445633, 0.18924414952236768, 0.18645054241676717, 0.1968618257213317, 0.18518795780196373, 0.1937842027148371, 0.18056909257476217, 0.1880484254915471, 0.19847149228289207, 0.1838160764067236, 0.16160912246038228, 0.3660104552596588, 0.1493326816768682, 0.4722973280790971, 0.17217832125491295, 0.6581680159052573, 0.5496119196746718, 0.3918991532919802, 0.4246602383829824, 0.3758155355103515, 0.19365460051212025, 0.18264527555281151, 0.42183405286579745, 0.24457029826311905, 0.2724294640107844, 0.20814834636980495, 0.5723370604968434, 0.20150119516536047, 0.1866217363676207, 0.18568451880804726, 0.18670077451278722, 0.1792453376440517, 0.18899730512256052, 0.2019618411317593, 0.20189933740584765, 0.1766540597467645, 0.19145436674001903, 0.07302006457304555, 0.07894132816754029, 0.06943357686431662, 0.08222309031842434, 0.07659232602949562, 0.07730782134372804, 0.0719982920023895, 0.06668153356818218, 0.07218534638100393]}, "mutation_prompt": null}
{"id": "61e39c98-f3b4-4f96-a369-d0e9f1d61352", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Standard DE population size scaling\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_prob = 0.3  # Probability of performing local search\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):  # Ensure at least one dimension is from mutant\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.01, 0.1)\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:  # Minimize\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                # Local search with a probability\n                if np.random.rand() < self.local_search_prob:\n                    local_candidate = self._local_search(population[i])\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "HybridDifferentialEvolution", "description": "A hybrid algorithm combining Differential Evolution and Local Search to efficiently explore and exploit the search space for global optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a244cd3f-eb28-42bf-a32b-4d44f079ed79", "metadata": {"aucs": [0.6114142209551812, 0.5322322411493297, 0.5369430876241068, 0.5774517316626574, 0.6245997861229118, 0.5891266220166977, 0.5593259725735618, 0.5687527748648598, 0.5643102639107673, 0.2951767234354773, 0.28332583043761084, 0.3136726485508349, 0.2846134351364241, 0.27468524779082015, 0.310043333142635, 0.2937624290223284, 0.27684693602465826, 0.30794818865505313, 0.10407272488589892, 0.10033319431780385, 0.10009239577651097, 0.10303142487419081, 0.10309386936535903, 0.10954681769299857, 0.12253752197861634, 0.11597473098381383, 0.10112593172243123, 0.09831000381076516, 0.08069074427506406, 0.09078858930168976, 0.09195246108385913, 0.10267430857204252, 0.09850483621219741, 0.10128327174430729, 0.08648363465045861, 0.09747417917515067, 0.9463491163314116, 0.9662875769733325, 0.923974465445904, 0.9570439027219089, 0.9157223634466837, 0.909676019202163, 0.9507824038002735, 0.9414365082748986, 0.8922644856357849, 0.23600098104952416, 0.25562692907507967, 0.251850449746567, 0.26543290253277696, 0.23823645908929758, 0.2454137075406817, 0.24769549260285872, 0.24580569428346377, 0.2592887473536599, 0.43467215151768235, 0.43108821549305, 0.4760794924471986, 0.5309272496232804, 0.4942420839993594, 0.4390807909423542, 0.5034969086623013, 0.5219839295999721, 0.44856117928123285, 0.16568769782639725, 0.14755223004932827, 0.20103808940388912, 0.1637882525777562, 0.18375768680575588, 0.1748325163379557, 0.14472448241799707, 0.18772423894214085, 0.20193162479565985, 0.13131953398834517, 0.23907010159985453, 0.12079931033724989, 0.19442928884826272, 0.20255234941521294, 0.18157060930266722, 0.16335789440505777, 0.16215947901404448, 0.15218735018551177, 0.11638020765869128, 0.12125454183780238, 0.10178264650076052, 0.14446799564442447, 0.09908843903934395, 0.10033313187855453, 0.1171659177410973, 0.08678438210344486, 0.12336154080100836, 0.23087652220101784, 0.19937685952214745, 0.21803708442057368, 0.23707611924408323, 0.19344852173736382, 0.24093356110615016, 0.2585556077061114, 0.2569764543760681, 0.2346086862458837, 0.016235517896165175, 0.021260391569981385, 0.029522151279046005, 0.03115304130222407, 0.02671315093986759, 0.026411361646530906, 0.023249744779409, 0.03342208652628831, 0.07611626932428917, 0.13151989684412202, 0.14863357016705592, 0.14241429345456658, 0.13817068586448733, 0.1372099540240077, 0.15028044138722185, 0.14537241762247521, 0.16566293464201298, 0.14842889048729213, 0.4307154040973843, 0.4435512946908935, 0.4544819686291335, 0.4509169688197001, 0.4332952709495055, 0.45018515963515526, 0.4758304342537166, 0.44898459084767206, 0.44155560618463807, 0.121286572850276, 0.10797634338112805, 0.10931969495567406, 0.10685386585272139, 0.10221404216583474, 0.11480925422768307, 0.10771029464192072, 0.1041074110216077, 0.10277885498196737, 0.16940512721330814, 0.1770902466938853, 0.18751577350228477, 0.18524137463388657, 0.20091127362963512, 0.2006930587641299, 0.19030574984305637, 0.1805229012941285, 0.18942831193586174, 0.2648939208022024, 0.2592966804266912, 0.25768508164619086, 0.24869150141054996, 0.24748457302135662, 0.25442970690493805, 0.26890176500120133, 0.27723999893500806, 0.26637334928443945, 0.18325860298984697, 0.19328408792366858, 0.18279122305112927, 0.18882838491143694, 0.18273403663408982, 0.19531755438536624, 0.20878598209139376, 0.19955478975440377, 0.20920533156238508, 0.18954026031488647, 0.16950503327630262, 0.1721755213239725, 0.1903538303234118, 0.17859787007795735, 0.16801916539698036, 0.21195355997600085, 0.19391644987895884, 0.17779839576445633, 0.18924414952236768, 0.18645054241676717, 0.1968618257213317, 0.18518795780196373, 0.1937842027148371, 0.18056909257476217, 0.1880484254915471, 0.19847149228289207, 0.1838160764067236, 0.16160912246038228, 0.3660104552596588, 0.1493326816768682, 0.4722973280790971, 0.17217832125491295, 0.6581680159052573, 0.5496119196746718, 0.3918991532919802, 0.4246602383829824, 0.3758155355103515, 0.19365460051212025, 0.18264527555281151, 0.42183405286579745, 0.24457029826311905, 0.2724294640107844, 0.20814834636980495, 0.5723370604968434, 0.20150119516536047, 0.1866217363676207, 0.18568451880804726, 0.18670077451278722, 0.1792453376440517, 0.18899730512256052, 0.2019618411317593, 0.20189933740584765, 0.1766540597467645, 0.19145436674001903, 0.07302006457304555, 0.07894132816754029, 0.06943357686431662, 0.08222309031842434, 0.07659232602949562, 0.07730782134372804, 0.0719982920023895, 0.06668153356818218, 0.07218534638100393]}, "mutation_prompt": null}
{"id": "3c2ed6f4-7258-46e3-b294-8078b784d900", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Standard DE population size scaling\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_prob = 0.3  # Probability of performing local search\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):  # Ensure at least one dimension is from mutant\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.01, 0.1)\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:  # Minimize\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                # Local search with a probability\n                if np.random.rand() < self.local_search_prob:\n                    local_candidate = self._local_search(population[i])\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "HybridDifferentialEvolution", "description": "A hybrid algorithm combining Differential Evolution and Local Search to efficiently explore and exploit the search space for global optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a244cd3f-eb28-42bf-a32b-4d44f079ed79", "metadata": {"aucs": [0.6114142209551812, 0.5322322411493297, 0.5369430876241068, 0.5774517316626574, 0.6245997861229118, 0.5891266220166977, 0.5593259725735618, 0.5687527748648598, 0.5643102639107673, 0.2951767234354773, 0.28332583043761084, 0.3136726485508349, 0.2846134351364241, 0.27468524779082015, 0.310043333142635, 0.2937624290223284, 0.27684693602465826, 0.30794818865505313, 0.10407272488589892, 0.10033319431780385, 0.10009239577651097, 0.10303142487419081, 0.10309386936535903, 0.10954681769299857, 0.12253752197861634, 0.11597473098381383, 0.10112593172243123, 0.09831000381076516, 0.08069074427506406, 0.09078858930168976, 0.09195246108385913, 0.10267430857204252, 0.09850483621219741, 0.10128327174430729, 0.08648363465045861, 0.09747417917515067, 0.9463491163314116, 0.9662875769733325, 0.923974465445904, 0.9570439027219089, 0.9157223634466837, 0.909676019202163, 0.9507824038002735, 0.9414365082748986, 0.8922644856357849, 0.23600098104952416, 0.25562692907507967, 0.251850449746567, 0.26543290253277696, 0.23823645908929758, 0.2454137075406817, 0.24769549260285872, 0.24580569428346377, 0.2592887473536599, 0.43467215151768235, 0.43108821549305, 0.4760794924471986, 0.5309272496232804, 0.4942420839993594, 0.4390807909423542, 0.5034969086623013, 0.5219839295999721, 0.44856117928123285, 0.16568769782639725, 0.14755223004932827, 0.20103808940388912, 0.1637882525777562, 0.18375768680575588, 0.1748325163379557, 0.14472448241799707, 0.18772423894214085, 0.20193162479565985, 0.13131953398834517, 0.23907010159985453, 0.12079931033724989, 0.19442928884826272, 0.20255234941521294, 0.18157060930266722, 0.16335789440505777, 0.16215947901404448, 0.15218735018551177, 0.11638020765869128, 0.12125454183780238, 0.10178264650076052, 0.14446799564442447, 0.09908843903934395, 0.10033313187855453, 0.1171659177410973, 0.08678438210344486, 0.12336154080100836, 0.23087652220101784, 0.19937685952214745, 0.21803708442057368, 0.23707611924408323, 0.19344852173736382, 0.24093356110615016, 0.2585556077061114, 0.2569764543760681, 0.2346086862458837, 0.016235517896165175, 0.021260391569981385, 0.029522151279046005, 0.03115304130222407, 0.02671315093986759, 0.026411361646530906, 0.023249744779409, 0.03342208652628831, 0.07611626932428917, 0.13151989684412202, 0.14863357016705592, 0.14241429345456658, 0.13817068586448733, 0.1372099540240077, 0.15028044138722185, 0.14537241762247521, 0.16566293464201298, 0.14842889048729213, 0.4307154040973843, 0.4435512946908935, 0.4544819686291335, 0.4509169688197001, 0.4332952709495055, 0.45018515963515526, 0.4758304342537166, 0.44898459084767206, 0.44155560618463807, 0.121286572850276, 0.10797634338112805, 0.10931969495567406, 0.10685386585272139, 0.10221404216583474, 0.11480925422768307, 0.10771029464192072, 0.1041074110216077, 0.10277885498196737, 0.16940512721330814, 0.1770902466938853, 0.18751577350228477, 0.18524137463388657, 0.20091127362963512, 0.2006930587641299, 0.19030574984305637, 0.1805229012941285, 0.18942831193586174, 0.2648939208022024, 0.2592966804266912, 0.25768508164619086, 0.24869150141054996, 0.24748457302135662, 0.25442970690493805, 0.26890176500120133, 0.27723999893500806, 0.26637334928443945, 0.18325860298984697, 0.19328408792366858, 0.18279122305112927, 0.18882838491143694, 0.18273403663408982, 0.19531755438536624, 0.20878598209139376, 0.19955478975440377, 0.20920533156238508, 0.18954026031488647, 0.16950503327630262, 0.1721755213239725, 0.1903538303234118, 0.17859787007795735, 0.16801916539698036, 0.21195355997600085, 0.19391644987895884, 0.17779839576445633, 0.18924414952236768, 0.18645054241676717, 0.1968618257213317, 0.18518795780196373, 0.1937842027148371, 0.18056909257476217, 0.1880484254915471, 0.19847149228289207, 0.1838160764067236, 0.16160912246038228, 0.3660104552596588, 0.1493326816768682, 0.4722973280790971, 0.17217832125491295, 0.6581680159052573, 0.5496119196746718, 0.3918991532919802, 0.4246602383829824, 0.3758155355103515, 0.19365460051212025, 0.18264527555281151, 0.42183405286579745, 0.24457029826311905, 0.2724294640107844, 0.20814834636980495, 0.5723370604968434, 0.20150119516536047, 0.1866217363676207, 0.18568451880804726, 0.18670077451278722, 0.1792453376440517, 0.18899730512256052, 0.2019618411317593, 0.20189933740584765, 0.1766540597467645, 0.19145436674001903, 0.07302006457304555, 0.07894132816754029, 0.06943357686431662, 0.08222309031842434, 0.07659232602949562, 0.07730782134372804, 0.0719982920023895, 0.06668153356818218, 0.07218534638100393]}, "mutation_prompt": null}
{"id": "fbdfce14-f539-4685-a74f-30aa07e2b7a3", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Standard DE population size scaling\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_prob = 0.3  # Probability of performing local search\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):  # Ensure at least one dimension is from mutant\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.01, 0.1)\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:  # Minimize\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                # Local search with a probability\n                if np.random.rand() < self.local_search_prob:\n                    local_candidate = self._local_search(population[i])\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "HybridDifferentialEvolution", "description": "A hybrid algorithm combining Differential Evolution and Local Search to efficiently explore and exploit the search space for global optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a244cd3f-eb28-42bf-a32b-4d44f079ed79", "metadata": {"aucs": [0.6114142209551812, 0.5322322411493297, 0.5369430876241068, 0.5774517316626574, 0.6245997861229118, 0.5891266220166977, 0.5593259725735618, 0.5687527748648598, 0.5643102639107673, 0.2951767234354773, 0.28332583043761084, 0.3136726485508349, 0.2846134351364241, 0.27468524779082015, 0.310043333142635, 0.2937624290223284, 0.27684693602465826, 0.30794818865505313, 0.10407272488589892, 0.10033319431780385, 0.10009239577651097, 0.10303142487419081, 0.10309386936535903, 0.10954681769299857, 0.12253752197861634, 0.11597473098381383, 0.10112593172243123, 0.09831000381076516, 0.08069074427506406, 0.09078858930168976, 0.09195246108385913, 0.10267430857204252, 0.09850483621219741, 0.10128327174430729, 0.08648363465045861, 0.09747417917515067, 0.9463491163314116, 0.9662875769733325, 0.923974465445904, 0.9570439027219089, 0.9157223634466837, 0.909676019202163, 0.9507824038002735, 0.9414365082748986, 0.8922644856357849, 0.23600098104952416, 0.25562692907507967, 0.251850449746567, 0.26543290253277696, 0.23823645908929758, 0.2454137075406817, 0.24769549260285872, 0.24580569428346377, 0.2592887473536599, 0.43467215151768235, 0.43108821549305, 0.4760794924471986, 0.5309272496232804, 0.4942420839993594, 0.4390807909423542, 0.5034969086623013, 0.5219839295999721, 0.44856117928123285, 0.16568769782639725, 0.14755223004932827, 0.20103808940388912, 0.1637882525777562, 0.18375768680575588, 0.1748325163379557, 0.14472448241799707, 0.18772423894214085, 0.20193162479565985, 0.13131953398834517, 0.23907010159985453, 0.12079931033724989, 0.19442928884826272, 0.20255234941521294, 0.18157060930266722, 0.16335789440505777, 0.16215947901404448, 0.15218735018551177, 0.11638020765869128, 0.12125454183780238, 0.10178264650076052, 0.14446799564442447, 0.09908843903934395, 0.10033313187855453, 0.1171659177410973, 0.08678438210344486, 0.12336154080100836, 0.23087652220101784, 0.19937685952214745, 0.21803708442057368, 0.23707611924408323, 0.19344852173736382, 0.24093356110615016, 0.2585556077061114, 0.2569764543760681, 0.2346086862458837, 0.016235517896165175, 0.021260391569981385, 0.029522151279046005, 0.03115304130222407, 0.02671315093986759, 0.026411361646530906, 0.023249744779409, 0.03342208652628831, 0.07611626932428917, 0.13151989684412202, 0.14863357016705592, 0.14241429345456658, 0.13817068586448733, 0.1372099540240077, 0.15028044138722185, 0.14537241762247521, 0.16566293464201298, 0.14842889048729213, 0.4307154040973843, 0.4435512946908935, 0.4544819686291335, 0.4509169688197001, 0.4332952709495055, 0.45018515963515526, 0.4758304342537166, 0.44898459084767206, 0.44155560618463807, 0.121286572850276, 0.10797634338112805, 0.10931969495567406, 0.10685386585272139, 0.10221404216583474, 0.11480925422768307, 0.10771029464192072, 0.1041074110216077, 0.10277885498196737, 0.16940512721330814, 0.1770902466938853, 0.18751577350228477, 0.18524137463388657, 0.20091127362963512, 0.2006930587641299, 0.19030574984305637, 0.1805229012941285, 0.18942831193586174, 0.2648939208022024, 0.2592966804266912, 0.25768508164619086, 0.24869150141054996, 0.24748457302135662, 0.25442970690493805, 0.26890176500120133, 0.27723999893500806, 0.26637334928443945, 0.18325860298984697, 0.19328408792366858, 0.18279122305112927, 0.18882838491143694, 0.18273403663408982, 0.19531755438536624, 0.20878598209139376, 0.19955478975440377, 0.20920533156238508, 0.18954026031488647, 0.16950503327630262, 0.1721755213239725, 0.1903538303234118, 0.17859787007795735, 0.16801916539698036, 0.21195355997600085, 0.19391644987895884, 0.17779839576445633, 0.18924414952236768, 0.18645054241676717, 0.1968618257213317, 0.18518795780196373, 0.1937842027148371, 0.18056909257476217, 0.1880484254915471, 0.19847149228289207, 0.1838160764067236, 0.16160912246038228, 0.3660104552596588, 0.1493326816768682, 0.4722973280790971, 0.17217832125491295, 0.6581680159052573, 0.5496119196746718, 0.3918991532919802, 0.4246602383829824, 0.3758155355103515, 0.19365460051212025, 0.18264527555281151, 0.42183405286579745, 0.24457029826311905, 0.2724294640107844, 0.20814834636980495, 0.5723370604968434, 0.20150119516536047, 0.1866217363676207, 0.18568451880804726, 0.18670077451278722, 0.1792453376440517, 0.18899730512256052, 0.2019618411317593, 0.20189933740584765, 0.1766540597467645, 0.19145436674001903, 0.07302006457304555, 0.07894132816754029, 0.06943357686431662, 0.08222309031842434, 0.07659232602949562, 0.07730782134372804, 0.0719982920023895, 0.06668153356818218, 0.07218534638100393]}, "mutation_prompt": null}
{"id": "13acd308-4218-4d5b-ab7a-21a29ca87dc1", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Standard DE population size scaling\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_prob = 0.3  # Probability of performing local search\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):  # Ensure at least one dimension is from mutant\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.01, 0.1)\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:  # Minimize\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                # Local search with a probability\n                if np.random.rand() < self.local_search_prob:\n                    local_candidate = self._local_search(population[i])\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "HybridDifferentialEvolution", "description": "A hybrid algorithm combining Differential Evolution and Local Search to efficiently explore and exploit the search space for global optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a244cd3f-eb28-42bf-a32b-4d44f079ed79", "metadata": {"aucs": [0.6114142209551812, 0.5322322411493297, 0.5369430876241068, 0.5774517316626574, 0.6245997861229118, 0.5891266220166977, 0.5593259725735618, 0.5687527748648598, 0.5643102639107673, 0.2951767234354773, 0.28332583043761084, 0.3136726485508349, 0.2846134351364241, 0.27468524779082015, 0.310043333142635, 0.2937624290223284, 0.27684693602465826, 0.30794818865505313, 0.10407272488589892, 0.10033319431780385, 0.10009239577651097, 0.10303142487419081, 0.10309386936535903, 0.10954681769299857, 0.12253752197861634, 0.11597473098381383, 0.10112593172243123, 0.09831000381076516, 0.08069074427506406, 0.09078858930168976, 0.09195246108385913, 0.10267430857204252, 0.09850483621219741, 0.10128327174430729, 0.08648363465045861, 0.09747417917515067, 0.9463491163314116, 0.9662875769733325, 0.923974465445904, 0.9570439027219089, 0.9157223634466837, 0.909676019202163, 0.9507824038002735, 0.9414365082748986, 0.8922644856357849, 0.23600098104952416, 0.25562692907507967, 0.251850449746567, 0.26543290253277696, 0.23823645908929758, 0.2454137075406817, 0.24769549260285872, 0.24580569428346377, 0.2592887473536599, 0.43467215151768235, 0.43108821549305, 0.4760794924471986, 0.5309272496232804, 0.4942420839993594, 0.4390807909423542, 0.5034969086623013, 0.5219839295999721, 0.44856117928123285, 0.16568769782639725, 0.14755223004932827, 0.20103808940388912, 0.1637882525777562, 0.18375768680575588, 0.1748325163379557, 0.14472448241799707, 0.18772423894214085, 0.20193162479565985, 0.13131953398834517, 0.23907010159985453, 0.12079931033724989, 0.19442928884826272, 0.20255234941521294, 0.18157060930266722, 0.16335789440505777, 0.16215947901404448, 0.15218735018551177, 0.11638020765869128, 0.12125454183780238, 0.10178264650076052, 0.14446799564442447, 0.09908843903934395, 0.10033313187855453, 0.1171659177410973, 0.08678438210344486, 0.12336154080100836, 0.23087652220101784, 0.19937685952214745, 0.21803708442057368, 0.23707611924408323, 0.19344852173736382, 0.24093356110615016, 0.2585556077061114, 0.2569764543760681, 0.2346086862458837, 0.016235517896165175, 0.021260391569981385, 0.029522151279046005, 0.03115304130222407, 0.02671315093986759, 0.026411361646530906, 0.023249744779409, 0.03342208652628831, 0.07611626932428917, 0.13151989684412202, 0.14863357016705592, 0.14241429345456658, 0.13817068586448733, 0.1372099540240077, 0.15028044138722185, 0.14537241762247521, 0.16566293464201298, 0.14842889048729213, 0.4307154040973843, 0.4435512946908935, 0.4544819686291335, 0.4509169688197001, 0.4332952709495055, 0.45018515963515526, 0.4758304342537166, 0.44898459084767206, 0.44155560618463807, 0.121286572850276, 0.10797634338112805, 0.10931969495567406, 0.10685386585272139, 0.10221404216583474, 0.11480925422768307, 0.10771029464192072, 0.1041074110216077, 0.10277885498196737, 0.16940512721330814, 0.1770902466938853, 0.18751577350228477, 0.18524137463388657, 0.20091127362963512, 0.2006930587641299, 0.19030574984305637, 0.1805229012941285, 0.18942831193586174, 0.2648939208022024, 0.2592966804266912, 0.25768508164619086, 0.24869150141054996, 0.24748457302135662, 0.25442970690493805, 0.26890176500120133, 0.27723999893500806, 0.26637334928443945, 0.18325860298984697, 0.19328408792366858, 0.18279122305112927, 0.18882838491143694, 0.18273403663408982, 0.19531755438536624, 0.20878598209139376, 0.19955478975440377, 0.20920533156238508, 0.18954026031488647, 0.16950503327630262, 0.1721755213239725, 0.1903538303234118, 0.17859787007795735, 0.16801916539698036, 0.21195355997600085, 0.19391644987895884, 0.17779839576445633, 0.18924414952236768, 0.18645054241676717, 0.1968618257213317, 0.18518795780196373, 0.1937842027148371, 0.18056909257476217, 0.1880484254915471, 0.19847149228289207, 0.1838160764067236, 0.16160912246038228, 0.3660104552596588, 0.1493326816768682, 0.4722973280790971, 0.17217832125491295, 0.6581680159052573, 0.5496119196746718, 0.3918991532919802, 0.4246602383829824, 0.3758155355103515, 0.19365460051212025, 0.18264527555281151, 0.42183405286579745, 0.24457029826311905, 0.2724294640107844, 0.20814834636980495, 0.5723370604968434, 0.20150119516536047, 0.1866217363676207, 0.18568451880804726, 0.18670077451278722, 0.1792453376440517, 0.18899730512256052, 0.2019618411317593, 0.20189933740584765, 0.1766540597467645, 0.19145436674001903, 0.07302006457304555, 0.07894132816754029, 0.06943357686431662, 0.08222309031842434, 0.07659232602949562, 0.07730782134372804, 0.0719982920023895, 0.06668153356818218, 0.07218534638100393]}, "mutation_prompt": null}
{"id": "fdddb8a1-fd74-4614-83ae-947d53e7cddc", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Standard DE population size scaling\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_prob = 0.3  # Probability of performing local search\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):  # Ensure at least one dimension is from mutant\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.01, 0.1)\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:  # Minimize\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                # Local search with a probability\n                if np.random.rand() < self.local_search_prob:\n                    local_candidate = self._local_search(population[i])\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "HybridDifferentialEvolution", "description": "A hybrid algorithm combining Differential Evolution and Local Search to efficiently explore and exploit the search space for global optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a244cd3f-eb28-42bf-a32b-4d44f079ed79", "metadata": {"aucs": [0.6114142209551812, 0.5322322411493297, 0.5369430876241068, 0.5774517316626574, 0.6245997861229118, 0.5891266220166977, 0.5593259725735618, 0.5687527748648598, 0.5643102639107673, 0.2951767234354773, 0.28332583043761084, 0.3136726485508349, 0.2846134351364241, 0.27468524779082015, 0.310043333142635, 0.2937624290223284, 0.27684693602465826, 0.30794818865505313, 0.10407272488589892, 0.10033319431780385, 0.10009239577651097, 0.10303142487419081, 0.10309386936535903, 0.10954681769299857, 0.12253752197861634, 0.11597473098381383, 0.10112593172243123, 0.09831000381076516, 0.08069074427506406, 0.09078858930168976, 0.09195246108385913, 0.10267430857204252, 0.09850483621219741, 0.10128327174430729, 0.08648363465045861, 0.09747417917515067, 0.9463491163314116, 0.9662875769733325, 0.923974465445904, 0.9570439027219089, 0.9157223634466837, 0.909676019202163, 0.9507824038002735, 0.9414365082748986, 0.8922644856357849, 0.23600098104952416, 0.25562692907507967, 0.251850449746567, 0.26543290253277696, 0.23823645908929758, 0.2454137075406817, 0.24769549260285872, 0.24580569428346377, 0.2592887473536599, 0.43467215151768235, 0.43108821549305, 0.4760794924471986, 0.5309272496232804, 0.4942420839993594, 0.4390807909423542, 0.5034969086623013, 0.5219839295999721, 0.44856117928123285, 0.16568769782639725, 0.14755223004932827, 0.20103808940388912, 0.1637882525777562, 0.18375768680575588, 0.1748325163379557, 0.14472448241799707, 0.18772423894214085, 0.20193162479565985, 0.13131953398834517, 0.23907010159985453, 0.12079931033724989, 0.19442928884826272, 0.20255234941521294, 0.18157060930266722, 0.16335789440505777, 0.16215947901404448, 0.15218735018551177, 0.11638020765869128, 0.12125454183780238, 0.10178264650076052, 0.14446799564442447, 0.09908843903934395, 0.10033313187855453, 0.1171659177410973, 0.08678438210344486, 0.12336154080100836, 0.23087652220101784, 0.19937685952214745, 0.21803708442057368, 0.23707611924408323, 0.19344852173736382, 0.24093356110615016, 0.2585556077061114, 0.2569764543760681, 0.2346086862458837, 0.016235517896165175, 0.021260391569981385, 0.029522151279046005, 0.03115304130222407, 0.02671315093986759, 0.026411361646530906, 0.023249744779409, 0.03342208652628831, 0.07611626932428917, 0.13151989684412202, 0.14863357016705592, 0.14241429345456658, 0.13817068586448733, 0.1372099540240077, 0.15028044138722185, 0.14537241762247521, 0.16566293464201298, 0.14842889048729213, 0.4307154040973843, 0.4435512946908935, 0.4544819686291335, 0.4509169688197001, 0.4332952709495055, 0.45018515963515526, 0.4758304342537166, 0.44898459084767206, 0.44155560618463807, 0.121286572850276, 0.10797634338112805, 0.10931969495567406, 0.10685386585272139, 0.10221404216583474, 0.11480925422768307, 0.10771029464192072, 0.1041074110216077, 0.10277885498196737, 0.16940512721330814, 0.1770902466938853, 0.18751577350228477, 0.18524137463388657, 0.20091127362963512, 0.2006930587641299, 0.19030574984305637, 0.1805229012941285, 0.18942831193586174, 0.2648939208022024, 0.2592966804266912, 0.25768508164619086, 0.24869150141054996, 0.24748457302135662, 0.25442970690493805, 0.26890176500120133, 0.27723999893500806, 0.26637334928443945, 0.18325860298984697, 0.19328408792366858, 0.18279122305112927, 0.18882838491143694, 0.18273403663408982, 0.19531755438536624, 0.20878598209139376, 0.19955478975440377, 0.20920533156238508, 0.18954026031488647, 0.16950503327630262, 0.1721755213239725, 0.1903538303234118, 0.17859787007795735, 0.16801916539698036, 0.21195355997600085, 0.19391644987895884, 0.17779839576445633, 0.18924414952236768, 0.18645054241676717, 0.1968618257213317, 0.18518795780196373, 0.1937842027148371, 0.18056909257476217, 0.1880484254915471, 0.19847149228289207, 0.1838160764067236, 0.16160912246038228, 0.3660104552596588, 0.1493326816768682, 0.4722973280790971, 0.17217832125491295, 0.6581680159052573, 0.5496119196746718, 0.3918991532919802, 0.4246602383829824, 0.3758155355103515, 0.19365460051212025, 0.18264527555281151, 0.42183405286579745, 0.24457029826311905, 0.2724294640107844, 0.20814834636980495, 0.5723370604968434, 0.20150119516536047, 0.1866217363676207, 0.18568451880804726, 0.18670077451278722, 0.1792453376440517, 0.18899730512256052, 0.2019618411317593, 0.20189933740584765, 0.1766540597467645, 0.19145436674001903, 0.07302006457304555, 0.07894132816754029, 0.06943357686431662, 0.08222309031842434, 0.07659232602949562, 0.07730782134372804, 0.0719982920023895, 0.06668153356818218, 0.07218534638100393]}, "mutation_prompt": null}
{"id": "5eb3021f-36cc-467f-95ae-7f80c10d54ee", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Standard DE population size scaling\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_prob = 0.3  # Probability of performing local search\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):  # Ensure at least one dimension is from mutant\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.01, 0.1)\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:  # Minimize\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                # Local search with a probability\n                if np.random.rand() < self.local_search_prob:\n                    local_candidate = self._local_search(population[i])\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "HybridDifferentialEvolution", "description": "A hybrid algorithm combining Differential Evolution and Local Search to efficiently explore and exploit the search space for global optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a244cd3f-eb28-42bf-a32b-4d44f079ed79", "metadata": {"aucs": [0.6114142209551812, 0.5322322411493297, 0.5369430876241068, 0.5774517316626574, 0.6245997861229118, 0.5891266220166977, 0.5593259725735618, 0.5687527748648598, 0.5643102639107673, 0.2951767234354773, 0.28332583043761084, 0.3136726485508349, 0.2846134351364241, 0.27468524779082015, 0.310043333142635, 0.2937624290223284, 0.27684693602465826, 0.30794818865505313, 0.10407272488589892, 0.10033319431780385, 0.10009239577651097, 0.10303142487419081, 0.10309386936535903, 0.10954681769299857, 0.12253752197861634, 0.11597473098381383, 0.10112593172243123, 0.09831000381076516, 0.08069074427506406, 0.09078858930168976, 0.09195246108385913, 0.10267430857204252, 0.09850483621219741, 0.10128327174430729, 0.08648363465045861, 0.09747417917515067, 0.9463491163314116, 0.9662875769733325, 0.923974465445904, 0.9570439027219089, 0.9157223634466837, 0.909676019202163, 0.9507824038002735, 0.9414365082748986, 0.8922644856357849, 0.23600098104952416, 0.25562692907507967, 0.251850449746567, 0.26543290253277696, 0.23823645908929758, 0.2454137075406817, 0.24769549260285872, 0.24580569428346377, 0.2592887473536599, 0.43467215151768235, 0.43108821549305, 0.4760794924471986, 0.5309272496232804, 0.4942420839993594, 0.4390807909423542, 0.5034969086623013, 0.5219839295999721, 0.44856117928123285, 0.16568769782639725, 0.14755223004932827, 0.20103808940388912, 0.1637882525777562, 0.18375768680575588, 0.1748325163379557, 0.14472448241799707, 0.18772423894214085, 0.20193162479565985, 0.13131953398834517, 0.23907010159985453, 0.12079931033724989, 0.19442928884826272, 0.20255234941521294, 0.18157060930266722, 0.16335789440505777, 0.16215947901404448, 0.15218735018551177, 0.11638020765869128, 0.12125454183780238, 0.10178264650076052, 0.14446799564442447, 0.09908843903934395, 0.10033313187855453, 0.1171659177410973, 0.08678438210344486, 0.12336154080100836, 0.23087652220101784, 0.19937685952214745, 0.21803708442057368, 0.23707611924408323, 0.19344852173736382, 0.24093356110615016, 0.2585556077061114, 0.2569764543760681, 0.2346086862458837, 0.016235517896165175, 0.021260391569981385, 0.029522151279046005, 0.03115304130222407, 0.02671315093986759, 0.026411361646530906, 0.023249744779409, 0.03342208652628831, 0.07611626932428917, 0.13151989684412202, 0.14863357016705592, 0.14241429345456658, 0.13817068586448733, 0.1372099540240077, 0.15028044138722185, 0.14537241762247521, 0.16566293464201298, 0.14842889048729213, 0.4307154040973843, 0.4435512946908935, 0.4544819686291335, 0.4509169688197001, 0.4332952709495055, 0.45018515963515526, 0.4758304342537166, 0.44898459084767206, 0.44155560618463807, 0.121286572850276, 0.10797634338112805, 0.10931969495567406, 0.10685386585272139, 0.10221404216583474, 0.11480925422768307, 0.10771029464192072, 0.1041074110216077, 0.10277885498196737, 0.16940512721330814, 0.1770902466938853, 0.18751577350228477, 0.18524137463388657, 0.20091127362963512, 0.2006930587641299, 0.19030574984305637, 0.1805229012941285, 0.18942831193586174, 0.2648939208022024, 0.2592966804266912, 0.25768508164619086, 0.24869150141054996, 0.24748457302135662, 0.25442970690493805, 0.26890176500120133, 0.27723999893500806, 0.26637334928443945, 0.18325860298984697, 0.19328408792366858, 0.18279122305112927, 0.18882838491143694, 0.18273403663408982, 0.19531755438536624, 0.20878598209139376, 0.19955478975440377, 0.20920533156238508, 0.18954026031488647, 0.16950503327630262, 0.1721755213239725, 0.1903538303234118, 0.17859787007795735, 0.16801916539698036, 0.21195355997600085, 0.19391644987895884, 0.17779839576445633, 0.18924414952236768, 0.18645054241676717, 0.1968618257213317, 0.18518795780196373, 0.1937842027148371, 0.18056909257476217, 0.1880484254915471, 0.19847149228289207, 0.1838160764067236, 0.16160912246038228, 0.3660104552596588, 0.1493326816768682, 0.4722973280790971, 0.17217832125491295, 0.6581680159052573, 0.5496119196746718, 0.3918991532919802, 0.4246602383829824, 0.3758155355103515, 0.19365460051212025, 0.18264527555281151, 0.42183405286579745, 0.24457029826311905, 0.2724294640107844, 0.20814834636980495, 0.5723370604968434, 0.20150119516536047, 0.1866217363676207, 0.18568451880804726, 0.18670077451278722, 0.1792453376440517, 0.18899730512256052, 0.2019618411317593, 0.20189933740584765, 0.1766540597467645, 0.19145436674001903, 0.07302006457304555, 0.07894132816754029, 0.06943357686431662, 0.08222309031842434, 0.07659232602949562, 0.07730782134372804, 0.0719982920023895, 0.06668153356818218, 0.07218534638100393]}, "mutation_prompt": null}
{"id": "601dd998-d74b-49aa-a6a0-f29a8db01732", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Standard DE population size scaling\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_prob = 0.3  # Probability of performing local search\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):  # Ensure at least one dimension is from mutant\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.01, 0.1)\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:  # Minimize\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                # Local search with a probability\n                if np.random.rand() < self.local_search_prob:\n                    local_candidate = self._local_search(population[i])\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "HybridDifferentialEvolution", "description": "A hybrid algorithm combining Differential Evolution and Local Search to efficiently explore and exploit the search space for global optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a244cd3f-eb28-42bf-a32b-4d44f079ed79", "metadata": {"aucs": [0.6114142209551812, 0.5322322411493297, 0.5369430876241068, 0.5774517316626574, 0.6245997861229118, 0.5891266220166977, 0.5593259725735618, 0.5687527748648598, 0.5643102639107673, 0.2951767234354773, 0.28332583043761084, 0.3136726485508349, 0.2846134351364241, 0.27468524779082015, 0.310043333142635, 0.2937624290223284, 0.27684693602465826, 0.30794818865505313, 0.10407272488589892, 0.10033319431780385, 0.10009239577651097, 0.10303142487419081, 0.10309386936535903, 0.10954681769299857, 0.12253752197861634, 0.11597473098381383, 0.10112593172243123, 0.09831000381076516, 0.08069074427506406, 0.09078858930168976, 0.09195246108385913, 0.10267430857204252, 0.09850483621219741, 0.10128327174430729, 0.08648363465045861, 0.09747417917515067, 0.9463491163314116, 0.9662875769733325, 0.923974465445904, 0.9570439027219089, 0.9157223634466837, 0.909676019202163, 0.9507824038002735, 0.9414365082748986, 0.8922644856357849, 0.23600098104952416, 0.25562692907507967, 0.251850449746567, 0.26543290253277696, 0.23823645908929758, 0.2454137075406817, 0.24769549260285872, 0.24580569428346377, 0.2592887473536599, 0.43467215151768235, 0.43108821549305, 0.4760794924471986, 0.5309272496232804, 0.4942420839993594, 0.4390807909423542, 0.5034969086623013, 0.5219839295999721, 0.44856117928123285, 0.16568769782639725, 0.14755223004932827, 0.20103808940388912, 0.1637882525777562, 0.18375768680575588, 0.1748325163379557, 0.14472448241799707, 0.18772423894214085, 0.20193162479565985, 0.13131953398834517, 0.23907010159985453, 0.12079931033724989, 0.19442928884826272, 0.20255234941521294, 0.18157060930266722, 0.16335789440505777, 0.16215947901404448, 0.15218735018551177, 0.11638020765869128, 0.12125454183780238, 0.10178264650076052, 0.14446799564442447, 0.09908843903934395, 0.10033313187855453, 0.1171659177410973, 0.08678438210344486, 0.12336154080100836, 0.23087652220101784, 0.19937685952214745, 0.21803708442057368, 0.23707611924408323, 0.19344852173736382, 0.24093356110615016, 0.2585556077061114, 0.2569764543760681, 0.2346086862458837, 0.016235517896165175, 0.021260391569981385, 0.029522151279046005, 0.03115304130222407, 0.02671315093986759, 0.026411361646530906, 0.023249744779409, 0.03342208652628831, 0.07611626932428917, 0.13151989684412202, 0.14863357016705592, 0.14241429345456658, 0.13817068586448733, 0.1372099540240077, 0.15028044138722185, 0.14537241762247521, 0.16566293464201298, 0.14842889048729213, 0.4307154040973843, 0.4435512946908935, 0.4544819686291335, 0.4509169688197001, 0.4332952709495055, 0.45018515963515526, 0.4758304342537166, 0.44898459084767206, 0.44155560618463807, 0.121286572850276, 0.10797634338112805, 0.10931969495567406, 0.10685386585272139, 0.10221404216583474, 0.11480925422768307, 0.10771029464192072, 0.1041074110216077, 0.10277885498196737, 0.16940512721330814, 0.1770902466938853, 0.18751577350228477, 0.18524137463388657, 0.20091127362963512, 0.2006930587641299, 0.19030574984305637, 0.1805229012941285, 0.18942831193586174, 0.2648939208022024, 0.2592966804266912, 0.25768508164619086, 0.24869150141054996, 0.24748457302135662, 0.25442970690493805, 0.26890176500120133, 0.27723999893500806, 0.26637334928443945, 0.18325860298984697, 0.19328408792366858, 0.18279122305112927, 0.18882838491143694, 0.18273403663408982, 0.19531755438536624, 0.20878598209139376, 0.19955478975440377, 0.20920533156238508, 0.18954026031488647, 0.16950503327630262, 0.1721755213239725, 0.1903538303234118, 0.17859787007795735, 0.16801916539698036, 0.21195355997600085, 0.19391644987895884, 0.17779839576445633, 0.18924414952236768, 0.18645054241676717, 0.1968618257213317, 0.18518795780196373, 0.1937842027148371, 0.18056909257476217, 0.1880484254915471, 0.19847149228289207, 0.1838160764067236, 0.16160912246038228, 0.3660104552596588, 0.1493326816768682, 0.4722973280790971, 0.17217832125491295, 0.6581680159052573, 0.5496119196746718, 0.3918991532919802, 0.4246602383829824, 0.3758155355103515, 0.19365460051212025, 0.18264527555281151, 0.42183405286579745, 0.24457029826311905, 0.2724294640107844, 0.20814834636980495, 0.5723370604968434, 0.20150119516536047, 0.1866217363676207, 0.18568451880804726, 0.18670077451278722, 0.1792453376440517, 0.18899730512256052, 0.2019618411317593, 0.20189933740584765, 0.1766540597467645, 0.19145436674001903, 0.07302006457304555, 0.07894132816754029, 0.06943357686431662, 0.08222309031842434, 0.07659232602949562, 0.07730782134372804, 0.0719982920023895, 0.06668153356818218, 0.07218534638100393]}, "mutation_prompt": null}
{"id": "571ec9fe-2537-4cdc-846f-adb0c6a5ad80", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Standard DE population size scaling\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_prob = 0.3  # Probability of performing local search\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):  # Ensure at least one dimension is from mutant\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.01, 0.1)\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:  # Minimize\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                # Local search with a probability\n                if np.random.rand() < self.local_search_prob:\n                    local_candidate = self._local_search(population[i])\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "HybridDifferentialEvolution", "description": "A hybrid algorithm combining Differential Evolution and Local Search to efficiently explore and exploit the search space for global optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a244cd3f-eb28-42bf-a32b-4d44f079ed79", "metadata": {"aucs": [0.6114142209551812, 0.5322322411493297, 0.5369430876241068, 0.5774517316626574, 0.6245997861229118, 0.5891266220166977, 0.5593259725735618, 0.5687527748648598, 0.5643102639107673, 0.2951767234354773, 0.28332583043761084, 0.3136726485508349, 0.2846134351364241, 0.27468524779082015, 0.310043333142635, 0.2937624290223284, 0.27684693602465826, 0.30794818865505313, 0.10407272488589892, 0.10033319431780385, 0.10009239577651097, 0.10303142487419081, 0.10309386936535903, 0.10954681769299857, 0.12253752197861634, 0.11597473098381383, 0.10112593172243123, 0.09831000381076516, 0.08069074427506406, 0.09078858930168976, 0.09195246108385913, 0.10267430857204252, 0.09850483621219741, 0.10128327174430729, 0.08648363465045861, 0.09747417917515067, 0.9463491163314116, 0.9662875769733325, 0.923974465445904, 0.9570439027219089, 0.9157223634466837, 0.909676019202163, 0.9507824038002735, 0.9414365082748986, 0.8922644856357849, 0.23600098104952416, 0.25562692907507967, 0.251850449746567, 0.26543290253277696, 0.23823645908929758, 0.2454137075406817, 0.24769549260285872, 0.24580569428346377, 0.2592887473536599, 0.43467215151768235, 0.43108821549305, 0.4760794924471986, 0.5309272496232804, 0.4942420839993594, 0.4390807909423542, 0.5034969086623013, 0.5219839295999721, 0.44856117928123285, 0.16568769782639725, 0.14755223004932827, 0.20103808940388912, 0.1637882525777562, 0.18375768680575588, 0.1748325163379557, 0.14472448241799707, 0.18772423894214085, 0.20193162479565985, 0.13131953398834517, 0.23907010159985453, 0.12079931033724989, 0.19442928884826272, 0.20255234941521294, 0.18157060930266722, 0.16335789440505777, 0.16215947901404448, 0.15218735018551177, 0.11638020765869128, 0.12125454183780238, 0.10178264650076052, 0.14446799564442447, 0.09908843903934395, 0.10033313187855453, 0.1171659177410973, 0.08678438210344486, 0.12336154080100836, 0.23087652220101784, 0.19937685952214745, 0.21803708442057368, 0.23707611924408323, 0.19344852173736382, 0.24093356110615016, 0.2585556077061114, 0.2569764543760681, 0.2346086862458837, 0.016235517896165175, 0.021260391569981385, 0.029522151279046005, 0.03115304130222407, 0.02671315093986759, 0.026411361646530906, 0.023249744779409, 0.03342208652628831, 0.07611626932428917, 0.13151989684412202, 0.14863357016705592, 0.14241429345456658, 0.13817068586448733, 0.1372099540240077, 0.15028044138722185, 0.14537241762247521, 0.16566293464201298, 0.14842889048729213, 0.4307154040973843, 0.4435512946908935, 0.4544819686291335, 0.4509169688197001, 0.4332952709495055, 0.45018515963515526, 0.4758304342537166, 0.44898459084767206, 0.44155560618463807, 0.121286572850276, 0.10797634338112805, 0.10931969495567406, 0.10685386585272139, 0.10221404216583474, 0.11480925422768307, 0.10771029464192072, 0.1041074110216077, 0.10277885498196737, 0.16940512721330814, 0.1770902466938853, 0.18751577350228477, 0.18524137463388657, 0.20091127362963512, 0.2006930587641299, 0.19030574984305637, 0.1805229012941285, 0.18942831193586174, 0.2648939208022024, 0.2592966804266912, 0.25768508164619086, 0.24869150141054996, 0.24748457302135662, 0.25442970690493805, 0.26890176500120133, 0.27723999893500806, 0.26637334928443945, 0.18325860298984697, 0.19328408792366858, 0.18279122305112927, 0.18882838491143694, 0.18273403663408982, 0.19531755438536624, 0.20878598209139376, 0.19955478975440377, 0.20920533156238508, 0.18954026031488647, 0.16950503327630262, 0.1721755213239725, 0.1903538303234118, 0.17859787007795735, 0.16801916539698036, 0.21195355997600085, 0.19391644987895884, 0.17779839576445633, 0.18924414952236768, 0.18645054241676717, 0.1968618257213317, 0.18518795780196373, 0.1937842027148371, 0.18056909257476217, 0.1880484254915471, 0.19847149228289207, 0.1838160764067236, 0.16160912246038228, 0.3660104552596588, 0.1493326816768682, 0.4722973280790971, 0.17217832125491295, 0.6581680159052573, 0.5496119196746718, 0.3918991532919802, 0.4246602383829824, 0.3758155355103515, 0.19365460051212025, 0.18264527555281151, 0.42183405286579745, 0.24457029826311905, 0.2724294640107844, 0.20814834636980495, 0.5723370604968434, 0.20150119516536047, 0.1866217363676207, 0.18568451880804726, 0.18670077451278722, 0.1792453376440517, 0.18899730512256052, 0.2019618411317593, 0.20189933740584765, 0.1766540597467645, 0.19145436674001903, 0.07302006457304555, 0.07894132816754029, 0.06943357686431662, 0.08222309031842434, 0.07659232602949562, 0.07730782134372804, 0.0719982920023895, 0.06668153356818218, 0.07218534638100393]}, "mutation_prompt": null}
{"id": "d63c5ef7-82d1-496d-ba14-f3566830b6ba", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Reduced initial differential weight\n        self.CR = 0.5  # Reduced initial crossover probability\n        self.local_search_prob = 0.3\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        direction = np.random.normal(0, 1, self.dim)\n        adaptive_step_size = np.clip(0.01 + np.std(individual) / 10, 0.01, 0.1)  # Adaptive step size\n        new_individual = np.clip(individual + adaptive_step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                self.F = 0.5 + 0.3 * (1 - evals / self.budget)  # Adaptive F\n                self.CR = 0.5 + 0.4 * (evals / self.budget)  # Adaptive CR\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    local_candidate = self._local_search(population[i])\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "HybridDifferentialEvolution", "description": "Improve exploration and convergence by introducing adaptive parameters in differential evolution and local search mechanisms.", "configspace": "", "generation": 19, "fitness": 0.24023173502695733, "feedback": "The algorithm HybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.20.", "error": "", "parent_id": "a244cd3f-eb28-42bf-a32b-4d44f079ed79", "metadata": {"aucs": [0.6558395592484624, 0.6371661787311484, 0.6584145440983107, 0.6586302960735562, 0.6528223823333154, 0.6621994053289075, 0.6538066747893754, 0.6638051566818172, 0.6416927754484729, 0.43022158322374227, 0.3798922661776549, 0.43784448351719163, 0.40177434249110167, 0.43836729143880804, 0.3988605879873153, 0.46890486893773653, 0.3953004570343117, 0.40321106148009633, 0.12455525606261397, 0.10657548120473226, 0.12074770939991397, 0.12357209721275608, 0.11351202522616588, 0.12447492218255307, 0.13831466691295824, 0.12412263822557146, 0.12102598399379949, 0.10769199026724052, 0.11026931441489829, 0.0988193586978725, 0.11241718247678478, 0.10831423035359022, 0.11297104797740598, 0.10056962659444257, 0.10504048228927299, 0.11012254263306043, 0.9367819596328824, 0.9433715096075175, 0.9354684793284198, 0.9264590679092152, 0.9407904021567627, 0.9308911409390703, 0.9628064028062095, 0.9577078644405992, 0.9564712301976507, 0.2445854814924714, 0.235323677173775, 0.23380125039400823, 0.22996153605917813, 0.24695386672956354, 0.23092798902744616, 0.22780768879449387, 0.24784771066534195, 0.24202663281114056, 0.2868758069566736, 0.3341592358829194, 0.3687078643125683, 0.4797084841790744, 0.3782838436692665, 0.3961520665848265, 0.33180958685309514, 0.3696874759471168, 0.4677830016906215, 0.15904966968681633, 0.1620568457353303, 0.1431182233345475, 0.15023667036870647, 0.14109874799096156, 0.13912437980147696, 0.1554810915976852, 0.16348895279170972, 0.1600503206433176, 0.09161048013014661, 0.0938530972057553, 0.10400343214667396, 0.18401748180214317, 0.1340964990896819, 0.16876085512562078, 0.13731586256930128, 0.12704230047805098, 0.14809599981418087, 0.04053782571886222, 0.03534028843373638, 0.01949317513433868, 0.02489105625857424, 0.03275362360557288, 0.032967533061098786, 0.024926829633262093, 0.029816551757603893, 0.05367537602387751, 0.13924700322091121, 0.15777205595708854, 0.12321368331901106, 0.14590714046039155, 0.11775504559856109, 0.12845554817562754, 0.1482720919262145, 0.1454231810485751, 0.12326644955286736, 0.007088857521512004, 0.011773034195031284, 0.009326358215246744, 0.009818220853418103, 0.007014851317833415, 0.013350459660598779, 0.009384889540313579, 0.019898742998601615, 0.026194219794927864, 0.10500366121000093, 0.10817407896765763, 0.11410199788755038, 0.12189852518475541, 0.1302815189272848, 0.1259371057765728, 0.10651969261072958, 0.10621863000727749, 0.11252203125707783, 0.44265861152311126, 0.43724463915675804, 0.44997698147197096, 0.44659803364566153, 0.4498002040203444, 0.4413465866554629, 0.453720521813334, 0.4379590432030783, 0.4663314143798717, 0.09808502213855386, 0.12042905023562611, 0.10179885166979763, 0.1014773021149471, 0.1054341159035499, 0.0894274704238005, 0.0902683277988956, 0.12143506199167897, 0.10702072711282473, 0.1775119789376527, 0.16655872357946377, 0.15661337697798772, 0.17713995103193114, 0.16234037722355954, 0.19015694566542174, 0.18879329355665941, 0.17864668701380726, 0.18412047867958603, 0.2558038251794317, 0.24483880645936584, 0.25610844571454494, 0.2602389773004634, 0.23323522218592685, 0.2439519745651545, 0.2849418998702584, 0.27596629550056195, 0.2645847189499858, 0.19419243407210218, 0.19733999048462703, 0.19377065122550707, 0.17069686349799118, 0.1852299807989437, 0.15657779534106975, 0.19474668917051718, 0.1906003412394317, 0.20657193919821037, 0.20096841996426884, 0.1805449378184365, 0.18240916847344257, 0.17499116205437382, 0.18358135499404593, 0.18629253314836391, 0.19674275003375474, 0.1826829422386519, 0.18887640140217332, 0.19054491581353172, 0.2092373929386414, 0.18269709075894303, 0.18975220564179607, 0.18581432185541558, 0.18683437588050333, 0.19383545378046507, 0.18108380241638167, 0.2098997133342253, 0.31242597739645217, 0.2579646130392024, 0.29676214001367496, 0.3008850627241777, 0.19519053513776696, 0.202448175001679, 0.284571963189136, 0.274770519141196, 0.25935945692160534, 0.3707762083791877, 0.19110723262354268, 0.2662057525041287, 0.26946156151359135, 0.1883665753090863, 0.29721089276250034, 0.20059162015489007, 0.19741468162274045, 0.19990275354749998, 0.191264074123644, 0.19482968914657384, 0.21465859498901396, 0.18091969090876037, 0.19290159980991461, 0.1860032852794894, 0.19342206085498737, 0.2019152317204297, 0.1755829698033502, 0.07440045859441347, 0.07562393636299225, 0.08639678487780278, 0.07289118786715776, 0.07457272660860548, 0.0673947893433211, 0.06733859345491222, 0.07637363920757856, 0.06332618814739821]}, "mutation_prompt": null}
{"id": "fd7239a8-124f-4da2-9bed-d9289348f2d0", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Standard DE population size scaling\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_prob = 0.3  # Probability of performing local search\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):  # Ensure at least one dimension is from mutant\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.01, 0.1)\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:  # Minimize\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                # Local search with a probability\n                if np.random.rand() < self.local_search_prob:\n                    local_candidate = self._local_search(population[i])\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "HybridDifferentialEvolution", "description": "A hybrid algorithm combining Differential Evolution and Local Search to efficiently explore and exploit the search space for global optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a244cd3f-eb28-42bf-a32b-4d44f079ed79", "metadata": {"aucs": [0.6114142209551812, 0.5322322411493297, 0.5369430876241068, 0.5774517316626574, 0.6245997861229118, 0.5891266220166977, 0.5593259725735618, 0.5687527748648598, 0.5643102639107673, 0.2951767234354773, 0.28332583043761084, 0.3136726485508349, 0.2846134351364241, 0.27468524779082015, 0.310043333142635, 0.2937624290223284, 0.27684693602465826, 0.30794818865505313, 0.10407272488589892, 0.10033319431780385, 0.10009239577651097, 0.10303142487419081, 0.10309386936535903, 0.10954681769299857, 0.12253752197861634, 0.11597473098381383, 0.10112593172243123, 0.09831000381076516, 0.08069074427506406, 0.09078858930168976, 0.09195246108385913, 0.10267430857204252, 0.09850483621219741, 0.10128327174430729, 0.08648363465045861, 0.09747417917515067, 0.9463491163314116, 0.9662875769733325, 0.923974465445904, 0.9570439027219089, 0.9157223634466837, 0.909676019202163, 0.9507824038002735, 0.9414365082748986, 0.8922644856357849, 0.23600098104952416, 0.25562692907507967, 0.251850449746567, 0.26543290253277696, 0.23823645908929758, 0.2454137075406817, 0.24769549260285872, 0.24580569428346377, 0.2592887473536599, 0.43467215151768235, 0.43108821549305, 0.4760794924471986, 0.5309272496232804, 0.4942420839993594, 0.4390807909423542, 0.5034969086623013, 0.5219839295999721, 0.44856117928123285, 0.16568769782639725, 0.14755223004932827, 0.20103808940388912, 0.1637882525777562, 0.18375768680575588, 0.1748325163379557, 0.14472448241799707, 0.18772423894214085, 0.20193162479565985, 0.13131953398834517, 0.23907010159985453, 0.12079931033724989, 0.19442928884826272, 0.20255234941521294, 0.18157060930266722, 0.16335789440505777, 0.16215947901404448, 0.15218735018551177, 0.11638020765869128, 0.12125454183780238, 0.10178264650076052, 0.14446799564442447, 0.09908843903934395, 0.10033313187855453, 0.1171659177410973, 0.08678438210344486, 0.12336154080100836, 0.23087652220101784, 0.19937685952214745, 0.21803708442057368, 0.23707611924408323, 0.19344852173736382, 0.24093356110615016, 0.2585556077061114, 0.2569764543760681, 0.2346086862458837, 0.016235517896165175, 0.021260391569981385, 0.029522151279046005, 0.03115304130222407, 0.02671315093986759, 0.026411361646530906, 0.023249744779409, 0.03342208652628831, 0.07611626932428917, 0.13151989684412202, 0.14863357016705592, 0.14241429345456658, 0.13817068586448733, 0.1372099540240077, 0.15028044138722185, 0.14537241762247521, 0.16566293464201298, 0.14842889048729213, 0.4307154040973843, 0.4435512946908935, 0.4544819686291335, 0.4509169688197001, 0.4332952709495055, 0.45018515963515526, 0.4758304342537166, 0.44898459084767206, 0.44155560618463807, 0.121286572850276, 0.10797634338112805, 0.10931969495567406, 0.10685386585272139, 0.10221404216583474, 0.11480925422768307, 0.10771029464192072, 0.1041074110216077, 0.10277885498196737, 0.16940512721330814, 0.1770902466938853, 0.18751577350228477, 0.18524137463388657, 0.20091127362963512, 0.2006930587641299, 0.19030574984305637, 0.1805229012941285, 0.18942831193586174, 0.2648939208022024, 0.2592966804266912, 0.25768508164619086, 0.24869150141054996, 0.24748457302135662, 0.25442970690493805, 0.26890176500120133, 0.27723999893500806, 0.26637334928443945, 0.18325860298984697, 0.19328408792366858, 0.18279122305112927, 0.18882838491143694, 0.18273403663408982, 0.19531755438536624, 0.20878598209139376, 0.19955478975440377, 0.20920533156238508, 0.18954026031488647, 0.16950503327630262, 0.1721755213239725, 0.1903538303234118, 0.17859787007795735, 0.16801916539698036, 0.21195355997600085, 0.19391644987895884, 0.17779839576445633, 0.18924414952236768, 0.18645054241676717, 0.1968618257213317, 0.18518795780196373, 0.1937842027148371, 0.18056909257476217, 0.1880484254915471, 0.19847149228289207, 0.1838160764067236, 0.16160912246038228, 0.3660104552596588, 0.1493326816768682, 0.4722973280790971, 0.17217832125491295, 0.6581680159052573, 0.5496119196746718, 0.3918991532919802, 0.4246602383829824, 0.3758155355103515, 0.19365460051212025, 0.18264527555281151, 0.42183405286579745, 0.24457029826311905, 0.2724294640107844, 0.20814834636980495, 0.5723370604968434, 0.20150119516536047, 0.1866217363676207, 0.18568451880804726, 0.18670077451278722, 0.1792453376440517, 0.18899730512256052, 0.2019618411317593, 0.20189933740584765, 0.1766540597467645, 0.19145436674001903, 0.07302006457304555, 0.07894132816754029, 0.06943357686431662, 0.08222309031842434, 0.07659232602949562, 0.07730782134372804, 0.0719982920023895, 0.06668153356818218, 0.07218534638100393]}, "mutation_prompt": null}
{"id": "1ccfb722-0098-44af-b1f3-f9f965a11343", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Standard DE population size scaling\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_prob = 0.3  # Probability of performing local search\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):  # Ensure at least one dimension is from mutant\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.01, 0.1)\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:  # Minimize\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                # Local search with a probability\n                if np.random.rand() < self.local_search_prob:\n                    local_candidate = self._local_search(population[i])\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "HybridDifferentialEvolution", "description": "A hybrid algorithm combining Differential Evolution and Local Search to efficiently explore and exploit the search space for global optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a244cd3f-eb28-42bf-a32b-4d44f079ed79", "metadata": {"aucs": [0.6114142209551812, 0.5322322411493297, 0.5369430876241068, 0.5774517316626574, 0.6245997861229118, 0.5891266220166977, 0.5593259725735618, 0.5687527748648598, 0.5643102639107673, 0.2951767234354773, 0.28332583043761084, 0.3136726485508349, 0.2846134351364241, 0.27468524779082015, 0.310043333142635, 0.2937624290223284, 0.27684693602465826, 0.30794818865505313, 0.10407272488589892, 0.10033319431780385, 0.10009239577651097, 0.10303142487419081, 0.10309386936535903, 0.10954681769299857, 0.12253752197861634, 0.11597473098381383, 0.10112593172243123, 0.09831000381076516, 0.08069074427506406, 0.09078858930168976, 0.09195246108385913, 0.10267430857204252, 0.09850483621219741, 0.10128327174430729, 0.08648363465045861, 0.09747417917515067, 0.9463491163314116, 0.9662875769733325, 0.923974465445904, 0.9570439027219089, 0.9157223634466837, 0.909676019202163, 0.9507824038002735, 0.9414365082748986, 0.8922644856357849, 0.23600098104952416, 0.25562692907507967, 0.251850449746567, 0.26543290253277696, 0.23823645908929758, 0.2454137075406817, 0.24769549260285872, 0.24580569428346377, 0.2592887473536599, 0.43467215151768235, 0.43108821549305, 0.4760794924471986, 0.5309272496232804, 0.4942420839993594, 0.4390807909423542, 0.5034969086623013, 0.5219839295999721, 0.44856117928123285, 0.16568769782639725, 0.14755223004932827, 0.20103808940388912, 0.1637882525777562, 0.18375768680575588, 0.1748325163379557, 0.14472448241799707, 0.18772423894214085, 0.20193162479565985, 0.13131953398834517, 0.23907010159985453, 0.12079931033724989, 0.19442928884826272, 0.20255234941521294, 0.18157060930266722, 0.16335789440505777, 0.16215947901404448, 0.15218735018551177, 0.11638020765869128, 0.12125454183780238, 0.10178264650076052, 0.14446799564442447, 0.09908843903934395, 0.10033313187855453, 0.1171659177410973, 0.08678438210344486, 0.12336154080100836, 0.23087652220101784, 0.19937685952214745, 0.21803708442057368, 0.23707611924408323, 0.19344852173736382, 0.24093356110615016, 0.2585556077061114, 0.2569764543760681, 0.2346086862458837, 0.016235517896165175, 0.021260391569981385, 0.029522151279046005, 0.03115304130222407, 0.02671315093986759, 0.026411361646530906, 0.023249744779409, 0.03342208652628831, 0.07611626932428917, 0.13151989684412202, 0.14863357016705592, 0.14241429345456658, 0.13817068586448733, 0.1372099540240077, 0.15028044138722185, 0.14537241762247521, 0.16566293464201298, 0.14842889048729213, 0.4307154040973843, 0.4435512946908935, 0.4544819686291335, 0.4509169688197001, 0.4332952709495055, 0.45018515963515526, 0.4758304342537166, 0.44898459084767206, 0.44155560618463807, 0.121286572850276, 0.10797634338112805, 0.10931969495567406, 0.10685386585272139, 0.10221404216583474, 0.11480925422768307, 0.10771029464192072, 0.1041074110216077, 0.10277885498196737, 0.16940512721330814, 0.1770902466938853, 0.18751577350228477, 0.18524137463388657, 0.20091127362963512, 0.2006930587641299, 0.19030574984305637, 0.1805229012941285, 0.18942831193586174, 0.2648939208022024, 0.2592966804266912, 0.25768508164619086, 0.24869150141054996, 0.24748457302135662, 0.25442970690493805, 0.26890176500120133, 0.27723999893500806, 0.26637334928443945, 0.18325860298984697, 0.19328408792366858, 0.18279122305112927, 0.18882838491143694, 0.18273403663408982, 0.19531755438536624, 0.20878598209139376, 0.19955478975440377, 0.20920533156238508, 0.18954026031488647, 0.16950503327630262, 0.1721755213239725, 0.1903538303234118, 0.17859787007795735, 0.16801916539698036, 0.21195355997600085, 0.19391644987895884, 0.17779839576445633, 0.18924414952236768, 0.18645054241676717, 0.1968618257213317, 0.18518795780196373, 0.1937842027148371, 0.18056909257476217, 0.1880484254915471, 0.19847149228289207, 0.1838160764067236, 0.16160912246038228, 0.3660104552596588, 0.1493326816768682, 0.4722973280790971, 0.17217832125491295, 0.6581680159052573, 0.5496119196746718, 0.3918991532919802, 0.4246602383829824, 0.3758155355103515, 0.19365460051212025, 0.18264527555281151, 0.42183405286579745, 0.24457029826311905, 0.2724294640107844, 0.20814834636980495, 0.5723370604968434, 0.20150119516536047, 0.1866217363676207, 0.18568451880804726, 0.18670077451278722, 0.1792453376440517, 0.18899730512256052, 0.2019618411317593, 0.20189933740584765, 0.1766540597467645, 0.19145436674001903, 0.07302006457304555, 0.07894132816754029, 0.06943357686431662, 0.08222309031842434, 0.07659232602949562, 0.07730782134372804, 0.0719982920023895, 0.06668153356818218, 0.07218534638100393]}, "mutation_prompt": null}
{"id": "f8a082f5-112f-48e1-8225-7fced4b01897", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Standard DE population size scaling\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_prob = 0.3  # Probability of performing local search\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):  # Ensure at least one dimension is from mutant\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.01, 0.1)\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:  # Minimize\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                # Local search with a probability\n                if np.random.rand() < self.local_search_prob:\n                    local_candidate = self._local_search(population[i])\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "HybridDifferentialEvolution", "description": "A hybrid algorithm combining Differential Evolution and Local Search to efficiently explore and exploit the search space for global optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a244cd3f-eb28-42bf-a32b-4d44f079ed79", "metadata": {"aucs": [0.6114142209551812, 0.5322322411493297, 0.5369430876241068, 0.5774517316626574, 0.6245997861229118, 0.5891266220166977, 0.5593259725735618, 0.5687527748648598, 0.5643102639107673, 0.2951767234354773, 0.28332583043761084, 0.3136726485508349, 0.2846134351364241, 0.27468524779082015, 0.310043333142635, 0.2937624290223284, 0.27684693602465826, 0.30794818865505313, 0.10407272488589892, 0.10033319431780385, 0.10009239577651097, 0.10303142487419081, 0.10309386936535903, 0.10954681769299857, 0.12253752197861634, 0.11597473098381383, 0.10112593172243123, 0.09831000381076516, 0.08069074427506406, 0.09078858930168976, 0.09195246108385913, 0.10267430857204252, 0.09850483621219741, 0.10128327174430729, 0.08648363465045861, 0.09747417917515067, 0.9463491163314116, 0.9662875769733325, 0.923974465445904, 0.9570439027219089, 0.9157223634466837, 0.909676019202163, 0.9507824038002735, 0.9414365082748986, 0.8922644856357849, 0.23600098104952416, 0.25562692907507967, 0.251850449746567, 0.26543290253277696, 0.23823645908929758, 0.2454137075406817, 0.24769549260285872, 0.24580569428346377, 0.2592887473536599, 0.43467215151768235, 0.43108821549305, 0.4760794924471986, 0.5309272496232804, 0.4942420839993594, 0.4390807909423542, 0.5034969086623013, 0.5219839295999721, 0.44856117928123285, 0.16568769782639725, 0.14755223004932827, 0.20103808940388912, 0.1637882525777562, 0.18375768680575588, 0.1748325163379557, 0.14472448241799707, 0.18772423894214085, 0.20193162479565985, 0.13131953398834517, 0.23907010159985453, 0.12079931033724989, 0.19442928884826272, 0.20255234941521294, 0.18157060930266722, 0.16335789440505777, 0.16215947901404448, 0.15218735018551177, 0.11638020765869128, 0.12125454183780238, 0.10178264650076052, 0.14446799564442447, 0.09908843903934395, 0.10033313187855453, 0.1171659177410973, 0.08678438210344486, 0.12336154080100836, 0.23087652220101784, 0.19937685952214745, 0.21803708442057368, 0.23707611924408323, 0.19344852173736382, 0.24093356110615016, 0.2585556077061114, 0.2569764543760681, 0.2346086862458837, 0.016235517896165175, 0.021260391569981385, 0.029522151279046005, 0.03115304130222407, 0.02671315093986759, 0.026411361646530906, 0.023249744779409, 0.03342208652628831, 0.07611626932428917, 0.13151989684412202, 0.14863357016705592, 0.14241429345456658, 0.13817068586448733, 0.1372099540240077, 0.15028044138722185, 0.14537241762247521, 0.16566293464201298, 0.14842889048729213, 0.4307154040973843, 0.4435512946908935, 0.4544819686291335, 0.4509169688197001, 0.4332952709495055, 0.45018515963515526, 0.4758304342537166, 0.44898459084767206, 0.44155560618463807, 0.121286572850276, 0.10797634338112805, 0.10931969495567406, 0.10685386585272139, 0.10221404216583474, 0.11480925422768307, 0.10771029464192072, 0.1041074110216077, 0.10277885498196737, 0.16940512721330814, 0.1770902466938853, 0.18751577350228477, 0.18524137463388657, 0.20091127362963512, 0.2006930587641299, 0.19030574984305637, 0.1805229012941285, 0.18942831193586174, 0.2648939208022024, 0.2592966804266912, 0.25768508164619086, 0.24869150141054996, 0.24748457302135662, 0.25442970690493805, 0.26890176500120133, 0.27723999893500806, 0.26637334928443945, 0.18325860298984697, 0.19328408792366858, 0.18279122305112927, 0.18882838491143694, 0.18273403663408982, 0.19531755438536624, 0.20878598209139376, 0.19955478975440377, 0.20920533156238508, 0.18954026031488647, 0.16950503327630262, 0.1721755213239725, 0.1903538303234118, 0.17859787007795735, 0.16801916539698036, 0.21195355997600085, 0.19391644987895884, 0.17779839576445633, 0.18924414952236768, 0.18645054241676717, 0.1968618257213317, 0.18518795780196373, 0.1937842027148371, 0.18056909257476217, 0.1880484254915471, 0.19847149228289207, 0.1838160764067236, 0.16160912246038228, 0.3660104552596588, 0.1493326816768682, 0.4722973280790971, 0.17217832125491295, 0.6581680159052573, 0.5496119196746718, 0.3918991532919802, 0.4246602383829824, 0.3758155355103515, 0.19365460051212025, 0.18264527555281151, 0.42183405286579745, 0.24457029826311905, 0.2724294640107844, 0.20814834636980495, 0.5723370604968434, 0.20150119516536047, 0.1866217363676207, 0.18568451880804726, 0.18670077451278722, 0.1792453376440517, 0.18899730512256052, 0.2019618411317593, 0.20189933740584765, 0.1766540597467645, 0.19145436674001903, 0.07302006457304555, 0.07894132816754029, 0.06943357686431662, 0.08222309031842434, 0.07659232602949562, 0.07730782134372804, 0.0719982920023895, 0.06668153356818218, 0.07218534638100393]}, "mutation_prompt": null}
{"id": "5f28aa71-310f-4384-b3cb-bec039a6274d", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim  # Increased population size for diverse exploration\n        self.F = 0.5  # Adaptive differential weight\n        self.CR = 0.85  # Lower crossover probability\n        self.local_search_prob = 0.4  # Increased probability of performing local search\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15)  # Adjusted step size for local search\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    local_candidate = self._local_search(population[i])\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "An enhanced hybrid algorithm utilizing adaptive Differential Evolution with occasional local search to optimize convergence across diverse functions.", "configspace": "", "generation": 23, "fitness": 0.2935797421347527, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.21.", "error": "", "parent_id": "a244cd3f-eb28-42bf-a32b-4d44f079ed79", "metadata": {"aucs": [0.6981563538069014, 0.686582960397212, 0.6959698878073168, 0.7204028067997494, 0.72421647471604, 0.7049087080836627, 0.7147050838113223, 0.6990777458791964, 0.7254395866067456, 0.44351652715716205, 0.49150730049168556, 0.47509612838711235, 0.4587739398833194, 0.4771102048155347, 0.4758421172122421, 0.46112528964825406, 0.43540451162869576, 0.4615144909611596, 0.1203433256371862, 0.1103859451845115, 0.120421238639424, 0.11383954662056972, 0.110745642305209, 0.15264477995270298, 0.12259318868938784, 0.12516556013820113, 0.1245490818677325, 0.11020388524407132, 0.10537948103595152, 0.10249211753271481, 0.10194281019370177, 0.10500315248179837, 0.10164045180970771, 0.10527391269952535, 0.10722334480475149, 0.1175386140957122, 0.8822372347830252, 0.8579934738208534, 0.9099920116930209, 0.8311504552360572, 0.8645446695585449, 0.8646076355992964, 0.8715298158650703, 0.9290076282021752, 0.9053085402486716, 0.33269418610266377, 0.31139217047121925, 0.29924446284852824, 0.3063118077870366, 0.31849002133187143, 0.33688268011185774, 0.35829515383696975, 0.32586794431593025, 0.30777524154033253, 0.6499067961650971, 0.6485783086003687, 0.5538396271597137, 0.7137051890327133, 0.6616343392599355, 0.5909988872698368, 0.6291095818199557, 0.5712787980552643, 0.5863517228419086, 0.20373626606238482, 0.20116672641695, 0.19786195060385658, 0.16296596714929235, 0.15423700941742735, 0.1844539283307246, 0.16882134361613876, 0.20031972923164132, 0.17655909213356535, 0.15315419601145475, 0.17029843600297967, 0.17074522887803578, 0.19113245904941956, 0.1500160130889039, 0.20447568025998997, 0.21367271550079192, 0.1919610594504645, 0.16109939886413216, 0.1487250994789896, 0.15582308061047512, 0.14652319805556557, 0.1462877946472303, 0.16588548477555054, 0.15495589345272542, 0.16116356582255653, 0.15144259046144526, 0.17503768385206664, 0.2908929784507853, 0.2858696981255586, 0.2653998464948113, 0.29205269110664367, 0.27507417231998077, 0.2679114905845903, 0.34007584166174976, 0.33632133540245646, 0.29354387009820726, 0.07128052640141647, 0.04079614198101389, 0.05262880288941818, 0.08076722223175115, 0.04360827028232839, 0.050204987827191516, 0.055783362216375254, 0.0800935695201257, 0.03762664939975624, 0.17359650682396421, 0.17927149123505637, 0.18054655079393211, 0.19995298038676868, 0.19145407097035938, 0.18874499220047747, 0.182112171740761, 0.20856279834568492, 0.17866851738587064, 0.5467967938073408, 0.5375122028782673, 0.5377341160521014, 0.5318327242853848, 0.5295521585194702, 0.5225184471881554, 0.5228395382391381, 0.5383002868151632, 0.5434737251439348, 0.10790560356911971, 0.0999791665444214, 0.10522447144311264, 0.12350027960812426, 0.12570118941556707, 0.10724560759952528, 0.10293921527060756, 0.10213393144000127, 0.10538785514764681, 0.1885238054567665, 0.159700339882343, 0.22078290499846498, 0.182977772003875, 0.1886763546649357, 0.16278492200673278, 0.17685390849314553, 0.15447676195251547, 0.20897466567755307, 0.30074203702052804, 0.3112950178850481, 0.31712812673948654, 0.28556623697457717, 0.3203540918213187, 0.3185355256988822, 0.3187920642977148, 0.34899845205913116, 0.3432762016572132, 0.24959868520536987, 0.23490929045284903, 0.23690403252100778, 0.2182127083736325, 0.21933729735911922, 0.228350254206525, 0.26791948115013586, 0.2633205461465703, 0.25404575515750594, 0.19389692668509506, 0.17896866752132223, 0.20798803883162753, 0.18454439320764426, 0.20293248394956076, 0.19418399047330392, 0.19681927676636646, 0.1979732506781312, 0.18190925802285263, 0.18967728942960815, 0.19684406106344576, 0.19539266539583056, 0.2054039388648644, 0.20461495385443496, 0.18289959794724286, 0.1839212758738319, 0.18281492063228566, 0.20345027383120473, 0.5977286142469573, 0.18018220876560787, 0.18937473439077912, 0.48467726647071563, 0.4735437493027943, 0.5801780549303038, 0.1791259575705504, 0.171943244632212, 0.4248258516814828, 0.39179128919285455, 0.19586871139984807, 0.3217489861028101, 0.4679737774682773, 0.19001961140939527, 0.3018802218757969, 0.5931220487160203, 0.6017084974713873, 0.20408620726966897, 0.18818278978123826, 0.19569743556095132, 0.1897773289398914, 0.19612767247819707, 0.17948201441919442, 0.19051138112779686, 0.18633862060260986, 0.1804562359589439, 0.18547848583321047, 0.07476308983145796, 0.07550278049315329, 0.08979131402794849, 0.06685621216047821, 0.0785330749011387, 0.0765990762934261, 0.0776349093000972, 0.07178091555681021, 0.0732544063980125]}, "mutation_prompt": null}
{"id": "b0556b09-5395-4139-a055-e374c8dc261e", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim  # Increased population size for diverse exploration\n        self.F = 0.5  # Adaptive differential weight\n        self.CR = 0.85  # Lower crossover probability\n        self.local_search_prob = 0.4  # Increased probability of performing local search\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15)  # Adjusted step size for local search\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    local_candidate = self._local_search(population[i])\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "An enhanced hybrid algorithm utilizing adaptive Differential Evolution with occasional local search to optimize convergence across diverse functions.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5f28aa71-310f-4384-b3cb-bec039a6274d", "metadata": {"aucs": [0.6981563538069014, 0.686582960397212, 0.6959698878073168, 0.7204028067997494, 0.72421647471604, 0.7049087080836627, 0.7147050838113223, 0.6990777458791964, 0.7254395866067456, 0.44351652715716205, 0.49150730049168556, 0.47509612838711235, 0.4587739398833194, 0.4771102048155347, 0.4758421172122421, 0.46112528964825406, 0.43540451162869576, 0.4615144909611596, 0.1203433256371862, 0.1103859451845115, 0.120421238639424, 0.11383954662056972, 0.110745642305209, 0.15264477995270298, 0.12259318868938784, 0.12516556013820113, 0.1245490818677325, 0.11020388524407132, 0.10537948103595152, 0.10249211753271481, 0.10194281019370177, 0.10500315248179837, 0.10164045180970771, 0.10527391269952535, 0.10722334480475149, 0.1175386140957122, 0.8822372347830252, 0.8579934738208534, 0.9099920116930209, 0.8311504552360572, 0.8645446695585449, 0.8646076355992964, 0.8715298158650703, 0.9290076282021752, 0.9053085402486716, 0.33269418610266377, 0.31139217047121925, 0.29924446284852824, 0.3063118077870366, 0.31849002133187143, 0.33688268011185774, 0.35829515383696975, 0.32586794431593025, 0.30777524154033253, 0.6499067961650971, 0.6485783086003687, 0.5538396271597137, 0.7137051890327133, 0.6616343392599355, 0.5909988872698368, 0.6291095818199557, 0.5712787980552643, 0.5863517228419086, 0.20373626606238482, 0.20116672641695, 0.19786195060385658, 0.16296596714929235, 0.15423700941742735, 0.1844539283307246, 0.16882134361613876, 0.20031972923164132, 0.17655909213356535, 0.15315419601145475, 0.17029843600297967, 0.17074522887803578, 0.19113245904941956, 0.1500160130889039, 0.20447568025998997, 0.21367271550079192, 0.1919610594504645, 0.16109939886413216, 0.1487250994789896, 0.15582308061047512, 0.14652319805556557, 0.1462877946472303, 0.16588548477555054, 0.15495589345272542, 0.16116356582255653, 0.15144259046144526, 0.17503768385206664, 0.2908929784507853, 0.2858696981255586, 0.2653998464948113, 0.29205269110664367, 0.27507417231998077, 0.2679114905845903, 0.34007584166174976, 0.33632133540245646, 0.29354387009820726, 0.07128052640141647, 0.04079614198101389, 0.05262880288941818, 0.08076722223175115, 0.04360827028232839, 0.050204987827191516, 0.055783362216375254, 0.0800935695201257, 0.03762664939975624, 0.17359650682396421, 0.17927149123505637, 0.18054655079393211, 0.19995298038676868, 0.19145407097035938, 0.18874499220047747, 0.182112171740761, 0.20856279834568492, 0.17866851738587064, 0.5467967938073408, 0.5375122028782673, 0.5377341160521014, 0.5318327242853848, 0.5295521585194702, 0.5225184471881554, 0.5228395382391381, 0.5383002868151632, 0.5434737251439348, 0.10790560356911971, 0.0999791665444214, 0.10522447144311264, 0.12350027960812426, 0.12570118941556707, 0.10724560759952528, 0.10293921527060756, 0.10213393144000127, 0.10538785514764681, 0.1885238054567665, 0.159700339882343, 0.22078290499846498, 0.182977772003875, 0.1886763546649357, 0.16278492200673278, 0.17685390849314553, 0.15447676195251547, 0.20897466567755307, 0.30074203702052804, 0.3112950178850481, 0.31712812673948654, 0.28556623697457717, 0.3203540918213187, 0.3185355256988822, 0.3187920642977148, 0.34899845205913116, 0.3432762016572132, 0.24959868520536987, 0.23490929045284903, 0.23690403252100778, 0.2182127083736325, 0.21933729735911922, 0.228350254206525, 0.26791948115013586, 0.2633205461465703, 0.25404575515750594, 0.19389692668509506, 0.17896866752132223, 0.20798803883162753, 0.18454439320764426, 0.20293248394956076, 0.19418399047330392, 0.19681927676636646, 0.1979732506781312, 0.18190925802285263, 0.18967728942960815, 0.19684406106344576, 0.19539266539583056, 0.2054039388648644, 0.20461495385443496, 0.18289959794724286, 0.1839212758738319, 0.18281492063228566, 0.20345027383120473, 0.5977286142469573, 0.18018220876560787, 0.18937473439077912, 0.48467726647071563, 0.4735437493027943, 0.5801780549303038, 0.1791259575705504, 0.171943244632212, 0.4248258516814828, 0.39179128919285455, 0.19586871139984807, 0.3217489861028101, 0.4679737774682773, 0.19001961140939527, 0.3018802218757969, 0.5931220487160203, 0.6017084974713873, 0.20408620726966897, 0.18818278978123826, 0.19569743556095132, 0.1897773289398914, 0.19612767247819707, 0.17948201441919442, 0.19051138112779686, 0.18633862060260986, 0.1804562359589439, 0.18547848583321047, 0.07476308983145796, 0.07550278049315329, 0.08979131402794849, 0.06685621216047821, 0.0785330749011387, 0.0765990762934261, 0.0776349093000972, 0.07178091555681021, 0.0732544063980125]}, "mutation_prompt": null}
{"id": "eb665236-1527-41b6-856c-233cdf8dcba0", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim  # Increased population size for diverse exploration\n        self.F_min = 0.4  # Minimum scaling factor for mutation\n        self.F_max = 0.9  # Maximum scaling factor for mutation\n        self.CR = 0.85  # Lower crossover probability\n        self.local_search_prob_init = 0.2  # Initial local search probability\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx, evals):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        F_dynamic = self.F_min + (self.F_max - self.F_min) * evals / self.budget\n        mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15)\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population, i, evals)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                local_search_prob_dynamic = self.local_search_prob_init + 0.6 * (evals / self.budget)\n                if np.random.rand() < local_search_prob_dynamic:\n                    local_candidate = self._local_search(population[i])\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduced adaptive scaling factors and a dynamic local search probability to enhance exploration and exploitation in the Differential Evolution framework.", "configspace": "", "generation": 25, "fitness": 0.2856779909826332, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.21.", "error": "", "parent_id": "5f28aa71-310f-4384-b3cb-bec039a6274d", "metadata": {"aucs": [0.6977077891804258, 0.7002375167680186, 0.70358775043176, 0.6927956926759933, 0.7503381622748647, 0.7120087522323528, 0.6535840061599058, 0.7070781624873472, 0.7033991134342195, 0.439693825102888, 0.4059938737912926, 0.37868048094834816, 0.38952117387425766, 0.397907160795135, 0.3792875047304427, 0.38650859602940113, 0.41341526420608865, 0.398974010292523, 0.11144444189895364, 0.12096194971446894, 0.12840471962371702, 0.11202057103969387, 0.10954555331291727, 0.13125431126576137, 0.11690835733382154, 0.11457591435942416, 0.12357277923521781, 0.1008793192012839, 0.10670787012754168, 0.11523795053995489, 0.10692654591796402, 0.11099671386187093, 0.11294020030723462, 0.10202681820023429, 0.11312060894180576, 0.1149698792541205, 0.8980336743700346, 0.8679100393365351, 0.8901020503585441, 0.8694492828500467, 0.8546263929595553, 0.9041388814862654, 0.9083373106450023, 0.8781863146078493, 0.9091045050792258, 0.2853650698449113, 0.3049168961670645, 0.28305734744797384, 0.2988926753940734, 0.2994926505547555, 0.2875124621409362, 0.2940081819186108, 0.31227340371338463, 0.30122584865346835, 0.5489627053982898, 0.528376728438893, 0.6081057125160254, 0.6306747633525376, 0.6567713084067219, 0.7247195200670629, 0.6697466643319816, 0.6963062520308481, 0.6337918620407261, 0.19887914120159156, 0.2015188880318638, 0.16454884652653745, 0.19530694623380396, 0.19057568205593978, 0.18296163212750205, 0.18149914375185394, 0.21093448512609236, 0.2211050872593856, 0.1674043460751633, 0.2400210253016305, 0.23393421038712203, 0.19634055897375102, 0.19023425119786064, 0.23549021020354044, 0.22927530209299185, 0.18590016128602005, 0.19371503950337166, 0.11338098249152717, 0.13685108061992346, 0.1048438989937065, 0.13412772491524194, 0.08879110813506252, 0.11323271219255149, 0.08604087030369412, 0.13626057646892475, 0.12300702862968338, 0.26254392343627475, 0.22555666066729996, 0.25269985340155277, 0.24201107938269717, 0.2141663457471803, 0.2123206417109338, 0.2602777342370477, 0.2767909764402623, 0.251535128027507, 0.026745308071187357, 0.008621024683543643, 0.0013226339565167722, 0.08891104665651894, 0.04052012934373983, 0.023713017047424234, 0.026177744910282685, 0.0284807771366945, 0.024403933056490357, 0.1570599101978083, 0.16302358138821804, 0.16103594875868366, 0.1574477327933409, 0.1518062759159844, 0.18095116879503215, 0.14552139552009158, 0.16009430794748636, 0.151915025251949, 0.5416239809469452, 0.5014550386463225, 0.5066797343236689, 0.4959011425211687, 0.5210775460873338, 0.46606408773796826, 0.5076562407805185, 0.4819864215630951, 0.510812424580241, 0.11239547070438916, 0.10439848538139085, 0.12325474331532682, 0.12115752811597502, 0.09653928868066308, 0.10589880534797358, 0.10902347164684345, 0.11130968053035317, 0.12206671675495817, 0.1925860090506082, 0.21926857161306534, 0.19068571758010766, 0.20717323601314097, 0.16229283380587645, 0.1973819553269952, 0.19966839862962715, 0.18161295769675379, 0.21090243847508816, 0.2982828812142372, 0.3006209621714281, 0.3015236538333679, 0.30136557993902446, 0.29546845222744933, 0.2857034977437477, 0.30353223251866235, 0.33614923717266953, 0.3164460501644579, 0.22198181791144056, 0.21800041899971834, 0.24450543409812686, 0.21192625514002472, 0.23134578666103667, 0.22130422548024908, 0.241886038954243, 0.27052625795179996, 0.24041793677295686, 0.20251385306155412, 0.17910215296176613, 0.18510401785333241, 0.19344753613701338, 0.202913153233663, 0.19922789385194195, 0.18807918500125043, 0.22390050512318171, 0.1925020177756669, 0.21972201227291221, 0.19235833479614262, 0.20088871783305162, 0.20074999124912507, 0.1987763447654921, 0.19279924073233679, 0.1881298320079513, 0.18665985861338508, 0.20706285332761076, 0.5150400976510325, 0.19901631687307464, 0.3315477084195547, 0.6629989306272814, 0.2210232137708169, 0.5062941293207209, 0.33325120834242905, 0.3888915773166617, 0.17145436518683732, 0.4703358304882542, 0.43285184235727836, 0.2903392936534236, 0.4780450780212957, 0.2931346735604927, 0.352374729697437, 0.20084776956801764, 0.4798650629547977, 0.38298194882202274, 0.19117151412285938, 0.19412855836525333, 0.20942460221008374, 0.17447591259933815, 0.18444018079691693, 0.1755457023631063, 0.20211787850403895, 0.20704704707676624, 0.19131374817175506, 0.08430100380770655, 0.07756337619034548, 0.07980863306040142, 0.07543998860176904, 0.07088597764012061, 0.08022494153588289, 0.0762439162293076, 0.08345464040000639, 0.08363142030260151]}, "mutation_prompt": null}
{"id": "2442244b-e7ae-432c-b768-5a3275f24962", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant1 = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        d, e, f = pop[np.random.choice(indices, 3, replace=False)]\n        mutant2 = np.clip(d + self.F * (e - f), self.lower_bound, self.upper_bound)\n        return mutant1 if np.random.rand() > 0.5 else mutant2\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "A refinement using multi-mutation strategies and dynamic local search for improved exploration-exploitation balance.", "configspace": "", "generation": 26, "fitness": 0.29884835358546635, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.21.", "error": "", "parent_id": "5f28aa71-310f-4384-b3cb-bec039a6274d", "metadata": {"aucs": [0.725081710347663, 0.7180357276016068, 0.6867939218685182, 0.7308636244576412, 0.7074049072404199, 0.7057968688898365, 0.7188060945237851, 0.7215707957775555, 0.7176560572704924, 0.4940417828066357, 0.44397285627998684, 0.4789209999245513, 0.4465631910994261, 0.44813165590385584, 0.4636119218009399, 0.4480443412672179, 0.46663307181116687, 0.4745220424876504, 0.14204107471394034, 0.12780664424306087, 0.1299667405369348, 0.14169820430614077, 0.13388325739404205, 0.1254720121278855, 0.1290209825560389, 0.12203618908940839, 0.13978334944597615, 0.1191639390090451, 0.10287471098499279, 0.1015299789590336, 0.1272315344268814, 0.11126629330881965, 0.11348867057099121, 0.11551000140444445, 0.10540972086524836, 0.1090644838251088, 0.8604019551635395, 0.8751360977787145, 0.8857925941029346, 0.8655076907442434, 0.8779026789195548, 0.8888028351118465, 0.8487069813528243, 0.893176294915844, 0.9435908575795628, 0.3283433776406305, 0.3132581057955406, 0.34068583389488294, 0.3363499086491081, 0.3690773035418373, 0.3421945958824911, 0.3170872557891884, 0.36784302795867485, 0.3221409514747413, 0.5781768435701058, 0.6245988075989384, 0.5869544355306378, 0.6465704973827557, 0.6391783797259402, 0.6732220903783428, 0.6155025552903268, 0.5868588445858717, 0.6600175700025683, 0.17729951334990657, 0.16804014621893826, 0.15813598267002127, 0.2323255974657853, 0.20263995456750605, 0.2406229512934991, 0.17211137533966137, 0.18500958625574782, 0.16902882627683224, 0.1755814249662595, 0.1761682364579248, 0.18011336429390667, 0.2594777874494779, 0.24438335931897404, 0.21634806363134018, 0.1979292048117559, 0.2049833070805689, 0.1861690272416301, 0.1913676244592465, 0.14498293106478544, 0.15609284044070704, 0.15578299501927872, 0.13832420942790946, 0.15175484651302962, 0.16725595739750676, 0.1445816269387844, 0.1660688945976746, 0.2957541520222364, 0.2813659584707503, 0.278888862487391, 0.2883192505744514, 0.2509821641034432, 0.25679715458048247, 0.3291991901224379, 0.29741158249321065, 0.2826912765239247, 0.0732131305536885, 0.06958440067620941, 0.06448805969708715, 0.07524179477711246, 0.09898181739752832, 0.0585606130968217, 0.06709332457610506, 0.09905691000224792, 0.07388668985688218, 0.17192171413513346, 0.17618030421315634, 0.18055019169543196, 0.174761881441011, 0.179140939480534, 0.19244032399658628, 0.19206658988529768, 0.18945250344996944, 0.18416401937847715, 0.534630778196471, 0.543479198538749, 0.5565326184569581, 0.5346275762817234, 0.553285652037312, 0.537470706512253, 0.5481131970198168, 0.5459991898241121, 0.5561494764517463, 0.1213848468000126, 0.1123366052084862, 0.11691811882614023, 0.11855444412425753, 0.13335099612564738, 0.11179130971691864, 0.12046535877636366, 0.11775283936711167, 0.10654856710618499, 0.24790109340060207, 0.18091827148689055, 0.18472795776241857, 0.20823143659307863, 0.20615159539998973, 0.207852615349305, 0.1691887742576853, 0.1993982688340309, 0.1914643106442364, 0.30557478335077437, 0.2993901081370567, 0.3322305921254589, 0.3269922778817177, 0.31755385737989417, 0.29902997719722635, 0.34714763546285776, 0.3447458863394388, 0.32594069716302576, 0.24782491402974505, 0.242051037614067, 0.23714500151997375, 0.22038772899325254, 0.23505143065485667, 0.24033948008622552, 0.24629102313713414, 0.27125036408547853, 0.23268699408264792, 0.20525675227364015, 0.18163871321204905, 0.19990351607185985, 0.20159451916782678, 0.17746834067922024, 0.20602847363619226, 0.22071636770155423, 0.18491682790969166, 0.19972428008321474, 0.21810659250751374, 0.20381325576149167, 0.19012210895848436, 0.1847749225029386, 0.2173550146691382, 0.1880343370423515, 0.23403057812359107, 0.19783363291479517, 0.23546511607519482, 0.24116821483819328, 0.6467021485628002, 0.4900527273159345, 0.5834911612288588, 0.4166512030369083, 0.18156610390830297, 0.4257289230897121, 0.19054649648463662, 0.6030147433850672, 0.6262319940846643, 0.19639851600960867, 0.19599948600772354, 0.18621571306349882, 0.18525177114926084, 0.20146464200918224, 0.19134538351428776, 0.20538774616860123, 0.6036922876878932, 0.18602928340177893, 0.19078693166916105, 0.17277928199630765, 0.18808036136690176, 0.17934712909098294, 0.17711775660303375, 0.20046673834617323, 0.18702588902113682, 0.19666799943648317, 0.1025029686052763, 0.10818917813097928, 0.09790141977223832, 0.07971998880636055, 0.08365518485745704, 0.07638137609038564, 0.0788620296436997, 0.08553413383871378, 0.08009235688358352]}, "mutation_prompt": null}
{"id": "87a11acb-070f-42ba-ada4-223d672abbd4", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant1 = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        d, e, f = pop[np.random.choice(indices, 3, replace=False)]\n        mutant2 = np.clip(d + self.F * (e - f), self.lower_bound, self.upper_bound)\n        return mutant1 if np.random.rand() > 0.5 else mutant2\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "A refinement using multi-mutation strategies and dynamic local search for improved exploration-exploitation balance.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2442244b-e7ae-432c-b768-5a3275f24962", "metadata": {"aucs": [0.725081710347663, 0.7180357276016068, 0.6867939218685182, 0.7308636244576412, 0.7074049072404199, 0.7057968688898365, 0.7188060945237851, 0.7215707957775555, 0.7176560572704924, 0.4940417828066357, 0.44397285627998684, 0.4789209999245513, 0.4465631910994261, 0.44813165590385584, 0.4636119218009399, 0.4480443412672179, 0.46663307181116687, 0.4745220424876504, 0.14204107471394034, 0.12780664424306087, 0.1299667405369348, 0.14169820430614077, 0.13388325739404205, 0.1254720121278855, 0.1290209825560389, 0.12203618908940839, 0.13978334944597615, 0.1191639390090451, 0.10287471098499279, 0.1015299789590336, 0.1272315344268814, 0.11126629330881965, 0.11348867057099121, 0.11551000140444445, 0.10540972086524836, 0.1090644838251088, 0.8604019551635395, 0.8751360977787145, 0.8857925941029346, 0.8655076907442434, 0.8779026789195548, 0.8888028351118465, 0.8487069813528243, 0.893176294915844, 0.9435908575795628, 0.3283433776406305, 0.3132581057955406, 0.34068583389488294, 0.3363499086491081, 0.3690773035418373, 0.3421945958824911, 0.3170872557891884, 0.36784302795867485, 0.3221409514747413, 0.5781768435701058, 0.6245988075989384, 0.5869544355306378, 0.6465704973827557, 0.6391783797259402, 0.6732220903783428, 0.6155025552903268, 0.5868588445858717, 0.6600175700025683, 0.17729951334990657, 0.16804014621893826, 0.15813598267002127, 0.2323255974657853, 0.20263995456750605, 0.2406229512934991, 0.17211137533966137, 0.18500958625574782, 0.16902882627683224, 0.1755814249662595, 0.1761682364579248, 0.18011336429390667, 0.2594777874494779, 0.24438335931897404, 0.21634806363134018, 0.1979292048117559, 0.2049833070805689, 0.1861690272416301, 0.1913676244592465, 0.14498293106478544, 0.15609284044070704, 0.15578299501927872, 0.13832420942790946, 0.15175484651302962, 0.16725595739750676, 0.1445816269387844, 0.1660688945976746, 0.2957541520222364, 0.2813659584707503, 0.278888862487391, 0.2883192505744514, 0.2509821641034432, 0.25679715458048247, 0.3291991901224379, 0.29741158249321065, 0.2826912765239247, 0.0732131305536885, 0.06958440067620941, 0.06448805969708715, 0.07524179477711246, 0.09898181739752832, 0.0585606130968217, 0.06709332457610506, 0.09905691000224792, 0.07388668985688218, 0.17192171413513346, 0.17618030421315634, 0.18055019169543196, 0.174761881441011, 0.179140939480534, 0.19244032399658628, 0.19206658988529768, 0.18945250344996944, 0.18416401937847715, 0.534630778196471, 0.543479198538749, 0.5565326184569581, 0.5346275762817234, 0.553285652037312, 0.537470706512253, 0.5481131970198168, 0.5459991898241121, 0.5561494764517463, 0.1213848468000126, 0.1123366052084862, 0.11691811882614023, 0.11855444412425753, 0.13335099612564738, 0.11179130971691864, 0.12046535877636366, 0.11775283936711167, 0.10654856710618499, 0.24790109340060207, 0.18091827148689055, 0.18472795776241857, 0.20823143659307863, 0.20615159539998973, 0.207852615349305, 0.1691887742576853, 0.1993982688340309, 0.1914643106442364, 0.30557478335077437, 0.2993901081370567, 0.3322305921254589, 0.3269922778817177, 0.31755385737989417, 0.29902997719722635, 0.34714763546285776, 0.3447458863394388, 0.32594069716302576, 0.24782491402974505, 0.242051037614067, 0.23714500151997375, 0.22038772899325254, 0.23505143065485667, 0.24033948008622552, 0.24629102313713414, 0.27125036408547853, 0.23268699408264792, 0.20525675227364015, 0.18163871321204905, 0.19990351607185985, 0.20159451916782678, 0.17746834067922024, 0.20602847363619226, 0.22071636770155423, 0.18491682790969166, 0.19972428008321474, 0.21810659250751374, 0.20381325576149167, 0.19012210895848436, 0.1847749225029386, 0.2173550146691382, 0.1880343370423515, 0.23403057812359107, 0.19783363291479517, 0.23546511607519482, 0.24116821483819328, 0.6467021485628002, 0.4900527273159345, 0.5834911612288588, 0.4166512030369083, 0.18156610390830297, 0.4257289230897121, 0.19054649648463662, 0.6030147433850672, 0.6262319940846643, 0.19639851600960867, 0.19599948600772354, 0.18621571306349882, 0.18525177114926084, 0.20146464200918224, 0.19134538351428776, 0.20538774616860123, 0.6036922876878932, 0.18602928340177893, 0.19078693166916105, 0.17277928199630765, 0.18808036136690176, 0.17934712909098294, 0.17711775660303375, 0.20046673834617323, 0.18702588902113682, 0.19666799943648317, 0.1025029686052763, 0.10818917813097928, 0.09790141977223832, 0.07971998880636055, 0.08365518485745704, 0.07638137609038564, 0.0788620296436997, 0.08553413383871378, 0.08009235688358352]}, "mutation_prompt": null}
{"id": "af65c3af-a927-4ef4-bda2-ff86800793fa", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant1 = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        d, e, f = pop[np.random.choice(indices, 3, replace=False)]\n        mutant2 = np.clip(d + self.F * (e - f), self.lower_bound, self.upper_bound)\n        return mutant1 if np.random.rand() > 0.5 else mutant2\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.01, 0.2) * scale  # Adjusted range\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def _update_population(self, population, fitness):\n        diversity_measure = np.std(population, axis=0)\n        if np.mean(diversity_measure) < 0.1:  # Threshold for diversity\n            new_inds = self._initialize_population()\n            new_fitness = np.array([func(ind) for ind in new_inds])\n            indices_to_replace = np.argsort(fitness)[-len(new_inds):]\n            population[indices_to_replace] = new_inds\n            fitness[indices_to_replace] = new_fitness\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n            self._update_population(population, fitness)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Differential Evolution with Adaptive Population and Strategic Local Search based on Diversity-Driven Exploration.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "2442244b-e7ae-432c-b768-5a3275f24962", "metadata": {}, "mutation_prompt": null}
{"id": "ef794c0a-3272-4c60-bb7f-e316258028bc", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant1 = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        d, e, f = pop[np.random.choice(indices, 3, replace=False)]\n        mutant2 = np.clip(d + self.F * (e - f), self.lower_bound, self.upper_bound)\n        return mutant1 if np.random.rand() > 0.5 else mutant2\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "A refinement using multi-mutation strategies and dynamic local search for improved exploration-exploitation balance.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2442244b-e7ae-432c-b768-5a3275f24962", "metadata": {"aucs": [0.725081710347663, 0.7180357276016068, 0.6867939218685182, 0.7308636244576412, 0.7074049072404199, 0.7057968688898365, 0.7188060945237851, 0.7215707957775555, 0.7176560572704924, 0.4940417828066357, 0.44397285627998684, 0.4789209999245513, 0.4465631910994261, 0.44813165590385584, 0.4636119218009399, 0.4480443412672179, 0.46663307181116687, 0.4745220424876504, 0.14204107471394034, 0.12780664424306087, 0.1299667405369348, 0.14169820430614077, 0.13388325739404205, 0.1254720121278855, 0.1290209825560389, 0.12203618908940839, 0.13978334944597615, 0.1191639390090451, 0.10287471098499279, 0.1015299789590336, 0.1272315344268814, 0.11126629330881965, 0.11348867057099121, 0.11551000140444445, 0.10540972086524836, 0.1090644838251088, 0.8604019551635395, 0.8751360977787145, 0.8857925941029346, 0.8655076907442434, 0.8779026789195548, 0.8888028351118465, 0.8487069813528243, 0.893176294915844, 0.9435908575795628, 0.3283433776406305, 0.3132581057955406, 0.34068583389488294, 0.3363499086491081, 0.3690773035418373, 0.3421945958824911, 0.3170872557891884, 0.36784302795867485, 0.3221409514747413, 0.5781768435701058, 0.6245988075989384, 0.5869544355306378, 0.6465704973827557, 0.6391783797259402, 0.6732220903783428, 0.6155025552903268, 0.5868588445858717, 0.6600175700025683, 0.17729951334990657, 0.16804014621893826, 0.15813598267002127, 0.2323255974657853, 0.20263995456750605, 0.2406229512934991, 0.17211137533966137, 0.18500958625574782, 0.16902882627683224, 0.1755814249662595, 0.1761682364579248, 0.18011336429390667, 0.2594777874494779, 0.24438335931897404, 0.21634806363134018, 0.1979292048117559, 0.2049833070805689, 0.1861690272416301, 0.1913676244592465, 0.14498293106478544, 0.15609284044070704, 0.15578299501927872, 0.13832420942790946, 0.15175484651302962, 0.16725595739750676, 0.1445816269387844, 0.1660688945976746, 0.2957541520222364, 0.2813659584707503, 0.278888862487391, 0.2883192505744514, 0.2509821641034432, 0.25679715458048247, 0.3291991901224379, 0.29741158249321065, 0.2826912765239247, 0.0732131305536885, 0.06958440067620941, 0.06448805969708715, 0.07524179477711246, 0.09898181739752832, 0.0585606130968217, 0.06709332457610506, 0.09905691000224792, 0.07388668985688218, 0.17192171413513346, 0.17618030421315634, 0.18055019169543196, 0.174761881441011, 0.179140939480534, 0.19244032399658628, 0.19206658988529768, 0.18945250344996944, 0.18416401937847715, 0.534630778196471, 0.543479198538749, 0.5565326184569581, 0.5346275762817234, 0.553285652037312, 0.537470706512253, 0.5481131970198168, 0.5459991898241121, 0.5561494764517463, 0.1213848468000126, 0.1123366052084862, 0.11691811882614023, 0.11855444412425753, 0.13335099612564738, 0.11179130971691864, 0.12046535877636366, 0.11775283936711167, 0.10654856710618499, 0.24790109340060207, 0.18091827148689055, 0.18472795776241857, 0.20823143659307863, 0.20615159539998973, 0.207852615349305, 0.1691887742576853, 0.1993982688340309, 0.1914643106442364, 0.30557478335077437, 0.2993901081370567, 0.3322305921254589, 0.3269922778817177, 0.31755385737989417, 0.29902997719722635, 0.34714763546285776, 0.3447458863394388, 0.32594069716302576, 0.24782491402974505, 0.242051037614067, 0.23714500151997375, 0.22038772899325254, 0.23505143065485667, 0.24033948008622552, 0.24629102313713414, 0.27125036408547853, 0.23268699408264792, 0.20525675227364015, 0.18163871321204905, 0.19990351607185985, 0.20159451916782678, 0.17746834067922024, 0.20602847363619226, 0.22071636770155423, 0.18491682790969166, 0.19972428008321474, 0.21810659250751374, 0.20381325576149167, 0.19012210895848436, 0.1847749225029386, 0.2173550146691382, 0.1880343370423515, 0.23403057812359107, 0.19783363291479517, 0.23546511607519482, 0.24116821483819328, 0.6467021485628002, 0.4900527273159345, 0.5834911612288588, 0.4166512030369083, 0.18156610390830297, 0.4257289230897121, 0.19054649648463662, 0.6030147433850672, 0.6262319940846643, 0.19639851600960867, 0.19599948600772354, 0.18621571306349882, 0.18525177114926084, 0.20146464200918224, 0.19134538351428776, 0.20538774616860123, 0.6036922876878932, 0.18602928340177893, 0.19078693166916105, 0.17277928199630765, 0.18808036136690176, 0.17934712909098294, 0.17711775660303375, 0.20046673834617323, 0.18702588902113682, 0.19666799943648317, 0.1025029686052763, 0.10818917813097928, 0.09790141977223832, 0.07971998880636055, 0.08365518485745704, 0.07638137609038564, 0.0788620296436997, 0.08553413383871378, 0.08009235688358352]}, "mutation_prompt": null}
{"id": "b3406910-e6bf-4cd7-97d2-7bf708c44c7f", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant1 = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        d, e, f = pop[np.random.choice(indices, 3, replace=False)]\n        mutant2 = np.clip(d + self.F * (e - f), self.lower_bound, self.upper_bound)\n        return mutant1 if np.random.rand() > 0.5 else mutant2\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "A refinement using multi-mutation strategies and dynamic local search for improved exploration-exploitation balance.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2442244b-e7ae-432c-b768-5a3275f24962", "metadata": {"aucs": [0.725081710347663, 0.7180357276016068, 0.6867939218685182, 0.7308636244576412, 0.7074049072404199, 0.7057968688898365, 0.7188060945237851, 0.7215707957775555, 0.7176560572704924, 0.4940417828066357, 0.44397285627998684, 0.4789209999245513, 0.4465631910994261, 0.44813165590385584, 0.4636119218009399, 0.4480443412672179, 0.46663307181116687, 0.4745220424876504, 0.14204107471394034, 0.12780664424306087, 0.1299667405369348, 0.14169820430614077, 0.13388325739404205, 0.1254720121278855, 0.1290209825560389, 0.12203618908940839, 0.13978334944597615, 0.1191639390090451, 0.10287471098499279, 0.1015299789590336, 0.1272315344268814, 0.11126629330881965, 0.11348867057099121, 0.11551000140444445, 0.10540972086524836, 0.1090644838251088, 0.8604019551635395, 0.8751360977787145, 0.8857925941029346, 0.8655076907442434, 0.8779026789195548, 0.8888028351118465, 0.8487069813528243, 0.893176294915844, 0.9435908575795628, 0.3283433776406305, 0.3132581057955406, 0.34068583389488294, 0.3363499086491081, 0.3690773035418373, 0.3421945958824911, 0.3170872557891884, 0.36784302795867485, 0.3221409514747413, 0.5781768435701058, 0.6245988075989384, 0.5869544355306378, 0.6465704973827557, 0.6391783797259402, 0.6732220903783428, 0.6155025552903268, 0.5868588445858717, 0.6600175700025683, 0.17729951334990657, 0.16804014621893826, 0.15813598267002127, 0.2323255974657853, 0.20263995456750605, 0.2406229512934991, 0.17211137533966137, 0.18500958625574782, 0.16902882627683224, 0.1755814249662595, 0.1761682364579248, 0.18011336429390667, 0.2594777874494779, 0.24438335931897404, 0.21634806363134018, 0.1979292048117559, 0.2049833070805689, 0.1861690272416301, 0.1913676244592465, 0.14498293106478544, 0.15609284044070704, 0.15578299501927872, 0.13832420942790946, 0.15175484651302962, 0.16725595739750676, 0.1445816269387844, 0.1660688945976746, 0.2957541520222364, 0.2813659584707503, 0.278888862487391, 0.2883192505744514, 0.2509821641034432, 0.25679715458048247, 0.3291991901224379, 0.29741158249321065, 0.2826912765239247, 0.0732131305536885, 0.06958440067620941, 0.06448805969708715, 0.07524179477711246, 0.09898181739752832, 0.0585606130968217, 0.06709332457610506, 0.09905691000224792, 0.07388668985688218, 0.17192171413513346, 0.17618030421315634, 0.18055019169543196, 0.174761881441011, 0.179140939480534, 0.19244032399658628, 0.19206658988529768, 0.18945250344996944, 0.18416401937847715, 0.534630778196471, 0.543479198538749, 0.5565326184569581, 0.5346275762817234, 0.553285652037312, 0.537470706512253, 0.5481131970198168, 0.5459991898241121, 0.5561494764517463, 0.1213848468000126, 0.1123366052084862, 0.11691811882614023, 0.11855444412425753, 0.13335099612564738, 0.11179130971691864, 0.12046535877636366, 0.11775283936711167, 0.10654856710618499, 0.24790109340060207, 0.18091827148689055, 0.18472795776241857, 0.20823143659307863, 0.20615159539998973, 0.207852615349305, 0.1691887742576853, 0.1993982688340309, 0.1914643106442364, 0.30557478335077437, 0.2993901081370567, 0.3322305921254589, 0.3269922778817177, 0.31755385737989417, 0.29902997719722635, 0.34714763546285776, 0.3447458863394388, 0.32594069716302576, 0.24782491402974505, 0.242051037614067, 0.23714500151997375, 0.22038772899325254, 0.23505143065485667, 0.24033948008622552, 0.24629102313713414, 0.27125036408547853, 0.23268699408264792, 0.20525675227364015, 0.18163871321204905, 0.19990351607185985, 0.20159451916782678, 0.17746834067922024, 0.20602847363619226, 0.22071636770155423, 0.18491682790969166, 0.19972428008321474, 0.21810659250751374, 0.20381325576149167, 0.19012210895848436, 0.1847749225029386, 0.2173550146691382, 0.1880343370423515, 0.23403057812359107, 0.19783363291479517, 0.23546511607519482, 0.24116821483819328, 0.6467021485628002, 0.4900527273159345, 0.5834911612288588, 0.4166512030369083, 0.18156610390830297, 0.4257289230897121, 0.19054649648463662, 0.6030147433850672, 0.6262319940846643, 0.19639851600960867, 0.19599948600772354, 0.18621571306349882, 0.18525177114926084, 0.20146464200918224, 0.19134538351428776, 0.20538774616860123, 0.6036922876878932, 0.18602928340177893, 0.19078693166916105, 0.17277928199630765, 0.18808036136690176, 0.17934712909098294, 0.17711775660303375, 0.20046673834617323, 0.18702588902113682, 0.19666799943648317, 0.1025029686052763, 0.10818917813097928, 0.09790141977223832, 0.07971998880636055, 0.08365518485745704, 0.07638137609038564, 0.0788620296436997, 0.08553413383871378, 0.08009235688358352]}, "mutation_prompt": null}
{"id": "9da1d8be-2ec3-429a-b0cc-00646e0920ab", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant1 = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        d, e, f = pop[np.random.choice(indices, 3, replace=False)]\n        mutant2 = np.clip(d + self.F * (e - f), self.lower_bound, self.upper_bound)\n        return mutant1 if np.random.rand() > 0.5 else mutant2\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "A refinement using multi-mutation strategies and dynamic local search for improved exploration-exploitation balance.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2442244b-e7ae-432c-b768-5a3275f24962", "metadata": {"aucs": [0.725081710347663, 0.7180357276016068, 0.6867939218685182, 0.7308636244576412, 0.7074049072404199, 0.7057968688898365, 0.7188060945237851, 0.7215707957775555, 0.7176560572704924, 0.4940417828066357, 0.44397285627998684, 0.4789209999245513, 0.4465631910994261, 0.44813165590385584, 0.4636119218009399, 0.4480443412672179, 0.46663307181116687, 0.4745220424876504, 0.14204107471394034, 0.12780664424306087, 0.1299667405369348, 0.14169820430614077, 0.13388325739404205, 0.1254720121278855, 0.1290209825560389, 0.12203618908940839, 0.13978334944597615, 0.1191639390090451, 0.10287471098499279, 0.1015299789590336, 0.1272315344268814, 0.11126629330881965, 0.11348867057099121, 0.11551000140444445, 0.10540972086524836, 0.1090644838251088, 0.8604019551635395, 0.8751360977787145, 0.8857925941029346, 0.8655076907442434, 0.8779026789195548, 0.8888028351118465, 0.8487069813528243, 0.893176294915844, 0.9435908575795628, 0.3283433776406305, 0.3132581057955406, 0.34068583389488294, 0.3363499086491081, 0.3690773035418373, 0.3421945958824911, 0.3170872557891884, 0.36784302795867485, 0.3221409514747413, 0.5781768435701058, 0.6245988075989384, 0.5869544355306378, 0.6465704973827557, 0.6391783797259402, 0.6732220903783428, 0.6155025552903268, 0.5868588445858717, 0.6600175700025683, 0.17729951334990657, 0.16804014621893826, 0.15813598267002127, 0.2323255974657853, 0.20263995456750605, 0.2406229512934991, 0.17211137533966137, 0.18500958625574782, 0.16902882627683224, 0.1755814249662595, 0.1761682364579248, 0.18011336429390667, 0.2594777874494779, 0.24438335931897404, 0.21634806363134018, 0.1979292048117559, 0.2049833070805689, 0.1861690272416301, 0.1913676244592465, 0.14498293106478544, 0.15609284044070704, 0.15578299501927872, 0.13832420942790946, 0.15175484651302962, 0.16725595739750676, 0.1445816269387844, 0.1660688945976746, 0.2957541520222364, 0.2813659584707503, 0.278888862487391, 0.2883192505744514, 0.2509821641034432, 0.25679715458048247, 0.3291991901224379, 0.29741158249321065, 0.2826912765239247, 0.0732131305536885, 0.06958440067620941, 0.06448805969708715, 0.07524179477711246, 0.09898181739752832, 0.0585606130968217, 0.06709332457610506, 0.09905691000224792, 0.07388668985688218, 0.17192171413513346, 0.17618030421315634, 0.18055019169543196, 0.174761881441011, 0.179140939480534, 0.19244032399658628, 0.19206658988529768, 0.18945250344996944, 0.18416401937847715, 0.534630778196471, 0.543479198538749, 0.5565326184569581, 0.5346275762817234, 0.553285652037312, 0.537470706512253, 0.5481131970198168, 0.5459991898241121, 0.5561494764517463, 0.1213848468000126, 0.1123366052084862, 0.11691811882614023, 0.11855444412425753, 0.13335099612564738, 0.11179130971691864, 0.12046535877636366, 0.11775283936711167, 0.10654856710618499, 0.24790109340060207, 0.18091827148689055, 0.18472795776241857, 0.20823143659307863, 0.20615159539998973, 0.207852615349305, 0.1691887742576853, 0.1993982688340309, 0.1914643106442364, 0.30557478335077437, 0.2993901081370567, 0.3322305921254589, 0.3269922778817177, 0.31755385737989417, 0.29902997719722635, 0.34714763546285776, 0.3447458863394388, 0.32594069716302576, 0.24782491402974505, 0.242051037614067, 0.23714500151997375, 0.22038772899325254, 0.23505143065485667, 0.24033948008622552, 0.24629102313713414, 0.27125036408547853, 0.23268699408264792, 0.20525675227364015, 0.18163871321204905, 0.19990351607185985, 0.20159451916782678, 0.17746834067922024, 0.20602847363619226, 0.22071636770155423, 0.18491682790969166, 0.19972428008321474, 0.21810659250751374, 0.20381325576149167, 0.19012210895848436, 0.1847749225029386, 0.2173550146691382, 0.1880343370423515, 0.23403057812359107, 0.19783363291479517, 0.23546511607519482, 0.24116821483819328, 0.6467021485628002, 0.4900527273159345, 0.5834911612288588, 0.4166512030369083, 0.18156610390830297, 0.4257289230897121, 0.19054649648463662, 0.6030147433850672, 0.6262319940846643, 0.19639851600960867, 0.19599948600772354, 0.18621571306349882, 0.18525177114926084, 0.20146464200918224, 0.19134538351428776, 0.20538774616860123, 0.6036922876878932, 0.18602928340177893, 0.19078693166916105, 0.17277928199630765, 0.18808036136690176, 0.17934712909098294, 0.17711775660303375, 0.20046673834617323, 0.18702588902113682, 0.19666799943648317, 0.1025029686052763, 0.10818917813097928, 0.09790141977223832, 0.07971998880636055, 0.08365518485745704, 0.07638137609038564, 0.0788620296436997, 0.08553413383871378, 0.08009235688358352]}, "mutation_prompt": null}
{"id": "97b8a3d7-8de2-4f6c-827b-722afe25e7fc", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant1 = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        d, e, f = pop[np.random.choice(indices, 3, replace=False)]\n        mutant2 = np.clip(d + self.F * (e - f), self.lower_bound, self.upper_bound)\n        return mutant1 if np.random.rand() > 0.5 else mutant2\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "A refinement using multi-mutation strategies and dynamic local search for improved exploration-exploitation balance.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2442244b-e7ae-432c-b768-5a3275f24962", "metadata": {"aucs": [0.725081710347663, 0.7180357276016068, 0.6867939218685182, 0.7308636244576412, 0.7074049072404199, 0.7057968688898365, 0.7188060945237851, 0.7215707957775555, 0.7176560572704924, 0.4940417828066357, 0.44397285627998684, 0.4789209999245513, 0.4465631910994261, 0.44813165590385584, 0.4636119218009399, 0.4480443412672179, 0.46663307181116687, 0.4745220424876504, 0.14204107471394034, 0.12780664424306087, 0.1299667405369348, 0.14169820430614077, 0.13388325739404205, 0.1254720121278855, 0.1290209825560389, 0.12203618908940839, 0.13978334944597615, 0.1191639390090451, 0.10287471098499279, 0.1015299789590336, 0.1272315344268814, 0.11126629330881965, 0.11348867057099121, 0.11551000140444445, 0.10540972086524836, 0.1090644838251088, 0.8604019551635395, 0.8751360977787145, 0.8857925941029346, 0.8655076907442434, 0.8779026789195548, 0.8888028351118465, 0.8487069813528243, 0.893176294915844, 0.9435908575795628, 0.3283433776406305, 0.3132581057955406, 0.34068583389488294, 0.3363499086491081, 0.3690773035418373, 0.3421945958824911, 0.3170872557891884, 0.36784302795867485, 0.3221409514747413, 0.5781768435701058, 0.6245988075989384, 0.5869544355306378, 0.6465704973827557, 0.6391783797259402, 0.6732220903783428, 0.6155025552903268, 0.5868588445858717, 0.6600175700025683, 0.17729951334990657, 0.16804014621893826, 0.15813598267002127, 0.2323255974657853, 0.20263995456750605, 0.2406229512934991, 0.17211137533966137, 0.18500958625574782, 0.16902882627683224, 0.1755814249662595, 0.1761682364579248, 0.18011336429390667, 0.2594777874494779, 0.24438335931897404, 0.21634806363134018, 0.1979292048117559, 0.2049833070805689, 0.1861690272416301, 0.1913676244592465, 0.14498293106478544, 0.15609284044070704, 0.15578299501927872, 0.13832420942790946, 0.15175484651302962, 0.16725595739750676, 0.1445816269387844, 0.1660688945976746, 0.2957541520222364, 0.2813659584707503, 0.278888862487391, 0.2883192505744514, 0.2509821641034432, 0.25679715458048247, 0.3291991901224379, 0.29741158249321065, 0.2826912765239247, 0.0732131305536885, 0.06958440067620941, 0.06448805969708715, 0.07524179477711246, 0.09898181739752832, 0.0585606130968217, 0.06709332457610506, 0.09905691000224792, 0.07388668985688218, 0.17192171413513346, 0.17618030421315634, 0.18055019169543196, 0.174761881441011, 0.179140939480534, 0.19244032399658628, 0.19206658988529768, 0.18945250344996944, 0.18416401937847715, 0.534630778196471, 0.543479198538749, 0.5565326184569581, 0.5346275762817234, 0.553285652037312, 0.537470706512253, 0.5481131970198168, 0.5459991898241121, 0.5561494764517463, 0.1213848468000126, 0.1123366052084862, 0.11691811882614023, 0.11855444412425753, 0.13335099612564738, 0.11179130971691864, 0.12046535877636366, 0.11775283936711167, 0.10654856710618499, 0.24790109340060207, 0.18091827148689055, 0.18472795776241857, 0.20823143659307863, 0.20615159539998973, 0.207852615349305, 0.1691887742576853, 0.1993982688340309, 0.1914643106442364, 0.30557478335077437, 0.2993901081370567, 0.3322305921254589, 0.3269922778817177, 0.31755385737989417, 0.29902997719722635, 0.34714763546285776, 0.3447458863394388, 0.32594069716302576, 0.24782491402974505, 0.242051037614067, 0.23714500151997375, 0.22038772899325254, 0.23505143065485667, 0.24033948008622552, 0.24629102313713414, 0.27125036408547853, 0.23268699408264792, 0.20525675227364015, 0.18163871321204905, 0.19990351607185985, 0.20159451916782678, 0.17746834067922024, 0.20602847363619226, 0.22071636770155423, 0.18491682790969166, 0.19972428008321474, 0.21810659250751374, 0.20381325576149167, 0.19012210895848436, 0.1847749225029386, 0.2173550146691382, 0.1880343370423515, 0.23403057812359107, 0.19783363291479517, 0.23546511607519482, 0.24116821483819328, 0.6467021485628002, 0.4900527273159345, 0.5834911612288588, 0.4166512030369083, 0.18156610390830297, 0.4257289230897121, 0.19054649648463662, 0.6030147433850672, 0.6262319940846643, 0.19639851600960867, 0.19599948600772354, 0.18621571306349882, 0.18525177114926084, 0.20146464200918224, 0.19134538351428776, 0.20538774616860123, 0.6036922876878932, 0.18602928340177893, 0.19078693166916105, 0.17277928199630765, 0.18808036136690176, 0.17934712909098294, 0.17711775660303375, 0.20046673834617323, 0.18702588902113682, 0.19666799943648317, 0.1025029686052763, 0.10818917813097928, 0.09790141977223832, 0.07971998880636055, 0.08365518485745704, 0.07638137609038564, 0.0788620296436997, 0.08553413383871378, 0.08009235688358352]}, "mutation_prompt": null}
{"id": "5ed36eec-9f9b-4e85-9014-09adc07200c9", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant1 = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        d, e, f = pop[np.random.choice(indices, 3, replace=False)]\n        mutant2 = np.clip(d + self.F * (e - f), self.lower_bound, self.upper_bound)\n        return mutant1 if np.random.rand() > 0.5 else mutant2\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "A refinement using multi-mutation strategies and dynamic local search for improved exploration-exploitation balance.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2442244b-e7ae-432c-b768-5a3275f24962", "metadata": {"aucs": [0.725081710347663, 0.7180357276016068, 0.6867939218685182, 0.7308636244576412, 0.7074049072404199, 0.7057968688898365, 0.7188060945237851, 0.7215707957775555, 0.7176560572704924, 0.4940417828066357, 0.44397285627998684, 0.4789209999245513, 0.4465631910994261, 0.44813165590385584, 0.4636119218009399, 0.4480443412672179, 0.46663307181116687, 0.4745220424876504, 0.14204107471394034, 0.12780664424306087, 0.1299667405369348, 0.14169820430614077, 0.13388325739404205, 0.1254720121278855, 0.1290209825560389, 0.12203618908940839, 0.13978334944597615, 0.1191639390090451, 0.10287471098499279, 0.1015299789590336, 0.1272315344268814, 0.11126629330881965, 0.11348867057099121, 0.11551000140444445, 0.10540972086524836, 0.1090644838251088, 0.8604019551635395, 0.8751360977787145, 0.8857925941029346, 0.8655076907442434, 0.8779026789195548, 0.8888028351118465, 0.8487069813528243, 0.893176294915844, 0.9435908575795628, 0.3283433776406305, 0.3132581057955406, 0.34068583389488294, 0.3363499086491081, 0.3690773035418373, 0.3421945958824911, 0.3170872557891884, 0.36784302795867485, 0.3221409514747413, 0.5781768435701058, 0.6245988075989384, 0.5869544355306378, 0.6465704973827557, 0.6391783797259402, 0.6732220903783428, 0.6155025552903268, 0.5868588445858717, 0.6600175700025683, 0.17729951334990657, 0.16804014621893826, 0.15813598267002127, 0.2323255974657853, 0.20263995456750605, 0.2406229512934991, 0.17211137533966137, 0.18500958625574782, 0.16902882627683224, 0.1755814249662595, 0.1761682364579248, 0.18011336429390667, 0.2594777874494779, 0.24438335931897404, 0.21634806363134018, 0.1979292048117559, 0.2049833070805689, 0.1861690272416301, 0.1913676244592465, 0.14498293106478544, 0.15609284044070704, 0.15578299501927872, 0.13832420942790946, 0.15175484651302962, 0.16725595739750676, 0.1445816269387844, 0.1660688945976746, 0.2957541520222364, 0.2813659584707503, 0.278888862487391, 0.2883192505744514, 0.2509821641034432, 0.25679715458048247, 0.3291991901224379, 0.29741158249321065, 0.2826912765239247, 0.0732131305536885, 0.06958440067620941, 0.06448805969708715, 0.07524179477711246, 0.09898181739752832, 0.0585606130968217, 0.06709332457610506, 0.09905691000224792, 0.07388668985688218, 0.17192171413513346, 0.17618030421315634, 0.18055019169543196, 0.174761881441011, 0.179140939480534, 0.19244032399658628, 0.19206658988529768, 0.18945250344996944, 0.18416401937847715, 0.534630778196471, 0.543479198538749, 0.5565326184569581, 0.5346275762817234, 0.553285652037312, 0.537470706512253, 0.5481131970198168, 0.5459991898241121, 0.5561494764517463, 0.1213848468000126, 0.1123366052084862, 0.11691811882614023, 0.11855444412425753, 0.13335099612564738, 0.11179130971691864, 0.12046535877636366, 0.11775283936711167, 0.10654856710618499, 0.24790109340060207, 0.18091827148689055, 0.18472795776241857, 0.20823143659307863, 0.20615159539998973, 0.207852615349305, 0.1691887742576853, 0.1993982688340309, 0.1914643106442364, 0.30557478335077437, 0.2993901081370567, 0.3322305921254589, 0.3269922778817177, 0.31755385737989417, 0.29902997719722635, 0.34714763546285776, 0.3447458863394388, 0.32594069716302576, 0.24782491402974505, 0.242051037614067, 0.23714500151997375, 0.22038772899325254, 0.23505143065485667, 0.24033948008622552, 0.24629102313713414, 0.27125036408547853, 0.23268699408264792, 0.20525675227364015, 0.18163871321204905, 0.19990351607185985, 0.20159451916782678, 0.17746834067922024, 0.20602847363619226, 0.22071636770155423, 0.18491682790969166, 0.19972428008321474, 0.21810659250751374, 0.20381325576149167, 0.19012210895848436, 0.1847749225029386, 0.2173550146691382, 0.1880343370423515, 0.23403057812359107, 0.19783363291479517, 0.23546511607519482, 0.24116821483819328, 0.6467021485628002, 0.4900527273159345, 0.5834911612288588, 0.4166512030369083, 0.18156610390830297, 0.4257289230897121, 0.19054649648463662, 0.6030147433850672, 0.6262319940846643, 0.19639851600960867, 0.19599948600772354, 0.18621571306349882, 0.18525177114926084, 0.20146464200918224, 0.19134538351428776, 0.20538774616860123, 0.6036922876878932, 0.18602928340177893, 0.19078693166916105, 0.17277928199630765, 0.18808036136690176, 0.17934712909098294, 0.17711775660303375, 0.20046673834617323, 0.18702588902113682, 0.19666799943648317, 0.1025029686052763, 0.10818917813097928, 0.09790141977223832, 0.07971998880636055, 0.08365518485745704, 0.07638137609038564, 0.0788620296436997, 0.08553413383871378, 0.08009235688358352]}, "mutation_prompt": null}
{"id": "ba65f122-7ed6-4404-8fe6-581d80e5d7af", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant1 = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        d, e, f = pop[np.random.choice(indices, 3, replace=False)]\n        mutant2 = np.clip(d + self.F * (e - f), self.lower_bound, self.upper_bound)\n        return mutant1 if np.random.rand() > 0.5 else mutant2\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "A refinement using multi-mutation strategies and dynamic local search for improved exploration-exploitation balance.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2442244b-e7ae-432c-b768-5a3275f24962", "metadata": {"aucs": [0.725081710347663, 0.7180357276016068, 0.6867939218685182, 0.7308636244576412, 0.7074049072404199, 0.7057968688898365, 0.7188060945237851, 0.7215707957775555, 0.7176560572704924, 0.4940417828066357, 0.44397285627998684, 0.4789209999245513, 0.4465631910994261, 0.44813165590385584, 0.4636119218009399, 0.4480443412672179, 0.46663307181116687, 0.4745220424876504, 0.14204107471394034, 0.12780664424306087, 0.1299667405369348, 0.14169820430614077, 0.13388325739404205, 0.1254720121278855, 0.1290209825560389, 0.12203618908940839, 0.13978334944597615, 0.1191639390090451, 0.10287471098499279, 0.1015299789590336, 0.1272315344268814, 0.11126629330881965, 0.11348867057099121, 0.11551000140444445, 0.10540972086524836, 0.1090644838251088, 0.8604019551635395, 0.8751360977787145, 0.8857925941029346, 0.8655076907442434, 0.8779026789195548, 0.8888028351118465, 0.8487069813528243, 0.893176294915844, 0.9435908575795628, 0.3283433776406305, 0.3132581057955406, 0.34068583389488294, 0.3363499086491081, 0.3690773035418373, 0.3421945958824911, 0.3170872557891884, 0.36784302795867485, 0.3221409514747413, 0.5781768435701058, 0.6245988075989384, 0.5869544355306378, 0.6465704973827557, 0.6391783797259402, 0.6732220903783428, 0.6155025552903268, 0.5868588445858717, 0.6600175700025683, 0.17729951334990657, 0.16804014621893826, 0.15813598267002127, 0.2323255974657853, 0.20263995456750605, 0.2406229512934991, 0.17211137533966137, 0.18500958625574782, 0.16902882627683224, 0.1755814249662595, 0.1761682364579248, 0.18011336429390667, 0.2594777874494779, 0.24438335931897404, 0.21634806363134018, 0.1979292048117559, 0.2049833070805689, 0.1861690272416301, 0.1913676244592465, 0.14498293106478544, 0.15609284044070704, 0.15578299501927872, 0.13832420942790946, 0.15175484651302962, 0.16725595739750676, 0.1445816269387844, 0.1660688945976746, 0.2957541520222364, 0.2813659584707503, 0.278888862487391, 0.2883192505744514, 0.2509821641034432, 0.25679715458048247, 0.3291991901224379, 0.29741158249321065, 0.2826912765239247, 0.0732131305536885, 0.06958440067620941, 0.06448805969708715, 0.07524179477711246, 0.09898181739752832, 0.0585606130968217, 0.06709332457610506, 0.09905691000224792, 0.07388668985688218, 0.17192171413513346, 0.17618030421315634, 0.18055019169543196, 0.174761881441011, 0.179140939480534, 0.19244032399658628, 0.19206658988529768, 0.18945250344996944, 0.18416401937847715, 0.534630778196471, 0.543479198538749, 0.5565326184569581, 0.5346275762817234, 0.553285652037312, 0.537470706512253, 0.5481131970198168, 0.5459991898241121, 0.5561494764517463, 0.1213848468000126, 0.1123366052084862, 0.11691811882614023, 0.11855444412425753, 0.13335099612564738, 0.11179130971691864, 0.12046535877636366, 0.11775283936711167, 0.10654856710618499, 0.24790109340060207, 0.18091827148689055, 0.18472795776241857, 0.20823143659307863, 0.20615159539998973, 0.207852615349305, 0.1691887742576853, 0.1993982688340309, 0.1914643106442364, 0.30557478335077437, 0.2993901081370567, 0.3322305921254589, 0.3269922778817177, 0.31755385737989417, 0.29902997719722635, 0.34714763546285776, 0.3447458863394388, 0.32594069716302576, 0.24782491402974505, 0.242051037614067, 0.23714500151997375, 0.22038772899325254, 0.23505143065485667, 0.24033948008622552, 0.24629102313713414, 0.27125036408547853, 0.23268699408264792, 0.20525675227364015, 0.18163871321204905, 0.19990351607185985, 0.20159451916782678, 0.17746834067922024, 0.20602847363619226, 0.22071636770155423, 0.18491682790969166, 0.19972428008321474, 0.21810659250751374, 0.20381325576149167, 0.19012210895848436, 0.1847749225029386, 0.2173550146691382, 0.1880343370423515, 0.23403057812359107, 0.19783363291479517, 0.23546511607519482, 0.24116821483819328, 0.6467021485628002, 0.4900527273159345, 0.5834911612288588, 0.4166512030369083, 0.18156610390830297, 0.4257289230897121, 0.19054649648463662, 0.6030147433850672, 0.6262319940846643, 0.19639851600960867, 0.19599948600772354, 0.18621571306349882, 0.18525177114926084, 0.20146464200918224, 0.19134538351428776, 0.20538774616860123, 0.6036922876878932, 0.18602928340177893, 0.19078693166916105, 0.17277928199630765, 0.18808036136690176, 0.17934712909098294, 0.17711775660303375, 0.20046673834617323, 0.18702588902113682, 0.19666799943648317, 0.1025029686052763, 0.10818917813097928, 0.09790141977223832, 0.07971998880636055, 0.08365518485745704, 0.07638137609038564, 0.0788620296436997, 0.08553413383871378, 0.08009235688358352]}, "mutation_prompt": null}
{"id": "152357ae-a979-4fbd-9e3e-68ea9e89b5e4", "solution": "import numpy as np\n\nclass AdaptivePopulationDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.resize_factor = 0.1  # New parameter for adaptive resizing\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant1 = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        d, e, f = pop[np.random.choice(indices, 3, replace=False)]\n        mutant2 = np.clip(d + self.F * (e - f), self.lower_bound, self.upper_bound)\n        # Enhanced mutation strategy\n        g, h, i = pop[np.random.choice(indices, 3, replace=False)]\n        mutant3 = np.clip(g + self.F * (h - i), self.lower_bound, self.upper_bound)\n        return mutant3 if np.random.rand() > 0.5 else (mutant1 if np.random.rand() > 0.5 else mutant2)\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n            # Adaptive population resizing\n            if np.random.rand() < self.resize_factor:\n                self.population_size = max(4, int(self.population_size * (0.9 + 0.2 * np.random.rand())))\n                population = population[:self.population_size]\n                fitness = fitness[:self.population_size]\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptivePopulationDifferentialEvolution", "description": "Adaptive Population Differential Evolution: Introduces adaptive population resizing and enhanced mutation strategies for improved convergence.", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 55 is out of bounds for axis 0 with size 55').", "error": "IndexError('index 55 is out of bounds for axis 0 with size 55')", "parent_id": "2442244b-e7ae-432c-b768-5a3275f24962", "metadata": {}, "mutation_prompt": null}
{"id": "89e0c5ce-7b62-409a-9489-545d2e19bf23", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant1 = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        d, e, f = pop[np.random.choice(indices, 3, replace=False)]\n        mutant2 = np.clip(d + self.F * (e - f), self.lower_bound, self.upper_bound)\n        return mutant1 if np.random.rand() > 0.5 else mutant2\n\n    def _crossover(self, target, mutant, adaptive_cr):\n        cross_points = np.random.rand(self.dim) < adaptive_cr\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                adaptive_F = self.F * (1 - evals / self.budget)\n                adaptive_CR = self.CR * (1 - evals / self.budget)\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant, adaptive_CR)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = (1 - evals / self.budget) ** 2\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "A refined differential evolution using adaptive scale factor and crossover rate combined with a dynamic local search intensity.", "configspace": "", "generation": 36, "fitness": 0.24755962871018486, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.20.", "error": "", "parent_id": "2442244b-e7ae-432c-b768-5a3275f24962", "metadata": {"aucs": [0.7200322713869733, 0.6817546838739286, 0.7083887391888828, 0.7079779469633878, 0.7075899467887581, 0.6834322861927812, 0.6823219971283571, 0.6842511729449617, 0.7066004524451323, 0.43336611985045714, 0.4034685371904634, 0.43607085860226746, 0.4176026425184244, 0.4209842817978585, 0.4254533663390305, 0.4310362317876776, 0.4512205610518427, 0.41975050234146205, 0.19987171905396517, 0.206368143810144, 0.1915781708413904, 0.20668778600377513, 0.21880464895130058, 0.2095626609916068, 0.2160132253732049, 0.2199850039942095, 0.21285518304192141, 0.18004671716074172, 0.16593420557276206, 0.17142366790987418, 0.16379865162501828, 0.15915918268186957, 0.18802882562100554, 0.16161344806956746, 0.15627434434480258, 0.16535417597515456, 0.864627785118239, 0.8519432795590953, 0.9492327282776094, 0.9118157633329154, 0.8582930932994804, 0.9478882767272483, 0.9263955139432255, 0.8957448419347999, 0.909670969607655, 0.23231256779566556, 0.21307152697630782, 0.2475500832639428, 0.24893523825318375, 0.22231380702485926, 0.22597505524034345, 0.2314767608291921, 0.23651433786615195, 0.19830918222244942, 0.2923941659794528, 0.307231757213804, 0.21553221413838142, 0.2893310944839015, 0.31421983698869704, 0.32708431129861737, 0.29122105443053614, 0.27367807816298517, 0.292115753230741, 0.14125326209132016, 0.14644586772284474, 0.1679504298723088, 0.15901152866438528, 0.19097218407991767, 0.16111205686064478, 0.1516451209657378, 0.18890973138541578, 0.18698874438145663, 0.13524353957573654, 0.11913242107726107, 0.15288781781118344, 0.18393870572854498, 0.16169225142982646, 0.17727490372051558, 0.1443478298805303, 0.12808280232040237, 0.16428280239717585, 0.03474798429054504, 0.022429127041067476, 9.999999999998899e-05, 0.005016546604041272, 0.005436790490667809, 0.03648940739601969, 0.01565614223183598, 0.027235537649533015, 0.007566328847784298, 0.12622432057045085, 0.0929577516773592, 0.10991869123595366, 0.06028702520345197, 0.12627001138945304, 0.11102163461480086, 0.12979584254317178, 0.12811564090201266, 0.12174532914240332, 0.007748396659699064, 0.015451372439332256, 0.026300234452751092, 0.013002713014181766, 0.026249566042992778, 0.039118556316758646, 0.03410913779366287, 0.04341941181566977, 0.039398824722659764, 0.12368242624876058, 0.13220367478742379, 0.10997977812190496, 0.1354387728402171, 0.12523073543599617, 0.11685018395934421, 0.11479234138979844, 0.1347521182719149, 0.13436480031614972, 0.43592634807727915, 0.4489968961614329, 0.4646970113871681, 0.47440100851949696, 0.4310526158542156, 0.44799444357974105, 0.4321575227756639, 0.44187100728254824, 0.4511224040155093, 0.11149976987970489, 0.10937999170758139, 0.12463841993513691, 0.10719593707927466, 0.10036424701477686, 0.11971740022717547, 0.11482784817826008, 0.11852423894916031, 0.10899913734105793, 0.182051611849405, 0.1706425221621639, 0.18117000046978382, 0.18800937360440717, 0.1622305835576885, 0.1787480470450299, 0.2081791978715527, 0.2054754929394238, 0.18297086650392036, 0.27896639111240573, 0.2658924156013598, 0.2820492492863109, 0.26248918072877436, 0.25212284483400116, 0.25072383471916915, 0.29402884715829003, 0.29937135355402233, 0.3004927860775277, 0.20763910644255423, 0.1871373973319974, 0.21415343438674794, 0.18713242916673367, 0.17436430273613002, 0.1726711797784798, 0.18202724717334762, 0.18649978671724, 0.23822002477168758, 0.22665929311428046, 0.2193457007732773, 0.20639657278155754, 0.21439762665996487, 0.20768124492721907, 0.2034325652135025, 0.20878225746334667, 0.20417684879598919, 0.20370990528879662, 0.22389707983897733, 0.2066441665287273, 0.20200495502537774, 0.20600306137661284, 0.22341744562778754, 0.21135745229088587, 0.2273558399261617, 0.26334374521383863, 0.19800595999265191, 0.23222870887265368, 0.2243354910759382, 0.3238495516136167, 0.29457255041287767, 0.2425234668936993, 0.256039849008567, 0.21496693520073862, 0.23953995915831916, 0.27243393285694306, 0.316317418547997, 0.2486148156800142, 0.19830492438850356, 0.25337115852537195, 0.24233818986334832, 0.18507175914898344, 0.20839670066736626, 0.20249529764698093, 0.32242461334194783, 0.19487865380612934, 0.19951111266368826, 0.19226284587577336, 0.19225243596034203, 0.19412982302459503, 0.2033444012454939, 0.20417057954251827, 0.1909982992116379, 0.2006861184916987, 0.08413078371415617, 0.08407792256781288, 0.08387036702197692, 0.08807923615256019, 0.08598284145356627, 0.074309954483324, 0.08567555728829845, 0.07988172133421556, 0.0775537552345682]}, "mutation_prompt": null}
{"id": "64873ee6-e9df-499b-8442-e7edb34c4643", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 12 * dim\n        self.population_size = self.initial_population_size\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_population_step = max(1, self.population_size // 5)\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant1 = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        d, e, f = pop[np.random.choice(indices, 3, replace=False)]\n        mutant2 = np.clip(d + self.F * (e - f), self.lower_bound, self.upper_bound)\n        return mutant1 if np.random.rand() > 0.5 else mutant2\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def _stochastic_ranking(self, population, fitness):\n        indices = np.argsort(fitness)\n        return population[indices], fitness[indices]\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n            if evals < self.budget:\n                population, fitness = self._stochastic_ranking(population, fitness)\n                if evals / self.budget > 0.5:\n                    self.population_size = max(4, self.population_size - self.adaptive_population_step)\n                    population = population[:self.population_size]\n                    fitness = fitness[:self.population_size]\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "A hybrid enhancement to balance exploration and exploitation by integrating adaptive population sizing and stochastic ranking.", "configspace": "", "generation": 37, "fitness": 0.294846835264902, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.21.", "error": "", "parent_id": "2442244b-e7ae-432c-b768-5a3275f24962", "metadata": {"aucs": [0.6588746524002684, 0.5942439076138002, 0.6111759059012425, 0.7015044845172955, 0.6565521126972906, 0.6533267183987854, 0.6699402984494638, 0.6418590434103011, 0.6228405137596703, 0.36749679205614694, 0.3433897918740684, 0.3289158511514243, 0.32767859309360414, 0.3299783744964273, 0.34138937598055963, 0.3215780412455084, 0.35951587765007653, 0.3350445256622545, 0.22041245418973276, 0.13694808811602377, 0.1266123014791175, 0.13052893588711245, 0.14109006324321782, 0.19430717193761116, 0.2043121141361245, 0.13965299349239846, 0.13424612857947327, 0.11037790501348099, 0.11041266852290355, 0.10432651975200646, 0.11932836236694677, 0.1140413869671596, 0.12498221673184884, 0.14378700587712423, 0.11497209276063425, 0.1208626886305717, 0.8834218271827751, 0.9239745711453224, 0.8766906442804765, 0.9275764501472699, 0.8694358868990287, 0.8880639269288315, 0.8749646397046604, 0.8783612693814077, 0.8904712865129514, 0.3189518373262542, 0.29454253729953117, 0.32086681798627514, 0.3268919106457516, 0.2908347902141539, 0.32694341099368385, 0.3190321870185574, 0.3234468142302852, 0.3202668581390993, 0.6298468216832405, 0.6093749094598693, 0.6145077585523457, 0.7023596302843247, 0.7020121111401676, 0.6341243500295143, 0.5855017312682009, 0.6107989009013564, 0.6351617219672566, 0.15891829586537565, 0.17444980996106718, 0.16793216416876822, 0.18690351771609437, 0.1680469597744696, 0.16840966262239343, 0.17409705495248784, 0.17623164044996686, 0.16658093145061215, 0.16005530773951482, 0.15181122631498334, 0.18011255171683882, 0.16860311657237892, 0.1891312085806388, 0.18244464656608217, 0.2000160640077252, 0.1658559497888109, 0.15609128142388384, 0.17570161657687133, 0.20522109700866298, 0.11957433582285992, 0.1610894037084235, 0.12652638673510808, 0.10764920220841434, 0.1333439414482238, 0.15045443636731615, 0.10577647753273489, 0.25160453401974214, 0.2998347039807383, 0.24723247303459917, 0.20744018113334584, 0.2547298506548291, 0.2790195847366115, 0.25217325291082904, 0.25060852683185575, 0.3110057230885461, 0.08677700570138536, 0.0693073159434382, 0.11308897810606544, 0.08535293962446866, 0.08989872609218219, 0.09003326726262362, 0.08085025026146919, 0.07043528545989175, 0.0262697733003735, 0.16162436388092627, 0.20042747896028723, 0.19404049802436252, 0.16667481950340024, 0.17038758825642453, 0.17393589368807938, 0.18072096629758783, 0.19851691979826624, 0.1661436469083586, 0.5117033112364322, 0.5129985390422124, 0.5204504747375693, 0.5717100392862347, 0.4864903218619202, 0.5096290607568537, 0.48406167624877616, 0.49624289825002166, 0.5308639698378222, 0.11886057175795273, 0.12125067362765296, 0.13423089530081922, 0.12544688385797764, 0.12298206646018095, 0.11398500689441593, 0.11508093928329255, 0.12434657644353808, 0.12183922854127105, 0.24149509189212093, 0.18230161243813958, 0.1861628379992042, 0.20902637648177957, 0.18319326905965694, 0.1716731904881682, 0.21238063607190039, 0.21645269896265318, 0.17845114114963523, 0.3241263116982732, 0.31047526569338146, 0.3119242689240438, 0.3025990259768355, 0.2993562025529104, 0.3034250946297623, 0.3189858421856362, 0.326134710438012, 0.32687637903709843, 0.24330670800592902, 0.2700201808423318, 0.2754684956189295, 0.2601184744673064, 0.2553997735706345, 0.24589532025731464, 0.22652416615123816, 0.2543755125395891, 0.2379454301303271, 0.19477233706712704, 0.213151366139113, 0.20267801799755147, 0.2124552234330035, 0.1996272656733844, 0.21085255201358144, 0.20162974963770197, 0.19937401912800212, 0.19182459216007008, 0.20294968719944484, 0.21602534835647758, 0.20264609929229616, 0.2858491867869465, 0.2757527068610536, 0.2718276625555238, 0.22178211188616792, 0.2136108807383641, 0.20953172951955312, 0.5786746135237725, 0.6619663973908423, 0.5481601651313119, 0.17776338895965893, 0.5686844775401289, 0.5802620926442015, 0.5183576696610819, 0.523306973119932, 0.5024360924257163, 0.5351595297721452, 0.4083713979206631, 0.16376295329597457, 0.32065490280870856, 0.1888024523542332, 0.19184191840118536, 0.19920753505461142, 0.6403673995254118, 0.33014766039159316, 0.18319793961447628, 0.1876000553267737, 0.2002213115811834, 0.18877667294184763, 0.1926269416873856, 0.19680170264412988, 0.20269873991609333, 0.1881121624430252, 0.1852558436113595, 0.08752005013686015, 0.08601158006671816, 0.08672086292325476, 0.0851193327137556, 0.08431192376572294, 0.09945337110910002, 0.08555779100757122, 0.10195873795174215, 0.09034169681789028]}, "mutation_prompt": null}
{"id": "9f3c7723-86d1-4724-9b7f-878e4b874813", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5  # New adaptive learning rate\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant1 = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        d, e, f = pop[np.random.choice(indices, 3, replace=False)]\n        mutant2 = np.clip(d + self.F * (e - f), self.lower_bound, self.upper_bound)\n        return mutant1 if np.random.rand() > 0.5 else mutant2\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                # Adjust F dynamically based on budget usage\n                self.F = self.adaptive_alpha * (1.0 - evals / self.budget)\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "An adaptive learning rate strategy is integrated with hybrid differential evolution to balance exploration and exploitation dynamically.", "configspace": "", "generation": 38, "fitness": 0.3259254230940338, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.23.", "error": "", "parent_id": "2442244b-e7ae-432c-b768-5a3275f24962", "metadata": {"aucs": [0.7806828199530647, 0.7403179105140761, 0.749761207096203, 0.7437351002018535, 0.7422547586057751, 0.7545929958322929, 0.7535537627469555, 0.7489236726620501, 0.761675357887737, 0.6062442212528227, 0.5763777532569886, 0.5819588108848505, 0.5394710372703809, 0.5509203761675361, 0.5605211083640753, 0.5394671996656535, 0.5630743984576695, 0.5618417824560498, 0.13901442188714008, 0.13625660992051802, 0.14144542233492285, 0.17367055120657493, 0.17730699490540303, 0.17581988604241727, 0.15406358055666203, 0.17957205113590158, 0.13308267056179446, 0.12812492863094704, 0.14194480028532797, 0.13289732965164858, 0.15237465899438563, 0.11254448473549761, 0.12907041877984504, 0.13355398953912645, 0.12418050625986199, 0.14420623897139961, 0.887155769711066, 0.8408769009974477, 0.8352716331657296, 0.8682342877856334, 0.8766241878804538, 0.8846493680238336, 0.8933381774492608, 0.8743154653129396, 0.9418761977200172, 0.3266027583811265, 0.3167190223066785, 0.3345489830272028, 0.3255116170363217, 0.3124641274171992, 0.33773571880694475, 0.30322849603344737, 0.31819706847850926, 0.3194660147589409, 0.663327086379958, 0.6700214230808077, 0.6848265215944647, 0.7068522508267706, 0.7001195716063847, 0.7086245137072056, 0.6874337293130075, 0.7159884619690349, 0.7177758821565152, 0.1433553717170395, 0.18044206247077021, 0.16509295185505524, 0.18028187926497596, 0.2666713968955393, 0.16837579738583186, 0.2998233639476704, 0.24659264627640498, 0.19274903068580496, 0.1782641951886299, 0.13181977437302972, 0.21665502951395477, 0.16055459663974703, 0.20445327619472353, 0.16065052729397433, 0.1976246048506749, 0.149239470508151, 0.1335080599465931, 0.1559063189742197, 0.17184712251803536, 0.14001218590670816, 0.1956796169463022, 0.14298850145748332, 0.17322775598754414, 0.17994366218028734, 0.1799585025271726, 0.09741797689075449, 0.2843703898892923, 0.3490963359013285, 0.3456562900596051, 0.2862152595852935, 0.20349894899408705, 0.21065982467513888, 0.33258374870033147, 0.2931357268788499, 0.3514297168246815, 0.10971641741672811, 0.05876809547926243, 0.07878200842314931, 0.1429578450432364, 0.09790599224212437, 0.10292479412555133, 0.10520060131816766, 0.07881251725719396, 0.1050998893345324, 0.2104795658489126, 0.202937224584116, 0.21177315495000426, 0.21016714919742363, 0.24003053387589002, 0.19577950098307684, 0.202849707842238, 0.22101519770501377, 0.21013353657912504, 0.5358501210784654, 0.5687325796347134, 0.550555433297179, 0.5321124514300758, 0.5046365014008675, 0.5360665037343553, 0.6201470147689343, 0.5739774942429292, 0.6378699883536221, 0.12084245863412157, 0.10800609635105263, 0.1267290545989327, 0.11179988907819494, 0.1293432859368726, 0.1228504144501803, 0.112763148165832, 0.13321393126864456, 0.11501154478545306, 0.1717787522443932, 0.18865191873923426, 0.1772077686838751, 0.20670991135765548, 0.18633318640261665, 0.19764834920673668, 0.1762414464141404, 0.20362560482986203, 0.16280633167833114, 0.398852879854958, 0.366829536596082, 0.4068396996522792, 0.35883984762832843, 0.34437488835819163, 0.3618441910831469, 0.40398539460405103, 0.4115351786749357, 0.39616219675792574, 0.2819969362125181, 0.28126773776026415, 0.26870832918963583, 0.26437044142730803, 0.308194817348421, 0.27886819617099756, 0.29400736881433653, 0.2980173316871074, 0.32553798311560844, 0.19953109516206124, 0.2047321727400535, 0.2246831938743784, 0.2566382370869935, 0.23801066883682842, 0.20067820955804394, 0.20475514122786742, 0.1914286880735968, 0.20671475174251486, 0.20234908732742285, 0.23233593626710103, 0.25511862833590404, 0.24218692259768104, 0.2617336922030612, 0.23448667431985948, 0.24398830665127202, 0.26551102409573446, 0.20931520975196016, 0.672196158736137, 0.703662516010737, 0.6299656556971335, 0.6038786140226907, 0.5503174739037415, 0.5220296232997237, 0.4631728368882815, 0.3286892354050146, 0.5309551059485893, 0.7082942642271719, 0.37063354255047376, 0.1952245071226375, 0.19824993911368716, 0.197435019238569, 0.19042170256846547, 0.530332019647262, 0.2024881103719406, 0.6360583351179672, 0.1920723986037789, 0.19255285959190704, 0.2029587462447715, 0.18282224112015832, 0.18549154128447487, 0.18977658579526713, 0.18356843844151083, 0.19763036207802753, 0.19026672498823083, 0.07789093452251106, 0.08106650335728005, 0.08778435105125848, 0.08633264238355043, 0.08349775788457048, 0.08178728630572152, 0.08290025507384802, 0.08331776896454501, 0.07682285048021675]}, "mutation_prompt": null}
{"id": "c145242e-b0e0-4c4f-a71b-f3ecb15da3b1", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5  # New adaptive learning rate\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant1 = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        d, e, f = pop[np.random.choice(indices, 3, replace=False)]\n        mutant2 = np.clip(d + self.F * (e - f), self.lower_bound, self.upper_bound)\n        return mutant1 if np.random.rand() > 0.5 else mutant2\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                # Adjust F dynamically based on budget usage\n                self.F = self.adaptive_alpha * (1.0 - evals / self.budget)\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "An adaptive learning rate strategy is integrated with hybrid differential evolution to balance exploration and exploitation dynamically.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9f3c7723-86d1-4724-9b7f-878e4b874813", "metadata": {"aucs": [0.7806828199530647, 0.7403179105140761, 0.749761207096203, 0.7437351002018535, 0.7422547586057751, 0.7545929958322929, 0.7535537627469555, 0.7489236726620501, 0.761675357887737, 0.6062442212528227, 0.5763777532569886, 0.5819588108848505, 0.5394710372703809, 0.5509203761675361, 0.5605211083640753, 0.5394671996656535, 0.5630743984576695, 0.5618417824560498, 0.13901442188714008, 0.13625660992051802, 0.14144542233492285, 0.17367055120657493, 0.17730699490540303, 0.17581988604241727, 0.15406358055666203, 0.17957205113590158, 0.13308267056179446, 0.12812492863094704, 0.14194480028532797, 0.13289732965164858, 0.15237465899438563, 0.11254448473549761, 0.12907041877984504, 0.13355398953912645, 0.12418050625986199, 0.14420623897139961, 0.887155769711066, 0.8408769009974477, 0.8352716331657296, 0.8682342877856334, 0.8766241878804538, 0.8846493680238336, 0.8933381774492608, 0.8743154653129396, 0.9418761977200172, 0.3266027583811265, 0.3167190223066785, 0.3345489830272028, 0.3255116170363217, 0.3124641274171992, 0.33773571880694475, 0.30322849603344737, 0.31819706847850926, 0.3194660147589409, 0.663327086379958, 0.6700214230808077, 0.6848265215944647, 0.7068522508267706, 0.7001195716063847, 0.7086245137072056, 0.6874337293130075, 0.7159884619690349, 0.7177758821565152, 0.1433553717170395, 0.18044206247077021, 0.16509295185505524, 0.18028187926497596, 0.2666713968955393, 0.16837579738583186, 0.2998233639476704, 0.24659264627640498, 0.19274903068580496, 0.1782641951886299, 0.13181977437302972, 0.21665502951395477, 0.16055459663974703, 0.20445327619472353, 0.16065052729397433, 0.1976246048506749, 0.149239470508151, 0.1335080599465931, 0.1559063189742197, 0.17184712251803536, 0.14001218590670816, 0.1956796169463022, 0.14298850145748332, 0.17322775598754414, 0.17994366218028734, 0.1799585025271726, 0.09741797689075449, 0.2843703898892923, 0.3490963359013285, 0.3456562900596051, 0.2862152595852935, 0.20349894899408705, 0.21065982467513888, 0.33258374870033147, 0.2931357268788499, 0.3514297168246815, 0.10971641741672811, 0.05876809547926243, 0.07878200842314931, 0.1429578450432364, 0.09790599224212437, 0.10292479412555133, 0.10520060131816766, 0.07881251725719396, 0.1050998893345324, 0.2104795658489126, 0.202937224584116, 0.21177315495000426, 0.21016714919742363, 0.24003053387589002, 0.19577950098307684, 0.202849707842238, 0.22101519770501377, 0.21013353657912504, 0.5358501210784654, 0.5687325796347134, 0.550555433297179, 0.5321124514300758, 0.5046365014008675, 0.5360665037343553, 0.6201470147689343, 0.5739774942429292, 0.6378699883536221, 0.12084245863412157, 0.10800609635105263, 0.1267290545989327, 0.11179988907819494, 0.1293432859368726, 0.1228504144501803, 0.112763148165832, 0.13321393126864456, 0.11501154478545306, 0.1717787522443932, 0.18865191873923426, 0.1772077686838751, 0.20670991135765548, 0.18633318640261665, 0.19764834920673668, 0.1762414464141404, 0.20362560482986203, 0.16280633167833114, 0.398852879854958, 0.366829536596082, 0.4068396996522792, 0.35883984762832843, 0.34437488835819163, 0.3618441910831469, 0.40398539460405103, 0.4115351786749357, 0.39616219675792574, 0.2819969362125181, 0.28126773776026415, 0.26870832918963583, 0.26437044142730803, 0.308194817348421, 0.27886819617099756, 0.29400736881433653, 0.2980173316871074, 0.32553798311560844, 0.19953109516206124, 0.2047321727400535, 0.2246831938743784, 0.2566382370869935, 0.23801066883682842, 0.20067820955804394, 0.20475514122786742, 0.1914286880735968, 0.20671475174251486, 0.20234908732742285, 0.23233593626710103, 0.25511862833590404, 0.24218692259768104, 0.2617336922030612, 0.23448667431985948, 0.24398830665127202, 0.26551102409573446, 0.20931520975196016, 0.672196158736137, 0.703662516010737, 0.6299656556971335, 0.6038786140226907, 0.5503174739037415, 0.5220296232997237, 0.4631728368882815, 0.3286892354050146, 0.5309551059485893, 0.7082942642271719, 0.37063354255047376, 0.1952245071226375, 0.19824993911368716, 0.197435019238569, 0.19042170256846547, 0.530332019647262, 0.2024881103719406, 0.6360583351179672, 0.1920723986037789, 0.19255285959190704, 0.2029587462447715, 0.18282224112015832, 0.18549154128447487, 0.18977658579526713, 0.18356843844151083, 0.19763036207802753, 0.19026672498823083, 0.07789093452251106, 0.08106650335728005, 0.08778435105125848, 0.08633264238355043, 0.08349775788457048, 0.08178728630572152, 0.08290025507384802, 0.08331776896454501, 0.07682285048021675]}, "mutation_prompt": null}
{"id": "d441081f-b4f8-4141-86e2-49322b6a9dbb", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5  # New adaptive learning rate\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant1 = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        d, e, f = pop[np.random.choice(indices, 3, replace=False)]\n        mutant2 = np.clip(d + self.F * (e - f), self.lower_bound, self.upper_bound)\n        return mutant1 if np.random.rand() > 0.5 else mutant2\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                # Adjust F dynamically based on budget usage\n                self.F = self.adaptive_alpha * (1.0 - evals / self.budget)\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "An adaptive learning rate strategy is integrated with hybrid differential evolution to balance exploration and exploitation dynamically.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9f3c7723-86d1-4724-9b7f-878e4b874813", "metadata": {"aucs": [0.7806828199530647, 0.7403179105140761, 0.749761207096203, 0.7437351002018535, 0.7422547586057751, 0.7545929958322929, 0.7535537627469555, 0.7489236726620501, 0.761675357887737, 0.6062442212528227, 0.5763777532569886, 0.5819588108848505, 0.5394710372703809, 0.5509203761675361, 0.5605211083640753, 0.5394671996656535, 0.5630743984576695, 0.5618417824560498, 0.13901442188714008, 0.13625660992051802, 0.14144542233492285, 0.17367055120657493, 0.17730699490540303, 0.17581988604241727, 0.15406358055666203, 0.17957205113590158, 0.13308267056179446, 0.12812492863094704, 0.14194480028532797, 0.13289732965164858, 0.15237465899438563, 0.11254448473549761, 0.12907041877984504, 0.13355398953912645, 0.12418050625986199, 0.14420623897139961, 0.887155769711066, 0.8408769009974477, 0.8352716331657296, 0.8682342877856334, 0.8766241878804538, 0.8846493680238336, 0.8933381774492608, 0.8743154653129396, 0.9418761977200172, 0.3266027583811265, 0.3167190223066785, 0.3345489830272028, 0.3255116170363217, 0.3124641274171992, 0.33773571880694475, 0.30322849603344737, 0.31819706847850926, 0.3194660147589409, 0.663327086379958, 0.6700214230808077, 0.6848265215944647, 0.7068522508267706, 0.7001195716063847, 0.7086245137072056, 0.6874337293130075, 0.7159884619690349, 0.7177758821565152, 0.1433553717170395, 0.18044206247077021, 0.16509295185505524, 0.18028187926497596, 0.2666713968955393, 0.16837579738583186, 0.2998233639476704, 0.24659264627640498, 0.19274903068580496, 0.1782641951886299, 0.13181977437302972, 0.21665502951395477, 0.16055459663974703, 0.20445327619472353, 0.16065052729397433, 0.1976246048506749, 0.149239470508151, 0.1335080599465931, 0.1559063189742197, 0.17184712251803536, 0.14001218590670816, 0.1956796169463022, 0.14298850145748332, 0.17322775598754414, 0.17994366218028734, 0.1799585025271726, 0.09741797689075449, 0.2843703898892923, 0.3490963359013285, 0.3456562900596051, 0.2862152595852935, 0.20349894899408705, 0.21065982467513888, 0.33258374870033147, 0.2931357268788499, 0.3514297168246815, 0.10971641741672811, 0.05876809547926243, 0.07878200842314931, 0.1429578450432364, 0.09790599224212437, 0.10292479412555133, 0.10520060131816766, 0.07881251725719396, 0.1050998893345324, 0.2104795658489126, 0.202937224584116, 0.21177315495000426, 0.21016714919742363, 0.24003053387589002, 0.19577950098307684, 0.202849707842238, 0.22101519770501377, 0.21013353657912504, 0.5358501210784654, 0.5687325796347134, 0.550555433297179, 0.5321124514300758, 0.5046365014008675, 0.5360665037343553, 0.6201470147689343, 0.5739774942429292, 0.6378699883536221, 0.12084245863412157, 0.10800609635105263, 0.1267290545989327, 0.11179988907819494, 0.1293432859368726, 0.1228504144501803, 0.112763148165832, 0.13321393126864456, 0.11501154478545306, 0.1717787522443932, 0.18865191873923426, 0.1772077686838751, 0.20670991135765548, 0.18633318640261665, 0.19764834920673668, 0.1762414464141404, 0.20362560482986203, 0.16280633167833114, 0.398852879854958, 0.366829536596082, 0.4068396996522792, 0.35883984762832843, 0.34437488835819163, 0.3618441910831469, 0.40398539460405103, 0.4115351786749357, 0.39616219675792574, 0.2819969362125181, 0.28126773776026415, 0.26870832918963583, 0.26437044142730803, 0.308194817348421, 0.27886819617099756, 0.29400736881433653, 0.2980173316871074, 0.32553798311560844, 0.19953109516206124, 0.2047321727400535, 0.2246831938743784, 0.2566382370869935, 0.23801066883682842, 0.20067820955804394, 0.20475514122786742, 0.1914286880735968, 0.20671475174251486, 0.20234908732742285, 0.23233593626710103, 0.25511862833590404, 0.24218692259768104, 0.2617336922030612, 0.23448667431985948, 0.24398830665127202, 0.26551102409573446, 0.20931520975196016, 0.672196158736137, 0.703662516010737, 0.6299656556971335, 0.6038786140226907, 0.5503174739037415, 0.5220296232997237, 0.4631728368882815, 0.3286892354050146, 0.5309551059485893, 0.7082942642271719, 0.37063354255047376, 0.1952245071226375, 0.19824993911368716, 0.197435019238569, 0.19042170256846547, 0.530332019647262, 0.2024881103719406, 0.6360583351179672, 0.1920723986037789, 0.19255285959190704, 0.2029587462447715, 0.18282224112015832, 0.18549154128447487, 0.18977658579526713, 0.18356843844151083, 0.19763036207802753, 0.19026672498823083, 0.07789093452251106, 0.08106650335728005, 0.08778435105125848, 0.08633264238355043, 0.08349775788457048, 0.08178728630572152, 0.08290025507384802, 0.08331776896454501, 0.07682285048021675]}, "mutation_prompt": null}
{"id": "1b3c3819-1703-406a-8d21-252459f9aaf2", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant1 = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        d, e, f = pop[np.random.choice(indices, 3, replace=False)]\n        mutant2 = np.clip(d + self.F * (e - f), self.lower_bound, self.upper_bound)\n        return mutant1 if np.random.rand() > 0.5 else mutant2\n\n    def _crossover(self, target, mutant):\n        dynamic_cr = self.CR * (1.0 - (self.budget - self.population_size) / self.budget)\n        cross_points = np.random.rand(self.dim) < dynamic_cr\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.2) * scale  # Increased randomness\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                self.F = self.adaptive_alpha * (1.0 - evals / self.budget)\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "Introducing dynamic crossover probability and enhanced local search randomness to optimize exploration-exploitation balance in hybrid differential evolution.", "configspace": "", "generation": 41, "fitness": 0.2347723346707929, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "9f3c7723-86d1-4724-9b7f-878e4b874813", "metadata": {"aucs": [0.6796784179741838, 0.6566939462697887, 0.6570536056655071, 0.6845532942172581, 0.6453308399052745, 0.6696051226704066, 0.6549554451077448, 0.6617597954358732, 0.6698023063882584, 0.4167995061485539, 0.41945713420013275, 0.4057222501247295, 0.3977619974774429, 0.4181088103216759, 0.43046839119013514, 0.4137724759887085, 0.4248471478634903, 0.4374158286986016, 0.29363866941433314, 0.29381608729717656, 0.32093387785471694, 0.345546943230691, 0.3281788102020854, 0.3189625215335159, 0.30864556331617354, 0.3623990757268303, 0.29255621000307297, 0.2911954204979347, 0.3093304392041514, 0.2921194570624217, 0.27424090648489163, 0.2960127886379843, 0.2627844888833303, 0.2592660206387857, 0.26974363329335305, 0.30484816441384444, 0.9050472353904478, 0.87957583897458, 0.9361656876838027, 0.8955947708475611, 0.8853765269237946, 0.9228951980624293, 0.900358385958347, 0.8816144191631683, 0.9222291102182739, 0.14666535225748611, 0.13516678029302676, 0.1383436713742665, 0.11845332567621936, 0.11509253423485555, 0.1563126590845646, 0.14499783960327928, 0.15174926950278, 0.17046194115271884, 0.15589461650454173, 0.15686227643659134, 0.15331920326369197, 0.2638204181197066, 0.25385781026302867, 0.21136660677951935, 0.1714896937613123, 0.21703234822352846, 0.21354852102559618, 0.1597570439724908, 0.15709670493202188, 0.16687285870579982, 0.1299053023394663, 0.20606803140917962, 0.17658474039438987, 0.20761442786702522, 0.14583767262489544, 0.1630511820339582, 0.1377403661291382, 0.1253720404437283, 0.13679136370718203, 0.13677410856345995, 0.15055290268468546, 0.12300200053724852, 0.12790236168814684, 0.11186242212822395, 0.1317095408545118, 9.999999999998899e-05, 9.999999999998899e-05, 0.00014113562773743205, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08651762885221193, 0.07085443981746409, 0.12702522906328173, 0.09024354736326934, 0.09454382645513815, 0.10350381358625094, 0.1211801962037482, 0.09028551709616173, 0.08229837229016845, 0.002218602886587373, 0.0001495308429384501, 0.0018586302219005812, 0.004631911391924204, 0.005339379376850362, 0.007034268795328202, 0.00011614232198520202, 0.006589132002095877, 0.00013530228923774867, 0.05580817522141146, 0.06751362778515291, 0.060493708155363146, 0.09111155954452532, 0.08184726639111572, 0.08913248997029843, 0.09202445215952015, 0.08316276309359583, 0.08629783674817404, 0.41010158295668586, 0.3840243696898442, 0.37804698432178885, 0.4000969236410812, 0.3789297924281009, 0.39609873823030206, 0.407093102716649, 0.38561914781779805, 0.4122915363333933, 0.11005918967785455, 0.09504055919446253, 0.11933849762437643, 0.08837729573983866, 0.08388725409176823, 0.09528507368027417, 0.08552989667119659, 0.09301258678620739, 0.10348085214699443, 0.2159243946423448, 0.1844037548647237, 0.17985600428388493, 0.18023772207637578, 0.18719422052757262, 0.25229183895551854, 0.20001337328455737, 0.2090703513882035, 0.17479262986585986, 0.19991758303745344, 0.19383723525288155, 0.2115963216419301, 0.23060706102673179, 0.19439122107625606, 0.20260599529735146, 0.2253619908716994, 0.21457615478601388, 0.20534070082710032, 0.13924823491670946, 0.15190927910140417, 0.14305045573750663, 0.14801249201180544, 0.15098857291220535, 0.1623792254522809, 0.15105781096936333, 0.17082673411669091, 0.167147374280475, 0.1951079568590246, 0.1874967735377987, 0.19841527839071416, 0.1908469714802441, 0.18758528184918777, 0.18603527187788682, 0.19450177333300267, 0.18781591697991984, 0.18820156837171031, 0.24377721347694625, 0.20769515750021905, 0.23578264039989427, 0.2170238235553026, 0.24808390834932703, 0.21623260032598757, 0.25456011029307135, 0.2176480456517247, 0.2037878761839671, 0.3152250756435133, 0.21657522400300677, 0.19428856920109616, 0.5609395745200796, 0.22299575823935425, 0.27633055599177436, 0.29059186136427007, 0.17298134954085942, 0.1770182786546215, 0.23511838039751543, 0.25288517363514906, 0.1841766146819288, 0.2534870123614308, 0.16972285559628875, 0.19658705490897121, 0.21461936193702413, 0.24727916030017316, 0.23686444506530857, 0.18277444358356487, 0.19015212734827414, 0.19032512469705098, 0.20131284634406554, 0.18660412321251474, 0.18000534970740378, 0.21310843565320392, 0.18039623986467523, 0.18250534014189368, 0.07846226727206795, 0.06993000302555041, 0.07683824103042547, 0.07956921497610858, 0.0847303577517643, 0.0818902206598412, 0.07821132132560982, 0.06477601712353187, 0.06934503307074358]}, "mutation_prompt": null}
{"id": "5d2deb5b-7ef5-4fd3-b335-6dbaa284f71e", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        gaussian_mutation = np.random.normal(0, 0.1, self.dim)\n        return np.clip(mutant + gaussian_mutation, self.lower_bound, self.upper_bound)\n\n    def _crossover(self, target, mutant):\n        self.CR = 0.9 * (1 - self.adaptive_alpha)  # Adaptive crossover rate\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                self.F = self.adaptive_alpha * (1.0 - evals / self.budget)\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced exploration and exploitation by introducing adaptive crossover rate and Gaussian mutation.", "configspace": "", "generation": 42, "fitness": 0.21482983955414758, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.17.", "error": "", "parent_id": "9f3c7723-86d1-4724-9b7f-878e4b874813", "metadata": {"aucs": [0.4819193209586127, 0.4787515421634567, 0.4778684803967599, 0.48191847891803674, 0.478025869337352, 0.46719486962063295, 0.4801434192388945, 0.47503717641283516, 0.49776016600485695, 0.13820477138357967, 0.12969206163098734, 0.1320753188456354, 0.17489327383363729, 0.1401634034847239, 0.14615604665851256, 0.12778904676028435, 0.1357666638991295, 0.1298496277734883, 0.159072835928187, 0.16789919966232647, 0.16808962386280002, 0.16737233502874116, 0.17400380786165193, 0.15547863228545955, 0.15991820057786876, 0.1405693084520211, 0.16705521502073295, 0.1340535373046834, 0.13565848217068577, 0.13576225871939773, 0.12394646787953556, 0.15026428456124086, 0.14287399795398292, 0.13847498031107186, 0.13810242588394595, 0.12885429905720613, 0.8327615540014234, 0.8344868704450181, 0.8424917768991612, 0.8354501374616361, 0.8508629292896129, 0.8525258295509139, 0.8490610483635519, 0.8774136063177962, 0.8884789530451702, 0.2198223603808317, 0.20699841453960155, 0.1944294322390665, 0.21626391937913325, 0.1943141725923434, 0.2230820556709293, 0.17609562497575593, 0.20751562103458954, 0.19077461098174986, 0.22785171053939035, 0.24308376888877614, 0.24354420192001403, 0.2729652894211757, 0.2862040692757267, 0.312572096572328, 0.2697005576462731, 0.2692033894220206, 0.26030686225538757, 0.15495271009590728, 0.2025078918581401, 0.1884182048561781, 0.1584890610798002, 0.17007315350942642, 0.16146340663973224, 0.15140387456453952, 0.16862953193830654, 0.19182802263630205, 0.12035651834171257, 0.16353473222900217, 0.12959320031839128, 0.13886631282136896, 0.16108625808528265, 0.1671709475384452, 0.12068102296691252, 0.14136443446351676, 0.15318794077226427, 0.004942770876502411, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00742268146895364, 9.999999999998899e-05, 0.01138063213136753, 0.09572140619948111, 0.09670160379669945, 0.1126636124620154, 0.09267426551899571, 0.09671800344786408, 0.09225872721190265, 0.08802580914278313, 0.0794500575795346, 0.1043977705456336, 0.0037645837287491046, 0.009854356637570394, 0.006912304674630443, 0.0098317403898589, 0.00724182926003436, 0.012058843145205667, 0.009123415577364513, 0.021257560991087443, 0.00357624439343196, 0.09291716285673468, 0.07989988487082222, 0.08610529435953973, 0.09521940603485746, 0.08524490914563898, 0.0903364048341726, 0.09779224165980627, 0.10431556361989058, 0.10993722545612183, 0.40562284919352, 0.405171154754867, 0.41538848555650354, 0.4146113303643416, 0.40101510426204723, 0.39201743371943787, 0.41066229909205, 0.396726789062565, 0.4242586701439617, 0.11063442283723546, 0.09863387308195992, 0.12211105567416658, 0.11736193259839578, 0.09519489793487723, 0.11923731788847491, 0.09448249984034685, 0.10778064817880473, 0.09891662190742245, 0.1663426622106159, 0.14985745515655124, 0.19532483365854592, 0.2070461793816062, 0.16509239353616778, 0.19846583566050224, 0.20735273417018296, 0.159007872156532, 0.18997728340034659, 0.2504473903489963, 0.2502760055221914, 0.2544230159319173, 0.2513781823311443, 0.22742426450661302, 0.25001610004543173, 0.26794756807117603, 0.28019830170258486, 0.2645602319345183, 0.18248640681875516, 0.1959425968290024, 0.18119730056509387, 0.18700854097314334, 0.1729432104952241, 0.1918686712470682, 0.18373909193771587, 0.18421330647687406, 0.17803347177533413, 0.2000273203114109, 0.2132572460530323, 0.20510718007499262, 0.201752668587722, 0.17629108448543662, 0.1937956229548209, 0.2053439578866092, 0.18960563902611016, 0.20718785042565802, 0.22273902092547304, 0.22800265818546184, 0.2203370749730107, 0.2407220344704719, 0.22549802164880017, 0.2409206217463351, 0.2353668351549053, 0.22378656710787426, 0.2137166465353827, 0.2665181940106033, 0.2580278072182316, 0.3862019275197829, 0.35708331606203314, 0.30039865930266496, 0.28555380895475924, 0.2612239191388166, 0.3363162073480701, 0.3622262040855787, 0.37530625628974956, 0.2282083806654328, 0.23567569005255706, 0.28023614655091356, 0.18151420176285482, 0.26016295925084465, 0.20349905227520948, 0.34327747426281663, 0.22301556397878397, 0.19037806573673477, 0.18931844283723664, 0.1775497607168408, 0.19136660055586396, 0.1920708276696893, 0.20017550017221653, 0.17854133246935122, 0.19296101062536009, 0.17941825287958013, 0.08662614114792866, 0.08369565864205364, 0.0737803749116216, 0.07953635665494618, 0.0816654348475675, 0.07357777390804765, 0.08219599166419289, 0.07040153630802726, 0.07881034004578757]}, "mutation_prompt": null}
{"id": "2f5f627e-c7b7-41e3-bbf5-b19d5b0dc43d", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        # Diversity-aware mutation strategy\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        diversity_metric = np.std(pop, axis=0)\n        weight = np.mean(diversity_metric) / (np.mean(np.abs(a - b)) + 1e-9)\n        mutant = np.clip(a + self.F * weight * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        # Dynamic crossover rate adjustment\n        self.CR = self.adaptive_alpha * (1.0 - np.var(mutant) / np.var(target))\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                self.F = self.adaptive_alpha * (1.0 - evals / self.budget)\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduced a novel diversity-guided mutation strategy and dynamic crossover rate adjustment to improve convergence and diversity.", "configspace": "", "generation": 43, "fitness": 0.2346742547268332, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.19.", "error": "", "parent_id": "9f3c7723-86d1-4724-9b7f-878e4b874813", "metadata": {"aucs": [0.6525254094100025, 0.671504402126398, 0.6600490558501952, 0.6513120145198534, 0.6345866009982148, 0.6569633260112329, 0.6519871684208136, 0.6473989118575498, 0.6524871459931718, 0.39456072851117496, 0.3855749894384639, 0.37698616539493135, 0.39107551803687124, 0.4050626765618718, 0.3940228645143343, 0.3728024596452013, 0.3903821106194829, 0.3936141646496575, 0.2772299751209716, 0.2727317437942638, 0.26358491528380945, 0.27157822986885305, 0.302308078264636, 0.2912088959314272, 0.2550553338683359, 0.23924763496767087, 0.2871616573359538, 0.2679118386697589, 0.23963804182519144, 0.23749271754143453, 0.23708638377401492, 0.26029842708040496, 0.25124637877686584, 0.26556339107267035, 0.26541368268859034, 0.2522961133426186, 0.9088406268206556, 0.8885744230628542, 0.8375237332360841, 0.8907017217690214, 0.9108381722494124, 0.8662984328212675, 0.9017473333881983, 0.9106628660033395, 0.9034472383738336, 0.1643551987097036, 0.11489794482810811, 0.1373626269722148, 0.138442601186213, 0.1365736235583237, 0.1371926915712406, 0.139472396714726, 0.13345055295887565, 0.1624693254202051, 0.20412854729341656, 0.176379559874143, 0.14393942650515856, 0.17829269173076812, 0.22453143415313104, 0.2030973422865292, 0.19546676613106806, 0.22541920444147634, 0.22131731810583466, 0.17856087403127663, 0.1791715893584236, 0.1802536243796441, 0.1640838121313536, 0.1638235683520678, 0.1767097181918671, 0.1671315483404906, 0.22769290018634525, 0.1730608862725589, 0.14452471496584363, 0.1293049756192367, 0.14910027711678575, 0.18446770449233318, 0.14439191069629453, 0.19522481224870591, 0.13330906999042835, 0.13919215538894947, 0.13755725332888147, 9.999999999998899e-05, 9.999999999998899e-05, 0.008929340153702059, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016151545950566115, 0.012220417646826132, 0.09288339386095612, 0.08267725011421045, 0.12006555420828058, 0.07961554370288448, 0.07681425665423991, 0.1094996013335604, 0.1094627016465094, 0.13324116446832357, 0.09583066676171437, 0.003398411388284339, 0.0056012863543924984, 0.0035686913337796833, 0.0035150247297016657, 0.0012207265401479317, 0.0024891975093797036, 0.005188786639320431, 0.011281525280885996, 0.01337229494222214, 0.06111616555655708, 0.07116936768769044, 0.09133713986014769, 0.0821099243515695, 0.07882177031606663, 0.09535869359977389, 0.07700440958670096, 0.09372851924474346, 0.10122789519973396, 0.4278321117651884, 0.4117226702365998, 0.4071924120737034, 0.41181057962914613, 0.3882905769881638, 0.37718443651098243, 0.39432648913101953, 0.37364195358730323, 0.3908494209280873, 0.09563278767765548, 0.10182060558607986, 0.09203960819654733, 0.09572417776685327, 0.09535543228784515, 0.09353061079246361, 0.08419943891161386, 0.09935017084895059, 0.1349089969395758, 0.17496598476124015, 0.20031000589696524, 0.18288982897976325, 0.18731729792584972, 0.21361007810261068, 0.16274752450630348, 0.23082222872255198, 0.15244159625051612, 0.1654721836828177, 0.19504388136634243, 0.20722388327288865, 0.19510439656242862, 0.22635685156504304, 0.21473988634914354, 0.20739119553349572, 0.2137867966703887, 0.21765826086073592, 0.21210779980690986, 0.16424498465730575, 0.15186576836424814, 0.1704204370368647, 0.1813562139257776, 0.15631114805713475, 0.17175093186141, 0.16806641695816593, 0.16780332430761014, 0.1606832974750192, 0.1929283828724866, 0.21295048993696286, 0.20387582190493125, 0.19542789853789067, 0.20420150844320883, 0.23050985444977368, 0.19473388298336414, 0.23694177012301165, 0.19194926728060235, 0.20215003697967282, 0.23898065717715888, 0.21968597808695522, 0.23504105009138998, 0.24627593129545233, 0.2556678420739199, 0.26376284767587277, 0.2134222101449501, 0.2493766130546221, 0.17950525233310488, 0.30948057205516777, 0.22250348055699776, 0.38835337895363276, 0.21895363084322705, 0.36335585519683256, 0.22187697275965645, 0.329445429314672, 0.3410357953497799, 0.2422655226186028, 0.2439955303502861, 0.28856282729173033, 0.33557968746604905, 0.3902897598549431, 0.19470349811120657, 0.20927317749646712, 0.2182598458611935, 0.23737542092321928, 0.18069819517112096, 0.1942185192270427, 0.18494558338145806, 0.17952874591712176, 0.19493130343278298, 0.18854393329708896, 0.19669189778637208, 0.18692468369327142, 0.1857180264768925, 0.07553932089253435, 0.0725369896186625, 0.06882712869600671, 0.07444072918079658, 0.07951458598861649, 0.07196477172138549, 0.07575171852328255, 0.07244041271949242, 0.07338449785868273]}, "mutation_prompt": null}
{"id": "4c75b669-79ce-40c6-9916-9d50c24f1709", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5  # New adaptive learning rate\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant1 = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        d, e, f = pop[np.random.choice(indices, 3, replace=False)]\n        mutant2 = np.clip(d + self.F * (e - f), self.lower_bound, self.upper_bound)\n        return mutant1 if np.random.rand() > 0.5 else mutant2\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                # Adjust F dynamically based on budget usage\n                self.F = self.adaptive_alpha * (1.0 - evals / self.budget)\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "An adaptive learning rate strategy is integrated with hybrid differential evolution to balance exploration and exploitation dynamically.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9f3c7723-86d1-4724-9b7f-878e4b874813", "metadata": {"aucs": [0.7806828199530647, 0.7403179105140761, 0.749761207096203, 0.7437351002018535, 0.7422547586057751, 0.7545929958322929, 0.7535537627469555, 0.7489236726620501, 0.761675357887737, 0.6062442212528227, 0.5763777532569886, 0.5819588108848505, 0.5394710372703809, 0.5509203761675361, 0.5605211083640753, 0.5394671996656535, 0.5630743984576695, 0.5618417824560498, 0.13901442188714008, 0.13625660992051802, 0.14144542233492285, 0.17367055120657493, 0.17730699490540303, 0.17581988604241727, 0.15406358055666203, 0.17957205113590158, 0.13308267056179446, 0.12812492863094704, 0.14194480028532797, 0.13289732965164858, 0.15237465899438563, 0.11254448473549761, 0.12907041877984504, 0.13355398953912645, 0.12418050625986199, 0.14420623897139961, 0.887155769711066, 0.8408769009974477, 0.8352716331657296, 0.8682342877856334, 0.8766241878804538, 0.8846493680238336, 0.8933381774492608, 0.8743154653129396, 0.9418761977200172, 0.3266027583811265, 0.3167190223066785, 0.3345489830272028, 0.3255116170363217, 0.3124641274171992, 0.33773571880694475, 0.30322849603344737, 0.31819706847850926, 0.3194660147589409, 0.663327086379958, 0.6700214230808077, 0.6848265215944647, 0.7068522508267706, 0.7001195716063847, 0.7086245137072056, 0.6874337293130075, 0.7159884619690349, 0.7177758821565152, 0.1433553717170395, 0.18044206247077021, 0.16509295185505524, 0.18028187926497596, 0.2666713968955393, 0.16837579738583186, 0.2998233639476704, 0.24659264627640498, 0.19274903068580496, 0.1782641951886299, 0.13181977437302972, 0.21665502951395477, 0.16055459663974703, 0.20445327619472353, 0.16065052729397433, 0.1976246048506749, 0.149239470508151, 0.1335080599465931, 0.1559063189742197, 0.17184712251803536, 0.14001218590670816, 0.1956796169463022, 0.14298850145748332, 0.17322775598754414, 0.17994366218028734, 0.1799585025271726, 0.09741797689075449, 0.2843703898892923, 0.3490963359013285, 0.3456562900596051, 0.2862152595852935, 0.20349894899408705, 0.21065982467513888, 0.33258374870033147, 0.2931357268788499, 0.3514297168246815, 0.10971641741672811, 0.05876809547926243, 0.07878200842314931, 0.1429578450432364, 0.09790599224212437, 0.10292479412555133, 0.10520060131816766, 0.07881251725719396, 0.1050998893345324, 0.2104795658489126, 0.202937224584116, 0.21177315495000426, 0.21016714919742363, 0.24003053387589002, 0.19577950098307684, 0.202849707842238, 0.22101519770501377, 0.21013353657912504, 0.5358501210784654, 0.5687325796347134, 0.550555433297179, 0.5321124514300758, 0.5046365014008675, 0.5360665037343553, 0.6201470147689343, 0.5739774942429292, 0.6378699883536221, 0.12084245863412157, 0.10800609635105263, 0.1267290545989327, 0.11179988907819494, 0.1293432859368726, 0.1228504144501803, 0.112763148165832, 0.13321393126864456, 0.11501154478545306, 0.1717787522443932, 0.18865191873923426, 0.1772077686838751, 0.20670991135765548, 0.18633318640261665, 0.19764834920673668, 0.1762414464141404, 0.20362560482986203, 0.16280633167833114, 0.398852879854958, 0.366829536596082, 0.4068396996522792, 0.35883984762832843, 0.34437488835819163, 0.3618441910831469, 0.40398539460405103, 0.4115351786749357, 0.39616219675792574, 0.2819969362125181, 0.28126773776026415, 0.26870832918963583, 0.26437044142730803, 0.308194817348421, 0.27886819617099756, 0.29400736881433653, 0.2980173316871074, 0.32553798311560844, 0.19953109516206124, 0.2047321727400535, 0.2246831938743784, 0.2566382370869935, 0.23801066883682842, 0.20067820955804394, 0.20475514122786742, 0.1914286880735968, 0.20671475174251486, 0.20234908732742285, 0.23233593626710103, 0.25511862833590404, 0.24218692259768104, 0.2617336922030612, 0.23448667431985948, 0.24398830665127202, 0.26551102409573446, 0.20931520975196016, 0.672196158736137, 0.703662516010737, 0.6299656556971335, 0.6038786140226907, 0.5503174739037415, 0.5220296232997237, 0.4631728368882815, 0.3286892354050146, 0.5309551059485893, 0.7082942642271719, 0.37063354255047376, 0.1952245071226375, 0.19824993911368716, 0.197435019238569, 0.19042170256846547, 0.530332019647262, 0.2024881103719406, 0.6360583351179672, 0.1920723986037789, 0.19255285959190704, 0.2029587462447715, 0.18282224112015832, 0.18549154128447487, 0.18977658579526713, 0.18356843844151083, 0.19763036207802753, 0.19026672498823083, 0.07789093452251106, 0.08106650335728005, 0.08778435105125848, 0.08633264238355043, 0.08349775788457048, 0.08178728630572152, 0.08290025507384802, 0.08331776896454501, 0.07682285048021675]}, "mutation_prompt": null}
{"id": "7dc91385-c2d7-4b91-9e97-c7e0129fcfbd", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant1 = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        d, e, f = pop[np.random.choice(indices, 3, replace=False)]\n        mutant2 = np.clip(d + self.F * (e - f), self.lower_bound, self.upper_bound)\n        return mutant1 if np.random.rand() > 0.5 else mutant2\n\n    def _crossover(self, target, mutant, evals):\n        # Adjust CR dynamically based on budget usage\n        self.CR = 0.9 - 0.5 * (evals / self.budget)\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                self.F = self.adaptive_alpha * (1.0 - evals / self.budget)\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant, evals)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    # Dynamically adjust local search scale factor\n                    scale_factor = 0.5 + 0.5 * (1 - (evals / self.budget))\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduce adaptive crossover probability and dynamic local search scaling to improve convergence speed and solution quality.", "configspace": "", "generation": 45, "fitness": 0.29675922089899714, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.23.", "error": "", "parent_id": "9f3c7723-86d1-4724-9b7f-878e4b874813", "metadata": {"aucs": [0.7416529674798065, 0.746118659232465, 0.7359967808563096, 0.7429678033408997, 0.747646968404668, 0.7526213847329776, 0.749644594500325, 0.7484891846439388, 0.7523312628303712, 0.5400907474201193, 0.5501507419165345, 0.5466356075410665, 0.5663542968936983, 0.5421284776081503, 0.5389809267727821, 0.5518041113500045, 0.5599785523704675, 0.553419835039126, 0.19050021734321498, 0.17151124517552652, 0.21185483669536465, 0.18078437745132891, 0.18791396758065915, 0.20007442419365062, 0.18655999458524752, 0.15950437148191632, 0.18499718737361637, 0.16618384729778535, 0.1414015038094627, 0.150391947156563, 0.1623034852141283, 0.13725783775399558, 0.16005367308731855, 0.13072149807913536, 0.13396515262166764, 0.1453199771192638, 0.8575808199151963, 0.9130801736483263, 0.8897011577533077, 0.9549627905223932, 0.8749391749474136, 0.9505665083812739, 0.9272621955519984, 0.9057964673811117, 0.9552562400242135, 0.3255978665882371, 0.31419509141607993, 0.29734374213087644, 0.3018368188507994, 0.29534820634425807, 0.31400779388323463, 0.2846714022717942, 0.27659036978981644, 0.3056872534549844, 0.5581971153422106, 0.7327800718573507, 0.6298016902354853, 0.6429629598129694, 0.618427465253959, 0.6635030813457018, 0.6159623000341757, 0.6587240673481405, 0.6437919620344119, 0.18741757033400008, 0.13267028208052467, 0.14878804008334723, 0.1699195912174699, 0.15129889378548977, 0.1252444265253977, 0.1662697322231408, 0.18484274908096887, 0.1886479846732817, 0.18669892740659166, 0.1340839147131977, 0.17574360490667984, 0.14182619538295438, 0.18559188592260978, 0.1589572847484103, 0.18207683982385092, 0.1658000546651519, 0.1612403334468443, 0.12134017756643911, 0.07997845781147261, 0.040075893835328724, 0.1001859088295961, 0.08561705976078315, 0.0638031048425961, 0.05728917271576406, 0.062187182576898925, 0.0632447802250441, 0.2016285869032265, 0.18729954992489106, 0.14085424988963802, 0.11199261976651576, 0.1951181604396398, 0.21887564897355483, 0.2397420249798824, 0.20796787737951894, 0.19095634409633722, 0.029232680635651542, 0.04630715478070235, 0.010523693716479987, 0.025718980155811866, 0.06657981435408289, 0.021853162686019667, 0.027499050078318432, 0.06995014192814542, 0.04504143457637344, 0.1534029886010574, 0.15300876604957014, 0.14012542658824767, 0.1723253332883985, 0.17442914059565973, 0.16173291867317252, 0.13653053818937655, 0.1391318621255574, 0.15096613415109728, 0.5012767592478903, 0.5055724021778077, 0.4879837078876891, 0.4848011457976682, 0.505072970053414, 0.49924681744115595, 0.52152903342068, 0.493239783593895, 0.5224389372054836, 0.13993082541500956, 0.12750255409643252, 0.12452379888994869, 0.12918986037644786, 0.10898269470628308, 0.11286426230507418, 0.11802057267993782, 0.12224920269867234, 0.12426579557012285, 0.2190733608227763, 0.17398378902862732, 0.18261482787833916, 0.21219926690355195, 0.1515539474454849, 0.21592341949553895, 0.17985589342482722, 0.18474863164845223, 0.2097053766265452, 0.35221488363770437, 0.3385118548593852, 0.35092265236656617, 0.352871212391193, 0.31660869359761445, 0.32144195930163, 0.3626849541476046, 0.3812417326066616, 0.37237518806543735, 0.22919855528739985, 0.2344770227175239, 0.2610869472187485, 0.21588612027088927, 0.23065260223389328, 0.2294066859725311, 0.2556689911738338, 0.2721285019596674, 0.2456481139685558, 0.20802140026496263, 0.1869148638820738, 0.20946447887731678, 0.20657186302629538, 0.20080147836545925, 0.2048419840447735, 0.22458516096286663, 0.19749608880489034, 0.1969393359538436, 0.24262041114621602, 0.21686708051387815, 0.25372026830191596, 0.20271287336098998, 0.23208630423554033, 0.272452422305716, 0.1927769483971089, 0.24806197748128866, 0.2121432147912916, 0.18440498902291158, 0.5876745236414591, 0.698552934227618, 0.6357874029408694, 0.2669029424778796, 0.5264106528822837, 0.281066648381443, 0.19917698476494627, 0.5584448283095619, 0.34776351660859495, 0.18812498402883215, 0.4327543290573548, 0.20194196493764205, 0.5377239398003661, 0.19038064856195613, 0.1997731115068705, 0.20646282376758995, 0.41514392190615, 0.18628549085947566, 0.20123602155149833, 0.17724686714425897, 0.1870707075052176, 0.19264781729722746, 0.19291764817993495, 0.1862985506746212, 0.20054284923913634, 0.1766651052253998, 0.07979150305185445, 0.0759232693863654, 0.08141135546090061, 0.08205996960251871, 0.08177551998533905, 0.08479822041502649, 0.07930885263694232, 0.09105481932430337, 0.07748997070397545]}, "mutation_prompt": null}
{"id": "7e8d511a-7b75-4b7a-aac8-76a2031de995", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5\n        self.elitism_rate = 0.1  # New elitism rate for competitive co-evolution\n        self.secondary_mut_prob = 0.3  # Probability for secondary mutation\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant1 = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        if np.random.rand() < self.secondary_mut_prob:  # Apply secondary mutation\n            a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n            mutant2 = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n            return mutant2 if np.random.rand() > 0.5 else mutant1\n        return mutant1\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            next_population = []  # For elitism\n            for i in range(self.population_size):\n                self.F = self.adaptive_alpha * (1.0 - evals / self.budget)\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    next_population.append(trial)\n                    fitness[i] = trial_fitness\n                else:\n                    next_population.append(population[i])\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        next_population[-1] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n            # Apply elitism\n            best_indices = np.argsort(fitness)[:int(self.elitism_rate * self.population_size)]\n            population = [population[i] for i in best_indices] + next_population[int(self.elitism_rate * self.population_size):]\n            fitness = [fitness[i] for i in best_indices] + fitness[int(self.elitism_rate * self.population_size):]\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduce a competitive co-evolution strategy by implementing an elitist selection mechanism and secondary mutation to enhance diversity.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (6,) (54,) ').", "error": "ValueError('operands could not be broadcast together with shapes (6,) (54,) ')", "parent_id": "9f3c7723-86d1-4724-9b7f-878e4b874813", "metadata": {}, "mutation_prompt": null}
{"id": "33805610-80ee-4ba6-b88c-c6d4ac3eb854", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _opposition_learning(self, pop):\n        opp_pop = self.lower_bound + self.upper_bound - pop\n        return np.clip(opp_pop, self.lower_bound, self.upper_bound)\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant, evals):\n        self.CR = 0.85 * (1 - evals / self.budget)\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        opp_population = self._opposition_learning(population)\n        fitness = np.array([func(ind) for ind in population])\n        opp_fitness = np.array([func(ind) for ind in opp_population])\n        evals = 2 * self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                self.F = self.adaptive_alpha * (1.0 - evals / self.budget)\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant, evals)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced strategy employs opposition-based learning and dynamic crossover to improve convergence and diversity.", "configspace": "", "generation": 47, "fitness": 0.26345591586457595, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "9f3c7723-86d1-4724-9b7f-878e4b874813", "metadata": {"aucs": [0.7470340784448154, 0.7374374825374389, 0.7029570404629666, 0.7205531946059862, 0.7539727398845566, 0.7145257447400156, 0.7396566830585142, 0.7230552011447615, 0.7428673270324406, 0.49263490444843694, 0.5251828016475921, 0.5279742069981206, 0.5550895518014899, 0.5165243386404293, 0.4888173113930002, 0.5367027299115901, 0.5290205661830774, 0.5192082200516117, 0.21072275645670846, 0.23595013199670078, 0.23578777266806805, 0.23075656735513117, 0.21607098952473502, 0.20012697750690467, 0.23093084810872044, 0.23755020097454327, 0.2627467199296877, 0.21918294944665395, 0.18950653334851408, 0.18049592524652014, 0.2236961168180286, 0.1918064081480182, 0.1806874289291287, 0.20055133826073857, 0.18954315444657244, 0.1820617183487505, 0.9064540795736828, 0.89992760427228, 0.8923951672753281, 0.8837835742459849, 0.8376794041616124, 0.894871763711795, 0.899718236500458, 0.9148325190419874, 0.9119347155038104, 0.2596462715808763, 0.2716749777331813, 0.2675242181691344, 0.3013765109528135, 0.2378603536561381, 0.29028251045008213, 0.233837915218019, 0.22652795399819636, 0.24757681595521852, 0.28423837012863395, 0.2725574641528621, 0.3005930858900441, 0.32611803971661735, 0.4305226476314673, 0.28924813609144195, 0.3052822205556466, 0.4874061837075174, 0.469128780808011, 0.20433827938226745, 0.16166188618915167, 0.14701339094613408, 0.18210109449516965, 0.20948106102514585, 0.16738639617058038, 0.18996576368508344, 0.16355258265000872, 0.17593511286397878, 0.12797755770198582, 0.12509985887658093, 0.15451438998137978, 0.18827878009963928, 0.14229975516152027, 0.1728491154284948, 0.1400660591353622, 0.18732292619108903, 0.13502902289274155, 0.011927391866120685, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03795634264055292, 0.0001593554440467715, 9.999999999998899e-05, 0.08214843463072141, 0.002731720254327441, 0.13483074820605123, 0.10116720104689958, 0.12666016522295231, 0.1416208762982416, 0.12892800846626795, 0.0918274272968922, 0.15452644282298933, 0.15409964780275986, 0.10046424721322367, 0.012038803234851736, 0.015569779835887476, 0.013668743949561746, 0.02746424056173624, 0.005491171077039891, 0.014739452357069194, 0.024500734707421867, 0.028719465086893825, 0.039576177585798344, 0.13567133874619797, 0.12129061714702383, 0.1173250788572654, 0.14638512333773923, 0.15716679129083422, 0.1308046400688041, 0.10800718209530369, 0.10054810844634432, 0.1097424086841986, 0.44113098254261474, 0.4627179306720093, 0.4638886253098964, 0.44840877036899596, 0.4505110833821756, 0.45607647982561916, 0.46560086185341387, 0.4549936588305896, 0.4568946233172553, 0.12409786743526963, 0.11432414806049096, 0.11363793785916498, 0.10741804190625659, 0.12213487622532071, 0.124769665573079, 0.10558532629136408, 0.11822876438156527, 0.11353264097607485, 0.17704290299214787, 0.1766115314136919, 0.23170433515083644, 0.2044081770380446, 0.1899856047766516, 0.2156279463658337, 0.21594769233815292, 0.178396548887919, 0.2055060327160385, 0.2953879617125854, 0.2828809829902812, 0.29602823783727095, 0.26925674094284, 0.2918717422485354, 0.26357599457455394, 0.31915684922102894, 0.33235934983004656, 0.3268174277367729, 0.2183041830256901, 0.23034791785069597, 0.22837146640974026, 0.21199574357039452, 0.19994142065626352, 0.2212252382238531, 0.22536076786168813, 0.23733756252533855, 0.21224286464525843, 0.21427845608580798, 0.2040320881827945, 0.26468271677466615, 0.20310678162325402, 0.2184864068510466, 0.18439318127021886, 0.2206820316913436, 0.20684999601342802, 0.19747133291690266, 0.22392185298620437, 0.2209246022785506, 0.26205884071591357, 0.244309111504328, 0.24965948618796518, 0.2143566786358574, 0.24082171561530474, 0.2122988508282151, 0.25496326795757884, 0.2611178700301836, 0.30351346938971757, 0.17485816023001555, 0.2399160612384763, 0.1853543534519807, 0.1954346069386388, 0.26159459821666764, 0.22894198482211192, 0.3860108549361073, 0.3081557139221216, 0.32454534631561005, 0.20892824056563142, 0.2831821274518238, 0.24436847551442475, 0.32913807175707543, 0.20305959799510398, 0.2668961965601999, 0.19805286107941178, 0.19000814296256718, 0.20365863636718062, 0.18727613124815135, 0.1952442729233037, 0.17860481084285562, 0.1915752819347568, 0.193507199533284, 0.18257792703552023, 0.18974082012775784, 0.09055646224746339, 0.08906763754379443, 0.0812712917508448, 0.0814510387520031, 0.09022439845335961, 0.08672036642881265, 0.0900949926675283, 0.07941987433601139, 0.07604796436308148]}, "mutation_prompt": null}
{"id": "19fff801-6a1c-4deb-9c6a-041f4b9e020c", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.9  # Adjusted crossover rate\n        self.local_search_prob = 0.35  # Reduced local search probability\n        self.adaptive_alpha = 0.5\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        neighborhood_radius = 0.1  # New neighborhood radius for mutation control\n        neighborhood_control = np.random.uniform(-neighborhood_radius, neighborhood_radius, self.dim)\n        mutant = np.clip(a + self.F * (b - c) + neighborhood_control, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.10) * scale  # Reduced max step size\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                self.F = self.adaptive_alpha * (1.0 - evals / self.budget)\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced adaptive differential evolution leverages adaptive mutation control and neighborhood selection to improve convergence speed and solution quality.", "configspace": "", "generation": 48, "fitness": 0.2474172890704964, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.20.", "error": "", "parent_id": "9f3c7723-86d1-4724-9b7f-878e4b874813", "metadata": {"aucs": [0.505626962147337, 0.48912614530820153, 0.5045622840046315, 0.5016944258646345, 0.4833279097602734, 0.48461260399605777, 0.5035976215017289, 0.4788408857343216, 0.5301515901783718, 0.09801260346582186, 0.11144340353192383, 0.08569953773901107, 0.08376135904695603, 0.09282145560760235, 0.11396930049861875, 0.09546306491212586, 0.0803122527944099, 0.08698300133736425, 0.16533939218651472, 0.12973608633760558, 0.1234235593637597, 0.12367484667578954, 0.12468869561902152, 0.11886085447521821, 0.135322555305047, 0.12997641617601363, 0.11884851291068621, 0.11922582257628545, 0.10797725215771137, 0.12572244955899425, 0.10770294862261975, 0.11463358028379356, 0.10600434761658195, 0.11906585975422845, 0.10200972874103431, 0.11011786021857206, 0.8398139326417334, 0.8953133695644172, 0.8302353766131705, 0.8561503369677324, 0.8633464498753024, 0.9148811231234313, 0.8631217111488312, 0.8547711586099929, 0.8417389212917313, 0.29880513865419456, 0.2884052717252049, 0.28463180120416254, 0.2773510132075212, 0.29959338335381913, 0.29023618569303644, 0.2815460716772219, 0.2891526221780597, 0.29722142766862714, 0.5723085121640528, 0.6506991672835263, 0.5986536394960609, 0.6848466502875861, 0.7551552239525232, 0.677422931473695, 0.6659649948985353, 0.7355314043924388, 0.6463469821151882, 0.1515440833754692, 0.1774153878168514, 0.1654881725787587, 0.1584543060332153, 0.15851918971479606, 0.16472717243286916, 0.15288551320759525, 0.17900559615749556, 0.18972170351030404, 0.13227122540877867, 0.1382513923234705, 0.14545045223383057, 0.14554362990554126, 0.1625363029942377, 0.14622076594712619, 0.19751922023473223, 0.22344550767256255, 0.14791266613288612, 0.05117556733449313, 0.07030665877267805, 0.061342229889704725, 0.05300043013439992, 0.03882631800165104, 0.038643975732823854, 0.06568747016752019, 0.06658385998374794, 0.053501783118586, 0.13817539659930722, 0.11952785452182357, 0.14576023335243915, 0.12751252246418676, 0.16663019121291855, 0.09998271206396458, 0.13201305312718725, 0.14013874342542598, 0.13107211445211142, 0.007171979923097926, 0.007925965704556281, 0.01678601373411659, 0.011843554324993288, 0.013495686583147704, 0.007063367161883605, 0.013611834793604394, 0.013647385187712469, 0.0025021763420111087, 0.12293583841095246, 0.12934680606984383, 0.140501619112677, 0.1305795483630845, 0.12789906394105288, 0.1307751475974197, 0.12389950807201744, 0.1366760258621783, 0.1335202346271699, 0.4341976558258771, 0.4258327641707964, 0.4305009061892533, 0.44144958102933873, 0.42980165309981444, 0.4322102335709106, 0.43143418181914184, 0.4155592480889455, 0.4404378223881077, 0.11747726302065531, 0.11534016108979417, 0.1290026559926266, 0.12070471456157916, 0.11848402438999506, 0.12708627161419372, 0.09725576617993281, 0.12015233033482642, 0.12549017194034406, 0.18993830771550302, 0.15864213742394528, 0.18209403666666468, 0.17645098681099936, 0.17231346335617181, 0.24233071877897794, 0.16919354502890271, 0.1784241632122997, 0.1794838770240582, 0.30661629168257387, 0.30167299944190884, 0.2974410674423802, 0.30941581917759453, 0.29807995119635156, 0.29277186816954603, 0.2992759702190858, 0.3037025890935674, 0.3000846126722774, 0.23964418040385405, 0.24039472568022546, 0.26192187939707223, 0.23501141079205234, 0.23994763226568838, 0.22699047016549456, 0.23755044760185484, 0.24596641187414203, 0.24737191438383765, 0.21607900898718868, 0.21143645380839693, 0.23129995617265542, 0.20273742224255653, 0.1922643966912072, 0.20934209429098194, 0.2010285819859945, 0.20082010829726382, 0.19905559396894634, 0.23793690411171653, 0.20465189995932387, 0.20820672292750697, 0.20572288398925154, 0.2008312724723299, 0.20057373923253075, 0.2852774705730924, 0.18648408677213135, 0.20409169076355171, 0.1949643212910226, 0.18380100400510846, 0.5330059833818908, 0.6530984207030728, 0.4797849424381153, 0.1914872376890112, 0.6232810433611826, 0.5211210110263563, 0.4313047389279564, 0.19763229217148792, 0.20368093421634081, 0.2031173338520782, 0.49652688215626606, 0.1969631948612416, 0.19770011434304413, 0.2094960127805302, 0.2031641568911533, 0.20819012996044117, 0.1858709780290525, 0.1774012002070362, 0.18728409745720742, 0.18719992207430958, 0.19097824935276908, 0.18828427662483072, 0.18496462084327958, 0.18284934512288598, 0.1888092080757685, 0.08492563010280663, 0.09229107471803566, 0.09079204537982699, 0.08432309633526458, 0.08806359105749473, 0.0817383434718798, 0.08093731633986567, 0.09362903883242701, 0.08792634579872005]}, "mutation_prompt": null}
{"id": "86031cdb-37a4-4dd4-b8ef-0467fa3e2cab", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5  # New adaptive learning rate\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant1 = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        d, e, f = pop[np.random.choice(indices, 3, replace=False)]\n        mutant2 = np.clip(d + self.F * (e - f), self.lower_bound, self.upper_bound)\n        return mutant1 if np.random.rand() > 0.5 else mutant2\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                # Adjust F dynamically based on budget usage\n                self.F = self.adaptive_alpha * (1.0 - evals / self.budget)\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "An adaptive learning rate strategy is integrated with hybrid differential evolution to balance exploration and exploitation dynamically.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9f3c7723-86d1-4724-9b7f-878e4b874813", "metadata": {"aucs": [0.7806828199530647, 0.7403179105140761, 0.749761207096203, 0.7437351002018535, 0.7422547586057751, 0.7545929958322929, 0.7535537627469555, 0.7489236726620501, 0.761675357887737, 0.6062442212528227, 0.5763777532569886, 0.5819588108848505, 0.5394710372703809, 0.5509203761675361, 0.5605211083640753, 0.5394671996656535, 0.5630743984576695, 0.5618417824560498, 0.13901442188714008, 0.13625660992051802, 0.14144542233492285, 0.17367055120657493, 0.17730699490540303, 0.17581988604241727, 0.15406358055666203, 0.17957205113590158, 0.13308267056179446, 0.12812492863094704, 0.14194480028532797, 0.13289732965164858, 0.15237465899438563, 0.11254448473549761, 0.12907041877984504, 0.13355398953912645, 0.12418050625986199, 0.14420623897139961, 0.887155769711066, 0.8408769009974477, 0.8352716331657296, 0.8682342877856334, 0.8766241878804538, 0.8846493680238336, 0.8933381774492608, 0.8743154653129396, 0.9418761977200172, 0.3266027583811265, 0.3167190223066785, 0.3345489830272028, 0.3255116170363217, 0.3124641274171992, 0.33773571880694475, 0.30322849603344737, 0.31819706847850926, 0.3194660147589409, 0.663327086379958, 0.6700214230808077, 0.6848265215944647, 0.7068522508267706, 0.7001195716063847, 0.7086245137072056, 0.6874337293130075, 0.7159884619690349, 0.7177758821565152, 0.1433553717170395, 0.18044206247077021, 0.16509295185505524, 0.18028187926497596, 0.2666713968955393, 0.16837579738583186, 0.2998233639476704, 0.24659264627640498, 0.19274903068580496, 0.1782641951886299, 0.13181977437302972, 0.21665502951395477, 0.16055459663974703, 0.20445327619472353, 0.16065052729397433, 0.1976246048506749, 0.149239470508151, 0.1335080599465931, 0.1559063189742197, 0.17184712251803536, 0.14001218590670816, 0.1956796169463022, 0.14298850145748332, 0.17322775598754414, 0.17994366218028734, 0.1799585025271726, 0.09741797689075449, 0.2843703898892923, 0.3490963359013285, 0.3456562900596051, 0.2862152595852935, 0.20349894899408705, 0.21065982467513888, 0.33258374870033147, 0.2931357268788499, 0.3514297168246815, 0.10971641741672811, 0.05876809547926243, 0.07878200842314931, 0.1429578450432364, 0.09790599224212437, 0.10292479412555133, 0.10520060131816766, 0.07881251725719396, 0.1050998893345324, 0.2104795658489126, 0.202937224584116, 0.21177315495000426, 0.21016714919742363, 0.24003053387589002, 0.19577950098307684, 0.202849707842238, 0.22101519770501377, 0.21013353657912504, 0.5358501210784654, 0.5687325796347134, 0.550555433297179, 0.5321124514300758, 0.5046365014008675, 0.5360665037343553, 0.6201470147689343, 0.5739774942429292, 0.6378699883536221, 0.12084245863412157, 0.10800609635105263, 0.1267290545989327, 0.11179988907819494, 0.1293432859368726, 0.1228504144501803, 0.112763148165832, 0.13321393126864456, 0.11501154478545306, 0.1717787522443932, 0.18865191873923426, 0.1772077686838751, 0.20670991135765548, 0.18633318640261665, 0.19764834920673668, 0.1762414464141404, 0.20362560482986203, 0.16280633167833114, 0.398852879854958, 0.366829536596082, 0.4068396996522792, 0.35883984762832843, 0.34437488835819163, 0.3618441910831469, 0.40398539460405103, 0.4115351786749357, 0.39616219675792574, 0.2819969362125181, 0.28126773776026415, 0.26870832918963583, 0.26437044142730803, 0.308194817348421, 0.27886819617099756, 0.29400736881433653, 0.2980173316871074, 0.32553798311560844, 0.19953109516206124, 0.2047321727400535, 0.2246831938743784, 0.2566382370869935, 0.23801066883682842, 0.20067820955804394, 0.20475514122786742, 0.1914286880735968, 0.20671475174251486, 0.20234908732742285, 0.23233593626710103, 0.25511862833590404, 0.24218692259768104, 0.2617336922030612, 0.23448667431985948, 0.24398830665127202, 0.26551102409573446, 0.20931520975196016, 0.672196158736137, 0.703662516010737, 0.6299656556971335, 0.6038786140226907, 0.5503174739037415, 0.5220296232997237, 0.4631728368882815, 0.3286892354050146, 0.5309551059485893, 0.7082942642271719, 0.37063354255047376, 0.1952245071226375, 0.19824993911368716, 0.197435019238569, 0.19042170256846547, 0.530332019647262, 0.2024881103719406, 0.6360583351179672, 0.1920723986037789, 0.19255285959190704, 0.2029587462447715, 0.18282224112015832, 0.18549154128447487, 0.18977658579526713, 0.18356843844151083, 0.19763036207802753, 0.19026672498823083, 0.07789093452251106, 0.08106650335728005, 0.08778435105125848, 0.08633264238355043, 0.08349775788457048, 0.08178728630572152, 0.08290025507384802, 0.08331776896454501, 0.07682285048021675]}, "mutation_prompt": null}
{"id": "fb52e4be-8f75-470a-b1cb-9eeb0cb6b0f6", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant1 = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        d, e, f = pop[np.random.choice(indices, 3, replace=False)]\n        mutant2 = np.clip(d + self.F * (e - f), self.lower_bound, self.upper_bound)\n        return mutant1 if np.random.rand() > 0.5 else mutant2\n\n    def _crossover(self, target, mutant):\n        diversity = np.mean(np.std(population, axis=0))\n        self.CR = 0.9 - 0.5 * diversity  # Adaptive CR adjustment based on diversity\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                self.F = self.adaptive_alpha * (1.0 - evals / self.budget)\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduce an adaptive crossover rate based on population diversity to further enhance convergence in EnhancedHybridDifferentialEvolution.", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'population' is not defined\").", "error": "NameError(\"name 'population' is not defined\")", "parent_id": "9f3c7723-86d1-4724-9b7f-878e4b874813", "metadata": {}, "mutation_prompt": null}
{"id": "11ec8115-b4c3-4131-9fcd-7b81fbcd7b55", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5  # New adaptive learning rate\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant1 = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        d, e, f = pop[np.random.choice(indices, 3, replace=False)]\n        mutant2 = np.clip(d + self.F * (e - f), self.lower_bound, self.upper_bound)\n        return mutant1 if np.random.rand() > 0.5 else mutant2\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                # Adjust F dynamically based on budget usage\n                self.F = self.adaptive_alpha * (1.0 - evals / self.budget)\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "An adaptive learning rate strategy is integrated with hybrid differential evolution to balance exploration and exploitation dynamically.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9f3c7723-86d1-4724-9b7f-878e4b874813", "metadata": {"aucs": [0.7806828199530647, 0.7403179105140761, 0.749761207096203, 0.7437351002018535, 0.7422547586057751, 0.7545929958322929, 0.7535537627469555, 0.7489236726620501, 0.761675357887737, 0.6062442212528227, 0.5763777532569886, 0.5819588108848505, 0.5394710372703809, 0.5509203761675361, 0.5605211083640753, 0.5394671996656535, 0.5630743984576695, 0.5618417824560498, 0.13901442188714008, 0.13625660992051802, 0.14144542233492285, 0.17367055120657493, 0.17730699490540303, 0.17581988604241727, 0.15406358055666203, 0.17957205113590158, 0.13308267056179446, 0.12812492863094704, 0.14194480028532797, 0.13289732965164858, 0.15237465899438563, 0.11254448473549761, 0.12907041877984504, 0.13355398953912645, 0.12418050625986199, 0.14420623897139961, 0.887155769711066, 0.8408769009974477, 0.8352716331657296, 0.8682342877856334, 0.8766241878804538, 0.8846493680238336, 0.8933381774492608, 0.8743154653129396, 0.9418761977200172, 0.3266027583811265, 0.3167190223066785, 0.3345489830272028, 0.3255116170363217, 0.3124641274171992, 0.33773571880694475, 0.30322849603344737, 0.31819706847850926, 0.3194660147589409, 0.663327086379958, 0.6700214230808077, 0.6848265215944647, 0.7068522508267706, 0.7001195716063847, 0.7086245137072056, 0.6874337293130075, 0.7159884619690349, 0.7177758821565152, 0.1433553717170395, 0.18044206247077021, 0.16509295185505524, 0.18028187926497596, 0.2666713968955393, 0.16837579738583186, 0.2998233639476704, 0.24659264627640498, 0.19274903068580496, 0.1782641951886299, 0.13181977437302972, 0.21665502951395477, 0.16055459663974703, 0.20445327619472353, 0.16065052729397433, 0.1976246048506749, 0.149239470508151, 0.1335080599465931, 0.1559063189742197, 0.17184712251803536, 0.14001218590670816, 0.1956796169463022, 0.14298850145748332, 0.17322775598754414, 0.17994366218028734, 0.1799585025271726, 0.09741797689075449, 0.2843703898892923, 0.3490963359013285, 0.3456562900596051, 0.2862152595852935, 0.20349894899408705, 0.21065982467513888, 0.33258374870033147, 0.2931357268788499, 0.3514297168246815, 0.10971641741672811, 0.05876809547926243, 0.07878200842314931, 0.1429578450432364, 0.09790599224212437, 0.10292479412555133, 0.10520060131816766, 0.07881251725719396, 0.1050998893345324, 0.2104795658489126, 0.202937224584116, 0.21177315495000426, 0.21016714919742363, 0.24003053387589002, 0.19577950098307684, 0.202849707842238, 0.22101519770501377, 0.21013353657912504, 0.5358501210784654, 0.5687325796347134, 0.550555433297179, 0.5321124514300758, 0.5046365014008675, 0.5360665037343553, 0.6201470147689343, 0.5739774942429292, 0.6378699883536221, 0.12084245863412157, 0.10800609635105263, 0.1267290545989327, 0.11179988907819494, 0.1293432859368726, 0.1228504144501803, 0.112763148165832, 0.13321393126864456, 0.11501154478545306, 0.1717787522443932, 0.18865191873923426, 0.1772077686838751, 0.20670991135765548, 0.18633318640261665, 0.19764834920673668, 0.1762414464141404, 0.20362560482986203, 0.16280633167833114, 0.398852879854958, 0.366829536596082, 0.4068396996522792, 0.35883984762832843, 0.34437488835819163, 0.3618441910831469, 0.40398539460405103, 0.4115351786749357, 0.39616219675792574, 0.2819969362125181, 0.28126773776026415, 0.26870832918963583, 0.26437044142730803, 0.308194817348421, 0.27886819617099756, 0.29400736881433653, 0.2980173316871074, 0.32553798311560844, 0.19953109516206124, 0.2047321727400535, 0.2246831938743784, 0.2566382370869935, 0.23801066883682842, 0.20067820955804394, 0.20475514122786742, 0.1914286880735968, 0.20671475174251486, 0.20234908732742285, 0.23233593626710103, 0.25511862833590404, 0.24218692259768104, 0.2617336922030612, 0.23448667431985948, 0.24398830665127202, 0.26551102409573446, 0.20931520975196016, 0.672196158736137, 0.703662516010737, 0.6299656556971335, 0.6038786140226907, 0.5503174739037415, 0.5220296232997237, 0.4631728368882815, 0.3286892354050146, 0.5309551059485893, 0.7082942642271719, 0.37063354255047376, 0.1952245071226375, 0.19824993911368716, 0.197435019238569, 0.19042170256846547, 0.530332019647262, 0.2024881103719406, 0.6360583351179672, 0.1920723986037789, 0.19255285959190704, 0.2029587462447715, 0.18282224112015832, 0.18549154128447487, 0.18977658579526713, 0.18356843844151083, 0.19763036207802753, 0.19026672498823083, 0.07789093452251106, 0.08106650335728005, 0.08778435105125848, 0.08633264238355043, 0.08349775788457048, 0.08178728630572152, 0.08290025507384802, 0.08331776896454501, 0.07682285048021675]}, "mutation_prompt": null}
{"id": "431c20a9-af7a-4d1f-89f0-80736adfa169", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        dynamic_F = self.adaptive_alpha * np.random.uniform(0.4, 0.9) * (1.0 - len(pop) / self.population_size)\n        mutant = np.clip(a + dynamic_F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                self.F = self.adaptive_alpha * (1.0 - evals / self.budget)\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                dynamic_local_prob = self.local_search_prob * (1 - evals / self.budget)\n                if np.random.rand() < dynamic_local_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "Incorporate adaptive mutation strategies and dynamic local search probability to enhance convergence speed and adaptability.", "configspace": "", "generation": 52, "fitness": 0.1951999967826589, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.17.", "error": "", "parent_id": "9f3c7723-86d1-4724-9b7f-878e4b874813", "metadata": {"aucs": [0.5236486097726181, 0.48044866981932033, 0.522769823538286, 0.5360549070127546, 0.4831874181446264, 0.5148665419580956, 0.5697327001678245, 0.47087633618033087, 0.49415723007155443, 0.0077839731685702684, 0.0718981433499184, 9.999999999998899e-05, 0.06661914214495124, 0.05730532749598061, 0.06111536191786404, 9.999999999998899e-05, 0.11606847899851869, 9.999999999998899e-05, 0.1490691572159476, 0.07295927238861821, 0.12119062656781188, 0.10878565635937898, 0.055027435079097686, 0.11293912813918594, 0.09147462292248898, 0.12258447980577636, 0.06403243337323727, 0.07532601113640791, 0.043378140799874565, 0.11068270190447871, 0.10338071246670877, 0.09697202372601332, 0.13081218646842696, 0.13677992000576922, 0.07645256394023758, 0.11167328325409964, 0.7159071749056574, 0.7865421315853259, 0.7544618756554465, 0.8237341523375359, 0.784361629399807, 0.8286967476585688, 0.7904097094034751, 0.7299301641671183, 0.7295444053005847, 0.16856801824976975, 0.13231333806225465, 0.10656906164057778, 0.2397201848114069, 0.08221696688780045, 0.23306417800140966, 0.22785118109801583, 0.11082835765389787, 0.25421725805136375, 0.2157770860604047, 0.17885668493653817, 0.13123947477555453, 0.26221983033541574, 0.18844037259489654, 0.10082847401717432, 0.15765758252332618, 0.35694528933729774, 0.16448611556565973, 0.09507700031278854, 0.10483062715847025, 0.13660662485389252, 0.15501992670798914, 0.23715013844105504, 9.999999999998899e-05, 0.2888442758485541, 0.15091313422344887, 0.291815736115572, 0.1282616524272846, 0.2364321170063809, 0.13977628574457068, 0.12878234875522243, 0.14053390836593294, 0.13709595083546477, 0.17380291062446063, 0.14715543291853883, 0.11176075532627505, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0026852589619500433, 0.014839414975258314, 9.999999999998899e-05, 9.999999999998899e-05, 0.026008561668195984, 0.05919347289497434, 0.07006496066923396, 0.045533293213942505, 0.032576849327652924, 0.04580363562048695, 0.04999829567692726, 0.04825838170981278, 0.1520391789619242, 0.13116843834854353, 0.019360833073631012, 0.009239801054759078, 0.020044132983767282, 0.031202651093859446, 0.023101945450812345, 0.025973450515619723, 0.015981467218098233, 0.008885530679684228, 0.01906916170448225, 0.14317471725883513, 0.05234979302159737, 0.09393601562396847, 0.11422790915166203, 0.14898190108217313, 0.08292723465774621, 0.1231402242628512, 0.05869070412873567, 0.0917291006666574, 0.418400673910447, 0.40540547146415484, 0.43074020257738677, 0.4382123023582961, 0.3793609497045053, 0.40588338143895797, 0.440490719647583, 0.393419417209078, 0.41093064585723293, 0.07818315209461402, 0.13254256074087223, 0.12703483441581342, 0.06025605745904672, 0.0779438924094864, 0.09119700044684254, 0.09334992733572767, 0.03910551203557766, 0.10243298312847715, 0.1376278637546695, 0.14957437395485373, 0.20447962971008526, 0.3008990924678835, 0.3272580407735003, 0.18562021355967062, 0.23718754506714512, 0.23517092763141256, 0.18720056682256236, 0.18402761183057081, 0.3278124565762539, 0.1660409551567824, 0.20176028703016158, 0.20832850986638352, 0.20967698411661873, 0.17275011146346075, 0.20115332493213167, 0.19271202930684495, 0.17305206091905223, 0.2337093688392461, 0.11309222130897656, 0.2061754475025992, 0.20802638345655, 0.2302797214997362, 0.17117920735737135, 0.2356788055088478, 0.18594307290347112, 0.19279909735702372, 0.18020578768809914, 0.18532260789867439, 0.21483107774893528, 0.16328340830888888, 0.2071856077423787, 0.24492660890826567, 0.1958304815183305, 0.18768409641104422, 0.16926813601061097, 0.1789105517433225, 0.2053031390069927, 0.1963016138177044, 0.24444421129335558, 0.17013445030650887, 0.17037604237594917, 0.21510100931069887, 0.20272640700629618, 0.18155386462258283, 0.187280276378044, 0.508726673302418, 0.16697988474676473, 0.1958244772515263, 0.11282458311213761, 0.531525164292159, 0.1433278331384501, 0.17258874988694062, 0.2346580371472946, 0.5321376379103169, 0.1923871879586514, 0.13145199335995716, 0.12984339908909825, 0.3381993696363004, 0.19444322665421365, 0.27463078419430786, 0.3513615127473019, 0.1809013218019282, 0.17763578574236294, 0.1825883693956606, 0.17942513402146543, 0.18678560805029287, 0.19218945325200443, 0.18780604677234358, 0.1768682798261514, 0.2086283028671554, 0.07970790056795884, 0.08237992091783386, 0.06094658977711842, 0.0837176317759426, 0.09719259287646165, 0.05886860028254537, 0.08108644535083931, 0.07084817836632806, 0.07945205034264324]}, "mutation_prompt": null}
{"id": "e574cccb-2419-4c43-bf2f-a4b51d9b1cf9", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5  # New adaptive learning rate\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant1 = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        d, e, f = pop[np.random.choice(indices, 3, replace=False)]\n        mutant2 = np.clip(d + self.F * (e - f), self.lower_bound, self.upper_bound)\n        return mutant1 if np.random.rand() > 0.5 else mutant2\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                # Adjust F dynamically based on budget usage\n                self.F = self.adaptive_alpha * (1.0 - evals / self.budget)\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "An adaptive learning rate strategy is integrated with hybrid differential evolution to balance exploration and exploitation dynamically.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9f3c7723-86d1-4724-9b7f-878e4b874813", "metadata": {"aucs": [0.7806828199530647, 0.7403179105140761, 0.749761207096203, 0.7437351002018535, 0.7422547586057751, 0.7545929958322929, 0.7535537627469555, 0.7489236726620501, 0.761675357887737, 0.6062442212528227, 0.5763777532569886, 0.5819588108848505, 0.5394710372703809, 0.5509203761675361, 0.5605211083640753, 0.5394671996656535, 0.5630743984576695, 0.5618417824560498, 0.13901442188714008, 0.13625660992051802, 0.14144542233492285, 0.17367055120657493, 0.17730699490540303, 0.17581988604241727, 0.15406358055666203, 0.17957205113590158, 0.13308267056179446, 0.12812492863094704, 0.14194480028532797, 0.13289732965164858, 0.15237465899438563, 0.11254448473549761, 0.12907041877984504, 0.13355398953912645, 0.12418050625986199, 0.14420623897139961, 0.887155769711066, 0.8408769009974477, 0.8352716331657296, 0.8682342877856334, 0.8766241878804538, 0.8846493680238336, 0.8933381774492608, 0.8743154653129396, 0.9418761977200172, 0.3266027583811265, 0.3167190223066785, 0.3345489830272028, 0.3255116170363217, 0.3124641274171992, 0.33773571880694475, 0.30322849603344737, 0.31819706847850926, 0.3194660147589409, 0.663327086379958, 0.6700214230808077, 0.6848265215944647, 0.7068522508267706, 0.7001195716063847, 0.7086245137072056, 0.6874337293130075, 0.7159884619690349, 0.7177758821565152, 0.1433553717170395, 0.18044206247077021, 0.16509295185505524, 0.18028187926497596, 0.2666713968955393, 0.16837579738583186, 0.2998233639476704, 0.24659264627640498, 0.19274903068580496, 0.1782641951886299, 0.13181977437302972, 0.21665502951395477, 0.16055459663974703, 0.20445327619472353, 0.16065052729397433, 0.1976246048506749, 0.149239470508151, 0.1335080599465931, 0.1559063189742197, 0.17184712251803536, 0.14001218590670816, 0.1956796169463022, 0.14298850145748332, 0.17322775598754414, 0.17994366218028734, 0.1799585025271726, 0.09741797689075449, 0.2843703898892923, 0.3490963359013285, 0.3456562900596051, 0.2862152595852935, 0.20349894899408705, 0.21065982467513888, 0.33258374870033147, 0.2931357268788499, 0.3514297168246815, 0.10971641741672811, 0.05876809547926243, 0.07878200842314931, 0.1429578450432364, 0.09790599224212437, 0.10292479412555133, 0.10520060131816766, 0.07881251725719396, 0.1050998893345324, 0.2104795658489126, 0.202937224584116, 0.21177315495000426, 0.21016714919742363, 0.24003053387589002, 0.19577950098307684, 0.202849707842238, 0.22101519770501377, 0.21013353657912504, 0.5358501210784654, 0.5687325796347134, 0.550555433297179, 0.5321124514300758, 0.5046365014008675, 0.5360665037343553, 0.6201470147689343, 0.5739774942429292, 0.6378699883536221, 0.12084245863412157, 0.10800609635105263, 0.1267290545989327, 0.11179988907819494, 0.1293432859368726, 0.1228504144501803, 0.112763148165832, 0.13321393126864456, 0.11501154478545306, 0.1717787522443932, 0.18865191873923426, 0.1772077686838751, 0.20670991135765548, 0.18633318640261665, 0.19764834920673668, 0.1762414464141404, 0.20362560482986203, 0.16280633167833114, 0.398852879854958, 0.366829536596082, 0.4068396996522792, 0.35883984762832843, 0.34437488835819163, 0.3618441910831469, 0.40398539460405103, 0.4115351786749357, 0.39616219675792574, 0.2819969362125181, 0.28126773776026415, 0.26870832918963583, 0.26437044142730803, 0.308194817348421, 0.27886819617099756, 0.29400736881433653, 0.2980173316871074, 0.32553798311560844, 0.19953109516206124, 0.2047321727400535, 0.2246831938743784, 0.2566382370869935, 0.23801066883682842, 0.20067820955804394, 0.20475514122786742, 0.1914286880735968, 0.20671475174251486, 0.20234908732742285, 0.23233593626710103, 0.25511862833590404, 0.24218692259768104, 0.2617336922030612, 0.23448667431985948, 0.24398830665127202, 0.26551102409573446, 0.20931520975196016, 0.672196158736137, 0.703662516010737, 0.6299656556971335, 0.6038786140226907, 0.5503174739037415, 0.5220296232997237, 0.4631728368882815, 0.3286892354050146, 0.5309551059485893, 0.7082942642271719, 0.37063354255047376, 0.1952245071226375, 0.19824993911368716, 0.197435019238569, 0.19042170256846547, 0.530332019647262, 0.2024881103719406, 0.6360583351179672, 0.1920723986037789, 0.19255285959190704, 0.2029587462447715, 0.18282224112015832, 0.18549154128447487, 0.18977658579526713, 0.18356843844151083, 0.19763036207802753, 0.19026672498823083, 0.07789093452251106, 0.08106650335728005, 0.08778435105125848, 0.08633264238355043, 0.08349775788457048, 0.08178728630572152, 0.08290025507384802, 0.08331776896454501, 0.07682285048021675]}, "mutation_prompt": null}
{"id": "376343fe-fbb8-434e-ac8b-3925df5f71c2", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5  # New adaptive learning rate\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        scale_factor = 1 - (self.adaptive_alpha * self.F * (idx / self.population_size))  # Dynamic scaling\n        mutant = np.clip(a + scale_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        perturbation = np.random.normal(0, 1, self.dim) * step_size  # Adaptive step size\n        new_individual = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                # Adjust F dynamically based on budget usage\n                self.F = self.adaptive_alpha * (1.0 - evals / self.budget)\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "Integrates dynamic scaling in mutation and an improved local search algorithm with adaptive step size.", "configspace": "", "generation": 54, "fitness": 0.20582314167249544, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.18.", "error": "", "parent_id": "9f3c7723-86d1-4724-9b7f-878e4b874813", "metadata": {"aucs": [0.4205709561684202, 0.4331251006372967, 0.41869087012881523, 0.468310360535657, 0.4501290271553551, 0.4779239432614325, 0.4443367808245029, 0.48593281291023893, 0.4428535162427185, 0.1477682194026102, 0.15665249895683342, 0.14535877659734875, 0.18764676578008077, 0.1402993240857413, 0.18333931927459612, 0.16206228080715923, 0.1663885357332474, 0.15519398628697878, 0.10985658005989551, 0.1367881935211177, 0.1026481186257675, 0.11189876645148267, 0.10843654538954428, 0.0990609538902496, 0.1302726494963281, 0.14617241747851062, 0.11765986480174162, 0.10464276455746091, 0.08936617046236572, 0.08567761268251939, 0.08695696069319914, 0.09064015735167419, 0.0888400584019311, 0.10084317436657253, 0.09348483061941626, 0.09951735590844668, 0.9243584012666779, 0.9467945337846063, 0.9539426134051863, 0.916053697189943, 0.9479800395925556, 0.9354485833076274, 0.9422950881456378, 0.953336910188116, 0.9009781713000511, 0.15858309960869044, 0.14914793650103075, 0.16069976023683286, 0.18120746808191945, 0.15734475179365126, 0.1742043414482357, 0.2110294477790282, 0.18046962363800234, 0.1798342182092827, 0.24879893431408828, 0.2541350643428948, 0.23774040982366573, 0.2605027448660596, 0.20816944181044794, 0.4829265967026303, 0.2054989524808708, 0.24115527872092823, 0.2417635928461409, 0.11577230793597759, 0.0988729822505271, 0.12833165940339875, 0.11000390939186855, 0.13654440709484883, 0.1560237013235084, 0.1409614252026955, 0.12535377358114563, 0.13369090182296373, 0.15849672884331834, 0.19141168360520444, 0.14138919923983229, 0.08610391067097245, 0.11600521310553036, 0.11121390354256977, 0.12163937898472466, 0.11536447774584357, 0.10410426853411248, 0.03640063396110238, 0.02339676395098811, 0.024972736837860943, 0.026498936046641886, 0.04339761650513263, 0.04057595403289105, 0.02415619877252062, 0.0188669949062773, 0.03404125888958298, 0.13798889843941975, 0.13282265046423614, 0.1264985700831105, 0.1364898125961168, 0.1198707589487632, 0.1092894576913288, 0.12579425368787434, 0.14351793922441558, 0.1377125010509408, 0.0064271619394610235, 0.008116529856150745, 0.0032724277547285796, 0.007453059868352652, 0.0039961787447234665, 0.010705230107312502, 0.007021084110255482, 0.02778419009283739, 0.0101970680756156, 0.09146784061936764, 0.09799352170145703, 0.09496208709293041, 0.11176565725167997, 0.0757642384752939, 0.10698488311629029, 0.10214493429888594, 0.10368754149246673, 0.0970666230261753, 0.3747935131643598, 0.36015596023992025, 0.3775776968769814, 0.36647653155155313, 0.3394309140848938, 0.3950795201967322, 0.3721506381629194, 0.34433810073497295, 0.36288182380823186, 0.10531339123887318, 0.10395625904257855, 0.09883684326183939, 0.09561645707011834, 0.0858745856024078, 0.1051911503043873, 0.10984911410233889, 0.08942965168292993, 0.10083220206943277, 0.15895622039193458, 0.20970894979966792, 0.1549842458652887, 0.25958447909641824, 0.17930881031445356, 0.1648027001502842, 0.19623557992341623, 0.17694772393529035, 0.16994801773782708, 0.20856475083229808, 0.20423632830000182, 0.22001735599819372, 0.187288131573351, 0.2029216000289068, 0.2006981898235043, 0.248272765830872, 0.23355334591778198, 0.2280957984957307, 0.1572272029347478, 0.16621570001584185, 0.13578245795900112, 0.13113325337755155, 0.1446411375391493, 0.1469119816853972, 0.16107857965429462, 0.17335864436847515, 0.1579219433694219, 0.17458455317304833, 0.21135138375266815, 0.178166251670002, 0.18454062884322386, 0.1791808969408456, 0.18747125195913827, 0.17375809019703192, 0.2151291224863271, 0.1890828272733932, 0.18114735500224055, 0.18035167238051786, 0.1904296295406812, 0.23485988995291462, 0.18689628679880943, 0.19064274623793287, 0.21112273238432333, 0.17470107239531119, 0.17959637655287974, 0.2880667129235478, 0.38010876577625163, 0.22892411750774266, 0.48664783334431083, 0.19001785142859173, 0.2017512823759, 0.16856862691879282, 0.2014312065269267, 0.24706229459408036, 0.42389704103849724, 0.22272385421265384, 0.2977920729049407, 0.19184352487947176, 0.21878046260495754, 0.16287737509359468, 0.3072714107506864, 0.47690023411318394, 0.3157471217877934, 0.1870905167537359, 0.19277701988904672, 0.18872159820707757, 0.20472336841825456, 0.2239680547262849, 0.19744267522676917, 0.1819018363770476, 0.19790899000452267, 0.1937052187484254, 0.07651734232835639, 0.076595731459844, 0.06859268460310908, 0.06530669964794777, 0.07562467387139837, 0.07085913025268986, 0.06264793410904279, 0.07024250586723124, 0.07943583940615628]}, "mutation_prompt": null}
{"id": "45cf6d3b-b85e-4f8b-9ecd-af77a41fd4b3", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5  # New adaptive learning rate\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant1 = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        d, e, f = pop[np.random.choice(indices, 3, replace=False)]\n        mutant2 = np.clip(d + self.F * (e - f), self.lower_bound, self.upper_bound)\n        return mutant1 if np.random.rand() > 0.5 else mutant2\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                # Adjust F dynamically based on budget usage\n                self.F = self.adaptive_alpha * (1.0 - evals / self.budget)\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "An adaptive learning rate strategy is integrated with hybrid differential evolution to balance exploration and exploitation dynamically.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9f3c7723-86d1-4724-9b7f-878e4b874813", "metadata": {"aucs": [0.7806828199530647, 0.7403179105140761, 0.749761207096203, 0.7437351002018535, 0.7422547586057751, 0.7545929958322929, 0.7535537627469555, 0.7489236726620501, 0.761675357887737, 0.6062442212528227, 0.5763777532569886, 0.5819588108848505, 0.5394710372703809, 0.5509203761675361, 0.5605211083640753, 0.5394671996656535, 0.5630743984576695, 0.5618417824560498, 0.13901442188714008, 0.13625660992051802, 0.14144542233492285, 0.17367055120657493, 0.17730699490540303, 0.17581988604241727, 0.15406358055666203, 0.17957205113590158, 0.13308267056179446, 0.12812492863094704, 0.14194480028532797, 0.13289732965164858, 0.15237465899438563, 0.11254448473549761, 0.12907041877984504, 0.13355398953912645, 0.12418050625986199, 0.14420623897139961, 0.887155769711066, 0.8408769009974477, 0.8352716331657296, 0.8682342877856334, 0.8766241878804538, 0.8846493680238336, 0.8933381774492608, 0.8743154653129396, 0.9418761977200172, 0.3266027583811265, 0.3167190223066785, 0.3345489830272028, 0.3255116170363217, 0.3124641274171992, 0.33773571880694475, 0.30322849603344737, 0.31819706847850926, 0.3194660147589409, 0.663327086379958, 0.6700214230808077, 0.6848265215944647, 0.7068522508267706, 0.7001195716063847, 0.7086245137072056, 0.6874337293130075, 0.7159884619690349, 0.7177758821565152, 0.1433553717170395, 0.18044206247077021, 0.16509295185505524, 0.18028187926497596, 0.2666713968955393, 0.16837579738583186, 0.2998233639476704, 0.24659264627640498, 0.19274903068580496, 0.1782641951886299, 0.13181977437302972, 0.21665502951395477, 0.16055459663974703, 0.20445327619472353, 0.16065052729397433, 0.1976246048506749, 0.149239470508151, 0.1335080599465931, 0.1559063189742197, 0.17184712251803536, 0.14001218590670816, 0.1956796169463022, 0.14298850145748332, 0.17322775598754414, 0.17994366218028734, 0.1799585025271726, 0.09741797689075449, 0.2843703898892923, 0.3490963359013285, 0.3456562900596051, 0.2862152595852935, 0.20349894899408705, 0.21065982467513888, 0.33258374870033147, 0.2931357268788499, 0.3514297168246815, 0.10971641741672811, 0.05876809547926243, 0.07878200842314931, 0.1429578450432364, 0.09790599224212437, 0.10292479412555133, 0.10520060131816766, 0.07881251725719396, 0.1050998893345324, 0.2104795658489126, 0.202937224584116, 0.21177315495000426, 0.21016714919742363, 0.24003053387589002, 0.19577950098307684, 0.202849707842238, 0.22101519770501377, 0.21013353657912504, 0.5358501210784654, 0.5687325796347134, 0.550555433297179, 0.5321124514300758, 0.5046365014008675, 0.5360665037343553, 0.6201470147689343, 0.5739774942429292, 0.6378699883536221, 0.12084245863412157, 0.10800609635105263, 0.1267290545989327, 0.11179988907819494, 0.1293432859368726, 0.1228504144501803, 0.112763148165832, 0.13321393126864456, 0.11501154478545306, 0.1717787522443932, 0.18865191873923426, 0.1772077686838751, 0.20670991135765548, 0.18633318640261665, 0.19764834920673668, 0.1762414464141404, 0.20362560482986203, 0.16280633167833114, 0.398852879854958, 0.366829536596082, 0.4068396996522792, 0.35883984762832843, 0.34437488835819163, 0.3618441910831469, 0.40398539460405103, 0.4115351786749357, 0.39616219675792574, 0.2819969362125181, 0.28126773776026415, 0.26870832918963583, 0.26437044142730803, 0.308194817348421, 0.27886819617099756, 0.29400736881433653, 0.2980173316871074, 0.32553798311560844, 0.19953109516206124, 0.2047321727400535, 0.2246831938743784, 0.2566382370869935, 0.23801066883682842, 0.20067820955804394, 0.20475514122786742, 0.1914286880735968, 0.20671475174251486, 0.20234908732742285, 0.23233593626710103, 0.25511862833590404, 0.24218692259768104, 0.2617336922030612, 0.23448667431985948, 0.24398830665127202, 0.26551102409573446, 0.20931520975196016, 0.672196158736137, 0.703662516010737, 0.6299656556971335, 0.6038786140226907, 0.5503174739037415, 0.5220296232997237, 0.4631728368882815, 0.3286892354050146, 0.5309551059485893, 0.7082942642271719, 0.37063354255047376, 0.1952245071226375, 0.19824993911368716, 0.197435019238569, 0.19042170256846547, 0.530332019647262, 0.2024881103719406, 0.6360583351179672, 0.1920723986037789, 0.19255285959190704, 0.2029587462447715, 0.18282224112015832, 0.18549154128447487, 0.18977658579526713, 0.18356843844151083, 0.19763036207802753, 0.19026672498823083, 0.07789093452251106, 0.08106650335728005, 0.08778435105125848, 0.08633264238355043, 0.08349775788457048, 0.08178728630572152, 0.08290025507384802, 0.08331776896454501, 0.07682285048021675]}, "mutation_prompt": null}
{"id": "8d14c281-2a76-488e-931c-5cf3284c7c0c", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5  # New adaptive learning rate\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant1 = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        d, e, f = pop[np.random.choice(indices, 3, replace=False)]\n        mutant2 = np.clip(d + self.F * (e - f), self.lower_bound, self.upper_bound)\n        return mutant1 if np.random.rand() > 0.5 else mutant2\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                # Adjust F dynamically based on budget usage\n                self.F = self.adaptive_alpha * (1.0 - evals / self.budget)\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "An adaptive learning rate strategy is integrated with hybrid differential evolution to balance exploration and exploitation dynamically.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9f3c7723-86d1-4724-9b7f-878e4b874813", "metadata": {"aucs": [0.7806828199530647, 0.7403179105140761, 0.749761207096203, 0.7437351002018535, 0.7422547586057751, 0.7545929958322929, 0.7535537627469555, 0.7489236726620501, 0.761675357887737, 0.6062442212528227, 0.5763777532569886, 0.5819588108848505, 0.5394710372703809, 0.5509203761675361, 0.5605211083640753, 0.5394671996656535, 0.5630743984576695, 0.5618417824560498, 0.13901442188714008, 0.13625660992051802, 0.14144542233492285, 0.17367055120657493, 0.17730699490540303, 0.17581988604241727, 0.15406358055666203, 0.17957205113590158, 0.13308267056179446, 0.12812492863094704, 0.14194480028532797, 0.13289732965164858, 0.15237465899438563, 0.11254448473549761, 0.12907041877984504, 0.13355398953912645, 0.12418050625986199, 0.14420623897139961, 0.887155769711066, 0.8408769009974477, 0.8352716331657296, 0.8682342877856334, 0.8766241878804538, 0.8846493680238336, 0.8933381774492608, 0.8743154653129396, 0.9418761977200172, 0.3266027583811265, 0.3167190223066785, 0.3345489830272028, 0.3255116170363217, 0.3124641274171992, 0.33773571880694475, 0.30322849603344737, 0.31819706847850926, 0.3194660147589409, 0.663327086379958, 0.6700214230808077, 0.6848265215944647, 0.7068522508267706, 0.7001195716063847, 0.7086245137072056, 0.6874337293130075, 0.7159884619690349, 0.7177758821565152, 0.1433553717170395, 0.18044206247077021, 0.16509295185505524, 0.18028187926497596, 0.2666713968955393, 0.16837579738583186, 0.2998233639476704, 0.24659264627640498, 0.19274903068580496, 0.1782641951886299, 0.13181977437302972, 0.21665502951395477, 0.16055459663974703, 0.20445327619472353, 0.16065052729397433, 0.1976246048506749, 0.149239470508151, 0.1335080599465931, 0.1559063189742197, 0.17184712251803536, 0.14001218590670816, 0.1956796169463022, 0.14298850145748332, 0.17322775598754414, 0.17994366218028734, 0.1799585025271726, 0.09741797689075449, 0.2843703898892923, 0.3490963359013285, 0.3456562900596051, 0.2862152595852935, 0.20349894899408705, 0.21065982467513888, 0.33258374870033147, 0.2931357268788499, 0.3514297168246815, 0.10971641741672811, 0.05876809547926243, 0.07878200842314931, 0.1429578450432364, 0.09790599224212437, 0.10292479412555133, 0.10520060131816766, 0.07881251725719396, 0.1050998893345324, 0.2104795658489126, 0.202937224584116, 0.21177315495000426, 0.21016714919742363, 0.24003053387589002, 0.19577950098307684, 0.202849707842238, 0.22101519770501377, 0.21013353657912504, 0.5358501210784654, 0.5687325796347134, 0.550555433297179, 0.5321124514300758, 0.5046365014008675, 0.5360665037343553, 0.6201470147689343, 0.5739774942429292, 0.6378699883536221, 0.12084245863412157, 0.10800609635105263, 0.1267290545989327, 0.11179988907819494, 0.1293432859368726, 0.1228504144501803, 0.112763148165832, 0.13321393126864456, 0.11501154478545306, 0.1717787522443932, 0.18865191873923426, 0.1772077686838751, 0.20670991135765548, 0.18633318640261665, 0.19764834920673668, 0.1762414464141404, 0.20362560482986203, 0.16280633167833114, 0.398852879854958, 0.366829536596082, 0.4068396996522792, 0.35883984762832843, 0.34437488835819163, 0.3618441910831469, 0.40398539460405103, 0.4115351786749357, 0.39616219675792574, 0.2819969362125181, 0.28126773776026415, 0.26870832918963583, 0.26437044142730803, 0.308194817348421, 0.27886819617099756, 0.29400736881433653, 0.2980173316871074, 0.32553798311560844, 0.19953109516206124, 0.2047321727400535, 0.2246831938743784, 0.2566382370869935, 0.23801066883682842, 0.20067820955804394, 0.20475514122786742, 0.1914286880735968, 0.20671475174251486, 0.20234908732742285, 0.23233593626710103, 0.25511862833590404, 0.24218692259768104, 0.2617336922030612, 0.23448667431985948, 0.24398830665127202, 0.26551102409573446, 0.20931520975196016, 0.672196158736137, 0.703662516010737, 0.6299656556971335, 0.6038786140226907, 0.5503174739037415, 0.5220296232997237, 0.4631728368882815, 0.3286892354050146, 0.5309551059485893, 0.7082942642271719, 0.37063354255047376, 0.1952245071226375, 0.19824993911368716, 0.197435019238569, 0.19042170256846547, 0.530332019647262, 0.2024881103719406, 0.6360583351179672, 0.1920723986037789, 0.19255285959190704, 0.2029587462447715, 0.18282224112015832, 0.18549154128447487, 0.18977658579526713, 0.18356843844151083, 0.19763036207802753, 0.19026672498823083, 0.07789093452251106, 0.08106650335728005, 0.08778435105125848, 0.08633264238355043, 0.08349775788457048, 0.08178728630572152, 0.08290025507384802, 0.08331776896454501, 0.07682285048021675]}, "mutation_prompt": null}
{"id": "6f2943d4-f61f-4418-8714-66885f9dc078", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5  # New adaptive learning rate\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant1 = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        d, e, f = pop[np.random.choice(indices, 3, replace=False)]\n        mutant2 = np.clip(d + self.F * (e - f), self.lower_bound, self.upper_bound)\n        return mutant1 if np.random.rand() > 0.5 else mutant2\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                # Adjust F dynamically based on budget usage\n                self.F = self.adaptive_alpha * (1.0 - evals / self.budget)\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "An adaptive learning rate strategy is integrated with hybrid differential evolution to balance exploration and exploitation dynamically.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9f3c7723-86d1-4724-9b7f-878e4b874813", "metadata": {"aucs": [0.7806828199530647, 0.7403179105140761, 0.749761207096203, 0.7437351002018535, 0.7422547586057751, 0.7545929958322929, 0.7535537627469555, 0.7489236726620501, 0.761675357887737, 0.6062442212528227, 0.5763777532569886, 0.5819588108848505, 0.5394710372703809, 0.5509203761675361, 0.5605211083640753, 0.5394671996656535, 0.5630743984576695, 0.5618417824560498, 0.13901442188714008, 0.13625660992051802, 0.14144542233492285, 0.17367055120657493, 0.17730699490540303, 0.17581988604241727, 0.15406358055666203, 0.17957205113590158, 0.13308267056179446, 0.12812492863094704, 0.14194480028532797, 0.13289732965164858, 0.15237465899438563, 0.11254448473549761, 0.12907041877984504, 0.13355398953912645, 0.12418050625986199, 0.14420623897139961, 0.887155769711066, 0.8408769009974477, 0.8352716331657296, 0.8682342877856334, 0.8766241878804538, 0.8846493680238336, 0.8933381774492608, 0.8743154653129396, 0.9418761977200172, 0.3266027583811265, 0.3167190223066785, 0.3345489830272028, 0.3255116170363217, 0.3124641274171992, 0.33773571880694475, 0.30322849603344737, 0.31819706847850926, 0.3194660147589409, 0.663327086379958, 0.6700214230808077, 0.6848265215944647, 0.7068522508267706, 0.7001195716063847, 0.7086245137072056, 0.6874337293130075, 0.7159884619690349, 0.7177758821565152, 0.1433553717170395, 0.18044206247077021, 0.16509295185505524, 0.18028187926497596, 0.2666713968955393, 0.16837579738583186, 0.2998233639476704, 0.24659264627640498, 0.19274903068580496, 0.1782641951886299, 0.13181977437302972, 0.21665502951395477, 0.16055459663974703, 0.20445327619472353, 0.16065052729397433, 0.1976246048506749, 0.149239470508151, 0.1335080599465931, 0.1559063189742197, 0.17184712251803536, 0.14001218590670816, 0.1956796169463022, 0.14298850145748332, 0.17322775598754414, 0.17994366218028734, 0.1799585025271726, 0.09741797689075449, 0.2843703898892923, 0.3490963359013285, 0.3456562900596051, 0.2862152595852935, 0.20349894899408705, 0.21065982467513888, 0.33258374870033147, 0.2931357268788499, 0.3514297168246815, 0.10971641741672811, 0.05876809547926243, 0.07878200842314931, 0.1429578450432364, 0.09790599224212437, 0.10292479412555133, 0.10520060131816766, 0.07881251725719396, 0.1050998893345324, 0.2104795658489126, 0.202937224584116, 0.21177315495000426, 0.21016714919742363, 0.24003053387589002, 0.19577950098307684, 0.202849707842238, 0.22101519770501377, 0.21013353657912504, 0.5358501210784654, 0.5687325796347134, 0.550555433297179, 0.5321124514300758, 0.5046365014008675, 0.5360665037343553, 0.6201470147689343, 0.5739774942429292, 0.6378699883536221, 0.12084245863412157, 0.10800609635105263, 0.1267290545989327, 0.11179988907819494, 0.1293432859368726, 0.1228504144501803, 0.112763148165832, 0.13321393126864456, 0.11501154478545306, 0.1717787522443932, 0.18865191873923426, 0.1772077686838751, 0.20670991135765548, 0.18633318640261665, 0.19764834920673668, 0.1762414464141404, 0.20362560482986203, 0.16280633167833114, 0.398852879854958, 0.366829536596082, 0.4068396996522792, 0.35883984762832843, 0.34437488835819163, 0.3618441910831469, 0.40398539460405103, 0.4115351786749357, 0.39616219675792574, 0.2819969362125181, 0.28126773776026415, 0.26870832918963583, 0.26437044142730803, 0.308194817348421, 0.27886819617099756, 0.29400736881433653, 0.2980173316871074, 0.32553798311560844, 0.19953109516206124, 0.2047321727400535, 0.2246831938743784, 0.2566382370869935, 0.23801066883682842, 0.20067820955804394, 0.20475514122786742, 0.1914286880735968, 0.20671475174251486, 0.20234908732742285, 0.23233593626710103, 0.25511862833590404, 0.24218692259768104, 0.2617336922030612, 0.23448667431985948, 0.24398830665127202, 0.26551102409573446, 0.20931520975196016, 0.672196158736137, 0.703662516010737, 0.6299656556971335, 0.6038786140226907, 0.5503174739037415, 0.5220296232997237, 0.4631728368882815, 0.3286892354050146, 0.5309551059485893, 0.7082942642271719, 0.37063354255047376, 0.1952245071226375, 0.19824993911368716, 0.197435019238569, 0.19042170256846547, 0.530332019647262, 0.2024881103719406, 0.6360583351179672, 0.1920723986037789, 0.19255285959190704, 0.2029587462447715, 0.18282224112015832, 0.18549154128447487, 0.18977658579526713, 0.18356843844151083, 0.19763036207802753, 0.19026672498823083, 0.07789093452251106, 0.08106650335728005, 0.08778435105125848, 0.08633264238355043, 0.08349775788457048, 0.08178728630572152, 0.08290025507384802, 0.08331776896454501, 0.07682285048021675]}, "mutation_prompt": null}
{"id": "54bae5e4-0872-433c-afb3-5ac46c2e1c8b", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5  # New adaptive learning rate\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant1 = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        d, e, f = pop[np.random.choice(indices, 3, replace=False)]\n        mutant2 = np.clip(d + self.F * (e - f), self.lower_bound, self.upper_bound)\n        return mutant1 if np.random.rand() > 0.5 else mutant2\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                # Adjust F dynamically based on budget usage\n                self.F = self.adaptive_alpha * (1.0 - evals / self.budget)\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "An adaptive learning rate strategy is integrated with hybrid differential evolution to balance exploration and exploitation dynamically.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9f3c7723-86d1-4724-9b7f-878e4b874813", "metadata": {"aucs": [0.7806828199530647, 0.7403179105140761, 0.749761207096203, 0.7437351002018535, 0.7422547586057751, 0.7545929958322929, 0.7535537627469555, 0.7489236726620501, 0.761675357887737, 0.6062442212528227, 0.5763777532569886, 0.5819588108848505, 0.5394710372703809, 0.5509203761675361, 0.5605211083640753, 0.5394671996656535, 0.5630743984576695, 0.5618417824560498, 0.13901442188714008, 0.13625660992051802, 0.14144542233492285, 0.17367055120657493, 0.17730699490540303, 0.17581988604241727, 0.15406358055666203, 0.17957205113590158, 0.13308267056179446, 0.12812492863094704, 0.14194480028532797, 0.13289732965164858, 0.15237465899438563, 0.11254448473549761, 0.12907041877984504, 0.13355398953912645, 0.12418050625986199, 0.14420623897139961, 0.887155769711066, 0.8408769009974477, 0.8352716331657296, 0.8682342877856334, 0.8766241878804538, 0.8846493680238336, 0.8933381774492608, 0.8743154653129396, 0.9418761977200172, 0.3266027583811265, 0.3167190223066785, 0.3345489830272028, 0.3255116170363217, 0.3124641274171992, 0.33773571880694475, 0.30322849603344737, 0.31819706847850926, 0.3194660147589409, 0.663327086379958, 0.6700214230808077, 0.6848265215944647, 0.7068522508267706, 0.7001195716063847, 0.7086245137072056, 0.6874337293130075, 0.7159884619690349, 0.7177758821565152, 0.1433553717170395, 0.18044206247077021, 0.16509295185505524, 0.18028187926497596, 0.2666713968955393, 0.16837579738583186, 0.2998233639476704, 0.24659264627640498, 0.19274903068580496, 0.1782641951886299, 0.13181977437302972, 0.21665502951395477, 0.16055459663974703, 0.20445327619472353, 0.16065052729397433, 0.1976246048506749, 0.149239470508151, 0.1335080599465931, 0.1559063189742197, 0.17184712251803536, 0.14001218590670816, 0.1956796169463022, 0.14298850145748332, 0.17322775598754414, 0.17994366218028734, 0.1799585025271726, 0.09741797689075449, 0.2843703898892923, 0.3490963359013285, 0.3456562900596051, 0.2862152595852935, 0.20349894899408705, 0.21065982467513888, 0.33258374870033147, 0.2931357268788499, 0.3514297168246815, 0.10971641741672811, 0.05876809547926243, 0.07878200842314931, 0.1429578450432364, 0.09790599224212437, 0.10292479412555133, 0.10520060131816766, 0.07881251725719396, 0.1050998893345324, 0.2104795658489126, 0.202937224584116, 0.21177315495000426, 0.21016714919742363, 0.24003053387589002, 0.19577950098307684, 0.202849707842238, 0.22101519770501377, 0.21013353657912504, 0.5358501210784654, 0.5687325796347134, 0.550555433297179, 0.5321124514300758, 0.5046365014008675, 0.5360665037343553, 0.6201470147689343, 0.5739774942429292, 0.6378699883536221, 0.12084245863412157, 0.10800609635105263, 0.1267290545989327, 0.11179988907819494, 0.1293432859368726, 0.1228504144501803, 0.112763148165832, 0.13321393126864456, 0.11501154478545306, 0.1717787522443932, 0.18865191873923426, 0.1772077686838751, 0.20670991135765548, 0.18633318640261665, 0.19764834920673668, 0.1762414464141404, 0.20362560482986203, 0.16280633167833114, 0.398852879854958, 0.366829536596082, 0.4068396996522792, 0.35883984762832843, 0.34437488835819163, 0.3618441910831469, 0.40398539460405103, 0.4115351786749357, 0.39616219675792574, 0.2819969362125181, 0.28126773776026415, 0.26870832918963583, 0.26437044142730803, 0.308194817348421, 0.27886819617099756, 0.29400736881433653, 0.2980173316871074, 0.32553798311560844, 0.19953109516206124, 0.2047321727400535, 0.2246831938743784, 0.2566382370869935, 0.23801066883682842, 0.20067820955804394, 0.20475514122786742, 0.1914286880735968, 0.20671475174251486, 0.20234908732742285, 0.23233593626710103, 0.25511862833590404, 0.24218692259768104, 0.2617336922030612, 0.23448667431985948, 0.24398830665127202, 0.26551102409573446, 0.20931520975196016, 0.672196158736137, 0.703662516010737, 0.6299656556971335, 0.6038786140226907, 0.5503174739037415, 0.5220296232997237, 0.4631728368882815, 0.3286892354050146, 0.5309551059485893, 0.7082942642271719, 0.37063354255047376, 0.1952245071226375, 0.19824993911368716, 0.197435019238569, 0.19042170256846547, 0.530332019647262, 0.2024881103719406, 0.6360583351179672, 0.1920723986037789, 0.19255285959190704, 0.2029587462447715, 0.18282224112015832, 0.18549154128447487, 0.18977658579526713, 0.18356843844151083, 0.19763036207802753, 0.19026672498823083, 0.07789093452251106, 0.08106650335728005, 0.08778435105125848, 0.08633264238355043, 0.08349775788457048, 0.08178728630572152, 0.08290025507384802, 0.08331776896454501, 0.07682285048021675]}, "mutation_prompt": null}
{"id": "b089a525-7a38-4101-87d2-c8347222e97d", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5  # New adaptive learning rate\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant1 = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        d, e, f = pop[np.random.choice(indices, 3, replace=False)]\n        mutant2 = np.clip(d + self.F * (e - f), self.lower_bound, self.upper_bound)\n        return mutant1 if np.random.rand() > 0.5 else mutant2\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                # Adjust F dynamically based on budget usage\n                self.F = self.adaptive_alpha * (1.0 - evals / self.budget)\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "An adaptive learning rate strategy is integrated with hybrid differential evolution to balance exploration and exploitation dynamically.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9f3c7723-86d1-4724-9b7f-878e4b874813", "metadata": {"aucs": [0.7806828199530647, 0.7403179105140761, 0.749761207096203, 0.7437351002018535, 0.7422547586057751, 0.7545929958322929, 0.7535537627469555, 0.7489236726620501, 0.761675357887737, 0.6062442212528227, 0.5763777532569886, 0.5819588108848505, 0.5394710372703809, 0.5509203761675361, 0.5605211083640753, 0.5394671996656535, 0.5630743984576695, 0.5618417824560498, 0.13901442188714008, 0.13625660992051802, 0.14144542233492285, 0.17367055120657493, 0.17730699490540303, 0.17581988604241727, 0.15406358055666203, 0.17957205113590158, 0.13308267056179446, 0.12812492863094704, 0.14194480028532797, 0.13289732965164858, 0.15237465899438563, 0.11254448473549761, 0.12907041877984504, 0.13355398953912645, 0.12418050625986199, 0.14420623897139961, 0.887155769711066, 0.8408769009974477, 0.8352716331657296, 0.8682342877856334, 0.8766241878804538, 0.8846493680238336, 0.8933381774492608, 0.8743154653129396, 0.9418761977200172, 0.3266027583811265, 0.3167190223066785, 0.3345489830272028, 0.3255116170363217, 0.3124641274171992, 0.33773571880694475, 0.30322849603344737, 0.31819706847850926, 0.3194660147589409, 0.663327086379958, 0.6700214230808077, 0.6848265215944647, 0.7068522508267706, 0.7001195716063847, 0.7086245137072056, 0.6874337293130075, 0.7159884619690349, 0.7177758821565152, 0.1433553717170395, 0.18044206247077021, 0.16509295185505524, 0.18028187926497596, 0.2666713968955393, 0.16837579738583186, 0.2998233639476704, 0.24659264627640498, 0.19274903068580496, 0.1782641951886299, 0.13181977437302972, 0.21665502951395477, 0.16055459663974703, 0.20445327619472353, 0.16065052729397433, 0.1976246048506749, 0.149239470508151, 0.1335080599465931, 0.1559063189742197, 0.17184712251803536, 0.14001218590670816, 0.1956796169463022, 0.14298850145748332, 0.17322775598754414, 0.17994366218028734, 0.1799585025271726, 0.09741797689075449, 0.2843703898892923, 0.3490963359013285, 0.3456562900596051, 0.2862152595852935, 0.20349894899408705, 0.21065982467513888, 0.33258374870033147, 0.2931357268788499, 0.3514297168246815, 0.10971641741672811, 0.05876809547926243, 0.07878200842314931, 0.1429578450432364, 0.09790599224212437, 0.10292479412555133, 0.10520060131816766, 0.07881251725719396, 0.1050998893345324, 0.2104795658489126, 0.202937224584116, 0.21177315495000426, 0.21016714919742363, 0.24003053387589002, 0.19577950098307684, 0.202849707842238, 0.22101519770501377, 0.21013353657912504, 0.5358501210784654, 0.5687325796347134, 0.550555433297179, 0.5321124514300758, 0.5046365014008675, 0.5360665037343553, 0.6201470147689343, 0.5739774942429292, 0.6378699883536221, 0.12084245863412157, 0.10800609635105263, 0.1267290545989327, 0.11179988907819494, 0.1293432859368726, 0.1228504144501803, 0.112763148165832, 0.13321393126864456, 0.11501154478545306, 0.1717787522443932, 0.18865191873923426, 0.1772077686838751, 0.20670991135765548, 0.18633318640261665, 0.19764834920673668, 0.1762414464141404, 0.20362560482986203, 0.16280633167833114, 0.398852879854958, 0.366829536596082, 0.4068396996522792, 0.35883984762832843, 0.34437488835819163, 0.3618441910831469, 0.40398539460405103, 0.4115351786749357, 0.39616219675792574, 0.2819969362125181, 0.28126773776026415, 0.26870832918963583, 0.26437044142730803, 0.308194817348421, 0.27886819617099756, 0.29400736881433653, 0.2980173316871074, 0.32553798311560844, 0.19953109516206124, 0.2047321727400535, 0.2246831938743784, 0.2566382370869935, 0.23801066883682842, 0.20067820955804394, 0.20475514122786742, 0.1914286880735968, 0.20671475174251486, 0.20234908732742285, 0.23233593626710103, 0.25511862833590404, 0.24218692259768104, 0.2617336922030612, 0.23448667431985948, 0.24398830665127202, 0.26551102409573446, 0.20931520975196016, 0.672196158736137, 0.703662516010737, 0.6299656556971335, 0.6038786140226907, 0.5503174739037415, 0.5220296232997237, 0.4631728368882815, 0.3286892354050146, 0.5309551059485893, 0.7082942642271719, 0.37063354255047376, 0.1952245071226375, 0.19824993911368716, 0.197435019238569, 0.19042170256846547, 0.530332019647262, 0.2024881103719406, 0.6360583351179672, 0.1920723986037789, 0.19255285959190704, 0.2029587462447715, 0.18282224112015832, 0.18549154128447487, 0.18977658579526713, 0.18356843844151083, 0.19763036207802753, 0.19026672498823083, 0.07789093452251106, 0.08106650335728005, 0.08778435105125848, 0.08633264238355043, 0.08349775788457048, 0.08178728630572152, 0.08290025507384802, 0.08331776896454501, 0.07682285048021675]}, "mutation_prompt": null}
{"id": "4b3f209a-c798-40e0-a8dd-6ee97fa37bba", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5  # New adaptive learning rate\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant1 = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        d, e, f = pop[np.random.choice(indices, 3, replace=False)]\n        mutant2 = np.clip(d + self.F * (e - f), self.lower_bound, self.upper_bound)\n        return mutant1 if np.random.rand() > 0.5 else mutant2\n\n    def _crossover(self, target, mutant):\n        # Adjust CR dynamically based on budget usage\n        self.CR = 0.9 * (1.0 - evals / self.budget) + 0.1 * np.random.rand()\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                self.F = self.adaptive_alpha * (1.0 - evals / self.budget)\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                # Apply stochastic trigger for local search\n                if np.random.rand() < self.local_search_prob * (1.0 - evals / self.budget):\n                    scale_factor = 1 - (evals / self.budget)\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "Incorporate a self-adaptive crossover rate and stochastic local search triggers to enhance convergence and diversity.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'evals' is not defined\").", "error": "NameError(\"name 'evals' is not defined\")", "parent_id": "9f3c7723-86d1-4724-9b7f-878e4b874813", "metadata": {}, "mutation_prompt": null}
{"id": "522e851c-0c48-40a7-9218-f5c746eb0cc7", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _adjust_population_size(self, evals):\n        new_size = int(self.population_size * (1 - evals / self.budget))\n        return max(4, new_size)  # Ensures a minimum population size\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant1 = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        d, e, f = pop[np.random.choice(indices, 3, replace=False)]\n        mutant2 = np.clip(d + self.F * (e - f), self.lower_bound, self.upper_bound)\n        return mutant1 if np.random.rand() > 0.5 else mutant2\n\n    def _crossover(self, target, mutant, diversity):\n        adj_CR = self.CR * (1 + diversity)\n        cross_points = np.random.rand(self.dim) < adj_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            self.population_size = self._adjust_population_size(evals)\n            for i in range(self.population_size):\n                self.F = self.adaptive_alpha * (1.0 - evals / self.budget)\n                diversity = np.std(population) / (self.upper_bound - self.lower_bound)\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant, diversity)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduce self-adaptive population size and adjust crossover rate dynamically based on diversity to improve convergence efficiency.", "configspace": "", "generation": 61, "fitness": 0.23423090765545898, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.19.", "error": "", "parent_id": "9f3c7723-86d1-4724-9b7f-878e4b874813", "metadata": {"aucs": [0.5273822193735789, 0.5128344288520101, 0.517422765511746, 0.5283418016854304, 0.5365455086443514, 0.5241608600465142, 0.5153320864865378, 0.5572994055462619, 0.5348743788665722, 0.16329926581773435, 0.026182312073116387, 0.05288793859254326, 0.13715996419326204, 0.1095421761465013, 0.11429273032206966, 0.05269942585180565, 9.999999999998899e-05, 0.08553887315803532, 0.16542141631483742, 0.13388074317774756, 0.09025731623981281, 0.09608779404297496, 0.12267036733952208, 0.08680996671822394, 0.10800494729783516, 0.11508923420116168, 0.11147897653912098, 0.13448314246867832, 0.09808525272928914, 0.10266442010513255, 0.07216094766021419, 0.10183118594357654, 0.14422757696754873, 0.13159850399204664, 0.055536479290519525, 0.111241013860362, 0.8681746512122156, 0.7682947443974074, 0.757470879142557, 0.7560214515758846, 0.8466293568925379, 0.7085959554716561, 0.873280244627189, 0.13250881922927493, 0.8562017216906118, 0.3514850035599325, 0.3662786600383615, 0.3657277841137163, 0.35961193958912574, 0.3723543938004171, 0.35418997003697683, 0.3490028557705247, 0.36126340653825795, 0.35580400663890555, 0.7520864355673387, 0.24179280392159286, 0.24750433082628132, 0.270299896212594, 0.18499365248995103, 0.2029182831176689, 0.22867186754768098, 0.2304002644176676, 0.7842107901969031, 0.17347657236698255, 0.15609670576707413, 0.29500029919382353, 0.12238671747539431, 0.23914493425245076, 0.2077284141015252, 0.1225355453567154, 0.154885532600047, 0.17855100829060389, 0.12210819058183187, 0.12687132211948593, 0.15494239663258635, 0.13698269655506123, 0.18625875262360136, 0.1664227466388677, 0.16380345353268255, 0.14900918650871575, 0.17932267907852006, 0.07895565513783553, 0.08712577569230473, 0.10193447670598665, 0.1212581477704725, 0.1000167554852125, 0.012098778094919882, 0.003175664734142436, 0.0612227543549243, 0.05834005724929503, 0.1904815216412199, 0.19344130451073438, 0.3632923001035204, 0.13968790762517824, 0.13133368509887533, 0.14304350930638954, 0.16543109306836845, 0.16912924917165761, 0.16732920248397531, 0.020794782479965912, 0.03260190630273463, 0.02665678392525428, 0.017322735136245493, 0.05288762395700486, 0.02317147644251616, 0.014976602598321231, 0.017806534854921674, 0.024378437654286933, 0.10110951098934584, 0.1529177622001725, 0.14015897854552717, 0.03187401901307663, 0.1281189754880273, 0.15731735093297627, 0.08592995962201588, 0.12318935305948886, 0.11890194989782354, 0.45977151344462863, 0.46719262703897224, 0.47103383869348614, 0.4897343563886365, 0.45926458157676886, 0.45220903534442636, 0.4929771632050022, 0.45852098243340655, 0.4874104318714546, 0.1465492706998912, 0.10995505329892041, 0.10288421078416177, 0.15179429759456575, 0.10240708704103307, 0.11818905366514032, 0.17081674490009668, 0.12089359510007014, 0.10048050104218309, 0.163040870563818, 0.1317867305419641, 0.20096550214567055, 0.2829552510098936, 0.18086118435548393, 0.31007688959775115, 0.19599727255613208, 0.18377943881026115, 0.25377176165998894, 0.2770184055653939, 0.34182916423593435, 0.30558293251672153, 0.34966195984395054, 0.2661114584594788, 0.29785013907227, 0.3419243437284637, 0.31995267962225515, 0.36014589887255266, 0.24423234289489704, 0.2328073005668837, 0.2222970847841581, 0.2677345604326763, 0.26777483968537996, 0.16534719241831897, 0.2471347398316721, 0.20767572082127195, 0.23750069762955883, 0.1978856265572746, 0.206598483436634, 0.26656449712993446, 0.2228544452875778, 0.19151665998089618, 0.2031502776310835, 0.21483523885650158, 0.17180268978536684, 0.2220652882641555, 0.1823364837879985, 0.18611736258104383, 0.1703293742122638, 0.21140040522172432, 0.21983667884242686, 0.18345530322251247, 0.1871342016717451, 0.18399387782240484, 0.21278685576641287, 0.171157968762368, 0.1688187850649392, 0.15231517455439914, 0.7971732145466984, 0.17546921638448498, 0.19455566942681668, 0.6225496404740707, 0.1700984581094297, 0.7530401224235769, 0.2057380098653766, 0.5316596638533531, 0.22155485479563375, 0.1690396372154066, 0.1635838405088369, 0.16444838686846885, 0.15058942350119942, 0.20705076634761066, 0.15298249622095283, 0.19082895150682477, 0.19342385368682158, 0.18534459819267946, 0.18677819426097442, 0.2093405232811537, 0.19201343706195972, 0.17950580395529836, 0.2045513998952755, 0.17709759320379692, 0.08778829599192162, 0.11164030606580322, 0.08436234116841934, 0.12940490231066037, 0.07072406011702681, 0.09195820446447522, 0.08644126685770248, 0.08347995489591753, 0.08866325164460853]}, "mutation_prompt": null}
{"id": "aafb64a5-d5cf-4ec8-addb-9c2653dfaecd", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5\n        self.num_subpopulations = 3  # New: Number of subpopulations\n        self.competitive_F = [0.4, 0.6, 0.8]  # New: competitive F values\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx, F):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant1 = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        d, e, f = pop[np.random.choice(indices, 3, replace=False)]\n        mutant2 = np.clip(d + F * (e - f), self.lower_bound, self.upper_bound)\n        return mutant1 if np.random.rand() > 0.5 else mutant2\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n        subpop_size = self.population_size // self.num_subpopulations  # New: subpopulation size\n\n        while evals < self.budget:\n            for subpop_id in range(self.num_subpopulations):  # New: Iterate over subpopulations\n                start_idx = subpop_id * subpop_size\n                end_idx = start_idx + subpop_size\n                subpop = population[start_idx:end_idx]\n                sub_fitness = fitness[start_idx:end_idx]\n                F = self.competitive_F[subpop_id]  # New: Use competitive F\n\n                for i in range(subpop_size):\n                    mutant = self._mutate(subpop, i, F)\n                    trial = self._crossover(subpop[i], mutant)\n                    trial_fitness = func(trial)\n                    evals += 1\n\n                    if trial_fitness < sub_fitness[i]:\n                        subpop[i] = trial\n                        sub_fitness[i] = trial_fitness\n\n                    if evals >= self.budget:\n                        break\n\n                    if np.random.rand() < self.local_search_prob:\n                        scale_factor = 1 - (evals / self.budget)\n                        local_candidate = self._local_search(subpop[i], scale=scale_factor)\n                        local_fitness = func(local_candidate)\n                        evals += 1\n                        if local_fitness < sub_fitness[i]:\n                            subpop[i] = local_candidate\n                            sub_fitness[i] = local_fitness\n\n                    if evals >= self.budget:\n                        break\n\n                population[start_idx:end_idx] = subpop\n                fitness[start_idx:end_idx] = sub_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "Integrate multi-population strategy with competitive F selection for enhanced exploration and exploitation.", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 45 is out of bounds for axis 0 with size 20').", "error": "IndexError('index 45 is out of bounds for axis 0 with size 20')", "parent_id": "9f3c7723-86d1-4724-9b7f-878e4b874813", "metadata": {}, "mutation_prompt": null}
{"id": "fd39be97-3a25-4693-aca9-e373fc0e92c4", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5  # New adaptive learning rate\n        self.elite_proportion = 0.1  # Proportion of elite individuals\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant1 = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        d, e, f = pop[np.random.choice(indices, 3, replace=False)]\n        mutant2 = np.clip(d + self.F * (e - f), self.lower_bound, self.upper_bound)\n        return mutant1 if np.random.rand() > 0.5 else mutant2\n\n    def _crossover(self, target, mutant, evals):\n        # Adaptive crossover rate\n        CR_dynamic = self.CR * (1.0 - evals / self.budget)\n        cross_points = np.random.rand(self.dim) < CR_dynamic\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Elite selection\n            elite_count = int(self.elite_proportion * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_count]\n\n            for i in range(self.population_size):\n                if i in elite_indices and np.random.rand() < 0.5:\n                    continue\n                # Adjust F dynamically based on budget usage\n                self.F = self.adaptive_alpha * (1.0 - evals / self.budget)\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant, evals)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduce adaptive crossover rate and integrate elite selection to improve convergence speed.", "configspace": "", "generation": 63, "fitness": 0.2586403535429766, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.21.", "error": "", "parent_id": "9f3c7723-86d1-4724-9b7f-878e4b874813", "metadata": {"aucs": [0.7442273191507879, 0.7320714751098212, 0.741329678954417, 0.7523323677756477, 0.712155996189485, 0.7389951607893417, 0.7346558443924276, 0.7481899315502956, 0.7572374353735307, 0.5029015794539169, 0.49808497055193557, 0.5541922866455301, 0.5412945155074186, 0.5231807841571428, 0.5583110501126147, 0.5222693580263778, 0.4777075054562271, 0.5247454351890475, 0.2229165844669353, 0.19913979994172437, 0.21490987646207416, 0.22243523012113764, 0.20373578299771677, 0.22106411456607145, 0.19754787995883438, 0.2868780092158698, 0.253501370935337, 0.18496587705125866, 0.1716130493561293, 0.18913778030387562, 0.1857910469657772, 0.1678788494041923, 0.2414971444541587, 0.20000567141489956, 0.21993578832661564, 0.17738492027335373, 0.8589279636080602, 0.9342306567628653, 0.8884182657580092, 0.9226073934868344, 0.9122680068007178, 0.9191195561490959, 0.8717322375890686, 0.9149239831052328, 0.8933116169722225, 0.3006262530640601, 0.2605521011343733, 0.26587462513555327, 0.27388940663198824, 0.30480177725692825, 0.2774272630346126, 0.22815118944165025, 0.24995684903628068, 0.22197671844663291, 0.29641852981637107, 0.28900637800775564, 0.2460807799204684, 0.32751964507420994, 0.508650500035517, 0.3049411909388351, 0.4938046982083629, 0.4473181101724846, 0.3245912753260678, 0.13260595227722427, 0.1680487406332355, 0.1714068840880083, 0.1811494323926398, 0.16793367263590675, 0.1607539355217863, 0.16144673999737935, 0.17819650317816849, 0.16554532221203777, 0.17573848926507218, 0.13743164098582128, 0.09036188056990757, 0.15936177074117752, 0.15425732979922613, 0.14425334322503625, 0.150653701364436, 0.12746858269118388, 0.14231445356060268, 0.025097138716676626, 0.009275823462523869, 0.008082079483371363, 0.009383548510500939, 0.001236028885317153, 0.0018518393059453464, 0.005289432324359633, 0.009880405596319752, 0.031067032374937464, 0.14996429200766903, 0.11265583695792047, 0.12972855934467065, 0.1214542243990756, 0.1207199856308454, 0.11473845287772311, 0.14060533871233893, 0.1123990272283425, 0.11615082333691262, 0.009666745625307116, 0.0006385403334577822, 0.017236430814266845, 0.019403086517015278, 0.016653870957782924, 0.00270518536073705, 0.03958961469142053, 0.013564764683174912, 0.0162311741754525, 0.11783203222002303, 0.11208326168674143, 0.12318907050653793, 0.1075097172582693, 0.14298824303187108, 0.13622791043704496, 0.13070687613616028, 0.10907913243839196, 0.13043245929123892, 0.4546339051902837, 0.47051336923320164, 0.4725687654905315, 0.47750768567349444, 0.4325033691722604, 0.454328201784184, 0.48471476403851366, 0.4342622930026594, 0.4580014129027906, 0.12009737380154506, 0.11360486558713712, 0.13967278702349561, 0.11573976685348264, 0.1030273132420445, 0.1074805614907467, 0.09788546083386296, 0.10864701505838126, 0.10863724156561616, 0.17463027142344512, 0.18473215505730556, 0.15664350880317013, 0.2181740177372442, 0.16950321706547222, 0.19131665269673082, 0.16682758544620535, 0.16416976887681034, 0.16485604476185267, 0.26280774545259233, 0.28761564972196696, 0.29881695644225803, 0.2865382176845789, 0.2911044214607498, 0.2985177169599822, 0.32903136832018953, 0.34449123676843707, 0.3031565830329902, 0.22279559997233056, 0.21676397434045636, 0.21156272523747943, 0.182690675443558, 0.2097122597179124, 0.1942829992460503, 0.20774554781126786, 0.24076910520937922, 0.21166321460230442, 0.21985599075507023, 0.21331830266663643, 0.19891993861670432, 0.2076202276887127, 0.19677541778020335, 0.19496800715708829, 0.19772728421917152, 0.18638885113180537, 0.20314196306235344, 0.2251983280899179, 0.23210425245874267, 0.23971776247462007, 0.1988492813425412, 0.20668976634194158, 0.22541521324271752, 0.21574799355671048, 0.22732506759609927, 0.19713855580009276, 0.16956596174414373, 0.21284696071307097, 0.1756766553012592, 0.39399278743168364, 0.31641072933583003, 0.2942358619228034, 0.20054696096899183, 0.17373450970819193, 0.21640086931199798, 0.26697641197613775, 0.22485438603550345, 0.1912579399561669, 0.24872602437760027, 0.21862249147877, 0.20430983606013708, 0.19873509576158688, 0.31863617775060604, 0.20129769680073262, 0.19151596412747918, 0.1808104341347836, 0.1860878095011117, 0.17881075290070092, 0.19142114394553733, 0.18028154836660581, 0.1808399747736884, 0.19473517295863063, 0.18224113743242443, 0.08836611613230849, 0.0775781226635951, 0.07940690515849713, 0.08169578676361056, 0.08283948679454312, 0.08741916749046619, 0.08566945977927898, 0.07231689146243281, 0.09021075706857007]}, "mutation_prompt": null}
{"id": "ea09f7f3-dc5c-4055-884f-6120755024c4", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5  # New adaptive learning rate\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        dynamic_F = self.F * (1 + np.random.normal(0, 0.1))  # Dynamic mutation step size\n        mutant1 = np.clip(a + dynamic_F * (b - c), self.lower_bound, self.upper_bound)\n        d, e, f = pop[np.random.choice(indices, 3, replace=False)]\n        mutant2 = np.clip(d + dynamic_F * (e - f), self.lower_bound, self.upper_bound)\n        return mutant1 if np.random.rand() > 0.5 else mutant2\n\n    def _crossover(self, target, mutant):\n        self.CR = 0.9 * (1 - np.abs(mutant - target).mean() / 5)  # Dynamic crossover rate\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                # Adjust F dynamically based on budget usage\n                self.F = self.adaptive_alpha * (1.0 - evals / self.budget)\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduce a dynamic crossover rate and a self-adaptive mutation step size to enhance solution diversity and convergence speed.", "configspace": "", "generation": 64, "fitness": 0.28039643404237435, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "9f3c7723-86d1-4724-9b7f-878e4b874813", "metadata": {"aucs": [0.7438934992226038, 0.7339039328544792, 0.7485679719848206, 0.7342893786560643, 0.7352781595652392, 0.7435734983328233, 0.737968266508551, 0.7466571413510059, 0.749657515792278, 0.527465539925317, 0.5465224602453165, 0.5020654963931759, 0.5251845859070992, 0.5364847271489986, 0.5180421955049122, 0.5067047849903179, 0.5141868837602596, 0.5041918959486023, 0.15468987331019157, 0.15575839167672945, 0.15496411175704472, 0.16097199881664181, 0.16923286916325564, 0.1522872661619804, 0.15150433288126441, 0.17062930738121063, 0.18410736851615195, 0.13018887305628124, 0.12996337250371404, 0.13353914884718054, 0.1441156072631975, 0.1450182212742639, 0.13265273878638695, 0.14879417176963394, 0.13159809631796993, 0.14180833653917257, 0.9031620646279734, 0.9329318201701133, 0.9058024773698363, 0.9238106876082327, 0.9241888217972062, 0.866540003935374, 0.8921436044577489, 0.8830068230884961, 0.8332184798736872, 0.31830285764015576, 0.27466822406347746, 0.3092962527327284, 0.3187370430517721, 0.3028322243120011, 0.3231354245798377, 0.32404991796780447, 0.3138228360460126, 0.2955964546993739, 0.44811875543452995, 0.5131673660350315, 0.4856778613652114, 0.6055596002182978, 0.5965301837722821, 0.6457509442265378, 0.5533652818619306, 0.5963188131809323, 0.593834011154035, 0.23509727699656668, 0.21874548727544996, 0.1811276297821206, 0.22534171156008198, 0.24839504438787585, 0.2061895275006681, 0.19507182186419436, 0.15345216367125702, 0.28212350580483203, 0.15185473941962313, 0.15850577157151002, 0.20857057358577835, 0.16099599511979468, 0.14877004411228567, 0.16587456929094146, 0.16399488697931341, 0.1523476029930092, 0.16798626206571676, 0.06749949271017741, 0.031064301845207254, 0.02499105131028445, 0.019606623651612587, 0.005844065328762138, 0.05361547299291092, 0.04119350728064386, 0.037022834788696835, 0.0158098744820665, 0.1089308837931694, 0.10760039760649265, 0.09522937158236344, 0.09129779730030985, 0.1270613809239216, 0.08586912217533316, 0.12236055395360212, 0.10758062799354051, 0.13783435666014343, 0.050129104923083645, 0.06950199243246136, 0.11005968528877252, 0.07439748122646217, 0.050500376354657206, 0.04595566158094466, 0.07900624583231053, 0.040948081447902074, 0.14110599245005195, 0.18835270107376967, 0.18640966257710978, 0.15812208994365295, 0.24643018125413252, 0.20942292336892254, 0.21248395778146012, 0.17018502995320905, 0.2088465226459223, 0.16372598232141167, 0.564791290098406, 0.5509379907743202, 0.5467967334482629, 0.5963233552117826, 0.5380986797224301, 0.5810708988504811, 0.504755839830481, 0.6104765487884609, 0.5182811563825329, 0.12341364237884933, 0.1073873101987548, 0.10945269861027063, 0.10986038047634006, 0.11784776852205214, 0.12587682637344677, 0.11521241936204629, 0.11760816941827157, 0.11039439337537515, 0.17945787279016645, 0.16525179133838885, 0.1833472104245084, 0.20568448508569437, 0.18257813857558824, 0.1822590745010314, 0.1996896318633271, 0.1579462218008204, 0.1845949585663994, 0.3175922370886515, 0.27079430816087946, 0.29423285722987824, 0.32254834974056845, 0.3229206694521586, 0.2978575149198859, 0.3560589020116117, 0.3380061386418942, 0.2950602400418929, 0.24422219423779534, 0.2653211322015693, 0.19400340572528907, 0.19424116058824104, 0.2296048171120859, 0.22598393083904034, 0.2673350201665974, 0.22878523108811544, 0.2308965540220035, 0.19831123304847598, 0.19537496964315937, 0.19755643421024027, 0.19985656979974142, 0.21902261479342267, 0.20744602086716424, 0.20903059916169442, 0.1957245627298314, 0.18615169633337703, 0.2040667053929398, 0.2492249714583954, 0.2423674737352438, 0.23969561474671786, 0.2832286512815625, 0.25047345279860656, 0.2393529799810249, 0.2206063515547524, 0.20060864570779724, 0.26398367529322697, 0.2323317784147333, 0.3000793762845787, 0.2568601986307669, 0.2330158599133425, 0.2142501515811115, 0.19802973490125697, 0.2571952452802938, 0.19155972809487187, 0.26057036880512974, 0.33413890580164285, 0.25259270032424264, 0.28357133747098073, 0.22568207800077167, 0.22520676677008267, 0.30065099738010637, 0.24800648245040402, 0.2775060347364413, 0.1782857093759107, 0.19952785957140884, 0.19210562252402785, 0.17847963633591024, 0.19429645777354765, 0.1834060860245269, 0.19083141170187257, 0.2056167388637804, 0.18435774697637541, 0.08997616029141042, 0.08339611317798024, 0.07911008649682372, 0.07601146128788783, 0.08372251837912881, 0.08371416313250901, 0.07945406515489628, 0.08348944062487695, 0.08118649984395632]}, "mutation_prompt": null}
{"id": "7a130184-d30c-4abc-b4b4-9f4c43c942d0", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5  # New adaptive learning rate\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant1 = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        d, e, f = pop[np.random.choice(indices, 3, replace=False)]\n        mutant2 = np.clip(d + self.F * (e - f), self.lower_bound, self.upper_bound)\n        return mutant1 if np.random.rand() > 0.5 else mutant2\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                # Adjust F dynamically based on budget usage\n                self.F = self.adaptive_alpha * (1.0 - evals / self.budget)\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "An adaptive learning rate strategy is integrated with hybrid differential evolution to balance exploration and exploitation dynamically.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9f3c7723-86d1-4724-9b7f-878e4b874813", "metadata": {"aucs": [0.7806828199530647, 0.7403179105140761, 0.749761207096203, 0.7437351002018535, 0.7422547586057751, 0.7545929958322929, 0.7535537627469555, 0.7489236726620501, 0.761675357887737, 0.6062442212528227, 0.5763777532569886, 0.5819588108848505, 0.5394710372703809, 0.5509203761675361, 0.5605211083640753, 0.5394671996656535, 0.5630743984576695, 0.5618417824560498, 0.13901442188714008, 0.13625660992051802, 0.14144542233492285, 0.17367055120657493, 0.17730699490540303, 0.17581988604241727, 0.15406358055666203, 0.17957205113590158, 0.13308267056179446, 0.12812492863094704, 0.14194480028532797, 0.13289732965164858, 0.15237465899438563, 0.11254448473549761, 0.12907041877984504, 0.13355398953912645, 0.12418050625986199, 0.14420623897139961, 0.887155769711066, 0.8408769009974477, 0.8352716331657296, 0.8682342877856334, 0.8766241878804538, 0.8846493680238336, 0.8933381774492608, 0.8743154653129396, 0.9418761977200172, 0.3266027583811265, 0.3167190223066785, 0.3345489830272028, 0.3255116170363217, 0.3124641274171992, 0.33773571880694475, 0.30322849603344737, 0.31819706847850926, 0.3194660147589409, 0.663327086379958, 0.6700214230808077, 0.6848265215944647, 0.7068522508267706, 0.7001195716063847, 0.7086245137072056, 0.6874337293130075, 0.7159884619690349, 0.7177758821565152, 0.1433553717170395, 0.18044206247077021, 0.16509295185505524, 0.18028187926497596, 0.2666713968955393, 0.16837579738583186, 0.2998233639476704, 0.24659264627640498, 0.19274903068580496, 0.1782641951886299, 0.13181977437302972, 0.21665502951395477, 0.16055459663974703, 0.20445327619472353, 0.16065052729397433, 0.1976246048506749, 0.149239470508151, 0.1335080599465931, 0.1559063189742197, 0.17184712251803536, 0.14001218590670816, 0.1956796169463022, 0.14298850145748332, 0.17322775598754414, 0.17994366218028734, 0.1799585025271726, 0.09741797689075449, 0.2843703898892923, 0.3490963359013285, 0.3456562900596051, 0.2862152595852935, 0.20349894899408705, 0.21065982467513888, 0.33258374870033147, 0.2931357268788499, 0.3514297168246815, 0.10971641741672811, 0.05876809547926243, 0.07878200842314931, 0.1429578450432364, 0.09790599224212437, 0.10292479412555133, 0.10520060131816766, 0.07881251725719396, 0.1050998893345324, 0.2104795658489126, 0.202937224584116, 0.21177315495000426, 0.21016714919742363, 0.24003053387589002, 0.19577950098307684, 0.202849707842238, 0.22101519770501377, 0.21013353657912504, 0.5358501210784654, 0.5687325796347134, 0.550555433297179, 0.5321124514300758, 0.5046365014008675, 0.5360665037343553, 0.6201470147689343, 0.5739774942429292, 0.6378699883536221, 0.12084245863412157, 0.10800609635105263, 0.1267290545989327, 0.11179988907819494, 0.1293432859368726, 0.1228504144501803, 0.112763148165832, 0.13321393126864456, 0.11501154478545306, 0.1717787522443932, 0.18865191873923426, 0.1772077686838751, 0.20670991135765548, 0.18633318640261665, 0.19764834920673668, 0.1762414464141404, 0.20362560482986203, 0.16280633167833114, 0.398852879854958, 0.366829536596082, 0.4068396996522792, 0.35883984762832843, 0.34437488835819163, 0.3618441910831469, 0.40398539460405103, 0.4115351786749357, 0.39616219675792574, 0.2819969362125181, 0.28126773776026415, 0.26870832918963583, 0.26437044142730803, 0.308194817348421, 0.27886819617099756, 0.29400736881433653, 0.2980173316871074, 0.32553798311560844, 0.19953109516206124, 0.2047321727400535, 0.2246831938743784, 0.2566382370869935, 0.23801066883682842, 0.20067820955804394, 0.20475514122786742, 0.1914286880735968, 0.20671475174251486, 0.20234908732742285, 0.23233593626710103, 0.25511862833590404, 0.24218692259768104, 0.2617336922030612, 0.23448667431985948, 0.24398830665127202, 0.26551102409573446, 0.20931520975196016, 0.672196158736137, 0.703662516010737, 0.6299656556971335, 0.6038786140226907, 0.5503174739037415, 0.5220296232997237, 0.4631728368882815, 0.3286892354050146, 0.5309551059485893, 0.7082942642271719, 0.37063354255047376, 0.1952245071226375, 0.19824993911368716, 0.197435019238569, 0.19042170256846547, 0.530332019647262, 0.2024881103719406, 0.6360583351179672, 0.1920723986037789, 0.19255285959190704, 0.2029587462447715, 0.18282224112015832, 0.18549154128447487, 0.18977658579526713, 0.18356843844151083, 0.19763036207802753, 0.19026672498823083, 0.07789093452251106, 0.08106650335728005, 0.08778435105125848, 0.08633264238355043, 0.08349775788457048, 0.08178728630572152, 0.08290025507384802, 0.08331776896454501, 0.07682285048021675]}, "mutation_prompt": null}
{"id": "53955bf5-2590-448f-a31a-f7ab2595317a", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5  # New adaptive learning rate\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant1 = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        d, e, f = pop[np.random.choice(indices, 3, replace=False)]\n        mutant2 = np.clip(d + self.F * (e - f), self.lower_bound, self.upper_bound)\n        return mutant1 if np.random.rand() > 0.5 else mutant2\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                # Adjust F dynamically based on budget usage\n                self.F = self.adaptive_alpha * (1.0 - evals / self.budget)\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "An adaptive learning rate strategy is integrated with hybrid differential evolution to balance exploration and exploitation dynamically.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9f3c7723-86d1-4724-9b7f-878e4b874813", "metadata": {"aucs": [0.7806828199530647, 0.7403179105140761, 0.749761207096203, 0.7437351002018535, 0.7422547586057751, 0.7545929958322929, 0.7535537627469555, 0.7489236726620501, 0.761675357887737, 0.6062442212528227, 0.5763777532569886, 0.5819588108848505, 0.5394710372703809, 0.5509203761675361, 0.5605211083640753, 0.5394671996656535, 0.5630743984576695, 0.5618417824560498, 0.13901442188714008, 0.13625660992051802, 0.14144542233492285, 0.17367055120657493, 0.17730699490540303, 0.17581988604241727, 0.15406358055666203, 0.17957205113590158, 0.13308267056179446, 0.12812492863094704, 0.14194480028532797, 0.13289732965164858, 0.15237465899438563, 0.11254448473549761, 0.12907041877984504, 0.13355398953912645, 0.12418050625986199, 0.14420623897139961, 0.887155769711066, 0.8408769009974477, 0.8352716331657296, 0.8682342877856334, 0.8766241878804538, 0.8846493680238336, 0.8933381774492608, 0.8743154653129396, 0.9418761977200172, 0.3266027583811265, 0.3167190223066785, 0.3345489830272028, 0.3255116170363217, 0.3124641274171992, 0.33773571880694475, 0.30322849603344737, 0.31819706847850926, 0.3194660147589409, 0.663327086379958, 0.6700214230808077, 0.6848265215944647, 0.7068522508267706, 0.7001195716063847, 0.7086245137072056, 0.6874337293130075, 0.7159884619690349, 0.7177758821565152, 0.1433553717170395, 0.18044206247077021, 0.16509295185505524, 0.18028187926497596, 0.2666713968955393, 0.16837579738583186, 0.2998233639476704, 0.24659264627640498, 0.19274903068580496, 0.1782641951886299, 0.13181977437302972, 0.21665502951395477, 0.16055459663974703, 0.20445327619472353, 0.16065052729397433, 0.1976246048506749, 0.149239470508151, 0.1335080599465931, 0.1559063189742197, 0.17184712251803536, 0.14001218590670816, 0.1956796169463022, 0.14298850145748332, 0.17322775598754414, 0.17994366218028734, 0.1799585025271726, 0.09741797689075449, 0.2843703898892923, 0.3490963359013285, 0.3456562900596051, 0.2862152595852935, 0.20349894899408705, 0.21065982467513888, 0.33258374870033147, 0.2931357268788499, 0.3514297168246815, 0.10971641741672811, 0.05876809547926243, 0.07878200842314931, 0.1429578450432364, 0.09790599224212437, 0.10292479412555133, 0.10520060131816766, 0.07881251725719396, 0.1050998893345324, 0.2104795658489126, 0.202937224584116, 0.21177315495000426, 0.21016714919742363, 0.24003053387589002, 0.19577950098307684, 0.202849707842238, 0.22101519770501377, 0.21013353657912504, 0.5358501210784654, 0.5687325796347134, 0.550555433297179, 0.5321124514300758, 0.5046365014008675, 0.5360665037343553, 0.6201470147689343, 0.5739774942429292, 0.6378699883536221, 0.12084245863412157, 0.10800609635105263, 0.1267290545989327, 0.11179988907819494, 0.1293432859368726, 0.1228504144501803, 0.112763148165832, 0.13321393126864456, 0.11501154478545306, 0.1717787522443932, 0.18865191873923426, 0.1772077686838751, 0.20670991135765548, 0.18633318640261665, 0.19764834920673668, 0.1762414464141404, 0.20362560482986203, 0.16280633167833114, 0.398852879854958, 0.366829536596082, 0.4068396996522792, 0.35883984762832843, 0.34437488835819163, 0.3618441910831469, 0.40398539460405103, 0.4115351786749357, 0.39616219675792574, 0.2819969362125181, 0.28126773776026415, 0.26870832918963583, 0.26437044142730803, 0.308194817348421, 0.27886819617099756, 0.29400736881433653, 0.2980173316871074, 0.32553798311560844, 0.19953109516206124, 0.2047321727400535, 0.2246831938743784, 0.2566382370869935, 0.23801066883682842, 0.20067820955804394, 0.20475514122786742, 0.1914286880735968, 0.20671475174251486, 0.20234908732742285, 0.23233593626710103, 0.25511862833590404, 0.24218692259768104, 0.2617336922030612, 0.23448667431985948, 0.24398830665127202, 0.26551102409573446, 0.20931520975196016, 0.672196158736137, 0.703662516010737, 0.6299656556971335, 0.6038786140226907, 0.5503174739037415, 0.5220296232997237, 0.4631728368882815, 0.3286892354050146, 0.5309551059485893, 0.7082942642271719, 0.37063354255047376, 0.1952245071226375, 0.19824993911368716, 0.197435019238569, 0.19042170256846547, 0.530332019647262, 0.2024881103719406, 0.6360583351179672, 0.1920723986037789, 0.19255285959190704, 0.2029587462447715, 0.18282224112015832, 0.18549154128447487, 0.18977658579526713, 0.18356843844151083, 0.19763036207802753, 0.19026672498823083, 0.07789093452251106, 0.08106650335728005, 0.08778435105125848, 0.08633264238355043, 0.08349775788457048, 0.08178728630572152, 0.08290025507384802, 0.08331776896454501, 0.07682285048021675]}, "mutation_prompt": null}
{"id": "5abd826b-fecc-400f-8617-7d7b1e241913", "solution": "import numpy as np\n\nclass RefinedEnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5  # New adaptive learning rate\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        mutant1 = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        d, e, f = pop[np.random.choice(indices, 3, replace=False)]\n        mutant2 = np.clip(d + self.F * (e - f), self.lower_bound, self.upper_bound)\n        \n        # Hybrid mutation strategy\n        g, h, i = pop[np.random.choice(indices, 3, replace=False)]\n        hybrid = np.clip(g + self.F * (h - i) + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant1 if np.random.rand() > 0.5 else mutant2 if np.random.rand() > 0.5 else hybrid\n\n    def _crossover(self, target, mutant, fitness_target, fitness_mutant):\n        # Adaptive crossover based on fitness\n        if fitness_mutant < fitness_target:\n            self.CR = min(1.0, self.CR + 0.1)\n        else:\n            self.CR = max(0.4, self.CR - 0.1)\n            \n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                # Adjust F dynamically based on budget usage\n                self.F = self.adaptive_alpha * (1.0 - evals / self.budget)\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant, fitness[i], func(mutant))\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "RefinedEnhancedHybridDifferentialEvolution", "description": "Refined EnhancedHybridDifferentialEvolution with fitness-based crossover adaptation and hybrid mutation for improved performance.", "configspace": "", "generation": 67, "fitness": 0.21005373157089574, "feedback": "The algorithm RefinedEnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.18.", "error": "", "parent_id": "9f3c7723-86d1-4724-9b7f-878e4b874813", "metadata": {"aucs": [0.5463157463802519, 0.541877249311778, 0.5587748226350198, 0.5752017538930503, 0.5927314768583464, 0.603103546809453, 0.5608142995839049, 0.533887529704766, 0.5401381235040073, 0.29696028744142045, 0.26240463068415065, 0.26892720589808783, 0.2604885756849946, 0.24107104543014723, 0.2922255223269903, 0.24863190275067326, 0.27069150714605106, 0.2992722409609242, 0.12667302952396853, 0.13230186623559803, 0.12082614268970249, 0.13220449920121646, 0.13405218902863003, 0.11415277477366492, 0.12327059733488044, 0.13004233186827074, 0.13259434739710363, 0.11145324509461318, 0.10622455998330937, 0.10463360218624207, 0.11670755712764092, 0.10498424065851963, 0.10664311185225561, 0.10364352610986294, 0.11884220039250981, 0.10623319453338731, 0.9063117974604346, 0.8180024207105843, 0.7386975580487136, 0.7924601140280035, 0.8877580152788329, 0.8397335322980362, 0.9203176720940857, 0.8940708262654803, 0.7736661143494614, 0.20449467940245802, 0.18208721037280173, 0.17169597574693907, 0.16032567032312328, 0.1793461373134756, 0.215585046201465, 0.18282600274815253, 0.20774118406871545, 0.19131858926377932, 0.22020817104801416, 0.24885531962691265, 0.24600600989518417, 0.25302768723246283, 0.26747816764143495, 0.2955254130379663, 0.23858601810827473, 0.35355296003773473, 0.22996487963395829, 0.10105313702846086, 0.14025485765063828, 0.15605659520416082, 0.13436388272869504, 0.13066374412300852, 0.13101781092955678, 0.1694244687059865, 0.13644715607885083, 0.14104581593743826, 0.11306595389105956, 0.09463230314082016, 0.110229256794793, 0.13538691731695596, 0.12298735188226584, 0.12518956516508328, 0.12663756220173072, 0.15224991996593185, 0.09840994433329975, 0.005687496208691689, 0.010557942204464932, 0.024528828261541125, 0.03316564209289752, 0.01897134172348247, 0.01946571581995704, 0.020644227985232133, 0.02954437536343324, 0.02700853455262109, 0.10818833934471861, 0.11664114705764228, 0.11532907211171384, 0.10722131150479486, 0.12337953423977377, 0.10654246963056158, 0.152094183763127, 0.14618890810247498, 0.1419044504630549, 0.020697847073474773, 0.014043039042767713, 0.005162389175960014, 0.022746177154416958, 0.022532969235223965, 0.008070559678744038, 0.024812746935637175, 0.009541493566043169, 0.020622578649923007, 0.10115913499347351, 0.09962462951545914, 0.1103292354943145, 0.10405942318434369, 0.11246913329022123, 0.11350498006680776, 0.11237657276760604, 0.08170512994317747, 0.09574640965642445, 0.4217365500938801, 0.42359923348648076, 0.4096911897650102, 0.42835976626455075, 0.39998829897891686, 0.42596892254830554, 0.43081746549717825, 0.40555248463699667, 0.43308967800372544, 0.0882108959463096, 0.08881336368032988, 0.09649292482009963, 0.08731387956933889, 0.08507768182791864, 0.09305579070667336, 0.09245737371122487, 0.08621224818073736, 0.08218772636965421, 0.18335407286729732, 0.18030380063092422, 0.18548111420637114, 0.17977982956626215, 0.1488603164048622, 0.151247141636909, 0.17705491856485, 0.1426435749027103, 0.17045065119795544, 0.2092393302252583, 0.2300186082810607, 0.21855116436891409, 0.2336720350908269, 0.2151998346069357, 0.2215713259904597, 0.23974419428560623, 0.24912695304057608, 0.23467352624109372, 0.16216254130674224, 0.1504533421417813, 0.1765147531325978, 0.1877423955427665, 0.1667784030261329, 0.16258100808001041, 0.15677552456934596, 0.20906839588485027, 0.15995620009276867, 0.19534425836465974, 0.18562365027370564, 0.19419610905544127, 0.2110602285802713, 0.18426323886619678, 0.1905533299441049, 0.2108524877452138, 0.19368848578260345, 0.19781613596141923, 0.1947196869559975, 0.18508290600824073, 0.1959429344885023, 0.20256921837927733, 0.1922988872351591, 0.20229205334528633, 0.19080694945852938, 0.2294644215813858, 0.19250792830007968, 0.1818571221899764, 0.2442796683289724, 0.19793032897710405, 0.19775521400314788, 0.2280904731661002, 0.2638769154668782, 0.21797078858007835, 0.16191001537639693, 0.186641809687346, 0.29285624346834416, 0.1764903637875892, 0.21417808326400445, 0.22736345146312864, 0.1961307909882818, 0.20349232494083613, 0.16830696872854245, 0.24730340029232456, 0.22942156577043005, 0.1896595858787371, 0.20905923639056256, 0.1804550999317256, 0.19238222950189743, 0.17488883724926074, 0.185102494143757, 0.18709007231215424, 0.192558854503301, 0.20125956918883658, 0.0707366663324287, 0.07526461895999381, 0.0694499873985791, 0.07688026798267134, 0.07022082409197117, 0.07359452734917415, 0.068376649672519, 0.06907653235622857, 0.0749532291261128]}, "mutation_prompt": null}
{"id": "c77bb9e7-6928-44a5-b72c-70bd7cd4a569", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5  # New adaptive learning rate\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        self.F = self.adaptive_alpha * (1.0 - np.random.rand() / 2)  # Self-adaptive mutation\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                # Adjust F dynamically based on budget usage\n                self.F = self.adaptive_alpha * (1.0 - evals / self.budget)\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "Integrate a self-adaptive mutation strategy with hybrid differential evolution to enhance convergence speed and accuracy.", "configspace": "", "generation": 68, "fitness": 0.3332313032721532, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.23.", "error": "", "parent_id": "9f3c7723-86d1-4724-9b7f-878e4b874813", "metadata": {"aucs": [0.7612133547626164, 0.7635974135918435, 0.7752878518207924, 0.7744891485125145, 0.7590266227141119, 0.765587013101981, 0.7623863846616221, 0.7708785550831908, 0.7556583284882229, 0.5516486341526301, 0.5731050850960036, 0.554864346304295, 0.5520674801575232, 0.5554410226692565, 0.5520266004358985, 0.5733179390909917, 0.5761366394863301, 0.5622457240215442, 0.131982600206634, 0.12915625458784674, 0.14383674304306315, 0.1338704409097463, 0.16154127440768518, 0.14322627575824953, 0.12363742621879115, 0.14506029149421973, 0.12784478342452732, 0.1196730559607504, 0.1094351055782703, 0.11686657251810662, 0.11613887553412128, 0.10515886888394821, 0.12617941931389398, 0.13227034434241836, 0.12496419636417433, 0.11704885698844414, 0.9307894154904343, 0.8779419650175174, 0.8492317114705105, 0.8967478489291592, 0.8844277776719465, 0.8384345033818077, 0.8686050382190194, 0.9637171134794177, 0.8862853965963882, 0.3752185515626154, 0.3615062602778808, 0.3915368370179376, 0.3530206579866112, 0.3458488811273339, 0.3289595836612633, 0.40017768415747523, 0.3486172987200348, 0.3695876032646632, 0.7039373306397954, 0.6745818425018811, 0.6923577316103662, 0.6828176113769283, 0.7118898391770248, 0.7110946795801579, 0.6702243315467178, 0.6993007089991511, 0.7332937561281794, 0.292307125009745, 0.19482608114683153, 0.2110641015662491, 0.17132981672490755, 0.15282956836629313, 0.22156283575110458, 0.17474271301211686, 0.1801169781087807, 0.2632574709449803, 0.1522750233191288, 0.1546217557733076, 0.27918226678415115, 0.17605864750728328, 0.20458264529164716, 0.24356065346793332, 0.18415509924700613, 0.18654016887535552, 0.17761447647866446, 0.20498826475822207, 0.1965450369790377, 0.2741291640484672, 0.22120134394487279, 0.24337747783720198, 0.21519640039819343, 0.23017529575789053, 0.2593010197665784, 0.24581757752947253, 0.34651807461528117, 0.36326595410228535, 0.3490898128523129, 0.3517188836346363, 0.335412606937182, 0.25904237953094744, 0.39148075402422267, 0.4257512562398018, 0.3032495934658621, 0.15917896970816692, 0.0844888656729087, 0.09547072483373176, 0.11351521934790088, 0.08161504373974893, 0.13108295199320041, 0.0749484423244905, 0.09812205265389007, 0.10596183941294435, 0.1992035028913237, 0.2332339828190989, 0.21882281661931335, 0.24179433180059595, 0.24709753740947316, 0.25593443679161254, 0.25238305775811376, 0.21459292618186776, 0.21053595536415537, 0.6278013485156035, 0.6180073476499195, 0.6350056156318289, 0.5808019853543325, 0.5949342521092276, 0.6293991123842815, 0.6388372142719174, 0.5881284309345677, 0.6246454091841627, 0.12130407531500864, 0.11528096244977515, 0.1149247274073385, 0.11491727616848735, 0.1128360742742861, 0.13232335542400653, 0.10676173018641744, 0.12449673485265378, 0.1286318868687606, 0.20599692288977378, 0.16812019616172347, 0.17553272870984804, 0.17958757976441286, 0.1616736806204484, 0.1664904330928193, 0.16888219485881395, 0.18365030097905277, 0.1783060831907396, 0.39061235436132113, 0.35185474644864, 0.3789196894124792, 0.3408393739835268, 0.3710663501850471, 0.33813373325719975, 0.388047322068548, 0.42223019968695075, 0.38162707434060705, 0.275796371328908, 0.3158537510454337, 0.2692635564641016, 0.3129351804094942, 0.2960868634000229, 0.2970844998614165, 0.2948334622908376, 0.2847763399174581, 0.2824922857440786, 0.20429662289329287, 0.22674174205701214, 0.2198412057146617, 0.2327645837110891, 0.19495616315404674, 0.20627633369578646, 0.19094814479977285, 0.21399320028801871, 0.19860748446532794, 0.19303241727571452, 0.2359463239392373, 0.212268510578828, 0.23807825541125527, 0.23613302747663378, 0.257656565538399, 0.20133480741106058, 0.19211873038970817, 0.20552555973047903, 0.5272605682420436, 0.18585211525015133, 0.6494803128618508, 0.47085216185846146, 0.7505794032227436, 0.5566847808247446, 0.602027689498045, 0.170682663312268, 0.6272166775319116, 0.3790953833019882, 0.681313707358442, 0.20230767502941127, 0.2025086598973358, 0.5690565496406128, 0.24129526554410752, 0.19840143416061873, 0.20432878888251427, 0.5367424243896946, 0.18737994247854983, 0.1947061126880285, 0.1914849448154483, 0.1863607724844072, 0.18898707215101618, 0.19499773413061317, 0.184280504036488, 0.19424548602585823, 0.19005294629459746, 0.09455499535230505, 0.0946368663092153, 0.09802169414539474, 0.08895328236027977, 0.08948855193254401, 0.08461738726790513, 0.08657557234219526, 0.08448907428396502, 0.08629934449377052]}, "mutation_prompt": null}
{"id": "ae70ef88-e3db-4ba4-bae9-8d88fb3543fc", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5  # New adaptive learning rate\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        self.F = self.adaptive_alpha * (1.0 - np.random.rand() / 2)  # Self-adaptive mutation\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                # Adjust F dynamically based on budget usage\n                self.F = self.adaptive_alpha * (1.0 - evals / self.budget)\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "Integrate a self-adaptive mutation strategy with hybrid differential evolution to enhance convergence speed and accuracy.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c77bb9e7-6928-44a5-b72c-70bd7cd4a569", "metadata": {"aucs": [0.7612133547626164, 0.7635974135918435, 0.7752878518207924, 0.7744891485125145, 0.7590266227141119, 0.765587013101981, 0.7623863846616221, 0.7708785550831908, 0.7556583284882229, 0.5516486341526301, 0.5731050850960036, 0.554864346304295, 0.5520674801575232, 0.5554410226692565, 0.5520266004358985, 0.5733179390909917, 0.5761366394863301, 0.5622457240215442, 0.131982600206634, 0.12915625458784674, 0.14383674304306315, 0.1338704409097463, 0.16154127440768518, 0.14322627575824953, 0.12363742621879115, 0.14506029149421973, 0.12784478342452732, 0.1196730559607504, 0.1094351055782703, 0.11686657251810662, 0.11613887553412128, 0.10515886888394821, 0.12617941931389398, 0.13227034434241836, 0.12496419636417433, 0.11704885698844414, 0.9307894154904343, 0.8779419650175174, 0.8492317114705105, 0.8967478489291592, 0.8844277776719465, 0.8384345033818077, 0.8686050382190194, 0.9637171134794177, 0.8862853965963882, 0.3752185515626154, 0.3615062602778808, 0.3915368370179376, 0.3530206579866112, 0.3458488811273339, 0.3289595836612633, 0.40017768415747523, 0.3486172987200348, 0.3695876032646632, 0.7039373306397954, 0.6745818425018811, 0.6923577316103662, 0.6828176113769283, 0.7118898391770248, 0.7110946795801579, 0.6702243315467178, 0.6993007089991511, 0.7332937561281794, 0.292307125009745, 0.19482608114683153, 0.2110641015662491, 0.17132981672490755, 0.15282956836629313, 0.22156283575110458, 0.17474271301211686, 0.1801169781087807, 0.2632574709449803, 0.1522750233191288, 0.1546217557733076, 0.27918226678415115, 0.17605864750728328, 0.20458264529164716, 0.24356065346793332, 0.18415509924700613, 0.18654016887535552, 0.17761447647866446, 0.20498826475822207, 0.1965450369790377, 0.2741291640484672, 0.22120134394487279, 0.24337747783720198, 0.21519640039819343, 0.23017529575789053, 0.2593010197665784, 0.24581757752947253, 0.34651807461528117, 0.36326595410228535, 0.3490898128523129, 0.3517188836346363, 0.335412606937182, 0.25904237953094744, 0.39148075402422267, 0.4257512562398018, 0.3032495934658621, 0.15917896970816692, 0.0844888656729087, 0.09547072483373176, 0.11351521934790088, 0.08161504373974893, 0.13108295199320041, 0.0749484423244905, 0.09812205265389007, 0.10596183941294435, 0.1992035028913237, 0.2332339828190989, 0.21882281661931335, 0.24179433180059595, 0.24709753740947316, 0.25593443679161254, 0.25238305775811376, 0.21459292618186776, 0.21053595536415537, 0.6278013485156035, 0.6180073476499195, 0.6350056156318289, 0.5808019853543325, 0.5949342521092276, 0.6293991123842815, 0.6388372142719174, 0.5881284309345677, 0.6246454091841627, 0.12130407531500864, 0.11528096244977515, 0.1149247274073385, 0.11491727616848735, 0.1128360742742861, 0.13232335542400653, 0.10676173018641744, 0.12449673485265378, 0.1286318868687606, 0.20599692288977378, 0.16812019616172347, 0.17553272870984804, 0.17958757976441286, 0.1616736806204484, 0.1664904330928193, 0.16888219485881395, 0.18365030097905277, 0.1783060831907396, 0.39061235436132113, 0.35185474644864, 0.3789196894124792, 0.3408393739835268, 0.3710663501850471, 0.33813373325719975, 0.388047322068548, 0.42223019968695075, 0.38162707434060705, 0.275796371328908, 0.3158537510454337, 0.2692635564641016, 0.3129351804094942, 0.2960868634000229, 0.2970844998614165, 0.2948334622908376, 0.2847763399174581, 0.2824922857440786, 0.20429662289329287, 0.22674174205701214, 0.2198412057146617, 0.2327645837110891, 0.19495616315404674, 0.20627633369578646, 0.19094814479977285, 0.21399320028801871, 0.19860748446532794, 0.19303241727571452, 0.2359463239392373, 0.212268510578828, 0.23807825541125527, 0.23613302747663378, 0.257656565538399, 0.20133480741106058, 0.19211873038970817, 0.20552555973047903, 0.5272605682420436, 0.18585211525015133, 0.6494803128618508, 0.47085216185846146, 0.7505794032227436, 0.5566847808247446, 0.602027689498045, 0.170682663312268, 0.6272166775319116, 0.3790953833019882, 0.681313707358442, 0.20230767502941127, 0.2025086598973358, 0.5690565496406128, 0.24129526554410752, 0.19840143416061873, 0.20432878888251427, 0.5367424243896946, 0.18737994247854983, 0.1947061126880285, 0.1914849448154483, 0.1863607724844072, 0.18898707215101618, 0.19499773413061317, 0.184280504036488, 0.19424548602585823, 0.19005294629459746, 0.09455499535230505, 0.0946368663092153, 0.09802169414539474, 0.08895328236027977, 0.08948855193254401, 0.08461738726790513, 0.08657557234219526, 0.08448907428396502, 0.08629934449377052]}, "mutation_prompt": null}
{"id": "b27634c9-06ad-40a7-a94b-70c7e6140f60", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5  # New adaptive learning rate\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        self.F = self.adaptive_alpha * (1.0 - np.random.rand() / 2)  # Self-adaptive mutation\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                # Adjust F dynamically based on budget usage\n                self.F = self.adaptive_alpha * (1.0 - evals / self.budget)\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "Integrate a self-adaptive mutation strategy with hybrid differential evolution to enhance convergence speed and accuracy.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c77bb9e7-6928-44a5-b72c-70bd7cd4a569", "metadata": {"aucs": [0.7612133547626164, 0.7635974135918435, 0.7752878518207924, 0.7744891485125145, 0.7590266227141119, 0.765587013101981, 0.7623863846616221, 0.7708785550831908, 0.7556583284882229, 0.5516486341526301, 0.5731050850960036, 0.554864346304295, 0.5520674801575232, 0.5554410226692565, 0.5520266004358985, 0.5733179390909917, 0.5761366394863301, 0.5622457240215442, 0.131982600206634, 0.12915625458784674, 0.14383674304306315, 0.1338704409097463, 0.16154127440768518, 0.14322627575824953, 0.12363742621879115, 0.14506029149421973, 0.12784478342452732, 0.1196730559607504, 0.1094351055782703, 0.11686657251810662, 0.11613887553412128, 0.10515886888394821, 0.12617941931389398, 0.13227034434241836, 0.12496419636417433, 0.11704885698844414, 0.9307894154904343, 0.8779419650175174, 0.8492317114705105, 0.8967478489291592, 0.8844277776719465, 0.8384345033818077, 0.8686050382190194, 0.9637171134794177, 0.8862853965963882, 0.3752185515626154, 0.3615062602778808, 0.3915368370179376, 0.3530206579866112, 0.3458488811273339, 0.3289595836612633, 0.40017768415747523, 0.3486172987200348, 0.3695876032646632, 0.7039373306397954, 0.6745818425018811, 0.6923577316103662, 0.6828176113769283, 0.7118898391770248, 0.7110946795801579, 0.6702243315467178, 0.6993007089991511, 0.7332937561281794, 0.292307125009745, 0.19482608114683153, 0.2110641015662491, 0.17132981672490755, 0.15282956836629313, 0.22156283575110458, 0.17474271301211686, 0.1801169781087807, 0.2632574709449803, 0.1522750233191288, 0.1546217557733076, 0.27918226678415115, 0.17605864750728328, 0.20458264529164716, 0.24356065346793332, 0.18415509924700613, 0.18654016887535552, 0.17761447647866446, 0.20498826475822207, 0.1965450369790377, 0.2741291640484672, 0.22120134394487279, 0.24337747783720198, 0.21519640039819343, 0.23017529575789053, 0.2593010197665784, 0.24581757752947253, 0.34651807461528117, 0.36326595410228535, 0.3490898128523129, 0.3517188836346363, 0.335412606937182, 0.25904237953094744, 0.39148075402422267, 0.4257512562398018, 0.3032495934658621, 0.15917896970816692, 0.0844888656729087, 0.09547072483373176, 0.11351521934790088, 0.08161504373974893, 0.13108295199320041, 0.0749484423244905, 0.09812205265389007, 0.10596183941294435, 0.1992035028913237, 0.2332339828190989, 0.21882281661931335, 0.24179433180059595, 0.24709753740947316, 0.25593443679161254, 0.25238305775811376, 0.21459292618186776, 0.21053595536415537, 0.6278013485156035, 0.6180073476499195, 0.6350056156318289, 0.5808019853543325, 0.5949342521092276, 0.6293991123842815, 0.6388372142719174, 0.5881284309345677, 0.6246454091841627, 0.12130407531500864, 0.11528096244977515, 0.1149247274073385, 0.11491727616848735, 0.1128360742742861, 0.13232335542400653, 0.10676173018641744, 0.12449673485265378, 0.1286318868687606, 0.20599692288977378, 0.16812019616172347, 0.17553272870984804, 0.17958757976441286, 0.1616736806204484, 0.1664904330928193, 0.16888219485881395, 0.18365030097905277, 0.1783060831907396, 0.39061235436132113, 0.35185474644864, 0.3789196894124792, 0.3408393739835268, 0.3710663501850471, 0.33813373325719975, 0.388047322068548, 0.42223019968695075, 0.38162707434060705, 0.275796371328908, 0.3158537510454337, 0.2692635564641016, 0.3129351804094942, 0.2960868634000229, 0.2970844998614165, 0.2948334622908376, 0.2847763399174581, 0.2824922857440786, 0.20429662289329287, 0.22674174205701214, 0.2198412057146617, 0.2327645837110891, 0.19495616315404674, 0.20627633369578646, 0.19094814479977285, 0.21399320028801871, 0.19860748446532794, 0.19303241727571452, 0.2359463239392373, 0.212268510578828, 0.23807825541125527, 0.23613302747663378, 0.257656565538399, 0.20133480741106058, 0.19211873038970817, 0.20552555973047903, 0.5272605682420436, 0.18585211525015133, 0.6494803128618508, 0.47085216185846146, 0.7505794032227436, 0.5566847808247446, 0.602027689498045, 0.170682663312268, 0.6272166775319116, 0.3790953833019882, 0.681313707358442, 0.20230767502941127, 0.2025086598973358, 0.5690565496406128, 0.24129526554410752, 0.19840143416061873, 0.20432878888251427, 0.5367424243896946, 0.18737994247854983, 0.1947061126880285, 0.1914849448154483, 0.1863607724844072, 0.18898707215101618, 0.19499773413061317, 0.184280504036488, 0.19424548602585823, 0.19005294629459746, 0.09455499535230505, 0.0946368663092153, 0.09802169414539474, 0.08895328236027977, 0.08948855193254401, 0.08461738726790513, 0.08657557234219526, 0.08448907428396502, 0.08629934449377052]}, "mutation_prompt": null}
{"id": "3bdc1819-be8e-4a9a-9cf4-4eaa55c9319c", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5  # New adaptive learning rate\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        self.F = self.adaptive_alpha * (1.0 - np.random.rand() / 2)  # Self-adaptive mutation\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                # Adjust F dynamically based on budget usage\n                self.F = self.adaptive_alpha * (1.0 - evals / self.budget)\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "Integrate a self-adaptive mutation strategy with hybrid differential evolution to enhance convergence speed and accuracy.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c77bb9e7-6928-44a5-b72c-70bd7cd4a569", "metadata": {"aucs": [0.7612133547626164, 0.7635974135918435, 0.7752878518207924, 0.7744891485125145, 0.7590266227141119, 0.765587013101981, 0.7623863846616221, 0.7708785550831908, 0.7556583284882229, 0.5516486341526301, 0.5731050850960036, 0.554864346304295, 0.5520674801575232, 0.5554410226692565, 0.5520266004358985, 0.5733179390909917, 0.5761366394863301, 0.5622457240215442, 0.131982600206634, 0.12915625458784674, 0.14383674304306315, 0.1338704409097463, 0.16154127440768518, 0.14322627575824953, 0.12363742621879115, 0.14506029149421973, 0.12784478342452732, 0.1196730559607504, 0.1094351055782703, 0.11686657251810662, 0.11613887553412128, 0.10515886888394821, 0.12617941931389398, 0.13227034434241836, 0.12496419636417433, 0.11704885698844414, 0.9307894154904343, 0.8779419650175174, 0.8492317114705105, 0.8967478489291592, 0.8844277776719465, 0.8384345033818077, 0.8686050382190194, 0.9637171134794177, 0.8862853965963882, 0.3752185515626154, 0.3615062602778808, 0.3915368370179376, 0.3530206579866112, 0.3458488811273339, 0.3289595836612633, 0.40017768415747523, 0.3486172987200348, 0.3695876032646632, 0.7039373306397954, 0.6745818425018811, 0.6923577316103662, 0.6828176113769283, 0.7118898391770248, 0.7110946795801579, 0.6702243315467178, 0.6993007089991511, 0.7332937561281794, 0.292307125009745, 0.19482608114683153, 0.2110641015662491, 0.17132981672490755, 0.15282956836629313, 0.22156283575110458, 0.17474271301211686, 0.1801169781087807, 0.2632574709449803, 0.1522750233191288, 0.1546217557733076, 0.27918226678415115, 0.17605864750728328, 0.20458264529164716, 0.24356065346793332, 0.18415509924700613, 0.18654016887535552, 0.17761447647866446, 0.20498826475822207, 0.1965450369790377, 0.2741291640484672, 0.22120134394487279, 0.24337747783720198, 0.21519640039819343, 0.23017529575789053, 0.2593010197665784, 0.24581757752947253, 0.34651807461528117, 0.36326595410228535, 0.3490898128523129, 0.3517188836346363, 0.335412606937182, 0.25904237953094744, 0.39148075402422267, 0.4257512562398018, 0.3032495934658621, 0.15917896970816692, 0.0844888656729087, 0.09547072483373176, 0.11351521934790088, 0.08161504373974893, 0.13108295199320041, 0.0749484423244905, 0.09812205265389007, 0.10596183941294435, 0.1992035028913237, 0.2332339828190989, 0.21882281661931335, 0.24179433180059595, 0.24709753740947316, 0.25593443679161254, 0.25238305775811376, 0.21459292618186776, 0.21053595536415537, 0.6278013485156035, 0.6180073476499195, 0.6350056156318289, 0.5808019853543325, 0.5949342521092276, 0.6293991123842815, 0.6388372142719174, 0.5881284309345677, 0.6246454091841627, 0.12130407531500864, 0.11528096244977515, 0.1149247274073385, 0.11491727616848735, 0.1128360742742861, 0.13232335542400653, 0.10676173018641744, 0.12449673485265378, 0.1286318868687606, 0.20599692288977378, 0.16812019616172347, 0.17553272870984804, 0.17958757976441286, 0.1616736806204484, 0.1664904330928193, 0.16888219485881395, 0.18365030097905277, 0.1783060831907396, 0.39061235436132113, 0.35185474644864, 0.3789196894124792, 0.3408393739835268, 0.3710663501850471, 0.33813373325719975, 0.388047322068548, 0.42223019968695075, 0.38162707434060705, 0.275796371328908, 0.3158537510454337, 0.2692635564641016, 0.3129351804094942, 0.2960868634000229, 0.2970844998614165, 0.2948334622908376, 0.2847763399174581, 0.2824922857440786, 0.20429662289329287, 0.22674174205701214, 0.2198412057146617, 0.2327645837110891, 0.19495616315404674, 0.20627633369578646, 0.19094814479977285, 0.21399320028801871, 0.19860748446532794, 0.19303241727571452, 0.2359463239392373, 0.212268510578828, 0.23807825541125527, 0.23613302747663378, 0.257656565538399, 0.20133480741106058, 0.19211873038970817, 0.20552555973047903, 0.5272605682420436, 0.18585211525015133, 0.6494803128618508, 0.47085216185846146, 0.7505794032227436, 0.5566847808247446, 0.602027689498045, 0.170682663312268, 0.6272166775319116, 0.3790953833019882, 0.681313707358442, 0.20230767502941127, 0.2025086598973358, 0.5690565496406128, 0.24129526554410752, 0.19840143416061873, 0.20432878888251427, 0.5367424243896946, 0.18737994247854983, 0.1947061126880285, 0.1914849448154483, 0.1863607724844072, 0.18898707215101618, 0.19499773413061317, 0.184280504036488, 0.19424548602585823, 0.19005294629459746, 0.09455499535230505, 0.0946368663092153, 0.09802169414539474, 0.08895328236027977, 0.08948855193254401, 0.08461738726790513, 0.08657557234219526, 0.08448907428396502, 0.08629934449377052]}, "mutation_prompt": null}
{"id": "fcb49f94-e9ee-4b7c-9cce-add0057dc823", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5  # New adaptive learning rate\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        self.F = self.adaptive_alpha * (1.0 - np.random.rand() / 2)  # Self-adaptive mutation\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                # Adjust F dynamically based on budget usage\n                self.F = self.adaptive_alpha * (1.0 - evals / self.budget)\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "Integrate a self-adaptive mutation strategy with hybrid differential evolution to enhance convergence speed and accuracy.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c77bb9e7-6928-44a5-b72c-70bd7cd4a569", "metadata": {"aucs": [0.7612133547626164, 0.7635974135918435, 0.7752878518207924, 0.7744891485125145, 0.7590266227141119, 0.765587013101981, 0.7623863846616221, 0.7708785550831908, 0.7556583284882229, 0.5516486341526301, 0.5731050850960036, 0.554864346304295, 0.5520674801575232, 0.5554410226692565, 0.5520266004358985, 0.5733179390909917, 0.5761366394863301, 0.5622457240215442, 0.131982600206634, 0.12915625458784674, 0.14383674304306315, 0.1338704409097463, 0.16154127440768518, 0.14322627575824953, 0.12363742621879115, 0.14506029149421973, 0.12784478342452732, 0.1196730559607504, 0.1094351055782703, 0.11686657251810662, 0.11613887553412128, 0.10515886888394821, 0.12617941931389398, 0.13227034434241836, 0.12496419636417433, 0.11704885698844414, 0.9307894154904343, 0.8779419650175174, 0.8492317114705105, 0.8967478489291592, 0.8844277776719465, 0.8384345033818077, 0.8686050382190194, 0.9637171134794177, 0.8862853965963882, 0.3752185515626154, 0.3615062602778808, 0.3915368370179376, 0.3530206579866112, 0.3458488811273339, 0.3289595836612633, 0.40017768415747523, 0.3486172987200348, 0.3695876032646632, 0.7039373306397954, 0.6745818425018811, 0.6923577316103662, 0.6828176113769283, 0.7118898391770248, 0.7110946795801579, 0.6702243315467178, 0.6993007089991511, 0.7332937561281794, 0.292307125009745, 0.19482608114683153, 0.2110641015662491, 0.17132981672490755, 0.15282956836629313, 0.22156283575110458, 0.17474271301211686, 0.1801169781087807, 0.2632574709449803, 0.1522750233191288, 0.1546217557733076, 0.27918226678415115, 0.17605864750728328, 0.20458264529164716, 0.24356065346793332, 0.18415509924700613, 0.18654016887535552, 0.17761447647866446, 0.20498826475822207, 0.1965450369790377, 0.2741291640484672, 0.22120134394487279, 0.24337747783720198, 0.21519640039819343, 0.23017529575789053, 0.2593010197665784, 0.24581757752947253, 0.34651807461528117, 0.36326595410228535, 0.3490898128523129, 0.3517188836346363, 0.335412606937182, 0.25904237953094744, 0.39148075402422267, 0.4257512562398018, 0.3032495934658621, 0.15917896970816692, 0.0844888656729087, 0.09547072483373176, 0.11351521934790088, 0.08161504373974893, 0.13108295199320041, 0.0749484423244905, 0.09812205265389007, 0.10596183941294435, 0.1992035028913237, 0.2332339828190989, 0.21882281661931335, 0.24179433180059595, 0.24709753740947316, 0.25593443679161254, 0.25238305775811376, 0.21459292618186776, 0.21053595536415537, 0.6278013485156035, 0.6180073476499195, 0.6350056156318289, 0.5808019853543325, 0.5949342521092276, 0.6293991123842815, 0.6388372142719174, 0.5881284309345677, 0.6246454091841627, 0.12130407531500864, 0.11528096244977515, 0.1149247274073385, 0.11491727616848735, 0.1128360742742861, 0.13232335542400653, 0.10676173018641744, 0.12449673485265378, 0.1286318868687606, 0.20599692288977378, 0.16812019616172347, 0.17553272870984804, 0.17958757976441286, 0.1616736806204484, 0.1664904330928193, 0.16888219485881395, 0.18365030097905277, 0.1783060831907396, 0.39061235436132113, 0.35185474644864, 0.3789196894124792, 0.3408393739835268, 0.3710663501850471, 0.33813373325719975, 0.388047322068548, 0.42223019968695075, 0.38162707434060705, 0.275796371328908, 0.3158537510454337, 0.2692635564641016, 0.3129351804094942, 0.2960868634000229, 0.2970844998614165, 0.2948334622908376, 0.2847763399174581, 0.2824922857440786, 0.20429662289329287, 0.22674174205701214, 0.2198412057146617, 0.2327645837110891, 0.19495616315404674, 0.20627633369578646, 0.19094814479977285, 0.21399320028801871, 0.19860748446532794, 0.19303241727571452, 0.2359463239392373, 0.212268510578828, 0.23807825541125527, 0.23613302747663378, 0.257656565538399, 0.20133480741106058, 0.19211873038970817, 0.20552555973047903, 0.5272605682420436, 0.18585211525015133, 0.6494803128618508, 0.47085216185846146, 0.7505794032227436, 0.5566847808247446, 0.602027689498045, 0.170682663312268, 0.6272166775319116, 0.3790953833019882, 0.681313707358442, 0.20230767502941127, 0.2025086598973358, 0.5690565496406128, 0.24129526554410752, 0.19840143416061873, 0.20432878888251427, 0.5367424243896946, 0.18737994247854983, 0.1947061126880285, 0.1914849448154483, 0.1863607724844072, 0.18898707215101618, 0.19499773413061317, 0.184280504036488, 0.19424548602585823, 0.19005294629459746, 0.09455499535230505, 0.0946368663092153, 0.09802169414539474, 0.08895328236027977, 0.08948855193254401, 0.08461738726790513, 0.08657557234219526, 0.08448907428396502, 0.08629934449377052]}, "mutation_prompt": null}
{"id": "5aadcf71-9b2f-444e-b6f2-f882da926a6a", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        self.F = self.adaptive_alpha * (1.0 - np.random.rand() / 2)\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant, evals):\n        dynamic_CR = self.CR * (0.5 + 0.5 * (1 - evals / self.budget))  # Dynamic CR\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, evals):\n        direction = np.random.normal(0, 1, self.dim)\n        scale = (1 - evals / self.budget) * 1.5  # Adaptive scaling\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                self.F = self.adaptive_alpha * (1.0 - evals / self.budget)\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant, evals)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    local_candidate = self._local_search(population[i], evals)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhance exploration and convergence by introducing a dynamic crossover rate and adaptive local search scaling.", "configspace": "", "generation": 73, "fitness": 0.28730932737380743, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.22.", "error": "", "parent_id": "c77bb9e7-6928-44a5-b72c-70bd7cd4a569", "metadata": {"aucs": [0.7611927390490458, 0.7453991043789094, 0.7584781023594174, 0.7508170719155198, 0.754082468568449, 0.7538026477722131, 0.7771988795580118, 0.7475204426479503, 0.7318112932544224, 0.5091628263587313, 0.5287777538535066, 0.5337559362852654, 0.53298651776702, 0.5649949611719334, 0.5484568748950127, 0.5193359350018831, 0.5695885546282331, 0.49256997403121694, 0.13695171347219925, 0.18307054124347588, 0.1530331369685768, 0.15839916164510648, 0.1428210557497721, 0.16394692986839743, 0.1559722351841215, 0.14072762915541592, 0.1470982662861805, 0.12637886310030955, 0.13839320566375224, 0.15366716623714505, 0.12519964753915735, 0.1315342956690132, 0.1317205173616547, 0.12688634424567302, 0.13225899700358024, 0.13746743298807795, 0.8826060117624744, 0.907939158154434, 0.9148037023576421, 0.8732872046423799, 0.8546261240013157, 0.8628498201345264, 0.8938650045845977, 0.9006507273814869, 0.8785382776167476, 0.331301103785676, 0.30632059548267343, 0.33070004727514535, 0.3237905126236388, 0.31281358698470063, 0.28445914189205, 0.2923989027384115, 0.28434457901561494, 0.3210477875299729, 0.4931475081689185, 0.5945876488695492, 0.5252091993729208, 0.6898936363395467, 0.6898065099625267, 0.583299159279225, 0.5450513202035077, 0.6301257708828922, 0.6671521466951692, 0.18022434929818176, 0.16666083768657414, 0.18592979311276392, 0.19714698384541895, 0.2221839975893315, 0.19039567965349735, 0.17724475623317026, 0.21068578269968752, 0.16218293924211868, 0.170222110967849, 0.1602269369207706, 0.17025335321714086, 0.13569644715274576, 0.14519050522812937, 0.19192683565456914, 0.16605454301640676, 0.1408529045913749, 0.1510347705221613, 0.04322394801703944, 0.04108966703318728, 0.07255264253642746, 0.07396981362141852, 0.08052250220212465, 0.040277862992959323, 0.09421400338573638, 0.043636846713185684, 0.05198404348855856, 0.18845389190139694, 0.16093151552305374, 0.21451666192274277, 0.1782861921597667, 0.10210404833667364, 0.1730372780972519, 0.19396007781379243, 0.20643964327163955, 0.19030905135256004, 0.011630714825098254, 0.0021319412826210637, 0.0377973904194947, 0.015595349724024876, 0.011678718993058279, 0.04720882827906314, 0.0327186101865542, 0.019732645029986617, 0.053492848585460884, 0.13834442350810128, 0.15211650926133147, 0.1613278615359055, 0.15508037248316664, 0.15919647896422706, 0.153908083508428, 0.1285690644343236, 0.1323806291532439, 0.14254087248471892, 0.5050922284326534, 0.4961044662556018, 0.5028969244193031, 0.49827436411505766, 0.4854321843053435, 0.5089142613471843, 0.4923995188377729, 0.49518829405409737, 0.49929549706179177, 0.11623895174677856, 0.11540736336989521, 0.10267546654427184, 0.11479626629315243, 0.12922563326896908, 0.11930139854889787, 0.13401237876585514, 0.11571881462024536, 0.12009672979330666, 0.16855897737827075, 0.1752489703996606, 0.25430850809904837, 0.17825971597432477, 0.1789129294165448, 0.19528454923738825, 0.19438944986045936, 0.19988134847277317, 0.18705053925436776, 0.34394537779308576, 0.32070200413958183, 0.337109916444852, 0.34829124768538133, 0.3421804648258713, 0.3207101808361823, 0.35466466748158043, 0.37990594903400965, 0.34037368126256684, 0.2252394011892468, 0.2679998602041789, 0.24414134474292282, 0.24116471052290422, 0.22770782275618418, 0.2558549629617227, 0.264370230162543, 0.24051999194031182, 0.2503704053917045, 0.21725024737543286, 0.21156398467562576, 0.1939600933772465, 0.21586286116411324, 0.19623991582008415, 0.20536001922676328, 0.2348135698092768, 0.1943538774591531, 0.2182637180872341, 0.23290605217582216, 0.20814002082480487, 0.249052207399184, 0.2052537844961373, 0.21668428869941758, 0.22779324575714532, 0.22043040566555505, 0.22362321626531134, 0.2387360720991254, 0.1794244388807188, 0.38403454188794617, 0.21984024045522377, 0.5815651118767551, 0.47287415913991915, 0.1945433920845574, 0.3459831509609247, 0.3359941965365142, 0.3354615105363494, 0.2842201350871215, 0.5512679040101252, 0.19939879557420193, 0.19989378159553783, 0.4874991382666388, 0.18601713570434586, 0.3066927629993639, 0.2020529226161304, 0.5176702707057117, 0.17685498075055128, 0.19181603369335676, 0.1737386107380131, 0.20021129072663268, 0.19330736304618645, 0.17998019106638696, 0.1838303255132876, 0.18425713061658677, 0.18376892130772682, 0.07938030265574292, 0.08244703683513455, 0.08917077406997864, 0.08366528153722697, 0.08727171899686803, 0.08078056558271962, 0.08395263916062345, 0.07373624659119016, 0.07855721103451274]}, "mutation_prompt": null}
{"id": "f9751a55-be67-4b25-8b5f-06fc60acd390", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.initial_CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        self.F = self.adaptive_alpha * (1.0 - np.random.rand() / 2)\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant, evals):\n        adaptive_CR = self.initial_CR * (1.0 - evals / self.budget)\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                self.F = self.adaptive_alpha * (1.0 - evals / self.budget)\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant, evals)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n            best_index = np.argmin(fitness)\n            if evals < self.budget:\n                elitist = population[best_index]  # Elitist retention\n                population[np.random.randint(0, self.population_size)] = elitist  \n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduce adaptive crossover rate and elitist selection to improve convergence and solution diversity.", "configspace": "", "generation": 74, "fitness": 0.31127384694061455, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.22.", "error": "", "parent_id": "c77bb9e7-6928-44a5-b72c-70bd7cd4a569", "metadata": {"aucs": [0.7603271692657303, 0.7639850487553432, 0.7537276676508807, 0.7729947689703996, 0.7531032898146273, 0.7735366522443714, 0.7653083852495847, 0.7601721738477063, 0.7570250515196268, 0.5470417318518757, 0.5674485018330562, 0.5585036711983303, 0.5764775232650559, 0.5814190527758567, 0.5827517620024902, 0.5689007458479293, 0.5162423763825551, 0.5617747802972997, 0.30633449761623566, 0.32129686566407945, 0.29116001987993334, 0.3387035535507361, 0.259355428156945, 0.29891567837830124, 0.3204552759938052, 0.31253242408232296, 0.3586145387077616, 0.23127829115350151, 0.15216454814680513, 0.22318466888735378, 0.1522714860125174, 0.26318393844609156, 0.14709257990012048, 0.22211154774544872, 0.2851693276971794, 0.30047904633989597, 0.9033982155901888, 0.8938312450432302, 0.9543198999729039, 0.895379983807638, 0.8751271218282097, 0.8903368426779553, 0.896393911079005, 0.9640012033249866, 0.9138144331079265, 0.330601370501994, 0.3326281682953277, 0.3419056989477458, 0.39002228999789945, 0.3195050345668018, 0.31143226118035316, 0.34197613567914364, 0.2856113345084983, 0.3683753772560636, 0.6395275531414306, 0.6106768335587465, 0.4802848083223469, 0.25812095492978904, 0.44111419749973824, 0.33045926207745424, 0.31803105953853683, 0.6383221943838686, 0.5427918764095717, 0.19402606400472788, 0.20285963485847425, 0.21677907580802636, 0.1908260975430296, 0.18041103399644876, 0.25925703679506584, 0.24945352595935255, 0.16583625537312052, 0.2567475859213221, 0.14377864860959622, 0.16654071681715032, 0.18546289980656383, 0.16411232264926512, 0.17473340684732752, 0.21946217566931436, 0.1672151546232994, 0.1669430372983004, 0.23315673041767226, 0.06762463569860189, 0.059957823844280944, 0.05459154589448412, 0.06196358771195576, 0.10811108021748073, 0.03192832118530409, 0.0857042452211132, 0.07514532477302693, 0.017956382477346433, 0.14633209517839818, 0.17122818854872623, 0.1545563435247741, 0.084730291554036, 0.16968898978299307, 0.18820949673679077, 0.18056988805240637, 0.17652104700599125, 0.2201329140566698, 0.02167259115722353, 0.0611691864836712, 0.0652885055600223, 0.038255155616623404, 0.0424361786515185, 0.09323121681428614, 0.011585173169020302, 0.03107683568733466, 0.047527484703544176, 0.13300407377407186, 0.1522658098269407, 0.14338633707579151, 0.16120025009245287, 0.15047823017257778, 0.1537941031440021, 0.13795102276772941, 0.1527863777657389, 0.14326382242304303, 0.5088768371653766, 0.4931435503951529, 0.5259084345897507, 0.5109835813415543, 0.5014094489597382, 0.5091287220349343, 0.49988441944621886, 0.47975961676956647, 0.5028170052859527, 0.14271695980452948, 0.11044622460348019, 0.1387441898401205, 0.13000574241202634, 0.12742634069615577, 0.13663161280302616, 0.129389031555449, 0.12479816850119785, 0.13335048390663273, 0.22631879318212034, 0.2128944464378757, 0.18625478023466002, 0.20061768646223832, 0.192226575079532, 0.220181529241275, 0.19250907396766404, 0.27434114188201286, 0.20811683860564834, 0.3803797640573201, 0.2866908556932095, 0.3347237412887266, 0.32786329121851, 0.3360340165165414, 0.3299195082094366, 0.3667642562709279, 0.3610393025100215, 0.35388530128645856, 0.211629566324522, 0.27873244644898876, 0.2971571696991807, 0.2517971940247852, 0.2652198458188444, 0.25934224524235183, 0.2532561511369049, 0.2832319152905255, 0.23751923536416408, 0.22426322294324885, 0.20418882014493844, 0.22166591580642503, 0.22688571828590054, 0.20927461019532811, 0.20266420158961596, 0.20910966013086896, 0.21520327078926416, 0.21525007101552873, 0.3120450486334996, 0.30841596066291177, 0.3536937958204037, 0.3514904788269717, 0.39853353396316216, 0.32721591710106734, 0.2997927998710105, 0.32307332668017963, 0.36909332280685214, 0.24021109940080365, 0.7684160478109989, 0.18584584459155318, 0.5116390393906265, 0.3605829252664531, 0.661353720082979, 0.7002609243957351, 0.16525625280462286, 0.23032579601787562, 0.6408460402139977, 0.5830958963813648, 0.202132577473064, 0.3498501319908365, 0.20270597558341596, 0.5413923048873328, 0.18723316821135094, 0.3504671920205642, 0.20793301114710683, 0.19634137797804396, 0.19259481827526725, 0.20422293394999447, 0.20243805105274537, 0.20182703032801919, 0.19633734563218985, 0.18780978166566675, 0.20831107754574885, 0.21045645269933844, 0.10156419200948952, 0.09270187936869367, 0.08282301989767527, 0.08696972482480703, 0.1070324130448782, 0.08866838666604382, 0.08551985205136625, 0.0818806314036794, 0.10621801052878599]}, "mutation_prompt": null}
{"id": "868624c3-366c-4e1e-b645-10cba3f70783", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5  # New adaptive learning rate\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        self.F = self.adaptive_alpha * (1.0 - np.random.rand() / 2)  # Self-adaptive mutation\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                # Adjust F dynamically based on budget usage\n                self.F = self.adaptive_alpha * (1.0 - evals / self.budget)\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "Integrate a self-adaptive mutation strategy with hybrid differential evolution to enhance convergence speed and accuracy.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c77bb9e7-6928-44a5-b72c-70bd7cd4a569", "metadata": {"aucs": [0.7612133547626164, 0.7635974135918435, 0.7752878518207924, 0.7744891485125145, 0.7590266227141119, 0.765587013101981, 0.7623863846616221, 0.7708785550831908, 0.7556583284882229, 0.5516486341526301, 0.5731050850960036, 0.554864346304295, 0.5520674801575232, 0.5554410226692565, 0.5520266004358985, 0.5733179390909917, 0.5761366394863301, 0.5622457240215442, 0.131982600206634, 0.12915625458784674, 0.14383674304306315, 0.1338704409097463, 0.16154127440768518, 0.14322627575824953, 0.12363742621879115, 0.14506029149421973, 0.12784478342452732, 0.1196730559607504, 0.1094351055782703, 0.11686657251810662, 0.11613887553412128, 0.10515886888394821, 0.12617941931389398, 0.13227034434241836, 0.12496419636417433, 0.11704885698844414, 0.9307894154904343, 0.8779419650175174, 0.8492317114705105, 0.8967478489291592, 0.8844277776719465, 0.8384345033818077, 0.8686050382190194, 0.9637171134794177, 0.8862853965963882, 0.3752185515626154, 0.3615062602778808, 0.3915368370179376, 0.3530206579866112, 0.3458488811273339, 0.3289595836612633, 0.40017768415747523, 0.3486172987200348, 0.3695876032646632, 0.7039373306397954, 0.6745818425018811, 0.6923577316103662, 0.6828176113769283, 0.7118898391770248, 0.7110946795801579, 0.6702243315467178, 0.6993007089991511, 0.7332937561281794, 0.292307125009745, 0.19482608114683153, 0.2110641015662491, 0.17132981672490755, 0.15282956836629313, 0.22156283575110458, 0.17474271301211686, 0.1801169781087807, 0.2632574709449803, 0.1522750233191288, 0.1546217557733076, 0.27918226678415115, 0.17605864750728328, 0.20458264529164716, 0.24356065346793332, 0.18415509924700613, 0.18654016887535552, 0.17761447647866446, 0.20498826475822207, 0.1965450369790377, 0.2741291640484672, 0.22120134394487279, 0.24337747783720198, 0.21519640039819343, 0.23017529575789053, 0.2593010197665784, 0.24581757752947253, 0.34651807461528117, 0.36326595410228535, 0.3490898128523129, 0.3517188836346363, 0.335412606937182, 0.25904237953094744, 0.39148075402422267, 0.4257512562398018, 0.3032495934658621, 0.15917896970816692, 0.0844888656729087, 0.09547072483373176, 0.11351521934790088, 0.08161504373974893, 0.13108295199320041, 0.0749484423244905, 0.09812205265389007, 0.10596183941294435, 0.1992035028913237, 0.2332339828190989, 0.21882281661931335, 0.24179433180059595, 0.24709753740947316, 0.25593443679161254, 0.25238305775811376, 0.21459292618186776, 0.21053595536415537, 0.6278013485156035, 0.6180073476499195, 0.6350056156318289, 0.5808019853543325, 0.5949342521092276, 0.6293991123842815, 0.6388372142719174, 0.5881284309345677, 0.6246454091841627, 0.12130407531500864, 0.11528096244977515, 0.1149247274073385, 0.11491727616848735, 0.1128360742742861, 0.13232335542400653, 0.10676173018641744, 0.12449673485265378, 0.1286318868687606, 0.20599692288977378, 0.16812019616172347, 0.17553272870984804, 0.17958757976441286, 0.1616736806204484, 0.1664904330928193, 0.16888219485881395, 0.18365030097905277, 0.1783060831907396, 0.39061235436132113, 0.35185474644864, 0.3789196894124792, 0.3408393739835268, 0.3710663501850471, 0.33813373325719975, 0.388047322068548, 0.42223019968695075, 0.38162707434060705, 0.275796371328908, 0.3158537510454337, 0.2692635564641016, 0.3129351804094942, 0.2960868634000229, 0.2970844998614165, 0.2948334622908376, 0.2847763399174581, 0.2824922857440786, 0.20429662289329287, 0.22674174205701214, 0.2198412057146617, 0.2327645837110891, 0.19495616315404674, 0.20627633369578646, 0.19094814479977285, 0.21399320028801871, 0.19860748446532794, 0.19303241727571452, 0.2359463239392373, 0.212268510578828, 0.23807825541125527, 0.23613302747663378, 0.257656565538399, 0.20133480741106058, 0.19211873038970817, 0.20552555973047903, 0.5272605682420436, 0.18585211525015133, 0.6494803128618508, 0.47085216185846146, 0.7505794032227436, 0.5566847808247446, 0.602027689498045, 0.170682663312268, 0.6272166775319116, 0.3790953833019882, 0.681313707358442, 0.20230767502941127, 0.2025086598973358, 0.5690565496406128, 0.24129526554410752, 0.19840143416061873, 0.20432878888251427, 0.5367424243896946, 0.18737994247854983, 0.1947061126880285, 0.1914849448154483, 0.1863607724844072, 0.18898707215101618, 0.19499773413061317, 0.184280504036488, 0.19424548602585823, 0.19005294629459746, 0.09455499535230505, 0.0946368663092153, 0.09802169414539474, 0.08895328236027977, 0.08948855193254401, 0.08461738726790513, 0.08657557234219526, 0.08448907428396502, 0.08629934449377052]}, "mutation_prompt": null}
{"id": "2c4b0d6c-d40c-4b06-80b3-8f21578fc3a6", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5  # New adaptive learning rate\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        self.F = self.adaptive_alpha * (1.0 - np.random.rand() / 2)  # Self-adaptive mutation\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                # Adjust F dynamically based on budget usage\n                self.F = self.adaptive_alpha * (1.0 - evals / self.budget)\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "Integrate a self-adaptive mutation strategy with hybrid differential evolution to enhance convergence speed and accuracy.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c77bb9e7-6928-44a5-b72c-70bd7cd4a569", "metadata": {"aucs": [0.7612133547626164, 0.7635974135918435, 0.7752878518207924, 0.7744891485125145, 0.7590266227141119, 0.765587013101981, 0.7623863846616221, 0.7708785550831908, 0.7556583284882229, 0.5516486341526301, 0.5731050850960036, 0.554864346304295, 0.5520674801575232, 0.5554410226692565, 0.5520266004358985, 0.5733179390909917, 0.5761366394863301, 0.5622457240215442, 0.131982600206634, 0.12915625458784674, 0.14383674304306315, 0.1338704409097463, 0.16154127440768518, 0.14322627575824953, 0.12363742621879115, 0.14506029149421973, 0.12784478342452732, 0.1196730559607504, 0.1094351055782703, 0.11686657251810662, 0.11613887553412128, 0.10515886888394821, 0.12617941931389398, 0.13227034434241836, 0.12496419636417433, 0.11704885698844414, 0.9307894154904343, 0.8779419650175174, 0.8492317114705105, 0.8967478489291592, 0.8844277776719465, 0.8384345033818077, 0.8686050382190194, 0.9637171134794177, 0.8862853965963882, 0.3752185515626154, 0.3615062602778808, 0.3915368370179376, 0.3530206579866112, 0.3458488811273339, 0.3289595836612633, 0.40017768415747523, 0.3486172987200348, 0.3695876032646632, 0.7039373306397954, 0.6745818425018811, 0.6923577316103662, 0.6828176113769283, 0.7118898391770248, 0.7110946795801579, 0.6702243315467178, 0.6993007089991511, 0.7332937561281794, 0.292307125009745, 0.19482608114683153, 0.2110641015662491, 0.17132981672490755, 0.15282956836629313, 0.22156283575110458, 0.17474271301211686, 0.1801169781087807, 0.2632574709449803, 0.1522750233191288, 0.1546217557733076, 0.27918226678415115, 0.17605864750728328, 0.20458264529164716, 0.24356065346793332, 0.18415509924700613, 0.18654016887535552, 0.17761447647866446, 0.20498826475822207, 0.1965450369790377, 0.2741291640484672, 0.22120134394487279, 0.24337747783720198, 0.21519640039819343, 0.23017529575789053, 0.2593010197665784, 0.24581757752947253, 0.34651807461528117, 0.36326595410228535, 0.3490898128523129, 0.3517188836346363, 0.335412606937182, 0.25904237953094744, 0.39148075402422267, 0.4257512562398018, 0.3032495934658621, 0.15917896970816692, 0.0844888656729087, 0.09547072483373176, 0.11351521934790088, 0.08161504373974893, 0.13108295199320041, 0.0749484423244905, 0.09812205265389007, 0.10596183941294435, 0.1992035028913237, 0.2332339828190989, 0.21882281661931335, 0.24179433180059595, 0.24709753740947316, 0.25593443679161254, 0.25238305775811376, 0.21459292618186776, 0.21053595536415537, 0.6278013485156035, 0.6180073476499195, 0.6350056156318289, 0.5808019853543325, 0.5949342521092276, 0.6293991123842815, 0.6388372142719174, 0.5881284309345677, 0.6246454091841627, 0.12130407531500864, 0.11528096244977515, 0.1149247274073385, 0.11491727616848735, 0.1128360742742861, 0.13232335542400653, 0.10676173018641744, 0.12449673485265378, 0.1286318868687606, 0.20599692288977378, 0.16812019616172347, 0.17553272870984804, 0.17958757976441286, 0.1616736806204484, 0.1664904330928193, 0.16888219485881395, 0.18365030097905277, 0.1783060831907396, 0.39061235436132113, 0.35185474644864, 0.3789196894124792, 0.3408393739835268, 0.3710663501850471, 0.33813373325719975, 0.388047322068548, 0.42223019968695075, 0.38162707434060705, 0.275796371328908, 0.3158537510454337, 0.2692635564641016, 0.3129351804094942, 0.2960868634000229, 0.2970844998614165, 0.2948334622908376, 0.2847763399174581, 0.2824922857440786, 0.20429662289329287, 0.22674174205701214, 0.2198412057146617, 0.2327645837110891, 0.19495616315404674, 0.20627633369578646, 0.19094814479977285, 0.21399320028801871, 0.19860748446532794, 0.19303241727571452, 0.2359463239392373, 0.212268510578828, 0.23807825541125527, 0.23613302747663378, 0.257656565538399, 0.20133480741106058, 0.19211873038970817, 0.20552555973047903, 0.5272605682420436, 0.18585211525015133, 0.6494803128618508, 0.47085216185846146, 0.7505794032227436, 0.5566847808247446, 0.602027689498045, 0.170682663312268, 0.6272166775319116, 0.3790953833019882, 0.681313707358442, 0.20230767502941127, 0.2025086598973358, 0.5690565496406128, 0.24129526554410752, 0.19840143416061873, 0.20432878888251427, 0.5367424243896946, 0.18737994247854983, 0.1947061126880285, 0.1914849448154483, 0.1863607724844072, 0.18898707215101618, 0.19499773413061317, 0.184280504036488, 0.19424548602585823, 0.19005294629459746, 0.09455499535230505, 0.0946368663092153, 0.09802169414539474, 0.08895328236027977, 0.08948855193254401, 0.08461738726790513, 0.08657557234219526, 0.08448907428396502, 0.08629934449377052]}, "mutation_prompt": null}
{"id": "2ec2f67a-9ebf-432b-88f7-34613a2b0ca2", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5\n        self.performance_threshold = 0.1  # New: Performance metric threshold\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        self.F = self.adaptive_alpha * (1.0 - np.random.rand() / 2)  \n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        # New: Adaptive crossover strategy\n        self.CR = 0.9 if np.std(target) > self.performance_threshold else 0.6 \n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        new_individual = np.clip(individual + step_size * direction, self.lower_bound, self.upper_bound)\n        return new_individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                self.F = self.adaptive_alpha * (1.0 - evals / self.budget)\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    local_candidate = self._local_search(population[i], scale=scale_factor)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n            # New: Dynamic population resizing\n            if evals < self.budget / 2:\n                self.population_size = max(4, int(self.population_size * 0.95))\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhance hybrid differential evolution by integrating a dynamic population resizing strategy and adaptive crossover rate based on performance metrics.", "configspace": "", "generation": 77, "fitness": 0.25271319890939115, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.20.", "error": "", "parent_id": "c77bb9e7-6928-44a5-b72c-70bd7cd4a569", "metadata": {"aucs": [0.5315568089646207, 0.5440404069934662, 0.5506753504016435, 0.5470610452311155, 0.5355092455316688, 0.5750075101736682, 0.5504929358731889, 0.5701832193129638, 0.5670867147075325, 0.17713393679356926, 0.19376721415865883, 0.20449791443416698, 0.0008190701860716354, 0.049850118396586374, 0.18326451594819915, 0.0653512973401823, 0.14527778070462993, 0.07952561648198131, 0.17479702591528035, 0.1346115847561281, 0.13974872149420203, 0.13766373586743397, 0.1356940105889597, 0.12570450193210325, 0.12166548328586102, 0.14633827923814047, 0.15307432408870103, 0.14089804040487908, 0.1231265186969498, 0.09276266580048487, 0.13081404712216005, 0.10629798742270902, 0.11087586135700511, 0.09097220578546972, 0.101913164345655, 0.09341221129519017, 0.8783341338064045, 0.8909855625048099, 0.8645483465504102, 0.8907381782565568, 0.9024915657537734, 0.8846675489330557, 0.900146013432472, 0.8975386882591476, 0.8766256187490564, 0.362521690235466, 0.35757016005267206, 0.3666736986663599, 0.38150784473820165, 0.3760261025013113, 0.3806233435878803, 0.3576669959652792, 0.37186861752597455, 0.3661511339107869, 0.2338731641850854, 0.20825023600372783, 0.2226277250920593, 0.9000719343321015, 0.3579177674617039, 0.36912578681253183, 0.2285795026988835, 0.34587511959218564, 0.385078939392951, 0.21520094172348714, 0.12648815364829347, 0.16915558780475826, 0.2064195008955395, 0.1375996816480738, 0.15045438206917094, 0.12413749967587706, 0.15650618834201158, 0.1939968539100272, 0.2043071216424247, 0.14890445105323802, 0.2982363787698421, 0.1635917785775537, 0.15605314742376197, 0.20530020718369346, 0.15953781702029357, 0.14891274665313248, 0.1962627706383291, 0.15050901549000661, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0034285369365115725, 0.14127275959971297, 0.18644222737314176, 0.03545282712731823, 0.053513663121126376, 0.22432546028234923, 0.1121727353577362, 0.21500585693743168, 0.17795649750957143, 0.1265786630354785, 0.16157326910226277, 0.2105302946247859, 0.1524159122735257, 0.13357472133122084, 0.012804083140393385, 0.05755905805235928, 0.027524016516758065, 0.06245922226355505, 0.038103410704305674, 0.05717425112322949, 0.02139897653995393, 0.0829374662867689, 0.03078472158618173, 0.16718178450651744, 0.14850720552125896, 0.17064997809006055, 0.19231335781996461, 0.13674546700531576, 0.16548391938472906, 0.17795776826547793, 0.13336325868982968, 0.16236404643446856, 0.5043238006456895, 0.4481290388990715, 0.4690543084780504, 0.48402602400320016, 0.5192689097503019, 0.4702402249641312, 0.45443702688998455, 0.46014944618286424, 0.4632888369738061, 0.10305499650336336, 0.10582462109549251, 0.13724047739445344, 0.13492471912027426, 0.13551486201586593, 0.09351915022405988, 0.09927351219285296, 0.1275095732208561, 0.10390693371188608, 0.19259796299708942, 0.1890044597954348, 0.17005633929524377, 0.26260481068988695, 0.31701841032579325, 0.15897589164004788, 0.17103268477769618, 0.26594512021911565, 0.17338345545072242, 0.3284778591119355, 0.34936698813465783, 0.3399127021002344, 0.3338839528343567, 0.3258442973613743, 0.34983376995952253, 0.3031049714174836, 0.3972889963838616, 0.3389965468012456, 0.23138161820747793, 0.2611653990395615, 0.2404016156394334, 0.28090717874377413, 0.26548070946847757, 0.17394561020485977, 0.21754877422864194, 0.2646479011288946, 0.26269629138488804, 0.22323800473675504, 0.2318794108954818, 0.2250083058891854, 0.23820042260349816, 0.22631563925800025, 0.2031009163093489, 0.23690983786570086, 0.24091086188317712, 0.19560599916289434, 0.19642169463161296, 0.19166984960469347, 0.19210297993388126, 0.19560839025458698, 0.20062285782722755, 0.19524753084419522, 0.1710549195372172, 0.2037768699810537, 0.1924786495491435, 0.16866675194891234, 0.18543176562761765, 0.1834179481881002, 0.7625170633167359, 0.19451245501265368, 0.13176161258860142, 0.7265130766442529, 0.4714739501774152, 0.8073277896526905, 0.20572012830942754, 0.20695541751859314, 0.4598150049260711, 0.28595544752240054, 0.2066840686958734, 0.1637175006441528, 0.20227445584544912, 0.1548139291488243, 0.20672457752330498, 0.19694584851042152, 0.20097157385509168, 0.19162332052087927, 0.18962303771457956, 0.20834811054940006, 0.18925782202760077, 0.20073847045393567, 0.19006022442151016, 0.20415486414690853, 0.09354223098946446, 0.08729605223984271, 0.11339080548665681, 0.08669090549489522, 0.09648051063854202, 0.09932847321422233, 0.10745413486150368, 0.09533421940605058, 0.09019736548544732]}, "mutation_prompt": null}
{"id": "245fc659-27c7-469e-a613-4d1b3e974732", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        self.F = self.adaptive_alpha * (1.0 - np.random.rand() / 2)  # Self-adaptive mutation\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant, rank):\n        # Rank-based adaptive crossover rate\n        self.CR = 0.5 + 0.5 * (rank / self.population_size)\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0, momentum=np.zeros((1,))):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        momentum = 0.9 * momentum + step_size * direction  # Add momentum\n        new_individual = np.clip(individual + momentum, self.lower_bound, self.upper_bound)\n        return new_individual, momentum\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n        momentum = np.zeros((self.population_size, self.dim))\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                self.F = self.adaptive_alpha * (1.0 - evals / self.budget)\n                rank = np.argsort(fitness).tolist().index(i)  # Get rank of the individual\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant, rank)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    local_candidate, momentum[i] = self._local_search(population[i], scale=scale_factor, momentum=momentum[i])\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduce a rank-based adaptive crossover rate and integrate a momentum term in local search to balance exploration and exploitation.", "configspace": "", "generation": 78, "fitness": 0.3352234633988513, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.24.", "error": "", "parent_id": "c77bb9e7-6928-44a5-b72c-70bd7cd4a569", "metadata": {"aucs": [0.7988641456491021, 0.768826774166891, 0.7750591751506644, 0.8011769247685507, 0.7636580189576789, 0.7827925986289906, 0.7969202888782461, 0.7696800506496033, 0.7739482840552282, 0.5989960556034106, 0.5911549253973829, 0.5891773706934186, 0.5966357733403727, 0.5911443449237024, 0.6057342379177786, 0.6043437635634787, 0.5792564936943903, 0.6229844363079973, 0.15021037491296596, 0.1478851228786623, 0.14800186506784307, 0.1407341926059522, 0.13155882351680992, 0.13460031405500572, 0.14395282990945835, 0.14627775766185425, 0.13206171492756347, 0.12759206227184916, 0.13139028246917328, 0.12541461477008053, 0.1298006275601461, 0.1092645490813946, 0.11965718516787693, 0.13420626242411782, 0.11753363156532037, 0.11162968502871662, 0.8748560522095489, 0.9232285986156205, 0.8803136892847, 0.8813189752197219, 0.9101278741203359, 0.9153891834094732, 0.9010724084866754, 0.908340880528805, 0.8754099912455098, 0.39278156038056855, 0.39110132020981436, 0.3917381909116251, 0.3387333890249272, 0.32779240613867056, 0.29997577841283796, 0.36451951813843997, 0.27276984304839846, 0.3117689112290385, 0.697347005571374, 0.6869696584211988, 0.6785613489568372, 0.7591335253179715, 0.6945131264488063, 0.6898470975851174, 0.7424186223713711, 0.6898549264301335, 0.762667669691355, 0.20250176208256976, 0.16345458660583612, 0.17244281207791368, 0.1599127238159992, 0.1682171363256122, 0.1815000020034251, 0.1502331673067996, 0.16044077912773158, 0.19691553726222355, 0.1757854764022332, 0.16615224825383157, 0.24689783519521025, 0.15785953827148114, 0.1440767752232296, 0.18713917427766458, 0.1720553918832749, 0.2062245552751324, 0.16903438185508657, 0.30512722488787114, 0.19460241607982187, 0.13241403655008632, 0.19889107359886138, 0.0921236796732039, 0.1584098409169672, 0.17478867835372836, 0.25890297157502307, 0.16998473798348657, 0.38613251169867546, 0.38609984439365774, 0.34265880724109277, 0.2891789691693323, 0.3377594168399364, 0.13032968759341057, 0.19685446527715944, 0.3762417934276675, 0.44799359141725303, 0.1091983676040903, 0.08316488308221048, 0.09882909826952513, 0.08797596474879321, 0.14369681928564093, 0.11722642337972289, 0.16738548331939895, 0.12965978713690474, 0.10339817098991111, 0.2282413397539632, 0.22573418331683992, 0.21781620939439927, 0.24621107106344453, 0.2276995732441084, 0.2446579855115235, 0.21223096841918287, 0.2388240940847508, 0.21954296470751822, 0.6135268934882263, 0.628072401890408, 0.6018532668865421, 0.6141706161805075, 0.63070508846396, 0.5953928817782066, 0.6026591126432125, 0.6302159810174917, 0.5314542417786308, 0.10813683058275458, 0.10330958014192437, 0.10569479464548281, 0.11118852054438289, 0.09534808706147746, 0.1089804348001997, 0.09051866150343957, 0.10055882294597873, 0.11105046619492953, 0.14171177212784491, 0.14561937208389497, 0.162184268836577, 0.18606415258741493, 0.15748037161092254, 0.19348373810420272, 0.14724845174307044, 0.16053154972867545, 0.19070464936700648, 0.3993884173522393, 0.40516660956786965, 0.3527980091289109, 0.40817656898113297, 0.3993663475378154, 0.3579441520709685, 0.4296578235031031, 0.4328923616476309, 0.4010150543069877, 0.29513354015327353, 0.27594214726509847, 0.27630037391201145, 0.3036364785288276, 0.29588134193465143, 0.266079450187086, 0.3433976419196165, 0.3467678527553322, 0.3035636871679067, 0.19307987799179305, 0.19664288953761966, 0.2065131627518807, 0.20812728188249208, 0.2148551330006212, 0.2030063794007395, 0.21000187036164486, 0.21263236693986487, 0.22411327084993604, 0.21031650607218533, 0.20085396902647146, 0.19721683376022647, 0.24404772569810562, 0.23365975922293625, 0.21611830610654048, 0.20947354533213836, 0.26863621491131784, 0.21740724022954028, 0.6560312491429774, 0.7313573849035863, 0.45995021421180227, 0.625546604671299, 0.7409390690974116, 0.7335834339787368, 0.5526111799745129, 0.413977190798697, 0.18442879874252582, 0.6737088019345865, 0.4771023852085652, 0.7047442448480457, 0.19783588177999567, 0.19683044595249088, 0.21837928288127728, 0.19938669155852762, 0.3143170690586896, 0.6711563859484153, 0.1793476391741644, 0.18306114817869845, 0.18813085280450448, 0.18526502137928713, 0.1731900530250714, 0.19423201063523732, 0.20256794277403345, 0.19118279347226264, 0.18471057247304634, 0.09013794072100167, 0.08856000865124802, 0.08448110720910595, 0.08206875083461418, 0.08118616491463004, 0.07189256377398012, 0.07754907927895038, 0.0769913360640272, 0.07864346749701889]}, "mutation_prompt": null}
{"id": "83410bc6-a534-470c-b14e-e6dd83f0107d", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        # Self-adaptive mutation factor\n        self.F = 0.1 + 0.9 * np.random.rand()\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant, rank):\n        # Rank-based adaptive crossover rate\n        self.CR = 0.5 + 0.5 * (rank / self.population_size)\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0, momentum=np.zeros((1,))):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        momentum = 0.7 * momentum + step_size * direction  # Adjusted momentum\n        new_individual = np.clip(individual + momentum, self.lower_bound, self.upper_bound)\n        return new_individual, momentum\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n        momentum = np.zeros((self.population_size, self.dim))\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                rank = np.argsort(fitness).tolist().index(i)  # Get rank of the individual\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant, rank)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    # Introduce neighborhood-aware local search\n                    neighbors = np.random.choice(self.population_size, 5, replace=False)\n                    best_neighbor = min(neighbors, key=lambda idx: fitness[idx])\n                    direction = population[best_neighbor] - population[i]\n                    local_candidate = np.clip(population[i] + 0.1 * direction, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduce a self-adaptive strategy for mutation factor F and integrate a neighborhood-aware local search to enhance convergence.", "configspace": "", "generation": 79, "fitness": 0.348383129168905, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.24.", "error": "", "parent_id": "245fc659-27c7-469e-a613-4d1b3e974732", "metadata": {"aucs": [0.7872662782232155, 0.7614452136338328, 0.7805064778725795, 0.777033032966406, 0.7942952704767343, 0.7865536967590909, 0.8098531367378005, 0.7856280244862203, 0.7746465622920444, 0.6173062827372708, 0.6159208546969014, 0.6118065550376617, 0.610497869807928, 0.6069507224223654, 0.6034317931000741, 0.6241996506983545, 0.6170956151703697, 0.6174962310319495, 0.16875690858881387, 0.16978754038424881, 0.1442986428188553, 0.1956904658831139, 0.23934467282060357, 0.14588586324563801, 0.14950077905265224, 0.33743626613019495, 0.20866212052994104, 0.1205345146103225, 0.13926576880289632, 0.13822167064067303, 0.12942694041542158, 0.1281983309324407, 0.14186107340297216, 0.12073543636727302, 0.14097352769367666, 0.1554506259033167, 0.8885709347273463, 0.8557578777417613, 0.9009513152894469, 0.9239845432386716, 0.895995087726823, 0.8634551789802956, 0.8625595759926562, 0.8594465255658232, 0.8620186052938734, 0.38589748153512726, 0.3873452064021907, 0.3563102830622802, 0.35491754368707584, 0.39219265884828114, 0.3637561149951083, 0.38100935279155457, 0.38921214406864924, 0.4029378062653397, 0.7305625534696606, 0.715620622963973, 0.7121897951309525, 0.708937962576391, 0.706590932208257, 0.6833759278034606, 0.6821359026364014, 0.7526333491896928, 0.709335533790602, 0.15333130488525437, 0.19821390933768512, 0.2050821843868884, 0.178335706145052, 0.17425783224728764, 0.22810148600640023, 0.25213456430302517, 0.1703460256871676, 0.21603779778543863, 0.17957295970712361, 0.2005863393737526, 0.2039759327499383, 0.13779337617090937, 0.20957779579711844, 0.24460308218446003, 0.17442114274148257, 0.15058318170012863, 0.16779673728798827, 0.19753565320136302, 0.21278533973706626, 0.25632945816341113, 0.31029821513792855, 0.13126327270759752, 0.13127073117409216, 0.2741835540001334, 0.34491092014935554, 0.16756508718766105, 0.4131768851962542, 0.4529658992378788, 0.4682477710614157, 0.36897785454709897, 0.39177971739930306, 0.3228091757761715, 0.540555556317911, 0.4798360018515757, 0.5132692806622567, 0.21349717654360545, 0.18627544276040053, 0.10537804847317944, 0.10248107734226519, 0.08382704655689344, 0.16673730970541, 0.17088987205881734, 0.10503827924756515, 0.13025257498049736, 0.2802295989555189, 0.2502820025029229, 0.2952413968755899, 0.2843705315813757, 0.25826269247562395, 0.2953775739742128, 0.2068419131747965, 0.24364418189670078, 0.15364961010201172, 0.6234457881631293, 0.6757471858704971, 0.6697391248468605, 0.5598079929206922, 0.6468507529878808, 0.6210684912371793, 0.6541046172748212, 0.6574734058073645, 0.6544831731966804, 0.11214768830756472, 0.123770535107383, 0.10990337876385414, 0.13739989145727882, 0.10272696810840476, 0.11896651905999045, 0.1100777997466863, 0.11136484729193419, 0.11720455865846491, 0.14443669858596553, 0.13297059698897318, 0.15329234741332642, 0.1810857227812891, 0.15584535659462473, 0.16806858876923347, 0.16384072885974033, 0.150753619246643, 0.17002329764990776, 0.3365824376788801, 0.36436044022032876, 0.4104239063989046, 0.36215850192391585, 0.36421992922970425, 0.37303284273089987, 0.39924272013251816, 0.39314187005289836, 0.40618145272894224, 0.2707517404895986, 0.29272182703415117, 0.2661664061847069, 0.2296602375001151, 0.2599685029177323, 0.25961735896361593, 0.31498231188969517, 0.327918527562292, 0.29280533201149683, 0.19260917387268517, 0.20756482917217756, 0.2099354834511905, 0.2026292954841431, 0.20862431326342656, 0.20247704004750744, 0.19889994082729834, 0.2168113481318571, 0.20253774307206118, 0.20450464870004303, 0.29181604529886296, 0.30550664392179927, 0.3056238938991297, 0.19497987301266495, 0.3057053032662481, 0.22765414631551995, 0.23754106366737116, 0.22511200763545813, 0.1925327674506584, 0.1996832657592651, 0.6869780383363059, 0.7215116438504618, 0.6772259604728927, 0.668224009631798, 0.16413228643574818, 0.184445153194567, 0.7313492760663372, 0.7317720441945056, 0.37655084090037194, 0.7630697540838438, 0.20190460989907255, 0.46282205545503086, 0.20185285987223356, 0.3954905909491063, 0.41802559519045857, 0.5349356912404313, 0.18181462808842552, 0.17698850608240568, 0.1744551108698582, 0.1916838351599982, 0.18285804479241197, 0.1829210899117325, 0.17476985283739865, 0.19304538675642946, 0.1831957508963601, 0.0786915194645067, 0.09398478108659825, 0.08056903295384577, 0.08346098101949173, 0.07644857909885328, 0.10932811423938893, 0.07733468714068781, 0.0830517648003366, 0.08412568434693968]}, "mutation_prompt": null}
{"id": "7315a21f-38db-420e-af74-c04df33cc3da", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5\n        self.diversity_threshold = 0.1  # New parameter for diversity\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        self.F = 0.1 + 0.9 * np.random.rand()\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant, rank):\n        self.CR = 0.5 + 0.5 * (rank / self.population_size)\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0, momentum=np.zeros((1,))):\n        direction = np.random.normal(0, 1, self.dim)\n        diversity = np.std(individual)  # Calculate diversity\n        adaptive_step_size = 0.1 + 0.2 * (1 - diversity / self.diversity_threshold)  # Adaptive step size\n        step_size = np.random.uniform(0.05, 0.15) * scale * adaptive_step_size\n        momentum = 0.7 * momentum + step_size * direction\n        new_individual = np.clip(individual + momentum, self.lower_bound, self.upper_bound)\n        return new_individual, momentum\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n        momentum = np.zeros((self.population_size, self.dim))\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                rank = np.argsort(fitness).tolist().index(i)\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant, rank)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    neighbors = np.random.choice(self.population_size, 5, replace=False)\n                    best_neighbor = min(neighbors, key=lambda idx: fitness[idx])\n                    direction = population[best_neighbor] - population[i]\n                    local_candidate = np.clip(population[i] + 0.1 * direction, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "Integrate a diversity-preserving strategy and adaptive learning rate into the local search phase to enhance global exploration.", "configspace": "", "generation": 80, "fitness": 0.348383129168905, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.24.", "error": "", "parent_id": "83410bc6-a534-470c-b14e-e6dd83f0107d", "metadata": {"aucs": [0.7872662782232155, 0.7614452136338328, 0.7805064778725795, 0.777033032966406, 0.7942952704767343, 0.7865536967590909, 0.8098531367378005, 0.7856280244862203, 0.7746465622920444, 0.6173062827372708, 0.6159208546969014, 0.6118065550376617, 0.610497869807928, 0.6069507224223654, 0.6034317931000741, 0.6241996506983545, 0.6170956151703697, 0.6174962310319495, 0.16875690858881387, 0.16978754038424881, 0.1442986428188553, 0.1956904658831139, 0.23934467282060357, 0.14588586324563801, 0.14950077905265224, 0.33743626613019495, 0.20866212052994104, 0.1205345146103225, 0.13926576880289632, 0.13822167064067303, 0.12942694041542158, 0.1281983309324407, 0.14186107340297216, 0.12073543636727302, 0.14097352769367666, 0.1554506259033167, 0.8885709347273463, 0.8557578777417613, 0.9009513152894469, 0.9239845432386716, 0.895995087726823, 0.8634551789802956, 0.8625595759926562, 0.8594465255658232, 0.8620186052938734, 0.38589748153512726, 0.3873452064021907, 0.3563102830622802, 0.35491754368707584, 0.39219265884828114, 0.3637561149951083, 0.38100935279155457, 0.38921214406864924, 0.4029378062653397, 0.7305625534696606, 0.715620622963973, 0.7121897951309525, 0.708937962576391, 0.706590932208257, 0.6833759278034606, 0.6821359026364014, 0.7526333491896928, 0.709335533790602, 0.15333130488525437, 0.19821390933768512, 0.2050821843868884, 0.178335706145052, 0.17425783224728764, 0.22810148600640023, 0.25213456430302517, 0.1703460256871676, 0.21603779778543863, 0.17957295970712361, 0.2005863393737526, 0.2039759327499383, 0.13779337617090937, 0.20957779579711844, 0.24460308218446003, 0.17442114274148257, 0.15058318170012863, 0.16779673728798827, 0.19753565320136302, 0.21278533973706626, 0.25632945816341113, 0.31029821513792855, 0.13126327270759752, 0.13127073117409216, 0.2741835540001334, 0.34491092014935554, 0.16756508718766105, 0.4131768851962542, 0.4529658992378788, 0.4682477710614157, 0.36897785454709897, 0.39177971739930306, 0.3228091757761715, 0.540555556317911, 0.4798360018515757, 0.5132692806622567, 0.21349717654360545, 0.18627544276040053, 0.10537804847317944, 0.10248107734226519, 0.08382704655689344, 0.16673730970541, 0.17088987205881734, 0.10503827924756515, 0.13025257498049736, 0.2802295989555189, 0.2502820025029229, 0.2952413968755899, 0.2843705315813757, 0.25826269247562395, 0.2953775739742128, 0.2068419131747965, 0.24364418189670078, 0.15364961010201172, 0.6234457881631293, 0.6757471858704971, 0.6697391248468605, 0.5598079929206922, 0.6468507529878808, 0.6210684912371793, 0.6541046172748212, 0.6574734058073645, 0.6544831731966804, 0.11214768830756472, 0.123770535107383, 0.10990337876385414, 0.13739989145727882, 0.10272696810840476, 0.11896651905999045, 0.1100777997466863, 0.11136484729193419, 0.11720455865846491, 0.14443669858596553, 0.13297059698897318, 0.15329234741332642, 0.1810857227812891, 0.15584535659462473, 0.16806858876923347, 0.16384072885974033, 0.150753619246643, 0.17002329764990776, 0.3365824376788801, 0.36436044022032876, 0.4104239063989046, 0.36215850192391585, 0.36421992922970425, 0.37303284273089987, 0.39924272013251816, 0.39314187005289836, 0.40618145272894224, 0.2707517404895986, 0.29272182703415117, 0.2661664061847069, 0.2296602375001151, 0.2599685029177323, 0.25961735896361593, 0.31498231188969517, 0.327918527562292, 0.29280533201149683, 0.19260917387268517, 0.20756482917217756, 0.2099354834511905, 0.2026292954841431, 0.20862431326342656, 0.20247704004750744, 0.19889994082729834, 0.2168113481318571, 0.20253774307206118, 0.20450464870004303, 0.29181604529886296, 0.30550664392179927, 0.3056238938991297, 0.19497987301266495, 0.3057053032662481, 0.22765414631551995, 0.23754106366737116, 0.22511200763545813, 0.1925327674506584, 0.1996832657592651, 0.6869780383363059, 0.7215116438504618, 0.6772259604728927, 0.668224009631798, 0.16413228643574818, 0.184445153194567, 0.7313492760663372, 0.7317720441945056, 0.37655084090037194, 0.7630697540838438, 0.20190460989907255, 0.46282205545503086, 0.20185285987223356, 0.3954905909491063, 0.41802559519045857, 0.5349356912404313, 0.18181462808842552, 0.17698850608240568, 0.1744551108698582, 0.1916838351599982, 0.18285804479241197, 0.1829210899117325, 0.17476985283739865, 0.19304538675642946, 0.1831957508963601, 0.0786915194645067, 0.09398478108659825, 0.08056903295384577, 0.08346098101949173, 0.07644857909885328, 0.10932811423938893, 0.07733468714068781, 0.0830517648003366, 0.08412568434693968]}, "mutation_prompt": null}
{"id": "9cae60bd-d675-459e-be3a-313a428df50f", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        # Self-adaptive mutation factor\n        self.F = 0.1 + 0.9 * np.random.rand()\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant, rank):\n        # Rank-based adaptive crossover rate\n        self.CR = 0.5 + 0.5 * (rank / self.population_size)\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0, momentum=np.zeros((1,))):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        momentum = 0.7 * momentum + step_size * direction  # Adjusted momentum\n        new_individual = np.clip(individual + momentum, self.lower_bound, self.upper_bound)\n        return new_individual, momentum\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n        momentum = np.zeros((self.population_size, self.dim))\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                rank = np.argsort(fitness).tolist().index(i)  # Get rank of the individual\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant, rank)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    # Introduce neighborhood-aware local search\n                    neighbors = np.random.choice(self.population_size, 5, replace=False)\n                    best_neighbor = min(neighbors, key=lambda idx: fitness[idx])\n                    direction = population[best_neighbor] - population[i]\n                    local_candidate = np.clip(population[i] + 0.1 * direction, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduce a self-adaptive strategy for mutation factor F and integrate a neighborhood-aware local search to enhance convergence.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "83410bc6-a534-470c-b14e-e6dd83f0107d", "metadata": {"aucs": [0.7872662782232155, 0.7614452136338328, 0.7805064778725795, 0.777033032966406, 0.7942952704767343, 0.7865536967590909, 0.8098531367378005, 0.7856280244862203, 0.7746465622920444, 0.6173062827372708, 0.6159208546969014, 0.6118065550376617, 0.610497869807928, 0.6069507224223654, 0.6034317931000741, 0.6241996506983545, 0.6170956151703697, 0.6174962310319495, 0.16875690858881387, 0.16978754038424881, 0.1442986428188553, 0.1956904658831139, 0.23934467282060357, 0.14588586324563801, 0.14950077905265224, 0.33743626613019495, 0.20866212052994104, 0.1205345146103225, 0.13926576880289632, 0.13822167064067303, 0.12942694041542158, 0.1281983309324407, 0.14186107340297216, 0.12073543636727302, 0.14097352769367666, 0.1554506259033167, 0.8885709347273463, 0.8557578777417613, 0.9009513152894469, 0.9239845432386716, 0.895995087726823, 0.8634551789802956, 0.8625595759926562, 0.8594465255658232, 0.8620186052938734, 0.38589748153512726, 0.3873452064021907, 0.3563102830622802, 0.35491754368707584, 0.39219265884828114, 0.3637561149951083, 0.38100935279155457, 0.38921214406864924, 0.4029378062653397, 0.7305625534696606, 0.715620622963973, 0.7121897951309525, 0.708937962576391, 0.706590932208257, 0.6833759278034606, 0.6821359026364014, 0.7526333491896928, 0.709335533790602, 0.15333130488525437, 0.19821390933768512, 0.2050821843868884, 0.178335706145052, 0.17425783224728764, 0.22810148600640023, 0.25213456430302517, 0.1703460256871676, 0.21603779778543863, 0.17957295970712361, 0.2005863393737526, 0.2039759327499383, 0.13779337617090937, 0.20957779579711844, 0.24460308218446003, 0.17442114274148257, 0.15058318170012863, 0.16779673728798827, 0.19753565320136302, 0.21278533973706626, 0.25632945816341113, 0.31029821513792855, 0.13126327270759752, 0.13127073117409216, 0.2741835540001334, 0.34491092014935554, 0.16756508718766105, 0.4131768851962542, 0.4529658992378788, 0.4682477710614157, 0.36897785454709897, 0.39177971739930306, 0.3228091757761715, 0.540555556317911, 0.4798360018515757, 0.5132692806622567, 0.21349717654360545, 0.18627544276040053, 0.10537804847317944, 0.10248107734226519, 0.08382704655689344, 0.16673730970541, 0.17088987205881734, 0.10503827924756515, 0.13025257498049736, 0.2802295989555189, 0.2502820025029229, 0.2952413968755899, 0.2843705315813757, 0.25826269247562395, 0.2953775739742128, 0.2068419131747965, 0.24364418189670078, 0.15364961010201172, 0.6234457881631293, 0.6757471858704971, 0.6697391248468605, 0.5598079929206922, 0.6468507529878808, 0.6210684912371793, 0.6541046172748212, 0.6574734058073645, 0.6544831731966804, 0.11214768830756472, 0.123770535107383, 0.10990337876385414, 0.13739989145727882, 0.10272696810840476, 0.11896651905999045, 0.1100777997466863, 0.11136484729193419, 0.11720455865846491, 0.14443669858596553, 0.13297059698897318, 0.15329234741332642, 0.1810857227812891, 0.15584535659462473, 0.16806858876923347, 0.16384072885974033, 0.150753619246643, 0.17002329764990776, 0.3365824376788801, 0.36436044022032876, 0.4104239063989046, 0.36215850192391585, 0.36421992922970425, 0.37303284273089987, 0.39924272013251816, 0.39314187005289836, 0.40618145272894224, 0.2707517404895986, 0.29272182703415117, 0.2661664061847069, 0.2296602375001151, 0.2599685029177323, 0.25961735896361593, 0.31498231188969517, 0.327918527562292, 0.29280533201149683, 0.19260917387268517, 0.20756482917217756, 0.2099354834511905, 0.2026292954841431, 0.20862431326342656, 0.20247704004750744, 0.19889994082729834, 0.2168113481318571, 0.20253774307206118, 0.20450464870004303, 0.29181604529886296, 0.30550664392179927, 0.3056238938991297, 0.19497987301266495, 0.3057053032662481, 0.22765414631551995, 0.23754106366737116, 0.22511200763545813, 0.1925327674506584, 0.1996832657592651, 0.6869780383363059, 0.7215116438504618, 0.6772259604728927, 0.668224009631798, 0.16413228643574818, 0.184445153194567, 0.7313492760663372, 0.7317720441945056, 0.37655084090037194, 0.7630697540838438, 0.20190460989907255, 0.46282205545503086, 0.20185285987223356, 0.3954905909491063, 0.41802559519045857, 0.5349356912404313, 0.18181462808842552, 0.17698850608240568, 0.1744551108698582, 0.1916838351599982, 0.18285804479241197, 0.1829210899117325, 0.17476985283739865, 0.19304538675642946, 0.1831957508963601, 0.0786915194645067, 0.09398478108659825, 0.08056903295384577, 0.08346098101949173, 0.07644857909885328, 0.10932811423938893, 0.07733468714068781, 0.0830517648003366, 0.08412568434693968]}, "mutation_prompt": null}
{"id": "175b6c93-0222-4ab1-8db8-e4f3d743218b", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        # Dynamic mutation scaling based on budget usage\n        dynamic_scale = 0.1 + 0.8 * (1 - (self.budget_used / self.budget))\n        self.F = dynamic_scale * (0.1 + 0.9 * np.random.rand())  \n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant, rank):\n        self.CR = 0.5 + 0.5 * (rank / self.population_size)\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0, momentum=np.zeros((1,))):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        momentum = 0.7 * momentum + step_size * direction\n        new_individual = np.clip(individual + momentum, self.lower_bound, self.upper_bound)\n        return new_individual, momentum\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n        momentum = np.zeros((self.population_size, self.dim))\n        self.budget_used = evals\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                rank = np.argsort(fitness).tolist().index(i)\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant, rank)\n                trial_fitness = func(trial)\n                evals += 1\n                self.budget_used = evals  # Track evaluations used\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    neighbors = np.random.choice(self.population_size, 5, replace=False)\n                    best_neighbor = min(neighbors, key=lambda idx: fitness[idx])\n                    direction = population[best_neighbor] - population[i]\n                    local_candidate = np.clip(population[i] + 0.1 * direction, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n            # Adaptive resizing based on budget usage\n            if evals < self.budget / 2 and self.population_size < 20 * self.dim:\n                self.population_size += 1  # Increase population size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduce adaptive population resizing and a dynamic mutation scaling mechanism to enhance exploration and exploitation balance.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 60 is out of bounds for axis 0 with size 60').", "error": "IndexError('index 60 is out of bounds for axis 0 with size 60')", "parent_id": "83410bc6-a534-470c-b14e-e6dd83f0107d", "metadata": {}, "mutation_prompt": null}
{"id": "b5ed38a2-ead2-4ef3-9004-ad9cb1de8af5", "solution": "import numpy as np\n\nclass RefinedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        # Dual mutation strategy\n        self.F = 0.1 + 0.9 * np.random.rand()\n        mutant_diff = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        direction_cauchy = np.random.standard_cauchy(self.dim)\n        mutant_cauchy = np.clip(pop[idx] + 0.1 * direction_cauchy, self.lower_bound, self.upper_bound)\n        if np.random.rand() < 0.5:\n            mutant = mutant_diff\n        else:\n            mutant = mutant_cauchy\n        return mutant\n\n    def _crossover(self, target, mutant, rank):\n        self.CR = 0.5 + 0.5 * (rank / self.population_size)\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0, momentum=np.zeros((1,))):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        momentum = 0.7 * momentum + step_size * direction\n        new_individual = np.clip(individual + momentum, self.lower_bound, self.upper_bound)\n        return new_individual, momentum\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n        momentum = np.zeros((self.population_size, self.dim))\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                rank = np.argsort(fitness).tolist().index(i)\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant, rank)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    neighbors = np.random.choice(self.population_size, 5, replace=False)\n                    best_neighbor = min(neighbors, key=lambda idx: fitness[idx])\n                    direction = population[best_neighbor] - population[i]\n                    local_candidate = np.clip(population[i] + 0.1 * direction, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "RefinedHybridDifferentialEvolution", "description": "Implement a dual mutation strategy combining differential mutation with Cauchy distribution to enhance global exploration.", "configspace": "", "generation": 83, "fitness": 0.2835723787366539, "feedback": "The algorithm RefinedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.20.", "error": "", "parent_id": "83410bc6-a534-470c-b14e-e6dd83f0107d", "metadata": {"aucs": [0.6531657184720427, 0.6327552995199721, 0.6866068657853567, 0.6785547208639331, 0.6585992617516393, 0.6690079247777678, 0.6819631215002717, 0.6613802533804435, 0.6590825017500945, 0.40477441650833557, 0.3554479136598053, 0.36045415548823323, 0.35976528899366855, 0.36535045395378474, 0.39292886634316104, 0.3901083458697784, 0.3552438165809295, 0.36407104648201283, 0.15190731006724267, 0.1305868747246588, 0.1446597702249195, 0.13228787167450684, 0.12922170051140203, 0.18320675131072106, 0.13405343518819313, 0.1291011647572048, 0.14722193594048494, 0.12385100300236918, 0.12445866411638307, 0.11828947559670322, 0.12139774453220453, 0.11345518085216877, 0.09701394475701675, 0.11465732673562834, 0.10719848298093582, 0.11714690396626815, 0.9293557059350603, 0.8955729496318756, 0.8588900641105226, 0.876919769195605, 0.9227048495905474, 0.8374558782494063, 0.83604575240268, 0.8624414476649127, 0.9150060395589776, 0.2948400430128447, 0.26191109695884174, 0.24199960194228354, 0.2740587119917126, 0.2383954411905307, 0.24866809021993042, 0.2642010357478324, 0.2952786720755295, 0.23434040493408848, 0.5585114861339092, 0.48389896165876656, 0.43021848532598184, 0.5621046896950199, 0.6338734694425373, 0.6109098118200538, 0.49969649200916666, 0.4236917756849844, 0.5377847576895523, 0.23860984913600547, 0.21501814420051746, 0.28325761171363295, 0.13408234713787592, 0.17398192507957488, 0.23485428940048503, 0.1819381218564482, 0.15752988905030307, 0.148672903855935, 0.19240510256591203, 0.12625609045585462, 0.12334629485053716, 0.15207971870710535, 0.14796037840262466, 0.16356136960025747, 0.1422220216194282, 0.15201192383411166, 0.20047821730486648, 0.12982390744127803, 0.13854433155335677, 0.08608498908448126, 0.12080854658525109, 0.12572280727495422, 0.10967769115687953, 0.16177118742141372, 0.08515724151432713, 0.09717798685928958, 0.2563689088910037, 0.29884891595346885, 0.32370001614270394, 0.13544915822965153, 0.21776955055478686, 0.1981768023556193, 0.3818484750149721, 0.2572914181438746, 0.266567188621619, 0.05720737515169494, 0.06880139903575277, 0.09906536239353392, 0.060599646699384335, 0.12015873137941946, 0.13304692425765574, 0.11511624452106173, 0.13871571505888602, 0.11605674147108402, 0.17243065190898432, 0.19540988639827606, 0.21088278702409813, 0.1492215036222857, 0.17408965365897144, 0.18172507888805067, 0.1792811235359335, 0.18969765215302947, 0.11299931287727394, 0.5100815690025877, 0.5136709030417188, 0.515239409001047, 0.518745382110295, 0.5121844184000252, 0.4687480237591567, 0.5087660166667063, 0.4893161259399933, 0.507155289875064, 0.1123010970797006, 0.11729861439133271, 0.1092105794555871, 0.10539550676403486, 0.10620636950960383, 0.13029809345203847, 0.11750554264768198, 0.10728647009032988, 0.10459416372007402, 0.1663498504863945, 0.17423280829015186, 0.17279494387963135, 0.1967913902797087, 0.17252949571303744, 0.17128295120070836, 0.16932426663733602, 0.18702156100477418, 0.15587806284326777, 0.28967885377695546, 0.28868048188921536, 0.2787537069420294, 0.2657772726619927, 0.2628080942209734, 0.26476947176907895, 0.2873470207494181, 0.31328529921656023, 0.27931647343703003, 0.21839531910549526, 0.24015249297286934, 0.2442653253402326, 0.2111459640812139, 0.22108521075804355, 0.21783810857717933, 0.21979122140954932, 0.22646482103741128, 0.19798484265759453, 0.19256870715899577, 0.20722869211356787, 0.2097298776730394, 0.2153708381545505, 0.18778807404641984, 0.20283995312642256, 0.1993642154187918, 0.2065071252248868, 0.2039568632003994, 0.22974107178046443, 0.2515564478649117, 0.20932339053066984, 0.1931440983825755, 0.2037559061052827, 0.22705698635137395, 0.22072096987814316, 0.2026567622932114, 0.2087577783494643, 0.41193334487984135, 0.18324423951244428, 0.3784071035968677, 0.6841242396579554, 0.27193308731233934, 0.6231244906701217, 0.45165313470814594, 0.30149303189249443, 0.37366284300672126, 0.6755300873968512, 0.36497784204049755, 0.6807122076058283, 0.37596001614199337, 0.30527937844270536, 0.19036395965572228, 0.2763307235212933, 0.5412119199790566, 0.613325692949042, 0.21246125772351876, 0.18980555161400015, 0.18089994286525402, 0.18662279709339857, 0.17675367002039766, 0.1839322606152537, 0.17967522602731556, 0.1849048874856437, 0.18170601343542503, 0.08120694510539073, 0.08697852177768195, 0.0895125294706468, 0.07815048314567064, 0.09320666948609813, 0.08950822516824175, 0.07477769902489195, 0.07166220266863244, 0.07547282982267844]}, "mutation_prompt": null}
{"id": "60cdc37c-8d3b-442c-9b1a-6a8fb1091f5b", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        # Self-adaptive mutation factor\n        self.F = 0.1 + 0.9 * np.random.rand()\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant, rank):\n        # Rank-based adaptive crossover rate\n        self.CR = 0.5 + 0.5 * (rank / self.population_size)\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0, momentum=np.zeros((1,))):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        momentum = 0.7 * momentum + step_size * direction  # Adjusted momentum\n        new_individual = np.clip(individual + momentum, self.lower_bound, self.upper_bound)\n        return new_individual, momentum\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n        momentum = np.zeros((self.population_size, self.dim))\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                rank = np.argsort(fitness).tolist().index(i)  # Get rank of the individual\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant, rank)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    # Introduce neighborhood-aware local search\n                    neighbors = np.random.choice(self.population_size, 5, replace=False)\n                    best_neighbor = min(neighbors, key=lambda idx: fitness[idx])\n                    direction = population[best_neighbor] - population[i]\n                    local_candidate = np.clip(population[i] + 0.1 * direction, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduce a self-adaptive strategy for mutation factor F and integrate a neighborhood-aware local search to enhance convergence.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "83410bc6-a534-470c-b14e-e6dd83f0107d", "metadata": {"aucs": [0.7872662782232155, 0.7614452136338328, 0.7805064778725795, 0.777033032966406, 0.7942952704767343, 0.7865536967590909, 0.8098531367378005, 0.7856280244862203, 0.7746465622920444, 0.6173062827372708, 0.6159208546969014, 0.6118065550376617, 0.610497869807928, 0.6069507224223654, 0.6034317931000741, 0.6241996506983545, 0.6170956151703697, 0.6174962310319495, 0.16875690858881387, 0.16978754038424881, 0.1442986428188553, 0.1956904658831139, 0.23934467282060357, 0.14588586324563801, 0.14950077905265224, 0.33743626613019495, 0.20866212052994104, 0.1205345146103225, 0.13926576880289632, 0.13822167064067303, 0.12942694041542158, 0.1281983309324407, 0.14186107340297216, 0.12073543636727302, 0.14097352769367666, 0.1554506259033167, 0.8885709347273463, 0.8557578777417613, 0.9009513152894469, 0.9239845432386716, 0.895995087726823, 0.8634551789802956, 0.8625595759926562, 0.8594465255658232, 0.8620186052938734, 0.38589748153512726, 0.3873452064021907, 0.3563102830622802, 0.35491754368707584, 0.39219265884828114, 0.3637561149951083, 0.38100935279155457, 0.38921214406864924, 0.4029378062653397, 0.7305625534696606, 0.715620622963973, 0.7121897951309525, 0.708937962576391, 0.706590932208257, 0.6833759278034606, 0.6821359026364014, 0.7526333491896928, 0.709335533790602, 0.15333130488525437, 0.19821390933768512, 0.2050821843868884, 0.178335706145052, 0.17425783224728764, 0.22810148600640023, 0.25213456430302517, 0.1703460256871676, 0.21603779778543863, 0.17957295970712361, 0.2005863393737526, 0.2039759327499383, 0.13779337617090937, 0.20957779579711844, 0.24460308218446003, 0.17442114274148257, 0.15058318170012863, 0.16779673728798827, 0.19753565320136302, 0.21278533973706626, 0.25632945816341113, 0.31029821513792855, 0.13126327270759752, 0.13127073117409216, 0.2741835540001334, 0.34491092014935554, 0.16756508718766105, 0.4131768851962542, 0.4529658992378788, 0.4682477710614157, 0.36897785454709897, 0.39177971739930306, 0.3228091757761715, 0.540555556317911, 0.4798360018515757, 0.5132692806622567, 0.21349717654360545, 0.18627544276040053, 0.10537804847317944, 0.10248107734226519, 0.08382704655689344, 0.16673730970541, 0.17088987205881734, 0.10503827924756515, 0.13025257498049736, 0.2802295989555189, 0.2502820025029229, 0.2952413968755899, 0.2843705315813757, 0.25826269247562395, 0.2953775739742128, 0.2068419131747965, 0.24364418189670078, 0.15364961010201172, 0.6234457881631293, 0.6757471858704971, 0.6697391248468605, 0.5598079929206922, 0.6468507529878808, 0.6210684912371793, 0.6541046172748212, 0.6574734058073645, 0.6544831731966804, 0.11214768830756472, 0.123770535107383, 0.10990337876385414, 0.13739989145727882, 0.10272696810840476, 0.11896651905999045, 0.1100777997466863, 0.11136484729193419, 0.11720455865846491, 0.14443669858596553, 0.13297059698897318, 0.15329234741332642, 0.1810857227812891, 0.15584535659462473, 0.16806858876923347, 0.16384072885974033, 0.150753619246643, 0.17002329764990776, 0.3365824376788801, 0.36436044022032876, 0.4104239063989046, 0.36215850192391585, 0.36421992922970425, 0.37303284273089987, 0.39924272013251816, 0.39314187005289836, 0.40618145272894224, 0.2707517404895986, 0.29272182703415117, 0.2661664061847069, 0.2296602375001151, 0.2599685029177323, 0.25961735896361593, 0.31498231188969517, 0.327918527562292, 0.29280533201149683, 0.19260917387268517, 0.20756482917217756, 0.2099354834511905, 0.2026292954841431, 0.20862431326342656, 0.20247704004750744, 0.19889994082729834, 0.2168113481318571, 0.20253774307206118, 0.20450464870004303, 0.29181604529886296, 0.30550664392179927, 0.3056238938991297, 0.19497987301266495, 0.3057053032662481, 0.22765414631551995, 0.23754106366737116, 0.22511200763545813, 0.1925327674506584, 0.1996832657592651, 0.6869780383363059, 0.7215116438504618, 0.6772259604728927, 0.668224009631798, 0.16413228643574818, 0.184445153194567, 0.7313492760663372, 0.7317720441945056, 0.37655084090037194, 0.7630697540838438, 0.20190460989907255, 0.46282205545503086, 0.20185285987223356, 0.3954905909491063, 0.41802559519045857, 0.5349356912404313, 0.18181462808842552, 0.17698850608240568, 0.1744551108698582, 0.1916838351599982, 0.18285804479241197, 0.1829210899117325, 0.17476985283739865, 0.19304538675642946, 0.1831957508963601, 0.0786915194645067, 0.09398478108659825, 0.08056903295384577, 0.08346098101949173, 0.07644857909885328, 0.10932811423938893, 0.07733468714068781, 0.0830517648003366, 0.08412568434693968]}, "mutation_prompt": null}
{"id": "01a64e24-0d61-455d-83c6-904c5c4c5527", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 12 * dim\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.current_population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        self.F = 0.1 + 0.9 * np.random.rand()\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant, rank):\n        self.CR = 0.5 + 0.5 * (rank / self.current_population_size)\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0, momentum=np.zeros((1,))):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        momentum = 0.7 * momentum + step_size * direction\n        new_individual = np.clip(individual + momentum, self.lower_bound, self.upper_bound)\n        return new_individual, momentum\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.initial_population_size\n        momentum = np.zeros((self.initial_population_size, self.dim))\n\n        while evals < self.budget:\n            self.current_population_size = max(4, int(self.initial_population_size * (1 - evals / self.budget)))\n            for i in range(self.current_population_size):\n                rank = np.argsort(fitness).tolist().index(i)\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant, rank)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                dynamic_local_search_prob = self.local_search_prob * (1 - evals / self.budget)\n                if np.random.rand() < dynamic_local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    neighbors = np.random.choice(self.current_population_size, 5, replace=False)\n                    best_neighbor = min(neighbors, key=lambda idx: fitness[idx])\n                    direction = population[best_neighbor] - population[i]\n                    local_candidate = np.clip(population[i] + 0.1 * direction, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "Integrate dynamic population size scaling and adaptive local search probability to enhance exploration and exploitation balance.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "83410bc6-a534-470c-b14e-e6dd83f0107d", "metadata": {}, "mutation_prompt": null}
{"id": "39947e65-534a-42a0-8265-20af14e433df", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        # Self-adaptive mutation factor\n        self.F = 0.1 + 0.9 * np.random.rand()\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant, rank):\n        # Rank-based adaptive crossover rate\n        self.CR = 0.5 + 0.5 * (rank / self.population_size)\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0, momentum=np.zeros((1,))):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        momentum = 0.7 * momentum + step_size * direction  # Adjusted momentum\n        new_individual = np.clip(individual + momentum, self.lower_bound, self.upper_bound)\n        return new_individual, momentum\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n        momentum = np.zeros((self.population_size, self.dim))\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                rank = np.argsort(fitness).tolist().index(i)  # Get rank of the individual\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant, rank)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    # Introduce neighborhood-aware local search\n                    neighbors = np.random.choice(self.population_size, 5, replace=False)\n                    best_neighbor = min(neighbors, key=lambda idx: fitness[idx])\n                    direction = population[best_neighbor] - population[i]\n                    local_candidate = np.clip(population[i] + 0.1 * direction, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduce a self-adaptive strategy for mutation factor F and integrate a neighborhood-aware local search to enhance convergence.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "83410bc6-a534-470c-b14e-e6dd83f0107d", "metadata": {"aucs": [0.7872662782232155, 0.7614452136338328, 0.7805064778725795, 0.777033032966406, 0.7942952704767343, 0.7865536967590909, 0.8098531367378005, 0.7856280244862203, 0.7746465622920444, 0.6173062827372708, 0.6159208546969014, 0.6118065550376617, 0.610497869807928, 0.6069507224223654, 0.6034317931000741, 0.6241996506983545, 0.6170956151703697, 0.6174962310319495, 0.16875690858881387, 0.16978754038424881, 0.1442986428188553, 0.1956904658831139, 0.23934467282060357, 0.14588586324563801, 0.14950077905265224, 0.33743626613019495, 0.20866212052994104, 0.1205345146103225, 0.13926576880289632, 0.13822167064067303, 0.12942694041542158, 0.1281983309324407, 0.14186107340297216, 0.12073543636727302, 0.14097352769367666, 0.1554506259033167, 0.8885709347273463, 0.8557578777417613, 0.9009513152894469, 0.9239845432386716, 0.895995087726823, 0.8634551789802956, 0.8625595759926562, 0.8594465255658232, 0.8620186052938734, 0.38589748153512726, 0.3873452064021907, 0.3563102830622802, 0.35491754368707584, 0.39219265884828114, 0.3637561149951083, 0.38100935279155457, 0.38921214406864924, 0.4029378062653397, 0.7305625534696606, 0.715620622963973, 0.7121897951309525, 0.708937962576391, 0.706590932208257, 0.6833759278034606, 0.6821359026364014, 0.7526333491896928, 0.709335533790602, 0.15333130488525437, 0.19821390933768512, 0.2050821843868884, 0.178335706145052, 0.17425783224728764, 0.22810148600640023, 0.25213456430302517, 0.1703460256871676, 0.21603779778543863, 0.17957295970712361, 0.2005863393737526, 0.2039759327499383, 0.13779337617090937, 0.20957779579711844, 0.24460308218446003, 0.17442114274148257, 0.15058318170012863, 0.16779673728798827, 0.19753565320136302, 0.21278533973706626, 0.25632945816341113, 0.31029821513792855, 0.13126327270759752, 0.13127073117409216, 0.2741835540001334, 0.34491092014935554, 0.16756508718766105, 0.4131768851962542, 0.4529658992378788, 0.4682477710614157, 0.36897785454709897, 0.39177971739930306, 0.3228091757761715, 0.540555556317911, 0.4798360018515757, 0.5132692806622567, 0.21349717654360545, 0.18627544276040053, 0.10537804847317944, 0.10248107734226519, 0.08382704655689344, 0.16673730970541, 0.17088987205881734, 0.10503827924756515, 0.13025257498049736, 0.2802295989555189, 0.2502820025029229, 0.2952413968755899, 0.2843705315813757, 0.25826269247562395, 0.2953775739742128, 0.2068419131747965, 0.24364418189670078, 0.15364961010201172, 0.6234457881631293, 0.6757471858704971, 0.6697391248468605, 0.5598079929206922, 0.6468507529878808, 0.6210684912371793, 0.6541046172748212, 0.6574734058073645, 0.6544831731966804, 0.11214768830756472, 0.123770535107383, 0.10990337876385414, 0.13739989145727882, 0.10272696810840476, 0.11896651905999045, 0.1100777997466863, 0.11136484729193419, 0.11720455865846491, 0.14443669858596553, 0.13297059698897318, 0.15329234741332642, 0.1810857227812891, 0.15584535659462473, 0.16806858876923347, 0.16384072885974033, 0.150753619246643, 0.17002329764990776, 0.3365824376788801, 0.36436044022032876, 0.4104239063989046, 0.36215850192391585, 0.36421992922970425, 0.37303284273089987, 0.39924272013251816, 0.39314187005289836, 0.40618145272894224, 0.2707517404895986, 0.29272182703415117, 0.2661664061847069, 0.2296602375001151, 0.2599685029177323, 0.25961735896361593, 0.31498231188969517, 0.327918527562292, 0.29280533201149683, 0.19260917387268517, 0.20756482917217756, 0.2099354834511905, 0.2026292954841431, 0.20862431326342656, 0.20247704004750744, 0.19889994082729834, 0.2168113481318571, 0.20253774307206118, 0.20450464870004303, 0.29181604529886296, 0.30550664392179927, 0.3056238938991297, 0.19497987301266495, 0.3057053032662481, 0.22765414631551995, 0.23754106366737116, 0.22511200763545813, 0.1925327674506584, 0.1996832657592651, 0.6869780383363059, 0.7215116438504618, 0.6772259604728927, 0.668224009631798, 0.16413228643574818, 0.184445153194567, 0.7313492760663372, 0.7317720441945056, 0.37655084090037194, 0.7630697540838438, 0.20190460989907255, 0.46282205545503086, 0.20185285987223356, 0.3954905909491063, 0.41802559519045857, 0.5349356912404313, 0.18181462808842552, 0.17698850608240568, 0.1744551108698582, 0.1916838351599982, 0.18285804479241197, 0.1829210899117325, 0.17476985283739865, 0.19304538675642946, 0.1831957508963601, 0.0786915194645067, 0.09398478108659825, 0.08056903295384577, 0.08346098101949173, 0.07644857909885328, 0.10932811423938893, 0.07733468714068781, 0.0830517648003366, 0.08412568434693968]}, "mutation_prompt": null}
{"id": "5027d66c-5894-4e3e-adb4-8f7edfd4d340", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        # Self-adaptive mutation factor\n        self.F = 0.1 + 0.9 * np.random.rand()\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant, rank):\n        # Rank-based adaptive crossover rate\n        self.CR = 0.5 + 0.5 * (rank / self.population_size)\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0, momentum=np.zeros((1,))):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        momentum = 0.7 * momentum + step_size * direction  # Adjusted momentum\n        new_individual = np.clip(individual + momentum, self.lower_bound, self.upper_bound)\n        return new_individual, momentum\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n        momentum = np.zeros((self.population_size, self.dim))\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                rank = np.argsort(fitness).tolist().index(i)  # Get rank of the individual\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant, rank)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    # Introduce neighborhood-aware local search\n                    neighbors = np.random.choice(self.population_size, 5, replace=False)\n                    best_neighbor = min(neighbors, key=lambda idx: fitness[idx])\n                    direction = population[best_neighbor] - population[i]\n                    local_candidate = np.clip(population[i] + 0.1 * direction, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduce a self-adaptive strategy for mutation factor F and integrate a neighborhood-aware local search to enhance convergence.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "83410bc6-a534-470c-b14e-e6dd83f0107d", "metadata": {"aucs": [0.7872662782232155, 0.7614452136338328, 0.7805064778725795, 0.777033032966406, 0.7942952704767343, 0.7865536967590909, 0.8098531367378005, 0.7856280244862203, 0.7746465622920444, 0.6173062827372708, 0.6159208546969014, 0.6118065550376617, 0.610497869807928, 0.6069507224223654, 0.6034317931000741, 0.6241996506983545, 0.6170956151703697, 0.6174962310319495, 0.16875690858881387, 0.16978754038424881, 0.1442986428188553, 0.1956904658831139, 0.23934467282060357, 0.14588586324563801, 0.14950077905265224, 0.33743626613019495, 0.20866212052994104, 0.1205345146103225, 0.13926576880289632, 0.13822167064067303, 0.12942694041542158, 0.1281983309324407, 0.14186107340297216, 0.12073543636727302, 0.14097352769367666, 0.1554506259033167, 0.8885709347273463, 0.8557578777417613, 0.9009513152894469, 0.9239845432386716, 0.895995087726823, 0.8634551789802956, 0.8625595759926562, 0.8594465255658232, 0.8620186052938734, 0.38589748153512726, 0.3873452064021907, 0.3563102830622802, 0.35491754368707584, 0.39219265884828114, 0.3637561149951083, 0.38100935279155457, 0.38921214406864924, 0.4029378062653397, 0.7305625534696606, 0.715620622963973, 0.7121897951309525, 0.708937962576391, 0.706590932208257, 0.6833759278034606, 0.6821359026364014, 0.7526333491896928, 0.709335533790602, 0.15333130488525437, 0.19821390933768512, 0.2050821843868884, 0.178335706145052, 0.17425783224728764, 0.22810148600640023, 0.25213456430302517, 0.1703460256871676, 0.21603779778543863, 0.17957295970712361, 0.2005863393737526, 0.2039759327499383, 0.13779337617090937, 0.20957779579711844, 0.24460308218446003, 0.17442114274148257, 0.15058318170012863, 0.16779673728798827, 0.19753565320136302, 0.21278533973706626, 0.25632945816341113, 0.31029821513792855, 0.13126327270759752, 0.13127073117409216, 0.2741835540001334, 0.34491092014935554, 0.16756508718766105, 0.4131768851962542, 0.4529658992378788, 0.4682477710614157, 0.36897785454709897, 0.39177971739930306, 0.3228091757761715, 0.540555556317911, 0.4798360018515757, 0.5132692806622567, 0.21349717654360545, 0.18627544276040053, 0.10537804847317944, 0.10248107734226519, 0.08382704655689344, 0.16673730970541, 0.17088987205881734, 0.10503827924756515, 0.13025257498049736, 0.2802295989555189, 0.2502820025029229, 0.2952413968755899, 0.2843705315813757, 0.25826269247562395, 0.2953775739742128, 0.2068419131747965, 0.24364418189670078, 0.15364961010201172, 0.6234457881631293, 0.6757471858704971, 0.6697391248468605, 0.5598079929206922, 0.6468507529878808, 0.6210684912371793, 0.6541046172748212, 0.6574734058073645, 0.6544831731966804, 0.11214768830756472, 0.123770535107383, 0.10990337876385414, 0.13739989145727882, 0.10272696810840476, 0.11896651905999045, 0.1100777997466863, 0.11136484729193419, 0.11720455865846491, 0.14443669858596553, 0.13297059698897318, 0.15329234741332642, 0.1810857227812891, 0.15584535659462473, 0.16806858876923347, 0.16384072885974033, 0.150753619246643, 0.17002329764990776, 0.3365824376788801, 0.36436044022032876, 0.4104239063989046, 0.36215850192391585, 0.36421992922970425, 0.37303284273089987, 0.39924272013251816, 0.39314187005289836, 0.40618145272894224, 0.2707517404895986, 0.29272182703415117, 0.2661664061847069, 0.2296602375001151, 0.2599685029177323, 0.25961735896361593, 0.31498231188969517, 0.327918527562292, 0.29280533201149683, 0.19260917387268517, 0.20756482917217756, 0.2099354834511905, 0.2026292954841431, 0.20862431326342656, 0.20247704004750744, 0.19889994082729834, 0.2168113481318571, 0.20253774307206118, 0.20450464870004303, 0.29181604529886296, 0.30550664392179927, 0.3056238938991297, 0.19497987301266495, 0.3057053032662481, 0.22765414631551995, 0.23754106366737116, 0.22511200763545813, 0.1925327674506584, 0.1996832657592651, 0.6869780383363059, 0.7215116438504618, 0.6772259604728927, 0.668224009631798, 0.16413228643574818, 0.184445153194567, 0.7313492760663372, 0.7317720441945056, 0.37655084090037194, 0.7630697540838438, 0.20190460989907255, 0.46282205545503086, 0.20185285987223356, 0.3954905909491063, 0.41802559519045857, 0.5349356912404313, 0.18181462808842552, 0.17698850608240568, 0.1744551108698582, 0.1916838351599982, 0.18285804479241197, 0.1829210899117325, 0.17476985283739865, 0.19304538675642946, 0.1831957508963601, 0.0786915194645067, 0.09398478108659825, 0.08056903295384577, 0.08346098101949173, 0.07644857909885328, 0.10932811423938893, 0.07733468714068781, 0.0830517648003366, 0.08412568434693968]}, "mutation_prompt": null}
{"id": "f12f5931-61f1-48a7-b144-2097f0f9d350", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 12 * dim\n        self.population_size = self.initial_population_size\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        self.F = 0.5 + 0.5 * np.random.rand()  # Adjusted mutation factor\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant, rank):\n        self.CR = 0.5 + 0.5 * (rank / self.population_size)\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale, momentum=np.zeros((1,))):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = 0.1 * scale  # Simplified step size\n        momentum = 0.7 * momentum + step_size * direction\n        new_individual = np.clip(individual + momentum, self.lower_bound, self.upper_bound)\n        return new_individual, momentum\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n        momentum = np.zeros((self.population_size, self.dim))\n\n        while evals < self.budget:\n            adaptive_pop_size = max(self.initial_population_size // 2, int(self.initial_population_size * (1 - evals / self.budget)))\n            self.population_size = adaptive_pop_size\n\n            for i in range(self.population_size):\n                rank = np.argsort(fitness).tolist().index(i)\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant, rank)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)**2  # Implemented cooling schedule\n                    local_candidate, momentum[i] = self._local_search(population[i], scale_factor, momentum[i])\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "Integrate a dynamic population size and a cooling schedule for local search to enhance exploration and exploitation phases.", "configspace": "", "generation": 88, "fitness": 0.2981428088717759, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.22.", "error": "", "parent_id": "83410bc6-a534-470c-b14e-e6dd83f0107d", "metadata": {"aucs": [0.7055555222812988, 0.6879376278498299, 0.6858905154553754, 0.6880349133168362, 0.6896460416843551, 0.6850438960827934, 0.6896105176332781, 0.7061287522818164, 0.68525048657668, 0.4653128891233178, 0.47608462813163765, 0.4955449803402734, 0.47170889934335514, 0.477828797345048, 0.48995840364376264, 0.4745735639922197, 0.480791021260516, 0.48795580159744556, 0.14379834717052487, 0.12920180760725164, 0.12181774349591301, 0.13860650105672467, 0.15024794588622314, 0.16408903565055366, 0.13819155156501728, 0.13367958997036733, 0.1525797356122064, 0.11261550223082972, 0.11350294037526198, 0.11580633596657497, 0.11729662140112018, 0.11701868915937974, 0.11834014490133193, 0.13108152653586802, 0.11263758155538506, 0.12780147525359675, 0.9852290982690964, 0.9316296595173709, 0.9416583697597914, 0.9070153217529492, 0.9482763699268252, 0.9416405647924144, 0.9180460754311632, 0.9371898480756129, 0.9138099029920966, 0.3258215986050812, 0.35319262770066984, 0.3452797721911184, 0.3332040818370695, 0.3016362053425823, 0.35124506002993616, 0.33960970675497015, 0.3429052155850715, 0.3263529254399976, 0.5776200752750641, 0.5463361113995567, 0.47994962671125396, 0.614762811553998, 0.575521219745368, 0.6528289054905355, 0.571726261240749, 0.5855176930659736, 0.5547630277172888, 0.2141873354720366, 0.21870508445145498, 0.19424185831568908, 0.23055790878658144, 0.1882437122844849, 0.20061179774349924, 0.2478339733888142, 0.2568992835178835, 0.23343356466727394, 0.14109381945832244, 0.20937204284120725, 0.19527527474079098, 0.24657052938410384, 0.1684246622941712, 0.2218347020517607, 0.20583603324198552, 0.21949952364583847, 0.15730447514001733, 0.17606679160808003, 0.1585038902508772, 0.17422374249617711, 0.13419228360593483, 0.1499633812984248, 0.11269106041451538, 0.16688264732431413, 0.11426108030697046, 0.16477898841402405, 0.25397319994082024, 0.25060268518132256, 0.29478057880942776, 0.27606914372847047, 0.28208723549419246, 0.273821493248832, 0.27698002721831994, 0.2837478297515086, 0.3006252444221883, 0.022312937072953898, 0.05225319784722415, 0.053946851226078785, 0.08021128482915774, 0.05076517342780784, 0.09042213047432546, 0.09125361064125703, 0.02351397504718966, 0.05227868802245761, 0.1615965931474006, 0.16036390173637993, 0.15502321532884433, 0.17305497068202225, 0.18044784550896753, 0.19003737625945238, 0.18914278733161616, 0.19279205928213072, 0.16688886192110386, 0.49594311038136063, 0.49951169341205026, 0.5282753356071473, 0.5181361040581116, 0.5162062116718661, 0.5379068931477945, 0.5118453877738496, 0.5185964539672971, 0.5157382659961859, 0.09724009655076082, 0.11677813278152294, 0.09711479352081354, 0.08952275336153215, 0.10473497839506818, 0.10929940232869362, 0.09320661417238296, 0.10481490831815787, 0.09362935373213499, 0.16519305857403088, 0.1855191566890355, 0.1703004578781021, 0.17248641512185492, 0.19778765652279195, 0.2616087412134097, 0.17046521457836716, 0.18758008742183097, 0.19394547706255094, 0.31960243393411714, 0.2688755831196904, 0.2842652373925628, 0.2860714418361696, 0.28961277232663274, 0.27520197522420997, 0.3272660093932962, 0.3457155170564453, 0.3189160092855752, 0.21926205037424007, 0.23089821819064804, 0.23605263297038903, 0.2021408867374389, 0.22156065283114612, 0.22696897127952376, 0.25581504238715147, 0.26992070973002835, 0.21743568919768008, 0.2017958845360167, 0.1937560758487089, 0.18660175235991505, 0.18983518962128687, 0.18473941805517102, 0.18864079960572788, 0.19499216461585056, 0.18007604062880544, 0.19562401150511644, 0.1837428630151372, 0.22062813307640994, 0.20394139257770838, 0.20366450630296495, 0.1988020564098567, 0.1970732542316509, 0.18984362368386187, 0.18346490428547957, 0.20171877589723242, 0.5705941272597792, 0.5942718467185322, 0.603351846168466, 0.40713172486275706, 0.59937911937452, 0.17317041497237606, 0.43683752032205847, 0.1840439705525878, 0.572353037567666, 0.17896705615419795, 0.5140992215839704, 0.5360398028179092, 0.18578368450081162, 0.20643749475686957, 0.4758700899397048, 0.6327881351918314, 0.20619966600500128, 0.20153215177325767, 0.18722329700353113, 0.18516290113691558, 0.18446486017878672, 0.18990877777474557, 0.19892160569141204, 0.18543670277235835, 0.19926550686531075, 0.18623370221612923, 0.1881979052327567, 0.07921330223071332, 0.08171562872485316, 0.07548946530030676, 0.08215591679458745, 0.07755240613452674, 0.06594942148712102, 0.08384434817872877, 0.07761201589351607, 0.07931779413818563]}, "mutation_prompt": null}
{"id": "5675265a-acdc-4731-ae2c-5498409a1fa5", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        # Self-adaptive mutation factor\n        self.F = 0.1 + 0.9 * np.random.rand()\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant, rank):\n        # Rank-based adaptive crossover rate\n        self.CR = 0.5 + 0.5 * (rank / self.population_size)\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0, momentum=np.zeros((1,))):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        momentum = 0.7 * momentum + step_size * direction  # Adjusted momentum\n        new_individual = np.clip(individual + momentum, self.lower_bound, self.upper_bound)\n        return new_individual, momentum\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n        momentum = np.zeros((self.population_size, self.dim))\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                rank = np.argsort(fitness).tolist().index(i)  # Get rank of the individual\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant, rank)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    # Introduce neighborhood-aware local search\n                    neighbors = np.random.choice(self.population_size, 5, replace=False)\n                    best_neighbor = min(neighbors, key=lambda idx: fitness[idx])\n                    direction = population[best_neighbor] - population[i]\n                    local_candidate = np.clip(population[i] + 0.1 * direction, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduce a self-adaptive strategy for mutation factor F and integrate a neighborhood-aware local search to enhance convergence.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "83410bc6-a534-470c-b14e-e6dd83f0107d", "metadata": {"aucs": [0.7872662782232155, 0.7614452136338328, 0.7805064778725795, 0.777033032966406, 0.7942952704767343, 0.7865536967590909, 0.8098531367378005, 0.7856280244862203, 0.7746465622920444, 0.6173062827372708, 0.6159208546969014, 0.6118065550376617, 0.610497869807928, 0.6069507224223654, 0.6034317931000741, 0.6241996506983545, 0.6170956151703697, 0.6174962310319495, 0.16875690858881387, 0.16978754038424881, 0.1442986428188553, 0.1956904658831139, 0.23934467282060357, 0.14588586324563801, 0.14950077905265224, 0.33743626613019495, 0.20866212052994104, 0.1205345146103225, 0.13926576880289632, 0.13822167064067303, 0.12942694041542158, 0.1281983309324407, 0.14186107340297216, 0.12073543636727302, 0.14097352769367666, 0.1554506259033167, 0.8885709347273463, 0.8557578777417613, 0.9009513152894469, 0.9239845432386716, 0.895995087726823, 0.8634551789802956, 0.8625595759926562, 0.8594465255658232, 0.8620186052938734, 0.38589748153512726, 0.3873452064021907, 0.3563102830622802, 0.35491754368707584, 0.39219265884828114, 0.3637561149951083, 0.38100935279155457, 0.38921214406864924, 0.4029378062653397, 0.7305625534696606, 0.715620622963973, 0.7121897951309525, 0.708937962576391, 0.706590932208257, 0.6833759278034606, 0.6821359026364014, 0.7526333491896928, 0.709335533790602, 0.15333130488525437, 0.19821390933768512, 0.2050821843868884, 0.178335706145052, 0.17425783224728764, 0.22810148600640023, 0.25213456430302517, 0.1703460256871676, 0.21603779778543863, 0.17957295970712361, 0.2005863393737526, 0.2039759327499383, 0.13779337617090937, 0.20957779579711844, 0.24460308218446003, 0.17442114274148257, 0.15058318170012863, 0.16779673728798827, 0.19753565320136302, 0.21278533973706626, 0.25632945816341113, 0.31029821513792855, 0.13126327270759752, 0.13127073117409216, 0.2741835540001334, 0.34491092014935554, 0.16756508718766105, 0.4131768851962542, 0.4529658992378788, 0.4682477710614157, 0.36897785454709897, 0.39177971739930306, 0.3228091757761715, 0.540555556317911, 0.4798360018515757, 0.5132692806622567, 0.21349717654360545, 0.18627544276040053, 0.10537804847317944, 0.10248107734226519, 0.08382704655689344, 0.16673730970541, 0.17088987205881734, 0.10503827924756515, 0.13025257498049736, 0.2802295989555189, 0.2502820025029229, 0.2952413968755899, 0.2843705315813757, 0.25826269247562395, 0.2953775739742128, 0.2068419131747965, 0.24364418189670078, 0.15364961010201172, 0.6234457881631293, 0.6757471858704971, 0.6697391248468605, 0.5598079929206922, 0.6468507529878808, 0.6210684912371793, 0.6541046172748212, 0.6574734058073645, 0.6544831731966804, 0.11214768830756472, 0.123770535107383, 0.10990337876385414, 0.13739989145727882, 0.10272696810840476, 0.11896651905999045, 0.1100777997466863, 0.11136484729193419, 0.11720455865846491, 0.14443669858596553, 0.13297059698897318, 0.15329234741332642, 0.1810857227812891, 0.15584535659462473, 0.16806858876923347, 0.16384072885974033, 0.150753619246643, 0.17002329764990776, 0.3365824376788801, 0.36436044022032876, 0.4104239063989046, 0.36215850192391585, 0.36421992922970425, 0.37303284273089987, 0.39924272013251816, 0.39314187005289836, 0.40618145272894224, 0.2707517404895986, 0.29272182703415117, 0.2661664061847069, 0.2296602375001151, 0.2599685029177323, 0.25961735896361593, 0.31498231188969517, 0.327918527562292, 0.29280533201149683, 0.19260917387268517, 0.20756482917217756, 0.2099354834511905, 0.2026292954841431, 0.20862431326342656, 0.20247704004750744, 0.19889994082729834, 0.2168113481318571, 0.20253774307206118, 0.20450464870004303, 0.29181604529886296, 0.30550664392179927, 0.3056238938991297, 0.19497987301266495, 0.3057053032662481, 0.22765414631551995, 0.23754106366737116, 0.22511200763545813, 0.1925327674506584, 0.1996832657592651, 0.6869780383363059, 0.7215116438504618, 0.6772259604728927, 0.668224009631798, 0.16413228643574818, 0.184445153194567, 0.7313492760663372, 0.7317720441945056, 0.37655084090037194, 0.7630697540838438, 0.20190460989907255, 0.46282205545503086, 0.20185285987223356, 0.3954905909491063, 0.41802559519045857, 0.5349356912404313, 0.18181462808842552, 0.17698850608240568, 0.1744551108698582, 0.1916838351599982, 0.18285804479241197, 0.1829210899117325, 0.17476985283739865, 0.19304538675642946, 0.1831957508963601, 0.0786915194645067, 0.09398478108659825, 0.08056903295384577, 0.08346098101949173, 0.07644857909885328, 0.10932811423938893, 0.07733468714068781, 0.0830517648003366, 0.08412568434693968]}, "mutation_prompt": null}
{"id": "70f0132f-fde0-44e0-9215-0468e6bafaa4", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        # Self-adaptive mutation factor\n        self.F = 0.1 + 0.9 * np.random.rand()\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant, rank):\n        # Rank-based adaptive crossover rate\n        self.CR = 0.5 + 0.5 * (rank / self.population_size)\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0, momentum=np.zeros((1,))):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        momentum = 0.7 * momentum + step_size * direction  # Adjusted momentum\n        new_individual = np.clip(individual + momentum, self.lower_bound, self.upper_bound)\n        return new_individual, momentum\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n        momentum = np.zeros((self.population_size, self.dim))\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                rank = np.argsort(fitness).tolist().index(i)  # Get rank of the individual\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant, rank)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    # Introduce neighborhood-aware local search\n                    neighbors = np.random.choice(self.population_size, 5, replace=False)\n                    best_neighbor = min(neighbors, key=lambda idx: fitness[idx])\n                    direction = population[best_neighbor] - population[i]\n                    local_candidate = np.clip(population[i] + 0.1 * direction, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduce a self-adaptive strategy for mutation factor F and integrate a neighborhood-aware local search to enhance convergence.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "83410bc6-a534-470c-b14e-e6dd83f0107d", "metadata": {"aucs": [0.7872662782232155, 0.7614452136338328, 0.7805064778725795, 0.777033032966406, 0.7942952704767343, 0.7865536967590909, 0.8098531367378005, 0.7856280244862203, 0.7746465622920444, 0.6173062827372708, 0.6159208546969014, 0.6118065550376617, 0.610497869807928, 0.6069507224223654, 0.6034317931000741, 0.6241996506983545, 0.6170956151703697, 0.6174962310319495, 0.16875690858881387, 0.16978754038424881, 0.1442986428188553, 0.1956904658831139, 0.23934467282060357, 0.14588586324563801, 0.14950077905265224, 0.33743626613019495, 0.20866212052994104, 0.1205345146103225, 0.13926576880289632, 0.13822167064067303, 0.12942694041542158, 0.1281983309324407, 0.14186107340297216, 0.12073543636727302, 0.14097352769367666, 0.1554506259033167, 0.8885709347273463, 0.8557578777417613, 0.9009513152894469, 0.9239845432386716, 0.895995087726823, 0.8634551789802956, 0.8625595759926562, 0.8594465255658232, 0.8620186052938734, 0.38589748153512726, 0.3873452064021907, 0.3563102830622802, 0.35491754368707584, 0.39219265884828114, 0.3637561149951083, 0.38100935279155457, 0.38921214406864924, 0.4029378062653397, 0.7305625534696606, 0.715620622963973, 0.7121897951309525, 0.708937962576391, 0.706590932208257, 0.6833759278034606, 0.6821359026364014, 0.7526333491896928, 0.709335533790602, 0.15333130488525437, 0.19821390933768512, 0.2050821843868884, 0.178335706145052, 0.17425783224728764, 0.22810148600640023, 0.25213456430302517, 0.1703460256871676, 0.21603779778543863, 0.17957295970712361, 0.2005863393737526, 0.2039759327499383, 0.13779337617090937, 0.20957779579711844, 0.24460308218446003, 0.17442114274148257, 0.15058318170012863, 0.16779673728798827, 0.19753565320136302, 0.21278533973706626, 0.25632945816341113, 0.31029821513792855, 0.13126327270759752, 0.13127073117409216, 0.2741835540001334, 0.34491092014935554, 0.16756508718766105, 0.4131768851962542, 0.4529658992378788, 0.4682477710614157, 0.36897785454709897, 0.39177971739930306, 0.3228091757761715, 0.540555556317911, 0.4798360018515757, 0.5132692806622567, 0.21349717654360545, 0.18627544276040053, 0.10537804847317944, 0.10248107734226519, 0.08382704655689344, 0.16673730970541, 0.17088987205881734, 0.10503827924756515, 0.13025257498049736, 0.2802295989555189, 0.2502820025029229, 0.2952413968755899, 0.2843705315813757, 0.25826269247562395, 0.2953775739742128, 0.2068419131747965, 0.24364418189670078, 0.15364961010201172, 0.6234457881631293, 0.6757471858704971, 0.6697391248468605, 0.5598079929206922, 0.6468507529878808, 0.6210684912371793, 0.6541046172748212, 0.6574734058073645, 0.6544831731966804, 0.11214768830756472, 0.123770535107383, 0.10990337876385414, 0.13739989145727882, 0.10272696810840476, 0.11896651905999045, 0.1100777997466863, 0.11136484729193419, 0.11720455865846491, 0.14443669858596553, 0.13297059698897318, 0.15329234741332642, 0.1810857227812891, 0.15584535659462473, 0.16806858876923347, 0.16384072885974033, 0.150753619246643, 0.17002329764990776, 0.3365824376788801, 0.36436044022032876, 0.4104239063989046, 0.36215850192391585, 0.36421992922970425, 0.37303284273089987, 0.39924272013251816, 0.39314187005289836, 0.40618145272894224, 0.2707517404895986, 0.29272182703415117, 0.2661664061847069, 0.2296602375001151, 0.2599685029177323, 0.25961735896361593, 0.31498231188969517, 0.327918527562292, 0.29280533201149683, 0.19260917387268517, 0.20756482917217756, 0.2099354834511905, 0.2026292954841431, 0.20862431326342656, 0.20247704004750744, 0.19889994082729834, 0.2168113481318571, 0.20253774307206118, 0.20450464870004303, 0.29181604529886296, 0.30550664392179927, 0.3056238938991297, 0.19497987301266495, 0.3057053032662481, 0.22765414631551995, 0.23754106366737116, 0.22511200763545813, 0.1925327674506584, 0.1996832657592651, 0.6869780383363059, 0.7215116438504618, 0.6772259604728927, 0.668224009631798, 0.16413228643574818, 0.184445153194567, 0.7313492760663372, 0.7317720441945056, 0.37655084090037194, 0.7630697540838438, 0.20190460989907255, 0.46282205545503086, 0.20185285987223356, 0.3954905909491063, 0.41802559519045857, 0.5349356912404313, 0.18181462808842552, 0.17698850608240568, 0.1744551108698582, 0.1916838351599982, 0.18285804479241197, 0.1829210899117325, 0.17476985283739865, 0.19304538675642946, 0.1831957508963601, 0.0786915194645067, 0.09398478108659825, 0.08056903295384577, 0.08346098101949173, 0.07644857909885328, 0.10932811423938893, 0.07733468714068781, 0.0830517648003366, 0.08412568434693968]}, "mutation_prompt": null}
{"id": "e90ff49f-c53b-4e11-bfb0-6b2805b79887", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        # Self-adaptive mutation factor\n        self.F = 0.1 + 0.9 * np.random.rand()\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant, rank):\n        # Rank-based adaptive crossover rate\n        self.CR = 0.5 + 0.5 * (rank / self.population_size)\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0, momentum=np.zeros((1,))):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        momentum = 0.7 * momentum + step_size * direction  # Adjusted momentum\n        new_individual = np.clip(individual + momentum, self.lower_bound, self.upper_bound)\n        return new_individual, momentum\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n        momentum = np.zeros((self.population_size, self.dim))\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                rank = np.argsort(fitness).tolist().index(i)  # Get rank of the individual\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant, rank)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    # Introduce neighborhood-aware local search\n                    neighbors = np.random.choice(self.population_size, 5, replace=False)\n                    best_neighbor = min(neighbors, key=lambda idx: fitness[idx])\n                    direction = population[best_neighbor] - population[i]\n                    local_candidate = np.clip(population[i] + 0.1 * direction, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduce a self-adaptive strategy for mutation factor F and integrate a neighborhood-aware local search to enhance convergence.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "83410bc6-a534-470c-b14e-e6dd83f0107d", "metadata": {"aucs": [0.7872662782232155, 0.7614452136338328, 0.7805064778725795, 0.777033032966406, 0.7942952704767343, 0.7865536967590909, 0.8098531367378005, 0.7856280244862203, 0.7746465622920444, 0.6173062827372708, 0.6159208546969014, 0.6118065550376617, 0.610497869807928, 0.6069507224223654, 0.6034317931000741, 0.6241996506983545, 0.6170956151703697, 0.6174962310319495, 0.16875690858881387, 0.16978754038424881, 0.1442986428188553, 0.1956904658831139, 0.23934467282060357, 0.14588586324563801, 0.14950077905265224, 0.33743626613019495, 0.20866212052994104, 0.1205345146103225, 0.13926576880289632, 0.13822167064067303, 0.12942694041542158, 0.1281983309324407, 0.14186107340297216, 0.12073543636727302, 0.14097352769367666, 0.1554506259033167, 0.8885709347273463, 0.8557578777417613, 0.9009513152894469, 0.9239845432386716, 0.895995087726823, 0.8634551789802956, 0.8625595759926562, 0.8594465255658232, 0.8620186052938734, 0.38589748153512726, 0.3873452064021907, 0.3563102830622802, 0.35491754368707584, 0.39219265884828114, 0.3637561149951083, 0.38100935279155457, 0.38921214406864924, 0.4029378062653397, 0.7305625534696606, 0.715620622963973, 0.7121897951309525, 0.708937962576391, 0.706590932208257, 0.6833759278034606, 0.6821359026364014, 0.7526333491896928, 0.709335533790602, 0.15333130488525437, 0.19821390933768512, 0.2050821843868884, 0.178335706145052, 0.17425783224728764, 0.22810148600640023, 0.25213456430302517, 0.1703460256871676, 0.21603779778543863, 0.17957295970712361, 0.2005863393737526, 0.2039759327499383, 0.13779337617090937, 0.20957779579711844, 0.24460308218446003, 0.17442114274148257, 0.15058318170012863, 0.16779673728798827, 0.19753565320136302, 0.21278533973706626, 0.25632945816341113, 0.31029821513792855, 0.13126327270759752, 0.13127073117409216, 0.2741835540001334, 0.34491092014935554, 0.16756508718766105, 0.4131768851962542, 0.4529658992378788, 0.4682477710614157, 0.36897785454709897, 0.39177971739930306, 0.3228091757761715, 0.540555556317911, 0.4798360018515757, 0.5132692806622567, 0.21349717654360545, 0.18627544276040053, 0.10537804847317944, 0.10248107734226519, 0.08382704655689344, 0.16673730970541, 0.17088987205881734, 0.10503827924756515, 0.13025257498049736, 0.2802295989555189, 0.2502820025029229, 0.2952413968755899, 0.2843705315813757, 0.25826269247562395, 0.2953775739742128, 0.2068419131747965, 0.24364418189670078, 0.15364961010201172, 0.6234457881631293, 0.6757471858704971, 0.6697391248468605, 0.5598079929206922, 0.6468507529878808, 0.6210684912371793, 0.6541046172748212, 0.6574734058073645, 0.6544831731966804, 0.11214768830756472, 0.123770535107383, 0.10990337876385414, 0.13739989145727882, 0.10272696810840476, 0.11896651905999045, 0.1100777997466863, 0.11136484729193419, 0.11720455865846491, 0.14443669858596553, 0.13297059698897318, 0.15329234741332642, 0.1810857227812891, 0.15584535659462473, 0.16806858876923347, 0.16384072885974033, 0.150753619246643, 0.17002329764990776, 0.3365824376788801, 0.36436044022032876, 0.4104239063989046, 0.36215850192391585, 0.36421992922970425, 0.37303284273089987, 0.39924272013251816, 0.39314187005289836, 0.40618145272894224, 0.2707517404895986, 0.29272182703415117, 0.2661664061847069, 0.2296602375001151, 0.2599685029177323, 0.25961735896361593, 0.31498231188969517, 0.327918527562292, 0.29280533201149683, 0.19260917387268517, 0.20756482917217756, 0.2099354834511905, 0.2026292954841431, 0.20862431326342656, 0.20247704004750744, 0.19889994082729834, 0.2168113481318571, 0.20253774307206118, 0.20450464870004303, 0.29181604529886296, 0.30550664392179927, 0.3056238938991297, 0.19497987301266495, 0.3057053032662481, 0.22765414631551995, 0.23754106366737116, 0.22511200763545813, 0.1925327674506584, 0.1996832657592651, 0.6869780383363059, 0.7215116438504618, 0.6772259604728927, 0.668224009631798, 0.16413228643574818, 0.184445153194567, 0.7313492760663372, 0.7317720441945056, 0.37655084090037194, 0.7630697540838438, 0.20190460989907255, 0.46282205545503086, 0.20185285987223356, 0.3954905909491063, 0.41802559519045857, 0.5349356912404313, 0.18181462808842552, 0.17698850608240568, 0.1744551108698582, 0.1916838351599982, 0.18285804479241197, 0.1829210899117325, 0.17476985283739865, 0.19304538675642946, 0.1831957508963601, 0.0786915194645067, 0.09398478108659825, 0.08056903295384577, 0.08346098101949173, 0.07644857909885328, 0.10932811423938893, 0.07733468714068781, 0.0830517648003366, 0.08412568434693968]}, "mutation_prompt": null}
{"id": "613b3de2-1f19-48ff-903d-c1b3ae930e78", "solution": "import numpy as np\nfrom sklearn.cluster import KMeans\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        self.F = 0.4 + 0.5 * np.random.rand()  # Adaptive mutation factor\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant, rank):\n        self.CR = 0.5 + 0.5 * (rank / self.population_size)\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0, momentum=np.zeros((1,))):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        momentum = 0.7 * momentum + step_size * direction\n        new_individual = np.clip(individual + momentum, self.lower_bound, self.upper_bound)\n        return new_individual, momentum\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n        momentum = np.zeros((self.population_size, self.dim))\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                rank = np.argsort(fitness).tolist().index(i)\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant, rank)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    kmeans = KMeans(n_clusters=3)  # Diversity maintenance through clustering\n                    kmeans.fit(population)\n                    cluster_center = kmeans.cluster_centers_[kmeans.labels_[i]]\n                    direction = cluster_center - population[i]\n                    local_candidate = np.clip(population[i] + 0.1 * direction, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduce diversity maintenance using clustering and adaptive mutation step-size to enhance exploration and exploitation balance.", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "An exception occurred: ModuleNotFoundError(\"No module named 'sklearn'\").", "error": "ModuleNotFoundError(\"No module named 'sklearn'\")", "parent_id": "83410bc6-a534-470c-b14e-e6dd83f0107d", "metadata": {}, "mutation_prompt": null}
{"id": "2ab4342c-23ca-4733-a6f2-7bfca47c06ed", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        # Self-adaptive mutation factor\n        self.F = 0.1 + 0.9 * np.random.rand()\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant, rank):\n        # Rank-based adaptive crossover rate\n        self.CR = 0.5 + 0.5 * (rank / self.population_size)\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0, momentum=np.zeros((1,))):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        momentum = 0.7 * momentum + step_size * direction  # Adjusted momentum\n        new_individual = np.clip(individual + momentum, self.lower_bound, self.upper_bound)\n        return new_individual, momentum\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n        momentum = np.zeros((self.population_size, self.dim))\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                rank = np.argsort(fitness).tolist().index(i)  # Get rank of the individual\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant, rank)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    # Introduce neighborhood-aware local search\n                    neighbors = np.random.choice(self.population_size, 5, replace=False)\n                    best_neighbor = min(neighbors, key=lambda idx: fitness[idx])\n                    direction = population[best_neighbor] - population[i]\n                    local_candidate = np.clip(population[i] + 0.1 * direction, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduce a self-adaptive strategy for mutation factor F and integrate a neighborhood-aware local search to enhance convergence.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "83410bc6-a534-470c-b14e-e6dd83f0107d", "metadata": {"aucs": [0.7872662782232155, 0.7614452136338328, 0.7805064778725795, 0.777033032966406, 0.7942952704767343, 0.7865536967590909, 0.8098531367378005, 0.7856280244862203, 0.7746465622920444, 0.6173062827372708, 0.6159208546969014, 0.6118065550376617, 0.610497869807928, 0.6069507224223654, 0.6034317931000741, 0.6241996506983545, 0.6170956151703697, 0.6174962310319495, 0.16875690858881387, 0.16978754038424881, 0.1442986428188553, 0.1956904658831139, 0.23934467282060357, 0.14588586324563801, 0.14950077905265224, 0.33743626613019495, 0.20866212052994104, 0.1205345146103225, 0.13926576880289632, 0.13822167064067303, 0.12942694041542158, 0.1281983309324407, 0.14186107340297216, 0.12073543636727302, 0.14097352769367666, 0.1554506259033167, 0.8885709347273463, 0.8557578777417613, 0.9009513152894469, 0.9239845432386716, 0.895995087726823, 0.8634551789802956, 0.8625595759926562, 0.8594465255658232, 0.8620186052938734, 0.38589748153512726, 0.3873452064021907, 0.3563102830622802, 0.35491754368707584, 0.39219265884828114, 0.3637561149951083, 0.38100935279155457, 0.38921214406864924, 0.4029378062653397, 0.7305625534696606, 0.715620622963973, 0.7121897951309525, 0.708937962576391, 0.706590932208257, 0.6833759278034606, 0.6821359026364014, 0.7526333491896928, 0.709335533790602, 0.15333130488525437, 0.19821390933768512, 0.2050821843868884, 0.178335706145052, 0.17425783224728764, 0.22810148600640023, 0.25213456430302517, 0.1703460256871676, 0.21603779778543863, 0.17957295970712361, 0.2005863393737526, 0.2039759327499383, 0.13779337617090937, 0.20957779579711844, 0.24460308218446003, 0.17442114274148257, 0.15058318170012863, 0.16779673728798827, 0.19753565320136302, 0.21278533973706626, 0.25632945816341113, 0.31029821513792855, 0.13126327270759752, 0.13127073117409216, 0.2741835540001334, 0.34491092014935554, 0.16756508718766105, 0.4131768851962542, 0.4529658992378788, 0.4682477710614157, 0.36897785454709897, 0.39177971739930306, 0.3228091757761715, 0.540555556317911, 0.4798360018515757, 0.5132692806622567, 0.21349717654360545, 0.18627544276040053, 0.10537804847317944, 0.10248107734226519, 0.08382704655689344, 0.16673730970541, 0.17088987205881734, 0.10503827924756515, 0.13025257498049736, 0.2802295989555189, 0.2502820025029229, 0.2952413968755899, 0.2843705315813757, 0.25826269247562395, 0.2953775739742128, 0.2068419131747965, 0.24364418189670078, 0.15364961010201172, 0.6234457881631293, 0.6757471858704971, 0.6697391248468605, 0.5598079929206922, 0.6468507529878808, 0.6210684912371793, 0.6541046172748212, 0.6574734058073645, 0.6544831731966804, 0.11214768830756472, 0.123770535107383, 0.10990337876385414, 0.13739989145727882, 0.10272696810840476, 0.11896651905999045, 0.1100777997466863, 0.11136484729193419, 0.11720455865846491, 0.14443669858596553, 0.13297059698897318, 0.15329234741332642, 0.1810857227812891, 0.15584535659462473, 0.16806858876923347, 0.16384072885974033, 0.150753619246643, 0.17002329764990776, 0.3365824376788801, 0.36436044022032876, 0.4104239063989046, 0.36215850192391585, 0.36421992922970425, 0.37303284273089987, 0.39924272013251816, 0.39314187005289836, 0.40618145272894224, 0.2707517404895986, 0.29272182703415117, 0.2661664061847069, 0.2296602375001151, 0.2599685029177323, 0.25961735896361593, 0.31498231188969517, 0.327918527562292, 0.29280533201149683, 0.19260917387268517, 0.20756482917217756, 0.2099354834511905, 0.2026292954841431, 0.20862431326342656, 0.20247704004750744, 0.19889994082729834, 0.2168113481318571, 0.20253774307206118, 0.20450464870004303, 0.29181604529886296, 0.30550664392179927, 0.3056238938991297, 0.19497987301266495, 0.3057053032662481, 0.22765414631551995, 0.23754106366737116, 0.22511200763545813, 0.1925327674506584, 0.1996832657592651, 0.6869780383363059, 0.7215116438504618, 0.6772259604728927, 0.668224009631798, 0.16413228643574818, 0.184445153194567, 0.7313492760663372, 0.7317720441945056, 0.37655084090037194, 0.7630697540838438, 0.20190460989907255, 0.46282205545503086, 0.20185285987223356, 0.3954905909491063, 0.41802559519045857, 0.5349356912404313, 0.18181462808842552, 0.17698850608240568, 0.1744551108698582, 0.1916838351599982, 0.18285804479241197, 0.1829210899117325, 0.17476985283739865, 0.19304538675642946, 0.1831957508963601, 0.0786915194645067, 0.09398478108659825, 0.08056903295384577, 0.08346098101949173, 0.07644857909885328, 0.10932811423938893, 0.07733468714068781, 0.0830517648003366, 0.08412568434693968]}, "mutation_prompt": null}
{"id": "ef0d87fe-bdc0-405b-8782-aaad72dc0ac0", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        # Self-adaptive mutation factor\n        self.F = 0.1 + 0.9 * np.random.rand()\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant, rank):\n        # Rank-based adaptive crossover rate\n        self.CR = 0.5 + 0.5 * (rank / self.population_size)\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0, momentum=np.zeros((1,))):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        momentum = 0.7 * momentum + step_size * direction  # Adjusted momentum\n        new_individual = np.clip(individual + momentum, self.lower_bound, self.upper_bound)\n        return new_individual, momentum\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n        momentum = np.zeros((self.population_size, self.dim))\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                rank = np.argsort(fitness).tolist().index(i)  # Get rank of the individual\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant, rank)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    # Introduce neighborhood-aware local search\n                    neighbors = np.random.choice(self.population_size, 5, replace=False)\n                    best_neighbor = min(neighbors, key=lambda idx: fitness[idx])\n                    direction = population[best_neighbor] - population[i]\n                    local_candidate = np.clip(population[i] + 0.1 * direction, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduce a self-adaptive strategy for mutation factor F and integrate a neighborhood-aware local search to enhance convergence.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "83410bc6-a534-470c-b14e-e6dd83f0107d", "metadata": {"aucs": [0.7872662782232155, 0.7614452136338328, 0.7805064778725795, 0.777033032966406, 0.7942952704767343, 0.7865536967590909, 0.8098531367378005, 0.7856280244862203, 0.7746465622920444, 0.6173062827372708, 0.6159208546969014, 0.6118065550376617, 0.610497869807928, 0.6069507224223654, 0.6034317931000741, 0.6241996506983545, 0.6170956151703697, 0.6174962310319495, 0.16875690858881387, 0.16978754038424881, 0.1442986428188553, 0.1956904658831139, 0.23934467282060357, 0.14588586324563801, 0.14950077905265224, 0.33743626613019495, 0.20866212052994104, 0.1205345146103225, 0.13926576880289632, 0.13822167064067303, 0.12942694041542158, 0.1281983309324407, 0.14186107340297216, 0.12073543636727302, 0.14097352769367666, 0.1554506259033167, 0.8885709347273463, 0.8557578777417613, 0.9009513152894469, 0.9239845432386716, 0.895995087726823, 0.8634551789802956, 0.8625595759926562, 0.8594465255658232, 0.8620186052938734, 0.38589748153512726, 0.3873452064021907, 0.3563102830622802, 0.35491754368707584, 0.39219265884828114, 0.3637561149951083, 0.38100935279155457, 0.38921214406864924, 0.4029378062653397, 0.7305625534696606, 0.715620622963973, 0.7121897951309525, 0.708937962576391, 0.706590932208257, 0.6833759278034606, 0.6821359026364014, 0.7526333491896928, 0.709335533790602, 0.15333130488525437, 0.19821390933768512, 0.2050821843868884, 0.178335706145052, 0.17425783224728764, 0.22810148600640023, 0.25213456430302517, 0.1703460256871676, 0.21603779778543863, 0.17957295970712361, 0.2005863393737526, 0.2039759327499383, 0.13779337617090937, 0.20957779579711844, 0.24460308218446003, 0.17442114274148257, 0.15058318170012863, 0.16779673728798827, 0.19753565320136302, 0.21278533973706626, 0.25632945816341113, 0.31029821513792855, 0.13126327270759752, 0.13127073117409216, 0.2741835540001334, 0.34491092014935554, 0.16756508718766105, 0.4131768851962542, 0.4529658992378788, 0.4682477710614157, 0.36897785454709897, 0.39177971739930306, 0.3228091757761715, 0.540555556317911, 0.4798360018515757, 0.5132692806622567, 0.21349717654360545, 0.18627544276040053, 0.10537804847317944, 0.10248107734226519, 0.08382704655689344, 0.16673730970541, 0.17088987205881734, 0.10503827924756515, 0.13025257498049736, 0.2802295989555189, 0.2502820025029229, 0.2952413968755899, 0.2843705315813757, 0.25826269247562395, 0.2953775739742128, 0.2068419131747965, 0.24364418189670078, 0.15364961010201172, 0.6234457881631293, 0.6757471858704971, 0.6697391248468605, 0.5598079929206922, 0.6468507529878808, 0.6210684912371793, 0.6541046172748212, 0.6574734058073645, 0.6544831731966804, 0.11214768830756472, 0.123770535107383, 0.10990337876385414, 0.13739989145727882, 0.10272696810840476, 0.11896651905999045, 0.1100777997466863, 0.11136484729193419, 0.11720455865846491, 0.14443669858596553, 0.13297059698897318, 0.15329234741332642, 0.1810857227812891, 0.15584535659462473, 0.16806858876923347, 0.16384072885974033, 0.150753619246643, 0.17002329764990776, 0.3365824376788801, 0.36436044022032876, 0.4104239063989046, 0.36215850192391585, 0.36421992922970425, 0.37303284273089987, 0.39924272013251816, 0.39314187005289836, 0.40618145272894224, 0.2707517404895986, 0.29272182703415117, 0.2661664061847069, 0.2296602375001151, 0.2599685029177323, 0.25961735896361593, 0.31498231188969517, 0.327918527562292, 0.29280533201149683, 0.19260917387268517, 0.20756482917217756, 0.2099354834511905, 0.2026292954841431, 0.20862431326342656, 0.20247704004750744, 0.19889994082729834, 0.2168113481318571, 0.20253774307206118, 0.20450464870004303, 0.29181604529886296, 0.30550664392179927, 0.3056238938991297, 0.19497987301266495, 0.3057053032662481, 0.22765414631551995, 0.23754106366737116, 0.22511200763545813, 0.1925327674506584, 0.1996832657592651, 0.6869780383363059, 0.7215116438504618, 0.6772259604728927, 0.668224009631798, 0.16413228643574818, 0.184445153194567, 0.7313492760663372, 0.7317720441945056, 0.37655084090037194, 0.7630697540838438, 0.20190460989907255, 0.46282205545503086, 0.20185285987223356, 0.3954905909491063, 0.41802559519045857, 0.5349356912404313, 0.18181462808842552, 0.17698850608240568, 0.1744551108698582, 0.1916838351599982, 0.18285804479241197, 0.1829210899117325, 0.17476985283739865, 0.19304538675642946, 0.1831957508963601, 0.0786915194645067, 0.09398478108659825, 0.08056903295384577, 0.08346098101949173, 0.07644857909885328, 0.10932811423938893, 0.07733468714068781, 0.0830517648003366, 0.08412568434693968]}, "mutation_prompt": null}
{"id": "eedfb608-39f0-4263-af48-42c0e56d23c7", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        # Self-adaptive mutation factor\n        self.F = 0.1 + 0.9 * np.random.rand()\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant, rank):\n        # Rank-based adaptive crossover rate\n        self.CR = 0.5 + 0.5 * (rank / self.population_size)\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0, momentum=np.zeros((1,))):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        momentum = 0.7 * momentum + step_size * direction  # Adjusted momentum\n        new_individual = np.clip(individual + momentum, self.lower_bound, self.upper_bound)\n        return new_individual, momentum\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n        momentum = np.zeros((self.population_size, self.dim))\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                rank = np.argsort(fitness).tolist().index(i)  # Get rank of the individual\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant, rank)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    # Introduce neighborhood-aware local search\n                    neighbors = np.random.choice(self.population_size, 5, replace=False)\n                    best_neighbor = min(neighbors, key=lambda idx: fitness[idx])\n                    direction = population[best_neighbor] - population[i]\n                    local_candidate = np.clip(population[i] + 0.1 * direction, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduce a self-adaptive strategy for mutation factor F and integrate a neighborhood-aware local search to enhance convergence.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "83410bc6-a534-470c-b14e-e6dd83f0107d", "metadata": {"aucs": [0.7872662782232155, 0.7614452136338328, 0.7805064778725795, 0.777033032966406, 0.7942952704767343, 0.7865536967590909, 0.8098531367378005, 0.7856280244862203, 0.7746465622920444, 0.6173062827372708, 0.6159208546969014, 0.6118065550376617, 0.610497869807928, 0.6069507224223654, 0.6034317931000741, 0.6241996506983545, 0.6170956151703697, 0.6174962310319495, 0.16875690858881387, 0.16978754038424881, 0.1442986428188553, 0.1956904658831139, 0.23934467282060357, 0.14588586324563801, 0.14950077905265224, 0.33743626613019495, 0.20866212052994104, 0.1205345146103225, 0.13926576880289632, 0.13822167064067303, 0.12942694041542158, 0.1281983309324407, 0.14186107340297216, 0.12073543636727302, 0.14097352769367666, 0.1554506259033167, 0.8885709347273463, 0.8557578777417613, 0.9009513152894469, 0.9239845432386716, 0.895995087726823, 0.8634551789802956, 0.8625595759926562, 0.8594465255658232, 0.8620186052938734, 0.38589748153512726, 0.3873452064021907, 0.3563102830622802, 0.35491754368707584, 0.39219265884828114, 0.3637561149951083, 0.38100935279155457, 0.38921214406864924, 0.4029378062653397, 0.7305625534696606, 0.715620622963973, 0.7121897951309525, 0.708937962576391, 0.706590932208257, 0.6833759278034606, 0.6821359026364014, 0.7526333491896928, 0.709335533790602, 0.15333130488525437, 0.19821390933768512, 0.2050821843868884, 0.178335706145052, 0.17425783224728764, 0.22810148600640023, 0.25213456430302517, 0.1703460256871676, 0.21603779778543863, 0.17957295970712361, 0.2005863393737526, 0.2039759327499383, 0.13779337617090937, 0.20957779579711844, 0.24460308218446003, 0.17442114274148257, 0.15058318170012863, 0.16779673728798827, 0.19753565320136302, 0.21278533973706626, 0.25632945816341113, 0.31029821513792855, 0.13126327270759752, 0.13127073117409216, 0.2741835540001334, 0.34491092014935554, 0.16756508718766105, 0.4131768851962542, 0.4529658992378788, 0.4682477710614157, 0.36897785454709897, 0.39177971739930306, 0.3228091757761715, 0.540555556317911, 0.4798360018515757, 0.5132692806622567, 0.21349717654360545, 0.18627544276040053, 0.10537804847317944, 0.10248107734226519, 0.08382704655689344, 0.16673730970541, 0.17088987205881734, 0.10503827924756515, 0.13025257498049736, 0.2802295989555189, 0.2502820025029229, 0.2952413968755899, 0.2843705315813757, 0.25826269247562395, 0.2953775739742128, 0.2068419131747965, 0.24364418189670078, 0.15364961010201172, 0.6234457881631293, 0.6757471858704971, 0.6697391248468605, 0.5598079929206922, 0.6468507529878808, 0.6210684912371793, 0.6541046172748212, 0.6574734058073645, 0.6544831731966804, 0.11214768830756472, 0.123770535107383, 0.10990337876385414, 0.13739989145727882, 0.10272696810840476, 0.11896651905999045, 0.1100777997466863, 0.11136484729193419, 0.11720455865846491, 0.14443669858596553, 0.13297059698897318, 0.15329234741332642, 0.1810857227812891, 0.15584535659462473, 0.16806858876923347, 0.16384072885974033, 0.150753619246643, 0.17002329764990776, 0.3365824376788801, 0.36436044022032876, 0.4104239063989046, 0.36215850192391585, 0.36421992922970425, 0.37303284273089987, 0.39924272013251816, 0.39314187005289836, 0.40618145272894224, 0.2707517404895986, 0.29272182703415117, 0.2661664061847069, 0.2296602375001151, 0.2599685029177323, 0.25961735896361593, 0.31498231188969517, 0.327918527562292, 0.29280533201149683, 0.19260917387268517, 0.20756482917217756, 0.2099354834511905, 0.2026292954841431, 0.20862431326342656, 0.20247704004750744, 0.19889994082729834, 0.2168113481318571, 0.20253774307206118, 0.20450464870004303, 0.29181604529886296, 0.30550664392179927, 0.3056238938991297, 0.19497987301266495, 0.3057053032662481, 0.22765414631551995, 0.23754106366737116, 0.22511200763545813, 0.1925327674506584, 0.1996832657592651, 0.6869780383363059, 0.7215116438504618, 0.6772259604728927, 0.668224009631798, 0.16413228643574818, 0.184445153194567, 0.7313492760663372, 0.7317720441945056, 0.37655084090037194, 0.7630697540838438, 0.20190460989907255, 0.46282205545503086, 0.20185285987223356, 0.3954905909491063, 0.41802559519045857, 0.5349356912404313, 0.18181462808842552, 0.17698850608240568, 0.1744551108698582, 0.1916838351599982, 0.18285804479241197, 0.1829210899117325, 0.17476985283739865, 0.19304538675642946, 0.1831957508963601, 0.0786915194645067, 0.09398478108659825, 0.08056903295384577, 0.08346098101949173, 0.07644857909885328, 0.10932811423938893, 0.07733468714068781, 0.0830517648003366, 0.08412568434693968]}, "mutation_prompt": null}
{"id": "77be9ef0-56c9-453f-90a7-ca4bc1089557", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        self.F = 0.1 + 0.9 * np.random.rand()\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant, rank):\n        self.CR = 0.5 + 0.5 * (rank / self.population_size)\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0, momentum=np.zeros((1,))):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        momentum = 0.7 * momentum + step_size * direction\n        new_individual = np.clip(individual + momentum, self.lower_bound, self.upper_bound)\n        return new_individual, momentum\n\n    def _adaptive_population_scaling(self, fitness):\n        diversity = np.std(fitness)\n        factor = 1 + (diversity / max(1, np.mean(fitness)))\n        self.population_size = int(min(self.population_size * factor, 12 * self.dim))\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n        momentum = np.zeros((self.population_size, self.dim))\n\n        while evals < self.budget:\n            self._adaptive_population_scaling(fitness)\n            for i in range(self.population_size):\n                rank = np.argsort(fitness).tolist().index(i)\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant, rank)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    neighbors = np.random.choice(self.population_size, 5, replace=False)\n                    best_neighbor = min(neighbors, key=lambda idx: fitness[idx])\n                    direction = population[best_neighbor] - population[i]\n                    local_candidate = np.clip(population[i] + 0.1 * direction, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "Implement adaptive population scaling based on fitness diversity to enhance exploration and exploitation balance.", "configspace": "", "generation": 96, "fitness": 0.348383129168905, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.24.", "error": "", "parent_id": "83410bc6-a534-470c-b14e-e6dd83f0107d", "metadata": {"aucs": [0.7872662782232155, 0.7614452136338328, 0.7805064778725795, 0.777033032966406, 0.7942952704767343, 0.7865536967590909, 0.8098531367378005, 0.7856280244862203, 0.7746465622920444, 0.6173062827372708, 0.6159208546969014, 0.6118065550376617, 0.610497869807928, 0.6069507224223654, 0.6034317931000741, 0.6241996506983545, 0.6170956151703697, 0.6174962310319495, 0.16875690858881387, 0.16978754038424881, 0.1442986428188553, 0.1956904658831139, 0.23934467282060357, 0.14588586324563801, 0.14950077905265224, 0.33743626613019495, 0.20866212052994104, 0.1205345146103225, 0.13926576880289632, 0.13822167064067303, 0.12942694041542158, 0.1281983309324407, 0.14186107340297216, 0.12073543636727302, 0.14097352769367666, 0.1554506259033167, 0.8885709347273463, 0.8557578777417613, 0.9009513152894469, 0.9239845432386716, 0.895995087726823, 0.8634551789802956, 0.8625595759926562, 0.8594465255658232, 0.8620186052938734, 0.38589748153512726, 0.3873452064021907, 0.3563102830622802, 0.35491754368707584, 0.39219265884828114, 0.3637561149951083, 0.38100935279155457, 0.38921214406864924, 0.4029378062653397, 0.7305625534696606, 0.715620622963973, 0.7121897951309525, 0.708937962576391, 0.706590932208257, 0.6833759278034606, 0.6821359026364014, 0.7526333491896928, 0.709335533790602, 0.15333130488525437, 0.19821390933768512, 0.2050821843868884, 0.178335706145052, 0.17425783224728764, 0.22810148600640023, 0.25213456430302517, 0.1703460256871676, 0.21603779778543863, 0.17957295970712361, 0.2005863393737526, 0.2039759327499383, 0.13779337617090937, 0.20957779579711844, 0.24460308218446003, 0.17442114274148257, 0.15058318170012863, 0.16779673728798827, 0.19753565320136302, 0.21278533973706626, 0.25632945816341113, 0.31029821513792855, 0.13126327270759752, 0.13127073117409216, 0.2741835540001334, 0.34491092014935554, 0.16756508718766105, 0.4131768851962542, 0.4529658992378788, 0.4682477710614157, 0.36897785454709897, 0.39177971739930306, 0.3228091757761715, 0.540555556317911, 0.4798360018515757, 0.5132692806622567, 0.21349717654360545, 0.18627544276040053, 0.10537804847317944, 0.10248107734226519, 0.08382704655689344, 0.16673730970541, 0.17088987205881734, 0.10503827924756515, 0.13025257498049736, 0.2802295989555189, 0.2502820025029229, 0.2952413968755899, 0.2843705315813757, 0.25826269247562395, 0.2953775739742128, 0.2068419131747965, 0.24364418189670078, 0.15364961010201172, 0.6234457881631293, 0.6757471858704971, 0.6697391248468605, 0.5598079929206922, 0.6468507529878808, 0.6210684912371793, 0.6541046172748212, 0.6574734058073645, 0.6544831731966804, 0.11214768830756472, 0.123770535107383, 0.10990337876385414, 0.13739989145727882, 0.10272696810840476, 0.11896651905999045, 0.1100777997466863, 0.11136484729193419, 0.11720455865846491, 0.14443669858596553, 0.13297059698897318, 0.15329234741332642, 0.1810857227812891, 0.15584535659462473, 0.16806858876923347, 0.16384072885974033, 0.150753619246643, 0.17002329764990776, 0.3365824376788801, 0.36436044022032876, 0.4104239063989046, 0.36215850192391585, 0.36421992922970425, 0.37303284273089987, 0.39924272013251816, 0.39314187005289836, 0.40618145272894224, 0.2707517404895986, 0.29272182703415117, 0.2661664061847069, 0.2296602375001151, 0.2599685029177323, 0.25961735896361593, 0.31498231188969517, 0.327918527562292, 0.29280533201149683, 0.19260917387268517, 0.20756482917217756, 0.2099354834511905, 0.2026292954841431, 0.20862431326342656, 0.20247704004750744, 0.19889994082729834, 0.2168113481318571, 0.20253774307206118, 0.20450464870004303, 0.29181604529886296, 0.30550664392179927, 0.3056238938991297, 0.19497987301266495, 0.3057053032662481, 0.22765414631551995, 0.23754106366737116, 0.22511200763545813, 0.1925327674506584, 0.1996832657592651, 0.6869780383363059, 0.7215116438504618, 0.6772259604728927, 0.668224009631798, 0.16413228643574818, 0.184445153194567, 0.7313492760663372, 0.7317720441945056, 0.37655084090037194, 0.7630697540838438, 0.20190460989907255, 0.46282205545503086, 0.20185285987223356, 0.3954905909491063, 0.41802559519045857, 0.5349356912404313, 0.18181462808842552, 0.17698850608240568, 0.1744551108698582, 0.1916838351599982, 0.18285804479241197, 0.1829210899117325, 0.17476985283739865, 0.19304538675642946, 0.1831957508963601, 0.0786915194645067, 0.09398478108659825, 0.08056903295384577, 0.08346098101949173, 0.07644857909885328, 0.10932811423938893, 0.07733468714068781, 0.0830517648003366, 0.08412568434693968]}, "mutation_prompt": null}
{"id": "76ca0a7a-c38e-41e2-bb69-55e2a25394cc", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5\n        self.diversity_threshold = 0.1\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        self.F = 0.1 + 0.9 * np.random.rand()\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant, rank):\n        self.CR = 0.5 + 0.5 * (rank / self.population_size)\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0, momentum=np.zeros((1,))):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        momentum = 0.7 * momentum + step_size * direction\n        new_individual = np.clip(individual + momentum, self.lower_bound, self.upper_bound)\n        return new_individual, momentum\n\n    def _adaptive_scaling(self, diversity):\n        return 0.1 + 0.9 * (1 - diversity / self.diversity_threshold)\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n        momentum = np.zeros((self.population_size, self.dim))\n\n        while evals < self.budget:\n            diversity = np.std(population, axis=0).mean()\n            if diversity < self.diversity_threshold:\n                self.population_size = max(4, int(self.population_size * 0.9))\n                population = population[:self.population_size]\n                fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                rank = np.argsort(fitness).tolist().index(i)\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant, rank)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = self._adaptive_scaling(diversity)\n                    neighbors = np.random.choice(self.population_size, 5, replace=False)\n                    best_neighbor = min(neighbors, key=lambda idx: fitness[idx])\n                    direction = population[best_neighbor] - population[i]\n                    local_candidate = np.clip(population[i] + 0.1 * direction, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhance convergence through adaptive scaling in local search and introduce adaptive population resizing based on diversity.", "configspace": "", "generation": 97, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "83410bc6-a534-470c-b14e-e6dd83f0107d", "metadata": {}, "mutation_prompt": null}
{"id": "f4438ccc-c18e-455a-80ca-7e7ed48edd63", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        # Self-adaptive mutation factor\n        self.F = 0.1 + 0.9 * np.random.rand()\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant, rank):\n        # Rank-based adaptive crossover rate\n        self.CR = 0.5 + 0.5 * (rank / self.population_size)\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0, momentum=np.zeros((1,))):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        momentum = 0.7 * momentum + step_size * direction  # Adjusted momentum\n        new_individual = np.clip(individual + momentum, self.lower_bound, self.upper_bound)\n        return new_individual, momentum\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n        momentum = np.zeros((self.population_size, self.dim))\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                rank = np.argsort(fitness).tolist().index(i)  # Get rank of the individual\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant, rank)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    # Introduce neighborhood-aware local search\n                    neighbors = np.random.choice(self.population_size, 5, replace=False)\n                    best_neighbor = min(neighbors, key=lambda idx: fitness[idx])\n                    direction = population[best_neighbor] - population[i]\n                    local_candidate = np.clip(population[i] + 0.1 * direction, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduce a self-adaptive strategy for mutation factor F and integrate a neighborhood-aware local search to enhance convergence.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "83410bc6-a534-470c-b14e-e6dd83f0107d", "metadata": {"aucs": [0.7872662782232155, 0.7614452136338328, 0.7805064778725795, 0.777033032966406, 0.7942952704767343, 0.7865536967590909, 0.8098531367378005, 0.7856280244862203, 0.7746465622920444, 0.6173062827372708, 0.6159208546969014, 0.6118065550376617, 0.610497869807928, 0.6069507224223654, 0.6034317931000741, 0.6241996506983545, 0.6170956151703697, 0.6174962310319495, 0.16875690858881387, 0.16978754038424881, 0.1442986428188553, 0.1956904658831139, 0.23934467282060357, 0.14588586324563801, 0.14950077905265224, 0.33743626613019495, 0.20866212052994104, 0.1205345146103225, 0.13926576880289632, 0.13822167064067303, 0.12942694041542158, 0.1281983309324407, 0.14186107340297216, 0.12073543636727302, 0.14097352769367666, 0.1554506259033167, 0.8885709347273463, 0.8557578777417613, 0.9009513152894469, 0.9239845432386716, 0.895995087726823, 0.8634551789802956, 0.8625595759926562, 0.8594465255658232, 0.8620186052938734, 0.38589748153512726, 0.3873452064021907, 0.3563102830622802, 0.35491754368707584, 0.39219265884828114, 0.3637561149951083, 0.38100935279155457, 0.38921214406864924, 0.4029378062653397, 0.7305625534696606, 0.715620622963973, 0.7121897951309525, 0.708937962576391, 0.706590932208257, 0.6833759278034606, 0.6821359026364014, 0.7526333491896928, 0.709335533790602, 0.15333130488525437, 0.19821390933768512, 0.2050821843868884, 0.178335706145052, 0.17425783224728764, 0.22810148600640023, 0.25213456430302517, 0.1703460256871676, 0.21603779778543863, 0.17957295970712361, 0.2005863393737526, 0.2039759327499383, 0.13779337617090937, 0.20957779579711844, 0.24460308218446003, 0.17442114274148257, 0.15058318170012863, 0.16779673728798827, 0.19753565320136302, 0.21278533973706626, 0.25632945816341113, 0.31029821513792855, 0.13126327270759752, 0.13127073117409216, 0.2741835540001334, 0.34491092014935554, 0.16756508718766105, 0.4131768851962542, 0.4529658992378788, 0.4682477710614157, 0.36897785454709897, 0.39177971739930306, 0.3228091757761715, 0.540555556317911, 0.4798360018515757, 0.5132692806622567, 0.21349717654360545, 0.18627544276040053, 0.10537804847317944, 0.10248107734226519, 0.08382704655689344, 0.16673730970541, 0.17088987205881734, 0.10503827924756515, 0.13025257498049736, 0.2802295989555189, 0.2502820025029229, 0.2952413968755899, 0.2843705315813757, 0.25826269247562395, 0.2953775739742128, 0.2068419131747965, 0.24364418189670078, 0.15364961010201172, 0.6234457881631293, 0.6757471858704971, 0.6697391248468605, 0.5598079929206922, 0.6468507529878808, 0.6210684912371793, 0.6541046172748212, 0.6574734058073645, 0.6544831731966804, 0.11214768830756472, 0.123770535107383, 0.10990337876385414, 0.13739989145727882, 0.10272696810840476, 0.11896651905999045, 0.1100777997466863, 0.11136484729193419, 0.11720455865846491, 0.14443669858596553, 0.13297059698897318, 0.15329234741332642, 0.1810857227812891, 0.15584535659462473, 0.16806858876923347, 0.16384072885974033, 0.150753619246643, 0.17002329764990776, 0.3365824376788801, 0.36436044022032876, 0.4104239063989046, 0.36215850192391585, 0.36421992922970425, 0.37303284273089987, 0.39924272013251816, 0.39314187005289836, 0.40618145272894224, 0.2707517404895986, 0.29272182703415117, 0.2661664061847069, 0.2296602375001151, 0.2599685029177323, 0.25961735896361593, 0.31498231188969517, 0.327918527562292, 0.29280533201149683, 0.19260917387268517, 0.20756482917217756, 0.2099354834511905, 0.2026292954841431, 0.20862431326342656, 0.20247704004750744, 0.19889994082729834, 0.2168113481318571, 0.20253774307206118, 0.20450464870004303, 0.29181604529886296, 0.30550664392179927, 0.3056238938991297, 0.19497987301266495, 0.3057053032662481, 0.22765414631551995, 0.23754106366737116, 0.22511200763545813, 0.1925327674506584, 0.1996832657592651, 0.6869780383363059, 0.7215116438504618, 0.6772259604728927, 0.668224009631798, 0.16413228643574818, 0.184445153194567, 0.7313492760663372, 0.7317720441945056, 0.37655084090037194, 0.7630697540838438, 0.20190460989907255, 0.46282205545503086, 0.20185285987223356, 0.3954905909491063, 0.41802559519045857, 0.5349356912404313, 0.18181462808842552, 0.17698850608240568, 0.1744551108698582, 0.1916838351599982, 0.18285804479241197, 0.1829210899117325, 0.17476985283739865, 0.19304538675642946, 0.1831957508963601, 0.0786915194645067, 0.09398478108659825, 0.08056903295384577, 0.08346098101949173, 0.07644857909885328, 0.10932811423938893, 0.07733468714068781, 0.0830517648003366, 0.08412568434693968]}, "mutation_prompt": null}
{"id": "3eef6875-9881-4b1e-94c5-cf8c8326d1b9", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 12 * dim\n        self.population_size = self.initial_population_size\n        self.CR = 0.85\n        self.local_search_prob = 0.4\n        self.adaptive_alpha = 0.5\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n\n    def _mutate(self, pop, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = pop[np.random.choice(indices, 3, replace=False)]\n        self.F = 0.1 + 0.9 * np.random.rand()\n        mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant, rank):\n        self.CR = 0.5 + 0.5 * (rank / self.population_size)\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, scale=1.0, momentum=np.zeros((1,))):\n        direction = np.random.normal(0, 1, self.dim)\n        step_size = np.random.uniform(0.05, 0.15) * scale\n        momentum = 0.7 * momentum + step_size * direction\n        new_individual = np.clip(individual + momentum, self.lower_bound, self.upper_bound)\n        return new_individual, momentum\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.initial_population_size\n        momentum = np.zeros((self.initial_population_size, self.dim))\n        generation = 0\n\n        while evals < self.budget:\n            generation += 1\n            self.population_size = max(4, int(self.initial_population_size - generation * 0.1 * self.initial_population_size))\n            \n            for i in range(self.population_size):\n                rank = np.argsort(fitness).tolist().index(i)\n                mutant = self._mutate(population, i)\n                trial = self._crossover(population[i], mutant, rank)\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n                if np.random.rand() < self.local_search_prob:\n                    scale_factor = 1 - (evals / self.budget)\n                    neighbors = np.random.choice(self.population_size, 5, replace=False)\n                    best_neighbor = min(neighbors, key=lambda idx: fitness[idx])\n                    direction = population[best_neighbor] - population[i]\n                    local_candidate = np.clip(population[i] + 0.1 * direction, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_candidate)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_candidate\n                        fitness[i] = local_fitness\n\n                if evals >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDifferentialEvolution", "description": "Integrate an adaptive population size strategy and dynamic local search scaling to improve exploration and convergence balance.", "configspace": "", "generation": 99, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "83410bc6-a534-470c-b14e-e6dd83f0107d", "metadata": {}, "mutation_prompt": null}
