{"id": "347e35b6-8fc5-4c15-80f6-7e2737bf945b", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = 0.8\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.7\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = 0.1\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 20\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(pop_size):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n                \n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Adaptive Scatter Search with Differential Mutation and Local Search Refinement for global optimization.", "configspace": "", "generation": 0, "fitness": 0.22177403550670946, "feedback": "The algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.20.", "error": "", "parent_id": null, "metadata": {"aucs": [0.6310222650601017, 0.6568254736125017, 0.6360526896268321, 0.6099837442465876, 0.6089767738702982, 0.6844568945865264, 0.6512124580258505, 0.5928944070903819, 0.6192994183019285, 0.35075137499786846, 0.36551233019479845, 0.3648931443613166, 0.34982376943755145, 0.3911119252381421, 0.36145883316002725, 0.312832331670458, 0.36839856477557276, 0.38286791712255486, 0.1438812864521225, 0.11849344531690453, 0.11157014182662939, 0.13249087159982986, 0.0989497920064738, 0.17665602568935534, 0.11779611290048453, 0.09504314670779657, 0.10140143790173861, 0.10561996836469134, 0.09152887557593858, 0.11274909969687563, 0.10832335026964213, 0.10862158298971192, 0.10421642497128303, 0.11043397367447161, 0.10586223347083246, 0.10199025748484347, 0.9306125869034108, 0.9274917208665487, 0.9155825346828464, 0.9321077279609241, 0.9284565408665312, 0.9013374981768034, 0.9803993278199885, 0.9078310364116894, 0.9141803725341682, 0.2369056219203256, 0.23120102155163125, 0.20012614979205134, 0.25404658236259237, 0.23460915770545876, 0.21898233152913293, 0.23137703307704982, 0.2404454334018471, 0.261172552692834, 0.36763781185481503, 0.2457095199483027, 0.3627001311903294, 0.25509622540093935, 0.26220497584185465, 0.27299165704949613, 0.24800227927826868, 0.25852040037343227, 0.2365200561737575, 0.13447649243322157, 0.11921299038568234, 0.14820122317628026, 0.1473358499473265, 0.13314823033526169, 0.16547651771721084, 0.15481529582187903, 0.13643602081712103, 0.1366724299297053, 0.14517934632994933, 0.0958077698508365, 0.10104023063306544, 0.12851530274001488, 0.12529458248930003, 0.16557365363606136, 0.12610655639207669, 0.11861835772772189, 0.17206011937317123, 9.999999999998899e-05, 0.001503608134376777, 0.005259855175402173, 0.010524457059965742, 0.0033679409070130895, 0.003858287981000852, 0.0014431657026522382, 0.0013670418907210102, 0.014350664119264778, 0.09284804004613345, 0.08725318738501842, 0.1217343286249496, 0.0839111446685421, 0.10366799036589613, 0.08007558264245729, 0.1277210936081007, 0.10585344569002297, 0.1053308403796509, 9.999999999998899e-05, 9.999999999998899e-05, 0.0006065531507590816, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003392162103688645, 0.00016173510615369313, 9.999999999998899e-05, 0.10482334996068654, 0.08102717201692722, 0.08102851163878766, 0.08503290938580432, 0.09099281035669682, 0.09522770574453077, 0.09070934306563017, 0.07453555120107391, 0.0817124311222549, 0.415538927153408, 0.432753802246044, 0.40933538497529354, 0.42605791552506045, 0.42081859249822795, 0.43615781751925564, 0.39286981786956365, 0.42726863821739147, 0.43065214931069995, 0.08236726104384418, 0.10187820747995124, 0.08085635477161268, 0.07562437528222621, 0.07659327471999533, 0.07363029787243791, 0.09070522210092535, 0.07530455818151327, 0.083634827397841, 0.17072797304576415, 0.15495691969737946, 0.14893429348402965, 0.11587608695088092, 0.11887299719984001, 0.14865524769294303, 0.1527482467255038, 0.16376735347164717, 0.1210302753148711, 0.28102618300798754, 0.23108626635297835, 0.22570785304058283, 0.24652083753944254, 0.21620259603570025, 0.20435648873214918, 0.27307284303472623, 0.2782099764656686, 0.28101640748723145, 0.1829985573587385, 0.186174722928648, 0.1623853998011915, 0.1573858798747071, 0.17604366523137793, 0.19266622993058913, 0.191654866539393, 0.17870178243463086, 0.2052544187506503, 0.172172676606286, 0.17538173189111006, 0.21064542562512711, 0.18255745776129007, 0.1716751489108871, 0.16993030936196574, 0.18667638134617692, 0.16365518493645026, 0.20846334274165046, 0.16507783040254254, 0.17943576014114804, 0.20209871132834512, 0.1686611404796282, 0.19388709001229065, 0.18357975784257485, 0.16369369755352414, 0.16679043968294427, 0.1850858941440905, 0.2988685902204101, 0.44406367382238054, 0.16730407940077052, 0.39479865487799115, 0.16457672993139383, 0.2489428252995921, 0.22975341740526267, 0.19175631308602004, 0.36993815827805576, 0.14493509968552587, 0.18506986990688323, 0.14481535974856075, 0.1786920430370419, 0.1475883538215127, 0.2757042277369832, 0.1948064534509485, 0.42307558864302564, 0.360557908640465, 0.17407256303596974, 0.19029436205821615, 0.17343889512070854, 0.16687602648572408, 0.18504565484852598, 0.17602625214136647, 0.18083473035712305, 0.1805234621646965, 0.17237121914314435, 0.07614635767772726, 0.06529733570544771, 0.07947994941171277, 0.07581598144477153, 0.07074510178176063, 0.07374860357152191, 0.06784729369368048, 0.08076713339865016, 0.06682111873709595]}, "mutation_prompt": null}
{"id": "da674775-04f3-4716-b8aa-b4095e5ae153", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = 0.8\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.7\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = 0.1\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 20\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(pop_size):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n                \n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Adaptive Scatter Search with Differential Mutation and Local Search Refinement for global optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "347e35b6-8fc5-4c15-80f6-7e2737bf945b", "metadata": {"aucs": [0.6310222650601017, 0.6568254736125017, 0.6360526896268321, 0.6099837442465876, 0.6089767738702982, 0.6844568945865264, 0.6512124580258505, 0.5928944070903819, 0.6192994183019285, 0.35075137499786846, 0.36551233019479845, 0.3648931443613166, 0.34982376943755145, 0.3911119252381421, 0.36145883316002725, 0.312832331670458, 0.36839856477557276, 0.38286791712255486, 0.1438812864521225, 0.11849344531690453, 0.11157014182662939, 0.13249087159982986, 0.0989497920064738, 0.17665602568935534, 0.11779611290048453, 0.09504314670779657, 0.10140143790173861, 0.10561996836469134, 0.09152887557593858, 0.11274909969687563, 0.10832335026964213, 0.10862158298971192, 0.10421642497128303, 0.11043397367447161, 0.10586223347083246, 0.10199025748484347, 0.9306125869034108, 0.9274917208665487, 0.9155825346828464, 0.9321077279609241, 0.9284565408665312, 0.9013374981768034, 0.9803993278199885, 0.9078310364116894, 0.9141803725341682, 0.2369056219203256, 0.23120102155163125, 0.20012614979205134, 0.25404658236259237, 0.23460915770545876, 0.21898233152913293, 0.23137703307704982, 0.2404454334018471, 0.261172552692834, 0.36763781185481503, 0.2457095199483027, 0.3627001311903294, 0.25509622540093935, 0.26220497584185465, 0.27299165704949613, 0.24800227927826868, 0.25852040037343227, 0.2365200561737575, 0.13447649243322157, 0.11921299038568234, 0.14820122317628026, 0.1473358499473265, 0.13314823033526169, 0.16547651771721084, 0.15481529582187903, 0.13643602081712103, 0.1366724299297053, 0.14517934632994933, 0.0958077698508365, 0.10104023063306544, 0.12851530274001488, 0.12529458248930003, 0.16557365363606136, 0.12610655639207669, 0.11861835772772189, 0.17206011937317123, 9.999999999998899e-05, 0.001503608134376777, 0.005259855175402173, 0.010524457059965742, 0.0033679409070130895, 0.003858287981000852, 0.0014431657026522382, 0.0013670418907210102, 0.014350664119264778, 0.09284804004613345, 0.08725318738501842, 0.1217343286249496, 0.0839111446685421, 0.10366799036589613, 0.08007558264245729, 0.1277210936081007, 0.10585344569002297, 0.1053308403796509, 9.999999999998899e-05, 9.999999999998899e-05, 0.0006065531507590816, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003392162103688645, 0.00016173510615369313, 9.999999999998899e-05, 0.10482334996068654, 0.08102717201692722, 0.08102851163878766, 0.08503290938580432, 0.09099281035669682, 0.09522770574453077, 0.09070934306563017, 0.07453555120107391, 0.0817124311222549, 0.415538927153408, 0.432753802246044, 0.40933538497529354, 0.42605791552506045, 0.42081859249822795, 0.43615781751925564, 0.39286981786956365, 0.42726863821739147, 0.43065214931069995, 0.08236726104384418, 0.10187820747995124, 0.08085635477161268, 0.07562437528222621, 0.07659327471999533, 0.07363029787243791, 0.09070522210092535, 0.07530455818151327, 0.083634827397841, 0.17072797304576415, 0.15495691969737946, 0.14893429348402965, 0.11587608695088092, 0.11887299719984001, 0.14865524769294303, 0.1527482467255038, 0.16376735347164717, 0.1210302753148711, 0.28102618300798754, 0.23108626635297835, 0.22570785304058283, 0.24652083753944254, 0.21620259603570025, 0.20435648873214918, 0.27307284303472623, 0.2782099764656686, 0.28101640748723145, 0.1829985573587385, 0.186174722928648, 0.1623853998011915, 0.1573858798747071, 0.17604366523137793, 0.19266622993058913, 0.191654866539393, 0.17870178243463086, 0.2052544187506503, 0.172172676606286, 0.17538173189111006, 0.21064542562512711, 0.18255745776129007, 0.1716751489108871, 0.16993030936196574, 0.18667638134617692, 0.16365518493645026, 0.20846334274165046, 0.16507783040254254, 0.17943576014114804, 0.20209871132834512, 0.1686611404796282, 0.19388709001229065, 0.18357975784257485, 0.16369369755352414, 0.16679043968294427, 0.1850858941440905, 0.2988685902204101, 0.44406367382238054, 0.16730407940077052, 0.39479865487799115, 0.16457672993139383, 0.2489428252995921, 0.22975341740526267, 0.19175631308602004, 0.36993815827805576, 0.14493509968552587, 0.18506986990688323, 0.14481535974856075, 0.1786920430370419, 0.1475883538215127, 0.2757042277369832, 0.1948064534509485, 0.42307558864302564, 0.360557908640465, 0.17407256303596974, 0.19029436205821615, 0.17343889512070854, 0.16687602648572408, 0.18504565484852598, 0.17602625214136647, 0.18083473035712305, 0.1805234621646965, 0.17237121914314435, 0.07614635767772726, 0.06529733570544771, 0.07947994941171277, 0.07581598144477153, 0.07074510178176063, 0.07374860357152191, 0.06784729369368048, 0.08076713339865016, 0.06682111873709595]}, "mutation_prompt": null}
{"id": "40e78d2b-42d9-4ae5-8883-cc8cfeeca908", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = 0.8\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.7\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = 0.1\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 20\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(pop_size):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n                \n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Adaptive Scatter Search with Differential Mutation and Local Search Refinement for global optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "347e35b6-8fc5-4c15-80f6-7e2737bf945b", "metadata": {"aucs": [0.6310222650601017, 0.6568254736125017, 0.6360526896268321, 0.6099837442465876, 0.6089767738702982, 0.6844568945865264, 0.6512124580258505, 0.5928944070903819, 0.6192994183019285, 0.35075137499786846, 0.36551233019479845, 0.3648931443613166, 0.34982376943755145, 0.3911119252381421, 0.36145883316002725, 0.312832331670458, 0.36839856477557276, 0.38286791712255486, 0.1438812864521225, 0.11849344531690453, 0.11157014182662939, 0.13249087159982986, 0.0989497920064738, 0.17665602568935534, 0.11779611290048453, 0.09504314670779657, 0.10140143790173861, 0.10561996836469134, 0.09152887557593858, 0.11274909969687563, 0.10832335026964213, 0.10862158298971192, 0.10421642497128303, 0.11043397367447161, 0.10586223347083246, 0.10199025748484347, 0.9306125869034108, 0.9274917208665487, 0.9155825346828464, 0.9321077279609241, 0.9284565408665312, 0.9013374981768034, 0.9803993278199885, 0.9078310364116894, 0.9141803725341682, 0.2369056219203256, 0.23120102155163125, 0.20012614979205134, 0.25404658236259237, 0.23460915770545876, 0.21898233152913293, 0.23137703307704982, 0.2404454334018471, 0.261172552692834, 0.36763781185481503, 0.2457095199483027, 0.3627001311903294, 0.25509622540093935, 0.26220497584185465, 0.27299165704949613, 0.24800227927826868, 0.25852040037343227, 0.2365200561737575, 0.13447649243322157, 0.11921299038568234, 0.14820122317628026, 0.1473358499473265, 0.13314823033526169, 0.16547651771721084, 0.15481529582187903, 0.13643602081712103, 0.1366724299297053, 0.14517934632994933, 0.0958077698508365, 0.10104023063306544, 0.12851530274001488, 0.12529458248930003, 0.16557365363606136, 0.12610655639207669, 0.11861835772772189, 0.17206011937317123, 9.999999999998899e-05, 0.001503608134376777, 0.005259855175402173, 0.010524457059965742, 0.0033679409070130895, 0.003858287981000852, 0.0014431657026522382, 0.0013670418907210102, 0.014350664119264778, 0.09284804004613345, 0.08725318738501842, 0.1217343286249496, 0.0839111446685421, 0.10366799036589613, 0.08007558264245729, 0.1277210936081007, 0.10585344569002297, 0.1053308403796509, 9.999999999998899e-05, 9.999999999998899e-05, 0.0006065531507590816, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003392162103688645, 0.00016173510615369313, 9.999999999998899e-05, 0.10482334996068654, 0.08102717201692722, 0.08102851163878766, 0.08503290938580432, 0.09099281035669682, 0.09522770574453077, 0.09070934306563017, 0.07453555120107391, 0.0817124311222549, 0.415538927153408, 0.432753802246044, 0.40933538497529354, 0.42605791552506045, 0.42081859249822795, 0.43615781751925564, 0.39286981786956365, 0.42726863821739147, 0.43065214931069995, 0.08236726104384418, 0.10187820747995124, 0.08085635477161268, 0.07562437528222621, 0.07659327471999533, 0.07363029787243791, 0.09070522210092535, 0.07530455818151327, 0.083634827397841, 0.17072797304576415, 0.15495691969737946, 0.14893429348402965, 0.11587608695088092, 0.11887299719984001, 0.14865524769294303, 0.1527482467255038, 0.16376735347164717, 0.1210302753148711, 0.28102618300798754, 0.23108626635297835, 0.22570785304058283, 0.24652083753944254, 0.21620259603570025, 0.20435648873214918, 0.27307284303472623, 0.2782099764656686, 0.28101640748723145, 0.1829985573587385, 0.186174722928648, 0.1623853998011915, 0.1573858798747071, 0.17604366523137793, 0.19266622993058913, 0.191654866539393, 0.17870178243463086, 0.2052544187506503, 0.172172676606286, 0.17538173189111006, 0.21064542562512711, 0.18255745776129007, 0.1716751489108871, 0.16993030936196574, 0.18667638134617692, 0.16365518493645026, 0.20846334274165046, 0.16507783040254254, 0.17943576014114804, 0.20209871132834512, 0.1686611404796282, 0.19388709001229065, 0.18357975784257485, 0.16369369755352414, 0.16679043968294427, 0.1850858941440905, 0.2988685902204101, 0.44406367382238054, 0.16730407940077052, 0.39479865487799115, 0.16457672993139383, 0.2489428252995921, 0.22975341740526267, 0.19175631308602004, 0.36993815827805576, 0.14493509968552587, 0.18506986990688323, 0.14481535974856075, 0.1786920430370419, 0.1475883538215127, 0.2757042277369832, 0.1948064534509485, 0.42307558864302564, 0.360557908640465, 0.17407256303596974, 0.19029436205821615, 0.17343889512070854, 0.16687602648572408, 0.18504565484852598, 0.17602625214136647, 0.18083473035712305, 0.1805234621646965, 0.17237121914314435, 0.07614635767772726, 0.06529733570544771, 0.07947994941171277, 0.07581598144477153, 0.07074510178176063, 0.07374860357152191, 0.06784729369368048, 0.08076713339865016, 0.06682111873709595]}, "mutation_prompt": null}
{"id": "32cd7748-abb9-43b9-b814-e9a7bf80773f", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = 0.8\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.7\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = 0.1\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 20\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(pop_size):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n                \n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Adaptive Scatter Search with Differential Mutation and Local Search Refinement for global optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "347e35b6-8fc5-4c15-80f6-7e2737bf945b", "metadata": {"aucs": [0.6310222650601017, 0.6568254736125017, 0.6360526896268321, 0.6099837442465876, 0.6089767738702982, 0.6844568945865264, 0.6512124580258505, 0.5928944070903819, 0.6192994183019285, 0.35075137499786846, 0.36551233019479845, 0.3648931443613166, 0.34982376943755145, 0.3911119252381421, 0.36145883316002725, 0.312832331670458, 0.36839856477557276, 0.38286791712255486, 0.1438812864521225, 0.11849344531690453, 0.11157014182662939, 0.13249087159982986, 0.0989497920064738, 0.17665602568935534, 0.11779611290048453, 0.09504314670779657, 0.10140143790173861, 0.10561996836469134, 0.09152887557593858, 0.11274909969687563, 0.10832335026964213, 0.10862158298971192, 0.10421642497128303, 0.11043397367447161, 0.10586223347083246, 0.10199025748484347, 0.9306125869034108, 0.9274917208665487, 0.9155825346828464, 0.9321077279609241, 0.9284565408665312, 0.9013374981768034, 0.9803993278199885, 0.9078310364116894, 0.9141803725341682, 0.2369056219203256, 0.23120102155163125, 0.20012614979205134, 0.25404658236259237, 0.23460915770545876, 0.21898233152913293, 0.23137703307704982, 0.2404454334018471, 0.261172552692834, 0.36763781185481503, 0.2457095199483027, 0.3627001311903294, 0.25509622540093935, 0.26220497584185465, 0.27299165704949613, 0.24800227927826868, 0.25852040037343227, 0.2365200561737575, 0.13447649243322157, 0.11921299038568234, 0.14820122317628026, 0.1473358499473265, 0.13314823033526169, 0.16547651771721084, 0.15481529582187903, 0.13643602081712103, 0.1366724299297053, 0.14517934632994933, 0.0958077698508365, 0.10104023063306544, 0.12851530274001488, 0.12529458248930003, 0.16557365363606136, 0.12610655639207669, 0.11861835772772189, 0.17206011937317123, 9.999999999998899e-05, 0.001503608134376777, 0.005259855175402173, 0.010524457059965742, 0.0033679409070130895, 0.003858287981000852, 0.0014431657026522382, 0.0013670418907210102, 0.014350664119264778, 0.09284804004613345, 0.08725318738501842, 0.1217343286249496, 0.0839111446685421, 0.10366799036589613, 0.08007558264245729, 0.1277210936081007, 0.10585344569002297, 0.1053308403796509, 9.999999999998899e-05, 9.999999999998899e-05, 0.0006065531507590816, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003392162103688645, 0.00016173510615369313, 9.999999999998899e-05, 0.10482334996068654, 0.08102717201692722, 0.08102851163878766, 0.08503290938580432, 0.09099281035669682, 0.09522770574453077, 0.09070934306563017, 0.07453555120107391, 0.0817124311222549, 0.415538927153408, 0.432753802246044, 0.40933538497529354, 0.42605791552506045, 0.42081859249822795, 0.43615781751925564, 0.39286981786956365, 0.42726863821739147, 0.43065214931069995, 0.08236726104384418, 0.10187820747995124, 0.08085635477161268, 0.07562437528222621, 0.07659327471999533, 0.07363029787243791, 0.09070522210092535, 0.07530455818151327, 0.083634827397841, 0.17072797304576415, 0.15495691969737946, 0.14893429348402965, 0.11587608695088092, 0.11887299719984001, 0.14865524769294303, 0.1527482467255038, 0.16376735347164717, 0.1210302753148711, 0.28102618300798754, 0.23108626635297835, 0.22570785304058283, 0.24652083753944254, 0.21620259603570025, 0.20435648873214918, 0.27307284303472623, 0.2782099764656686, 0.28101640748723145, 0.1829985573587385, 0.186174722928648, 0.1623853998011915, 0.1573858798747071, 0.17604366523137793, 0.19266622993058913, 0.191654866539393, 0.17870178243463086, 0.2052544187506503, 0.172172676606286, 0.17538173189111006, 0.21064542562512711, 0.18255745776129007, 0.1716751489108871, 0.16993030936196574, 0.18667638134617692, 0.16365518493645026, 0.20846334274165046, 0.16507783040254254, 0.17943576014114804, 0.20209871132834512, 0.1686611404796282, 0.19388709001229065, 0.18357975784257485, 0.16369369755352414, 0.16679043968294427, 0.1850858941440905, 0.2988685902204101, 0.44406367382238054, 0.16730407940077052, 0.39479865487799115, 0.16457672993139383, 0.2489428252995921, 0.22975341740526267, 0.19175631308602004, 0.36993815827805576, 0.14493509968552587, 0.18506986990688323, 0.14481535974856075, 0.1786920430370419, 0.1475883538215127, 0.2757042277369832, 0.1948064534509485, 0.42307558864302564, 0.360557908640465, 0.17407256303596974, 0.19029436205821615, 0.17343889512070854, 0.16687602648572408, 0.18504565484852598, 0.17602625214136647, 0.18083473035712305, 0.1805234621646965, 0.17237121914314435, 0.07614635767772726, 0.06529733570544771, 0.07947994941171277, 0.07581598144477153, 0.07074510178176063, 0.07374860357152191, 0.06784729369368048, 0.08076713339865016, 0.06682111873709595]}, "mutation_prompt": null}
{"id": "06a9c248-2fa4-4117-9c6a-0d2bb6b6cf1c", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.5, 1.0)  # Self-adaptive F\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.7\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = np.random.uniform(0.05, 0.2)  # Dynamic step size\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 20\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(pop_size):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n                \n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Enhanced Adaptive Scatter Search with Self-Adaptive Differential Mutation and Dynamic Local Search for improved convergence.", "configspace": "", "generation": 4, "fitness": 0.23468025634112552, "feedback": "The algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.21.", "error": "", "parent_id": "347e35b6-8fc5-4c15-80f6-7e2737bf945b", "metadata": {"aucs": [0.6706517668037243, 0.6541420907176894, 0.6816464734936755, 0.6769248037087673, 0.6736461697680551, 0.6756262789209232, 0.7265843923061919, 0.6666629883827284, 0.6646155642509584, 0.4105296181592456, 0.43610624294015654, 0.4199908664718762, 0.4144939014151052, 0.45456348276695724, 0.3948005714962438, 0.41118272360523855, 0.4253144322569571, 0.4640896792960748, 0.10619236983053215, 0.12475255682713593, 0.12741524848488517, 0.13572125053537398, 0.12579324467281972, 0.11313448539087678, 0.11536358782745615, 0.11779959513317395, 0.1105255404818799, 0.11723868474354893, 0.10867685917540693, 0.10857148543452, 0.11475602666481333, 0.11798899643917649, 0.09073193853618955, 0.09281312761502158, 0.0914200218948299, 0.12223097038470465, 0.8617664254289192, 0.9422904455675509, 0.936743447623639, 0.9047744658282048, 0.9243311669948564, 0.9604431859330838, 0.9390249617208063, 0.9393716712843161, 0.9151110366288775, 0.27013792350224564, 0.27099056267132104, 0.2518887629700607, 0.27837957646220424, 0.2864467981913973, 0.2563103882888602, 0.30014799335736275, 0.25610770529622384, 0.27271775266673004, 0.3173230087663468, 0.35982690175362164, 0.2488566826139047, 0.3037555711027109, 0.35613115987220967, 0.3282546302027233, 0.4710959693853416, 0.23025504657300822, 0.2848771737614053, 0.16387861338404164, 0.14698841178431432, 0.14417115373094547, 0.16530440438364546, 0.1491876692893802, 0.14085828421062363, 0.15340688639542222, 0.1524959732110589, 0.17345324982445454, 0.17298559711577421, 0.11556758675329615, 0.09270611298357012, 0.14426176318386075, 0.12775668948889618, 0.1645258214007438, 0.14259331260296926, 0.14421226637400286, 0.13607586380039416, 0.020527240875920838, 0.0055635098594589705, 0.007377317118743676, 0.011254328970098482, 0.007538921576040747, 0.02661672014785821, 0.004345605095991467, 0.010975744793985776, 0.023200974681020448, 0.13228933596798942, 0.1387280825201036, 0.11616570031656615, 0.08226921558308697, 0.09137204315898084, 0.09563813722646375, 0.16980852446450367, 0.10736627816637812, 0.14611984417359913, 9.999999999998899e-05, 9.999999999998899e-05, 0.010012316072017358, 9.999999999998899e-05, 0.0012795477477702821, 0.028678440359643953, 0.006789301786997437, 0.002571591842487231, 0.0063755170956019125, 0.10187173937287863, 0.09520605818233274, 0.10615033386629258, 0.1195823229005375, 0.12546027969824625, 0.09207177801437993, 0.0999026421010023, 0.08467939047641282, 0.09824397911866523, 0.46184650531087057, 0.43814101122435245, 0.4213238922674438, 0.46804401246641547, 0.438114557507846, 0.46230857980199913, 0.4458380383632904, 0.458180680170052, 0.4213291646297974, 0.08681789829027331, 0.09653198621242576, 0.08639158154695992, 0.09368811243268194, 0.08474960883240545, 0.08237717223588603, 0.07356395290469775, 0.08391546760085511, 0.08618399397507515, 0.13609125261462673, 0.1335897251821503, 0.13960690958548894, 0.13272392076609107, 0.14984259393919908, 0.1334765710360425, 0.13965209463812212, 0.14761633616820768, 0.14738073721867528, 0.26369517203033166, 0.269071989475107, 0.26373738166938776, 0.251605229699424, 0.2738099183460724, 0.2438069403650135, 0.2679694194660215, 0.28560477588641064, 0.28110831734010455, 0.1709933356454827, 0.21262080314559995, 0.17766147031430846, 0.18359852869753468, 0.16234061426473123, 0.1801511784732458, 0.20867212122724255, 0.1911451493099725, 0.22524091420879555, 0.24029829683013215, 0.2217445259148142, 0.20049644705594039, 0.19413480667334748, 0.1849984646950491, 0.19902532796123373, 0.1860784739046465, 0.1875206335810562, 0.20838723498626488, 0.193805764735956, 0.19693587260801493, 0.18459773332669605, 0.1797825403063924, 0.17760385094287556, 0.1878394261852976, 0.18718512423527445, 0.18872180224619406, 0.21519314175261883, 0.18054076301358635, 0.36845279826566, 0.39957628045154103, 0.3311492661099603, 0.16785763821204258, 0.16354085130892504, 0.1554317240826424, 0.1711830525785617, 0.16655010218870525, 0.16438063648514145, 0.15765098333845362, 0.28416929350807274, 0.24887785403513385, 0.17164995352320023, 0.19192172910722938, 0.3914043792879607, 0.3335940689080841, 0.19864737685840106, 0.18427535210343526, 0.17198724823672928, 0.18865075358718109, 0.18353283872552129, 0.1713494262875176, 0.1727664894114983, 0.19092395216932723, 0.1918114095000728, 0.20085618259563776, 0.07970541470222847, 0.05863615404389033, 0.06594874411256768, 0.08478809712675939, 0.08138071749034004, 0.0685161506706019, 0.07447566082333357, 0.06909238863767697, 0.0723296792366731]}, "mutation_prompt": null}
{"id": "f1331837-5571-42c3-884f-a36d931e681b", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.5, 1.0)  # Self-adaptive F\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.7\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = np.random.uniform(0.05, 0.2)  # Dynamic step size\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 20\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(pop_size):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n                \n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Enhanced Adaptive Scatter Search with Self-Adaptive Differential Mutation and Dynamic Local Search for improved convergence.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "06a9c248-2fa4-4117-9c6a-0d2bb6b6cf1c", "metadata": {"aucs": [0.6706517668037243, 0.6541420907176894, 0.6816464734936755, 0.6769248037087673, 0.6736461697680551, 0.6756262789209232, 0.7265843923061919, 0.6666629883827284, 0.6646155642509584, 0.4105296181592456, 0.43610624294015654, 0.4199908664718762, 0.4144939014151052, 0.45456348276695724, 0.3948005714962438, 0.41118272360523855, 0.4253144322569571, 0.4640896792960748, 0.10619236983053215, 0.12475255682713593, 0.12741524848488517, 0.13572125053537398, 0.12579324467281972, 0.11313448539087678, 0.11536358782745615, 0.11779959513317395, 0.1105255404818799, 0.11723868474354893, 0.10867685917540693, 0.10857148543452, 0.11475602666481333, 0.11798899643917649, 0.09073193853618955, 0.09281312761502158, 0.0914200218948299, 0.12223097038470465, 0.8617664254289192, 0.9422904455675509, 0.936743447623639, 0.9047744658282048, 0.9243311669948564, 0.9604431859330838, 0.9390249617208063, 0.9393716712843161, 0.9151110366288775, 0.27013792350224564, 0.27099056267132104, 0.2518887629700607, 0.27837957646220424, 0.2864467981913973, 0.2563103882888602, 0.30014799335736275, 0.25610770529622384, 0.27271775266673004, 0.3173230087663468, 0.35982690175362164, 0.2488566826139047, 0.3037555711027109, 0.35613115987220967, 0.3282546302027233, 0.4710959693853416, 0.23025504657300822, 0.2848771737614053, 0.16387861338404164, 0.14698841178431432, 0.14417115373094547, 0.16530440438364546, 0.1491876692893802, 0.14085828421062363, 0.15340688639542222, 0.1524959732110589, 0.17345324982445454, 0.17298559711577421, 0.11556758675329615, 0.09270611298357012, 0.14426176318386075, 0.12775668948889618, 0.1645258214007438, 0.14259331260296926, 0.14421226637400286, 0.13607586380039416, 0.020527240875920838, 0.0055635098594589705, 0.007377317118743676, 0.011254328970098482, 0.007538921576040747, 0.02661672014785821, 0.004345605095991467, 0.010975744793985776, 0.023200974681020448, 0.13228933596798942, 0.1387280825201036, 0.11616570031656615, 0.08226921558308697, 0.09137204315898084, 0.09563813722646375, 0.16980852446450367, 0.10736627816637812, 0.14611984417359913, 9.999999999998899e-05, 9.999999999998899e-05, 0.010012316072017358, 9.999999999998899e-05, 0.0012795477477702821, 0.028678440359643953, 0.006789301786997437, 0.002571591842487231, 0.0063755170956019125, 0.10187173937287863, 0.09520605818233274, 0.10615033386629258, 0.1195823229005375, 0.12546027969824625, 0.09207177801437993, 0.0999026421010023, 0.08467939047641282, 0.09824397911866523, 0.46184650531087057, 0.43814101122435245, 0.4213238922674438, 0.46804401246641547, 0.438114557507846, 0.46230857980199913, 0.4458380383632904, 0.458180680170052, 0.4213291646297974, 0.08681789829027331, 0.09653198621242576, 0.08639158154695992, 0.09368811243268194, 0.08474960883240545, 0.08237717223588603, 0.07356395290469775, 0.08391546760085511, 0.08618399397507515, 0.13609125261462673, 0.1335897251821503, 0.13960690958548894, 0.13272392076609107, 0.14984259393919908, 0.1334765710360425, 0.13965209463812212, 0.14761633616820768, 0.14738073721867528, 0.26369517203033166, 0.269071989475107, 0.26373738166938776, 0.251605229699424, 0.2738099183460724, 0.2438069403650135, 0.2679694194660215, 0.28560477588641064, 0.28110831734010455, 0.1709933356454827, 0.21262080314559995, 0.17766147031430846, 0.18359852869753468, 0.16234061426473123, 0.1801511784732458, 0.20867212122724255, 0.1911451493099725, 0.22524091420879555, 0.24029829683013215, 0.2217445259148142, 0.20049644705594039, 0.19413480667334748, 0.1849984646950491, 0.19902532796123373, 0.1860784739046465, 0.1875206335810562, 0.20838723498626488, 0.193805764735956, 0.19693587260801493, 0.18459773332669605, 0.1797825403063924, 0.17760385094287556, 0.1878394261852976, 0.18718512423527445, 0.18872180224619406, 0.21519314175261883, 0.18054076301358635, 0.36845279826566, 0.39957628045154103, 0.3311492661099603, 0.16785763821204258, 0.16354085130892504, 0.1554317240826424, 0.1711830525785617, 0.16655010218870525, 0.16438063648514145, 0.15765098333845362, 0.28416929350807274, 0.24887785403513385, 0.17164995352320023, 0.19192172910722938, 0.3914043792879607, 0.3335940689080841, 0.19864737685840106, 0.18427535210343526, 0.17198724823672928, 0.18865075358718109, 0.18353283872552129, 0.1713494262875176, 0.1727664894114983, 0.19092395216932723, 0.1918114095000728, 0.20085618259563776, 0.07970541470222847, 0.05863615404389033, 0.06594874411256768, 0.08478809712675939, 0.08138071749034004, 0.0685161506706019, 0.07447566082333357, 0.06909238863767697, 0.0723296792366731]}, "mutation_prompt": null}
{"id": "a26788ea-c16a-4e0f-af1b-863d9df6936f", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.5, 1.0)  # Self-adaptive F\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.7\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = np.random.uniform(0.05, 0.2)  # Dynamic step size\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 20\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(pop_size):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n                \n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Enhanced Adaptive Scatter Search with Self-Adaptive Differential Mutation and Dynamic Local Search for improved convergence.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "06a9c248-2fa4-4117-9c6a-0d2bb6b6cf1c", "metadata": {"aucs": [0.6706517668037243, 0.6541420907176894, 0.6816464734936755, 0.6769248037087673, 0.6736461697680551, 0.6756262789209232, 0.7265843923061919, 0.6666629883827284, 0.6646155642509584, 0.4105296181592456, 0.43610624294015654, 0.4199908664718762, 0.4144939014151052, 0.45456348276695724, 0.3948005714962438, 0.41118272360523855, 0.4253144322569571, 0.4640896792960748, 0.10619236983053215, 0.12475255682713593, 0.12741524848488517, 0.13572125053537398, 0.12579324467281972, 0.11313448539087678, 0.11536358782745615, 0.11779959513317395, 0.1105255404818799, 0.11723868474354893, 0.10867685917540693, 0.10857148543452, 0.11475602666481333, 0.11798899643917649, 0.09073193853618955, 0.09281312761502158, 0.0914200218948299, 0.12223097038470465, 0.8617664254289192, 0.9422904455675509, 0.936743447623639, 0.9047744658282048, 0.9243311669948564, 0.9604431859330838, 0.9390249617208063, 0.9393716712843161, 0.9151110366288775, 0.27013792350224564, 0.27099056267132104, 0.2518887629700607, 0.27837957646220424, 0.2864467981913973, 0.2563103882888602, 0.30014799335736275, 0.25610770529622384, 0.27271775266673004, 0.3173230087663468, 0.35982690175362164, 0.2488566826139047, 0.3037555711027109, 0.35613115987220967, 0.3282546302027233, 0.4710959693853416, 0.23025504657300822, 0.2848771737614053, 0.16387861338404164, 0.14698841178431432, 0.14417115373094547, 0.16530440438364546, 0.1491876692893802, 0.14085828421062363, 0.15340688639542222, 0.1524959732110589, 0.17345324982445454, 0.17298559711577421, 0.11556758675329615, 0.09270611298357012, 0.14426176318386075, 0.12775668948889618, 0.1645258214007438, 0.14259331260296926, 0.14421226637400286, 0.13607586380039416, 0.020527240875920838, 0.0055635098594589705, 0.007377317118743676, 0.011254328970098482, 0.007538921576040747, 0.02661672014785821, 0.004345605095991467, 0.010975744793985776, 0.023200974681020448, 0.13228933596798942, 0.1387280825201036, 0.11616570031656615, 0.08226921558308697, 0.09137204315898084, 0.09563813722646375, 0.16980852446450367, 0.10736627816637812, 0.14611984417359913, 9.999999999998899e-05, 9.999999999998899e-05, 0.010012316072017358, 9.999999999998899e-05, 0.0012795477477702821, 0.028678440359643953, 0.006789301786997437, 0.002571591842487231, 0.0063755170956019125, 0.10187173937287863, 0.09520605818233274, 0.10615033386629258, 0.1195823229005375, 0.12546027969824625, 0.09207177801437993, 0.0999026421010023, 0.08467939047641282, 0.09824397911866523, 0.46184650531087057, 0.43814101122435245, 0.4213238922674438, 0.46804401246641547, 0.438114557507846, 0.46230857980199913, 0.4458380383632904, 0.458180680170052, 0.4213291646297974, 0.08681789829027331, 0.09653198621242576, 0.08639158154695992, 0.09368811243268194, 0.08474960883240545, 0.08237717223588603, 0.07356395290469775, 0.08391546760085511, 0.08618399397507515, 0.13609125261462673, 0.1335897251821503, 0.13960690958548894, 0.13272392076609107, 0.14984259393919908, 0.1334765710360425, 0.13965209463812212, 0.14761633616820768, 0.14738073721867528, 0.26369517203033166, 0.269071989475107, 0.26373738166938776, 0.251605229699424, 0.2738099183460724, 0.2438069403650135, 0.2679694194660215, 0.28560477588641064, 0.28110831734010455, 0.1709933356454827, 0.21262080314559995, 0.17766147031430846, 0.18359852869753468, 0.16234061426473123, 0.1801511784732458, 0.20867212122724255, 0.1911451493099725, 0.22524091420879555, 0.24029829683013215, 0.2217445259148142, 0.20049644705594039, 0.19413480667334748, 0.1849984646950491, 0.19902532796123373, 0.1860784739046465, 0.1875206335810562, 0.20838723498626488, 0.193805764735956, 0.19693587260801493, 0.18459773332669605, 0.1797825403063924, 0.17760385094287556, 0.1878394261852976, 0.18718512423527445, 0.18872180224619406, 0.21519314175261883, 0.18054076301358635, 0.36845279826566, 0.39957628045154103, 0.3311492661099603, 0.16785763821204258, 0.16354085130892504, 0.1554317240826424, 0.1711830525785617, 0.16655010218870525, 0.16438063648514145, 0.15765098333845362, 0.28416929350807274, 0.24887785403513385, 0.17164995352320023, 0.19192172910722938, 0.3914043792879607, 0.3335940689080841, 0.19864737685840106, 0.18427535210343526, 0.17198724823672928, 0.18865075358718109, 0.18353283872552129, 0.1713494262875176, 0.1727664894114983, 0.19092395216932723, 0.1918114095000728, 0.20085618259563776, 0.07970541470222847, 0.05863615404389033, 0.06594874411256768, 0.08478809712675939, 0.08138071749034004, 0.0685161506706019, 0.07447566082333357, 0.06909238863767697, 0.0723296792366731]}, "mutation_prompt": null}
{"id": "fdedbf27-a867-4f50-87b9-3957e04d14c3", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.5, 1.0)  # Self-adaptive F\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.7\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = np.random.uniform(0.05, 0.2)  # Dynamic step size\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 20\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(pop_size):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n                \n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Enhanced Adaptive Scatter Search with Self-Adaptive Differential Mutation and Dynamic Local Search for improved convergence.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "06a9c248-2fa4-4117-9c6a-0d2bb6b6cf1c", "metadata": {"aucs": [0.6706517668037243, 0.6541420907176894, 0.6816464734936755, 0.6769248037087673, 0.6736461697680551, 0.6756262789209232, 0.7265843923061919, 0.6666629883827284, 0.6646155642509584, 0.4105296181592456, 0.43610624294015654, 0.4199908664718762, 0.4144939014151052, 0.45456348276695724, 0.3948005714962438, 0.41118272360523855, 0.4253144322569571, 0.4640896792960748, 0.10619236983053215, 0.12475255682713593, 0.12741524848488517, 0.13572125053537398, 0.12579324467281972, 0.11313448539087678, 0.11536358782745615, 0.11779959513317395, 0.1105255404818799, 0.11723868474354893, 0.10867685917540693, 0.10857148543452, 0.11475602666481333, 0.11798899643917649, 0.09073193853618955, 0.09281312761502158, 0.0914200218948299, 0.12223097038470465, 0.8617664254289192, 0.9422904455675509, 0.936743447623639, 0.9047744658282048, 0.9243311669948564, 0.9604431859330838, 0.9390249617208063, 0.9393716712843161, 0.9151110366288775, 0.27013792350224564, 0.27099056267132104, 0.2518887629700607, 0.27837957646220424, 0.2864467981913973, 0.2563103882888602, 0.30014799335736275, 0.25610770529622384, 0.27271775266673004, 0.3173230087663468, 0.35982690175362164, 0.2488566826139047, 0.3037555711027109, 0.35613115987220967, 0.3282546302027233, 0.4710959693853416, 0.23025504657300822, 0.2848771737614053, 0.16387861338404164, 0.14698841178431432, 0.14417115373094547, 0.16530440438364546, 0.1491876692893802, 0.14085828421062363, 0.15340688639542222, 0.1524959732110589, 0.17345324982445454, 0.17298559711577421, 0.11556758675329615, 0.09270611298357012, 0.14426176318386075, 0.12775668948889618, 0.1645258214007438, 0.14259331260296926, 0.14421226637400286, 0.13607586380039416, 0.020527240875920838, 0.0055635098594589705, 0.007377317118743676, 0.011254328970098482, 0.007538921576040747, 0.02661672014785821, 0.004345605095991467, 0.010975744793985776, 0.023200974681020448, 0.13228933596798942, 0.1387280825201036, 0.11616570031656615, 0.08226921558308697, 0.09137204315898084, 0.09563813722646375, 0.16980852446450367, 0.10736627816637812, 0.14611984417359913, 9.999999999998899e-05, 9.999999999998899e-05, 0.010012316072017358, 9.999999999998899e-05, 0.0012795477477702821, 0.028678440359643953, 0.006789301786997437, 0.002571591842487231, 0.0063755170956019125, 0.10187173937287863, 0.09520605818233274, 0.10615033386629258, 0.1195823229005375, 0.12546027969824625, 0.09207177801437993, 0.0999026421010023, 0.08467939047641282, 0.09824397911866523, 0.46184650531087057, 0.43814101122435245, 0.4213238922674438, 0.46804401246641547, 0.438114557507846, 0.46230857980199913, 0.4458380383632904, 0.458180680170052, 0.4213291646297974, 0.08681789829027331, 0.09653198621242576, 0.08639158154695992, 0.09368811243268194, 0.08474960883240545, 0.08237717223588603, 0.07356395290469775, 0.08391546760085511, 0.08618399397507515, 0.13609125261462673, 0.1335897251821503, 0.13960690958548894, 0.13272392076609107, 0.14984259393919908, 0.1334765710360425, 0.13965209463812212, 0.14761633616820768, 0.14738073721867528, 0.26369517203033166, 0.269071989475107, 0.26373738166938776, 0.251605229699424, 0.2738099183460724, 0.2438069403650135, 0.2679694194660215, 0.28560477588641064, 0.28110831734010455, 0.1709933356454827, 0.21262080314559995, 0.17766147031430846, 0.18359852869753468, 0.16234061426473123, 0.1801511784732458, 0.20867212122724255, 0.1911451493099725, 0.22524091420879555, 0.24029829683013215, 0.2217445259148142, 0.20049644705594039, 0.19413480667334748, 0.1849984646950491, 0.19902532796123373, 0.1860784739046465, 0.1875206335810562, 0.20838723498626488, 0.193805764735956, 0.19693587260801493, 0.18459773332669605, 0.1797825403063924, 0.17760385094287556, 0.1878394261852976, 0.18718512423527445, 0.18872180224619406, 0.21519314175261883, 0.18054076301358635, 0.36845279826566, 0.39957628045154103, 0.3311492661099603, 0.16785763821204258, 0.16354085130892504, 0.1554317240826424, 0.1711830525785617, 0.16655010218870525, 0.16438063648514145, 0.15765098333845362, 0.28416929350807274, 0.24887785403513385, 0.17164995352320023, 0.19192172910722938, 0.3914043792879607, 0.3335940689080841, 0.19864737685840106, 0.18427535210343526, 0.17198724823672928, 0.18865075358718109, 0.18353283872552129, 0.1713494262875176, 0.1727664894114983, 0.19092395216932723, 0.1918114095000728, 0.20085618259563776, 0.07970541470222847, 0.05863615404389033, 0.06594874411256768, 0.08478809712675939, 0.08138071749034004, 0.0685161506706019, 0.07447566082333357, 0.06909238863767697, 0.0723296792366731]}, "mutation_prompt": null}
{"id": "c67e7399-c67a-460e-bd02-c90497c7aa4f", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.5, 1.0)  # Self-adaptive F\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.7\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = np.random.uniform(0.05, 0.2)  # Dynamic step size\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 20\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(pop_size):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n                \n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Enhanced Adaptive Scatter Search with Self-Adaptive Differential Mutation and Dynamic Local Search for improved convergence.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "06a9c248-2fa4-4117-9c6a-0d2bb6b6cf1c", "metadata": {"aucs": [0.6706517668037243, 0.6541420907176894, 0.6816464734936755, 0.6769248037087673, 0.6736461697680551, 0.6756262789209232, 0.7265843923061919, 0.6666629883827284, 0.6646155642509584, 0.4105296181592456, 0.43610624294015654, 0.4199908664718762, 0.4144939014151052, 0.45456348276695724, 0.3948005714962438, 0.41118272360523855, 0.4253144322569571, 0.4640896792960748, 0.10619236983053215, 0.12475255682713593, 0.12741524848488517, 0.13572125053537398, 0.12579324467281972, 0.11313448539087678, 0.11536358782745615, 0.11779959513317395, 0.1105255404818799, 0.11723868474354893, 0.10867685917540693, 0.10857148543452, 0.11475602666481333, 0.11798899643917649, 0.09073193853618955, 0.09281312761502158, 0.0914200218948299, 0.12223097038470465, 0.8617664254289192, 0.9422904455675509, 0.936743447623639, 0.9047744658282048, 0.9243311669948564, 0.9604431859330838, 0.9390249617208063, 0.9393716712843161, 0.9151110366288775, 0.27013792350224564, 0.27099056267132104, 0.2518887629700607, 0.27837957646220424, 0.2864467981913973, 0.2563103882888602, 0.30014799335736275, 0.25610770529622384, 0.27271775266673004, 0.3173230087663468, 0.35982690175362164, 0.2488566826139047, 0.3037555711027109, 0.35613115987220967, 0.3282546302027233, 0.4710959693853416, 0.23025504657300822, 0.2848771737614053, 0.16387861338404164, 0.14698841178431432, 0.14417115373094547, 0.16530440438364546, 0.1491876692893802, 0.14085828421062363, 0.15340688639542222, 0.1524959732110589, 0.17345324982445454, 0.17298559711577421, 0.11556758675329615, 0.09270611298357012, 0.14426176318386075, 0.12775668948889618, 0.1645258214007438, 0.14259331260296926, 0.14421226637400286, 0.13607586380039416, 0.020527240875920838, 0.0055635098594589705, 0.007377317118743676, 0.011254328970098482, 0.007538921576040747, 0.02661672014785821, 0.004345605095991467, 0.010975744793985776, 0.023200974681020448, 0.13228933596798942, 0.1387280825201036, 0.11616570031656615, 0.08226921558308697, 0.09137204315898084, 0.09563813722646375, 0.16980852446450367, 0.10736627816637812, 0.14611984417359913, 9.999999999998899e-05, 9.999999999998899e-05, 0.010012316072017358, 9.999999999998899e-05, 0.0012795477477702821, 0.028678440359643953, 0.006789301786997437, 0.002571591842487231, 0.0063755170956019125, 0.10187173937287863, 0.09520605818233274, 0.10615033386629258, 0.1195823229005375, 0.12546027969824625, 0.09207177801437993, 0.0999026421010023, 0.08467939047641282, 0.09824397911866523, 0.46184650531087057, 0.43814101122435245, 0.4213238922674438, 0.46804401246641547, 0.438114557507846, 0.46230857980199913, 0.4458380383632904, 0.458180680170052, 0.4213291646297974, 0.08681789829027331, 0.09653198621242576, 0.08639158154695992, 0.09368811243268194, 0.08474960883240545, 0.08237717223588603, 0.07356395290469775, 0.08391546760085511, 0.08618399397507515, 0.13609125261462673, 0.1335897251821503, 0.13960690958548894, 0.13272392076609107, 0.14984259393919908, 0.1334765710360425, 0.13965209463812212, 0.14761633616820768, 0.14738073721867528, 0.26369517203033166, 0.269071989475107, 0.26373738166938776, 0.251605229699424, 0.2738099183460724, 0.2438069403650135, 0.2679694194660215, 0.28560477588641064, 0.28110831734010455, 0.1709933356454827, 0.21262080314559995, 0.17766147031430846, 0.18359852869753468, 0.16234061426473123, 0.1801511784732458, 0.20867212122724255, 0.1911451493099725, 0.22524091420879555, 0.24029829683013215, 0.2217445259148142, 0.20049644705594039, 0.19413480667334748, 0.1849984646950491, 0.19902532796123373, 0.1860784739046465, 0.1875206335810562, 0.20838723498626488, 0.193805764735956, 0.19693587260801493, 0.18459773332669605, 0.1797825403063924, 0.17760385094287556, 0.1878394261852976, 0.18718512423527445, 0.18872180224619406, 0.21519314175261883, 0.18054076301358635, 0.36845279826566, 0.39957628045154103, 0.3311492661099603, 0.16785763821204258, 0.16354085130892504, 0.1554317240826424, 0.1711830525785617, 0.16655010218870525, 0.16438063648514145, 0.15765098333845362, 0.28416929350807274, 0.24887785403513385, 0.17164995352320023, 0.19192172910722938, 0.3914043792879607, 0.3335940689080841, 0.19864737685840106, 0.18427535210343526, 0.17198724823672928, 0.18865075358718109, 0.18353283872552129, 0.1713494262875176, 0.1727664894114983, 0.19092395216932723, 0.1918114095000728, 0.20085618259563776, 0.07970541470222847, 0.05863615404389033, 0.06594874411256768, 0.08478809712675939, 0.08138071749034004, 0.0685161506706019, 0.07447566082333357, 0.06909238863767697, 0.0723296792366731]}, "mutation_prompt": null}
{"id": "fa5b9797-6194-4c8d-8a23-99ad36988848", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.5, 1.0)  # Self-adaptive F\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = np.random.uniform(0.6, 0.9)  # Adaptive crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = 0.1 / (1 + np.exp(-0.1 * self.num_evaluations))  # Adaptive step size\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 20\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(pop_size):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n                \n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Adaptive Scatter Search with Enhanced Self-Adaptive Differential Mutation and Improved Local Search using Adaptive Step Size.", "configspace": "", "generation": 9, "fitness": 0.24996415491191895, "feedback": "The algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.21.", "error": "", "parent_id": "06a9c248-2fa4-4117-9c6a-0d2bb6b6cf1c", "metadata": {"aucs": [0.7076388362005067, 0.6391102109358799, 0.6775479077367059, 0.7407892379512833, 0.6866090976914696, 0.7111976964081124, 0.6828599326596834, 0.6721410561072239, 0.6620570698045185, 0.45941858029418403, 0.3716379838521563, 0.48161976925036476, 0.40420622072611523, 0.4163022615007256, 0.3998692477536341, 0.4204357944387349, 0.3747799811657504, 0.40233345114364494, 0.09822061625397094, 0.12720362178658928, 0.13261859750304517, 0.1232727702194335, 0.1142339490963743, 0.11126440699143092, 0.10824440073508157, 0.10399034749910208, 0.1335696714559148, 0.09706338258986835, 0.11925415474818346, 0.1085627806539865, 0.10779739609034344, 0.09299758822392579, 0.10203925233846645, 0.10281320233960034, 0.10026807192508425, 0.11095448722195211, 0.8989343537598027, 0.9404304363740433, 0.9246109983233763, 0.9159894832893983, 0.9526651923730393, 0.9308655870763092, 0.8944423794203002, 0.9206902080042424, 0.9028380336612838, 0.297377086720364, 0.2726609834210584, 0.23727429130328948, 0.2762831704309683, 0.30112387912281824, 0.3206121203330554, 0.2897506960851042, 0.29410387893836865, 0.2811676780918577, 0.43736669963900743, 0.3392403986456014, 0.39836598815832014, 0.44314425663187396, 0.26920967774204363, 0.48584249519580025, 0.49680350443480037, 0.4472273550808614, 0.542660017985773, 0.17050593421579963, 0.160991593990101, 0.1672349843270038, 0.17786829158764905, 0.2148855744092384, 0.15925995078351896, 0.17766539052927677, 0.19527556224600218, 0.15485565822023362, 0.210880271757807, 0.10474221741794698, 0.13665374260468832, 0.14159247188436508, 0.16065225099584257, 0.17679794931939852, 0.12411079019167248, 0.11399124857473364, 0.154128104810888, 0.03844063009037568, 0.08251674402033005, 0.0388914394502935, 0.08525982662819787, 0.08980279259949697, 0.0385131543234527, 0.024058287595611016, 0.10771383114194544, 0.07179820348099752, 0.17291318633964914, 0.12000164891199916, 0.204761400370003, 0.1334567685903021, 0.1605006629039728, 0.06268575324361958, 0.22314775095389094, 0.18568809662021235, 0.2301171164474366, 0.03234361021278187, 0.02340901702966003, 0.010518393156637273, 0.032586274357206846, 0.004464487837155917, 0.011816647387359658, 0.01790882989278819, 0.004099881447262699, 0.02122662023644173, 0.12688053217050632, 0.10763293100152238, 0.13587406242317213, 0.13259504911771514, 0.12713042250594497, 0.14128126758808035, 0.131296637702219, 0.1207266010758653, 0.10562374543675956, 0.44271198688225355, 0.42610661180738774, 0.4806835035764787, 0.49473376251985635, 0.46802732588898344, 0.4417734634434385, 0.45381345112212645, 0.45530341537661256, 0.4986930534405941, 0.09100184264721478, 0.07943562972240903, 0.07528736477975706, 0.09109562355754774, 0.09061307537927898, 0.08862297469731462, 0.09825880565268197, 0.09240839150027147, 0.0784082057697777, 0.12473123837441469, 0.11900422208379824, 0.14746987751723795, 0.14864598353429392, 0.1491680578279918, 0.1369874857372939, 0.13966233892448432, 0.15003997240827682, 0.13992481709677462, 0.24194917664364923, 0.26071276328054216, 0.2845183978945931, 0.2685413467975033, 0.2728400950064076, 0.2680745061005657, 0.3136676448955955, 0.2739989262280683, 0.30212802045700216, 0.23560908748252818, 0.2138705275899584, 0.2039264720963362, 0.19650929757245172, 0.19234284280976055, 0.18445670089268806, 0.201510410214229, 0.2150453069865096, 0.205200842157222, 0.20429274876992132, 0.17763989846858586, 0.1880405688813298, 0.17735841644547623, 0.203613388773337, 0.16515549865072476, 0.16666933612464851, 0.1803805412726579, 0.18335362722771542, 0.16815863518255503, 0.20444194805142635, 0.16849491089037105, 0.18755646560384842, 0.2680717996058356, 0.17507379877592244, 0.18480001489224518, 0.17884031185119986, 0.16965284043335738, 0.4493108394195331, 0.4696839603006412, 0.18641097643324733, 0.6655282906570792, 0.16290911951555043, 0.3623811575398559, 0.21985104098101216, 0.2402256761323721, 0.17796902155856464, 0.1483093834352066, 0.15954081685215493, 0.19575554743151413, 0.2430530521330605, 0.4493915332012407, 0.17980246840172331, 0.14786549192301957, 0.20557997022804475, 0.20973812334577102, 0.18437480098510628, 0.19178696038188747, 0.1792475606513919, 0.18568375648645497, 0.18644680574663897, 0.1737143183178641, 0.17295645937058524, 0.18657558592549262, 0.17484000758679363, 0.07484167308992551, 0.0875968195992658, 0.07078897489618452, 0.08231519046562752, 0.0791439055523373, 0.07929988791432674, 0.08434831046222313, 0.08166749207155621, 0.07783471001308317]}, "mutation_prompt": null}
{"id": "3c4363a1-3c0c-4d17-9722-2a47b2bda92b", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)  # Adjusted F for improved exploration\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)  # Dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))  # Adjusted step size\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))  # Dynamic population size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):  # Use current dynamic population size\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Enhanced Adaptive Scatter Search with Adaptive Learning Rates and Dynamic Population Size for Improved Exploration.", "configspace": "", "generation": 10, "fitness": 0.31091926409241133, "feedback": "The algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.", "error": "", "parent_id": "fa5b9797-6194-4c8d-8a23-99ad36988848", "metadata": {"aucs": [0.738201287656756, 0.7691982510680817, 0.7616170017383036, 0.7723575324811431, 0.7724143292883717, 0.7688710022810007, 0.7512446754439891, 0.7737289031660515, 0.747700039125325, 0.5689266285009613, 0.5398818242247032, 0.46751690649494837, 0.4780181255411625, 0.613687949795267, 0.5997491730795946, 0.574816064747095, 0.5573715411322453, 0.5852184759756376, 0.10966790138022553, 0.12301450535901681, 0.10725849225359396, 0.13279294841588418, 0.1104369648033171, 0.1423742076308523, 0.10823593931867981, 0.11015593174838034, 0.10520574534032001, 0.10054779669414415, 0.10399688123947581, 0.10346094475768586, 0.10186074493853503, 0.10932028919258852, 0.09934785280569436, 0.0989634460035822, 0.10489817243660271, 0.09042903645556777, 0.9058528281041253, 0.8756868138220796, 0.9329918273098777, 0.9266115455863444, 0.9616951025354443, 0.9206299193373818, 0.9018297525137864, 0.9202644425221242, 0.9244480982294093, 0.38252185857230125, 0.396427085105057, 0.394594926275472, 0.3594779877828841, 0.38923654638793526, 0.3880412259202636, 0.3553553494759175, 0.33429895865391446, 0.3647241541709868, 0.6572144992694362, 0.6807299858277391, 0.7218511665870344, 0.6421851761743829, 0.7257170667927136, 0.7518703107118334, 0.7358011177909592, 0.7099794790785467, 0.658473385690538, 0.1819259566191398, 0.19793144623295944, 0.21303686137792444, 0.21959339527261212, 0.3273930104371261, 0.11769874152001669, 0.20716196610756465, 0.18265644175254425, 0.1804099559800334, 0.15748908335825285, 0.16925280944444876, 0.24220574391753535, 0.27035207350338786, 0.18984715468295177, 0.20322076661482247, 0.21599246621821844, 0.18737397494746777, 0.1766899408348136, 0.13425710030704163, 0.181156431768149, 0.2209722105798636, 0.07956030284305671, 0.13857132875184885, 0.09526848813928135, 0.2499352302347374, 0.23382541650695543, 0.2603401423982302, 0.25359847041188965, 0.3210433434576354, 0.3552326595742671, 0.1432309210738556, 0.18033704368678483, 0.24180329680886625, 0.439520367908537, 0.39419504191519494, 0.21859726332918195, 0.09422645278524322, 0.06952732658422922, 0.07692071355693475, 0.05653788825965056, 0.12485087693001518, 0.1548583066274738, 0.07438429743482011, 0.1523604378651937, 0.11744376089214348, 0.21279630481763323, 0.20548057708376943, 0.2135360132648989, 0.23450348653200204, 0.21731694654001543, 0.22480860677681247, 0.2049641143344083, 0.2407594935734202, 0.23787500628041336, 0.6240672973122611, 0.5892645452771447, 0.553574757003642, 0.5761107324147166, 0.5800855593334139, 0.5870270313802208, 0.5323267730773815, 0.5768101328465619, 0.6101327316615441, 0.10285983149207245, 0.09193794868495275, 0.09650219210126909, 0.09743002946975099, 0.10229944852698214, 0.095341553856368, 0.08408492071922224, 0.08165305606356965, 0.12517539129543132, 0.1496104046986031, 0.13017935319665208, 0.16712629612975938, 0.26602327756620625, 0.18809013917062134, 0.1364682471898956, 0.14265096206992112, 0.1781604465552371, 0.13341576903043373, 0.3353541500365358, 0.3529052437169964, 0.31978863931498236, 0.3523549217516171, 0.33958186408862634, 0.3632628218352757, 0.3444501290322598, 0.36343902509190407, 0.37573126399945844, 0.279611035779293, 0.26426519192325837, 0.24461376274499358, 0.2299220713389939, 0.24790020118363432, 0.22480952252231778, 0.27704789226828797, 0.29316438300858905, 0.2866158235890027, 0.188000272580085, 0.1876590328743989, 0.1943645745770688, 0.18146396941279408, 0.19888740937551952, 0.19045777661456753, 0.20425579742468614, 0.20006969458749868, 0.19551516386593293, 0.19811035342738004, 0.21486665494224166, 0.23832818374834386, 0.21501219286747497, 0.18931118505391564, 0.19654757641040232, 0.1851410346276834, 0.23961408283418018, 0.1974865549862499, 0.6614310551442828, 0.16368222403723287, 0.1627357651532706, 0.17376843773628736, 0.19018164393771153, 0.7329352853700006, 0.5417731141673049, 0.5146793605646893, 0.7307114188261215, 0.16449947521111719, 0.11183706091588297, 0.19360235503654744, 0.18078575252025852, 0.20356962872429085, 0.15084013469482904, 0.4839068991542971, 0.15350922121481925, 0.15069787978977434, 0.19250521031673362, 0.17991098529263072, 0.16733845620330845, 0.17652989821419618, 0.19491060774668512, 0.19207171698891146, 0.17722155471630718, 0.17322502530285588, 0.19539250995653878, 0.08803902699039223, 0.06057531541827743, 0.08293477527804716, 0.08482405180209518, 0.08448617008404058, 0.07778041885266429, 0.08666058065941273, 0.07450552174114222, 0.08035864323804653]}, "mutation_prompt": null}
{"id": "cffd96eb-6f58-4e71-8a9f-90010075b16c", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.5, 0.9)  # Adjusted F for more robust exploration\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.8 - 0.3 * (self.num_evaluations / self.budget)  # More stable crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = 0.15 / (1 + np.exp(-0.1 * self.num_evaluations))  # Fine-tuned step size\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def adaptive_diversity_maintenance(self, population, func):\n        diversity_factor = 0.1 * (1 - (self.num_evaluations / self.budget))\n        for i in range(len(population)):\n            if np.random.rand() < diversity_factor:\n                perturbation = np.random.uniform(-0.5, 0.5, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                if func(candidate) < func(population[i]):\n                    population[i] = candidate\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            self.adaptive_diversity_maintenance(population, func)  # New diversity maintenance step\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Enhanced Adaptive Scatter Search with Adaptive Diversity Maintenance and Multi-Phase Exploration Strategy to Improve Optimization Performance.", "configspace": "", "generation": 11, "fitness": 0.2518118306459642, "feedback": "The algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.21.", "error": "", "parent_id": "3c4363a1-3c0c-4d17-9722-2a47b2bda92b", "metadata": {"aucs": [0.7369099223587157, 0.6791971268175198, 0.6577526403469629, 0.7214023787465305, 0.6917070813685007, 0.6641695251659689, 0.6921374590727554, 0.724556490270153, 0.6872154301826386, 0.42727160780611984, 0.4823503237464214, 0.40765319130528965, 0.41189150911946404, 0.47353543698859546, 0.47932068082009427, 0.4207249230830288, 0.481380130383935, 0.4473985009658398, 0.11835549349477992, 0.11353617836837326, 0.11705847746626619, 0.10742536914028611, 0.12003921674400175, 0.09244953356767915, 0.12343014302885513, 0.11549986394038136, 0.10422773066836832, 0.08861565771799274, 0.11051807711861872, 0.09349582989517691, 0.11881541402575968, 0.10712587160420484, 0.09860549149307973, 0.08511177436543893, 0.09179045237023165, 0.10150866125868074, 0.9760979997466444, 0.9244351838737777, 0.9498587333200839, 0.9302361761427523, 0.9624792304539058, 0.947657750611656, 0.9667592346727413, 0.9332127149246622, 0.9506065204088928, 0.34914273394522866, 0.2873864813090601, 0.32812038424692413, 0.29118978960821074, 0.29596575462408026, 0.2914972602565391, 0.3184400678051317, 0.2925066861280805, 0.2678904285646778, 0.4479238527603475, 0.39242187580854004, 0.4763583238655553, 0.5398471072825723, 0.48648301772227265, 0.4947440652943228, 0.3836172519751795, 0.5294634896230938, 0.3739440012493086, 0.16726485789647305, 0.16502955923820317, 0.16286247530865472, 0.1883337487469735, 0.13023430438231098, 0.22047239172694177, 0.183378379138062, 0.1542897577896829, 0.21405962571719972, 0.1381713521980863, 0.17131842500571015, 0.1498913774816032, 0.18077866574513668, 0.15666269275171674, 0.16394045523280387, 0.1460553696243846, 0.11481764146796847, 0.1463512943681895, 0.04244184922837846, 0.05091474323119072, 0.04153703588601698, 0.0634971975922477, 0.02975219209753499, 0.0737658158671688, 0.04818007511982103, 0.047092943260628406, 0.055029149860586046, 0.15532484514801015, 0.18002475267944662, 0.19956309443786435, 0.18181315946310161, 0.15567555488827134, 0.08336744203348845, 0.16146039766473863, 0.18608469666832583, 0.16532640466731463, 0.018382546368988728, 0.01029223733604867, 0.01012041636243266, 0.0009844848961545472, 0.04941301065041681, 0.06350598879879998, 0.00649915676788293, 0.006867786280422061, 0.002475806865856467, 0.11997007626041378, 0.12048874122594277, 0.14384202516777023, 0.12707779505696248, 0.13140981687486364, 0.13844616213712868, 0.1237396270259864, 0.1343995721662019, 0.13115094522608073, 0.4471521053095242, 0.4391089055839462, 0.48579015994944286, 0.4895817303083503, 0.47999110788288635, 0.4804764909292084, 0.4678996323552169, 0.4819093863112336, 0.44928487943678375, 0.08128535695538086, 0.08737004141048488, 0.08656470910132918, 0.08760918960032982, 0.08829648522090516, 0.10931446264207711, 0.0826580965333158, 0.084751872263499, 0.078466723405752, 0.12103655630882071, 0.13673354085006473, 0.12320587603278732, 0.13630106907102435, 0.14013844598455638, 0.14284758921578466, 0.14927006947439536, 0.1412298841621581, 0.15981469617099886, 0.26418187195104237, 0.26870982964705226, 0.25874528100929806, 0.3064703491639722, 0.2500662499671925, 0.2644800079406082, 0.33131713589103984, 0.3183396815116202, 0.30738212868370685, 0.18649837335381914, 0.19969455898075283, 0.18421038539299184, 0.18797266303720295, 0.20435810408763533, 0.1908413306025445, 0.2146364979505052, 0.24456449859464402, 0.2001807831745276, 0.17859338646962553, 0.18063104436694088, 0.18332531506107663, 0.20444214240141378, 0.1793063274572705, 0.18611928376751696, 0.18573262003915725, 0.18397410028596262, 0.1997801610578368, 0.17847216120473153, 0.1954548905034027, 0.182861586524662, 0.18851199609235014, 0.19758660266162764, 0.19035329981486682, 0.17929391223843105, 0.1824442840542777, 0.17689823713164754, 0.3784920486412666, 0.1667428456304595, 0.16554287274272705, 0.2841673105721588, 0.4838170183035404, 0.1752676788601646, 0.4225698913687913, 0.15447576210824587, 0.1830355979068231, 0.28368949023811574, 0.16339962345436798, 0.18507941969981312, 0.193522335066174, 0.22399733663995058, 0.18923604279366857, 0.2042965666616866, 0.1949685246117625, 0.20583458758772732, 0.19962116538365526, 0.17205496581370805, 0.20161553678216892, 0.18284372510054703, 0.1726214113407144, 0.19165193334195196, 0.16582320834289732, 0.17423604309695584, 0.1837325230970941, 0.081078915421821, 0.07296233557417253, 0.07871198352184294, 0.07612788789150005, 0.07230465041416478, 0.0743426638601331, 0.09037223410122219, 0.07909328403317906, 0.07320622485634143]}, "mutation_prompt": null}
{"id": "c56c2a86-6723-465a-9c8e-f9016955b199", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)  # Adjusted F for improved exploration\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)  # Dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))  # Adjusted step size\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))  # Dynamic population size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):  # Use current dynamic population size\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Enhanced Adaptive Scatter Search with Adaptive Learning Rates and Dynamic Population Size for Improved Exploration.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3c4363a1-3c0c-4d17-9722-2a47b2bda92b", "metadata": {"aucs": [0.738201287656756, 0.7691982510680817, 0.7616170017383036, 0.7723575324811431, 0.7724143292883717, 0.7688710022810007, 0.7512446754439891, 0.7737289031660515, 0.747700039125325, 0.5689266285009613, 0.5398818242247032, 0.46751690649494837, 0.4780181255411625, 0.613687949795267, 0.5997491730795946, 0.574816064747095, 0.5573715411322453, 0.5852184759756376, 0.10966790138022553, 0.12301450535901681, 0.10725849225359396, 0.13279294841588418, 0.1104369648033171, 0.1423742076308523, 0.10823593931867981, 0.11015593174838034, 0.10520574534032001, 0.10054779669414415, 0.10399688123947581, 0.10346094475768586, 0.10186074493853503, 0.10932028919258852, 0.09934785280569436, 0.0989634460035822, 0.10489817243660271, 0.09042903645556777, 0.9058528281041253, 0.8756868138220796, 0.9329918273098777, 0.9266115455863444, 0.9616951025354443, 0.9206299193373818, 0.9018297525137864, 0.9202644425221242, 0.9244480982294093, 0.38252185857230125, 0.396427085105057, 0.394594926275472, 0.3594779877828841, 0.38923654638793526, 0.3880412259202636, 0.3553553494759175, 0.33429895865391446, 0.3647241541709868, 0.6572144992694362, 0.6807299858277391, 0.7218511665870344, 0.6421851761743829, 0.7257170667927136, 0.7518703107118334, 0.7358011177909592, 0.7099794790785467, 0.658473385690538, 0.1819259566191398, 0.19793144623295944, 0.21303686137792444, 0.21959339527261212, 0.3273930104371261, 0.11769874152001669, 0.20716196610756465, 0.18265644175254425, 0.1804099559800334, 0.15748908335825285, 0.16925280944444876, 0.24220574391753535, 0.27035207350338786, 0.18984715468295177, 0.20322076661482247, 0.21599246621821844, 0.18737397494746777, 0.1766899408348136, 0.13425710030704163, 0.181156431768149, 0.2209722105798636, 0.07956030284305671, 0.13857132875184885, 0.09526848813928135, 0.2499352302347374, 0.23382541650695543, 0.2603401423982302, 0.25359847041188965, 0.3210433434576354, 0.3552326595742671, 0.1432309210738556, 0.18033704368678483, 0.24180329680886625, 0.439520367908537, 0.39419504191519494, 0.21859726332918195, 0.09422645278524322, 0.06952732658422922, 0.07692071355693475, 0.05653788825965056, 0.12485087693001518, 0.1548583066274738, 0.07438429743482011, 0.1523604378651937, 0.11744376089214348, 0.21279630481763323, 0.20548057708376943, 0.2135360132648989, 0.23450348653200204, 0.21731694654001543, 0.22480860677681247, 0.2049641143344083, 0.2407594935734202, 0.23787500628041336, 0.6240672973122611, 0.5892645452771447, 0.553574757003642, 0.5761107324147166, 0.5800855593334139, 0.5870270313802208, 0.5323267730773815, 0.5768101328465619, 0.6101327316615441, 0.10285983149207245, 0.09193794868495275, 0.09650219210126909, 0.09743002946975099, 0.10229944852698214, 0.095341553856368, 0.08408492071922224, 0.08165305606356965, 0.12517539129543132, 0.1496104046986031, 0.13017935319665208, 0.16712629612975938, 0.26602327756620625, 0.18809013917062134, 0.1364682471898956, 0.14265096206992112, 0.1781604465552371, 0.13341576903043373, 0.3353541500365358, 0.3529052437169964, 0.31978863931498236, 0.3523549217516171, 0.33958186408862634, 0.3632628218352757, 0.3444501290322598, 0.36343902509190407, 0.37573126399945844, 0.279611035779293, 0.26426519192325837, 0.24461376274499358, 0.2299220713389939, 0.24790020118363432, 0.22480952252231778, 0.27704789226828797, 0.29316438300858905, 0.2866158235890027, 0.188000272580085, 0.1876590328743989, 0.1943645745770688, 0.18146396941279408, 0.19888740937551952, 0.19045777661456753, 0.20425579742468614, 0.20006969458749868, 0.19551516386593293, 0.19811035342738004, 0.21486665494224166, 0.23832818374834386, 0.21501219286747497, 0.18931118505391564, 0.19654757641040232, 0.1851410346276834, 0.23961408283418018, 0.1974865549862499, 0.6614310551442828, 0.16368222403723287, 0.1627357651532706, 0.17376843773628736, 0.19018164393771153, 0.7329352853700006, 0.5417731141673049, 0.5146793605646893, 0.7307114188261215, 0.16449947521111719, 0.11183706091588297, 0.19360235503654744, 0.18078575252025852, 0.20356962872429085, 0.15084013469482904, 0.4839068991542971, 0.15350922121481925, 0.15069787978977434, 0.19250521031673362, 0.17991098529263072, 0.16733845620330845, 0.17652989821419618, 0.19491060774668512, 0.19207171698891146, 0.17722155471630718, 0.17322502530285588, 0.19539250995653878, 0.08803902699039223, 0.06057531541827743, 0.08293477527804716, 0.08482405180209518, 0.08448617008404058, 0.07778041885266429, 0.08666058065941273, 0.07450552174114222, 0.08035864323804653]}, "mutation_prompt": null}
{"id": "c76a27c3-921a-4981-9cc9-f772f2d471e6", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)  # Adjusted F for improved exploration\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)  # Dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))  # Adjusted step size\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))  # Dynamic population size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):  # Use current dynamic population size\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Enhanced Adaptive Scatter Search with Adaptive Learning Rates and Dynamic Population Size for Improved Exploration.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3c4363a1-3c0c-4d17-9722-2a47b2bda92b", "metadata": {"aucs": [0.738201287656756, 0.7691982510680817, 0.7616170017383036, 0.7723575324811431, 0.7724143292883717, 0.7688710022810007, 0.7512446754439891, 0.7737289031660515, 0.747700039125325, 0.5689266285009613, 0.5398818242247032, 0.46751690649494837, 0.4780181255411625, 0.613687949795267, 0.5997491730795946, 0.574816064747095, 0.5573715411322453, 0.5852184759756376, 0.10966790138022553, 0.12301450535901681, 0.10725849225359396, 0.13279294841588418, 0.1104369648033171, 0.1423742076308523, 0.10823593931867981, 0.11015593174838034, 0.10520574534032001, 0.10054779669414415, 0.10399688123947581, 0.10346094475768586, 0.10186074493853503, 0.10932028919258852, 0.09934785280569436, 0.0989634460035822, 0.10489817243660271, 0.09042903645556777, 0.9058528281041253, 0.8756868138220796, 0.9329918273098777, 0.9266115455863444, 0.9616951025354443, 0.9206299193373818, 0.9018297525137864, 0.9202644425221242, 0.9244480982294093, 0.38252185857230125, 0.396427085105057, 0.394594926275472, 0.3594779877828841, 0.38923654638793526, 0.3880412259202636, 0.3553553494759175, 0.33429895865391446, 0.3647241541709868, 0.6572144992694362, 0.6807299858277391, 0.7218511665870344, 0.6421851761743829, 0.7257170667927136, 0.7518703107118334, 0.7358011177909592, 0.7099794790785467, 0.658473385690538, 0.1819259566191398, 0.19793144623295944, 0.21303686137792444, 0.21959339527261212, 0.3273930104371261, 0.11769874152001669, 0.20716196610756465, 0.18265644175254425, 0.1804099559800334, 0.15748908335825285, 0.16925280944444876, 0.24220574391753535, 0.27035207350338786, 0.18984715468295177, 0.20322076661482247, 0.21599246621821844, 0.18737397494746777, 0.1766899408348136, 0.13425710030704163, 0.181156431768149, 0.2209722105798636, 0.07956030284305671, 0.13857132875184885, 0.09526848813928135, 0.2499352302347374, 0.23382541650695543, 0.2603401423982302, 0.25359847041188965, 0.3210433434576354, 0.3552326595742671, 0.1432309210738556, 0.18033704368678483, 0.24180329680886625, 0.439520367908537, 0.39419504191519494, 0.21859726332918195, 0.09422645278524322, 0.06952732658422922, 0.07692071355693475, 0.05653788825965056, 0.12485087693001518, 0.1548583066274738, 0.07438429743482011, 0.1523604378651937, 0.11744376089214348, 0.21279630481763323, 0.20548057708376943, 0.2135360132648989, 0.23450348653200204, 0.21731694654001543, 0.22480860677681247, 0.2049641143344083, 0.2407594935734202, 0.23787500628041336, 0.6240672973122611, 0.5892645452771447, 0.553574757003642, 0.5761107324147166, 0.5800855593334139, 0.5870270313802208, 0.5323267730773815, 0.5768101328465619, 0.6101327316615441, 0.10285983149207245, 0.09193794868495275, 0.09650219210126909, 0.09743002946975099, 0.10229944852698214, 0.095341553856368, 0.08408492071922224, 0.08165305606356965, 0.12517539129543132, 0.1496104046986031, 0.13017935319665208, 0.16712629612975938, 0.26602327756620625, 0.18809013917062134, 0.1364682471898956, 0.14265096206992112, 0.1781604465552371, 0.13341576903043373, 0.3353541500365358, 0.3529052437169964, 0.31978863931498236, 0.3523549217516171, 0.33958186408862634, 0.3632628218352757, 0.3444501290322598, 0.36343902509190407, 0.37573126399945844, 0.279611035779293, 0.26426519192325837, 0.24461376274499358, 0.2299220713389939, 0.24790020118363432, 0.22480952252231778, 0.27704789226828797, 0.29316438300858905, 0.2866158235890027, 0.188000272580085, 0.1876590328743989, 0.1943645745770688, 0.18146396941279408, 0.19888740937551952, 0.19045777661456753, 0.20425579742468614, 0.20006969458749868, 0.19551516386593293, 0.19811035342738004, 0.21486665494224166, 0.23832818374834386, 0.21501219286747497, 0.18931118505391564, 0.19654757641040232, 0.1851410346276834, 0.23961408283418018, 0.1974865549862499, 0.6614310551442828, 0.16368222403723287, 0.1627357651532706, 0.17376843773628736, 0.19018164393771153, 0.7329352853700006, 0.5417731141673049, 0.5146793605646893, 0.7307114188261215, 0.16449947521111719, 0.11183706091588297, 0.19360235503654744, 0.18078575252025852, 0.20356962872429085, 0.15084013469482904, 0.4839068991542971, 0.15350922121481925, 0.15069787978977434, 0.19250521031673362, 0.17991098529263072, 0.16733845620330845, 0.17652989821419618, 0.19491060774668512, 0.19207171698891146, 0.17722155471630718, 0.17322502530285588, 0.19539250995653878, 0.08803902699039223, 0.06057531541827743, 0.08293477527804716, 0.08482405180209518, 0.08448617008404058, 0.07778041885266429, 0.08666058065941273, 0.07450552174114222, 0.08035864323804653]}, "mutation_prompt": null}
{"id": "a811846c-50f6-43dd-bb8b-177c47cdc91e", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        # Adaptive F for improved exploration and exploitation\n        F = 0.5 + 0.3 * np.sin(self.num_evaluations / self.budget * np.pi)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def stochastic_ranking(self, population, fitness):\n        # Stochastic ranking with bubble sort-like swaps\n        for _ in range(len(population)):\n            for i in range(len(population) - 1):\n                if (np.random.rand() < 0.45) or (fitness[i] > fitness[i + 1]):\n                    population[i], population[i + 1] = population[i + 1], population[i]\n                    fitness[i], fitness[i + 1] = fitness[i + 1], fitness[i]\n        return population, fitness\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            population, fitness = self.stochastic_ranking(population, fitness)  # New ranking\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Enhanced Adaptive Scatter Search with Stochastic Ranking and Adaptive Mutation for Better Handling of Multi-Modal Functions.", "configspace": "", "generation": 14, "fitness": 0.12030958814414615, "feedback": "The algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.12.", "error": "", "parent_id": "3c4363a1-3c0c-4d17-9722-2a47b2bda92b", "metadata": {"aucs": [0.39432140187023856, 0.4398671006204722, 0.4334854499987293, 0.3641362149792745, 0.3530918657092812, 0.3036078952039234, 0.33403442096391467, 0.43569144469791743, 0.36982695053192216, 9.999999999998899e-05, 0.018498843695914036, 0.0024057312147660603, 9.999999999998899e-05, 0.02378159838421745, 0.02931581034825992, 9.999999999998899e-05, 0.007891519944781988, 0.0037845066470280075, 9.999999999998899e-05, 0.03821674929976493, 0.01804815495187362, 0.015236656508794133, 0.0012186513362246743, 0.010609942889060364, 0.018248263482334326, 9.999999999998899e-05, 0.03620465592556266, 9.999999999998899e-05, 0.0248023023459919, 0.01487591191308435, 0.01959972157639278, 9.999999999998899e-05, 0.004616260693491303, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2972553822903956, 0.1203690784887731, 0.13421022393019832, 0.12224073137548697, 0.42116141487192094, 0.3461682540627592, 0.6428588411447766, 0.10060634764394094, 0.4579313225395665, 0.2042934263655638, 0.1839294500794647, 0.25265396227891956, 0.279870344944365, 0.1791854602123698, 0.22293500172830527, 0.23714380972211735, 0.19525573255188844, 0.14405099478964933, 0.10027683525177622, 0.13535251780074764, 0.0896523973606903, 0.06678974530710224, 0.02725496812965944, 0.13518031247141404, 0.14369874253397774, 0.06244997880010228, 0.09477569755086712, 0.07945451185958119, 0.18086132654827114, 0.08151557008857402, 0.005692199301820966, 0.12431747734515397, 0.0913983447529143, 0.0959557593145377, 0.09671859235337776, 0.11558889116074156, 0.13376783706808693, 0.1227966458998151, 0.2117710855553836, 0.11341740580658388, 0.0328128438265054, 0.14386081707109022, 0.00021032627575567897, 0.03487928837700949, 0.07010128530638449, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.023856611611339895, 0.0003471678094276731, 0.00033479047651596705, 0.0013986141290630583, 9.999999999998899e-05, 0.000699476529136378, 0.04278124345315515, 0.06036091296575885, 0.012192070446484515, 9.999999999998899e-05, 0.08258721678163561, 0.03844508245729972, 0.01708478207668962, 0.08209001545306072, 0.03486260295609955, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07437064875474608, 0.010433317856104574, 0.05060744766475678, 0.023939383865621888, 0.07856886641596506, 0.0556102352986374, 0.11285869345693045, 0.09997683015846692, 9.999999999998899e-05, 0.3267842631191563, 0.4353399850859839, 0.14838054695461433, 0.3870671628494575, 0.34280254677591515, 0.3191288401134923, 0.3440891181610499, 0.3515097920136955, 0.39053726252205867, 0.08347425677775899, 0.03923164267597368, 0.011284027207503655, 0.026789719300867376, 9.999999999998899e-05, 0.01759993274736349, 0.016326768987538154, 0.041160685631416394, 0.028074617950273884, 0.1253457440744562, 0.12411356011140995, 0.1276956215196824, 0.1072171901191441, 0.12160623793200409, 0.12623466956313678, 0.2831682321655712, 0.11727877111724083, 0.10501414244783813, 0.14076554843989286, 0.11809284776316675, 0.10359778603806002, 0.1513524908871532, 0.1467795183475593, 0.13043426171755368, 0.12006100214159376, 0.17377774300845283, 0.12869261089194317, 0.061497884760240096, 0.08058936676855388, 0.060354867507710463, 0.09197407178554573, 0.11390070798719298, 0.0774117667765497, 0.07638165825231913, 0.12848077274713776, 0.04208957008777725, 0.13131336973441643, 0.12691730982459393, 0.14686303733340234, 0.13916444525845895, 0.10936230281430415, 0.16280497349919565, 0.134624978572628, 0.12860559073423317, 0.167455557019628, 0.1580411167797947, 0.16335683979220195, 0.210468386382768, 0.1541334546770886, 0.16440818741085728, 0.1439421557587406, 0.166177231760953, 0.16401862970387593, 0.15548933339860305, 0.1388439416699333, 0.16452354256274926, 0.2085855764324045, 0.17236637155622736, 0.1207914665021157, 0.15060058379972308, 0.09989168007027671, 0.13264339694402805, 0.08320181284992179, 0.19765996474260095, 0.15902890286417337, 0.058239922364526686, 0.5032477701293048, 0.19455729659038912, 0.1502939614451667, 0.05858039151528405, 0.33603890973770567, 0.1324924389378368, 0.21013393959342053, 0.17544272567375596, 0.17068238825635418, 0.17518611297278242, 0.16988630503055413, 0.17942873479104726, 0.1700408776573189, 0.17296732144066296, 0.16766950821851168, 0.015744909500762017, 0.0206993993810054, 0.031393493129599714, 0.0435888832279383, 0.04097103293833204, 0.10069431931629802, 0.02177663892395232, 0.03693429688625749, 0.047310288705397]}, "mutation_prompt": null}
{"id": "bd490d7b-6c80-43bd-b719-918de626dc79", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)  # Adjusted F for improved exploration\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)  # Dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))  # Adjusted step size\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))  # Dynamic population size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):  # Use current dynamic population size\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Enhanced Adaptive Scatter Search with Adaptive Learning Rates and Dynamic Population Size for Improved Exploration.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3c4363a1-3c0c-4d17-9722-2a47b2bda92b", "metadata": {"aucs": [0.738201287656756, 0.7691982510680817, 0.7616170017383036, 0.7723575324811431, 0.7724143292883717, 0.7688710022810007, 0.7512446754439891, 0.7737289031660515, 0.747700039125325, 0.5689266285009613, 0.5398818242247032, 0.46751690649494837, 0.4780181255411625, 0.613687949795267, 0.5997491730795946, 0.574816064747095, 0.5573715411322453, 0.5852184759756376, 0.10966790138022553, 0.12301450535901681, 0.10725849225359396, 0.13279294841588418, 0.1104369648033171, 0.1423742076308523, 0.10823593931867981, 0.11015593174838034, 0.10520574534032001, 0.10054779669414415, 0.10399688123947581, 0.10346094475768586, 0.10186074493853503, 0.10932028919258852, 0.09934785280569436, 0.0989634460035822, 0.10489817243660271, 0.09042903645556777, 0.9058528281041253, 0.8756868138220796, 0.9329918273098777, 0.9266115455863444, 0.9616951025354443, 0.9206299193373818, 0.9018297525137864, 0.9202644425221242, 0.9244480982294093, 0.38252185857230125, 0.396427085105057, 0.394594926275472, 0.3594779877828841, 0.38923654638793526, 0.3880412259202636, 0.3553553494759175, 0.33429895865391446, 0.3647241541709868, 0.6572144992694362, 0.6807299858277391, 0.7218511665870344, 0.6421851761743829, 0.7257170667927136, 0.7518703107118334, 0.7358011177909592, 0.7099794790785467, 0.658473385690538, 0.1819259566191398, 0.19793144623295944, 0.21303686137792444, 0.21959339527261212, 0.3273930104371261, 0.11769874152001669, 0.20716196610756465, 0.18265644175254425, 0.1804099559800334, 0.15748908335825285, 0.16925280944444876, 0.24220574391753535, 0.27035207350338786, 0.18984715468295177, 0.20322076661482247, 0.21599246621821844, 0.18737397494746777, 0.1766899408348136, 0.13425710030704163, 0.181156431768149, 0.2209722105798636, 0.07956030284305671, 0.13857132875184885, 0.09526848813928135, 0.2499352302347374, 0.23382541650695543, 0.2603401423982302, 0.25359847041188965, 0.3210433434576354, 0.3552326595742671, 0.1432309210738556, 0.18033704368678483, 0.24180329680886625, 0.439520367908537, 0.39419504191519494, 0.21859726332918195, 0.09422645278524322, 0.06952732658422922, 0.07692071355693475, 0.05653788825965056, 0.12485087693001518, 0.1548583066274738, 0.07438429743482011, 0.1523604378651937, 0.11744376089214348, 0.21279630481763323, 0.20548057708376943, 0.2135360132648989, 0.23450348653200204, 0.21731694654001543, 0.22480860677681247, 0.2049641143344083, 0.2407594935734202, 0.23787500628041336, 0.6240672973122611, 0.5892645452771447, 0.553574757003642, 0.5761107324147166, 0.5800855593334139, 0.5870270313802208, 0.5323267730773815, 0.5768101328465619, 0.6101327316615441, 0.10285983149207245, 0.09193794868495275, 0.09650219210126909, 0.09743002946975099, 0.10229944852698214, 0.095341553856368, 0.08408492071922224, 0.08165305606356965, 0.12517539129543132, 0.1496104046986031, 0.13017935319665208, 0.16712629612975938, 0.26602327756620625, 0.18809013917062134, 0.1364682471898956, 0.14265096206992112, 0.1781604465552371, 0.13341576903043373, 0.3353541500365358, 0.3529052437169964, 0.31978863931498236, 0.3523549217516171, 0.33958186408862634, 0.3632628218352757, 0.3444501290322598, 0.36343902509190407, 0.37573126399945844, 0.279611035779293, 0.26426519192325837, 0.24461376274499358, 0.2299220713389939, 0.24790020118363432, 0.22480952252231778, 0.27704789226828797, 0.29316438300858905, 0.2866158235890027, 0.188000272580085, 0.1876590328743989, 0.1943645745770688, 0.18146396941279408, 0.19888740937551952, 0.19045777661456753, 0.20425579742468614, 0.20006969458749868, 0.19551516386593293, 0.19811035342738004, 0.21486665494224166, 0.23832818374834386, 0.21501219286747497, 0.18931118505391564, 0.19654757641040232, 0.1851410346276834, 0.23961408283418018, 0.1974865549862499, 0.6614310551442828, 0.16368222403723287, 0.1627357651532706, 0.17376843773628736, 0.19018164393771153, 0.7329352853700006, 0.5417731141673049, 0.5146793605646893, 0.7307114188261215, 0.16449947521111719, 0.11183706091588297, 0.19360235503654744, 0.18078575252025852, 0.20356962872429085, 0.15084013469482904, 0.4839068991542971, 0.15350922121481925, 0.15069787978977434, 0.19250521031673362, 0.17991098529263072, 0.16733845620330845, 0.17652989821419618, 0.19491060774668512, 0.19207171698891146, 0.17722155471630718, 0.17322502530285588, 0.19539250995653878, 0.08803902699039223, 0.06057531541827743, 0.08293477527804716, 0.08482405180209518, 0.08448617008404058, 0.07778041885266429, 0.08666058065941273, 0.07450552174114222, 0.08035864323804653]}, "mutation_prompt": null}
{"id": "c43be6c0-6774-4b26-9598-2f69f33c9d63", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.5, 0.9)  # Slightly increased F for more aggressive exploration\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.8 - 0.2 * (self.num_evaluations / self.budget)  # Adjusted crossover probability for gradual convergence\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = 0.1 / (1 + np.exp(-0.1 * self.num_evaluations))  # Reduced step size for finer exploration\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def hybrid_search(self, solution, func):\n        # Hybrid search: combine local search with a random perturbation\n        hybrid_step = np.random.uniform(-0.05, 0.05, self.dim)\n        new_solution = np.clip(solution + hybrid_step, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 15 + int(10 * (1 - (self.num_evaluations / self.budget)))  # Increased dynamic population size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.hybrid_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Enhanced Adaptive Scatter Search with Hybrid Search Strategy and Adaptive Crossover for Improved Convergence.", "configspace": "", "generation": 16, "fitness": 0.22932005566552927, "feedback": "The algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "3c4363a1-3c0c-4d17-9722-2a47b2bda92b", "metadata": {"aucs": [0.6435850315096956, 0.6242326640600446, 0.6431405578410199, 0.6004474993328135, 0.6287767936558661, 0.6740029825693599, 0.631550138071983, 0.6122701242095067, 0.6447264128323577, 0.3621386215284492, 0.3163348073505001, 0.3720980083138382, 0.3350125782675065, 0.33877130825688706, 0.3411807902476681, 0.356961440669062, 0.3869250239207507, 0.38794945437381323, 0.10687162511980075, 0.09673396844009619, 0.09762155243419379, 0.10339266318697993, 0.10794916271259114, 0.10220596130725157, 0.11238453998987952, 0.11349995853610195, 0.1091775231682206, 0.08911820743572296, 0.08815714395614083, 0.09985103762441072, 0.10198667811335949, 0.0893102220487072, 0.10303453069738477, 0.09219909251501945, 0.10319694313227323, 0.09403941690203976, 0.8887082695620734, 0.9496299401662105, 0.9319032369150647, 0.8836594250306868, 0.8603505869112806, 0.946183162932561, 0.8908911994930585, 0.8514693336568708, 0.8907471772932096, 0.22951784720264168, 0.2662854220473516, 0.2565926208265109, 0.23736154639637674, 0.2226790859068124, 0.22193879500498237, 0.2481554559772673, 0.2558248255327634, 0.2783149881183129, 0.24087798835202712, 0.26216564466834624, 0.3283904523222747, 0.26013608794033494, 0.39595375213598905, 0.47295124869623684, 0.38815437371885164, 0.4420806806532456, 0.3259853274909008, 0.1485175422834376, 0.12607216668955334, 0.17383058824699604, 0.1408134965271769, 0.13553101626606145, 0.09821458871328159, 0.17390875418292584, 0.10716945830695024, 0.15267787930728316, 0.14599508707154052, 0.14449456239217362, 0.09773885854989772, 0.17823405571841866, 0.1564110361686306, 0.14716941249857318, 0.1371695628512849, 0.14847968056278227, 0.10099901624770724, 0.03900034119877238, 0.01901157841585377, 0.01903252267636435, 0.02170037046567208, 0.03177180689843495, 0.04979450002862229, 0.04555179739549098, 0.03476705887488074, 0.03833458474605178, 0.12574766936831094, 0.11725467386729671, 0.14657361806120384, 0.12536736995216557, 0.10390037503137373, 0.15494530403924023, 0.1954600173367107, 0.16578523009507384, 0.14990258017644353, 0.020919831197768524, 0.008253827276598513, 9.999999999998899e-05, 0.009992222744920176, 0.006895372093358332, 0.008304664408291473, 0.009076899931388493, 0.02263297276938503, 0.0008176401167907521, 0.10401013160581551, 0.1205536829096816, 0.11765127170194445, 0.1321952173741775, 0.12702748539360642, 0.11732846877966419, 0.09520307783546245, 0.12180933179289355, 0.1126543455096436, 0.4520108883160874, 0.4030998280545016, 0.416003646966409, 0.46209312253778057, 0.4534354659416363, 0.4465542727812064, 0.43533855308132297, 0.4375741794997553, 0.45939768705469064, 0.0711585272587798, 0.10314927869874768, 0.07594622757504477, 0.08397267696802935, 0.06926173332397212, 0.07170930774197426, 0.07601216783262732, 0.07481880046566625, 0.08316508236244113, 0.10925300373441149, 0.11433429563050068, 0.12702391694585946, 0.1317004611305993, 0.13423241224967475, 0.12419954468062167, 0.13981306283006378, 0.13153928684290184, 0.1788634250053539, 0.2565933196164033, 0.25949454763465596, 0.22723475335227528, 0.2711590488396749, 0.2409538723169088, 0.2787724893794492, 0.2968514412409353, 0.2904073632222717, 0.277673684446187, 0.19229897721477285, 0.19779156602020076, 0.16315186772657142, 0.1856782684997651, 0.19456189192995232, 0.1668484770334091, 0.21870735515869566, 0.19674688609880453, 0.21472127336663382, 0.1748535758181693, 0.1773675711534317, 0.18232203800553304, 0.1959372546416822, 0.17216569155823547, 0.1769981544146496, 0.18410291703529513, 0.17642475202530639, 0.196572406898897, 0.19729516273752423, 0.1666140269993075, 0.1784634733183531, 0.19329130987881915, 0.1758097335736255, 0.16759316755347686, 0.17395738248813264, 0.18548819083382084, 0.17114059749202226, 0.4285875073640363, 0.5965922413080772, 0.16021498840663462, 0.23337455746884184, 0.27009005119225693, 0.17207894881305896, 0.1572713381364782, 0.15409424158602725, 0.15775867165491997, 0.16738003451497152, 0.18700280464515806, 0.17996716642782662, 0.1700824494605968, 0.35792800797805446, 0.3200257966339537, 0.20474092122283094, 0.5789075337716147, 0.15335832728913024, 0.17470237598647687, 0.18007977654331475, 0.17561094446590086, 0.18675995623066055, 0.1818903340886442, 0.1809986157205905, 0.18460088861229518, 0.1856027490362948, 0.1811310473583535, 0.0675689366310378, 0.07008634204121078, 0.07720272468092226, 0.07569157175523633, 0.07293710245975837, 0.06791195199246758, 0.0724196675102321, 0.06816056196982423, 0.06811799982456068]}, "mutation_prompt": null}
{"id": "ca7db2bf-9d64-45b7-85c2-9a0a9c9d3210", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.9)  # Broader range for F to enhance exploration\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def stochastic_ranking(self, population, fitness):\n        probabilities = np.random.rand(len(fitness))\n        ranked = sorted(range(len(fitness)), key=lambda i: (fitness[i], probabilities[i]))\n        return [population[i] for i in ranked]\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            population = self.stochastic_ranking(population, fitness)\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Modified Adaptive Scatter Search with Stochastic Ranking for better balance between exploration and exploitation.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('only integer scalar arrays can be converted to a scalar index').", "error": "TypeError('only integer scalar arrays can be converted to a scalar index')", "parent_id": "3c4363a1-3c0c-4d17-9722-2a47b2bda92b", "metadata": {}, "mutation_prompt": null}
{"id": "01071ccf-74ad-4e52-870a-89e1ea23f657", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)  # Adjusted F for improved exploration\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)  # Dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))  # Adjusted step size\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))  # Dynamic population size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):  # Use current dynamic population size\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Enhanced Adaptive Scatter Search with Adaptive Learning Rates and Dynamic Population Size for Improved Exploration.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3c4363a1-3c0c-4d17-9722-2a47b2bda92b", "metadata": {"aucs": [0.738201287656756, 0.7691982510680817, 0.7616170017383036, 0.7723575324811431, 0.7724143292883717, 0.7688710022810007, 0.7512446754439891, 0.7737289031660515, 0.747700039125325, 0.5689266285009613, 0.5398818242247032, 0.46751690649494837, 0.4780181255411625, 0.613687949795267, 0.5997491730795946, 0.574816064747095, 0.5573715411322453, 0.5852184759756376, 0.10966790138022553, 0.12301450535901681, 0.10725849225359396, 0.13279294841588418, 0.1104369648033171, 0.1423742076308523, 0.10823593931867981, 0.11015593174838034, 0.10520574534032001, 0.10054779669414415, 0.10399688123947581, 0.10346094475768586, 0.10186074493853503, 0.10932028919258852, 0.09934785280569436, 0.0989634460035822, 0.10489817243660271, 0.09042903645556777, 0.9058528281041253, 0.8756868138220796, 0.9329918273098777, 0.9266115455863444, 0.9616951025354443, 0.9206299193373818, 0.9018297525137864, 0.9202644425221242, 0.9244480982294093, 0.38252185857230125, 0.396427085105057, 0.394594926275472, 0.3594779877828841, 0.38923654638793526, 0.3880412259202636, 0.3553553494759175, 0.33429895865391446, 0.3647241541709868, 0.6572144992694362, 0.6807299858277391, 0.7218511665870344, 0.6421851761743829, 0.7257170667927136, 0.7518703107118334, 0.7358011177909592, 0.7099794790785467, 0.658473385690538, 0.1819259566191398, 0.19793144623295944, 0.21303686137792444, 0.21959339527261212, 0.3273930104371261, 0.11769874152001669, 0.20716196610756465, 0.18265644175254425, 0.1804099559800334, 0.15748908335825285, 0.16925280944444876, 0.24220574391753535, 0.27035207350338786, 0.18984715468295177, 0.20322076661482247, 0.21599246621821844, 0.18737397494746777, 0.1766899408348136, 0.13425710030704163, 0.181156431768149, 0.2209722105798636, 0.07956030284305671, 0.13857132875184885, 0.09526848813928135, 0.2499352302347374, 0.23382541650695543, 0.2603401423982302, 0.25359847041188965, 0.3210433434576354, 0.3552326595742671, 0.1432309210738556, 0.18033704368678483, 0.24180329680886625, 0.439520367908537, 0.39419504191519494, 0.21859726332918195, 0.09422645278524322, 0.06952732658422922, 0.07692071355693475, 0.05653788825965056, 0.12485087693001518, 0.1548583066274738, 0.07438429743482011, 0.1523604378651937, 0.11744376089214348, 0.21279630481763323, 0.20548057708376943, 0.2135360132648989, 0.23450348653200204, 0.21731694654001543, 0.22480860677681247, 0.2049641143344083, 0.2407594935734202, 0.23787500628041336, 0.6240672973122611, 0.5892645452771447, 0.553574757003642, 0.5761107324147166, 0.5800855593334139, 0.5870270313802208, 0.5323267730773815, 0.5768101328465619, 0.6101327316615441, 0.10285983149207245, 0.09193794868495275, 0.09650219210126909, 0.09743002946975099, 0.10229944852698214, 0.095341553856368, 0.08408492071922224, 0.08165305606356965, 0.12517539129543132, 0.1496104046986031, 0.13017935319665208, 0.16712629612975938, 0.26602327756620625, 0.18809013917062134, 0.1364682471898956, 0.14265096206992112, 0.1781604465552371, 0.13341576903043373, 0.3353541500365358, 0.3529052437169964, 0.31978863931498236, 0.3523549217516171, 0.33958186408862634, 0.3632628218352757, 0.3444501290322598, 0.36343902509190407, 0.37573126399945844, 0.279611035779293, 0.26426519192325837, 0.24461376274499358, 0.2299220713389939, 0.24790020118363432, 0.22480952252231778, 0.27704789226828797, 0.29316438300858905, 0.2866158235890027, 0.188000272580085, 0.1876590328743989, 0.1943645745770688, 0.18146396941279408, 0.19888740937551952, 0.19045777661456753, 0.20425579742468614, 0.20006969458749868, 0.19551516386593293, 0.19811035342738004, 0.21486665494224166, 0.23832818374834386, 0.21501219286747497, 0.18931118505391564, 0.19654757641040232, 0.1851410346276834, 0.23961408283418018, 0.1974865549862499, 0.6614310551442828, 0.16368222403723287, 0.1627357651532706, 0.17376843773628736, 0.19018164393771153, 0.7329352853700006, 0.5417731141673049, 0.5146793605646893, 0.7307114188261215, 0.16449947521111719, 0.11183706091588297, 0.19360235503654744, 0.18078575252025852, 0.20356962872429085, 0.15084013469482904, 0.4839068991542971, 0.15350922121481925, 0.15069787978977434, 0.19250521031673362, 0.17991098529263072, 0.16733845620330845, 0.17652989821419618, 0.19491060774668512, 0.19207171698891146, 0.17722155471630718, 0.17322502530285588, 0.19539250995653878, 0.08803902699039223, 0.06057531541827743, 0.08293477527804716, 0.08482405180209518, 0.08448617008404058, 0.07778041885266429, 0.08666058065941273, 0.07450552174114222, 0.08035864323804653]}, "mutation_prompt": null}
{"id": "1781f53c-d427-415b-b341-51b757b0883a", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.", "configspace": "", "generation": 19, "fitness": 0.3185678771052579, "feedback": "The algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.", "error": "", "parent_id": "3c4363a1-3c0c-4d17-9722-2a47b2bda92b", "metadata": {"aucs": [0.8155080130564687, 0.7559033804976276, 0.7905083647019924, 0.7706365799583045, 0.7720004892919544, 0.7593470219345677, 0.7537370188105208, 0.760038582709117, 0.7688127909607124, 0.5655881478001787, 0.5774910683303923, 0.5640605575423558, 0.5925450739444624, 0.572418207547452, 0.6097388193042579, 0.5556425429128315, 0.5794651159433983, 0.4865324343657187, 0.10943136396215947, 0.09551252924468845, 0.19098254722941055, 0.1241651193987725, 0.11679336299777643, 0.11247960589287809, 0.16658243415655982, 0.1632262133238752, 0.11016878883262637, 0.10253476795804106, 0.10701880832640687, 0.11420581915681427, 0.0991033430946705, 0.09434269006753326, 0.09919209965355336, 0.0899865563697555, 0.0976362981869745, 0.10370745962354033, 0.923371693436908, 0.9363393286271675, 0.9608986395726264, 0.9463349414245236, 0.9247224580034754, 0.9279701146332561, 0.9364984422653984, 0.892427483563698, 0.9327239774445928, 0.38961470800148157, 0.3963780867715607, 0.3686744308588069, 0.3515614301952177, 0.38238093954163144, 0.43305139347151844, 0.41129460015236496, 0.3709672897802697, 0.41145014541706304, 0.6318642824223506, 0.6570223002505244, 0.6689572208121993, 0.7081456948982934, 0.7229000682226474, 0.6888472264719517, 0.7369845083567743, 0.687656214634984, 0.6319416473784123, 0.20893564626953753, 0.16228156593626775, 0.17338691928834882, 0.17647999228280753, 0.24285597991865826, 0.16118881822081088, 0.24473973831693185, 0.16551774375254769, 0.23476747011081156, 0.14383782780042698, 0.20626465327264576, 0.15773475133562065, 0.170206041048668, 0.21390758419115674, 0.21210583976041686, 0.20367153521640124, 0.24212705844334348, 0.2874615594205191, 0.24943938636657104, 0.1516988015971077, 0.14246514859489356, 0.16179380538329502, 0.05283406603146834, 0.16399208308360724, 0.08230390917160779, 0.23903450289247374, 0.19828219686521076, 0.38785787456595877, 0.1944053508152328, 0.20255903876423798, 0.30903918241211026, 0.08832873300199118, 0.2857456767736388, 0.2542965026183789, 0.3312113038170096, 0.26096961762957693, 0.1340230634623918, 0.06850336774886201, 0.0776777271545539, 0.13454392931627845, 0.16769666118628357, 0.13932391155391777, 0.19572413483334838, 0.10905776980095017, 0.07939909619366403, 0.21869671965659854, 0.24069183744191902, 0.2449777441711366, 0.24249713021935504, 0.22925334786160378, 0.21948998938137942, 0.22631154759998884, 0.13903149065133602, 0.2123170410292312, 0.592410353772121, 0.5684522966706104, 0.620032363275939, 0.5112054176539589, 0.5671683914164736, 0.5588984269431831, 0.5721274467175509, 0.6286008067195519, 0.4918649782488407, 0.1012396790249328, 0.0902208929203181, 0.09910907027098126, 0.08495686269696978, 0.08939890254541771, 0.10663674442861903, 0.11445232136113026, 0.09868097204222592, 0.09350706528911856, 0.15083767353253552, 0.12925164396279065, 0.12927750175204256, 0.14393042481362028, 0.13517460891076039, 0.16922078480273417, 0.17726654486825955, 0.17899464471903337, 0.14806208923146802, 0.3385064755394417, 0.3420195134293488, 0.37353325323882947, 0.38367508340147016, 0.36743206885613455, 0.3558564247864303, 0.3846914821853128, 0.44415119438478146, 0.30676904999245347, 0.25601381386222477, 0.2826239374327034, 0.2430533894011503, 0.2700414170094949, 0.20531713781403182, 0.25824891401701033, 0.25161223547838085, 0.27354689584154246, 0.2489349943783482, 0.211943166537908, 0.1711755788774303, 0.1829352222178865, 0.18306520226945278, 0.19257543927701726, 0.1886523531768498, 0.1983072573583481, 0.1817123683265266, 0.20729085075393172, 0.1938562863628135, 0.18021484475111627, 0.17425845280891605, 0.21246585147881236, 0.2063308769307325, 0.18989750267968653, 0.2049176702240061, 0.20565710230219647, 0.1965406425342291, 0.7705403016370592, 0.731721010009793, 0.6774948716833766, 0.16940668299918094, 0.18148865100910339, 0.6363469912578363, 0.6058619081548582, 0.6134353036444747, 0.6609550140440952, 0.5626305444830952, 0.20245676549081038, 0.2028523864752264, 0.1997670225341035, 0.16160522813605516, 0.3898407233241753, 0.2085555458785595, 0.2017501609276201, 0.2172740397968571, 0.20267674272573766, 0.19313308227723391, 0.1838331864222783, 0.17655238715641697, 0.17402241032542243, 0.1844822118261935, 0.19108853101452516, 0.1985809825634044, 0.19006367058715223, 0.06864813008708859, 0.0721558288638886, 0.07205634995464061, 0.09150845335842928, 0.08067770296549259, 0.06946006424978224, 0.07282317686083117, 0.08409236261461006, 0.07105247295702777]}, "mutation_prompt": null}
{"id": "59fb1a21-89a4-4860-b2ea-f8b11f3f121c", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  \n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n    \n    def stochastic_ranking(self, population, fitness):\n        idxs = np.arange(len(population))\n        for i in range(len(population) - 1):\n            for j in range(len(population) - 1 - i):\n                p = np.random.rand()\n                if (p < 0.45 and fitness[idxs[j]] > fitness[idxs[j + 1]]) or (fitness[idxs[j]] > fitness[idxs[j + 1]]):\n                    idxs[j], idxs[j + 1] = idxs[j + 1], idxs[j]\n        return population[idxs], fitness[idxs]\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n            population, fitness = self.stochastic_ranking(population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Improved Adaptive Scatter Search with Stochastic Ranking for Balanced Exploration and Exploitation in Black Box Optimization.", "configspace": "", "generation": 20, "fitness": 0.31522286387129284, "feedback": "The algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.", "error": "", "parent_id": "1781f53c-d427-415b-b341-51b757b0883a", "metadata": {"aucs": [0.7343988638002972, 0.7534989115053842, 0.7627722388638153, 0.7264199144929244, 0.7613096344604373, 0.7720007167624645, 0.7507792090848235, 0.7737444940095297, 0.7531562282417847, 0.5873173058266703, 0.582465105149223, 0.5043129806504726, 0.5726724371799379, 0.5247089070356816, 0.5117915878305914, 0.5337125602179968, 0.5776235325450523, 0.5698595984935109, 0.10510040796908993, 0.09921122058701459, 0.11074907914301946, 0.10829033886228667, 0.10718785934883979, 0.10269167988210792, 0.12022376216596475, 0.09830790543129564, 0.09458780775811138, 0.1026313262289077, 0.10801325237272197, 0.10058021800841255, 0.08355726668210517, 0.09159873698383103, 0.11775929175388045, 0.10622092078533263, 0.0903886810958422, 0.10122099412612973, 0.9427184722987452, 0.960395624847632, 0.8712459202145707, 0.8938114993487152, 0.9457060693770134, 0.9789996209898832, 0.9076078350910539, 0.9384942596937782, 0.9469772368951237, 0.3889387611472366, 0.42412469801275077, 0.40556357631151263, 0.4019266597309201, 0.3743825964609022, 0.38235448906775005, 0.3646478533342604, 0.3634696994086849, 0.28908558714695465, 0.7471878505070031, 0.696241345575235, 0.6283319607957081, 0.621709546366747, 0.4006817713271049, 0.720654563549124, 0.71373789066284, 0.7040107109436682, 0.6792516791017355, 0.17593211102526096, 0.2002745977852085, 0.1676096876845108, 0.16967698260884445, 0.15016772632777486, 0.20051857648260796, 0.22295640399215833, 0.15759625429693092, 0.2370446169462106, 0.18133097003855658, 0.3746997480752714, 0.19744075029046537, 0.18997482077523953, 0.14105722801737486, 0.14676517302867975, 0.15942085780660986, 0.17930052988752943, 0.15544527666685704, 0.13878968255683177, 0.23004987320854053, 0.20862297444151878, 0.23022822261239861, 0.16307499613287746, 0.013300260888421733, 0.04532494081905314, 0.17981085727473745, 0.15680614718904584, 0.30513512802191123, 0.17250170387329855, 0.36254915732427684, 0.3656210510711716, 0.2930780746919497, 0.1880295051030797, 0.3695835601789955, 0.42109737622361854, 0.23989662825944302, 0.10005151317774796, 0.08426040744726593, 0.05829440253992657, 0.06390376062826342, 0.11764894955099081, 0.12277739740575344, 0.15476639020385496, 0.08332341263472187, 0.0942228660172928, 0.22182256091531805, 0.2028442768503259, 0.17251626402709608, 0.20745363283096707, 0.22023358819338879, 0.204093853397607, 0.17817544059805202, 0.25107437981765535, 0.2099130767109041, 0.5967103375559697, 0.6540353596552487, 0.6049514197640946, 0.5369063250230983, 0.49925091216530604, 0.649163505936803, 0.49206939654271675, 0.5855211817089083, 0.6338890904739058, 0.09471281477092597, 0.08860425060450128, 0.08105308224615693, 0.09923327129589421, 0.08026362284649435, 0.08286231783181242, 0.0903987765502976, 0.0883918000402738, 0.08603659939659536, 0.18363827099944685, 0.1391041533321652, 0.20873339181362693, 0.134033145205121, 0.20245943808713895, 0.1604584018594205, 0.20469962474903414, 0.15150091789980036, 0.1415695597747164, 0.3222189613711569, 0.33390390089903355, 0.3351278161062087, 0.34653704475988734, 0.3408627868970524, 0.33681804529197645, 0.3562860875919318, 0.38178386173304135, 0.33272225866848326, 0.2848876999164879, 0.2477954349321574, 0.22329508982409996, 0.23359786030034735, 0.28610091680053473, 0.2549492655381289, 0.24946999719185214, 0.29768850797743907, 0.2370181454238326, 0.2171935921550373, 0.20458211931791792, 0.20587999400766488, 0.18104046150243525, 0.19097038886344297, 0.18944448604086128, 0.19852734345327838, 0.20250326230896876, 0.20653085013624128, 0.1915849327260567, 0.17643322042232612, 0.1899470988472466, 0.23021526876726894, 0.19135431870036623, 0.1851168778796496, 0.18012448272447779, 0.18879118304880382, 0.18885987374701896, 0.7645673119765752, 0.1758059456565494, 0.18926298938802089, 0.7562381273168188, 0.1834268943683134, 0.7740211932539159, 0.6507480916936499, 0.1872980867797076, 0.17073038984001032, 0.7357837467744557, 0.5577239810062584, 0.1994543243897895, 0.15774476272641147, 0.33803233538116206, 0.708506916680886, 0.205058026517834, 0.6107480531778261, 0.38714762588527796, 0.18019102627397843, 0.1687344867706222, 0.18617098845560165, 0.191347645729524, 0.17886997588812936, 0.17126733552170315, 0.18207120505710828, 0.18743615541487957, 0.17226584031876957, 0.07654814130307719, 0.0739706680392137, 0.08306163180397308, 0.08776655151142643, 0.08027151830563994, 0.07646049323120552, 0.07826068118099971, 0.07358130413456188, 0.06593836234665795]}, "mutation_prompt": null}
{"id": "f86f1622-1013-459f-b52f-84cc9a985b2f", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1781f53c-d427-415b-b341-51b757b0883a", "metadata": {"aucs": [0.8155080130564687, 0.7559033804976276, 0.7905083647019924, 0.7706365799583045, 0.7720004892919544, 0.7593470219345677, 0.7537370188105208, 0.760038582709117, 0.7688127909607124, 0.5655881478001787, 0.5774910683303923, 0.5640605575423558, 0.5925450739444624, 0.572418207547452, 0.6097388193042579, 0.5556425429128315, 0.5794651159433983, 0.4865324343657187, 0.10943136396215947, 0.09551252924468845, 0.19098254722941055, 0.1241651193987725, 0.11679336299777643, 0.11247960589287809, 0.16658243415655982, 0.1632262133238752, 0.11016878883262637, 0.10253476795804106, 0.10701880832640687, 0.11420581915681427, 0.0991033430946705, 0.09434269006753326, 0.09919209965355336, 0.0899865563697555, 0.0976362981869745, 0.10370745962354033, 0.923371693436908, 0.9363393286271675, 0.9608986395726264, 0.9463349414245236, 0.9247224580034754, 0.9279701146332561, 0.9364984422653984, 0.892427483563698, 0.9327239774445928, 0.38961470800148157, 0.3963780867715607, 0.3686744308588069, 0.3515614301952177, 0.38238093954163144, 0.43305139347151844, 0.41129460015236496, 0.3709672897802697, 0.41145014541706304, 0.6318642824223506, 0.6570223002505244, 0.6689572208121993, 0.7081456948982934, 0.7229000682226474, 0.6888472264719517, 0.7369845083567743, 0.687656214634984, 0.6319416473784123, 0.20893564626953753, 0.16228156593626775, 0.17338691928834882, 0.17647999228280753, 0.24285597991865826, 0.16118881822081088, 0.24473973831693185, 0.16551774375254769, 0.23476747011081156, 0.14383782780042698, 0.20626465327264576, 0.15773475133562065, 0.170206041048668, 0.21390758419115674, 0.21210583976041686, 0.20367153521640124, 0.24212705844334348, 0.2874615594205191, 0.24943938636657104, 0.1516988015971077, 0.14246514859489356, 0.16179380538329502, 0.05283406603146834, 0.16399208308360724, 0.08230390917160779, 0.23903450289247374, 0.19828219686521076, 0.38785787456595877, 0.1944053508152328, 0.20255903876423798, 0.30903918241211026, 0.08832873300199118, 0.2857456767736388, 0.2542965026183789, 0.3312113038170096, 0.26096961762957693, 0.1340230634623918, 0.06850336774886201, 0.0776777271545539, 0.13454392931627845, 0.16769666118628357, 0.13932391155391777, 0.19572413483334838, 0.10905776980095017, 0.07939909619366403, 0.21869671965659854, 0.24069183744191902, 0.2449777441711366, 0.24249713021935504, 0.22925334786160378, 0.21948998938137942, 0.22631154759998884, 0.13903149065133602, 0.2123170410292312, 0.592410353772121, 0.5684522966706104, 0.620032363275939, 0.5112054176539589, 0.5671683914164736, 0.5588984269431831, 0.5721274467175509, 0.6286008067195519, 0.4918649782488407, 0.1012396790249328, 0.0902208929203181, 0.09910907027098126, 0.08495686269696978, 0.08939890254541771, 0.10663674442861903, 0.11445232136113026, 0.09868097204222592, 0.09350706528911856, 0.15083767353253552, 0.12925164396279065, 0.12927750175204256, 0.14393042481362028, 0.13517460891076039, 0.16922078480273417, 0.17726654486825955, 0.17899464471903337, 0.14806208923146802, 0.3385064755394417, 0.3420195134293488, 0.37353325323882947, 0.38367508340147016, 0.36743206885613455, 0.3558564247864303, 0.3846914821853128, 0.44415119438478146, 0.30676904999245347, 0.25601381386222477, 0.2826239374327034, 0.2430533894011503, 0.2700414170094949, 0.20531713781403182, 0.25824891401701033, 0.25161223547838085, 0.27354689584154246, 0.2489349943783482, 0.211943166537908, 0.1711755788774303, 0.1829352222178865, 0.18306520226945278, 0.19257543927701726, 0.1886523531768498, 0.1983072573583481, 0.1817123683265266, 0.20729085075393172, 0.1938562863628135, 0.18021484475111627, 0.17425845280891605, 0.21246585147881236, 0.2063308769307325, 0.18989750267968653, 0.2049176702240061, 0.20565710230219647, 0.1965406425342291, 0.7705403016370592, 0.731721010009793, 0.6774948716833766, 0.16940668299918094, 0.18148865100910339, 0.6363469912578363, 0.6058619081548582, 0.6134353036444747, 0.6609550140440952, 0.5626305444830952, 0.20245676549081038, 0.2028523864752264, 0.1997670225341035, 0.16160522813605516, 0.3898407233241753, 0.2085555458785595, 0.2017501609276201, 0.2172740397968571, 0.20267674272573766, 0.19313308227723391, 0.1838331864222783, 0.17655238715641697, 0.17402241032542243, 0.1844822118261935, 0.19108853101452516, 0.1985809825634044, 0.19006367058715223, 0.06864813008708859, 0.0721558288638886, 0.07205634995464061, 0.09150845335842928, 0.08067770296549259, 0.06946006424978224, 0.07282317686083117, 0.08409236261461006, 0.07105247295702777]}, "mutation_prompt": null}
{"id": "185d1d18-dc59-44bb-b68e-8e7c1060bf90", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.5, 0.9)  # Adjusted F for better exploration\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.8 + 0.1 * np.sin((self.num_evaluations / self.budget) * np.pi)  # Dynamic crossover\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.1 + 0.1 * (1 - self.num_evaluations / self.budget)  # Adaptive step size\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Enhanced Adaptive Scatter Search with Dynamic Crossover and Adaptive Step Size for Improved Exploration and Exploitation.", "configspace": "", "generation": 22, "fitness": 0.2808377513148956, "feedback": "The algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.23.", "error": "", "parent_id": "1781f53c-d427-415b-b341-51b757b0883a", "metadata": {"aucs": [0.7079171086635647, 0.6780640960348465, 0.7077227596163896, 0.7415276503377628, 0.6879459271174162, 0.6925895694833928, 0.6874157675801555, 0.710249434167977, 0.6991714662569585, 0.5022818703986314, 0.4669078223298653, 0.4875972493986591, 0.4616094907941728, 0.4240391630166733, 0.47477183111531807, 0.49985453865973284, 0.4796678100885674, 0.5019083985013372, 0.11257036336034121, 0.10006390042674829, 0.09984137126249004, 0.10769106968119291, 0.09408271915411592, 0.1284121494496141, 0.09767458505555315, 0.11113447125620624, 0.10064197372177786, 0.08808050462353767, 0.09133092094593886, 0.09414013748137573, 0.10244531685778147, 0.08660533814082028, 0.096187956576955, 0.09397522521189328, 0.09579498104604045, 0.09681503929471769, 0.9511192180067654, 0.9621679406045733, 0.919364589469788, 0.9433679609126892, 0.9461609282490346, 0.9575278852414196, 0.9137463538130768, 0.9313651439139131, 0.948927240562696, 0.3229977456547557, 0.31136931755291697, 0.3110909594560989, 0.34898179552289366, 0.30675730015347746, 0.35447310705913315, 0.3722966773161813, 0.3263904824733552, 0.3378714376888261, 0.6844131223026064, 0.47300080913014275, 0.6257841345105379, 0.6071529736601268, 0.6913241504189764, 0.5925287529218923, 0.46166351657050286, 0.5730722324439086, 0.5822888837870014, 0.18138289440567346, 0.2520693840457142, 0.13048222967375733, 0.19148290481787433, 0.18140189817175023, 0.12917327370200693, 0.22569376951052433, 0.17187005510476394, 0.21702911242052247, 0.14951984458371148, 0.18465509242816558, 0.1990365411391929, 0.20159142719716905, 0.2111795948172206, 0.2186283391839785, 0.2003130774562022, 0.150523723694583, 0.1821992019006945, 0.13872919079564272, 0.1285589027602304, 0.10852161638260072, 0.14149128646240083, 0.11260347847112173, 0.1380563493363567, 0.12979995413693068, 0.1372240429976449, 0.19805365154903498, 0.25016731845293905, 0.1960550639132579, 0.22295567142545947, 0.25438572121165215, 0.14167388370176637, 0.19643013323141534, 0.2515702523442548, 0.3064424188980238, 0.3448320416948355, 0.0414559390854633, 0.021768318192720848, 0.03188410595083602, 0.0658881403850794, 0.045575086231482986, 0.0839572754283292, 0.01829932263587175, 0.03520652742297192, 0.07770994276390653, 0.17199505650508506, 0.1582919086756166, 0.16406526193952942, 0.16665887001832413, 0.15111703401590515, 0.17949819535777078, 0.1607555032717808, 0.17305403722181456, 0.15890750080468974, 0.5431454630727601, 0.5762109316743974, 0.5677079278596024, 0.5458931833114337, 0.5076167992450257, 0.5026117395494963, 0.5209397844668554, 0.5369072670277478, 0.5581815394352795, 0.07784031759649701, 0.10009799367270955, 0.10690314522721345, 0.09857942257208308, 0.09415518037349724, 0.07788060637989569, 0.07621200615947932, 0.08589942006226026, 0.09111789563037365, 0.1284636211626623, 0.1385794516107055, 0.1533147681668181, 0.13242225635628257, 0.16632539207285757, 0.13751600625087468, 0.14543887771888675, 0.12137466348652692, 0.1320959651796766, 0.3191310981480242, 0.3263880387380642, 0.2973849326969801, 0.27088389172125904, 0.25920604797720315, 0.28635809305653515, 0.33968057207414837, 0.306040199476863, 0.2909180283623335, 0.228474216918908, 0.2134973542778158, 0.22412797173782206, 0.22122595838265147, 0.20135163019531221, 0.21891577824953878, 0.24831626834874254, 0.251520910578528, 0.2220680132874282, 0.169288687895928, 0.17864249839405988, 0.168687689396805, 0.16482368034732586, 0.20655124408354109, 0.18041137594372048, 0.1717578848193796, 0.18030261176857798, 0.19022815160234707, 0.17297484941080687, 0.1800953255364247, 0.17777314397868416, 0.17991799001338482, 0.17563092959786386, 0.17625209649103069, 0.1743415632607388, 0.17591251788956075, 0.18173140075715433, 0.749487987307405, 0.1667545667153847, 0.17663663741953606, 0.6473099083861694, 0.16945362722224944, 0.17124438733324243, 0.18818574870897609, 0.18986527568383604, 0.13817180463379153, 0.610316246892251, 0.18516060527785672, 0.6227090339725474, 0.19400890091059897, 0.17202798817679288, 0.6325464311621931, 0.20732316239376192, 0.2077889032793654, 0.19930696778335233, 0.18870681104179943, 0.1829077735289104, 0.17338343161936587, 0.17299527293595873, 0.18528738687978552, 0.21179577975026664, 0.18089477832199774, 0.19031392781666012, 0.18749347890120127, 0.06369624772852567, 0.08469073072009325, 0.06798089520797179, 0.08574351726090024, 0.06887467277871806, 0.08440142495085379, 0.06423142756127653, 0.06420030172558033, 0.07300796685881883]}, "mutation_prompt": null}
{"id": "b36c63ac-4ef1-4c6e-9b4a-829ee7ccdf23", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1781f53c-d427-415b-b341-51b757b0883a", "metadata": {"aucs": [0.8155080130564687, 0.7559033804976276, 0.7905083647019924, 0.7706365799583045, 0.7720004892919544, 0.7593470219345677, 0.7537370188105208, 0.760038582709117, 0.7688127909607124, 0.5655881478001787, 0.5774910683303923, 0.5640605575423558, 0.5925450739444624, 0.572418207547452, 0.6097388193042579, 0.5556425429128315, 0.5794651159433983, 0.4865324343657187, 0.10943136396215947, 0.09551252924468845, 0.19098254722941055, 0.1241651193987725, 0.11679336299777643, 0.11247960589287809, 0.16658243415655982, 0.1632262133238752, 0.11016878883262637, 0.10253476795804106, 0.10701880832640687, 0.11420581915681427, 0.0991033430946705, 0.09434269006753326, 0.09919209965355336, 0.0899865563697555, 0.0976362981869745, 0.10370745962354033, 0.923371693436908, 0.9363393286271675, 0.9608986395726264, 0.9463349414245236, 0.9247224580034754, 0.9279701146332561, 0.9364984422653984, 0.892427483563698, 0.9327239774445928, 0.38961470800148157, 0.3963780867715607, 0.3686744308588069, 0.3515614301952177, 0.38238093954163144, 0.43305139347151844, 0.41129460015236496, 0.3709672897802697, 0.41145014541706304, 0.6318642824223506, 0.6570223002505244, 0.6689572208121993, 0.7081456948982934, 0.7229000682226474, 0.6888472264719517, 0.7369845083567743, 0.687656214634984, 0.6319416473784123, 0.20893564626953753, 0.16228156593626775, 0.17338691928834882, 0.17647999228280753, 0.24285597991865826, 0.16118881822081088, 0.24473973831693185, 0.16551774375254769, 0.23476747011081156, 0.14383782780042698, 0.20626465327264576, 0.15773475133562065, 0.170206041048668, 0.21390758419115674, 0.21210583976041686, 0.20367153521640124, 0.24212705844334348, 0.2874615594205191, 0.24943938636657104, 0.1516988015971077, 0.14246514859489356, 0.16179380538329502, 0.05283406603146834, 0.16399208308360724, 0.08230390917160779, 0.23903450289247374, 0.19828219686521076, 0.38785787456595877, 0.1944053508152328, 0.20255903876423798, 0.30903918241211026, 0.08832873300199118, 0.2857456767736388, 0.2542965026183789, 0.3312113038170096, 0.26096961762957693, 0.1340230634623918, 0.06850336774886201, 0.0776777271545539, 0.13454392931627845, 0.16769666118628357, 0.13932391155391777, 0.19572413483334838, 0.10905776980095017, 0.07939909619366403, 0.21869671965659854, 0.24069183744191902, 0.2449777441711366, 0.24249713021935504, 0.22925334786160378, 0.21948998938137942, 0.22631154759998884, 0.13903149065133602, 0.2123170410292312, 0.592410353772121, 0.5684522966706104, 0.620032363275939, 0.5112054176539589, 0.5671683914164736, 0.5588984269431831, 0.5721274467175509, 0.6286008067195519, 0.4918649782488407, 0.1012396790249328, 0.0902208929203181, 0.09910907027098126, 0.08495686269696978, 0.08939890254541771, 0.10663674442861903, 0.11445232136113026, 0.09868097204222592, 0.09350706528911856, 0.15083767353253552, 0.12925164396279065, 0.12927750175204256, 0.14393042481362028, 0.13517460891076039, 0.16922078480273417, 0.17726654486825955, 0.17899464471903337, 0.14806208923146802, 0.3385064755394417, 0.3420195134293488, 0.37353325323882947, 0.38367508340147016, 0.36743206885613455, 0.3558564247864303, 0.3846914821853128, 0.44415119438478146, 0.30676904999245347, 0.25601381386222477, 0.2826239374327034, 0.2430533894011503, 0.2700414170094949, 0.20531713781403182, 0.25824891401701033, 0.25161223547838085, 0.27354689584154246, 0.2489349943783482, 0.211943166537908, 0.1711755788774303, 0.1829352222178865, 0.18306520226945278, 0.19257543927701726, 0.1886523531768498, 0.1983072573583481, 0.1817123683265266, 0.20729085075393172, 0.1938562863628135, 0.18021484475111627, 0.17425845280891605, 0.21246585147881236, 0.2063308769307325, 0.18989750267968653, 0.2049176702240061, 0.20565710230219647, 0.1965406425342291, 0.7705403016370592, 0.731721010009793, 0.6774948716833766, 0.16940668299918094, 0.18148865100910339, 0.6363469912578363, 0.6058619081548582, 0.6134353036444747, 0.6609550140440952, 0.5626305444830952, 0.20245676549081038, 0.2028523864752264, 0.1997670225341035, 0.16160522813605516, 0.3898407233241753, 0.2085555458785595, 0.2017501609276201, 0.2172740397968571, 0.20267674272573766, 0.19313308227723391, 0.1838331864222783, 0.17655238715641697, 0.17402241032542243, 0.1844822118261935, 0.19108853101452516, 0.1985809825634044, 0.19006367058715223, 0.06864813008708859, 0.0721558288638886, 0.07205634995464061, 0.09150845335842928, 0.08067770296549259, 0.06946006424978224, 0.07282317686083117, 0.08409236261461006, 0.07105247295702777]}, "mutation_prompt": null}
{"id": "56e02139-eeb9-49b4-87e9-33e017d587e9", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.9)  # Adjusted range\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.7 + 0.2 * (1 - (self.num_evaluations / self.budget))  # Inverted logic for diversity\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def hybrid_mutation(self, solution):  # Introduced hybrid mutation\n        perturbation = np.random.normal(0, 0.1, self.dim)\n        return solution + perturbation\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 15 + int(5 * (1 - (self.num_evaluations / self.budget)))  # Dynamic adjustment\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.hybrid_mutation(trial)  # Apply hybrid mutation\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Enhanced Adaptive Scatter Search with Dynamic Population Adjustment and Hybrid Mutation for Accelerated Convergence.", "configspace": "", "generation": 24, "fitness": 0.202923939241537, "feedback": "The algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.19.", "error": "", "parent_id": "1781f53c-d427-415b-b341-51b757b0883a", "metadata": {"aucs": [0.4131421971510105, 0.429084483252156, 0.410226974717229, 0.4250492592429528, 0.40478629755459616, 0.40499556414446247, 0.41263646553946787, 0.41753768552090287, 0.4392302164574291, 0.046465836369075975, 0.028806583985524048, 0.022685362667083653, 0.013398780612049466, 0.017913222989363375, 0.03487128281904206, 0.028924702235291644, 0.036123385840182376, 0.027438776216669458, 0.10117326521872094, 0.10403118027988112, 0.0885853812250813, 0.08642623214099021, 0.10196616145270221, 0.09742353680721794, 0.08644966481619498, 0.09190784885401315, 0.0855132522370603, 0.09351465130892067, 0.08786286815230981, 0.08461310996940341, 0.08613640660484512, 0.08360168469530926, 0.07637801312622705, 0.09272773026299641, 0.07837156129097456, 0.09366997734901361, 0.8822578900830957, 0.9277548236182184, 0.8729297322292595, 0.8996734627854606, 0.9037352640525744, 0.9104251126468479, 0.8787918276142327, 0.9074593407349615, 0.8806000153914009, 0.24309869884108115, 0.23604178320484237, 0.26058011180084895, 0.231471964345211, 0.24035432018763137, 0.26340709846762045, 0.25284927210624164, 0.24499533799429196, 0.2389574549622836, 0.32132922795599894, 0.3093388920829322, 0.32129089126931987, 0.3089423070306909, 0.3373089588618723, 0.3046866366983436, 0.2951775072548667, 0.3080829788906604, 0.3280761648081011, 0.14118071272710675, 0.13870307982836416, 0.13822878239191028, 0.13846573453842737, 0.140050028569496, 0.1336021716195186, 0.14561913269390903, 0.12993890042865608, 0.15764595946660043, 0.15093488710416036, 0.09772033935834712, 0.12667234533344984, 0.14678485271886454, 0.14538373602065457, 0.14638706599315576, 0.14267398224671435, 0.14884508170330024, 0.14514498145378896, 0.0016170951386306198, 9.999999999998899e-05, 9.999999999998899e-05, 0.010270051630854149, 0.01577765576168, 0.007094050801217278, 9.999999999998899e-05, 0.0022668063674289307, 0.031195781241460052, 0.09981952267957517, 0.12388949829701945, 0.08591449587656153, 0.07881126735734556, 0.09151456083777199, 0.06786765432228181, 0.10542742259372695, 0.07637573024380295, 0.09045869982720811, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09022870241660563, 0.09002897643902308, 0.09416100482742096, 0.08505829628742756, 0.09185998693282105, 0.09951942232927247, 0.08698710678500665, 0.08609835076323158, 0.09228313856667769, 0.41235780972598035, 0.3906753243470805, 0.3736429646734535, 0.36818640750539255, 0.39330817617812297, 0.38250632949873264, 0.38400083538691754, 0.37100130262082076, 0.3711637126018973, 0.08107439171743647, 0.09446681539372315, 0.10265739756335057, 0.09869758866745393, 0.09256546634837359, 0.07652044622794252, 0.09054974044481601, 0.08526204738506382, 0.0860775585173329, 0.1444279604886648, 0.12241231765842386, 0.1344539060048312, 0.11675883005804921, 0.1672475606953603, 0.15367017739460864, 0.1729656580862189, 0.1806372378486254, 0.1609692614092817, 0.2786934761037886, 0.26859681027769644, 0.2645794152296891, 0.2718415727375314, 0.2508479830044804, 0.26336803245845375, 0.2851439582816859, 0.2727827672169333, 0.271695958264772, 0.19618077626320496, 0.2046249842110467, 0.2062586733266436, 0.20072424523356192, 0.22091686490492157, 0.20386032989240743, 0.2057912553121286, 0.22469870392199265, 0.19483007775519245, 0.186067057533587, 0.17584681386166412, 0.18421701641916766, 0.18922211112304865, 0.1865377157396758, 0.17670136115642365, 0.18342168378792134, 0.17549835846700113, 0.18129765952675936, 0.17750835192418546, 0.18865085102099488, 0.17037378035286654, 0.18417788969258764, 0.17767991655667903, 0.18261410988615168, 0.19084185084659522, 0.18036149109259436, 0.17880745546475918, 0.5151060552323952, 0.1764758297565, 0.5171898101580432, 0.16404335172073026, 0.18521274102480678, 0.1788673378653992, 0.20354796043566525, 0.16676592277253055, 0.5658443622204548, 0.1647954334423477, 0.19850991741952861, 0.4642865089860094, 0.20098398305225007, 0.30504543543110285, 0.1909832386614123, 0.20707091352575113, 0.40073680645751286, 0.52259598554249, 0.18464974967656855, 0.193660162926532, 0.17962118752108558, 0.19849245057548148, 0.18227325918015347, 0.1774673395253734, 0.19725775673829804, 0.18685754635826546, 0.176775221449204, 0.08224443913107515, 0.0828273693736441, 0.08041624387895807, 0.07818398695716156, 0.07503819378446774, 0.06694513595319185, 0.07722194125179249, 0.07693387650844374, 0.0801311068349072]}, "mutation_prompt": null}
{"id": "166899c7-21c0-43ae-a035-3d8985d6dd0b", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1781f53c-d427-415b-b341-51b757b0883a", "metadata": {"aucs": [0.8155080130564687, 0.7559033804976276, 0.7905083647019924, 0.7706365799583045, 0.7720004892919544, 0.7593470219345677, 0.7537370188105208, 0.760038582709117, 0.7688127909607124, 0.5655881478001787, 0.5774910683303923, 0.5640605575423558, 0.5925450739444624, 0.572418207547452, 0.6097388193042579, 0.5556425429128315, 0.5794651159433983, 0.4865324343657187, 0.10943136396215947, 0.09551252924468845, 0.19098254722941055, 0.1241651193987725, 0.11679336299777643, 0.11247960589287809, 0.16658243415655982, 0.1632262133238752, 0.11016878883262637, 0.10253476795804106, 0.10701880832640687, 0.11420581915681427, 0.0991033430946705, 0.09434269006753326, 0.09919209965355336, 0.0899865563697555, 0.0976362981869745, 0.10370745962354033, 0.923371693436908, 0.9363393286271675, 0.9608986395726264, 0.9463349414245236, 0.9247224580034754, 0.9279701146332561, 0.9364984422653984, 0.892427483563698, 0.9327239774445928, 0.38961470800148157, 0.3963780867715607, 0.3686744308588069, 0.3515614301952177, 0.38238093954163144, 0.43305139347151844, 0.41129460015236496, 0.3709672897802697, 0.41145014541706304, 0.6318642824223506, 0.6570223002505244, 0.6689572208121993, 0.7081456948982934, 0.7229000682226474, 0.6888472264719517, 0.7369845083567743, 0.687656214634984, 0.6319416473784123, 0.20893564626953753, 0.16228156593626775, 0.17338691928834882, 0.17647999228280753, 0.24285597991865826, 0.16118881822081088, 0.24473973831693185, 0.16551774375254769, 0.23476747011081156, 0.14383782780042698, 0.20626465327264576, 0.15773475133562065, 0.170206041048668, 0.21390758419115674, 0.21210583976041686, 0.20367153521640124, 0.24212705844334348, 0.2874615594205191, 0.24943938636657104, 0.1516988015971077, 0.14246514859489356, 0.16179380538329502, 0.05283406603146834, 0.16399208308360724, 0.08230390917160779, 0.23903450289247374, 0.19828219686521076, 0.38785787456595877, 0.1944053508152328, 0.20255903876423798, 0.30903918241211026, 0.08832873300199118, 0.2857456767736388, 0.2542965026183789, 0.3312113038170096, 0.26096961762957693, 0.1340230634623918, 0.06850336774886201, 0.0776777271545539, 0.13454392931627845, 0.16769666118628357, 0.13932391155391777, 0.19572413483334838, 0.10905776980095017, 0.07939909619366403, 0.21869671965659854, 0.24069183744191902, 0.2449777441711366, 0.24249713021935504, 0.22925334786160378, 0.21948998938137942, 0.22631154759998884, 0.13903149065133602, 0.2123170410292312, 0.592410353772121, 0.5684522966706104, 0.620032363275939, 0.5112054176539589, 0.5671683914164736, 0.5588984269431831, 0.5721274467175509, 0.6286008067195519, 0.4918649782488407, 0.1012396790249328, 0.0902208929203181, 0.09910907027098126, 0.08495686269696978, 0.08939890254541771, 0.10663674442861903, 0.11445232136113026, 0.09868097204222592, 0.09350706528911856, 0.15083767353253552, 0.12925164396279065, 0.12927750175204256, 0.14393042481362028, 0.13517460891076039, 0.16922078480273417, 0.17726654486825955, 0.17899464471903337, 0.14806208923146802, 0.3385064755394417, 0.3420195134293488, 0.37353325323882947, 0.38367508340147016, 0.36743206885613455, 0.3558564247864303, 0.3846914821853128, 0.44415119438478146, 0.30676904999245347, 0.25601381386222477, 0.2826239374327034, 0.2430533894011503, 0.2700414170094949, 0.20531713781403182, 0.25824891401701033, 0.25161223547838085, 0.27354689584154246, 0.2489349943783482, 0.211943166537908, 0.1711755788774303, 0.1829352222178865, 0.18306520226945278, 0.19257543927701726, 0.1886523531768498, 0.1983072573583481, 0.1817123683265266, 0.20729085075393172, 0.1938562863628135, 0.18021484475111627, 0.17425845280891605, 0.21246585147881236, 0.2063308769307325, 0.18989750267968653, 0.2049176702240061, 0.20565710230219647, 0.1965406425342291, 0.7705403016370592, 0.731721010009793, 0.6774948716833766, 0.16940668299918094, 0.18148865100910339, 0.6363469912578363, 0.6058619081548582, 0.6134353036444747, 0.6609550140440952, 0.5626305444830952, 0.20245676549081038, 0.2028523864752264, 0.1997670225341035, 0.16160522813605516, 0.3898407233241753, 0.2085555458785595, 0.2017501609276201, 0.2172740397968571, 0.20267674272573766, 0.19313308227723391, 0.1838331864222783, 0.17655238715641697, 0.17402241032542243, 0.1844822118261935, 0.19108853101452516, 0.1985809825634044, 0.19006367058715223, 0.06864813008708859, 0.0721558288638886, 0.07205634995464061, 0.09150845335842928, 0.08067770296549259, 0.06946006424978224, 0.07282317686083117, 0.08409236261461006, 0.07105247295702777]}, "mutation_prompt": null}
{"id": "0f16d83e-caa9-4fd9-a1f4-b93278f305a2", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1781f53c-d427-415b-b341-51b757b0883a", "metadata": {"aucs": [0.8155080130564687, 0.7559033804976276, 0.7905083647019924, 0.7706365799583045, 0.7720004892919544, 0.7593470219345677, 0.7537370188105208, 0.760038582709117, 0.7688127909607124, 0.5655881478001787, 0.5774910683303923, 0.5640605575423558, 0.5925450739444624, 0.572418207547452, 0.6097388193042579, 0.5556425429128315, 0.5794651159433983, 0.4865324343657187, 0.10943136396215947, 0.09551252924468845, 0.19098254722941055, 0.1241651193987725, 0.11679336299777643, 0.11247960589287809, 0.16658243415655982, 0.1632262133238752, 0.11016878883262637, 0.10253476795804106, 0.10701880832640687, 0.11420581915681427, 0.0991033430946705, 0.09434269006753326, 0.09919209965355336, 0.0899865563697555, 0.0976362981869745, 0.10370745962354033, 0.923371693436908, 0.9363393286271675, 0.9608986395726264, 0.9463349414245236, 0.9247224580034754, 0.9279701146332561, 0.9364984422653984, 0.892427483563698, 0.9327239774445928, 0.38961470800148157, 0.3963780867715607, 0.3686744308588069, 0.3515614301952177, 0.38238093954163144, 0.43305139347151844, 0.41129460015236496, 0.3709672897802697, 0.41145014541706304, 0.6318642824223506, 0.6570223002505244, 0.6689572208121993, 0.7081456948982934, 0.7229000682226474, 0.6888472264719517, 0.7369845083567743, 0.687656214634984, 0.6319416473784123, 0.20893564626953753, 0.16228156593626775, 0.17338691928834882, 0.17647999228280753, 0.24285597991865826, 0.16118881822081088, 0.24473973831693185, 0.16551774375254769, 0.23476747011081156, 0.14383782780042698, 0.20626465327264576, 0.15773475133562065, 0.170206041048668, 0.21390758419115674, 0.21210583976041686, 0.20367153521640124, 0.24212705844334348, 0.2874615594205191, 0.24943938636657104, 0.1516988015971077, 0.14246514859489356, 0.16179380538329502, 0.05283406603146834, 0.16399208308360724, 0.08230390917160779, 0.23903450289247374, 0.19828219686521076, 0.38785787456595877, 0.1944053508152328, 0.20255903876423798, 0.30903918241211026, 0.08832873300199118, 0.2857456767736388, 0.2542965026183789, 0.3312113038170096, 0.26096961762957693, 0.1340230634623918, 0.06850336774886201, 0.0776777271545539, 0.13454392931627845, 0.16769666118628357, 0.13932391155391777, 0.19572413483334838, 0.10905776980095017, 0.07939909619366403, 0.21869671965659854, 0.24069183744191902, 0.2449777441711366, 0.24249713021935504, 0.22925334786160378, 0.21948998938137942, 0.22631154759998884, 0.13903149065133602, 0.2123170410292312, 0.592410353772121, 0.5684522966706104, 0.620032363275939, 0.5112054176539589, 0.5671683914164736, 0.5588984269431831, 0.5721274467175509, 0.6286008067195519, 0.4918649782488407, 0.1012396790249328, 0.0902208929203181, 0.09910907027098126, 0.08495686269696978, 0.08939890254541771, 0.10663674442861903, 0.11445232136113026, 0.09868097204222592, 0.09350706528911856, 0.15083767353253552, 0.12925164396279065, 0.12927750175204256, 0.14393042481362028, 0.13517460891076039, 0.16922078480273417, 0.17726654486825955, 0.17899464471903337, 0.14806208923146802, 0.3385064755394417, 0.3420195134293488, 0.37353325323882947, 0.38367508340147016, 0.36743206885613455, 0.3558564247864303, 0.3846914821853128, 0.44415119438478146, 0.30676904999245347, 0.25601381386222477, 0.2826239374327034, 0.2430533894011503, 0.2700414170094949, 0.20531713781403182, 0.25824891401701033, 0.25161223547838085, 0.27354689584154246, 0.2489349943783482, 0.211943166537908, 0.1711755788774303, 0.1829352222178865, 0.18306520226945278, 0.19257543927701726, 0.1886523531768498, 0.1983072573583481, 0.1817123683265266, 0.20729085075393172, 0.1938562863628135, 0.18021484475111627, 0.17425845280891605, 0.21246585147881236, 0.2063308769307325, 0.18989750267968653, 0.2049176702240061, 0.20565710230219647, 0.1965406425342291, 0.7705403016370592, 0.731721010009793, 0.6774948716833766, 0.16940668299918094, 0.18148865100910339, 0.6363469912578363, 0.6058619081548582, 0.6134353036444747, 0.6609550140440952, 0.5626305444830952, 0.20245676549081038, 0.2028523864752264, 0.1997670225341035, 0.16160522813605516, 0.3898407233241753, 0.2085555458785595, 0.2017501609276201, 0.2172740397968571, 0.20267674272573766, 0.19313308227723391, 0.1838331864222783, 0.17655238715641697, 0.17402241032542243, 0.1844822118261935, 0.19108853101452516, 0.1985809825634044, 0.19006367058715223, 0.06864813008708859, 0.0721558288638886, 0.07205634995464061, 0.09150845335842928, 0.08067770296549259, 0.06946006424978224, 0.07282317686083117, 0.08409236261461006, 0.07105247295702777]}, "mutation_prompt": null}
{"id": "fd414b3c-4f8c-4504-9cfb-d7e4395834d2", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def adaptive_differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 1.0) * (1 - (self.num_evaluations / self.budget))\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.8 - 0.2 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def stochastic_local_search(self, solution, func):\n        step_size = 0.15 / (1 + np.exp(-0.1 * self.num_evaluations))\n        perturbation = np.where(np.random.rand(self.dim) < 0.3, self.levy_flight() * step_size, 0)\n        new_solution = solution + perturbation\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.adaptive_differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.stochastic_local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Enhanced Adaptive Scatter Search with Adaptive Differential Mutation and Stochastic Local Search for Improved Exploration-Exploitation Balance.", "configspace": "", "generation": 27, "fitness": 0.2761404483014812, "feedback": "The algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "1781f53c-d427-415b-b341-51b757b0883a", "metadata": {"aucs": [0.7150942784003851, 0.7169922198207901, 0.7307418558302339, 0.7140493839262265, 0.7176402103023265, 0.7318184025414152, 0.7204915346827585, 0.7664381872363039, 0.7208039888364453, 0.5283377169600327, 0.5159849138504526, 0.5554134278788361, 0.5266963703884217, 0.549711132249302, 0.5065699665057919, 0.556571307829915, 0.5137622010719198, 0.5229733725971338, 0.13285251617747307, 0.13001421936828372, 0.15589208769342622, 0.13907351852063476, 0.10850533087368053, 0.10908252794176565, 0.11803522871621408, 0.15978597722799948, 0.12441323398738491, 0.09907550419131239, 0.10904455757666787, 0.12203213435011206, 0.1326876930420664, 0.10150972495182375, 0.11035204072476468, 0.10825356931220542, 0.1125597447419957, 0.11332765228920394, 0.9300604088541523, 0.9344715776323286, 0.9148340509855397, 0.9543841976485351, 0.9393971677616509, 0.9185796805203976, 0.9252305014168017, 0.9554261446321115, 0.9126275335936885, 0.3553359612234981, 0.3006708609727845, 0.31018154412808807, 0.3305566426038705, 0.3181324478832417, 0.38013925824962314, 0.3517183503549892, 0.3365803810511744, 0.3691042883595429, 0.3187796475672341, 0.6057546493274496, 0.503759798626368, 0.43071205503669885, 0.586673603647065, 0.6667565734650261, 0.546564387234044, 0.5731925665595866, 0.5650905419350978, 0.18083481431791748, 0.1628187832793241, 0.13497975776586812, 0.18278847334750237, 0.2053617066342509, 0.1344231815183743, 0.14970094938184375, 0.1691193594621122, 0.1461204189728733, 0.1722744096625074, 0.14984178629707712, 0.13669314751178496, 0.15824827656173002, 0.1594978842647211, 0.15075724368426147, 0.1734200836838634, 0.17798590748461596, 0.18152076232999548, 0.06830546869692078, 0.1497741253277931, 0.14693209173694521, 0.08173514180178809, 0.03884972853868407, 0.07441756689398604, 0.06522802088155111, 0.06356223557022511, 0.06419472060773024, 0.19849962155499323, 0.17669578054850976, 0.20315562345522098, 0.15496006336679424, 0.14645739952222736, 0.17657705621381647, 0.2362945755547976, 0.26700744442629665, 0.27521145584787254, 0.05874814711597354, 0.0018725417827852864, 0.0573520457598552, 0.0467309039695758, 0.09744258826029184, 0.048615712703436786, 0.07236776075951601, 0.08721564806478255, 0.036854582244163936, 0.14194717543106272, 0.17781460812216843, 0.1419040804622136, 0.17434073919995718, 0.1859010567010525, 0.14982389181793843, 0.16061125794250852, 0.13253939830467842, 0.1731064260723928, 0.5199904504461752, 0.5019523764408949, 0.5235390848040711, 0.5064098538806798, 0.5372093434363625, 0.5360440087266813, 0.5449672973405573, 0.5175328255180053, 0.5204896883399321, 0.09003105637961539, 0.07443574059313873, 0.10719083076529501, 0.08782248101842471, 0.0933779962193898, 0.08770387337690755, 0.08796385091558201, 0.08422519692799468, 0.09126543069003223, 0.1446296931352019, 0.14910225434829083, 0.13590493242298618, 0.11933803715760805, 0.13242676483516191, 0.12447761382720257, 0.1436587417189621, 0.14125171205860876, 0.17429895567860898, 0.32172688321325127, 0.3097560598970447, 0.3227940979003112, 0.3009691786262687, 0.30655655597275944, 0.32919173776769983, 0.3392786201178919, 0.3744691808474977, 0.3392647134463389, 0.24462578446780092, 0.2191989908926707, 0.2264244107105141, 0.2156475244563545, 0.18587322884145163, 0.17850444969884138, 0.23132690365019004, 0.25123344522473856, 0.24813561755187308, 0.19713227838162806, 0.18590022677569296, 0.1879264995684684, 0.18892827176929972, 0.20110906358695035, 0.2125455228228812, 0.17957980344174107, 0.19523711859660664, 0.18165149421808635, 0.1909646344613447, 0.1903454053993613, 0.1890548830308011, 0.2150868600099286, 0.19035908308057992, 0.2368518358470304, 0.23728664234746544, 0.2054971853774148, 0.1837263304579948, 0.15569782245186126, 0.5640255920221358, 0.1558948362178617, 0.5755652432385978, 0.16677353737832978, 0.563650170346272, 0.30951722609668764, 0.19005502058529056, 0.3798289866963176, 0.16673980119486165, 0.16136489777550977, 0.2424144346445095, 0.1619371603525397, 0.17327260005274225, 0.29712533637221517, 0.1979802025301356, 0.20017027769996498, 0.20407597298126967, 0.1825883174887155, 0.17485051484777758, 0.20881239127616513, 0.17971316844766083, 0.17696398873789276, 0.17225754180084918, 0.1681548380712682, 0.18087480076411677, 0.18597340819839536, 0.06917252852724798, 0.074457187830267, 0.08195821493923883, 0.07953088757853255, 0.08891140428210498, 0.07658004268168983, 0.07126122653223743, 0.062154538836852624, 0.06389591489525281]}, "mutation_prompt": null}
{"id": "9adcf0eb-ac2f-4b58-877e-4f69bb1c5ff5", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1781f53c-d427-415b-b341-51b757b0883a", "metadata": {"aucs": [0.8155080130564687, 0.7559033804976276, 0.7905083647019924, 0.7706365799583045, 0.7720004892919544, 0.7593470219345677, 0.7537370188105208, 0.760038582709117, 0.7688127909607124, 0.5655881478001787, 0.5774910683303923, 0.5640605575423558, 0.5925450739444624, 0.572418207547452, 0.6097388193042579, 0.5556425429128315, 0.5794651159433983, 0.4865324343657187, 0.10943136396215947, 0.09551252924468845, 0.19098254722941055, 0.1241651193987725, 0.11679336299777643, 0.11247960589287809, 0.16658243415655982, 0.1632262133238752, 0.11016878883262637, 0.10253476795804106, 0.10701880832640687, 0.11420581915681427, 0.0991033430946705, 0.09434269006753326, 0.09919209965355336, 0.0899865563697555, 0.0976362981869745, 0.10370745962354033, 0.923371693436908, 0.9363393286271675, 0.9608986395726264, 0.9463349414245236, 0.9247224580034754, 0.9279701146332561, 0.9364984422653984, 0.892427483563698, 0.9327239774445928, 0.38961470800148157, 0.3963780867715607, 0.3686744308588069, 0.3515614301952177, 0.38238093954163144, 0.43305139347151844, 0.41129460015236496, 0.3709672897802697, 0.41145014541706304, 0.6318642824223506, 0.6570223002505244, 0.6689572208121993, 0.7081456948982934, 0.7229000682226474, 0.6888472264719517, 0.7369845083567743, 0.687656214634984, 0.6319416473784123, 0.20893564626953753, 0.16228156593626775, 0.17338691928834882, 0.17647999228280753, 0.24285597991865826, 0.16118881822081088, 0.24473973831693185, 0.16551774375254769, 0.23476747011081156, 0.14383782780042698, 0.20626465327264576, 0.15773475133562065, 0.170206041048668, 0.21390758419115674, 0.21210583976041686, 0.20367153521640124, 0.24212705844334348, 0.2874615594205191, 0.24943938636657104, 0.1516988015971077, 0.14246514859489356, 0.16179380538329502, 0.05283406603146834, 0.16399208308360724, 0.08230390917160779, 0.23903450289247374, 0.19828219686521076, 0.38785787456595877, 0.1944053508152328, 0.20255903876423798, 0.30903918241211026, 0.08832873300199118, 0.2857456767736388, 0.2542965026183789, 0.3312113038170096, 0.26096961762957693, 0.1340230634623918, 0.06850336774886201, 0.0776777271545539, 0.13454392931627845, 0.16769666118628357, 0.13932391155391777, 0.19572413483334838, 0.10905776980095017, 0.07939909619366403, 0.21869671965659854, 0.24069183744191902, 0.2449777441711366, 0.24249713021935504, 0.22925334786160378, 0.21948998938137942, 0.22631154759998884, 0.13903149065133602, 0.2123170410292312, 0.592410353772121, 0.5684522966706104, 0.620032363275939, 0.5112054176539589, 0.5671683914164736, 0.5588984269431831, 0.5721274467175509, 0.6286008067195519, 0.4918649782488407, 0.1012396790249328, 0.0902208929203181, 0.09910907027098126, 0.08495686269696978, 0.08939890254541771, 0.10663674442861903, 0.11445232136113026, 0.09868097204222592, 0.09350706528911856, 0.15083767353253552, 0.12925164396279065, 0.12927750175204256, 0.14393042481362028, 0.13517460891076039, 0.16922078480273417, 0.17726654486825955, 0.17899464471903337, 0.14806208923146802, 0.3385064755394417, 0.3420195134293488, 0.37353325323882947, 0.38367508340147016, 0.36743206885613455, 0.3558564247864303, 0.3846914821853128, 0.44415119438478146, 0.30676904999245347, 0.25601381386222477, 0.2826239374327034, 0.2430533894011503, 0.2700414170094949, 0.20531713781403182, 0.25824891401701033, 0.25161223547838085, 0.27354689584154246, 0.2489349943783482, 0.211943166537908, 0.1711755788774303, 0.1829352222178865, 0.18306520226945278, 0.19257543927701726, 0.1886523531768498, 0.1983072573583481, 0.1817123683265266, 0.20729085075393172, 0.1938562863628135, 0.18021484475111627, 0.17425845280891605, 0.21246585147881236, 0.2063308769307325, 0.18989750267968653, 0.2049176702240061, 0.20565710230219647, 0.1965406425342291, 0.7705403016370592, 0.731721010009793, 0.6774948716833766, 0.16940668299918094, 0.18148865100910339, 0.6363469912578363, 0.6058619081548582, 0.6134353036444747, 0.6609550140440952, 0.5626305444830952, 0.20245676549081038, 0.2028523864752264, 0.1997670225341035, 0.16160522813605516, 0.3898407233241753, 0.2085555458785595, 0.2017501609276201, 0.2172740397968571, 0.20267674272573766, 0.19313308227723391, 0.1838331864222783, 0.17655238715641697, 0.17402241032542243, 0.1844822118261935, 0.19108853101452516, 0.1985809825634044, 0.19006367058715223, 0.06864813008708859, 0.0721558288638886, 0.07205634995464061, 0.09150845335842928, 0.08067770296549259, 0.06946006424978224, 0.07282317686083117, 0.08409236261461006, 0.07105247295702777]}, "mutation_prompt": null}
{"id": "276d3e6a-2889-4b92-95d6-394cd0f7ca4e", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        L = 1.5 - 0.5 * (self.num_evaluations / self.budget)  # Dynamic Levy exponent\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight(L) * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 15 + int(5 * (1 - (self.num_evaluations / self.budget)))  # Adjusted adaptive population size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Enhanced Scatter Search with Dynamic Levy Exponent and Adaptive Population Size for Improved Exploration-Exploitation Balance.", "configspace": "", "generation": 29, "fitness": 0.3105787028094679, "feedback": "The algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.24.", "error": "", "parent_id": "1781f53c-d427-415b-b341-51b757b0883a", "metadata": {"aucs": [0.8039366968546373, 0.7285827887118402, 0.7909832432525882, 0.75678568158855, 0.7485888284278068, 0.7530722745597593, 0.7553618302570664, 0.7956538211543548, 0.7537920020811665, 0.5581823744421115, 0.5433306469096155, 0.5246606131428893, 0.5542791745494792, 0.5716044062532649, 0.5401065952180408, 0.577260369131001, 0.5884797643390556, 0.503476199142899, 0.10764968384396745, 0.09672601017950477, 0.11423611379830911, 0.12637872467880773, 0.10357307217389311, 0.10606057248818557, 0.09789919129198421, 0.1057550694994881, 0.10666789544433541, 0.10901683403283913, 0.10804552728209327, 0.09200284955997218, 0.10961942264924496, 0.10564342423217599, 0.08583490864185916, 0.09929572049674174, 0.09983164435634839, 0.09420619769170535, 0.9233509661245356, 0.9363575977968215, 0.9608995115705715, 0.9463403781281438, 0.9244826611453746, 0.9284085298916588, 0.9365032545526264, 0.8970867928807646, 0.9327676239819155, 0.35853555334522214, 0.3830975035361157, 0.3254612892023043, 0.3445683538639547, 0.33455509281141327, 0.41365435279294127, 0.3893389520379764, 0.35380083611888036, 0.37411144809483754, 0.7348291702240289, 0.684687123336499, 0.6417527044219359, 0.6865551325650054, 0.7669171732187365, 0.6884654056259554, 0.6582418179762051, 0.6242228614135154, 0.6813418170754753, 0.22533223817179937, 0.16911162617091047, 0.14796103841655917, 0.1699240984497875, 0.2287626142112562, 0.14556285924074586, 0.24676410873771004, 0.17009120508796238, 0.2835612412847164, 0.1818120412252816, 0.15309588392110396, 0.1685425151865304, 0.17234531906289996, 0.1331085731889523, 0.19020758668321647, 0.2383638145360264, 0.15118501549701946, 0.23386188974355626, 0.19560316066741945, 0.22869473237718252, 0.046781200450183635, 0.28524153327090573, 0.20575189240263558, 0.13450181585938625, 0.05602785502905694, 0.1324583140359058, 0.07401120813557027, 0.2773978045900459, 0.2365939925307995, 0.1999988014434967, 0.4279366435986801, 0.140487130896909, 0.14561940962542175, 0.38796371503232796, 0.2811699086072631, 0.37875337765239536, 0.10746425826458361, 0.14247672764473396, 0.05338214327312474, 0.10524353612445414, 0.0875392055173344, 0.0931275709151107, 0.11243947077646221, 0.09721629267138598, 0.1486957297776511, 0.20900004743396272, 0.20513177355426038, 0.19531832723749254, 0.22161961267052488, 0.20197935901327868, 0.19783039206915143, 0.20960785047623343, 0.2184537422499302, 0.22509155859689123, 0.6105044814983505, 0.5914627138460566, 0.6449571271350163, 0.5434430791319294, 0.5590956510378188, 0.5359963897265814, 0.6069683381188116, 0.5932488475351883, 0.6134423668171749, 0.10578770842691043, 0.08077354343969367, 0.09969535163615406, 0.09152082774925219, 0.08966988635732775, 0.09323023228112437, 0.08412643176255441, 0.09274996696295235, 0.0774244983911867, 0.15852145709425602, 0.14276371564882562, 0.14771069418721694, 0.1435210397994362, 0.158115102669234, 0.17551339128933963, 0.14975589847038262, 0.1313214469636963, 0.1416113634314795, 0.36007484519355737, 0.3628367958961186, 0.2992121070762749, 0.329598286576937, 0.3640224162386312, 0.3131100073356785, 0.3626331889253269, 0.36777813586792696, 0.36400495496612106, 0.27536689815542803, 0.22799005355785784, 0.2711175573416502, 0.2981548964469366, 0.2259193228038302, 0.30134652341123225, 0.24394133787205952, 0.3267716041835875, 0.2643805883024951, 0.20439833987429867, 0.1975746212088283, 0.1846199806654628, 0.1893452306733311, 0.19918166442901075, 0.17211733162840315, 0.1845760217928749, 0.19570268785334588, 0.19076256601110442, 0.18612980359427567, 0.1800237662148858, 0.19745531871759947, 0.18065253461952502, 0.1891210055570034, 0.17466806743222352, 0.2127299269635463, 0.181282556117782, 0.1916997824597908, 0.7544283730912041, 0.1700061673700668, 0.7056320306595188, 0.16945460830043357, 0.18157694917050815, 0.6319177716929076, 0.6129373870099872, 0.6042766306664162, 0.7571371169535674, 0.45595838419383083, 0.2017552013381042, 0.2026951257064752, 0.20066879670347604, 0.16144303013784012, 0.2688616625017962, 0.20844570592478762, 0.20172143735956383, 0.16714314930670426, 0.17447701681338113, 0.1851083490299401, 0.18684835147636347, 0.1858405350189084, 0.19137083891230566, 0.1712703470790211, 0.18888970133873095, 0.2016206536198013, 0.17596822340835372, 0.08373385993083593, 0.08494641132727743, 0.08361078465331317, 0.07699951189056298, 0.0762534781878974, 0.0851957893945835, 0.07542075580347662, 0.069561663268767, 0.07547389085228273]}, "mutation_prompt": null}
{"id": "adf62f53-cc5a-4a61-8d44-036908fadc22", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1781f53c-d427-415b-b341-51b757b0883a", "metadata": {"aucs": [0.8155080130564687, 0.7559033804976276, 0.7905083647019924, 0.7706365799583045, 0.7720004892919544, 0.7593470219345677, 0.7537370188105208, 0.760038582709117, 0.7688127909607124, 0.5655881478001787, 0.5774910683303923, 0.5640605575423558, 0.5925450739444624, 0.572418207547452, 0.6097388193042579, 0.5556425429128315, 0.5794651159433983, 0.4865324343657187, 0.10943136396215947, 0.09551252924468845, 0.19098254722941055, 0.1241651193987725, 0.11679336299777643, 0.11247960589287809, 0.16658243415655982, 0.1632262133238752, 0.11016878883262637, 0.10253476795804106, 0.10701880832640687, 0.11420581915681427, 0.0991033430946705, 0.09434269006753326, 0.09919209965355336, 0.0899865563697555, 0.0976362981869745, 0.10370745962354033, 0.923371693436908, 0.9363393286271675, 0.9608986395726264, 0.9463349414245236, 0.9247224580034754, 0.9279701146332561, 0.9364984422653984, 0.892427483563698, 0.9327239774445928, 0.38961470800148157, 0.3963780867715607, 0.3686744308588069, 0.3515614301952177, 0.38238093954163144, 0.43305139347151844, 0.41129460015236496, 0.3709672897802697, 0.41145014541706304, 0.6318642824223506, 0.6570223002505244, 0.6689572208121993, 0.7081456948982934, 0.7229000682226474, 0.6888472264719517, 0.7369845083567743, 0.687656214634984, 0.6319416473784123, 0.20893564626953753, 0.16228156593626775, 0.17338691928834882, 0.17647999228280753, 0.24285597991865826, 0.16118881822081088, 0.24473973831693185, 0.16551774375254769, 0.23476747011081156, 0.14383782780042698, 0.20626465327264576, 0.15773475133562065, 0.170206041048668, 0.21390758419115674, 0.21210583976041686, 0.20367153521640124, 0.24212705844334348, 0.2874615594205191, 0.24943938636657104, 0.1516988015971077, 0.14246514859489356, 0.16179380538329502, 0.05283406603146834, 0.16399208308360724, 0.08230390917160779, 0.23903450289247374, 0.19828219686521076, 0.38785787456595877, 0.1944053508152328, 0.20255903876423798, 0.30903918241211026, 0.08832873300199118, 0.2857456767736388, 0.2542965026183789, 0.3312113038170096, 0.26096961762957693, 0.1340230634623918, 0.06850336774886201, 0.0776777271545539, 0.13454392931627845, 0.16769666118628357, 0.13932391155391777, 0.19572413483334838, 0.10905776980095017, 0.07939909619366403, 0.21869671965659854, 0.24069183744191902, 0.2449777441711366, 0.24249713021935504, 0.22925334786160378, 0.21948998938137942, 0.22631154759998884, 0.13903149065133602, 0.2123170410292312, 0.592410353772121, 0.5684522966706104, 0.620032363275939, 0.5112054176539589, 0.5671683914164736, 0.5588984269431831, 0.5721274467175509, 0.6286008067195519, 0.4918649782488407, 0.1012396790249328, 0.0902208929203181, 0.09910907027098126, 0.08495686269696978, 0.08939890254541771, 0.10663674442861903, 0.11445232136113026, 0.09868097204222592, 0.09350706528911856, 0.15083767353253552, 0.12925164396279065, 0.12927750175204256, 0.14393042481362028, 0.13517460891076039, 0.16922078480273417, 0.17726654486825955, 0.17899464471903337, 0.14806208923146802, 0.3385064755394417, 0.3420195134293488, 0.37353325323882947, 0.38367508340147016, 0.36743206885613455, 0.3558564247864303, 0.3846914821853128, 0.44415119438478146, 0.30676904999245347, 0.25601381386222477, 0.2826239374327034, 0.2430533894011503, 0.2700414170094949, 0.20531713781403182, 0.25824891401701033, 0.25161223547838085, 0.27354689584154246, 0.2489349943783482, 0.211943166537908, 0.1711755788774303, 0.1829352222178865, 0.18306520226945278, 0.19257543927701726, 0.1886523531768498, 0.1983072573583481, 0.1817123683265266, 0.20729085075393172, 0.1938562863628135, 0.18021484475111627, 0.17425845280891605, 0.21246585147881236, 0.2063308769307325, 0.18989750267968653, 0.2049176702240061, 0.20565710230219647, 0.1965406425342291, 0.7705403016370592, 0.731721010009793, 0.6774948716833766, 0.16940668299918094, 0.18148865100910339, 0.6363469912578363, 0.6058619081548582, 0.6134353036444747, 0.6609550140440952, 0.5626305444830952, 0.20245676549081038, 0.2028523864752264, 0.1997670225341035, 0.16160522813605516, 0.3898407233241753, 0.2085555458785595, 0.2017501609276201, 0.2172740397968571, 0.20267674272573766, 0.19313308227723391, 0.1838331864222783, 0.17655238715641697, 0.17402241032542243, 0.1844822118261935, 0.19108853101452516, 0.1985809825634044, 0.19006367058715223, 0.06864813008708859, 0.0721558288638886, 0.07205634995464061, 0.09150845335842928, 0.08067770296549259, 0.06946006424978224, 0.07282317686083117, 0.08409236261461006, 0.07105247295702777]}, "mutation_prompt": null}
{"id": "874f23de-2e7a-438a-b05d-98702180174e", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1781f53c-d427-415b-b341-51b757b0883a", "metadata": {"aucs": [0.8155080130564687, 0.7559033804976276, 0.7905083647019924, 0.7706365799583045, 0.7720004892919544, 0.7593470219345677, 0.7537370188105208, 0.760038582709117, 0.7688127909607124, 0.5655881478001787, 0.5774910683303923, 0.5640605575423558, 0.5925450739444624, 0.572418207547452, 0.6097388193042579, 0.5556425429128315, 0.5794651159433983, 0.4865324343657187, 0.10943136396215947, 0.09551252924468845, 0.19098254722941055, 0.1241651193987725, 0.11679336299777643, 0.11247960589287809, 0.16658243415655982, 0.1632262133238752, 0.11016878883262637, 0.10253476795804106, 0.10701880832640687, 0.11420581915681427, 0.0991033430946705, 0.09434269006753326, 0.09919209965355336, 0.0899865563697555, 0.0976362981869745, 0.10370745962354033, 0.923371693436908, 0.9363393286271675, 0.9608986395726264, 0.9463349414245236, 0.9247224580034754, 0.9279701146332561, 0.9364984422653984, 0.892427483563698, 0.9327239774445928, 0.38961470800148157, 0.3963780867715607, 0.3686744308588069, 0.3515614301952177, 0.38238093954163144, 0.43305139347151844, 0.41129460015236496, 0.3709672897802697, 0.41145014541706304, 0.6318642824223506, 0.6570223002505244, 0.6689572208121993, 0.7081456948982934, 0.7229000682226474, 0.6888472264719517, 0.7369845083567743, 0.687656214634984, 0.6319416473784123, 0.20893564626953753, 0.16228156593626775, 0.17338691928834882, 0.17647999228280753, 0.24285597991865826, 0.16118881822081088, 0.24473973831693185, 0.16551774375254769, 0.23476747011081156, 0.14383782780042698, 0.20626465327264576, 0.15773475133562065, 0.170206041048668, 0.21390758419115674, 0.21210583976041686, 0.20367153521640124, 0.24212705844334348, 0.2874615594205191, 0.24943938636657104, 0.1516988015971077, 0.14246514859489356, 0.16179380538329502, 0.05283406603146834, 0.16399208308360724, 0.08230390917160779, 0.23903450289247374, 0.19828219686521076, 0.38785787456595877, 0.1944053508152328, 0.20255903876423798, 0.30903918241211026, 0.08832873300199118, 0.2857456767736388, 0.2542965026183789, 0.3312113038170096, 0.26096961762957693, 0.1340230634623918, 0.06850336774886201, 0.0776777271545539, 0.13454392931627845, 0.16769666118628357, 0.13932391155391777, 0.19572413483334838, 0.10905776980095017, 0.07939909619366403, 0.21869671965659854, 0.24069183744191902, 0.2449777441711366, 0.24249713021935504, 0.22925334786160378, 0.21948998938137942, 0.22631154759998884, 0.13903149065133602, 0.2123170410292312, 0.592410353772121, 0.5684522966706104, 0.620032363275939, 0.5112054176539589, 0.5671683914164736, 0.5588984269431831, 0.5721274467175509, 0.6286008067195519, 0.4918649782488407, 0.1012396790249328, 0.0902208929203181, 0.09910907027098126, 0.08495686269696978, 0.08939890254541771, 0.10663674442861903, 0.11445232136113026, 0.09868097204222592, 0.09350706528911856, 0.15083767353253552, 0.12925164396279065, 0.12927750175204256, 0.14393042481362028, 0.13517460891076039, 0.16922078480273417, 0.17726654486825955, 0.17899464471903337, 0.14806208923146802, 0.3385064755394417, 0.3420195134293488, 0.37353325323882947, 0.38367508340147016, 0.36743206885613455, 0.3558564247864303, 0.3846914821853128, 0.44415119438478146, 0.30676904999245347, 0.25601381386222477, 0.2826239374327034, 0.2430533894011503, 0.2700414170094949, 0.20531713781403182, 0.25824891401701033, 0.25161223547838085, 0.27354689584154246, 0.2489349943783482, 0.211943166537908, 0.1711755788774303, 0.1829352222178865, 0.18306520226945278, 0.19257543927701726, 0.1886523531768498, 0.1983072573583481, 0.1817123683265266, 0.20729085075393172, 0.1938562863628135, 0.18021484475111627, 0.17425845280891605, 0.21246585147881236, 0.2063308769307325, 0.18989750267968653, 0.2049176702240061, 0.20565710230219647, 0.1965406425342291, 0.7705403016370592, 0.731721010009793, 0.6774948716833766, 0.16940668299918094, 0.18148865100910339, 0.6363469912578363, 0.6058619081548582, 0.6134353036444747, 0.6609550140440952, 0.5626305444830952, 0.20245676549081038, 0.2028523864752264, 0.1997670225341035, 0.16160522813605516, 0.3898407233241753, 0.2085555458785595, 0.2017501609276201, 0.2172740397968571, 0.20267674272573766, 0.19313308227723391, 0.1838331864222783, 0.17655238715641697, 0.17402241032542243, 0.1844822118261935, 0.19108853101452516, 0.1985809825634044, 0.19006367058715223, 0.06864813008708859, 0.0721558288638886, 0.07205634995464061, 0.09150845335842928, 0.08067770296549259, 0.06946006424978224, 0.07282317686083117, 0.08409236261461006, 0.07105247295702777]}, "mutation_prompt": null}
{"id": "7e8b001d-3d8e-4c2c-bd17-859a74d2d7db", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1781f53c-d427-415b-b341-51b757b0883a", "metadata": {"aucs": [0.8155080130564687, 0.7559033804976276, 0.7905083647019924, 0.7706365799583045, 0.7720004892919544, 0.7593470219345677, 0.7537370188105208, 0.760038582709117, 0.7688127909607124, 0.5655881478001787, 0.5774910683303923, 0.5640605575423558, 0.5925450739444624, 0.572418207547452, 0.6097388193042579, 0.5556425429128315, 0.5794651159433983, 0.4865324343657187, 0.10943136396215947, 0.09551252924468845, 0.19098254722941055, 0.1241651193987725, 0.11679336299777643, 0.11247960589287809, 0.16658243415655982, 0.1632262133238752, 0.11016878883262637, 0.10253476795804106, 0.10701880832640687, 0.11420581915681427, 0.0991033430946705, 0.09434269006753326, 0.09919209965355336, 0.0899865563697555, 0.0976362981869745, 0.10370745962354033, 0.923371693436908, 0.9363393286271675, 0.9608986395726264, 0.9463349414245236, 0.9247224580034754, 0.9279701146332561, 0.9364984422653984, 0.892427483563698, 0.9327239774445928, 0.38961470800148157, 0.3963780867715607, 0.3686744308588069, 0.3515614301952177, 0.38238093954163144, 0.43305139347151844, 0.41129460015236496, 0.3709672897802697, 0.41145014541706304, 0.6318642824223506, 0.6570223002505244, 0.6689572208121993, 0.7081456948982934, 0.7229000682226474, 0.6888472264719517, 0.7369845083567743, 0.687656214634984, 0.6319416473784123, 0.20893564626953753, 0.16228156593626775, 0.17338691928834882, 0.17647999228280753, 0.24285597991865826, 0.16118881822081088, 0.24473973831693185, 0.16551774375254769, 0.23476747011081156, 0.14383782780042698, 0.20626465327264576, 0.15773475133562065, 0.170206041048668, 0.21390758419115674, 0.21210583976041686, 0.20367153521640124, 0.24212705844334348, 0.2874615594205191, 0.24943938636657104, 0.1516988015971077, 0.14246514859489356, 0.16179380538329502, 0.05283406603146834, 0.16399208308360724, 0.08230390917160779, 0.23903450289247374, 0.19828219686521076, 0.38785787456595877, 0.1944053508152328, 0.20255903876423798, 0.30903918241211026, 0.08832873300199118, 0.2857456767736388, 0.2542965026183789, 0.3312113038170096, 0.26096961762957693, 0.1340230634623918, 0.06850336774886201, 0.0776777271545539, 0.13454392931627845, 0.16769666118628357, 0.13932391155391777, 0.19572413483334838, 0.10905776980095017, 0.07939909619366403, 0.21869671965659854, 0.24069183744191902, 0.2449777441711366, 0.24249713021935504, 0.22925334786160378, 0.21948998938137942, 0.22631154759998884, 0.13903149065133602, 0.2123170410292312, 0.592410353772121, 0.5684522966706104, 0.620032363275939, 0.5112054176539589, 0.5671683914164736, 0.5588984269431831, 0.5721274467175509, 0.6286008067195519, 0.4918649782488407, 0.1012396790249328, 0.0902208929203181, 0.09910907027098126, 0.08495686269696978, 0.08939890254541771, 0.10663674442861903, 0.11445232136113026, 0.09868097204222592, 0.09350706528911856, 0.15083767353253552, 0.12925164396279065, 0.12927750175204256, 0.14393042481362028, 0.13517460891076039, 0.16922078480273417, 0.17726654486825955, 0.17899464471903337, 0.14806208923146802, 0.3385064755394417, 0.3420195134293488, 0.37353325323882947, 0.38367508340147016, 0.36743206885613455, 0.3558564247864303, 0.3846914821853128, 0.44415119438478146, 0.30676904999245347, 0.25601381386222477, 0.2826239374327034, 0.2430533894011503, 0.2700414170094949, 0.20531713781403182, 0.25824891401701033, 0.25161223547838085, 0.27354689584154246, 0.2489349943783482, 0.211943166537908, 0.1711755788774303, 0.1829352222178865, 0.18306520226945278, 0.19257543927701726, 0.1886523531768498, 0.1983072573583481, 0.1817123683265266, 0.20729085075393172, 0.1938562863628135, 0.18021484475111627, 0.17425845280891605, 0.21246585147881236, 0.2063308769307325, 0.18989750267968653, 0.2049176702240061, 0.20565710230219647, 0.1965406425342291, 0.7705403016370592, 0.731721010009793, 0.6774948716833766, 0.16940668299918094, 0.18148865100910339, 0.6363469912578363, 0.6058619081548582, 0.6134353036444747, 0.6609550140440952, 0.5626305444830952, 0.20245676549081038, 0.2028523864752264, 0.1997670225341035, 0.16160522813605516, 0.3898407233241753, 0.2085555458785595, 0.2017501609276201, 0.2172740397968571, 0.20267674272573766, 0.19313308227723391, 0.1838331864222783, 0.17655238715641697, 0.17402241032542243, 0.1844822118261935, 0.19108853101452516, 0.1985809825634044, 0.19006367058715223, 0.06864813008708859, 0.0721558288638886, 0.07205634995464061, 0.09150845335842928, 0.08067770296549259, 0.06946006424978224, 0.07282317686083117, 0.08409236261461006, 0.07105247295702777]}, "mutation_prompt": null}
{"id": "f2853ac4-d258-411a-8734-588926f5cfe1", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.6, 0.9)  # Increased F for diversity\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.8 - 0.2 * (self.num_evaluations / self.budget)  # Adjusted crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.4 / (1 + np.exp(-0.1 * self.num_evaluations))  # Increased step size for intensified search\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        initial_pop_size = 15 + int(5 * (1 - (self.num_evaluations / self.budget)))  # Adjusted initial population size\n        population = self.initialize_population(initial_pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Enhanced Adaptive Scatter Search with Dynamic Population Size Adjustment and Intensified Local Search for Improved Exploration-Exploitation Balance.", "configspace": "", "generation": 33, "fitness": 0.24257540945061032, "feedback": "The algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.21.", "error": "", "parent_id": "1781f53c-d427-415b-b341-51b757b0883a", "metadata": {"aucs": [0.6530624198177201, 0.6324175405666451, 0.643396984669817, 0.6677827936251912, 0.707401356669562, 0.7258611221769884, 0.6868190119959188, 0.6317042466362507, 0.708629691342757, 0.3993315223401157, 0.380668751425535, 0.40215440453814166, 0.4111746308959382, 0.45719161631582694, 0.4675212573148704, 0.45301615121973704, 0.377092152813988, 0.4168660539186634, 0.12033762073527965, 0.11312155417331815, 0.10662368913788445, 0.09479986177910993, 0.12930293330714282, 0.10396866419613471, 0.1167370234976326, 0.10234219863989524, 0.12706746091454735, 0.08347103344241735, 0.09880397577997413, 0.10687508906315069, 0.10191442701003961, 0.10181487551406732, 0.09431671267429609, 0.08949167260867874, 0.0993542248180167, 0.1229194967635745, 0.9133157754925783, 0.9636056686138204, 0.9289816857651179, 0.9366038594044134, 0.9496358482863968, 0.9588733320367936, 0.9317739104967439, 0.9518604920868101, 0.9343075786866984, 0.27249335857912804, 0.2691566302734103, 0.2791957210259146, 0.269755090542502, 0.292095646145518, 0.2629793107208217, 0.26908642427265095, 0.2789562720819695, 0.24707625341518435, 0.5562617721289561, 0.34344263417005805, 0.2666491072041024, 0.4785051849779616, 0.3450160234659255, 0.45354561350212774, 0.3867443702516101, 0.4366905983445841, 0.5335972583032051, 0.15112523250811916, 0.17679405395871983, 0.12808917218412774, 0.16248243058568712, 0.13839322219910233, 0.15140678769684823, 0.17334673490771424, 0.14217473264109737, 0.1551646102382852, 0.14252511046208804, 0.1309408251053168, 0.12665476897957229, 0.1638035857662058, 0.15934475424730643, 0.16729442053243715, 0.1281409300293621, 0.17438770949461635, 0.1351790195555994, 0.10245288215441473, 0.050054706824994355, 0.04133097957667664, 0.022240017982698146, 0.03420383642066316, 0.03647035231203011, 0.02041604864669444, 0.051617171573986154, 0.05855993835611406, 0.1528122965602703, 0.11608458095405783, 0.1969052669569178, 0.12515797939451567, 0.12292149873947111, 0.11113659457220038, 0.16504730670541667, 0.1758438679600628, 0.16769722603029313, 9.999999999998899e-05, 0.01562494753598076, 0.015083579348681098, 0.0032272405588924524, 0.00516172510340529, 0.02370694835372522, 9.999999999998899e-05, 0.00014091163944651708, 9.999999999998899e-05, 0.10488917245816354, 0.10875574398501198, 0.12761983517740083, 0.11663445047427645, 0.12728952343928135, 0.12721420221001722, 0.12357768662855906, 0.13460403347331407, 0.12450250381666339, 0.46547465168097857, 0.45565158362179237, 0.48892409558596583, 0.43454132126529466, 0.44201564240616753, 0.45647894613670426, 0.4651348433199066, 0.4218339181895794, 0.4617137094952931, 0.09067235052461708, 0.08189789044446605, 0.07803072633512742, 0.09100129621706587, 0.08478544009701983, 0.10598440842400092, 0.07511213972848896, 0.07170612368228957, 0.07923385845337239, 0.1215540976830547, 0.15151392700489164, 0.21816291261454435, 0.1348579557351186, 0.12229872705133893, 0.1539294085940064, 0.1719036242733144, 0.14869069574942784, 0.16019697428787838, 0.26695662883234417, 0.2552792480786582, 0.270405702796769, 0.24301486001168526, 0.2842804786836701, 0.2924246483745535, 0.3408125841340005, 0.2853082837801203, 0.2875835196683706, 0.19501113531177694, 0.18167938305216058, 0.18722919330617038, 0.17644977922965477, 0.19081439549615042, 0.18978806882199017, 0.201715589921737, 0.19244761697194201, 0.19658013727478285, 0.15746945063617457, 0.1748527119569393, 0.18286799414675703, 0.19493271709353222, 0.20543105137855888, 0.18459102456762644, 0.1878142954922114, 0.172817769299766, 0.18538966354614006, 0.17510267434696836, 0.17303693779072216, 0.17793513523499715, 0.19027746663392897, 0.18809051114272946, 0.184414478878428, 0.18326496954232085, 0.16757893939059287, 0.1692249741919959, 0.5912813680459007, 0.1622112333618193, 0.16161118677501085, 0.4670075247586216, 0.18206703230017707, 0.17115112847907343, 0.4014849265680983, 0.17261892544120416, 0.1914834850108137, 0.16225000777081366, 0.18585204391414722, 0.21038034819420193, 0.1962961533612121, 0.17828247044900214, 0.18560635386976276, 0.20555894492107118, 0.20180108953073217, 0.2932991300522674, 0.17707175900577987, 0.1781971202243663, 0.17432500940053364, 0.18120141941258994, 0.18891504832473838, 0.1898310988446118, 0.17532269549585666, 0.18956058682267973, 0.17597370877635188, 0.06871838897860594, 0.09222455108760041, 0.0788531987575567, 0.07904810445079369, 0.074231979571314, 0.06252940549837471, 0.06842456856540502, 0.061297414793744065, 0.07205094326802974]}, "mutation_prompt": null}
{"id": "cddf84db-edde-475a-a829-b08163552061", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.5, 0.9)  # Adjusted mutation factor range\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.8 - 0.4 * (self.num_evaluations / self.budget)  # Adjusted crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.3 / (1 + np.exp(-0.1 * self.num_evaluations))  # Adjusted step size factor\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 15 + int(10 * (1 - (self.num_evaluations / self.budget)))  # Adjusted initial population size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Enhanced Adaptive Scatter Search with Dynamic Population and Step Size Adaptation for Improved Exploration and Exploitation Balance.", "configspace": "", "generation": 34, "fitness": 0.22616948287774544, "feedback": "The algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "1781f53c-d427-415b-b341-51b757b0883a", "metadata": {"aucs": [0.5907497115306026, 0.6416469596188704, 0.6077043282243155, 0.6030396566576128, 0.6822722317577408, 0.6324714201242064, 0.6286825944199803, 0.6406019941338514, 0.6296542266883267, 0.3671932853667902, 0.32547637731630286, 0.37671506967119717, 0.3607262841296225, 0.3116627300286615, 0.33103956829525616, 0.39877044696744657, 0.36213352341935645, 0.37571529038982854, 0.11159742771600012, 0.10906115275203809, 0.1146603206938267, 0.10693725514847574, 0.10044284372016954, 0.10888521308006816, 0.12499444144355709, 0.10296656622295597, 0.09351984323101203, 0.09054077069780997, 0.09910805414208357, 0.09783705964270772, 0.08831539868398885, 0.0864227897314297, 0.10070050466449232, 0.08889247705599523, 0.09952674113106863, 0.08618012144502085, 0.9561620600606635, 0.9127895259282967, 0.9130358750132257, 0.951724737411731, 0.9866501660224805, 0.9717026228363377, 0.9717201444698536, 0.9449046878011322, 0.9104807970923166, 0.2615064439773247, 0.2318817135414365, 0.21550080000385186, 0.25644009693202174, 0.20642184612266423, 0.23778767704590886, 0.26430729493044947, 0.2847098012099234, 0.24980811764860356, 0.30535074136038287, 0.2703979444382666, 0.2701511655167359, 0.25560836126139774, 0.3155124679403304, 0.286909130140783, 0.2846964100749281, 0.24625620948907678, 0.37901366323394203, 0.13410541414338373, 0.13057337524064982, 0.13477943539013193, 0.14215844859186055, 0.1189966377446301, 0.13300382424802215, 0.16109889233005703, 0.14047100825696401, 0.1425291790211255, 0.12216004583665763, 0.11878274183176052, 0.13305694619063724, 0.15923088925461504, 0.12471442085395301, 0.14399361595702354, 0.12341272678415649, 0.15615836824308538, 0.14495779994084768, 0.03357288350018284, 0.010390155063978668, 0.003812879974048, 0.026737174364348304, 0.014833994051198007, 0.02981350377162051, 0.024069553577070968, 0.008545587231153284, 0.015812737285521128, 0.12499665194236009, 0.09159970635626613, 0.14597295387611253, 0.0983384510495624, 0.11148651470366622, 0.09341426465541958, 0.17575286609663932, 0.13771217398232838, 0.16453290143582855, 0.000375319754817971, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008584990513781698, 9.999999999998899e-05, 9.999999999998899e-05, 0.09390976166045606, 0.10385397084247039, 0.09846383466361963, 0.11626534112722275, 0.11000350561051797, 0.11745884860348088, 0.11156238716237854, 0.10362915531913497, 0.11899180454533254, 0.42536917258029394, 0.4309209958516276, 0.42952930523704314, 0.4352121627893196, 0.43483403618948346, 0.4390083924359506, 0.44465897509402563, 0.428722857933704, 0.4523983893016261, 0.0760648307122972, 0.08772892923154263, 0.08380134828897712, 0.08582814871870992, 0.08074196320656124, 0.08367499301239623, 0.08019590612393368, 0.08736670893092635, 0.08365916691186559, 0.1467044313236896, 0.15253512936705516, 0.13792828672447488, 0.15693503940612086, 0.1255715059498128, 0.13411100646014507, 0.12100952158264477, 0.13471689993652636, 0.15301238030010078, 0.26316570026194464, 0.24874984590326787, 0.2587332638995139, 0.2548427119899468, 0.24972882863143253, 0.24016415082879705, 0.26333379042727834, 0.2893030905579633, 0.2894197620285668, 0.1876398064161815, 0.17480371948233098, 0.1799278171429196, 0.15481822609287532, 0.17627997480308788, 0.1896955636403459, 0.20894074377372185, 0.20196024866021256, 0.18906369049501714, 0.18853160482557363, 0.1864016810006922, 0.2106419314236906, 0.1904342769015871, 0.1787360598462937, 0.19033211239652614, 0.1779792556597628, 0.18519781255898804, 0.19249814398712173, 0.16766448062420936, 0.1743184142639027, 0.17473428987957873, 0.17481929922327222, 0.16624096771789065, 0.17858386782836655, 0.1752992110311894, 0.1901109144072809, 0.18476238954426605, 0.3350604328045449, 0.16547731936157817, 0.1590025278048628, 0.17350358296744184, 0.33277952330751226, 0.26747687783728447, 0.17241434536357225, 0.3442041524676912, 0.21471432987385475, 0.19459224681492215, 0.19240026413240852, 0.37275639018323425, 0.3338679108732706, 0.30189334478449004, 0.216341854237319, 0.20536976249810135, 0.37387432539567067, 0.2011191282454099, 0.18450762821171307, 0.18868062222404525, 0.16438867026385928, 0.1723921321544094, 0.18870213545377235, 0.1800086104491867, 0.1812571610682514, 0.16675933754395922, 0.21227030185726126, 0.06940495579106243, 0.0658141694349248, 0.06981873018752849, 0.07146072597332243, 0.06869752222851055, 0.07074546301000684, 0.07842623624020506, 0.06787883311455156, 0.07679579165001049]}, "mutation_prompt": null}
{"id": "bf8dedd3-fcb5-48df-9dc2-3e149ec4e9ec", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        candidates = np.random.choice(idxs, 3, replace=False)\n        a, b, c = population[candidates]\n        F = 0.5 + 0.3 * np.random.rand()  # Enhanced F value\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.8 + 0.2 * (1 - (self.num_evaluations / self.budget))  # Adjusted crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.1 / (1 + np.exp(-0.1 * self.num_evaluations))  # Reduced step size for finer adjustment\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(15 * (1 - (self.num_evaluations / self.budget)))  # Dynamic population size increase\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Enhanced Adaptive Scatter Search with Fitness-Based Dynamic Population Scaling and Hybrid Local Search for Robust Optimization.", "configspace": "", "generation": 35, "fitness": 0.30648913504692665, "feedback": "The algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.21.", "error": "", "parent_id": "1781f53c-d427-415b-b341-51b757b0883a", "metadata": {"aucs": [0.6899181057945799, 0.6619793669472638, 0.6462884168658132, 0.6315634497036581, 0.6775794621973459, 0.7013506372331172, 0.6307092193310845, 0.657334981274269, 0.6639962325471251, 0.43029951175969783, 0.4305892318051633, 0.39008833359522466, 0.3969423949846921, 0.3732611252370316, 0.3973923064939714, 0.30387385449241233, 0.45199419942677654, 0.4865372515041617, 0.09602334212274366, 0.09856221053328795, 0.08494859641145158, 0.11144338662013675, 0.11179548891708035, 0.10889213214744209, 0.11080278795197085, 0.09643605221854468, 0.09429915817694368, 0.08657319310693234, 0.08111721817715023, 0.08769232404412564, 0.09662921807892799, 0.09204113472146547, 0.07986915489683, 0.07632889643947838, 0.09261346728901987, 0.07455767732771479, 0.8171146308507061, 0.7719458075758272, 0.8436123695132061, 0.8382936370267801, 0.9513132151856887, 0.8092997782034389, 0.9310054295509709, 0.8676393690288262, 0.8312349766442038, 0.3305259427612567, 0.30399545855833177, 0.318097671339011, 0.338254163796309, 0.3223138376336139, 0.33743348398275486, 0.30342110786802867, 0.32171517413757766, 0.3566064285498979, 0.6951795176953949, 0.6317708114299243, 0.6025312898625481, 0.7289514465168401, 0.6452620559893167, 0.7626301709707067, 0.5979650083373372, 0.7179120597851147, 0.7006196365841676, 0.18904970984084668, 0.22458835335812866, 0.2577006333125137, 0.14774745582338622, 0.18107764426740003, 0.32095819458892183, 0.1758923017286299, 0.2495441109838914, 0.26151315915904483, 0.1966700144568143, 0.2132105954180643, 0.27173202141532815, 0.2764683402227457, 0.23770249045002578, 0.17831234263671525, 0.14372585921991143, 0.17682639463448246, 0.15860582978545956, 0.2264521162755957, 0.3352106201244611, 0.29131851045069745, 0.28228136751494814, 0.29905731142168424, 0.2987738335058443, 0.33366852882614473, 0.17047817066098847, 0.27991587834037035, 0.3569465472849702, 0.4538645181966886, 0.4587389459425564, 0.44036807812048984, 0.40536056077491445, 0.47704872612123017, 0.4655537111212763, 0.4728053619202226, 0.4175839625929748, 0.14762588570097546, 0.04734146606080414, 0.08229970775538664, 0.14100186109907775, 0.22046215544941428, 0.1852972404878963, 0.06721864408243583, 0.10201123320944205, 0.14059602055220854, 0.24495556447837152, 0.27664815778404306, 0.2276755484614147, 0.2292494423647854, 0.2503158905360978, 0.23665574298730774, 0.20618215717172883, 0.25388557357288144, 0.26864568391453636, 0.5841089916478259, 0.6050549843573407, 0.622731593468566, 0.5945696438806791, 0.5814505495916584, 0.5382857499811822, 0.5766217715268209, 0.5981342603234672, 0.6018635728527073, 0.09920593861575921, 0.08448511473293752, 0.10309712411163019, 0.08574628213079993, 0.08151030848694718, 0.11428877118429659, 0.09199072820039078, 0.09878017281387697, 0.08459553934102682, 0.14586088371819828, 0.16107027969015175, 0.13299477672712767, 0.17898534512216868, 0.17106950394219544, 0.14938781633291087, 0.23545503488547026, 0.25057753391236415, 0.13358913148593765, 0.32654084081948054, 0.306294125539072, 0.30591222320518785, 0.299950162285227, 0.33248009374643894, 0.30866567007896706, 0.36052225616174194, 0.3129116231086003, 0.3447647866849267, 0.25119545873505567, 0.24787546578450348, 0.2516067766281148, 0.2583501964698458, 0.2482857733932461, 0.2520200308361781, 0.26267574253047865, 0.2618569906398227, 0.25512979882112663, 0.20277319885618994, 0.18534396558315147, 0.1865089455282628, 0.22382743859044174, 0.17991842193806518, 0.1687383942225893, 0.18326034524279944, 0.20829248639771292, 0.18587605737709623, 0.18570516684276783, 0.2075051136743522, 0.171950856291039, 0.20824037740429546, 0.18982885832259222, 0.1933350563959253, 0.18271064734997333, 0.1728308466143642, 0.18353721129968636, 0.18784663838060278, 0.14061616330781712, 0.15781689280240285, 0.16975017763670108, 0.16368508528106418, 0.19382755983024214, 0.17980304822511517, 0.5260678453309022, 0.5700009317240805, 0.16045757176399023, 0.7370884675218563, 0.6619484442040647, 0.15632030895717797, 0.20127665902260228, 0.6378963850685705, 0.20603695603964256, 0.16007229933884648, 0.7441842760424853, 0.17224390413938473, 0.18371838727141543, 0.18687602572312167, 0.18736874407686832, 0.18806925594394408, 0.19231331223070436, 0.1733492575821447, 0.16791609648360206, 0.1924213588503051, 0.06787631931001192, 0.06668273090352395, 0.07556170910123106, 0.07011945322756796, 0.06761157809446994, 0.07240743471868771, 0.08668534073239831, 0.07648957237646214, 0.07272599650879841]}, "mutation_prompt": null}
{"id": "b016fa9c-e9ad-4c9b-8f3e-3fbc7e32ce52", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1781f53c-d427-415b-b341-51b757b0883a", "metadata": {"aucs": [0.8155080130564687, 0.7559033804976276, 0.7905083647019924, 0.7706365799583045, 0.7720004892919544, 0.7593470219345677, 0.7537370188105208, 0.760038582709117, 0.7688127909607124, 0.5655881478001787, 0.5774910683303923, 0.5640605575423558, 0.5925450739444624, 0.572418207547452, 0.6097388193042579, 0.5556425429128315, 0.5794651159433983, 0.4865324343657187, 0.10943136396215947, 0.09551252924468845, 0.19098254722941055, 0.1241651193987725, 0.11679336299777643, 0.11247960589287809, 0.16658243415655982, 0.1632262133238752, 0.11016878883262637, 0.10253476795804106, 0.10701880832640687, 0.11420581915681427, 0.0991033430946705, 0.09434269006753326, 0.09919209965355336, 0.0899865563697555, 0.0976362981869745, 0.10370745962354033, 0.923371693436908, 0.9363393286271675, 0.9608986395726264, 0.9463349414245236, 0.9247224580034754, 0.9279701146332561, 0.9364984422653984, 0.892427483563698, 0.9327239774445928, 0.38961470800148157, 0.3963780867715607, 0.3686744308588069, 0.3515614301952177, 0.38238093954163144, 0.43305139347151844, 0.41129460015236496, 0.3709672897802697, 0.41145014541706304, 0.6318642824223506, 0.6570223002505244, 0.6689572208121993, 0.7081456948982934, 0.7229000682226474, 0.6888472264719517, 0.7369845083567743, 0.687656214634984, 0.6319416473784123, 0.20893564626953753, 0.16228156593626775, 0.17338691928834882, 0.17647999228280753, 0.24285597991865826, 0.16118881822081088, 0.24473973831693185, 0.16551774375254769, 0.23476747011081156, 0.14383782780042698, 0.20626465327264576, 0.15773475133562065, 0.170206041048668, 0.21390758419115674, 0.21210583976041686, 0.20367153521640124, 0.24212705844334348, 0.2874615594205191, 0.24943938636657104, 0.1516988015971077, 0.14246514859489356, 0.16179380538329502, 0.05283406603146834, 0.16399208308360724, 0.08230390917160779, 0.23903450289247374, 0.19828219686521076, 0.38785787456595877, 0.1944053508152328, 0.20255903876423798, 0.30903918241211026, 0.08832873300199118, 0.2857456767736388, 0.2542965026183789, 0.3312113038170096, 0.26096961762957693, 0.1340230634623918, 0.06850336774886201, 0.0776777271545539, 0.13454392931627845, 0.16769666118628357, 0.13932391155391777, 0.19572413483334838, 0.10905776980095017, 0.07939909619366403, 0.21869671965659854, 0.24069183744191902, 0.2449777441711366, 0.24249713021935504, 0.22925334786160378, 0.21948998938137942, 0.22631154759998884, 0.13903149065133602, 0.2123170410292312, 0.592410353772121, 0.5684522966706104, 0.620032363275939, 0.5112054176539589, 0.5671683914164736, 0.5588984269431831, 0.5721274467175509, 0.6286008067195519, 0.4918649782488407, 0.1012396790249328, 0.0902208929203181, 0.09910907027098126, 0.08495686269696978, 0.08939890254541771, 0.10663674442861903, 0.11445232136113026, 0.09868097204222592, 0.09350706528911856, 0.15083767353253552, 0.12925164396279065, 0.12927750175204256, 0.14393042481362028, 0.13517460891076039, 0.16922078480273417, 0.17726654486825955, 0.17899464471903337, 0.14806208923146802, 0.3385064755394417, 0.3420195134293488, 0.37353325323882947, 0.38367508340147016, 0.36743206885613455, 0.3558564247864303, 0.3846914821853128, 0.44415119438478146, 0.30676904999245347, 0.25601381386222477, 0.2826239374327034, 0.2430533894011503, 0.2700414170094949, 0.20531713781403182, 0.25824891401701033, 0.25161223547838085, 0.27354689584154246, 0.2489349943783482, 0.211943166537908, 0.1711755788774303, 0.1829352222178865, 0.18306520226945278, 0.19257543927701726, 0.1886523531768498, 0.1983072573583481, 0.1817123683265266, 0.20729085075393172, 0.1938562863628135, 0.18021484475111627, 0.17425845280891605, 0.21246585147881236, 0.2063308769307325, 0.18989750267968653, 0.2049176702240061, 0.20565710230219647, 0.1965406425342291, 0.7705403016370592, 0.731721010009793, 0.6774948716833766, 0.16940668299918094, 0.18148865100910339, 0.6363469912578363, 0.6058619081548582, 0.6134353036444747, 0.6609550140440952, 0.5626305444830952, 0.20245676549081038, 0.2028523864752264, 0.1997670225341035, 0.16160522813605516, 0.3898407233241753, 0.2085555458785595, 0.2017501609276201, 0.2172740397968571, 0.20267674272573766, 0.19313308227723391, 0.1838331864222783, 0.17655238715641697, 0.17402241032542243, 0.1844822118261935, 0.19108853101452516, 0.1985809825634044, 0.19006367058715223, 0.06864813008708859, 0.0721558288638886, 0.07205634995464061, 0.09150845335842928, 0.08067770296549259, 0.06946006424978224, 0.07282317686083117, 0.08409236261461006, 0.07105247295702777]}, "mutation_prompt": null}
{"id": "bb39fa41-9ea8-47cc-ab74-ef15548efe86", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.5, 0.9)  # Adjusted mutation step\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.7 + 0.2 * (1 - (self.num_evaluations / self.budget))  # Dynamic crossover\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.1 / (1 + np.exp(-0.05 * self.num_evaluations))  # Adjusted step size control\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        initial_pop_size = 20  # Increased initial population size\n        population = self.initialize_population(initial_pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Enhanced Adaptive Scatter Search with Dynamic Population Sizing and Adaptive Mutation for Balanced Exploration-Exploitation.", "configspace": "", "generation": 37, "fitness": 0.2988559502810247, "feedback": "The algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.23.", "error": "", "parent_id": "1781f53c-d427-415b-b341-51b757b0883a", "metadata": {"aucs": [0.6998511516518869, 0.6987076675782822, 0.70622191155604, 0.6982410148730973, 0.7234964970897767, 0.6840623580503642, 0.6677404371205383, 0.6913485945821926, 0.7199478194681406, 0.45464682719941274, 0.4814967951938842, 0.46892466643069486, 0.5156097492219267, 0.4692127838069988, 0.5074356999700302, 0.45537165689635095, 0.4872650015195116, 0.455462359052318, 0.11166935254530708, 0.10010308548088798, 0.11735107936578737, 0.10082490528405341, 0.09593401828605597, 0.1086931367688545, 0.1151582316171762, 0.09985156430959707, 0.11911555697405873, 0.09537771912759563, 0.09631875726113726, 0.08980208110485022, 0.10475064967982384, 0.09149619303131862, 0.0832883904278573, 0.10323471768481662, 0.09816496962640142, 0.0966031395726884, 0.8897274227692351, 0.9230004284837923, 0.961599177943474, 0.8887857322126873, 0.8955606299454103, 0.9255398583677739, 0.9473148772661755, 0.9309222710545764, 0.938168251750744, 0.30931588055874004, 0.352620035265072, 0.3467230348254777, 0.34278263772051676, 0.35040506730154664, 0.3834522492081952, 0.37045384637484413, 0.3789933371024482, 0.3378966330506529, 0.6693154354699093, 0.6126511632811018, 0.5030022481320757, 0.6524952323085413, 0.5858922319762763, 0.7452953990629502, 0.7022584088483019, 0.6366901462038139, 0.6575630217576593, 0.14748914670989377, 0.22047063417121338, 0.21361488159970998, 0.197264010020909, 0.15778473992194342, 0.21889361898420978, 0.16617058287320874, 0.19818009158243155, 0.1547960284122113, 0.1964020645478558, 0.11517480162616922, 0.16178312201101452, 0.25141686884283776, 0.2579694595344655, 0.2130284829247333, 0.19900648150521683, 0.18616343536331292, 0.18061900224189287, 0.1542621437053573, 0.19227546887929525, 0.16482334626424422, 0.19794354706688155, 0.14718986139367607, 0.18241897808830987, 0.21131239898631704, 0.22796337541618572, 0.29219251683949965, 0.3264649537609303, 0.2807874552728584, 0.18710630738659795, 0.3510261937385354, 0.26325050867893607, 0.2775035447025638, 0.26600855820920766, 0.26750164133735377, 0.30036605547279394, 0.05035951584609155, 0.019506430438609668, 0.022278449096689856, 0.06552894137502119, 0.10791333250559487, 0.08493046913797586, 0.0854906938830895, 0.1450601666366942, 0.04806909549158844, 0.16705297458654456, 0.17986148001928015, 0.1683987634843468, 0.18990718141416552, 0.21121205671977072, 0.1692468099414851, 0.20486461152230118, 0.21198794240276797, 0.19693559821376694, 0.5563540806590074, 0.554290529218628, 0.5696257677526225, 0.5191337677426116, 0.5324422273855023, 0.5192459438953791, 0.5331414349321724, 0.5248739669900255, 0.565003992450877, 0.07985756859190063, 0.085858232517663, 0.08910284965089976, 0.08335845299414946, 0.09656075753886739, 0.0928227387053745, 0.08960024646355891, 0.09713671143433733, 0.09742741086213114, 0.13055393972410823, 0.14398033577091085, 0.12434561993380522, 0.17485702845082474, 0.13210656290619194, 0.22222516037401918, 0.1371156926296042, 0.1332973566059905, 0.17347827011978312, 0.32633123298838773, 0.3234867748781408, 0.3203194403976318, 0.2885697991308993, 0.27354793920205955, 0.33923271329597515, 0.31238883542615536, 0.30945606949792903, 0.30710303834646746, 0.22878811124815024, 0.21159562218089922, 0.2200578014645609, 0.2535662764668103, 0.23559282224238054, 0.24200387084139197, 0.2453970218170095, 0.23893743635745002, 0.2459164183468523, 0.1964755696551953, 0.18472005390946378, 0.19980586467868233, 0.19450615716194675, 0.19029399438066796, 0.19311954545949106, 0.17078469248229156, 0.18163568976238986, 0.18209414145782143, 0.1888090032578471, 0.25979849953797973, 0.20929261309424785, 0.17485342944039584, 0.17193842132539483, 0.21037313964179516, 0.1685089841005878, 0.18397793658687556, 0.18936658278759555, 0.6968024964976044, 0.7316153015248883, 0.7186572010167348, 0.16769920892667067, 0.18761670434860067, 0.17688950083828636, 0.19580595440964288, 0.2833673693195399, 0.4978395167947658, 0.47222975467383654, 0.2002186851047898, 0.6971026832168241, 0.6271484602654729, 0.18143269868645095, 0.1537136838638249, 0.204183276220395, 0.20247309813815095, 0.7040476225708262, 0.18823167148448283, 0.17757548603834183, 0.17641778254407514, 0.17476594153126368, 0.18927859591726937, 0.20041806472665735, 0.20142651265582812, 0.17171778183659847, 0.1698244306916773, 0.07768752516136479, 0.07580749971981227, 0.07283410087323972, 0.07161442325973366, 0.07398632549918571, 0.07618560448291023, 0.08523618075319084, 0.060670563278408696, 0.07348734623895747]}, "mutation_prompt": null}
{"id": "b1a9163e-11f2-49f4-b655-84b27cdc93fa", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1781f53c-d427-415b-b341-51b757b0883a", "metadata": {"aucs": [0.8155080130564687, 0.7559033804976276, 0.7905083647019924, 0.7706365799583045, 0.7720004892919544, 0.7593470219345677, 0.7537370188105208, 0.760038582709117, 0.7688127909607124, 0.5655881478001787, 0.5774910683303923, 0.5640605575423558, 0.5925450739444624, 0.572418207547452, 0.6097388193042579, 0.5556425429128315, 0.5794651159433983, 0.4865324343657187, 0.10943136396215947, 0.09551252924468845, 0.19098254722941055, 0.1241651193987725, 0.11679336299777643, 0.11247960589287809, 0.16658243415655982, 0.1632262133238752, 0.11016878883262637, 0.10253476795804106, 0.10701880832640687, 0.11420581915681427, 0.0991033430946705, 0.09434269006753326, 0.09919209965355336, 0.0899865563697555, 0.0976362981869745, 0.10370745962354033, 0.923371693436908, 0.9363393286271675, 0.9608986395726264, 0.9463349414245236, 0.9247224580034754, 0.9279701146332561, 0.9364984422653984, 0.892427483563698, 0.9327239774445928, 0.38961470800148157, 0.3963780867715607, 0.3686744308588069, 0.3515614301952177, 0.38238093954163144, 0.43305139347151844, 0.41129460015236496, 0.3709672897802697, 0.41145014541706304, 0.6318642824223506, 0.6570223002505244, 0.6689572208121993, 0.7081456948982934, 0.7229000682226474, 0.6888472264719517, 0.7369845083567743, 0.687656214634984, 0.6319416473784123, 0.20893564626953753, 0.16228156593626775, 0.17338691928834882, 0.17647999228280753, 0.24285597991865826, 0.16118881822081088, 0.24473973831693185, 0.16551774375254769, 0.23476747011081156, 0.14383782780042698, 0.20626465327264576, 0.15773475133562065, 0.170206041048668, 0.21390758419115674, 0.21210583976041686, 0.20367153521640124, 0.24212705844334348, 0.2874615594205191, 0.24943938636657104, 0.1516988015971077, 0.14246514859489356, 0.16179380538329502, 0.05283406603146834, 0.16399208308360724, 0.08230390917160779, 0.23903450289247374, 0.19828219686521076, 0.38785787456595877, 0.1944053508152328, 0.20255903876423798, 0.30903918241211026, 0.08832873300199118, 0.2857456767736388, 0.2542965026183789, 0.3312113038170096, 0.26096961762957693, 0.1340230634623918, 0.06850336774886201, 0.0776777271545539, 0.13454392931627845, 0.16769666118628357, 0.13932391155391777, 0.19572413483334838, 0.10905776980095017, 0.07939909619366403, 0.21869671965659854, 0.24069183744191902, 0.2449777441711366, 0.24249713021935504, 0.22925334786160378, 0.21948998938137942, 0.22631154759998884, 0.13903149065133602, 0.2123170410292312, 0.592410353772121, 0.5684522966706104, 0.620032363275939, 0.5112054176539589, 0.5671683914164736, 0.5588984269431831, 0.5721274467175509, 0.6286008067195519, 0.4918649782488407, 0.1012396790249328, 0.0902208929203181, 0.09910907027098126, 0.08495686269696978, 0.08939890254541771, 0.10663674442861903, 0.11445232136113026, 0.09868097204222592, 0.09350706528911856, 0.15083767353253552, 0.12925164396279065, 0.12927750175204256, 0.14393042481362028, 0.13517460891076039, 0.16922078480273417, 0.17726654486825955, 0.17899464471903337, 0.14806208923146802, 0.3385064755394417, 0.3420195134293488, 0.37353325323882947, 0.38367508340147016, 0.36743206885613455, 0.3558564247864303, 0.3846914821853128, 0.44415119438478146, 0.30676904999245347, 0.25601381386222477, 0.2826239374327034, 0.2430533894011503, 0.2700414170094949, 0.20531713781403182, 0.25824891401701033, 0.25161223547838085, 0.27354689584154246, 0.2489349943783482, 0.211943166537908, 0.1711755788774303, 0.1829352222178865, 0.18306520226945278, 0.19257543927701726, 0.1886523531768498, 0.1983072573583481, 0.1817123683265266, 0.20729085075393172, 0.1938562863628135, 0.18021484475111627, 0.17425845280891605, 0.21246585147881236, 0.2063308769307325, 0.18989750267968653, 0.2049176702240061, 0.20565710230219647, 0.1965406425342291, 0.7705403016370592, 0.731721010009793, 0.6774948716833766, 0.16940668299918094, 0.18148865100910339, 0.6363469912578363, 0.6058619081548582, 0.6134353036444747, 0.6609550140440952, 0.5626305444830952, 0.20245676549081038, 0.2028523864752264, 0.1997670225341035, 0.16160522813605516, 0.3898407233241753, 0.2085555458785595, 0.2017501609276201, 0.2172740397968571, 0.20267674272573766, 0.19313308227723391, 0.1838331864222783, 0.17655238715641697, 0.17402241032542243, 0.1844822118261935, 0.19108853101452516, 0.1985809825634044, 0.19006367058715223, 0.06864813008708859, 0.0721558288638886, 0.07205634995464061, 0.09150845335842928, 0.08067770296549259, 0.06946006424978224, 0.07282317686083117, 0.08409236261461006, 0.07105247295702777]}, "mutation_prompt": null}
{"id": "bfc748a2-2256-4d52-8e8c-8a039d0b97ec", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.5, 0.9)  # Adjusted lower bound\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.7 - 0.2 * (self.num_evaluations / self.budget)  # Adjusted starting probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.3 / (1 + np.exp(-0.1 * self.num_evaluations))  # Increased step size\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        initial_pop_size = 20  # Increased initial population size\n        population = self.initialize_population(initial_pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Enhanced Adaptive Scatter Search with Dynamic Population and Adaptive Crossover for Improved Exploration and Exploitation Balance.", "configspace": "", "generation": 39, "fitness": 0.23783467581575546, "feedback": "The algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.21.", "error": "", "parent_id": "1781f53c-d427-415b-b341-51b757b0883a", "metadata": {"aucs": [0.6919958464095464, 0.6470088366125295, 0.7237936291332012, 0.7035586292669562, 0.7099689012105361, 0.7093482722873791, 0.7044793972655099, 0.6980514907109027, 0.7120371635208379, 0.4479371260030365, 0.4863009178188126, 0.43580089906285036, 0.4456079908132241, 0.47518460757279246, 0.3935293522601707, 0.46331081017171694, 0.47962958471939854, 0.5258419684409761, 0.14890289538257162, 0.10027588226313944, 0.12099696831865636, 0.12136304518617469, 0.10882031494360977, 0.11768021345403135, 0.14019415220379883, 0.15173185057647043, 0.11987651676978017, 0.11274216302791251, 0.102971854831581, 0.1050964140798486, 0.1107150707042962, 0.10070303783025447, 0.11229429111406586, 0.11443412948502463, 0.11698100649747101, 0.11240730748087413, 0.9371523794387742, 0.9498393685905472, 0.9471255358481563, 0.9478251020072925, 0.949815759314328, 0.9184108929926798, 0.938722502657702, 0.9341667862811405, 0.9334160203360345, 0.26002761902768023, 0.2738587248053598, 0.29600998689458213, 0.25938318921939807, 0.2541778813106672, 0.3117778598699681, 0.2835307923110302, 0.2722610264626112, 0.27543153954899546, 0.2702884276132852, 0.2728975998082974, 0.2823349367636969, 0.26771068106968, 0.34051109090515896, 0.2950099956061263, 0.2718608847439623, 0.34981049917460727, 0.2723367030523959, 0.16180272273407503, 0.1325387687973988, 0.15352450558256825, 0.14673076251898076, 0.12677186067076363, 0.14705345672232417, 0.17376785343277246, 0.16426287492881053, 0.13239352745823274, 0.15482876519092237, 0.12976884154260804, 0.12309588891760237, 0.15692846233252655, 0.13210794503986623, 0.13560303824268116, 0.1377503506385026, 0.12276814836614847, 0.13264930198455882, 0.003688969911592399, 0.013310627899421501, 0.006993185651210876, 0.0015908242886601975, 0.008067990140428805, 0.000104535581781251, 0.009643849618133027, 9.999999999998899e-05, 9.999999999998899e-05, 0.10148451660882707, 0.11728167065608064, 0.1151504984045898, 0.13019912184019522, 0.08100163249590864, 0.072359947612754, 0.1364402226757815, 0.12133174346945852, 0.1041677068548319, 0.008641118038450801, 0.00011962581082625157, 9.999999999998899e-05, 0.009586889359746276, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005019858554479062, 9.999999999998899e-05, 0.08213455080781129, 0.0997848698365551, 0.10750361774645478, 0.10325534686648374, 0.09959166297461541, 0.1116571256826514, 0.10124443974704278, 0.11284058501129235, 0.10547284937806545, 0.4319011598035186, 0.4243133799071761, 0.4688277410988181, 0.4778317775652332, 0.4632503161841489, 0.44584736601184927, 0.4346406233203278, 0.44560785303331985, 0.45933488248865084, 0.08739389012235954, 0.09011844044590667, 0.07768898760425202, 0.0817658927269107, 0.08378221394278573, 0.0798287042818785, 0.11131248482837086, 0.07848375557718479, 0.09898869299621382, 0.15152925353279456, 0.14740502198778216, 0.1348662852522009, 0.13446653612767456, 0.1318203954700855, 0.12833900794689435, 0.18147584554683494, 0.1311696383156955, 0.14477258625816225, 0.2716169832502484, 0.2800914293719299, 0.2763955332912489, 0.27355893704081613, 0.2849069710744645, 0.25119148300730354, 0.29253150144372064, 0.3051711254725984, 0.2781950527803557, 0.20984406666480104, 0.19049061587203775, 0.1859869770219783, 0.16862448129183194, 0.18511396243755696, 0.19555934923693463, 0.1987932868723713, 0.1978250764290972, 0.20236863598560217, 0.1829888650404181, 0.1921029451135614, 0.2003856530904209, 0.18882923977011168, 0.2121080838380751, 0.18268197275194376, 0.17762832398847583, 0.16895121344572417, 0.20506249970308077, 0.16711229289634755, 0.1774629996573438, 0.16903759076550906, 0.18057816859590115, 0.17736532336987332, 0.18291593355509106, 0.20253399119274584, 0.18846303747608184, 0.19601821199067104, 0.3437041409853757, 0.2614314720110624, 0.1782460586583442, 0.16956645250679359, 0.21617887304240524, 0.5154179102172418, 0.1342237682710351, 0.20255364370560236, 0.3517623635206202, 0.16829328745938077, 0.21417721284435998, 0.33852657540783426, 0.18560649243466953, 0.191401186715762, 0.18764911198529677, 0.468161857017776, 0.2084820536459645, 0.336418499693255, 0.18256092005622626, 0.19216827573909667, 0.1764574420302797, 0.17015070818081535, 0.17745837835076472, 0.20264788483894614, 0.18668969740711017, 0.17597984674260936, 0.18689918921389215, 0.07799101249617868, 0.07253581041233614, 0.07552209531983212, 0.0823030150773939, 0.06591224182688837, 0.07184424019652813, 0.07472124294763527, 0.05908822448626139, 0.07032126188472465]}, "mutation_prompt": null}
{"id": "9d34ba8e-6e12-4ad8-8af7-d706c36b38f7", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1781f53c-d427-415b-b341-51b757b0883a", "metadata": {"aucs": [0.8155080130564687, 0.7559033804976276, 0.7905083647019924, 0.7706365799583045, 0.7720004892919544, 0.7593470219345677, 0.7537370188105208, 0.760038582709117, 0.7688127909607124, 0.5655881478001787, 0.5774910683303923, 0.5640605575423558, 0.5925450739444624, 0.572418207547452, 0.6097388193042579, 0.5556425429128315, 0.5794651159433983, 0.4865324343657187, 0.10943136396215947, 0.09551252924468845, 0.19098254722941055, 0.1241651193987725, 0.11679336299777643, 0.11247960589287809, 0.16658243415655982, 0.1632262133238752, 0.11016878883262637, 0.10253476795804106, 0.10701880832640687, 0.11420581915681427, 0.0991033430946705, 0.09434269006753326, 0.09919209965355336, 0.0899865563697555, 0.0976362981869745, 0.10370745962354033, 0.923371693436908, 0.9363393286271675, 0.9608986395726264, 0.9463349414245236, 0.9247224580034754, 0.9279701146332561, 0.9364984422653984, 0.892427483563698, 0.9327239774445928, 0.38961470800148157, 0.3963780867715607, 0.3686744308588069, 0.3515614301952177, 0.38238093954163144, 0.43305139347151844, 0.41129460015236496, 0.3709672897802697, 0.41145014541706304, 0.6318642824223506, 0.6570223002505244, 0.6689572208121993, 0.7081456948982934, 0.7229000682226474, 0.6888472264719517, 0.7369845083567743, 0.687656214634984, 0.6319416473784123, 0.20893564626953753, 0.16228156593626775, 0.17338691928834882, 0.17647999228280753, 0.24285597991865826, 0.16118881822081088, 0.24473973831693185, 0.16551774375254769, 0.23476747011081156, 0.14383782780042698, 0.20626465327264576, 0.15773475133562065, 0.170206041048668, 0.21390758419115674, 0.21210583976041686, 0.20367153521640124, 0.24212705844334348, 0.2874615594205191, 0.24943938636657104, 0.1516988015971077, 0.14246514859489356, 0.16179380538329502, 0.05283406603146834, 0.16399208308360724, 0.08230390917160779, 0.23903450289247374, 0.19828219686521076, 0.38785787456595877, 0.1944053508152328, 0.20255903876423798, 0.30903918241211026, 0.08832873300199118, 0.2857456767736388, 0.2542965026183789, 0.3312113038170096, 0.26096961762957693, 0.1340230634623918, 0.06850336774886201, 0.0776777271545539, 0.13454392931627845, 0.16769666118628357, 0.13932391155391777, 0.19572413483334838, 0.10905776980095017, 0.07939909619366403, 0.21869671965659854, 0.24069183744191902, 0.2449777441711366, 0.24249713021935504, 0.22925334786160378, 0.21948998938137942, 0.22631154759998884, 0.13903149065133602, 0.2123170410292312, 0.592410353772121, 0.5684522966706104, 0.620032363275939, 0.5112054176539589, 0.5671683914164736, 0.5588984269431831, 0.5721274467175509, 0.6286008067195519, 0.4918649782488407, 0.1012396790249328, 0.0902208929203181, 0.09910907027098126, 0.08495686269696978, 0.08939890254541771, 0.10663674442861903, 0.11445232136113026, 0.09868097204222592, 0.09350706528911856, 0.15083767353253552, 0.12925164396279065, 0.12927750175204256, 0.14393042481362028, 0.13517460891076039, 0.16922078480273417, 0.17726654486825955, 0.17899464471903337, 0.14806208923146802, 0.3385064755394417, 0.3420195134293488, 0.37353325323882947, 0.38367508340147016, 0.36743206885613455, 0.3558564247864303, 0.3846914821853128, 0.44415119438478146, 0.30676904999245347, 0.25601381386222477, 0.2826239374327034, 0.2430533894011503, 0.2700414170094949, 0.20531713781403182, 0.25824891401701033, 0.25161223547838085, 0.27354689584154246, 0.2489349943783482, 0.211943166537908, 0.1711755788774303, 0.1829352222178865, 0.18306520226945278, 0.19257543927701726, 0.1886523531768498, 0.1983072573583481, 0.1817123683265266, 0.20729085075393172, 0.1938562863628135, 0.18021484475111627, 0.17425845280891605, 0.21246585147881236, 0.2063308769307325, 0.18989750267968653, 0.2049176702240061, 0.20565710230219647, 0.1965406425342291, 0.7705403016370592, 0.731721010009793, 0.6774948716833766, 0.16940668299918094, 0.18148865100910339, 0.6363469912578363, 0.6058619081548582, 0.6134353036444747, 0.6609550140440952, 0.5626305444830952, 0.20245676549081038, 0.2028523864752264, 0.1997670225341035, 0.16160522813605516, 0.3898407233241753, 0.2085555458785595, 0.2017501609276201, 0.2172740397968571, 0.20267674272573766, 0.19313308227723391, 0.1838331864222783, 0.17655238715641697, 0.17402241032542243, 0.1844822118261935, 0.19108853101452516, 0.1985809825634044, 0.19006367058715223, 0.06864813008708859, 0.0721558288638886, 0.07205634995464061, 0.09150845335842928, 0.08067770296549259, 0.06946006424978224, 0.07282317686083117, 0.08409236261461006, 0.07105247295702777]}, "mutation_prompt": null}
{"id": "ad65489d-3473-42df-88d4-7adc7a6b62cb", "solution": "import numpy as np\n\nclass EnhancedAdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.5, 0.9)  # Changed to enhance exploration\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.8 - 0.3 * (self.num_evaluations / self.budget)  # Adjust to influence exploration/exploitation\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.1 / (1 + np.exp(-0.05 * self.num_evaluations))  # Adjust step size for more gradual changes\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        return new_solution if func(new_solution) < func(solution) else solution\n\n    def __call__(self, func):\n        initial_pop_size = 15  # Slightly increased population size for initial diversity\n        population = self.initialize_population(initial_pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "EnhancedAdaptiveScatterSearch", "description": "Enhanced Adaptive Scatter Search with Dynamic Population Size Adjustment and Improved Diversity Mechanism for Robust Performance.", "configspace": "", "generation": 41, "fitness": 0.30513815889875934, "feedback": "The algorithm EnhancedAdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.25.", "error": "", "parent_id": "1781f53c-d427-415b-b341-51b757b0883a", "metadata": {"aucs": [0.7719956960026684, 0.7829671061106522, 0.762576899144677, 0.7733899267968917, 0.8178812011342358, 0.7910850223131174, 0.8044526485749967, 0.8072313346538637, 0.8016747483964503, 0.6172215372927962, 0.5971788647169987, 0.6245274381314059, 0.5709864061797757, 0.6127749470460682, 0.5771534214004428, 0.5940347688005118, 0.6116325177090045, 0.5662769296886363, 0.18328991977877374, 0.10499219372995361, 0.15123526807696674, 0.11756583023628209, 0.19219567517410607, 0.12873044697023273, 0.11274155567854072, 0.30112201398063276, 0.11789143625560738, 0.11423629144011826, 0.10995553892502052, 0.10810988956133749, 0.1342674359226801, 0.11460301877941914, 0.10873821814750795, 0.10800326384788206, 0.11492980155448118, 0.10719184184365749, 0.954022444442777, 0.9783583257818199, 0.9404106171899433, 0.952092644740131, 0.9135407669829201, 0.921644712618428, 0.9512996878822584, 0.8908273851605265, 0.9466749096757893, 0.39247032120346226, 0.32136048837131337, 0.39173336977555806, 0.4077303837043147, 0.3757799366619162, 0.38434305108639966, 0.38378411006090707, 0.36799346797302523, 0.3708579021734614, 0.5903216258485697, 0.6691406284084016, 0.5661562792223667, 0.6593160843302783, 0.615997448621517, 0.6245845502107892, 0.6058158361878142, 0.6136923825905447, 0.5124883921765157, 0.2148664512796553, 0.21554965021415906, 0.21437978926262635, 0.16945127728410003, 0.18605050175874593, 0.11025694119801244, 0.2104215851671326, 0.16042047381096458, 0.18887209879379097, 0.16838853232408257, 0.2595468169666667, 0.1028094052329327, 0.15455235798159883, 0.18573847145505706, 0.30673886472555667, 0.17266792007856002, 0.13680330277428643, 0.1857855142673387, 0.09171067629463125, 0.06893851201073808, 0.0584265876704998, 0.01581327958349188, 0.01103916711877595, 0.1320591284922772, 0.03921090132489313, 0.02148726108011889, 0.10714799527424679, 0.1633314362152125, 0.1657081708876833, 0.19035111822923645, 0.20439751663060812, 0.09085906043458092, 0.17038791170845802, 0.24103188975391032, 0.2658549108357896, 0.22464502065010594, 0.03640213132353565, 0.04636076154156199, 0.0007863991418560756, 0.04676700241855147, 0.05062504520121347, 0.092621950871976, 0.0637403322134007, 0.06489507535005123, 0.09405058004975164, 0.17685466602529376, 0.16362398928992827, 0.2010036277538032, 0.20140197349970979, 0.1728044230254282, 0.20004930349565675, 0.1691150604568773, 0.16532725956511962, 0.1498258637046569, 0.5296486631805978, 0.5254378582549178, 0.5399568752180023, 0.5089956822040947, 0.5210723122700525, 0.5382585717292154, 0.5258853712417155, 0.5110936866856954, 0.5405701019154274, 0.09915297296055614, 0.11505039225444236, 0.10020090972536233, 0.10217603146783205, 0.09042895871138679, 0.10444439504128733, 0.09136176386961359, 0.07432444789936399, 0.08973558149105954, 0.14397042913417513, 0.14182883018257342, 0.1417980812676808, 0.14372725479621973, 0.1188684719453571, 0.12961726196118273, 0.14251941282361824, 0.2061135505044338, 0.1391557600537482, 0.3217616654840112, 0.33556556432486784, 0.31555999051863093, 0.2700094744203396, 0.3137008351666888, 0.30556870744264186, 0.33493342530568393, 0.36501579459873046, 0.3419585513794249, 0.21612390279410099, 0.2261469108854881, 0.2309816268599707, 0.2423226304193541, 0.24345984140308474, 0.2221594003766706, 0.23064559496210346, 0.2664131198267262, 0.24143316787727043, 0.17383752769910477, 0.19085318046677635, 0.17379197767641286, 0.1932765052296881, 0.21441888687605926, 0.17375086375659754, 0.19027983485746514, 0.18583190672556682, 0.19976927291813829, 0.19727186042340394, 0.18336302985704556, 0.28017980064621595, 0.18002605503076685, 0.19402126099030825, 0.20303177567727004, 0.18873868953608308, 0.1912441270256724, 0.22102007943740387, 0.17007639026364285, 0.7750776936002445, 0.15058688635573403, 0.7514223461403009, 0.18297342404342642, 0.7192564405616637, 0.15809519959871354, 0.4920184293778238, 0.7888720930714888, 0.6008361955964341, 0.2039414404707729, 0.5215659211910894, 0.5249300183477774, 0.19689308614477175, 0.19666209713976146, 0.5507112130160468, 0.6735600441670774, 0.5510397583006653, 0.1937555460255196, 0.18452648288464402, 0.17711661642440324, 0.17423122763769539, 0.18294372220770827, 0.1708500969774288, 0.17479551722621722, 0.18907814609586704, 0.1794136069898533, 0.0790493779121818, 0.07191403137786856, 0.07445003203597711, 0.08103282321092398, 0.0778105276516482, 0.07967535243959645, 0.07238679234924494, 0.07218881088405082, 0.07300971597133044]}, "mutation_prompt": null}
{"id": "dec3eb53-3e02-4092-a1ea-8170d54a1074", "solution": "import numpy as np\n\nclass EnhancedAdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.6, 0.9)  # Adjusted mutation factor range\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def adaptive_crossover(self, target, mutant):\n        cross_prob = 0.8 - 0.3 * np.exp(-0.005 * self.num_evaluations)  # Adaptive crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * np.exp(-0.0025 * self.num_evaluations))  # Dynamic population size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.adaptive_crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "EnhancedAdaptiveScatterSearch", "description": "Enhanced Adaptive Scatter Search with Dynamic Population Adjustment and Adaptive Crossover for Improved Exploration and Exploitation Balance.", "configspace": "", "generation": 42, "fitness": 0.2453831784388783, "feedback": "The algorithm EnhancedAdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.21.", "error": "", "parent_id": "1781f53c-d427-415b-b341-51b757b0883a", "metadata": {"aucs": [0.6162177503710808, 0.6712131677034288, 0.6677233819649371, 0.6795790321591451, 0.6602176842363756, 0.6731530100778436, 0.6844188747262807, 0.6526570442895097, 0.6268640899983869, 0.3739112994620625, 0.3953656331234904, 0.4403358509415676, 0.39742258717825885, 0.3758413011406996, 0.4400040647386707, 0.4113074844439887, 0.4137799151937077, 0.38251485854141065, 0.11400685247195341, 0.1272596856741618, 0.1042916340452813, 0.11597969721206514, 0.09034011599611969, 0.0929933063406736, 0.09883300766753966, 0.10898997761648666, 0.09137577355240678, 0.07981410792326027, 0.10401463671301592, 0.11698556704794394, 0.09528983700333171, 0.09157127699649736, 0.090895908077949, 0.0952343514249353, 0.09273261402698718, 0.10042969946823999, 0.9217764498832468, 0.9363058628829086, 0.9221786816826948, 0.9098561151518969, 0.9247582906287155, 0.9089816487425156, 0.9429237588739456, 0.9415864639096813, 0.8995130207920602, 0.27738396247019037, 0.2369020425576358, 0.256297562400431, 0.29117398495279057, 0.2853141837274228, 0.27229546727030196, 0.2998159741448666, 0.3025975793183987, 0.2737727429804788, 0.4832519259197692, 0.37112617478156307, 0.43976128191055275, 0.28020748697253095, 0.5072528392796647, 0.5137100103202832, 0.4945569228739851, 0.44261949780921905, 0.3875692837161556, 0.17010081619284878, 0.19694871563530036, 0.18161981410695216, 0.17910200179847724, 0.14561401115644335, 0.19737614412326177, 0.16810137524656, 0.15220275245072368, 0.1567612663648672, 0.10100063556590266, 0.15843602323994588, 0.10277724738931338, 0.16831743345784456, 0.12486288605035245, 0.15355390859930917, 0.15079751652668816, 0.11028603509577628, 0.18496527126175744, 0.08015639925485707, 0.05451450338113939, 0.05054012666345209, 0.016553401212628494, 0.08718510671297608, 0.03935333386738671, 0.09550290201966549, 0.07616401082445479, 0.02330825230570388, 0.16438000441906264, 0.1574908917358514, 0.1313263306809893, 0.1386064448973775, 0.1814845387933387, 0.11972766324898898, 0.19781567715161508, 0.2088377258306937, 0.13694339692242796, 0.027111599917431173, 0.009687209366767147, 0.03313673034006648, 0.024036481469445037, 0.007046073574438871, 0.014963326688664846, 0.014531969990033589, 0.015248676269994266, 0.012136186239096403, 0.13692809219849056, 0.1134573595335664, 0.13179876703824134, 0.13377094202645845, 0.12858754171368514, 0.16012124194138777, 0.11426875844743156, 0.12427393120661467, 0.1188019997052705, 0.4792195390309353, 0.4640460442123885, 0.4980274707409079, 0.4472743739879106, 0.47925224928961185, 0.46499751086392715, 0.46382762696405666, 0.4746088419902831, 0.47155063220887883, 0.07648118979509433, 0.08943189247936678, 0.09984829779576265, 0.07826156346070379, 0.07951712086795337, 0.07135428171200786, 0.09069241319584376, 0.08479039902519159, 0.12562143205609322, 0.12880701075279632, 0.12629750457960542, 0.1325321224466406, 0.12518256847346565, 0.18690601409654473, 0.15181714914704958, 0.14333302823634875, 0.12330621948411136, 0.16432032764910032, 0.26636092329660244, 0.24235012614994134, 0.2688541062904194, 0.2393568322845957, 0.2554128965578244, 0.283752767286242, 0.2920655046168187, 0.2787965742089805, 0.29775892864280484, 0.21797511487710497, 0.20334119696268071, 0.19589039267814867, 0.19041999096357387, 0.18377075514575458, 0.18518469356896727, 0.216668572493517, 0.19989905152830068, 0.2107499976193823, 0.18452040000431147, 0.17652579911532973, 0.1881610495605689, 0.1672448747739692, 0.2028817587117977, 0.17863150152358354, 0.1788374715942257, 0.17378538382334352, 0.18410662106166054, 0.1881887555082956, 0.1660744266204136, 0.1714188980304625, 0.1718621295258821, 0.18057253619435976, 0.23089507328427994, 0.18027731816714132, 0.17014999816412268, 0.18824484666103225, 0.599487711556681, 0.1522299817675472, 0.18558926069683968, 0.17186159469554496, 0.18057370347880553, 0.43338532619111925, 0.17714742535156602, 0.33196859756060826, 0.540016119763645, 0.15777204453543014, 0.1910675269205463, 0.15953946027601507, 0.19389355782964823, 0.3847427236064147, 0.358256642100929, 0.204171841242332, 0.14429060903077406, 0.18486966153032613, 0.1746125451652688, 0.18017875128263006, 0.18080295217465914, 0.17268740331875576, 0.1690225359693459, 0.17629306877681628, 0.1792911186151911, 0.17691061569877298, 0.19381438128035955, 0.07844560064250983, 0.06907610619458249, 0.0677954196204098, 0.06864974967171289, 0.07277771876009442, 0.0701450646440096, 0.06436287854520584, 0.0663886457039351, 0.07868035920405059]}, "mutation_prompt": null}
{"id": "1cb83902-082d-4549-8b0a-2cdc77285970", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.5, 0.9)  # Adjusted range for F\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.8 - 0.2 * (self.num_evaluations / self.budget)  # Modified crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.2):  # Adjusted L for Levy flight\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.3 / (1 + np.exp(-0.1 * self.num_evaluations))  # Modified step size\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        initial_pop_size = 15  # Adjusted initial population size\n        population = self.initialize_population(initial_pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Enhanced Adaptive Scatter Search with Dynamic Population Size Adjustment and Improved Local Search Intensification.", "configspace": "", "generation": 43, "fitness": 0.29517026078309133, "feedback": "The algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "1781f53c-d427-415b-b341-51b757b0883a", "metadata": {"aucs": [0.742971357447513, 0.7809466376623333, 0.8145938713835356, 0.7786063455619876, 0.776071936874644, 0.7876050567927354, 0.7629171335894059, 0.7984620774422208, 0.7607548690391679, 0.6064340943171203, 0.5396809572906975, 0.5939184911247553, 0.61860174895494, 0.6219556002819294, 0.6030476093834019, 0.5723487048829523, 0.6167802356662742, 0.5708945978318758, 0.10017143934437567, 0.11544969624596979, 0.12666186907367916, 0.12194436898452199, 0.1503617548772045, 0.15421768309436845, 0.13189050277188852, 0.10880514202717773, 0.1501286941249531, 0.0920628617613134, 0.10212127877184052, 0.11460126008003513, 0.10742584313514236, 0.19485282148673466, 0.115390063794788, 0.10362740947671722, 0.10447907996529615, 0.10465213012241237, 0.9365884436217673, 0.940467610121365, 0.9267202418737142, 0.9797188397110201, 0.9465231193021492, 0.968460652595574, 0.9687914673688199, 0.9177378577471836, 0.9525161429325909, 0.3732837678558204, 0.3083483786352852, 0.34932343051816495, 0.3709035000763661, 0.37043322281365076, 0.4408103526914129, 0.3619490717933228, 0.3493918262151444, 0.38326511583440215, 0.5751397885757549, 0.5854505190174533, 0.55884445505422, 0.650781834635692, 0.5884920636175285, 0.5993199597676969, 0.5691347174495834, 0.6486942894380181, 0.6944852942839346, 0.16486971425073738, 0.2148976051227789, 0.20819333346515623, 0.21402943870679025, 0.17607803288770396, 0.10457481924736911, 0.16642645306398152, 0.17549298723145634, 0.16149766371546137, 0.1082544579819672, 0.15598837986955427, 0.1019198355364731, 0.17274353325949965, 0.1318898974257947, 0.17699041081714517, 0.1781028463542167, 0.13552050753545442, 0.20994917196602414, 0.08093011556464935, 0.07256810961500837, 0.08910169131812218, 0.11951991119061567, 0.0809035895958492, 0.055561661584358935, 0.04683410825135126, 0.13537256050533064, 0.09345183247408073, 0.22486541679549577, 0.1684521902193794, 0.18002609082459353, 0.17924980696418935, 0.03860682784536473, 0.09989912393769451, 0.21080728015030326, 0.2047490427764811, 0.2954720307726125, 0.033307505208821975, 0.03443925214236465, 0.011296356147396214, 0.08497739024717355, 0.07211551774239489, 0.039096803410035186, 0.03199032150910208, 0.07878211284249115, 0.027433736479665072, 0.16655974692221986, 0.17929649711364726, 0.17272407470021356, 0.18210583676384118, 0.15539607240808506, 0.20234663758791926, 0.15267568980142587, 0.1892546996847605, 0.18324739838895232, 0.5387914981251305, 0.5388343333607233, 0.542580096884067, 0.4927573944509702, 0.5077735622404773, 0.5351248392141004, 0.529375554962336, 0.5076326337281771, 0.5961923145454764, 0.089980993951004, 0.07992808295945819, 0.09461505408703219, 0.08500775701087826, 0.08117398657316932, 0.10585604601572995, 0.08474141010585012, 0.08754108380764158, 0.08195779006748016, 0.15876893036040696, 0.1482314499343802, 0.1360452595003928, 0.12146728603268253, 0.19523933118078962, 0.2208951296557764, 0.1713849618083193, 0.1302488664469158, 0.13384088285216345, 0.3509790504002043, 0.3437526292980425, 0.32054962050776026, 0.3210676151470607, 0.3219812252397425, 0.3285730577586583, 0.36434080812135483, 0.35422296878427073, 0.35137933554511935, 0.2608414612415316, 0.2716649527859619, 0.20826523291542232, 0.21846898594330078, 0.22330171641966567, 0.24935355552449034, 0.2598974205178197, 0.2330845264256458, 0.25926363333810976, 0.18110011485915722, 0.21402761773667944, 0.22017469007490764, 0.18129508524903226, 0.18201180185310994, 0.21266239492617156, 0.18558465883070685, 0.1919118929441841, 0.2266712920333911, 0.33679719165338584, 0.19119152075853785, 0.2087471186817761, 0.21478403984661576, 0.22118696546989847, 0.20552755248537002, 0.30236216978725616, 0.19712819741722498, 0.40093568737796415, 0.17009432720990003, 0.16400874590401304, 0.14814542454652324, 0.1804924358554052, 0.1740965482007547, 0.5502413109062463, 0.5907261029375448, 0.18362988823361337, 0.1741206386608939, 0.46472396840176444, 0.4973917323755862, 0.684125711617638, 0.39847967006602447, 0.3219048703835261, 0.1947856582346439, 0.2110664173665201, 0.2025206638139918, 0.6312498663311719, 0.19066560037757518, 0.17494760901472073, 0.16894759463290554, 0.1939771578407038, 0.17311948966433488, 0.18708553449035015, 0.1900184331520952, 0.19364150182625728, 0.17648536805078274, 0.08833544518614378, 0.0737705355447581, 0.06312279255710418, 0.07751386227705748, 0.062323505234601506, 0.07423510701594982, 0.06676478906735517, 0.0734171050925504, 0.08367928317856987]}, "mutation_prompt": null}
{"id": "65e17c83-97f9-4302-acd8-f2401b9f471d", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1781f53c-d427-415b-b341-51b757b0883a", "metadata": {"aucs": [0.8155080130564687, 0.7559033804976276, 0.7905083647019924, 0.7706365799583045, 0.7720004892919544, 0.7593470219345677, 0.7537370188105208, 0.760038582709117, 0.7688127909607124, 0.5655881478001787, 0.5774910683303923, 0.5640605575423558, 0.5925450739444624, 0.572418207547452, 0.6097388193042579, 0.5556425429128315, 0.5794651159433983, 0.4865324343657187, 0.10943136396215947, 0.09551252924468845, 0.19098254722941055, 0.1241651193987725, 0.11679336299777643, 0.11247960589287809, 0.16658243415655982, 0.1632262133238752, 0.11016878883262637, 0.10253476795804106, 0.10701880832640687, 0.11420581915681427, 0.0991033430946705, 0.09434269006753326, 0.09919209965355336, 0.0899865563697555, 0.0976362981869745, 0.10370745962354033, 0.923371693436908, 0.9363393286271675, 0.9608986395726264, 0.9463349414245236, 0.9247224580034754, 0.9279701146332561, 0.9364984422653984, 0.892427483563698, 0.9327239774445928, 0.38961470800148157, 0.3963780867715607, 0.3686744308588069, 0.3515614301952177, 0.38238093954163144, 0.43305139347151844, 0.41129460015236496, 0.3709672897802697, 0.41145014541706304, 0.6318642824223506, 0.6570223002505244, 0.6689572208121993, 0.7081456948982934, 0.7229000682226474, 0.6888472264719517, 0.7369845083567743, 0.687656214634984, 0.6319416473784123, 0.20893564626953753, 0.16228156593626775, 0.17338691928834882, 0.17647999228280753, 0.24285597991865826, 0.16118881822081088, 0.24473973831693185, 0.16551774375254769, 0.23476747011081156, 0.14383782780042698, 0.20626465327264576, 0.15773475133562065, 0.170206041048668, 0.21390758419115674, 0.21210583976041686, 0.20367153521640124, 0.24212705844334348, 0.2874615594205191, 0.24943938636657104, 0.1516988015971077, 0.14246514859489356, 0.16179380538329502, 0.05283406603146834, 0.16399208308360724, 0.08230390917160779, 0.23903450289247374, 0.19828219686521076, 0.38785787456595877, 0.1944053508152328, 0.20255903876423798, 0.30903918241211026, 0.08832873300199118, 0.2857456767736388, 0.2542965026183789, 0.3312113038170096, 0.26096961762957693, 0.1340230634623918, 0.06850336774886201, 0.0776777271545539, 0.13454392931627845, 0.16769666118628357, 0.13932391155391777, 0.19572413483334838, 0.10905776980095017, 0.07939909619366403, 0.21869671965659854, 0.24069183744191902, 0.2449777441711366, 0.24249713021935504, 0.22925334786160378, 0.21948998938137942, 0.22631154759998884, 0.13903149065133602, 0.2123170410292312, 0.592410353772121, 0.5684522966706104, 0.620032363275939, 0.5112054176539589, 0.5671683914164736, 0.5588984269431831, 0.5721274467175509, 0.6286008067195519, 0.4918649782488407, 0.1012396790249328, 0.0902208929203181, 0.09910907027098126, 0.08495686269696978, 0.08939890254541771, 0.10663674442861903, 0.11445232136113026, 0.09868097204222592, 0.09350706528911856, 0.15083767353253552, 0.12925164396279065, 0.12927750175204256, 0.14393042481362028, 0.13517460891076039, 0.16922078480273417, 0.17726654486825955, 0.17899464471903337, 0.14806208923146802, 0.3385064755394417, 0.3420195134293488, 0.37353325323882947, 0.38367508340147016, 0.36743206885613455, 0.3558564247864303, 0.3846914821853128, 0.44415119438478146, 0.30676904999245347, 0.25601381386222477, 0.2826239374327034, 0.2430533894011503, 0.2700414170094949, 0.20531713781403182, 0.25824891401701033, 0.25161223547838085, 0.27354689584154246, 0.2489349943783482, 0.211943166537908, 0.1711755788774303, 0.1829352222178865, 0.18306520226945278, 0.19257543927701726, 0.1886523531768498, 0.1983072573583481, 0.1817123683265266, 0.20729085075393172, 0.1938562863628135, 0.18021484475111627, 0.17425845280891605, 0.21246585147881236, 0.2063308769307325, 0.18989750267968653, 0.2049176702240061, 0.20565710230219647, 0.1965406425342291, 0.7705403016370592, 0.731721010009793, 0.6774948716833766, 0.16940668299918094, 0.18148865100910339, 0.6363469912578363, 0.6058619081548582, 0.6134353036444747, 0.6609550140440952, 0.5626305444830952, 0.20245676549081038, 0.2028523864752264, 0.1997670225341035, 0.16160522813605516, 0.3898407233241753, 0.2085555458785595, 0.2017501609276201, 0.2172740397968571, 0.20267674272573766, 0.19313308227723391, 0.1838331864222783, 0.17655238715641697, 0.17402241032542243, 0.1844822118261935, 0.19108853101452516, 0.1985809825634044, 0.19006367058715223, 0.06864813008708859, 0.0721558288638886, 0.07205634995464061, 0.09150845335842928, 0.08067770296549259, 0.06946006424978224, 0.07282317686083117, 0.08409236261461006, 0.07105247295702777]}, "mutation_prompt": null}
{"id": "8fbc3cf8-e3eb-4dff-9d6d-a78c2a3be102", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1781f53c-d427-415b-b341-51b757b0883a", "metadata": {"aucs": [0.8155080130564687, 0.7559033804976276, 0.7905083647019924, 0.7706365799583045, 0.7720004892919544, 0.7593470219345677, 0.7537370188105208, 0.760038582709117, 0.7688127909607124, 0.5655881478001787, 0.5774910683303923, 0.5640605575423558, 0.5925450739444624, 0.572418207547452, 0.6097388193042579, 0.5556425429128315, 0.5794651159433983, 0.4865324343657187, 0.10943136396215947, 0.09551252924468845, 0.19098254722941055, 0.1241651193987725, 0.11679336299777643, 0.11247960589287809, 0.16658243415655982, 0.1632262133238752, 0.11016878883262637, 0.10253476795804106, 0.10701880832640687, 0.11420581915681427, 0.0991033430946705, 0.09434269006753326, 0.09919209965355336, 0.0899865563697555, 0.0976362981869745, 0.10370745962354033, 0.923371693436908, 0.9363393286271675, 0.9608986395726264, 0.9463349414245236, 0.9247224580034754, 0.9279701146332561, 0.9364984422653984, 0.892427483563698, 0.9327239774445928, 0.38961470800148157, 0.3963780867715607, 0.3686744308588069, 0.3515614301952177, 0.38238093954163144, 0.43305139347151844, 0.41129460015236496, 0.3709672897802697, 0.41145014541706304, 0.6318642824223506, 0.6570223002505244, 0.6689572208121993, 0.7081456948982934, 0.7229000682226474, 0.6888472264719517, 0.7369845083567743, 0.687656214634984, 0.6319416473784123, 0.20893564626953753, 0.16228156593626775, 0.17338691928834882, 0.17647999228280753, 0.24285597991865826, 0.16118881822081088, 0.24473973831693185, 0.16551774375254769, 0.23476747011081156, 0.14383782780042698, 0.20626465327264576, 0.15773475133562065, 0.170206041048668, 0.21390758419115674, 0.21210583976041686, 0.20367153521640124, 0.24212705844334348, 0.2874615594205191, 0.24943938636657104, 0.1516988015971077, 0.14246514859489356, 0.16179380538329502, 0.05283406603146834, 0.16399208308360724, 0.08230390917160779, 0.23903450289247374, 0.19828219686521076, 0.38785787456595877, 0.1944053508152328, 0.20255903876423798, 0.30903918241211026, 0.08832873300199118, 0.2857456767736388, 0.2542965026183789, 0.3312113038170096, 0.26096961762957693, 0.1340230634623918, 0.06850336774886201, 0.0776777271545539, 0.13454392931627845, 0.16769666118628357, 0.13932391155391777, 0.19572413483334838, 0.10905776980095017, 0.07939909619366403, 0.21869671965659854, 0.24069183744191902, 0.2449777441711366, 0.24249713021935504, 0.22925334786160378, 0.21948998938137942, 0.22631154759998884, 0.13903149065133602, 0.2123170410292312, 0.592410353772121, 0.5684522966706104, 0.620032363275939, 0.5112054176539589, 0.5671683914164736, 0.5588984269431831, 0.5721274467175509, 0.6286008067195519, 0.4918649782488407, 0.1012396790249328, 0.0902208929203181, 0.09910907027098126, 0.08495686269696978, 0.08939890254541771, 0.10663674442861903, 0.11445232136113026, 0.09868097204222592, 0.09350706528911856, 0.15083767353253552, 0.12925164396279065, 0.12927750175204256, 0.14393042481362028, 0.13517460891076039, 0.16922078480273417, 0.17726654486825955, 0.17899464471903337, 0.14806208923146802, 0.3385064755394417, 0.3420195134293488, 0.37353325323882947, 0.38367508340147016, 0.36743206885613455, 0.3558564247864303, 0.3846914821853128, 0.44415119438478146, 0.30676904999245347, 0.25601381386222477, 0.2826239374327034, 0.2430533894011503, 0.2700414170094949, 0.20531713781403182, 0.25824891401701033, 0.25161223547838085, 0.27354689584154246, 0.2489349943783482, 0.211943166537908, 0.1711755788774303, 0.1829352222178865, 0.18306520226945278, 0.19257543927701726, 0.1886523531768498, 0.1983072573583481, 0.1817123683265266, 0.20729085075393172, 0.1938562863628135, 0.18021484475111627, 0.17425845280891605, 0.21246585147881236, 0.2063308769307325, 0.18989750267968653, 0.2049176702240061, 0.20565710230219647, 0.1965406425342291, 0.7705403016370592, 0.731721010009793, 0.6774948716833766, 0.16940668299918094, 0.18148865100910339, 0.6363469912578363, 0.6058619081548582, 0.6134353036444747, 0.6609550140440952, 0.5626305444830952, 0.20245676549081038, 0.2028523864752264, 0.1997670225341035, 0.16160522813605516, 0.3898407233241753, 0.2085555458785595, 0.2017501609276201, 0.2172740397968571, 0.20267674272573766, 0.19313308227723391, 0.1838331864222783, 0.17655238715641697, 0.17402241032542243, 0.1844822118261935, 0.19108853101452516, 0.1985809825634044, 0.19006367058715223, 0.06864813008708859, 0.0721558288638886, 0.07205634995464061, 0.09150845335842928, 0.08067770296549259, 0.06946006424978224, 0.07282317686083117, 0.08409236261461006, 0.07105247295702777]}, "mutation_prompt": null}
{"id": "28b46e7f-e9e0-4e9a-ad5d-7ddb4ff81a9f", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = 0.5 + np.random.rand() * 0.3  # Adjusted mutation factor\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.8 + 0.2 * np.sin(np.pi * (self.num_evaluations / self.budget))  # Dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.1 + 0.1 * (1 - (self.num_evaluations / self.budget))  # Adaptive step size\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 12 + int(8 * (1 - (self.num_evaluations / self.budget)))  # Adjusted population size calculation\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Enhanced Adaptive Scatter Search with Dynamic Crossover Rate and Adaptive Levy Flight Scaling for Improved Exploration-Exploitation Balance.", "configspace": "", "generation": 46, "fitness": 0.30990283266855423, "feedback": "The algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.", "error": "", "parent_id": "1781f53c-d427-415b-b341-51b757b0883a", "metadata": {"aucs": [0.707024623094828, 0.7148086793526656, 0.7477428286015819, 0.711808392807219, 0.7134346256183217, 0.7339874092078856, 0.7384146957072426, 0.7200813352139568, 0.729529808479461, 0.4881660338496502, 0.4906507385210729, 0.4985856917608873, 0.5229177051457411, 0.54054637518468, 0.5128864362346317, 0.5489974901545837, 0.4626980688299869, 0.4807953268229539, 0.10954213077461139, 0.10985496760298319, 0.08945774242575533, 0.11141041881291802, 0.09972557952703698, 0.11763886205513141, 0.10228993055341429, 0.11359321599323213, 0.11555914321228267, 0.08572863390316887, 0.09325674928494732, 0.09018063093326167, 0.10406028330975492, 0.09480751316429048, 0.09968985471424074, 0.09285398241358234, 0.0894482109617567, 0.08793363568779244, 0.9149982752182944, 0.9651072544047318, 0.9170726335032985, 0.9475737747020166, 0.9398340198534263, 0.9386440566599865, 0.9411673854970208, 0.9218569519832268, 0.9364722486000031, 0.34340975523556083, 0.35540711050825435, 0.33920875350913504, 0.3654209879069352, 0.375522813979159, 0.35395725683352197, 0.34620416121961484, 0.3709692600805098, 0.3941171761407488, 0.6850369124962041, 0.5849924709947738, 0.5461387774200749, 0.5965651437952606, 0.6560377957451298, 0.5982801811362108, 0.639157446345789, 0.6576785744146862, 0.7108967345692203, 0.20013214603980334, 0.14350178422604765, 0.14555316785321115, 0.18347778956856886, 0.18039258915036172, 0.15719094444088821, 0.21874681616930425, 0.2294504922608458, 0.18896260245463936, 0.20722353465920706, 0.1454932764494271, 0.12722378769162146, 0.18173352210140925, 0.13049864311147086, 0.22866045753630593, 0.1901096757947438, 0.13217255816561413, 0.1812167542193306, 0.23224797440087763, 0.1885129144978217, 0.14126902709322564, 0.186292311811471, 0.24025847373758757, 0.11159350851261973, 0.2129068489573931, 0.250245105977871, 0.1446838153296629, 0.4327035726484888, 0.3411768631784141, 0.1463680970678175, 0.31025917383377144, 0.3079542521845957, 0.28714781432622727, 0.3872722089366899, 0.31799013369279405, 0.3975275155938034, 0.14567739563654047, 0.054186591221510594, 0.06235299575469855, 0.110651042468764, 0.10054402312922261, 0.06549419600134676, 0.10032871445820546, 0.12601022079336266, 0.07320363181629252, 0.17475816066164518, 0.20617353806494154, 0.2040280077281097, 0.2063585100291606, 0.21453295637829273, 0.21937103219802068, 0.20688443705639914, 0.2035613380567507, 0.218558722837348, 0.5965468163330259, 0.5509486160193847, 0.5775152053877157, 0.6164227811736296, 0.5861005143712613, 0.6632980363521518, 0.6130267578591015, 0.5789593321837891, 0.5986399240026608, 0.08634068502546866, 0.08875004908686912, 0.09364603079078537, 0.11082043908562333, 0.10033280079257578, 0.08518785569030718, 0.08557996530349976, 0.09233080481955314, 0.09682223305056814, 0.19372364491916094, 0.2686380644953038, 0.12763097682744318, 0.14410505859014577, 0.22028498209602576, 0.14795483625874184, 0.13211540089853646, 0.19618538081921943, 0.13738064972033115, 0.305433261724695, 0.28866505810656407, 0.27475984917995944, 0.3311835390632989, 0.3096041672245984, 0.3290621420892269, 0.3469182762271228, 0.33797620377036885, 0.3084160078943893, 0.24165506285695038, 0.23992476473304203, 0.24683333395346985, 0.20959828230941346, 0.2657015571129897, 0.25723678768304825, 0.28553286163263936, 0.25508611929895975, 0.2459483883700505, 0.22515041546080705, 0.19764451582716258, 0.1948276322732203, 0.2228677371580463, 0.1847970875170889, 0.18288776066044643, 0.1878203396039576, 0.21295962829184867, 0.18718929611623625, 0.1946396299512152, 0.17405548848917096, 0.1717966307559946, 0.19758024683513176, 0.19955930894961715, 0.17324025615668726, 0.31517245646143766, 0.1916714150692057, 0.18452091366165502, 0.8079606884737297, 0.1652798027793435, 0.1868029977523442, 0.648491491435411, 0.18271634499585876, 0.7031827537049026, 0.13692929752177585, 0.597468177775543, 0.15958228899419513, 0.6982050077358263, 0.5587743525866481, 0.1235011957831581, 0.17478376400813145, 0.5926020560596306, 0.600740075708752, 0.20638355733778657, 0.20114051979955028, 0.7045079170391391, 0.17199202230672395, 0.18646424041794307, 0.17800549182899505, 0.18038775768106297, 0.1814169956425733, 0.19238129134901716, 0.202112220642241, 0.18979151048143406, 0.18568780869914647, 0.07177067579293561, 0.06721983982949875, 0.06968669769271452, 0.07400253324161388, 0.07651440429297274, 0.07117837917823633, 0.07519995996460715, 0.06180675801155866, 0.07447538480527505]}, "mutation_prompt": null}
{"id": "2ab38239-e733-4736-a2e2-00ef35f511f5", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.5, 0.9)  # Adjusted to enhance exploration\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.7 + 0.2 * np.sin(2 * np.pi * (self.num_evaluations / self.budget))  # Dynamic crossover rate\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.1 / (1 + np.exp(-0.05 * self.num_evaluations))  # Adjusted step size for adaptive levy\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 12 + int(8 * (1 - (self.num_evaluations / self.budget)))  # Dynamic population size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Enhanced Adaptive Scatter Search with Dynamic Population and Adaptive Levy Step for Better Exploration and Exploitation Balance.", "configspace": "", "generation": 47, "fitness": 0.27763430322410215, "feedback": "The algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "1781f53c-d427-415b-b341-51b757b0883a", "metadata": {"aucs": [0.7059967546971815, 0.6802310175794015, 0.6676106852435237, 0.7171835026734762, 0.7079105954050573, 0.7247306172815289, 0.7065184619650207, 0.7318669105008456, 0.7177895092391071, 0.4259056046357047, 0.4911189505787913, 0.38968173297638287, 0.4898533584407151, 0.45208012347557736, 0.48346328030640606, 0.4270248308469353, 0.4621606593811406, 0.5067293185773216, 0.1045064694574932, 0.09261865233719724, 0.12475645569282912, 0.11825967307746743, 0.0976238478207957, 0.09162379993724623, 0.11889702061989049, 0.10302645828680834, 0.11060402507196143, 0.10833113572030595, 0.10021357207425152, 0.08666153181948555, 0.09939580955159422, 0.08838172819544599, 0.11416731610669051, 0.08807440065198202, 0.09338367738095898, 0.08351638429050723, 0.8628693826390634, 0.9241841208031272, 0.9362379491787289, 0.9374922173189727, 0.925085462684489, 0.9188730686489841, 0.9413837526351452, 0.9531164886444561, 0.9302096061127055, 0.2993491638545779, 0.3042245518946165, 0.3627946846454626, 0.3397724202436838, 0.32978638129855087, 0.34126324173944544, 0.3569473087217635, 0.3060438834913167, 0.29527710381955563, 0.55174624280821, 0.5561883029772309, 0.5114178448719107, 0.5808204670987454, 0.5241642943792661, 0.5774110796471639, 0.5898316858561812, 0.6016008948762445, 0.6275308553077938, 0.15153290671986275, 0.16995579368320868, 0.2010427347599858, 0.10311985554727876, 0.15237383863932663, 0.16848448808663996, 0.24706110625620215, 0.23101333421055037, 0.1473067386167941, 0.13341971548454545, 0.14119482698386987, 0.1441357278225609, 0.1430695862777227, 0.11780851122761327, 0.17044050423383506, 0.19391406113988074, 0.1572605600162753, 0.23948772177511368, 0.08309476679514194, 0.06787199403449229, 0.14057099218846159, 0.14404939410228113, 0.11619998356101313, 0.09753078290158157, 0.12586154416323225, 0.12294452661551403, 0.11079610845439514, 0.24150499692493088, 0.16830230760825893, 0.25852663711922164, 0.21521525630624705, 0.25705036417130545, 0.23912903783116646, 0.2928992203177476, 0.25346547923834994, 0.22254829915965468, 0.07006188765272436, 0.013910768377522476, 0.03947823692656616, 0.059588565012986705, 0.06495197826451748, 0.04536931083957785, 0.06070444421186805, 0.08939312549064327, 0.029264965245519692, 0.15670052008498947, 0.1484931987900352, 0.16512806645207256, 0.16829105049671467, 0.1721513066186553, 0.15616540512152988, 0.20303101612777086, 0.1606722487231138, 0.17446330125605203, 0.4979939614269502, 0.5418311297638383, 0.5748375325171249, 0.550251829434306, 0.5191280500183021, 0.5419848744256214, 0.5204040108926855, 0.5048756992176037, 0.5565334803686877, 0.08355406740260174, 0.08910206309038204, 0.08364320251555013, 0.10601341056770741, 0.09069086678849747, 0.0846662077464787, 0.08287736976748727, 0.07989930203027851, 0.0886883156977255, 0.12305388019294317, 0.13378988263365277, 0.1509087233234302, 0.15667752749069808, 0.1633490653975932, 0.1462097938400635, 0.14312573070168366, 0.15042116857095478, 0.20583472672631253, 0.282283245302535, 0.3348397451064369, 0.2640692777050987, 0.28434006775248055, 0.23550646457532265, 0.2948497722665919, 0.29895992795067927, 0.31234883836194904, 0.3222455378107627, 0.24162003643442354, 0.22476289526231397, 0.22031780862664307, 0.23085580712904097, 0.21414880523173374, 0.23023718744207466, 0.21793974599257593, 0.25713595192965655, 0.230840212665123, 0.18790929509325482, 0.17855635665028224, 0.18169494326560787, 0.2128164884483642, 0.17989298626489159, 0.17557928978489723, 0.17461362402999436, 0.21077695504335736, 0.19233735727373358, 0.16981944245040503, 0.1900868204629499, 0.1676190520340206, 0.17469465840607556, 0.17325525524619156, 0.27625344912447625, 0.17955827423675985, 0.1993038375693844, 0.1732215427849293, 0.6276818360407841, 0.1887632232117733, 0.14589618546551686, 0.15627040548093007, 0.1571432008911683, 0.1809066109103371, 0.13643874752105223, 0.3791774087550468, 0.4423938721861501, 0.19300377461215634, 0.49189132050669493, 0.5788763354410132, 0.49885863765202054, 0.4360887652980764, 0.14110375784921814, 0.19882993019127737, 0.5553136950443851, 0.1938317420460458, 0.19425908735562403, 0.20377100102405465, 0.1956692191274274, 0.18098728262719965, 0.1764295405392159, 0.19573761961690628, 0.17312541944747462, 0.1727031154355424, 0.1785844452254569, 0.07436915411818101, 0.07760887742082034, 0.06928965801457143, 0.0828378173415153, 0.07028928180037586, 0.0894300720229998, 0.07139200650133803, 0.07666926187034884, 0.07222693278764891]}, "mutation_prompt": null}
{"id": "9963f658-4c68-4955-9fee-dca5814b93c1", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.dynamic_pop_size_factor = 0.1\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.5, 0.9)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        adaptive_step = 0.1 + 0.1 * (1 - (self.num_evaluations / self.budget))\n        new_solution = solution + self.levy_flight() * adaptive_step\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        initial_pop_size = 10 + int(10 * self.dynamic_pop_size_factor)\n        population = self.initialize_population(initial_pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Enhanced Adaptive Scatter Search Utilizing Dynamic Population Resizing and Adaptive Step Size for Improved Global Exploration and Local Exploitation.", "configspace": "", "generation": 48, "fitness": 0.3168580027742767, "feedback": "The algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.25.", "error": "", "parent_id": "1781f53c-d427-415b-b341-51b757b0883a", "metadata": {"aucs": [0.8647887673146856, 0.8150749093628658, 0.7926178182337029, 0.86059803276438, 0.7836411256991073, 0.8405838773791907, 0.8598477120407209, 0.8398385132972154, 0.8736900412187034, 0.5137355582462066, 0.6864165699539049, 0.6112711675849165, 0.7084606992495371, 0.03523490040345856, 0.7017000934789311, 0.6893119174805878, 0.09297389661984035, 0.7146687195730974, 0.13842895178007986, 0.14421116444475923, 0.15541171969875744, 0.2252997150158128, 0.15631870655715685, 0.13928880542635547, 0.10929093786131039, 0.14221794677646593, 0.21524495898938167, 0.10151600882227652, 0.13754505631846226, 0.10412489257175206, 0.11631056123118, 0.11662326834720638, 0.12185118381493631, 0.11337811115185725, 0.13630383346533814, 0.15330731278269705, 0.9340954164262834, 0.9668149885444172, 0.9234927303190134, 0.9189135609700603, 0.9427289096522887, 0.9371810909410484, 0.9543801441555577, 0.9456782136412611, 0.9623521741273691, 0.4048953895367279, 0.46644322949008277, 0.5035750251957775, 0.5077565502306449, 0.39597800084933266, 0.4912023137965551, 0.5230026030777102, 0.427558997013316, 0.5193752562535516, 0.8611844501167254, 0.7877010256070212, 0.606253273268633, 0.8382994870554585, 0.24848972940025182, 0.23927968807467048, 0.22799994433977644, 0.6462552487288249, 0.8029572550935198, 0.12806969350374997, 0.14215438268700886, 0.22042177856704392, 0.12824151078942525, 0.20649585826432104, 0.09964454501438735, 0.1751568511073761, 0.18359990392483783, 0.141663541183507, 0.19797935963505786, 0.23450633147601763, 0.17807091587436386, 0.23166478278528868, 0.12923274264915052, 0.2697211312540789, 0.1919870567187716, 0.18417818106794281, 0.1560505896743445, 0.15928322640067472, 9.999999999998899e-05, 0.14917818853815956, 0.002298929650007442, 0.061653322321690074, 0.06431409913212227, 9.999999999998899e-05, 0.056709271635633884, 0.08650734825400463, 0.2875047292631454, 0.18493186881356638, 0.1524881730414932, 0.2048145492741441, 0.09658569159437336, 0.09601850210926854, 0.20884515662572956, 0.139645182835882, 0.22826954772898944, 0.057307907801473434, 0.05471484304608698, 0.11266937256272302, 0.09780555214474207, 0.22802205417073018, 0.20616554087945949, 0.27734042819156557, 0.07436834804065218, 0.1657654280713674, 0.26690335645714824, 0.29338419902893476, 0.23456815082338955, 0.2655914842468797, 0.19099182059375475, 0.2632024823489726, 0.26205204773723567, 0.22819596091327166, 0.2976662207541906, 0.5699191545451019, 0.6234380417876624, 0.5605708502463915, 0.6006945628715312, 0.5282902183634378, 0.5488302547847467, 0.5803012791172255, 0.5464836268295199, 0.5726636781451535, 0.09602521473811043, 0.10673100857217288, 0.09057517150619165, 0.10972509743432934, 0.07848832247534543, 0.08912286662111579, 0.10391057504155743, 0.09178563732782163, 0.14441866665344116, 0.1917247447533882, 0.13438121944636072, 0.14598982391183968, 0.13136588407591987, 0.23632225717387978, 0.18008802090944787, 0.23647102830687794, 0.3148807474807519, 0.20745072098383444, 0.42922858344171966, 0.3904751976717723, 0.39005361326848187, 0.2605449702107244, 0.4447419935362147, 0.4288614267695673, 0.5088985745411089, 0.4542806579998925, 0.425272427537957, 0.24319918546773878, 0.32435519372960986, 0.180774341099314, 0.3310594752188395, 0.2830358390624358, 0.3279238282121836, 0.2873635340559285, 0.4113918730678955, 0.39871493769366695, 0.19126738755972228, 0.23101262509182563, 0.19425717320841807, 0.17727098406259278, 0.22191983431336804, 0.19256941640634562, 0.18081053638828448, 0.17264565931783837, 0.22426107963359232, 0.2366060003224839, 0.5029793808171947, 0.3166725545755458, 0.23329582634941848, 0.2253738163625073, 0.20233009573539418, 0.5744866381739401, 0.524127137712303, 0.2015854828379785, 0.18330945525273323, 0.16499208960549805, 0.822237730313365, 0.7932875908313913, 0.19276586720042455, 0.13049366951760444, 0.14521560117529375, 0.17274042948857604, 0.16511386805435646, 0.6742416601609789, 0.20657342221906283, 0.12617403368526614, 0.4786435094176158, 0.1256470317066789, 0.20688434188300198, 0.11205561544583831, 0.15290845766271066, 0.3812548296651216, 0.18901263372658572, 0.1714561172666318, 0.1855114982096645, 0.18035477746468842, 0.17667767628682107, 0.17162118145235383, 0.191873009247031, 0.19502432430128425, 0.16811651616592682, 0.07136551343867614, 0.07332563408132842, 0.07069503402834565, 0.08327692111691465, 0.0794772696296232, 0.06790442172235112, 0.07188959332054545, 0.08235703147481233, 0.0827799953968612]}, "mutation_prompt": null}
{"id": "2cc81fef-81ae-4772-9503-de25bdb0e47a", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1781f53c-d427-415b-b341-51b757b0883a", "metadata": {"aucs": [0.8155080130564687, 0.7559033804976276, 0.7905083647019924, 0.7706365799583045, 0.7720004892919544, 0.7593470219345677, 0.7537370188105208, 0.760038582709117, 0.7688127909607124, 0.5655881478001787, 0.5774910683303923, 0.5640605575423558, 0.5925450739444624, 0.572418207547452, 0.6097388193042579, 0.5556425429128315, 0.5794651159433983, 0.4865324343657187, 0.10943136396215947, 0.09551252924468845, 0.19098254722941055, 0.1241651193987725, 0.11679336299777643, 0.11247960589287809, 0.16658243415655982, 0.1632262133238752, 0.11016878883262637, 0.10253476795804106, 0.10701880832640687, 0.11420581915681427, 0.0991033430946705, 0.09434269006753326, 0.09919209965355336, 0.0899865563697555, 0.0976362981869745, 0.10370745962354033, 0.923371693436908, 0.9363393286271675, 0.9608986395726264, 0.9463349414245236, 0.9247224580034754, 0.9279701146332561, 0.9364984422653984, 0.892427483563698, 0.9327239774445928, 0.38961470800148157, 0.3963780867715607, 0.3686744308588069, 0.3515614301952177, 0.38238093954163144, 0.43305139347151844, 0.41129460015236496, 0.3709672897802697, 0.41145014541706304, 0.6318642824223506, 0.6570223002505244, 0.6689572208121993, 0.7081456948982934, 0.7229000682226474, 0.6888472264719517, 0.7369845083567743, 0.687656214634984, 0.6319416473784123, 0.20893564626953753, 0.16228156593626775, 0.17338691928834882, 0.17647999228280753, 0.24285597991865826, 0.16118881822081088, 0.24473973831693185, 0.16551774375254769, 0.23476747011081156, 0.14383782780042698, 0.20626465327264576, 0.15773475133562065, 0.170206041048668, 0.21390758419115674, 0.21210583976041686, 0.20367153521640124, 0.24212705844334348, 0.2874615594205191, 0.24943938636657104, 0.1516988015971077, 0.14246514859489356, 0.16179380538329502, 0.05283406603146834, 0.16399208308360724, 0.08230390917160779, 0.23903450289247374, 0.19828219686521076, 0.38785787456595877, 0.1944053508152328, 0.20255903876423798, 0.30903918241211026, 0.08832873300199118, 0.2857456767736388, 0.2542965026183789, 0.3312113038170096, 0.26096961762957693, 0.1340230634623918, 0.06850336774886201, 0.0776777271545539, 0.13454392931627845, 0.16769666118628357, 0.13932391155391777, 0.19572413483334838, 0.10905776980095017, 0.07939909619366403, 0.21869671965659854, 0.24069183744191902, 0.2449777441711366, 0.24249713021935504, 0.22925334786160378, 0.21948998938137942, 0.22631154759998884, 0.13903149065133602, 0.2123170410292312, 0.592410353772121, 0.5684522966706104, 0.620032363275939, 0.5112054176539589, 0.5671683914164736, 0.5588984269431831, 0.5721274467175509, 0.6286008067195519, 0.4918649782488407, 0.1012396790249328, 0.0902208929203181, 0.09910907027098126, 0.08495686269696978, 0.08939890254541771, 0.10663674442861903, 0.11445232136113026, 0.09868097204222592, 0.09350706528911856, 0.15083767353253552, 0.12925164396279065, 0.12927750175204256, 0.14393042481362028, 0.13517460891076039, 0.16922078480273417, 0.17726654486825955, 0.17899464471903337, 0.14806208923146802, 0.3385064755394417, 0.3420195134293488, 0.37353325323882947, 0.38367508340147016, 0.36743206885613455, 0.3558564247864303, 0.3846914821853128, 0.44415119438478146, 0.30676904999245347, 0.25601381386222477, 0.2826239374327034, 0.2430533894011503, 0.2700414170094949, 0.20531713781403182, 0.25824891401701033, 0.25161223547838085, 0.27354689584154246, 0.2489349943783482, 0.211943166537908, 0.1711755788774303, 0.1829352222178865, 0.18306520226945278, 0.19257543927701726, 0.1886523531768498, 0.1983072573583481, 0.1817123683265266, 0.20729085075393172, 0.1938562863628135, 0.18021484475111627, 0.17425845280891605, 0.21246585147881236, 0.2063308769307325, 0.18989750267968653, 0.2049176702240061, 0.20565710230219647, 0.1965406425342291, 0.7705403016370592, 0.731721010009793, 0.6774948716833766, 0.16940668299918094, 0.18148865100910339, 0.6363469912578363, 0.6058619081548582, 0.6134353036444747, 0.6609550140440952, 0.5626305444830952, 0.20245676549081038, 0.2028523864752264, 0.1997670225341035, 0.16160522813605516, 0.3898407233241753, 0.2085555458785595, 0.2017501609276201, 0.2172740397968571, 0.20267674272573766, 0.19313308227723391, 0.1838331864222783, 0.17655238715641697, 0.17402241032542243, 0.1844822118261935, 0.19108853101452516, 0.1985809825634044, 0.19006367058715223, 0.06864813008708859, 0.0721558288638886, 0.07205634995464061, 0.09150845335842928, 0.08067770296549259, 0.06946006424978224, 0.07282317686083117, 0.08409236261461006, 0.07105247295702777]}, "mutation_prompt": null}
{"id": "0419aae2-6b82-4714-85ce-31d345ae5765", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def hybrid_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c, d = population[np.random.choice(idxs, 4, replace=False)]\n        F1 = np.random.uniform(0.4, 0.8)\n        F2 = np.random.uniform(0.1, 0.4)\n        mutant_vector = np.clip(a + F1 * (b - c) + F2 * (d - b), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        initial_pop_size = 15\n        population = self.initialize_population(initial_pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.hybrid_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n            if self.num_evaluations < self.budget * 0.5:\n                new_pop_size = len(population) + int(5 * (self.num_evaluations / self.budget))\n                population = np.vstack((population, self.initialize_population(new_pop_size - len(population))))\n                fitness = np.hstack((fitness, self.evaluate_population(population[len(fitness):], func)))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Enhanced Adaptive Scatter Search with Hybrid Mutation and Dynamic Population Adjustment for Improved Convergence.", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Cannot apply_along_axis when any iteration dimensions are 0').", "error": "ValueError('Cannot apply_along_axis when any iteration dimensions are 0')", "parent_id": "1781f53c-d427-415b-b341-51b757b0883a", "metadata": {}, "mutation_prompt": null}
{"id": "0e67b810-5bbe-4e70-939c-7b711d140826", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.archive_size = 5  # Dynamic archive for diversity\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def update_archive(self, population, fitness):\n        top_indices = np.argsort(fitness)[:self.archive_size]\n        return population[top_indices]\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n        archive = self.update_archive(population, fitness)  # Maintain a diverse archive\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, archive, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n            archive = self.update_archive(population, fitness)  # Update archive dynamically\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Enhanced Adaptive Scatter Search with Dynamic Archive for Diversity and Enhanced Exploitation.", "configspace": "", "generation": 51, "fitness": 0.23167750021672268, "feedback": "The algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "1781f53c-d427-415b-b341-51b757b0883a", "metadata": {"aucs": [0.49219659234979607, 0.48361851539030787, 0.6481329954329675, 0.504213477815451, 0.513151287041358, 0.5071263880039966, 0.4538257135360725, 0.48149231357002786, 0.508381577731216, 0.008164776751062197, 0.013734283551945059, 9.999999999998899e-05, 0.011428029810986451, 0.03020346090026682, 0.022549981237715455, 0.015810979803359215, 0.028716032227282806, 9.999999999998899e-05, 0.14160391022706675, 0.11757188524032369, 0.13902028452694026, 0.15045621063861525, 0.13684071087845495, 0.14397413809705595, 0.11111183063573948, 0.11097624693870745, 0.17165338474519853, 0.11731638051289683, 0.10576346607338727, 0.12135851558261024, 0.0995695231838718, 0.13810486650205567, 0.11462679244670382, 0.10407240587308275, 0.0838041532785132, 0.10635252206125878, 0.9188091650904274, 0.9368031903714613, 0.9326368718021814, 0.9510566883240323, 0.9378697491255257, 0.9364236346475876, 0.9343556738967457, 0.924887796351895, 0.9449240281986971, 0.2883123765893868, 0.2657159544198474, 0.25031501278696555, 0.27487215391192954, 0.28291016738653274, 0.30805772449032887, 0.24878538421246266, 0.2390570807385215, 0.29044692152298357, 0.29002981887115753, 0.3041944626487785, 0.21950226456798383, 0.2725673045431376, 0.32935392207916137, 0.3203637549093997, 0.2232098969098847, 0.2960866006061833, 0.38517761808315976, 0.23493565920269022, 0.15892999196926172, 0.14134558497974792, 0.154090000995447, 0.19489141170802282, 0.18373951925784415, 0.16108721844560692, 0.2540671316468077, 0.17098496881178982, 0.16804070898761325, 0.205506396395997, 0.12161185981541545, 0.1786747715416872, 0.1984166527236162, 0.1525018548072472, 0.1629940137512954, 0.1369395175380792, 0.130250703372626, 0.0520675739526012, 9.999999999998899e-05, 0.0763062140582611, 9.999999999998899e-05, 0.010120794087658203, 9.999999999998899e-05, 9.999999999998899e-05, 0.09528224488180437, 0.07242561790267121, 0.10674032808970246, 0.06367903003412978, 0.15103550419627187, 0.11156825543321935, 0.01446240856402159, 0.019866418105172867, 0.10599665016409732, 0.16798780590100382, 0.11779463237275345, 0.06544975538820386, 0.16012363271866747, 0.10511568977280172, 0.14063340375644862, 9.999999999998899e-05, 0.09441852514521998, 9.999999999998899e-05, 0.0014273507537287955, 0.1765795577276078, 0.17315465230438554, 0.1356119367538975, 0.045616156319444934, 0.06588644045602432, 0.09442906509221316, 0.13529459789116083, 0.055132046690926084, 0.061442772902421505, 0.1353303668009267, 0.3983117270692098, 0.42793452541590826, 0.40424854695368495, 0.4075493390295364, 0.4462066199218383, 0.46525432259887356, 0.42450985869579827, 0.4724718080989394, 0.5531290695085278, 0.09223380946984383, 0.09591563943653802, 0.1107710633413006, 0.10716539427299498, 0.1165794765821816, 0.09058041038926601, 0.11013948654696037, 0.10873273483975987, 0.11391342531630833, 0.2467000013809849, 0.18882386142351804, 0.15159493174385696, 0.31606241832181337, 0.24806532810269544, 0.2207946836601684, 0.17651592276421546, 0.2540757269020949, 0.17543135662372566, 0.2636743782198657, 0.28136336027301645, 0.3197319441404072, 0.3453961356641334, 0.3363916925490652, 0.22908026697511563, 0.37840987402985127, 0.30991118398178297, 0.2821315332798672, 0.2503584271431668, 0.21300649761247137, 0.16803830384750817, 0.16984382092006267, 0.21111285945057567, 0.2814817159976013, 0.2818732291197147, 0.4127153633034806, 0.27103741215028, 0.17412154418002412, 0.20481740146095972, 0.2310252470925549, 0.18689305949200474, 0.22595668869662566, 0.19556868245280412, 0.2147752287181891, 0.1935205099323991, 0.21928884482400768, 0.2182099477911975, 0.18217986641395278, 0.17814210984359702, 0.2047737805105906, 0.1810884996665122, 0.21228237037198783, 0.20215107672931842, 0.1992027324324871, 0.2008392970849976, 0.5845313711884556, 0.18301644913521964, 0.152348179426955, 0.5663826987692501, 0.19973471400270992, 0.6060044309278045, 0.21125981425768392, 0.16810232888942078, 0.17239960516350294, 0.47077307677891767, 0.20975679109104217, 0.5665655370713283, 0.20528579350143072, 0.31889787564497274, 0.3712843714565053, 0.20971810983930605, 0.1679813752729804, 0.30713641075973575, 0.19958743189404216, 0.18214351266239748, 0.24951341222080203, 0.18193160234621197, 0.17691433298027082, 0.1904427031028515, 0.17262608117249056, 0.1838827850739534, 0.18496082919751977, 0.07388850918291101, 0.08405078489814855, 0.0891708330123967, 0.09480133518831046, 0.07703710078642256, 0.0758876817661891, 0.0825052243671538, 0.07267219425784222, 0.0806021409113522]}, "mutation_prompt": null}
{"id": "ab0b7cda-ed4c-4062-9b8e-311d5e880f55", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1781f53c-d427-415b-b341-51b757b0883a", "metadata": {"aucs": [0.8155080130564687, 0.7559033804976276, 0.7905083647019924, 0.7706365799583045, 0.7720004892919544, 0.7593470219345677, 0.7537370188105208, 0.760038582709117, 0.7688127909607124, 0.5655881478001787, 0.5774910683303923, 0.5640605575423558, 0.5925450739444624, 0.572418207547452, 0.6097388193042579, 0.5556425429128315, 0.5794651159433983, 0.4865324343657187, 0.10943136396215947, 0.09551252924468845, 0.19098254722941055, 0.1241651193987725, 0.11679336299777643, 0.11247960589287809, 0.16658243415655982, 0.1632262133238752, 0.11016878883262637, 0.10253476795804106, 0.10701880832640687, 0.11420581915681427, 0.0991033430946705, 0.09434269006753326, 0.09919209965355336, 0.0899865563697555, 0.0976362981869745, 0.10370745962354033, 0.923371693436908, 0.9363393286271675, 0.9608986395726264, 0.9463349414245236, 0.9247224580034754, 0.9279701146332561, 0.9364984422653984, 0.892427483563698, 0.9327239774445928, 0.38961470800148157, 0.3963780867715607, 0.3686744308588069, 0.3515614301952177, 0.38238093954163144, 0.43305139347151844, 0.41129460015236496, 0.3709672897802697, 0.41145014541706304, 0.6318642824223506, 0.6570223002505244, 0.6689572208121993, 0.7081456948982934, 0.7229000682226474, 0.6888472264719517, 0.7369845083567743, 0.687656214634984, 0.6319416473784123, 0.20893564626953753, 0.16228156593626775, 0.17338691928834882, 0.17647999228280753, 0.24285597991865826, 0.16118881822081088, 0.24473973831693185, 0.16551774375254769, 0.23476747011081156, 0.14383782780042698, 0.20626465327264576, 0.15773475133562065, 0.170206041048668, 0.21390758419115674, 0.21210583976041686, 0.20367153521640124, 0.24212705844334348, 0.2874615594205191, 0.24943938636657104, 0.1516988015971077, 0.14246514859489356, 0.16179380538329502, 0.05283406603146834, 0.16399208308360724, 0.08230390917160779, 0.23903450289247374, 0.19828219686521076, 0.38785787456595877, 0.1944053508152328, 0.20255903876423798, 0.30903918241211026, 0.08832873300199118, 0.2857456767736388, 0.2542965026183789, 0.3312113038170096, 0.26096961762957693, 0.1340230634623918, 0.06850336774886201, 0.0776777271545539, 0.13454392931627845, 0.16769666118628357, 0.13932391155391777, 0.19572413483334838, 0.10905776980095017, 0.07939909619366403, 0.21869671965659854, 0.24069183744191902, 0.2449777441711366, 0.24249713021935504, 0.22925334786160378, 0.21948998938137942, 0.22631154759998884, 0.13903149065133602, 0.2123170410292312, 0.592410353772121, 0.5684522966706104, 0.620032363275939, 0.5112054176539589, 0.5671683914164736, 0.5588984269431831, 0.5721274467175509, 0.6286008067195519, 0.4918649782488407, 0.1012396790249328, 0.0902208929203181, 0.09910907027098126, 0.08495686269696978, 0.08939890254541771, 0.10663674442861903, 0.11445232136113026, 0.09868097204222592, 0.09350706528911856, 0.15083767353253552, 0.12925164396279065, 0.12927750175204256, 0.14393042481362028, 0.13517460891076039, 0.16922078480273417, 0.17726654486825955, 0.17899464471903337, 0.14806208923146802, 0.3385064755394417, 0.3420195134293488, 0.37353325323882947, 0.38367508340147016, 0.36743206885613455, 0.3558564247864303, 0.3846914821853128, 0.44415119438478146, 0.30676904999245347, 0.25601381386222477, 0.2826239374327034, 0.2430533894011503, 0.2700414170094949, 0.20531713781403182, 0.25824891401701033, 0.25161223547838085, 0.27354689584154246, 0.2489349943783482, 0.211943166537908, 0.1711755788774303, 0.1829352222178865, 0.18306520226945278, 0.19257543927701726, 0.1886523531768498, 0.1983072573583481, 0.1817123683265266, 0.20729085075393172, 0.1938562863628135, 0.18021484475111627, 0.17425845280891605, 0.21246585147881236, 0.2063308769307325, 0.18989750267968653, 0.2049176702240061, 0.20565710230219647, 0.1965406425342291, 0.7705403016370592, 0.731721010009793, 0.6774948716833766, 0.16940668299918094, 0.18148865100910339, 0.6363469912578363, 0.6058619081548582, 0.6134353036444747, 0.6609550140440952, 0.5626305444830952, 0.20245676549081038, 0.2028523864752264, 0.1997670225341035, 0.16160522813605516, 0.3898407233241753, 0.2085555458785595, 0.2017501609276201, 0.2172740397968571, 0.20267674272573766, 0.19313308227723391, 0.1838331864222783, 0.17655238715641697, 0.17402241032542243, 0.1844822118261935, 0.19108853101452516, 0.1985809825634044, 0.19006367058715223, 0.06864813008708859, 0.0721558288638886, 0.07205634995464061, 0.09150845335842928, 0.08067770296549259, 0.06946006424978224, 0.07282317686083117, 0.08409236261461006, 0.07105247295702777]}, "mutation_prompt": null}
{"id": "4598c547-396b-443d-90f9-33effc94896e", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        temperature = 1 - (self.num_evaluations / self.budget)  # New temperature-based crossover\n        cross_prob = 0.9 - 0.3 * temperature\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Enhanced Adaptive Scatter Search with Simulated Annealing-inspired Temperature Decay for Improved Exploration-Exploitation Balance.", "configspace": "", "generation": 53, "fitness": 0.2566183502183515, "feedback": "The algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "1781f53c-d427-415b-b341-51b757b0883a", "metadata": {"aucs": [0.7571486504203542, 0.7633793166014738, 0.7145907081584093, 0.7623402112590962, 0.7519791354047616, 0.7681762425038363, 0.725940842169496, 0.73435438548515, 0.7209560348229134, 0.5449204660191376, 0.5268407021967774, 0.4644671642105406, 0.5747781875229392, 0.5459001564372297, 0.4969238878037594, 0.52184958179656, 0.5097891915928505, 0.5075576833085467, 0.17851672347838243, 0.11686863386421864, 0.11245209363018238, 0.12486243157241028, 0.11681521488517388, 0.19676614897296707, 0.12601866289924224, 0.11312648490656352, 0.1293229729447234, 0.09948411432725568, 0.11620836751954744, 0.10897657811379446, 0.11709367113891456, 0.12453717027349809, 0.13859511291481308, 0.09895749111361551, 0.12707728992015543, 0.12433278974857198, 0.9177382808250211, 0.9317880098205733, 0.9394247333079724, 0.9218910315605895, 0.9478645510880541, 0.9345836361344706, 0.9060378415116461, 0.9190934510330326, 0.9103802553216273, 0.3042239460974965, 0.2806339996809546, 0.27028071015635924, 0.2894223857238418, 0.30162965819893306, 0.27686344808392227, 0.36807724089613836, 0.2611941222965394, 0.31396999415107785, 0.3832230457227608, 0.35089823297916933, 0.3913174180840153, 0.422329338117848, 0.5356838644894933, 0.4439367262380213, 0.47379299447124434, 0.41546575494254345, 0.4332827014282902, 0.14976403469636557, 0.18044544916096894, 0.13487816817995868, 0.1312982984782639, 0.15496154869046108, 0.1411109008023761, 0.16056437431754678, 0.15133112645057767, 0.17519130023839513, 0.16069744415299736, 0.1580379448096897, 0.16285031837452302, 0.1525954933705057, 0.1698873410562226, 0.14841514224180208, 0.1499896103341949, 0.14358100233154747, 0.12795189162598597, 0.0072758219297953675, 0.007154482633052739, 0.03668538204493432, 0.009723820358029434, 0.007970298046177993, 0.0047465899392358235, 0.018599783260674463, 0.018710882876101675, 0.033330187492806695, 0.093319601006295, 0.10706998094756326, 0.10073914907794901, 0.11756676348072037, 0.03933613128044966, 0.08126208586950301, 0.10097170899369357, 0.13663780683314475, 0.12287503725387416, 0.001635193785200717, 0.0033508967987277982, 9.999999999998899e-05, 0.029710237650429905, 0.013203662741558375, 0.0014056858307253117, 0.0009934282419570284, 0.04238145756632006, 0.0042444103681748, 0.12306438806150999, 0.11075650033717088, 0.11383960857152431, 0.12799929457364811, 0.11422813323853043, 0.10153194263248111, 0.10092925766310146, 0.12912675444287558, 0.120389557551569, 0.47925916692142534, 0.4694079671682323, 0.4947052080179223, 0.4750845688009997, 0.4870872942079161, 0.49305496209610733, 0.46328755579129044, 0.46222435641348236, 0.5200040378545974, 0.08578140952907198, 0.09427359770096677, 0.09085301222071773, 0.09120258359961464, 0.09801053516406355, 0.0949193703967669, 0.08508349424064177, 0.11067446381774493, 0.08447065331349335, 0.13416859784877921, 0.13464081848075093, 0.12425019034890683, 0.13523701762504392, 0.14247336918948872, 0.13065791279201, 0.1564385407583515, 0.14079375677716577, 0.14492962102205587, 0.30792666766171317, 0.30183450618394536, 0.27491427865905604, 0.2679904540212179, 0.2628570446048868, 0.2933231774471937, 0.30319574093652857, 0.33280767884219165, 0.29752376151749826, 0.18878130715248964, 0.1904405793338374, 0.21456110387062588, 0.21627517511730676, 0.23024614848289204, 0.15985507912479957, 0.24295027576403105, 0.22885457420969013, 0.1917066627079509, 0.18524742069532252, 0.19880814303631733, 0.18106127281345363, 0.20215920101682194, 0.17187044175763644, 0.21174483144497136, 0.2319058771827367, 0.1738468050871177, 0.17850021650669967, 0.1895636842873143, 0.18973865329778705, 0.20253627378827954, 0.17824205220769596, 0.18406616838569767, 0.18111133596452045, 0.2049105470303183, 0.1893665990234613, 0.19789655810186257, 0.5691329571647537, 0.1681171715975397, 0.4257795763818175, 0.583510934181932, 0.16627517362852084, 0.5822605732191349, 0.21147788784854205, 0.1401449782903884, 0.17657831382434996, 0.2918829498430622, 0.18615123846074355, 0.2647522122312431, 0.23293746069047472, 0.2384648522641437, 0.19784750764897485, 0.20456364123111426, 0.41025507466578914, 0.1958436975672605, 0.18125530627253428, 0.19234511553090283, 0.17894527856435694, 0.18570860328342287, 0.1885634907612347, 0.2103908511830639, 0.18540964089432366, 0.1818402780737174, 0.1895213583064984, 0.08566228762322758, 0.0648315035591368, 0.06672176225107596, 0.0650202468389236, 0.07595491646964547, 0.07487456015144522, 0.07991062547478855, 0.07671019766145859, 0.0749778791695227]}, "mutation_prompt": null}
{"id": "4fb7aa55-ea98-4cc5-9c38-ade5ae9cfa37", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.9)  # Adjusted mutation factor range\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.4 * (self.num_evaluations / self.budget)  # Adjusted dynamic cross probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.25 / (1 + np.exp(-0.05 * self.num_evaluations))  # Adjusted step size\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 15 + int(10 * (1 - (self.num_evaluations / self.budget)))  # Adjusted population size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(fitness)\n            for i in range(len(population)):\n                if i == best_idx:  # Elite preservation\n                    continue\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]", "name": "AdaptiveScatterSearch", "description": "Enhanced Scatter Search integrating Dynamic Population Size and Elite Preservation for Robust Optimization.", "configspace": "", "generation": 54, "fitness": 0.271082371353769, "feedback": "The algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.22.", "error": "", "parent_id": "1781f53c-d427-415b-b341-51b757b0883a", "metadata": {"aucs": [0.6709053219274046, 0.6536675258493134, 0.6899040033165333, 0.6912105664615866, 0.691231476037215, 0.6760794735923645, 0.650739300328985, 0.6695871139181838, 0.6079281263435883, 0.4415682526613155, 0.38518522357309315, 0.3822804236340136, 0.44274443196107516, 0.43202857491791213, 0.36341195467683995, 0.36521804814808945, 0.38868835232735177, 0.45348608464613693, 0.09859352164859048, 0.10684580091381524, 0.10001348908780561, 0.11186214015988227, 0.09688531284123869, 0.11694055261255021, 0.08724666582227947, 0.0924575687310687, 0.10300374350952901, 0.08785813475129434, 0.12297289784179466, 0.09953629133286324, 0.08847228619544423, 0.0894207161436128, 0.09835398980065402, 0.09375331729253344, 0.08858173679871184, 0.09003513505428962, 0.9721666426318907, 0.8979566759462497, 0.9164421152951658, 0.8842647276914894, 0.9213142335093306, 0.9003967624265966, 0.9254558967452281, 0.9390722351622985, 0.9207891812972673, 0.31438211730398213, 0.3536215934660297, 0.32366970331521483, 0.32294260168462063, 0.31455296440757063, 0.30129383044651437, 0.2761572293338934, 0.31861750568426805, 0.3201913303603666, 0.676586985285519, 0.5273468038712471, 0.4580731873871331, 0.5466399096194727, 0.6735551124980976, 0.5797685705691065, 0.336670703720099, 0.5313562102586064, 0.6429948565307407, 0.1674706651665816, 0.19430076188107437, 0.16688556851672598, 0.15970460385186835, 0.14172228951801813, 0.14956410599463488, 0.1572341829491325, 0.15314511466697844, 0.1456333961152284, 0.27846849814864405, 0.1392585053985287, 0.19513344523599607, 0.17496619968527793, 0.16180095491148494, 0.15065706238345355, 0.16676020926871282, 0.18027430799313604, 0.158921621563336, 0.11785754334515164, 0.07585004637232429, 0.06962341828924512, 0.10489661079546608, 0.13219593589280776, 0.15485989798636768, 0.14678986089493262, 0.12666278432839995, 0.08824381398629844, 0.34609955449634955, 0.27895301491850344, 0.20685972836570565, 0.25172906415522733, 0.20832628793741337, 0.23359632136061625, 0.23611894053544247, 0.2709825788888771, 0.28114891123183583, 0.05669283815440862, 0.025854250960072545, 0.016120257031370988, 0.03597914852994455, 0.02849413240557408, 0.019859902814302277, 0.06440771752358976, 0.06999444714172698, 0.04232934006277267, 0.142724688857794, 0.15572912335218703, 0.14298034261445558, 0.16471589859808222, 0.1765850944044849, 0.16415021170129018, 0.16307897701824547, 0.13876523305122046, 0.14886373150386512, 0.47867263211493805, 0.4877796442269001, 0.48352149081909745, 0.46828356021185413, 0.4828904566872493, 0.4805216122435587, 0.4976660448541079, 0.508801291924716, 0.48726783224425163, 0.08946083974775354, 0.09030201079162348, 0.10053997947600202, 0.10270390154754949, 0.08506473388406377, 0.08599781971633313, 0.08858747460549965, 0.09327124112356544, 0.09050849566133834, 0.13944262556284426, 0.14014410923257692, 0.15050554308772213, 0.12425335385554737, 0.14846235883236136, 0.14559940016447637, 0.15592086653191362, 0.16273350715529233, 0.12353995311933974, 0.27834395198659145, 0.3222516299000635, 0.2908300323894889, 0.2939116877776865, 0.3014910824212125, 0.27354814336334565, 0.2963090035458371, 0.3059057166191951, 0.3084046656445891, 0.23370461625740313, 0.2667901736488697, 0.21059467315777813, 0.22272742185293315, 0.20810061192115548, 0.19852780388534763, 0.21657890601892515, 0.24710879458031254, 0.22476475603153312, 0.19422610422911835, 0.1758372200028936, 0.17921399026022788, 0.18427171711888646, 0.17652658629623696, 0.19704433046716885, 0.19292737894510936, 0.19129911424597612, 0.19198753622333276, 0.18697611761327726, 0.16972406825401032, 0.18867410990684852, 0.19051805244633413, 0.17104908123796525, 0.1823254470291089, 0.18886614930118162, 0.1746579749685001, 0.18105999368229708, 0.17629168584959354, 0.1661229979575184, 0.18637627349685737, 0.17780595962887202, 0.7219983862022179, 0.6526537169721804, 0.1813972339597144, 0.5809921606754653, 0.1657193436546024, 0.3503086364910635, 0.35655725807679706, 0.18998114139186162, 0.5446512080677861, 0.18871991256328402, 0.15907406272340063, 0.48909332564875474, 0.20455884028811022, 0.5774707527156471, 0.1785413306834165, 0.17487188640867646, 0.18545385588094299, 0.18369870149977474, 0.1796637446036291, 0.20532918482252482, 0.17965156339961064, 0.19435699124876582, 0.18571624690841837, 0.07969849615777347, 0.07205353047008534, 0.06701070519351293, 0.06864610323350717, 0.06861169084578456, 0.07232621483010282, 0.07277626903117818, 0.07317262403926761, 0.07792037007807007]}, "mutation_prompt": null}
{"id": "c73f75cb-d5b9-4cd4-931f-4093cd4b5578", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1781f53c-d427-415b-b341-51b757b0883a", "metadata": {"aucs": [0.8155080130564687, 0.7559033804976276, 0.7905083647019924, 0.7706365799583045, 0.7720004892919544, 0.7593470219345677, 0.7537370188105208, 0.760038582709117, 0.7688127909607124, 0.5655881478001787, 0.5774910683303923, 0.5640605575423558, 0.5925450739444624, 0.572418207547452, 0.6097388193042579, 0.5556425429128315, 0.5794651159433983, 0.4865324343657187, 0.10943136396215947, 0.09551252924468845, 0.19098254722941055, 0.1241651193987725, 0.11679336299777643, 0.11247960589287809, 0.16658243415655982, 0.1632262133238752, 0.11016878883262637, 0.10253476795804106, 0.10701880832640687, 0.11420581915681427, 0.0991033430946705, 0.09434269006753326, 0.09919209965355336, 0.0899865563697555, 0.0976362981869745, 0.10370745962354033, 0.923371693436908, 0.9363393286271675, 0.9608986395726264, 0.9463349414245236, 0.9247224580034754, 0.9279701146332561, 0.9364984422653984, 0.892427483563698, 0.9327239774445928, 0.38961470800148157, 0.3963780867715607, 0.3686744308588069, 0.3515614301952177, 0.38238093954163144, 0.43305139347151844, 0.41129460015236496, 0.3709672897802697, 0.41145014541706304, 0.6318642824223506, 0.6570223002505244, 0.6689572208121993, 0.7081456948982934, 0.7229000682226474, 0.6888472264719517, 0.7369845083567743, 0.687656214634984, 0.6319416473784123, 0.20893564626953753, 0.16228156593626775, 0.17338691928834882, 0.17647999228280753, 0.24285597991865826, 0.16118881822081088, 0.24473973831693185, 0.16551774375254769, 0.23476747011081156, 0.14383782780042698, 0.20626465327264576, 0.15773475133562065, 0.170206041048668, 0.21390758419115674, 0.21210583976041686, 0.20367153521640124, 0.24212705844334348, 0.2874615594205191, 0.24943938636657104, 0.1516988015971077, 0.14246514859489356, 0.16179380538329502, 0.05283406603146834, 0.16399208308360724, 0.08230390917160779, 0.23903450289247374, 0.19828219686521076, 0.38785787456595877, 0.1944053508152328, 0.20255903876423798, 0.30903918241211026, 0.08832873300199118, 0.2857456767736388, 0.2542965026183789, 0.3312113038170096, 0.26096961762957693, 0.1340230634623918, 0.06850336774886201, 0.0776777271545539, 0.13454392931627845, 0.16769666118628357, 0.13932391155391777, 0.19572413483334838, 0.10905776980095017, 0.07939909619366403, 0.21869671965659854, 0.24069183744191902, 0.2449777441711366, 0.24249713021935504, 0.22925334786160378, 0.21948998938137942, 0.22631154759998884, 0.13903149065133602, 0.2123170410292312, 0.592410353772121, 0.5684522966706104, 0.620032363275939, 0.5112054176539589, 0.5671683914164736, 0.5588984269431831, 0.5721274467175509, 0.6286008067195519, 0.4918649782488407, 0.1012396790249328, 0.0902208929203181, 0.09910907027098126, 0.08495686269696978, 0.08939890254541771, 0.10663674442861903, 0.11445232136113026, 0.09868097204222592, 0.09350706528911856, 0.15083767353253552, 0.12925164396279065, 0.12927750175204256, 0.14393042481362028, 0.13517460891076039, 0.16922078480273417, 0.17726654486825955, 0.17899464471903337, 0.14806208923146802, 0.3385064755394417, 0.3420195134293488, 0.37353325323882947, 0.38367508340147016, 0.36743206885613455, 0.3558564247864303, 0.3846914821853128, 0.44415119438478146, 0.30676904999245347, 0.25601381386222477, 0.2826239374327034, 0.2430533894011503, 0.2700414170094949, 0.20531713781403182, 0.25824891401701033, 0.25161223547838085, 0.27354689584154246, 0.2489349943783482, 0.211943166537908, 0.1711755788774303, 0.1829352222178865, 0.18306520226945278, 0.19257543927701726, 0.1886523531768498, 0.1983072573583481, 0.1817123683265266, 0.20729085075393172, 0.1938562863628135, 0.18021484475111627, 0.17425845280891605, 0.21246585147881236, 0.2063308769307325, 0.18989750267968653, 0.2049176702240061, 0.20565710230219647, 0.1965406425342291, 0.7705403016370592, 0.731721010009793, 0.6774948716833766, 0.16940668299918094, 0.18148865100910339, 0.6363469912578363, 0.6058619081548582, 0.6134353036444747, 0.6609550140440952, 0.5626305444830952, 0.20245676549081038, 0.2028523864752264, 0.1997670225341035, 0.16160522813605516, 0.3898407233241753, 0.2085555458785595, 0.2017501609276201, 0.2172740397968571, 0.20267674272573766, 0.19313308227723391, 0.1838331864222783, 0.17655238715641697, 0.17402241032542243, 0.1844822118261935, 0.19108853101452516, 0.1985809825634044, 0.19006367058715223, 0.06864813008708859, 0.0721558288638886, 0.07205634995464061, 0.09150845335842928, 0.08067770296549259, 0.06946006424978224, 0.07282317686083117, 0.08409236261461006, 0.07105247295702777]}, "mutation_prompt": null}
{"id": "ee9a92ad-73d9-4b63-8727-e85dcbb334e7", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1781f53c-d427-415b-b341-51b757b0883a", "metadata": {"aucs": [0.8155080130564687, 0.7559033804976276, 0.7905083647019924, 0.7706365799583045, 0.7720004892919544, 0.7593470219345677, 0.7537370188105208, 0.760038582709117, 0.7688127909607124, 0.5655881478001787, 0.5774910683303923, 0.5640605575423558, 0.5925450739444624, 0.572418207547452, 0.6097388193042579, 0.5556425429128315, 0.5794651159433983, 0.4865324343657187, 0.10943136396215947, 0.09551252924468845, 0.19098254722941055, 0.1241651193987725, 0.11679336299777643, 0.11247960589287809, 0.16658243415655982, 0.1632262133238752, 0.11016878883262637, 0.10253476795804106, 0.10701880832640687, 0.11420581915681427, 0.0991033430946705, 0.09434269006753326, 0.09919209965355336, 0.0899865563697555, 0.0976362981869745, 0.10370745962354033, 0.923371693436908, 0.9363393286271675, 0.9608986395726264, 0.9463349414245236, 0.9247224580034754, 0.9279701146332561, 0.9364984422653984, 0.892427483563698, 0.9327239774445928, 0.38961470800148157, 0.3963780867715607, 0.3686744308588069, 0.3515614301952177, 0.38238093954163144, 0.43305139347151844, 0.41129460015236496, 0.3709672897802697, 0.41145014541706304, 0.6318642824223506, 0.6570223002505244, 0.6689572208121993, 0.7081456948982934, 0.7229000682226474, 0.6888472264719517, 0.7369845083567743, 0.687656214634984, 0.6319416473784123, 0.20893564626953753, 0.16228156593626775, 0.17338691928834882, 0.17647999228280753, 0.24285597991865826, 0.16118881822081088, 0.24473973831693185, 0.16551774375254769, 0.23476747011081156, 0.14383782780042698, 0.20626465327264576, 0.15773475133562065, 0.170206041048668, 0.21390758419115674, 0.21210583976041686, 0.20367153521640124, 0.24212705844334348, 0.2874615594205191, 0.24943938636657104, 0.1516988015971077, 0.14246514859489356, 0.16179380538329502, 0.05283406603146834, 0.16399208308360724, 0.08230390917160779, 0.23903450289247374, 0.19828219686521076, 0.38785787456595877, 0.1944053508152328, 0.20255903876423798, 0.30903918241211026, 0.08832873300199118, 0.2857456767736388, 0.2542965026183789, 0.3312113038170096, 0.26096961762957693, 0.1340230634623918, 0.06850336774886201, 0.0776777271545539, 0.13454392931627845, 0.16769666118628357, 0.13932391155391777, 0.19572413483334838, 0.10905776980095017, 0.07939909619366403, 0.21869671965659854, 0.24069183744191902, 0.2449777441711366, 0.24249713021935504, 0.22925334786160378, 0.21948998938137942, 0.22631154759998884, 0.13903149065133602, 0.2123170410292312, 0.592410353772121, 0.5684522966706104, 0.620032363275939, 0.5112054176539589, 0.5671683914164736, 0.5588984269431831, 0.5721274467175509, 0.6286008067195519, 0.4918649782488407, 0.1012396790249328, 0.0902208929203181, 0.09910907027098126, 0.08495686269696978, 0.08939890254541771, 0.10663674442861903, 0.11445232136113026, 0.09868097204222592, 0.09350706528911856, 0.15083767353253552, 0.12925164396279065, 0.12927750175204256, 0.14393042481362028, 0.13517460891076039, 0.16922078480273417, 0.17726654486825955, 0.17899464471903337, 0.14806208923146802, 0.3385064755394417, 0.3420195134293488, 0.37353325323882947, 0.38367508340147016, 0.36743206885613455, 0.3558564247864303, 0.3846914821853128, 0.44415119438478146, 0.30676904999245347, 0.25601381386222477, 0.2826239374327034, 0.2430533894011503, 0.2700414170094949, 0.20531713781403182, 0.25824891401701033, 0.25161223547838085, 0.27354689584154246, 0.2489349943783482, 0.211943166537908, 0.1711755788774303, 0.1829352222178865, 0.18306520226945278, 0.19257543927701726, 0.1886523531768498, 0.1983072573583481, 0.1817123683265266, 0.20729085075393172, 0.1938562863628135, 0.18021484475111627, 0.17425845280891605, 0.21246585147881236, 0.2063308769307325, 0.18989750267968653, 0.2049176702240061, 0.20565710230219647, 0.1965406425342291, 0.7705403016370592, 0.731721010009793, 0.6774948716833766, 0.16940668299918094, 0.18148865100910339, 0.6363469912578363, 0.6058619081548582, 0.6134353036444747, 0.6609550140440952, 0.5626305444830952, 0.20245676549081038, 0.2028523864752264, 0.1997670225341035, 0.16160522813605516, 0.3898407233241753, 0.2085555458785595, 0.2017501609276201, 0.2172740397968571, 0.20267674272573766, 0.19313308227723391, 0.1838331864222783, 0.17655238715641697, 0.17402241032542243, 0.1844822118261935, 0.19108853101452516, 0.1985809825634044, 0.19006367058715223, 0.06864813008708859, 0.0721558288638886, 0.07205634995464061, 0.09150845335842928, 0.08067770296549259, 0.06946006424978224, 0.07282317686083117, 0.08409236261461006, 0.07105247295702777]}, "mutation_prompt": null}
{"id": "e651b8cc-968c-409c-8cdc-ed3e15bd0b95", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1781f53c-d427-415b-b341-51b757b0883a", "metadata": {"aucs": [0.8155080130564687, 0.7559033804976276, 0.7905083647019924, 0.7706365799583045, 0.7720004892919544, 0.7593470219345677, 0.7537370188105208, 0.760038582709117, 0.7688127909607124, 0.5655881478001787, 0.5774910683303923, 0.5640605575423558, 0.5925450739444624, 0.572418207547452, 0.6097388193042579, 0.5556425429128315, 0.5794651159433983, 0.4865324343657187, 0.10943136396215947, 0.09551252924468845, 0.19098254722941055, 0.1241651193987725, 0.11679336299777643, 0.11247960589287809, 0.16658243415655982, 0.1632262133238752, 0.11016878883262637, 0.10253476795804106, 0.10701880832640687, 0.11420581915681427, 0.0991033430946705, 0.09434269006753326, 0.09919209965355336, 0.0899865563697555, 0.0976362981869745, 0.10370745962354033, 0.923371693436908, 0.9363393286271675, 0.9608986395726264, 0.9463349414245236, 0.9247224580034754, 0.9279701146332561, 0.9364984422653984, 0.892427483563698, 0.9327239774445928, 0.38961470800148157, 0.3963780867715607, 0.3686744308588069, 0.3515614301952177, 0.38238093954163144, 0.43305139347151844, 0.41129460015236496, 0.3709672897802697, 0.41145014541706304, 0.6318642824223506, 0.6570223002505244, 0.6689572208121993, 0.7081456948982934, 0.7229000682226474, 0.6888472264719517, 0.7369845083567743, 0.687656214634984, 0.6319416473784123, 0.20893564626953753, 0.16228156593626775, 0.17338691928834882, 0.17647999228280753, 0.24285597991865826, 0.16118881822081088, 0.24473973831693185, 0.16551774375254769, 0.23476747011081156, 0.14383782780042698, 0.20626465327264576, 0.15773475133562065, 0.170206041048668, 0.21390758419115674, 0.21210583976041686, 0.20367153521640124, 0.24212705844334348, 0.2874615594205191, 0.24943938636657104, 0.1516988015971077, 0.14246514859489356, 0.16179380538329502, 0.05283406603146834, 0.16399208308360724, 0.08230390917160779, 0.23903450289247374, 0.19828219686521076, 0.38785787456595877, 0.1944053508152328, 0.20255903876423798, 0.30903918241211026, 0.08832873300199118, 0.2857456767736388, 0.2542965026183789, 0.3312113038170096, 0.26096961762957693, 0.1340230634623918, 0.06850336774886201, 0.0776777271545539, 0.13454392931627845, 0.16769666118628357, 0.13932391155391777, 0.19572413483334838, 0.10905776980095017, 0.07939909619366403, 0.21869671965659854, 0.24069183744191902, 0.2449777441711366, 0.24249713021935504, 0.22925334786160378, 0.21948998938137942, 0.22631154759998884, 0.13903149065133602, 0.2123170410292312, 0.592410353772121, 0.5684522966706104, 0.620032363275939, 0.5112054176539589, 0.5671683914164736, 0.5588984269431831, 0.5721274467175509, 0.6286008067195519, 0.4918649782488407, 0.1012396790249328, 0.0902208929203181, 0.09910907027098126, 0.08495686269696978, 0.08939890254541771, 0.10663674442861903, 0.11445232136113026, 0.09868097204222592, 0.09350706528911856, 0.15083767353253552, 0.12925164396279065, 0.12927750175204256, 0.14393042481362028, 0.13517460891076039, 0.16922078480273417, 0.17726654486825955, 0.17899464471903337, 0.14806208923146802, 0.3385064755394417, 0.3420195134293488, 0.37353325323882947, 0.38367508340147016, 0.36743206885613455, 0.3558564247864303, 0.3846914821853128, 0.44415119438478146, 0.30676904999245347, 0.25601381386222477, 0.2826239374327034, 0.2430533894011503, 0.2700414170094949, 0.20531713781403182, 0.25824891401701033, 0.25161223547838085, 0.27354689584154246, 0.2489349943783482, 0.211943166537908, 0.1711755788774303, 0.1829352222178865, 0.18306520226945278, 0.19257543927701726, 0.1886523531768498, 0.1983072573583481, 0.1817123683265266, 0.20729085075393172, 0.1938562863628135, 0.18021484475111627, 0.17425845280891605, 0.21246585147881236, 0.2063308769307325, 0.18989750267968653, 0.2049176702240061, 0.20565710230219647, 0.1965406425342291, 0.7705403016370592, 0.731721010009793, 0.6774948716833766, 0.16940668299918094, 0.18148865100910339, 0.6363469912578363, 0.6058619081548582, 0.6134353036444747, 0.6609550140440952, 0.5626305444830952, 0.20245676549081038, 0.2028523864752264, 0.1997670225341035, 0.16160522813605516, 0.3898407233241753, 0.2085555458785595, 0.2017501609276201, 0.2172740397968571, 0.20267674272573766, 0.19313308227723391, 0.1838331864222783, 0.17655238715641697, 0.17402241032542243, 0.1844822118261935, 0.19108853101452516, 0.1985809825634044, 0.19006367058715223, 0.06864813008708859, 0.0721558288638886, 0.07205634995464061, 0.09150845335842928, 0.08067770296549259, 0.06946006424978224, 0.07282317686083117, 0.08409236261461006, 0.07105247295702777]}, "mutation_prompt": null}
{"id": "da66f7cc-08eb-4760-a4b5-d5150faf43c2", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.", "configspace": "", "generation": 58, "fitness": 0.36016074191880193, "feedback": "The algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.", "error": "", "parent_id": "1781f53c-d427-415b-b341-51b757b0883a", "metadata": {"aucs": [0.8548318385729348, 0.872653021443316, 0.8652536735112889, 0.8960424015381643, 0.8618573997873242, 0.898481482903389, 0.8916460748618078, 0.8395895177912309, 0.8614849515074394, 0.7832347976856403, 0.7812727217138351, 0.761678003804076, 0.766912193125078, 0.7742793114758036, 0.7908259298654678, 0.7865636735794322, 0.7117836086703349, 0.7720212242965693, 0.6617146979727642, 0.14748796721941582, 0.1450861292877016, 0.13851788236753293, 0.16997729346783474, 0.17611175246839772, 0.11249566391301213, 0.12704268620858583, 0.14972834149319225, 0.09276430119672219, 0.16479991406555416, 0.13028980597096584, 0.11271049728875027, 0.1171729071098151, 0.15183487480308266, 0.10725929301580583, 0.11355320224387633, 0.11750984654383845, 0.9833424689668839, 0.9654388062752698, 0.9650462295588489, 0.9752180238801252, 0.9777533358445616, 0.9926075243690655, 0.9770260779429703, 0.9896002674321291, 0.983901633138145, 0.606975557061285, 0.5156634547615945, 0.5837755942363012, 0.621574103386666, 0.6296580534177081, 0.6148050812267977, 0.6019218780310516, 0.6235849328680237, 0.6678229133126679, 0.22557620908533882, 0.7839059649206297, 0.8841260739400381, 0.17321701013800883, 0.2514621815814657, 0.8513894757080122, 0.7916687145249199, 0.7608605096398121, 0.8595745593017013, 0.12676823505718826, 0.13387539724167075, 0.4009095820146594, 0.12762934925869762, 0.4183289801457517, 0.43758382249047545, 0.44511925336579794, 0.33941978503492654, 0.1324958754344442, 0.37187630083756107, 0.31497161015486996, 0.2713487112167996, 0.13175148268917014, 0.12278842937778023, 0.34134175666956457, 0.3832512501442662, 0.29373917137407934, 0.5526834092103177, 0.07499757792106998, 0.033028783021207486, 0.12015090546269169, 0.05112619649586647, 0.14439085831215448, 0.08772845194281764, 0.2008748841006177, 0.04928704254459826, 0.11316990193349086, 0.10325038768722206, 0.09740302290511504, 0.1575658018961973, 0.2523018856595388, 0.2691067699579177, 0.2845178041791563, 0.5192483212057037, 0.18631575636953035, 0.14329047930071104, 0.21494476404576912, 0.058620860851931855, 0.05001180023498142, 0.09476294023547749, 0.10974958469389151, 0.14290504732295706, 0.2523294778235642, 0.19101399842763822, 0.07156976531758719, 0.2984843679013447, 0.2166503377545992, 0.3105191709301902, 0.35762319304981327, 0.2736671569005069, 0.3426995597142627, 0.2050072336624198, 0.23887188947544924, 0.23892535811074067, 0.6594723262387852, 0.673669847630006, 0.6844728086148513, 0.6241593308994504, 0.6288555770028349, 0.609330732140837, 0.7420212795479343, 0.648101512817916, 0.6293571777625386, 0.10811106375998791, 0.0964301121756369, 0.11272416942100372, 0.086735718170737, 0.08762716979984575, 0.08863345616221663, 0.07876179031338093, 0.08711501959326173, 0.13636899739975106, 0.7288151967493938, 0.24653946563393425, 0.16892088669115002, 0.1968681207119387, 0.321559933105111, 0.5889682095652952, 0.17633759488531164, 0.15436006900017984, 0.17320944187751175, 0.4538199159561146, 0.31181281961323737, 0.397465379030257, 0.3504804025047934, 0.42309067460723626, 0.3652615284811468, 0.5243362021654452, 0.4276947454060872, 0.5401146194457727, 0.2557371274356919, 0.2693477636611349, 0.19784070848552315, 0.30869566167569207, 0.2392425356733886, 0.23236312023037708, 0.3011240271377704, 0.28260298015165075, 0.27246688253099605, 0.19564735911117892, 0.16914847589560977, 0.19014833249503582, 0.20267393413063162, 0.1671794962689681, 0.19071192329076336, 0.17951590564453457, 0.20508383481160652, 0.1986995978087691, 0.24419725714418616, 0.19941785163382397, 0.18476689294996307, 0.23947431045187673, 0.2241324517684904, 0.2001797398005486, 0.2368582268078867, 0.1867700929180025, 0.20287994707968093, 0.8727280756692124, 0.8913286495526961, 0.15413543682634068, 0.9153001509334646, 0.8873429939036275, 0.19805283018761077, 0.0996744172654519, 0.16973365740239732, 0.16787331682078843, 0.08292643316707471, 0.20814120649932688, 0.1279211453614043, 0.35154373171240383, 0.14074905436744645, 0.8023213157910414, 0.2114627793463827, 0.15525174592892077, 0.213694147185007, 0.18214906348298632, 0.1822877546726026, 0.17852481874901982, 0.20436549616565303, 0.17692304829360983, 0.1873540754032671, 0.17939247563762806, 0.1772861508383572, 0.17561340544908766, 0.08124522158221226, 0.08978045675483393, 0.08111778013331272, 0.07709137007412015, 0.08352346779236342, 0.08193626253646868, 0.07110787016824849, 0.07796387241750014, 0.0824075881279116]}, "mutation_prompt": null}
{"id": "f34f023e-a5cd-4b94-b3f3-309055865d20", "solution": "import numpy as np\n\nclass ImprovedAdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b), self.lower_bound, self.upper_bound)  # Simplified strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.6 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n    \n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n    \n    def local_search(self, solution, func, fitness_value):\n        step_size = 0.1 + 0.9 * (1 - fitness_value / np.max(fitness_value))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 15 + int(5 * (1 - (self.num_evaluations / self.budget)))  # Adjusted dynamic resizing\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func, fitness)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "ImprovedAdaptiveScatterSearch", "description": "Improved Adaptive Scatter Search with Rebalanced Strategy for Exploration and Exploitation using Dynamic Population Resizing and Fitness-Based Local Search.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (5,) (20,) ').", "error": "ValueError('operands could not be broadcast together with shapes (5,) (20,) ')", "parent_id": "da66f7cc-08eb-4760-a4b5-d5150faf43c2", "metadata": {}, "mutation_prompt": null}
{"id": "f464f8db-501e-4290-b9d4-991038f17b94", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "da66f7cc-08eb-4760-a4b5-d5150faf43c2", "metadata": {"aucs": [0.8548318385729348, 0.872653021443316, 0.8652536735112889, 0.8960424015381643, 0.8618573997873242, 0.898481482903389, 0.8916460748618078, 0.8395895177912309, 0.8614849515074394, 0.7832347976856403, 0.7812727217138351, 0.761678003804076, 0.766912193125078, 0.7742793114758036, 0.7908259298654678, 0.7865636735794322, 0.7117836086703349, 0.7720212242965693, 0.6617146979727642, 0.14748796721941582, 0.1450861292877016, 0.13851788236753293, 0.16997729346783474, 0.17611175246839772, 0.11249566391301213, 0.12704268620858583, 0.14972834149319225, 0.09276430119672219, 0.16479991406555416, 0.13028980597096584, 0.11271049728875027, 0.1171729071098151, 0.15183487480308266, 0.10725929301580583, 0.11355320224387633, 0.11750984654383845, 0.9833424689668839, 0.9654388062752698, 0.9650462295588489, 0.9752180238801252, 0.9777533358445616, 0.9926075243690655, 0.9770260779429703, 0.9896002674321291, 0.983901633138145, 0.606975557061285, 0.5156634547615945, 0.5837755942363012, 0.621574103386666, 0.6296580534177081, 0.6148050812267977, 0.6019218780310516, 0.6235849328680237, 0.6678229133126679, 0.22557620908533882, 0.7839059649206297, 0.8841260739400381, 0.17321701013800883, 0.2514621815814657, 0.8513894757080122, 0.7916687145249199, 0.7608605096398121, 0.8595745593017013, 0.12676823505718826, 0.13387539724167075, 0.4009095820146594, 0.12762934925869762, 0.4183289801457517, 0.43758382249047545, 0.44511925336579794, 0.33941978503492654, 0.1324958754344442, 0.37187630083756107, 0.31497161015486996, 0.2713487112167996, 0.13175148268917014, 0.12278842937778023, 0.34134175666956457, 0.3832512501442662, 0.29373917137407934, 0.5526834092103177, 0.07499757792106998, 0.033028783021207486, 0.12015090546269169, 0.05112619649586647, 0.14439085831215448, 0.08772845194281764, 0.2008748841006177, 0.04928704254459826, 0.11316990193349086, 0.10325038768722206, 0.09740302290511504, 0.1575658018961973, 0.2523018856595388, 0.2691067699579177, 0.2845178041791563, 0.5192483212057037, 0.18631575636953035, 0.14329047930071104, 0.21494476404576912, 0.058620860851931855, 0.05001180023498142, 0.09476294023547749, 0.10974958469389151, 0.14290504732295706, 0.2523294778235642, 0.19101399842763822, 0.07156976531758719, 0.2984843679013447, 0.2166503377545992, 0.3105191709301902, 0.35762319304981327, 0.2736671569005069, 0.3426995597142627, 0.2050072336624198, 0.23887188947544924, 0.23892535811074067, 0.6594723262387852, 0.673669847630006, 0.6844728086148513, 0.6241593308994504, 0.6288555770028349, 0.609330732140837, 0.7420212795479343, 0.648101512817916, 0.6293571777625386, 0.10811106375998791, 0.0964301121756369, 0.11272416942100372, 0.086735718170737, 0.08762716979984575, 0.08863345616221663, 0.07876179031338093, 0.08711501959326173, 0.13636899739975106, 0.7288151967493938, 0.24653946563393425, 0.16892088669115002, 0.1968681207119387, 0.321559933105111, 0.5889682095652952, 0.17633759488531164, 0.15436006900017984, 0.17320944187751175, 0.4538199159561146, 0.31181281961323737, 0.397465379030257, 0.3504804025047934, 0.42309067460723626, 0.3652615284811468, 0.5243362021654452, 0.4276947454060872, 0.5401146194457727, 0.2557371274356919, 0.2693477636611349, 0.19784070848552315, 0.30869566167569207, 0.2392425356733886, 0.23236312023037708, 0.3011240271377704, 0.28260298015165075, 0.27246688253099605, 0.19564735911117892, 0.16914847589560977, 0.19014833249503582, 0.20267393413063162, 0.1671794962689681, 0.19071192329076336, 0.17951590564453457, 0.20508383481160652, 0.1986995978087691, 0.24419725714418616, 0.19941785163382397, 0.18476689294996307, 0.23947431045187673, 0.2241324517684904, 0.2001797398005486, 0.2368582268078867, 0.1867700929180025, 0.20287994707968093, 0.8727280756692124, 0.8913286495526961, 0.15413543682634068, 0.9153001509334646, 0.8873429939036275, 0.19805283018761077, 0.0996744172654519, 0.16973365740239732, 0.16787331682078843, 0.08292643316707471, 0.20814120649932688, 0.1279211453614043, 0.35154373171240383, 0.14074905436744645, 0.8023213157910414, 0.2114627793463827, 0.15525174592892077, 0.213694147185007, 0.18214906348298632, 0.1822877546726026, 0.17852481874901982, 0.20436549616565303, 0.17692304829360983, 0.1873540754032671, 0.17939247563762806, 0.1772861508383572, 0.17561340544908766, 0.08124522158221226, 0.08978045675483393, 0.08111778013331272, 0.07709137007412015, 0.08352346779236342, 0.08193626253646868, 0.07110787016824849, 0.07796387241750014, 0.0824075881279116]}, "mutation_prompt": null}
{"id": "6e30a28e-cd95-4520-b1eb-86d5bee024ae", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def reinitialize_population(self, current_population, best_solution):\n        # Reinitialize half the population randomly to prevent premature convergence\n        half_size = len(current_population) // 2\n        new_population = self.initialize_population(half_size)\n        new_population = np.vstack((current_population, new_population))\n        return new_population\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            if self.num_evaluations % (self.budget // 10) == 0:  # Periodically reinitialize\n                population = self.reinitialize_population(population, population[np.argmin(fitness)])\n                fitness = self.evaluate_population(population, func)\n            \n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Adaptive Scatter Search with Enhanced Differential Mutation, Adaptive Crossover Probability, and Periodic Reinitialization to Prevent Premature Convergence.", "configspace": "", "generation": 61, "fitness": 0.350015287167513, "feedback": "The algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.28.", "error": "", "parent_id": "da66f7cc-08eb-4760-a4b5-d5150faf43c2", "metadata": {"aucs": [0.8533551047238865, 0.8723002109624729, 0.8652536735112889, 0.8960424015381643, 0.861191948745871, 0.898481482903389, 0.8916460748618078, 0.8357991319825121, 0.8614668296330444, 0.7783881671423398, 0.768340569640569, 0.7405274910208144, 0.7571654529283732, 0.7654457158690064, 0.787363191163986, 0.7722106080562103, 0.6863701745262132, 0.7630678139823408, 0.6005600378022264, 0.14670808888387132, 0.14467719245428912, 0.1385173590836044, 0.16978142669105323, 0.17610774652191796, 0.1515194481201173, 0.12703939026391686, 0.14974014864275342, 0.10337773977408815, 0.16362444423221623, 0.1296863399735243, 0.11241311076665228, 0.14119148894670996, 0.15183110277115885, 0.13262178766926103, 0.10799450074886918, 0.1306351903714491, 0.9833424689668839, 0.9654388062752698, 0.9650462295588489, 0.9752180238801252, 0.9777533358445616, 0.9926075243690655, 0.9770260779429703, 0.9896002674321291, 0.983901633138145, 0.5788180609159366, 0.45724357366430946, 0.47089124285306083, 0.531299648654893, 0.5322907097926931, 0.5351654874907265, 0.5000611881352421, 0.5151017642072013, 0.5794590067461061, 0.22557620908533882, 0.7839059649206297, 0.8841260739400381, 0.16137170623522523, 0.21284584017317132, 0.8513894757080122, 0.7916687145249199, 0.6708665497783495, 0.8595745593017013, 0.12616377677798774, 0.18331179391741692, 0.31922200257132705, 0.1275236389275507, 0.32501027376702873, 0.4373862937308829, 0.12913943848501097, 0.26568735561899937, 0.13248985323923357, 0.33499510584658, 0.2951086283825983, 0.24671750929310288, 0.13173376972158835, 0.12295643613118612, 0.298428046761545, 0.31016275972665885, 0.31007058943961396, 0.5137153087840431, 0.07445555421104832, 0.05391727533179069, 0.09548970601477469, 0.07455761963757745, 0.1506605171720421, 0.08850346555104427, 0.18838074333267263, 0.052666659491700574, 0.12140804422381846, 0.13786846092769278, 0.1603051493214236, 0.1747584267836655, 0.3153322207130106, 0.3042086156029624, 0.38263161793453815, 0.38445652523220064, 0.20515544991073809, 0.1740865676868114, 0.16130078762205302, 0.05206087959763195, 0.05001179905939279, 0.10300931775665645, 0.10694789372937774, 0.13343310765758176, 0.25658299759314473, 0.18948923931918393, 0.07156975713728919, 0.24007692300017136, 0.18770453479698268, 0.31090640514502454, 0.31180425880462403, 0.28177206176879777, 0.3240083977859336, 0.18737625583161155, 0.23885331981858404, 0.2251857645743025, 0.7273770264582394, 0.6917955374156874, 0.713491990464906, 0.6640568766971895, 0.6861776204804637, 0.6163182657280961, 0.7136789828257604, 0.6558625608289629, 0.6798917146722168, 0.1057726589389244, 0.08898941379897518, 0.0996368112224747, 0.08559823150956802, 0.09396534897851849, 0.08760905252294937, 0.07864936594161587, 0.09092819858319834, 0.08866921446407816, 0.6408596880999079, 0.3778581996144934, 0.19943264625077095, 0.2068864604068642, 0.28941561008941885, 0.39586995519545587, 0.1823845707302425, 0.15413059589795264, 0.17269457847063274, 0.37426197909143133, 0.3079731185580976, 0.3785810185977825, 0.3461553634664378, 0.4082323759074792, 0.3414982776325566, 0.4936842648051899, 0.36502868171725056, 0.5182717507486987, 0.2578780663024348, 0.266014728179938, 0.19609634743116977, 0.29329160272008714, 0.21384086590150664, 0.2312540281266252, 0.29898252299338524, 0.2828312220270469, 0.2735506623010364, 0.21090093669211418, 0.19191272113715208, 0.193409875055348, 0.20789368141864029, 0.17568066789748404, 0.19465447671912184, 0.18475428021882445, 0.20051699269313872, 0.2021298696952335, 0.2441876645209098, 0.19920040763402724, 0.18475486370508976, 0.23935719082670825, 0.22413244319290493, 0.20017972628449066, 0.23631692325547315, 0.18677000613424843, 0.20762465128843288, 0.8727280756692124, 0.8913286495526961, 0.15413543682481923, 0.9153001509334646, 0.8873429939036275, 0.19805283018550157, 0.09967441726405868, 0.16973365740165314, 0.16787331643439518, 0.08292643316692339, 0.20814120589448803, 0.12792114441020275, 0.10484572986234908, 0.09302895355555207, 0.806203680438297, 0.21146277932714896, 0.15525174592459057, 0.21369414718492352, 0.18770492998905652, 0.18511943402963915, 0.17943173471467921, 0.19645256848411374, 0.17654150471465924, 0.1916939058904713, 0.18692267552951114, 0.17759091427496354, 0.1783066753318544, 0.0826396368782889, 0.07936236096313765, 0.0816508277568675, 0.0774526637138826, 0.07730770853230806, 0.07754098804444787, 0.07124421575808082, 0.07393516903301733, 0.07816170379913112]}, "mutation_prompt": null}
{"id": "68b277f2-2569-4e40-8e48-36f3e5cf3b3e", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "da66f7cc-08eb-4760-a4b5-d5150faf43c2", "metadata": {"aucs": [0.8548318385729348, 0.872653021443316, 0.8652536735112889, 0.8960424015381643, 0.8618573997873242, 0.898481482903389, 0.8916460748618078, 0.8395895177912309, 0.8614849515074394, 0.7832347976856403, 0.7812727217138351, 0.761678003804076, 0.766912193125078, 0.7742793114758036, 0.7908259298654678, 0.7865636735794322, 0.7117836086703349, 0.7720212242965693, 0.6617146979727642, 0.14748796721941582, 0.1450861292877016, 0.13851788236753293, 0.16997729346783474, 0.17611175246839772, 0.11249566391301213, 0.12704268620858583, 0.14972834149319225, 0.09276430119672219, 0.16479991406555416, 0.13028980597096584, 0.11271049728875027, 0.1171729071098151, 0.15183487480308266, 0.10725929301580583, 0.11355320224387633, 0.11750984654383845, 0.9833424689668839, 0.9654388062752698, 0.9650462295588489, 0.9752180238801252, 0.9777533358445616, 0.9926075243690655, 0.9770260779429703, 0.9896002674321291, 0.983901633138145, 0.606975557061285, 0.5156634547615945, 0.5837755942363012, 0.621574103386666, 0.6296580534177081, 0.6148050812267977, 0.6019218780310516, 0.6235849328680237, 0.6678229133126679, 0.22557620908533882, 0.7839059649206297, 0.8841260739400381, 0.17321701013800883, 0.2514621815814657, 0.8513894757080122, 0.7916687145249199, 0.7608605096398121, 0.8595745593017013, 0.12676823505718826, 0.13387539724167075, 0.4009095820146594, 0.12762934925869762, 0.4183289801457517, 0.43758382249047545, 0.44511925336579794, 0.33941978503492654, 0.1324958754344442, 0.37187630083756107, 0.31497161015486996, 0.2713487112167996, 0.13175148268917014, 0.12278842937778023, 0.34134175666956457, 0.3832512501442662, 0.29373917137407934, 0.5526834092103177, 0.07499757792106998, 0.033028783021207486, 0.12015090546269169, 0.05112619649586647, 0.14439085831215448, 0.08772845194281764, 0.2008748841006177, 0.04928704254459826, 0.11316990193349086, 0.10325038768722206, 0.09740302290511504, 0.1575658018961973, 0.2523018856595388, 0.2691067699579177, 0.2845178041791563, 0.5192483212057037, 0.18631575636953035, 0.14329047930071104, 0.21494476404576912, 0.058620860851931855, 0.05001180023498142, 0.09476294023547749, 0.10974958469389151, 0.14290504732295706, 0.2523294778235642, 0.19101399842763822, 0.07156976531758719, 0.2984843679013447, 0.2166503377545992, 0.3105191709301902, 0.35762319304981327, 0.2736671569005069, 0.3426995597142627, 0.2050072336624198, 0.23887188947544924, 0.23892535811074067, 0.6594723262387852, 0.673669847630006, 0.6844728086148513, 0.6241593308994504, 0.6288555770028349, 0.609330732140837, 0.7420212795479343, 0.648101512817916, 0.6293571777625386, 0.10811106375998791, 0.0964301121756369, 0.11272416942100372, 0.086735718170737, 0.08762716979984575, 0.08863345616221663, 0.07876179031338093, 0.08711501959326173, 0.13636899739975106, 0.7288151967493938, 0.24653946563393425, 0.16892088669115002, 0.1968681207119387, 0.321559933105111, 0.5889682095652952, 0.17633759488531164, 0.15436006900017984, 0.17320944187751175, 0.4538199159561146, 0.31181281961323737, 0.397465379030257, 0.3504804025047934, 0.42309067460723626, 0.3652615284811468, 0.5243362021654452, 0.4276947454060872, 0.5401146194457727, 0.2557371274356919, 0.2693477636611349, 0.19784070848552315, 0.30869566167569207, 0.2392425356733886, 0.23236312023037708, 0.3011240271377704, 0.28260298015165075, 0.27246688253099605, 0.19564735911117892, 0.16914847589560977, 0.19014833249503582, 0.20267393413063162, 0.1671794962689681, 0.19071192329076336, 0.17951590564453457, 0.20508383481160652, 0.1986995978087691, 0.24419725714418616, 0.19941785163382397, 0.18476689294996307, 0.23947431045187673, 0.2241324517684904, 0.2001797398005486, 0.2368582268078867, 0.1867700929180025, 0.20287994707968093, 0.8727280756692124, 0.8913286495526961, 0.15413543682634068, 0.9153001509334646, 0.8873429939036275, 0.19805283018761077, 0.0996744172654519, 0.16973365740239732, 0.16787331682078843, 0.08292643316707471, 0.20814120649932688, 0.1279211453614043, 0.35154373171240383, 0.14074905436744645, 0.8023213157910414, 0.2114627793463827, 0.15525174592892077, 0.213694147185007, 0.18214906348298632, 0.1822877546726026, 0.17852481874901982, 0.20436549616565303, 0.17692304829360983, 0.1873540754032671, 0.17939247563762806, 0.1772861508383572, 0.17561340544908766, 0.08124522158221226, 0.08978045675483393, 0.08111778013331272, 0.07709137007412015, 0.08352346779236342, 0.08193626253646868, 0.07110787016824849, 0.07796387241750014, 0.0824075881279116]}, "mutation_prompt": null}
{"id": "d2f99ee7-2f4f-42d2-af1d-e4b4a03d043d", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.shrink_factor = 0.99\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.6, 1.0)  # Slightly increased F for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (c - a), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.6 * (self.num_evaluations / self.budget)  # Adjusted dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.5 / (1 + np.exp(-0.15 * self.num_evaluations))  # Improved step size\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def shrink_search_space(self):\n        self.lower_bound *= self.shrink_factor\n        self.upper_bound *= self.shrink_factor\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations % (self.budget // 4) == 0:\n                    self.shrink_search_space()  # Occasional shrinkage\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Enhanced Adaptive Scatter Search with Dynamic Search Space Reduction and Improved Local Search Heuristic.", "configspace": "", "generation": 63, "fitness": 0.3369734340736163, "feedback": "The algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.26.", "error": "", "parent_id": "da66f7cc-08eb-4760-a4b5-d5150faf43c2", "metadata": {"aucs": [0.8169828489563462, 0.8164322673710187, 0.8190422721119807, 0.842351459066413, 0.8454016340895827, 0.8264533508700005, 0.8343982124960331, 0.8295776479875824, 0.8379053354124916, 0.25950401083682817, 0.6866702334980777, 0.2641115126645287, 0.6793062127223961, 0.6708571131357015, 0.6952454858167212, 0.6599305528372709, 0.7046306116639778, 0.23848264308450873, 0.13799716786536664, 0.11123037026166871, 0.11163975371339152, 0.14216973341996086, 0.14118663501398754, 0.13514861400210376, 0.16987662288402916, 0.5158688233492377, 0.1364746736969744, 0.1298898857211045, 0.1215066872667292, 0.13125048298976494, 0.09427018214385008, 0.14408042078262118, 0.13005171838902674, 0.13133804242489655, 0.13168994372514176, 0.1123013188690769, 0.9945642451318412, 0.9794065979028026, 0.9866869238648667, 0.9824948781773165, 0.9816158765319806, 0.9904847689178001, 0.9847023248108651, 0.9849614637812495, 0.9884818604574629, 0.46177377818559984, 0.4394344006832255, 0.47439176693415985, 0.48899086250243695, 0.481824313599286, 0.5531243747964718, 0.514741070516238, 0.4216054037306489, 0.504097587481322, 0.3567582588944693, 0.2185457274970235, 0.22561487327658114, 0.19212512129093506, 0.7021420321259125, 0.7753230079374676, 0.6975026262657298, 0.8042856958475364, 0.7760674361978672, 0.43394459175167943, 0.38128885723032113, 0.44965805581126284, 0.3646196667155198, 0.1275357009204483, 0.3838790466551433, 0.5050497171696853, 0.3417688210979831, 0.625789057936636, 0.38434884227996235, 0.11301246281548594, 0.12432265553570454, 0.5390611739463316, 0.3428019115012487, 0.5098489079710362, 0.4197480094868715, 9.999999999998899e-05, 0.1243927131224496, 0.07885141037634202, 0.20113633917246487, 0.20175253015889572, 0.03449199766059807, 0.11369758128742691, 0.05342490729518323, 0.24946345057277886, 0.21669719403460685, 0.1322145995862014, 0.17930096186471312, 0.2967681765417156, 0.12097040232460399, 0.32800561533906003, 0.2924984208520818, 0.19519375880921286, 0.15821920341919027, 0.2909595807434734, 0.30876782842892103, 0.03231441717447303, 0.05977241505067854, 0.18571071813555973, 0.07553226599980711, 0.30089866575654245, 0.20077972593742943, 0.13115502502598497, 0.19697879232037319, 0.06629193457431082, 0.2133228355494462, 0.31571703835788945, 0.266597828973125, 0.32545382399869627, 0.2800811932988151, 0.3320288880983119, 0.30370577384292674, 0.32251546513923945, 0.2885487466425368, 0.5645676345696538, 0.6679437294640211, 0.6531194304892449, 0.5813102636882959, 0.6953133145367316, 0.5928581399583814, 0.6604151613007262, 0.5990714531353007, 0.6141463834995682, 0.09689173290717024, 0.10401905584227045, 0.11573576711285039, 0.10810364641036596, 0.09036159490478435, 0.1072951354303312, 0.10250085766300143, 0.13497731793044754, 0.10713691552098303, 0.25223019159760685, 0.20229357860622899, 0.2204318299168997, 0.24436065740518376, 0.2339262314889291, 0.13002354582091136, 0.17040746468025902, 0.23926317028654875, 0.11302800306346494, 0.3560227734433544, 0.4060615852525198, 0.41058128969196006, 0.4010667306774024, 0.32766643362588155, 0.368260411567105, 0.35092753474295013, 0.3203691968854535, 0.26839222232555926, 0.3289404774620087, 0.3579437242811929, 0.25418564055523984, 0.28237672587918283, 0.2474637193968553, 0.19177531192619846, 0.3055878828781846, 0.26801926278252053, 0.2449750884464027, 0.18460886009892696, 0.20274795705014736, 0.1979494496737193, 0.16370807599943615, 0.1709998172223972, 0.17888974391827084, 0.19200301717912038, 0.18661347884398682, 0.18493581810663073, 0.21664621394273742, 0.24325583140183626, 0.23682126025731964, 0.20008965384001975, 0.19541758480110405, 0.5763144715055984, 0.342024073237264, 0.20211959285427106, 0.21205582105689025, 0.8505099432894678, 0.17004822161700417, 0.15404044125386385, 0.8732465072757916, 0.193408622673775, 0.1561006460650296, 0.10777774361320136, 0.16499810588981034, 0.15988858247138937, 0.15547002057084924, 0.2097186978373906, 0.11278120422896387, 0.804798286438998, 0.16777935086931062, 0.20757225329852913, 0.21443687397344213, 0.21247018296015885, 0.7635621752572133, 0.18802651135379356, 0.18051703353764748, 0.17907355468830155, 0.17259649995520887, 0.20705181979774512, 0.21755352038601072, 0.19114743195246464, 0.18438452594313093, 0.19898943913258915, 0.07694777047762569, 0.07787819496725301, 0.07119860218337415, 0.07309862121843302, 0.0761878809152613, 0.0655172102323095, 0.07991886626637257, 0.08099180338626488, 0.06903421111245989]}, "mutation_prompt": null}
{"id": "04191306-86ce-4404-8c04-19805d8ea9bc", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "da66f7cc-08eb-4760-a4b5-d5150faf43c2", "metadata": {"aucs": [0.8548318385729348, 0.872653021443316, 0.8652536735112889, 0.8960424015381643, 0.8618573997873242, 0.898481482903389, 0.8916460748618078, 0.8395895177912309, 0.8614849515074394, 0.7832347976856403, 0.7812727217138351, 0.761678003804076, 0.766912193125078, 0.7742793114758036, 0.7908259298654678, 0.7865636735794322, 0.7117836086703349, 0.7720212242965693, 0.6617146979727642, 0.14748796721941582, 0.1450861292877016, 0.13851788236753293, 0.16997729346783474, 0.17611175246839772, 0.11249566391301213, 0.12704268620858583, 0.14972834149319225, 0.09276430119672219, 0.16479991406555416, 0.13028980597096584, 0.11271049728875027, 0.1171729071098151, 0.15183487480308266, 0.10725929301580583, 0.11355320224387633, 0.11750984654383845, 0.9833424689668839, 0.9654388062752698, 0.9650462295588489, 0.9752180238801252, 0.9777533358445616, 0.9926075243690655, 0.9770260779429703, 0.9896002674321291, 0.983901633138145, 0.606975557061285, 0.5156634547615945, 0.5837755942363012, 0.621574103386666, 0.6296580534177081, 0.6148050812267977, 0.6019218780310516, 0.6235849328680237, 0.6678229133126679, 0.22557620908533882, 0.7839059649206297, 0.8841260739400381, 0.17321701013800883, 0.2514621815814657, 0.8513894757080122, 0.7916687145249199, 0.7608605096398121, 0.8595745593017013, 0.12676823505718826, 0.13387539724167075, 0.4009095820146594, 0.12762934925869762, 0.4183289801457517, 0.43758382249047545, 0.44511925336579794, 0.33941978503492654, 0.1324958754344442, 0.37187630083756107, 0.31497161015486996, 0.2713487112167996, 0.13175148268917014, 0.12278842937778023, 0.34134175666956457, 0.3832512501442662, 0.29373917137407934, 0.5526834092103177, 0.07499757792106998, 0.033028783021207486, 0.12015090546269169, 0.05112619649586647, 0.14439085831215448, 0.08772845194281764, 0.2008748841006177, 0.04928704254459826, 0.11316990193349086, 0.10325038768722206, 0.09740302290511504, 0.1575658018961973, 0.2523018856595388, 0.2691067699579177, 0.2845178041791563, 0.5192483212057037, 0.18631575636953035, 0.14329047930071104, 0.21494476404576912, 0.058620860851931855, 0.05001180023498142, 0.09476294023547749, 0.10974958469389151, 0.14290504732295706, 0.2523294778235642, 0.19101399842763822, 0.07156976531758719, 0.2984843679013447, 0.2166503377545992, 0.3105191709301902, 0.35762319304981327, 0.2736671569005069, 0.3426995597142627, 0.2050072336624198, 0.23887188947544924, 0.23892535811074067, 0.6594723262387852, 0.673669847630006, 0.6844728086148513, 0.6241593308994504, 0.6288555770028349, 0.609330732140837, 0.7420212795479343, 0.648101512817916, 0.6293571777625386, 0.10811106375998791, 0.0964301121756369, 0.11272416942100372, 0.086735718170737, 0.08762716979984575, 0.08863345616221663, 0.07876179031338093, 0.08711501959326173, 0.13636899739975106, 0.7288151967493938, 0.24653946563393425, 0.16892088669115002, 0.1968681207119387, 0.321559933105111, 0.5889682095652952, 0.17633759488531164, 0.15436006900017984, 0.17320944187751175, 0.4538199159561146, 0.31181281961323737, 0.397465379030257, 0.3504804025047934, 0.42309067460723626, 0.3652615284811468, 0.5243362021654452, 0.4276947454060872, 0.5401146194457727, 0.2557371274356919, 0.2693477636611349, 0.19784070848552315, 0.30869566167569207, 0.2392425356733886, 0.23236312023037708, 0.3011240271377704, 0.28260298015165075, 0.27246688253099605, 0.19564735911117892, 0.16914847589560977, 0.19014833249503582, 0.20267393413063162, 0.1671794962689681, 0.19071192329076336, 0.17951590564453457, 0.20508383481160652, 0.1986995978087691, 0.24419725714418616, 0.19941785163382397, 0.18476689294996307, 0.23947431045187673, 0.2241324517684904, 0.2001797398005486, 0.2368582268078867, 0.1867700929180025, 0.20287994707968093, 0.8727280756692124, 0.8913286495526961, 0.15413543682634068, 0.9153001509334646, 0.8873429939036275, 0.19805283018761077, 0.0996744172654519, 0.16973365740239732, 0.16787331682078843, 0.08292643316707471, 0.20814120649932688, 0.1279211453614043, 0.35154373171240383, 0.14074905436744645, 0.8023213157910414, 0.2114627793463827, 0.15525174592892077, 0.213694147185007, 0.18214906348298632, 0.1822877546726026, 0.17852481874901982, 0.20436549616565303, 0.17692304829360983, 0.1873540754032671, 0.17939247563762806, 0.1772861508383572, 0.17561340544908766, 0.08124522158221226, 0.08978045675483393, 0.08111778013331272, 0.07709137007412015, 0.08352346779236342, 0.08193626253646868, 0.07110787016824849, 0.07796387241750014, 0.0824075881279116]}, "mutation_prompt": null}
{"id": "44259bb8-0365-4eeb-86ae-ac86501627cb", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "da66f7cc-08eb-4760-a4b5-d5150faf43c2", "metadata": {"aucs": [0.8548318385729348, 0.872653021443316, 0.8652536735112889, 0.8960424015381643, 0.8618573997873242, 0.898481482903389, 0.8916460748618078, 0.8395895177912309, 0.8614849515074394, 0.7832347976856403, 0.7812727217138351, 0.761678003804076, 0.766912193125078, 0.7742793114758036, 0.7908259298654678, 0.7865636735794322, 0.7117836086703349, 0.7720212242965693, 0.6617146979727642, 0.14748796721941582, 0.1450861292877016, 0.13851788236753293, 0.16997729346783474, 0.17611175246839772, 0.11249566391301213, 0.12704268620858583, 0.14972834149319225, 0.09276430119672219, 0.16479991406555416, 0.13028980597096584, 0.11271049728875027, 0.1171729071098151, 0.15183487480308266, 0.10725929301580583, 0.11355320224387633, 0.11750984654383845, 0.9833424689668839, 0.9654388062752698, 0.9650462295588489, 0.9752180238801252, 0.9777533358445616, 0.9926075243690655, 0.9770260779429703, 0.9896002674321291, 0.983901633138145, 0.606975557061285, 0.5156634547615945, 0.5837755942363012, 0.621574103386666, 0.6296580534177081, 0.6148050812267977, 0.6019218780310516, 0.6235849328680237, 0.6678229133126679, 0.22557620908533882, 0.7839059649206297, 0.8841260739400381, 0.17321701013800883, 0.2514621815814657, 0.8513894757080122, 0.7916687145249199, 0.7608605096398121, 0.8595745593017013, 0.12676823505718826, 0.13387539724167075, 0.4009095820146594, 0.12762934925869762, 0.4183289801457517, 0.43758382249047545, 0.44511925336579794, 0.33941978503492654, 0.1324958754344442, 0.37187630083756107, 0.31497161015486996, 0.2713487112167996, 0.13175148268917014, 0.12278842937778023, 0.34134175666956457, 0.3832512501442662, 0.29373917137407934, 0.5526834092103177, 0.07499757792106998, 0.033028783021207486, 0.12015090546269169, 0.05112619649586647, 0.14439085831215448, 0.08772845194281764, 0.2008748841006177, 0.04928704254459826, 0.11316990193349086, 0.10325038768722206, 0.09740302290511504, 0.1575658018961973, 0.2523018856595388, 0.2691067699579177, 0.2845178041791563, 0.5192483212057037, 0.18631575636953035, 0.14329047930071104, 0.21494476404576912, 0.058620860851931855, 0.05001180023498142, 0.09476294023547749, 0.10974958469389151, 0.14290504732295706, 0.2523294778235642, 0.19101399842763822, 0.07156976531758719, 0.2984843679013447, 0.2166503377545992, 0.3105191709301902, 0.35762319304981327, 0.2736671569005069, 0.3426995597142627, 0.2050072336624198, 0.23887188947544924, 0.23892535811074067, 0.6594723262387852, 0.673669847630006, 0.6844728086148513, 0.6241593308994504, 0.6288555770028349, 0.609330732140837, 0.7420212795479343, 0.648101512817916, 0.6293571777625386, 0.10811106375998791, 0.0964301121756369, 0.11272416942100372, 0.086735718170737, 0.08762716979984575, 0.08863345616221663, 0.07876179031338093, 0.08711501959326173, 0.13636899739975106, 0.7288151967493938, 0.24653946563393425, 0.16892088669115002, 0.1968681207119387, 0.321559933105111, 0.5889682095652952, 0.17633759488531164, 0.15436006900017984, 0.17320944187751175, 0.4538199159561146, 0.31181281961323737, 0.397465379030257, 0.3504804025047934, 0.42309067460723626, 0.3652615284811468, 0.5243362021654452, 0.4276947454060872, 0.5401146194457727, 0.2557371274356919, 0.2693477636611349, 0.19784070848552315, 0.30869566167569207, 0.2392425356733886, 0.23236312023037708, 0.3011240271377704, 0.28260298015165075, 0.27246688253099605, 0.19564735911117892, 0.16914847589560977, 0.19014833249503582, 0.20267393413063162, 0.1671794962689681, 0.19071192329076336, 0.17951590564453457, 0.20508383481160652, 0.1986995978087691, 0.24419725714418616, 0.19941785163382397, 0.18476689294996307, 0.23947431045187673, 0.2241324517684904, 0.2001797398005486, 0.2368582268078867, 0.1867700929180025, 0.20287994707968093, 0.8727280756692124, 0.8913286495526961, 0.15413543682634068, 0.9153001509334646, 0.8873429939036275, 0.19805283018761077, 0.0996744172654519, 0.16973365740239732, 0.16787331682078843, 0.08292643316707471, 0.20814120649932688, 0.1279211453614043, 0.35154373171240383, 0.14074905436744645, 0.8023213157910414, 0.2114627793463827, 0.15525174592892077, 0.213694147185007, 0.18214906348298632, 0.1822877546726026, 0.17852481874901982, 0.20436549616565303, 0.17692304829360983, 0.1873540754032671, 0.17939247563762806, 0.1772861508383572, 0.17561340544908766, 0.08124522158221226, 0.08978045675483393, 0.08111778013331272, 0.07709137007412015, 0.08352346779236342, 0.08193626253646868, 0.07110787016824849, 0.07796387241750014, 0.0824075881279116]}, "mutation_prompt": null}
{"id": "f314ec66-79ed-45a1-ad85-b0b5b93c1762", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "da66f7cc-08eb-4760-a4b5-d5150faf43c2", "metadata": {"aucs": [0.8548318385729348, 0.872653021443316, 0.8652536735112889, 0.8960424015381643, 0.8618573997873242, 0.898481482903389, 0.8916460748618078, 0.8395895177912309, 0.8614849515074394, 0.7832347976856403, 0.7812727217138351, 0.761678003804076, 0.766912193125078, 0.7742793114758036, 0.7908259298654678, 0.7865636735794322, 0.7117836086703349, 0.7720212242965693, 0.6617146979727642, 0.14748796721941582, 0.1450861292877016, 0.13851788236753293, 0.16997729346783474, 0.17611175246839772, 0.11249566391301213, 0.12704268620858583, 0.14972834149319225, 0.09276430119672219, 0.16479991406555416, 0.13028980597096584, 0.11271049728875027, 0.1171729071098151, 0.15183487480308266, 0.10725929301580583, 0.11355320224387633, 0.11750984654383845, 0.9833424689668839, 0.9654388062752698, 0.9650462295588489, 0.9752180238801252, 0.9777533358445616, 0.9926075243690655, 0.9770260779429703, 0.9896002674321291, 0.983901633138145, 0.606975557061285, 0.5156634547615945, 0.5837755942363012, 0.621574103386666, 0.6296580534177081, 0.6148050812267977, 0.6019218780310516, 0.6235849328680237, 0.6678229133126679, 0.22557620908533882, 0.7839059649206297, 0.8841260739400381, 0.17321701013800883, 0.2514621815814657, 0.8513894757080122, 0.7916687145249199, 0.7608605096398121, 0.8595745593017013, 0.12676823505718826, 0.13387539724167075, 0.4009095820146594, 0.12762934925869762, 0.4183289801457517, 0.43758382249047545, 0.44511925336579794, 0.33941978503492654, 0.1324958754344442, 0.37187630083756107, 0.31497161015486996, 0.2713487112167996, 0.13175148268917014, 0.12278842937778023, 0.34134175666956457, 0.3832512501442662, 0.29373917137407934, 0.5526834092103177, 0.07499757792106998, 0.033028783021207486, 0.12015090546269169, 0.05112619649586647, 0.14439085831215448, 0.08772845194281764, 0.2008748841006177, 0.04928704254459826, 0.11316990193349086, 0.10325038768722206, 0.09740302290511504, 0.1575658018961973, 0.2523018856595388, 0.2691067699579177, 0.2845178041791563, 0.5192483212057037, 0.18631575636953035, 0.14329047930071104, 0.21494476404576912, 0.058620860851931855, 0.05001180023498142, 0.09476294023547749, 0.10974958469389151, 0.14290504732295706, 0.2523294778235642, 0.19101399842763822, 0.07156976531758719, 0.2984843679013447, 0.2166503377545992, 0.3105191709301902, 0.35762319304981327, 0.2736671569005069, 0.3426995597142627, 0.2050072336624198, 0.23887188947544924, 0.23892535811074067, 0.6594723262387852, 0.673669847630006, 0.6844728086148513, 0.6241593308994504, 0.6288555770028349, 0.609330732140837, 0.7420212795479343, 0.648101512817916, 0.6293571777625386, 0.10811106375998791, 0.0964301121756369, 0.11272416942100372, 0.086735718170737, 0.08762716979984575, 0.08863345616221663, 0.07876179031338093, 0.08711501959326173, 0.13636899739975106, 0.7288151967493938, 0.24653946563393425, 0.16892088669115002, 0.1968681207119387, 0.321559933105111, 0.5889682095652952, 0.17633759488531164, 0.15436006900017984, 0.17320944187751175, 0.4538199159561146, 0.31181281961323737, 0.397465379030257, 0.3504804025047934, 0.42309067460723626, 0.3652615284811468, 0.5243362021654452, 0.4276947454060872, 0.5401146194457727, 0.2557371274356919, 0.2693477636611349, 0.19784070848552315, 0.30869566167569207, 0.2392425356733886, 0.23236312023037708, 0.3011240271377704, 0.28260298015165075, 0.27246688253099605, 0.19564735911117892, 0.16914847589560977, 0.19014833249503582, 0.20267393413063162, 0.1671794962689681, 0.19071192329076336, 0.17951590564453457, 0.20508383481160652, 0.1986995978087691, 0.24419725714418616, 0.19941785163382397, 0.18476689294996307, 0.23947431045187673, 0.2241324517684904, 0.2001797398005486, 0.2368582268078867, 0.1867700929180025, 0.20287994707968093, 0.8727280756692124, 0.8913286495526961, 0.15413543682634068, 0.9153001509334646, 0.8873429939036275, 0.19805283018761077, 0.0996744172654519, 0.16973365740239732, 0.16787331682078843, 0.08292643316707471, 0.20814120649932688, 0.1279211453614043, 0.35154373171240383, 0.14074905436744645, 0.8023213157910414, 0.2114627793463827, 0.15525174592892077, 0.213694147185007, 0.18214906348298632, 0.1822877546726026, 0.17852481874901982, 0.20436549616565303, 0.17692304829360983, 0.1873540754032671, 0.17939247563762806, 0.1772861508383572, 0.17561340544908766, 0.08124522158221226, 0.08978045675483393, 0.08111778013331272, 0.07709137007412015, 0.08352346779236342, 0.08193626253646868, 0.07110787016824849, 0.07796387241750014, 0.0824075881279116]}, "mutation_prompt": null}
{"id": "4e84e02e-b9a0-435b-8f6a-b4149ac63d08", "solution": "import numpy as np\n\nclass EnhancedAdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.4, 0.8)  # Adjusted F range for better stability\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.6 * (self.num_evaluations / self.budget)  # Enhanced dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.15 / (1 + np.exp(-0.1 * self.num_evaluations))  # Tighter step size for refined search\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        while self.num_evaluations < self.budget:\n            pop_size = 12 + int(8 * (1 - (self.num_evaluations / self.budget)))  # Dynamic pop size\n            population = self.initialize_population(pop_size)\n            fitness = self.evaluate_population(population, func)\n\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        return best_solution", "name": "EnhancedAdaptiveScatterSearch", "description": "Enhanced Adaptive Scatter Search with Dynamic Population Size and Optimized Crossover using Historical Best.", "configspace": "", "generation": 67, "fitness": 0.12592663955691105, "feedback": "The algorithm EnhancedAdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.17.", "error": "", "parent_id": "da66f7cc-08eb-4760-a4b5-d5150faf43c2", "metadata": {"aucs": [0.2005513261352918, 0.190373840628413, 0.20658260488873992, 0.2036531487937585, 0.2050929434286496, 0.19948390280055683, 0.19949154938555924, 0.20934420663462394, 0.1931287491743522, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05266773172614847, 0.051999306117671895, 0.06443051156837787, 0.052438788864573316, 0.050902000656826374, 0.047034098251011014, 0.0692782011229176, 0.04091146607829799, 0.05534028939751623, 0.041065356446235435, 0.037088353974663923, 0.05638208481784246, 0.04536720358579527, 0.03793294653494883, 0.029111491130100475, 0.0389381638660905, 0.030802181466833778, 0.02821934445835561, 0.9305337308643773, 0.20708235242055129, 0.9863193245952043, 0.981897927190681, 0.9492432419691227, 0.9842956319031962, 0.7441205943466472, 0.9310453331178116, 0.7096887454592317, 0.09144367720712032, 0.07545375311278224, 0.07456059244912272, 0.08034084762541882, 0.0722272564413372, 0.08990775200845469, 0.0979803201415338, 0.07957953053717448, 0.07627276690478124, 0.1348116961128939, 0.13198763657081636, 0.11587422099943812, 0.15237075072589978, 0.1436956470542735, 0.1563913963693141, 0.12981112880835466, 0.14738721776026975, 0.15166701390745607, 0.028200061271057564, 0.0036929786735078185, 0.003443551813505419, 9.999999999998899e-05, 0.020525412907998697, 0.018635703919103852, 0.005670992981234302, 9.999999999998899e-05, 0.07074570863413465, 0.010990189348219936, 9.999999999998899e-05, 0.00664100633060194, 9.999999999998899e-05, 0.006042840415657835, 0.01872688458661942, 0.026331008845512982, 9.999999999998899e-05, 0.020612022915099115, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08340786839567971, 0.03390576358123076, 0.0875909997634362, 0.040845281289392354, 0.07810466747376688, 0.028275003257571152, 0.06818193242000248, 0.026433980627933895, 0.04938982468053632, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0034982079930611087, 9.999999999998899e-05, 9.999999999998899e-05, 0.00036198108187091016, 0.023890508123508014, 9.999999999998899e-05, 9.999999999998899e-05, 0.25310230587626714, 0.23098000826466558, 0.2181892536845782, 0.22459001194719663, 0.2462196986379328, 0.23115551357268282, 0.18866212212446576, 0.20316517590398975, 0.21853466818529654, 0.04466923640001663, 0.04698785425152541, 0.070206848189859, 0.06639700962221029, 0.06193356669418759, 0.05116959805543231, 0.04969979046490658, 0.051031109431769583, 0.06263982480422203, 0.12181195700215319, 0.12991732401826994, 0.12991272247843533, 0.12395328157512342, 0.12182992830650696, 0.11956422243756404, 0.13852013109594552, 0.13629805761642744, 0.13884481201649723, 0.17288329652162937, 0.17575451453196533, 0.17284407988333927, 0.17818304422745934, 0.16384669296790122, 0.180392453971849, 0.1682588860884131, 0.18783249195058938, 0.17423072042431154, 0.11190487354760081, 0.10850882007373241, 0.1175073176143584, 0.11837637316562233, 0.11271311978172993, 0.12201725593307633, 0.11712718607722472, 0.1168009355454458, 0.12502497711315386, 0.16293751161447867, 0.15421079730469334, 0.18749547088229612, 0.15715736971391836, 0.16913737229246895, 0.15931945970055317, 0.1568556471150796, 0.15672720534540185, 0.1618605343727697, 0.1516990266135435, 0.1398487349120131, 0.15296598305156273, 0.17516059577659815, 0.152352626847172, 0.15407417847768135, 0.15455978253662728, 0.1531760024303792, 0.14446681718584442, 0.16663229399448487, 0.20343703589792062, 0.15865047668035914, 0.2080068415545019, 0.16310329501711296, 0.15829479685513814, 0.1411659658200226, 0.12552229547560567, 0.1608218401186714, 0.1576943451763997, 0.2001311053198629, 0.2113252037121831, 0.15888027179902542, 0.15396803989310415, 0.15829347200508348, 0.15953529732536265, 0.16869416772010937, 0.23695347119441634, 0.18191518374115367, 0.1855256537438259, 0.1793514518172762, 0.18114995114152976, 0.177670444673649, 0.17224478045349423, 0.18260064936956155, 0.20363067710704852, 0.17073669285200976, 0.0555801050503294, 0.05349645183336704, 0.05673052002070056, 0.05319951592298677, 0.06738436281226223, 0.058353675519549175, 0.05139380054467768, 0.05339896586657, 0.04493659814516193]}, "mutation_prompt": null}
{"id": "d98cc4a4-5e98-452a-8bab-809ed4018e4e", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "da66f7cc-08eb-4760-a4b5-d5150faf43c2", "metadata": {"aucs": [0.8548318385729348, 0.872653021443316, 0.8652536735112889, 0.8960424015381643, 0.8618573997873242, 0.898481482903389, 0.8916460748618078, 0.8395895177912309, 0.8614849515074394, 0.7832347976856403, 0.7812727217138351, 0.761678003804076, 0.766912193125078, 0.7742793114758036, 0.7908259298654678, 0.7865636735794322, 0.7117836086703349, 0.7720212242965693, 0.6617146979727642, 0.14748796721941582, 0.1450861292877016, 0.13851788236753293, 0.16997729346783474, 0.17611175246839772, 0.11249566391301213, 0.12704268620858583, 0.14972834149319225, 0.09276430119672219, 0.16479991406555416, 0.13028980597096584, 0.11271049728875027, 0.1171729071098151, 0.15183487480308266, 0.10725929301580583, 0.11355320224387633, 0.11750984654383845, 0.9833424689668839, 0.9654388062752698, 0.9650462295588489, 0.9752180238801252, 0.9777533358445616, 0.9926075243690655, 0.9770260779429703, 0.9896002674321291, 0.983901633138145, 0.606975557061285, 0.5156634547615945, 0.5837755942363012, 0.621574103386666, 0.6296580534177081, 0.6148050812267977, 0.6019218780310516, 0.6235849328680237, 0.6678229133126679, 0.22557620908533882, 0.7839059649206297, 0.8841260739400381, 0.17321701013800883, 0.2514621815814657, 0.8513894757080122, 0.7916687145249199, 0.7608605096398121, 0.8595745593017013, 0.12676823505718826, 0.13387539724167075, 0.4009095820146594, 0.12762934925869762, 0.4183289801457517, 0.43758382249047545, 0.44511925336579794, 0.33941978503492654, 0.1324958754344442, 0.37187630083756107, 0.31497161015486996, 0.2713487112167996, 0.13175148268917014, 0.12278842937778023, 0.34134175666956457, 0.3832512501442662, 0.29373917137407934, 0.5526834092103177, 0.07499757792106998, 0.033028783021207486, 0.12015090546269169, 0.05112619649586647, 0.14439085831215448, 0.08772845194281764, 0.2008748841006177, 0.04928704254459826, 0.11316990193349086, 0.10325038768722206, 0.09740302290511504, 0.1575658018961973, 0.2523018856595388, 0.2691067699579177, 0.2845178041791563, 0.5192483212057037, 0.18631575636953035, 0.14329047930071104, 0.21494476404576912, 0.058620860851931855, 0.05001180023498142, 0.09476294023547749, 0.10974958469389151, 0.14290504732295706, 0.2523294778235642, 0.19101399842763822, 0.07156976531758719, 0.2984843679013447, 0.2166503377545992, 0.3105191709301902, 0.35762319304981327, 0.2736671569005069, 0.3426995597142627, 0.2050072336624198, 0.23887188947544924, 0.23892535811074067, 0.6594723262387852, 0.673669847630006, 0.6844728086148513, 0.6241593308994504, 0.6288555770028349, 0.609330732140837, 0.7420212795479343, 0.648101512817916, 0.6293571777625386, 0.10811106375998791, 0.0964301121756369, 0.11272416942100372, 0.086735718170737, 0.08762716979984575, 0.08863345616221663, 0.07876179031338093, 0.08711501959326173, 0.13636899739975106, 0.7288151967493938, 0.24653946563393425, 0.16892088669115002, 0.1968681207119387, 0.321559933105111, 0.5889682095652952, 0.17633759488531164, 0.15436006900017984, 0.17320944187751175, 0.4538199159561146, 0.31181281961323737, 0.397465379030257, 0.3504804025047934, 0.42309067460723626, 0.3652615284811468, 0.5243362021654452, 0.4276947454060872, 0.5401146194457727, 0.2557371274356919, 0.2693477636611349, 0.19784070848552315, 0.30869566167569207, 0.2392425356733886, 0.23236312023037708, 0.3011240271377704, 0.28260298015165075, 0.27246688253099605, 0.19564735911117892, 0.16914847589560977, 0.19014833249503582, 0.20267393413063162, 0.1671794962689681, 0.19071192329076336, 0.17951590564453457, 0.20508383481160652, 0.1986995978087691, 0.24419725714418616, 0.19941785163382397, 0.18476689294996307, 0.23947431045187673, 0.2241324517684904, 0.2001797398005486, 0.2368582268078867, 0.1867700929180025, 0.20287994707968093, 0.8727280756692124, 0.8913286495526961, 0.15413543682634068, 0.9153001509334646, 0.8873429939036275, 0.19805283018761077, 0.0996744172654519, 0.16973365740239732, 0.16787331682078843, 0.08292643316707471, 0.20814120649932688, 0.1279211453614043, 0.35154373171240383, 0.14074905436744645, 0.8023213157910414, 0.2114627793463827, 0.15525174592892077, 0.213694147185007, 0.18214906348298632, 0.1822877546726026, 0.17852481874901982, 0.20436549616565303, 0.17692304829360983, 0.1873540754032671, 0.17939247563762806, 0.1772861508383572, 0.17561340544908766, 0.08124522158221226, 0.08978045675483393, 0.08111778013331272, 0.07709137007412015, 0.08352346779236342, 0.08193626253646868, 0.07110787016824849, 0.07796387241750014, 0.0824075881279116]}, "mutation_prompt": null}
{"id": "ef41aeaa-7a89-4556-beec-afc1d60122c8", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "da66f7cc-08eb-4760-a4b5-d5150faf43c2", "metadata": {"aucs": [0.8548318385729348, 0.872653021443316, 0.8652536735112889, 0.8960424015381643, 0.8618573997873242, 0.898481482903389, 0.8916460748618078, 0.8395895177912309, 0.8614849515074394, 0.7832347976856403, 0.7812727217138351, 0.761678003804076, 0.766912193125078, 0.7742793114758036, 0.7908259298654678, 0.7865636735794322, 0.7117836086703349, 0.7720212242965693, 0.6617146979727642, 0.14748796721941582, 0.1450861292877016, 0.13851788236753293, 0.16997729346783474, 0.17611175246839772, 0.11249566391301213, 0.12704268620858583, 0.14972834149319225, 0.09276430119672219, 0.16479991406555416, 0.13028980597096584, 0.11271049728875027, 0.1171729071098151, 0.15183487480308266, 0.10725929301580583, 0.11355320224387633, 0.11750984654383845, 0.9833424689668839, 0.9654388062752698, 0.9650462295588489, 0.9752180238801252, 0.9777533358445616, 0.9926075243690655, 0.9770260779429703, 0.9896002674321291, 0.983901633138145, 0.606975557061285, 0.5156634547615945, 0.5837755942363012, 0.621574103386666, 0.6296580534177081, 0.6148050812267977, 0.6019218780310516, 0.6235849328680237, 0.6678229133126679, 0.22557620908533882, 0.7839059649206297, 0.8841260739400381, 0.17321701013800883, 0.2514621815814657, 0.8513894757080122, 0.7916687145249199, 0.7608605096398121, 0.8595745593017013, 0.12676823505718826, 0.13387539724167075, 0.4009095820146594, 0.12762934925869762, 0.4183289801457517, 0.43758382249047545, 0.44511925336579794, 0.33941978503492654, 0.1324958754344442, 0.37187630083756107, 0.31497161015486996, 0.2713487112167996, 0.13175148268917014, 0.12278842937778023, 0.34134175666956457, 0.3832512501442662, 0.29373917137407934, 0.5526834092103177, 0.07499757792106998, 0.033028783021207486, 0.12015090546269169, 0.05112619649586647, 0.14439085831215448, 0.08772845194281764, 0.2008748841006177, 0.04928704254459826, 0.11316990193349086, 0.10325038768722206, 0.09740302290511504, 0.1575658018961973, 0.2523018856595388, 0.2691067699579177, 0.2845178041791563, 0.5192483212057037, 0.18631575636953035, 0.14329047930071104, 0.21494476404576912, 0.058620860851931855, 0.05001180023498142, 0.09476294023547749, 0.10974958469389151, 0.14290504732295706, 0.2523294778235642, 0.19101399842763822, 0.07156976531758719, 0.2984843679013447, 0.2166503377545992, 0.3105191709301902, 0.35762319304981327, 0.2736671569005069, 0.3426995597142627, 0.2050072336624198, 0.23887188947544924, 0.23892535811074067, 0.6594723262387852, 0.673669847630006, 0.6844728086148513, 0.6241593308994504, 0.6288555770028349, 0.609330732140837, 0.7420212795479343, 0.648101512817916, 0.6293571777625386, 0.10811106375998791, 0.0964301121756369, 0.11272416942100372, 0.086735718170737, 0.08762716979984575, 0.08863345616221663, 0.07876179031338093, 0.08711501959326173, 0.13636899739975106, 0.7288151967493938, 0.24653946563393425, 0.16892088669115002, 0.1968681207119387, 0.321559933105111, 0.5889682095652952, 0.17633759488531164, 0.15436006900017984, 0.17320944187751175, 0.4538199159561146, 0.31181281961323737, 0.397465379030257, 0.3504804025047934, 0.42309067460723626, 0.3652615284811468, 0.5243362021654452, 0.4276947454060872, 0.5401146194457727, 0.2557371274356919, 0.2693477636611349, 0.19784070848552315, 0.30869566167569207, 0.2392425356733886, 0.23236312023037708, 0.3011240271377704, 0.28260298015165075, 0.27246688253099605, 0.19564735911117892, 0.16914847589560977, 0.19014833249503582, 0.20267393413063162, 0.1671794962689681, 0.19071192329076336, 0.17951590564453457, 0.20508383481160652, 0.1986995978087691, 0.24419725714418616, 0.19941785163382397, 0.18476689294996307, 0.23947431045187673, 0.2241324517684904, 0.2001797398005486, 0.2368582268078867, 0.1867700929180025, 0.20287994707968093, 0.8727280756692124, 0.8913286495526961, 0.15413543682634068, 0.9153001509334646, 0.8873429939036275, 0.19805283018761077, 0.0996744172654519, 0.16973365740239732, 0.16787331682078843, 0.08292643316707471, 0.20814120649932688, 0.1279211453614043, 0.35154373171240383, 0.14074905436744645, 0.8023213157910414, 0.2114627793463827, 0.15525174592892077, 0.213694147185007, 0.18214906348298632, 0.1822877546726026, 0.17852481874901982, 0.20436549616565303, 0.17692304829360983, 0.1873540754032671, 0.17939247563762806, 0.1772861508383572, 0.17561340544908766, 0.08124522158221226, 0.08978045675483393, 0.08111778013331272, 0.07709137007412015, 0.08352346779236342, 0.08193626253646868, 0.07110787016824849, 0.07796387241750014, 0.0824075881279116]}, "mutation_prompt": null}
{"id": "290b1897-371f-4815-9636-e62a46214d78", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.4, 0.8)  # Slightly modified F range\n        mutant_vector = np.clip(best + F * (a - c), self.lower_bound, self.upper_bound)  # Revised strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.75 - 0.45 * (self.num_evaluations / self.budget)  # Adjusted crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.8):  # Enhanced Levy flight\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.3 / (1 + np.exp(-0.1 * self.num_evaluations))  # Adjusted step size\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def centralized_selection(self, population, fitness):\n        central_point = np.mean(population, axis=0)\n        distances = np.linalg.norm(population - central_point, axis=1)\n        best_idx = np.argmin(fitness + distances * 0.1)  # Promote central convergence\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_solution, best_fitness = self.centralized_selection(population, fitness)\n        return best_solution", "name": "AdaptiveScatterSearch", "description": "Adaptive Scatter Search with Centralized Selection and Enhanced Levy Flight for Improved Convergence in Multi-modal Landscapes.", "configspace": "", "generation": 70, "fitness": 0.3425600235327232, "feedback": "The algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.28.", "error": "", "parent_id": "da66f7cc-08eb-4760-a4b5-d5150faf43c2", "metadata": {"aucs": [0.9102198900138643, 0.8941835858472882, 0.8836611141723029, 0.8957238225640547, 0.8882894846235013, 0.8793842437555174, 0.9043632607643484, 0.8928565966451378, 0.8856940308457466, 0.8290256621571087, 0.7663621994593978, 0.773639438259506, 0.750235355976353, 0.7905134877466459, 0.72748475466348, 0.7939481769271792, 0.804636205132875, 0.7648579448657492, 0.11579868799577853, 0.13270322156883596, 0.1458394269652986, 0.14305719370436876, 0.14483579712313954, 0.1503757253013842, 0.7192318848829353, 0.7551944333800561, 0.14849582712064435, 0.15056555664520233, 0.12958490026867053, 0.13771338738941452, 0.132732009512323, 0.14015097131208099, 0.0958041279720262, 0.13393892164499344, 0.12222119777088625, 0.1435015477869923, 0.9691522895211343, 0.9526387886171246, 0.9767999631400557, 0.9746231993549298, 0.9749581785313376, 0.9850966368610276, 0.9774538478835463, 0.9850269298517765, 0.9726187501597996, 0.5917851575484927, 0.5903534662077856, 0.5931249378116829, 0.6473339658353707, 0.6643640590165454, 0.6840113683466083, 0.6449036919395802, 0.49782253897604845, 0.6058237740346817, 0.723589690174556, 0.28173253228753015, 0.3788782152375386, 0.7699022063136843, 0.2778452285066455, 0.37381622329009856, 0.7443899265580736, 0.23665611298310774, 0.32875072365452984, 0.30981732689398933, 0.1283325184456957, 0.24784254470699574, 0.20798075641148406, 0.2583064161268448, 0.1322239175064882, 0.49492582623787784, 0.3289886989608639, 0.3137640485971862, 0.2512863164480593, 0.22624640020420217, 0.25896781473353314, 0.12614513798784177, 0.1205555078047178, 0.3963463557860263, 0.40327481807239884, 0.12178031486218266, 0.2731237260668927, 0.1747699370839919, 0.10305398424418233, 0.051258504325825904, 0.06417149079878814, 0.08889790355226501, 0.09231287675200894, 0.12419730502938653, 0.05565047145382107, 0.16477887592440277, 0.15977548149700938, 0.24665077260395174, 0.10521301618926104, 0.1886941314295144, 0.1035023728840675, 0.0317630884043274, 0.149777856897369, 0.203596953551191, 0.21095981731274727, 0.050646910534739575, 0.05801654280535562, 0.13794922973549983, 0.21319182997088137, 0.09215321341023663, 0.08443100951979199, 0.10885254559160329, 0.19547657458651047, 0.08009450255586248, 0.20722626370955077, 0.19404812395935822, 0.2562287828330395, 0.24041977044521412, 0.22349453079507653, 0.30630391814226565, 0.22034309770224714, 0.14946158549447797, 0.27514156028866554, 0.5998840438484732, 0.6136679331801067, 0.5962056650406437, 0.6395992630863223, 0.5551141761812965, 0.6087241189151926, 0.6197609474993051, 0.6368511774001506, 0.5911506472589703, 0.09512811149425338, 0.08576151875597193, 0.11481188367193429, 0.13513685215022875, 0.13108491240191034, 0.12069948198304759, 0.13742232201387627, 0.11831464521452073, 0.1255745617438042, 0.2199845131942887, 0.14022841076942427, 0.23577133169494313, 0.1747958802519215, 0.132137698882145, 0.2086638823322059, 0.2050437320923727, 0.26326233337216887, 0.22095917462868664, 0.433270876450351, 0.28096458149630366, 0.43729042532451834, 0.48552381700052916, 0.3249923707150012, 0.21456842652498853, 0.249356269005634, 0.5569814166712579, 0.500374974446785, 0.29145336516682496, 0.3589957243272416, 0.16366679470055245, 0.22800797942303208, 0.26553187851271765, 0.2710992516183731, 0.23711307737889853, 0.25986445195879426, 0.20534058362649898, 0.22562956917881372, 0.2174863777800451, 0.1851562298252093, 0.209562899374664, 0.20912727023677768, 0.21619015038418965, 0.20744493261946406, 0.20965669216157334, 0.21684411264353598, 0.25037975309669835, 0.20214055561229882, 0.2389765038885734, 0.2521067782395119, 0.688175364146794, 0.2051855349553543, 0.18680431847368295, 0.20598412923845832, 0.21942932056065068, 0.1649444657998147, 0.1550888118143985, 0.1131576262970444, 0.7857179319655077, 0.19878304732920726, 0.8921721366163904, 0.09976493070824877, 0.16889290864426998, 0.1574087307423222, 0.822986624098736, 0.20788578125874857, 0.12799837753656407, 0.7952653665486796, 0.1537085338308729, 0.8395027319906864, 0.10486399907702393, 0.10407449289866, 0.21244683167933454, 0.1747846348765033, 0.18421085087244393, 0.16630898309846165, 0.17627340031297967, 0.17599734178992854, 0.18145393098698803, 0.169351907487579, 0.17523093565318248, 0.18340410164543441, 0.09183826522115801, 0.08478007735713122, 0.08249641900562532, 0.07924947281860917, 0.08337767516298722, 0.09186808224081755, 0.08226587255989504, 0.08687126731108052, 0.08943280673198528]}, "mutation_prompt": null}
{"id": "6521037e-f063-408b-9b12-4ee859398901", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "da66f7cc-08eb-4760-a4b5-d5150faf43c2", "metadata": {"aucs": [0.8548318385729348, 0.872653021443316, 0.8652536735112889, 0.8960424015381643, 0.8618573997873242, 0.898481482903389, 0.8916460748618078, 0.8395895177912309, 0.8614849515074394, 0.7832347976856403, 0.7812727217138351, 0.761678003804076, 0.766912193125078, 0.7742793114758036, 0.7908259298654678, 0.7865636735794322, 0.7117836086703349, 0.7720212242965693, 0.6617146979727642, 0.14748796721941582, 0.1450861292877016, 0.13851788236753293, 0.16997729346783474, 0.17611175246839772, 0.11249566391301213, 0.12704268620858583, 0.14972834149319225, 0.09276430119672219, 0.16479991406555416, 0.13028980597096584, 0.11271049728875027, 0.1171729071098151, 0.15183487480308266, 0.10725929301580583, 0.11355320224387633, 0.11750984654383845, 0.9833424689668839, 0.9654388062752698, 0.9650462295588489, 0.9752180238801252, 0.9777533358445616, 0.9926075243690655, 0.9770260779429703, 0.9896002674321291, 0.983901633138145, 0.606975557061285, 0.5156634547615945, 0.5837755942363012, 0.621574103386666, 0.6296580534177081, 0.6148050812267977, 0.6019218780310516, 0.6235849328680237, 0.6678229133126679, 0.22557620908533882, 0.7839059649206297, 0.8841260739400381, 0.17321701013800883, 0.2514621815814657, 0.8513894757080122, 0.7916687145249199, 0.7608605096398121, 0.8595745593017013, 0.12676823505718826, 0.13387539724167075, 0.4009095820146594, 0.12762934925869762, 0.4183289801457517, 0.43758382249047545, 0.44511925336579794, 0.33941978503492654, 0.1324958754344442, 0.37187630083756107, 0.31497161015486996, 0.2713487112167996, 0.13175148268917014, 0.12278842937778023, 0.34134175666956457, 0.3832512501442662, 0.29373917137407934, 0.5526834092103177, 0.07499757792106998, 0.033028783021207486, 0.12015090546269169, 0.05112619649586647, 0.14439085831215448, 0.08772845194281764, 0.2008748841006177, 0.04928704254459826, 0.11316990193349086, 0.10325038768722206, 0.09740302290511504, 0.1575658018961973, 0.2523018856595388, 0.2691067699579177, 0.2845178041791563, 0.5192483212057037, 0.18631575636953035, 0.14329047930071104, 0.21494476404576912, 0.058620860851931855, 0.05001180023498142, 0.09476294023547749, 0.10974958469389151, 0.14290504732295706, 0.2523294778235642, 0.19101399842763822, 0.07156976531758719, 0.2984843679013447, 0.2166503377545992, 0.3105191709301902, 0.35762319304981327, 0.2736671569005069, 0.3426995597142627, 0.2050072336624198, 0.23887188947544924, 0.23892535811074067, 0.6594723262387852, 0.673669847630006, 0.6844728086148513, 0.6241593308994504, 0.6288555770028349, 0.609330732140837, 0.7420212795479343, 0.648101512817916, 0.6293571777625386, 0.10811106375998791, 0.0964301121756369, 0.11272416942100372, 0.086735718170737, 0.08762716979984575, 0.08863345616221663, 0.07876179031338093, 0.08711501959326173, 0.13636899739975106, 0.7288151967493938, 0.24653946563393425, 0.16892088669115002, 0.1968681207119387, 0.321559933105111, 0.5889682095652952, 0.17633759488531164, 0.15436006900017984, 0.17320944187751175, 0.4538199159561146, 0.31181281961323737, 0.397465379030257, 0.3504804025047934, 0.42309067460723626, 0.3652615284811468, 0.5243362021654452, 0.4276947454060872, 0.5401146194457727, 0.2557371274356919, 0.2693477636611349, 0.19784070848552315, 0.30869566167569207, 0.2392425356733886, 0.23236312023037708, 0.3011240271377704, 0.28260298015165075, 0.27246688253099605, 0.19564735911117892, 0.16914847589560977, 0.19014833249503582, 0.20267393413063162, 0.1671794962689681, 0.19071192329076336, 0.17951590564453457, 0.20508383481160652, 0.1986995978087691, 0.24419725714418616, 0.19941785163382397, 0.18476689294996307, 0.23947431045187673, 0.2241324517684904, 0.2001797398005486, 0.2368582268078867, 0.1867700929180025, 0.20287994707968093, 0.8727280756692124, 0.8913286495526961, 0.15413543682634068, 0.9153001509334646, 0.8873429939036275, 0.19805283018761077, 0.0996744172654519, 0.16973365740239732, 0.16787331682078843, 0.08292643316707471, 0.20814120649932688, 0.1279211453614043, 0.35154373171240383, 0.14074905436744645, 0.8023213157910414, 0.2114627793463827, 0.15525174592892077, 0.213694147185007, 0.18214906348298632, 0.1822877546726026, 0.17852481874901982, 0.20436549616565303, 0.17692304829360983, 0.1873540754032671, 0.17939247563762806, 0.1772861508383572, 0.17561340544908766, 0.08124522158221226, 0.08978045675483393, 0.08111778013331272, 0.07709137007412015, 0.08352346779236342, 0.08193626253646868, 0.07110787016824849, 0.07796387241750014, 0.0824075881279116]}, "mutation_prompt": null}
{"id": "7bc37b01-efb0-426e-8508-36262567956c", "solution": "import numpy as np\n\nclass EnhancedAdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = 0.8 + 0.1 * np.random.rand()  # Adjusted F range for better balance\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.4 * (self.num_evaluations / self.budget)  # Modified crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.15 / (1 + np.exp(-0.1 * self.num_evaluations))  # Slightly reduced step size for precision\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 12 + int(8 * (1 - (self.num_evaluations / self.budget)))  # Fine-tuned population size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "EnhancedAdaptiveScatterSearch", "description": "Enhanced Adaptive Scatter Search with Self-Adjusting Parameters and Reinforced Diversity for Robust Optimization.", "configspace": "", "generation": 72, "fitness": 0.23253955596957046, "feedback": "The algorithm EnhancedAdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "da66f7cc-08eb-4760-a4b5-d5150faf43c2", "metadata": {"aucs": [0.5531524502718467, 0.5710778173182922, 0.5435839850637596, 0.5828207407551453, 0.5702870825917763, 0.6331765395841362, 0.5662325908213347, 0.5952388204995229, 0.5987107707937442, 0.30960068109401473, 0.29148394249252885, 0.2789063495530175, 0.3231068784968333, 0.28701242138390504, 0.26387820426741493, 0.3328851814533168, 0.3757315487886196, 0.3172439547591078, 0.10874748203629092, 0.11806793173257413, 0.10035854790444942, 0.09306211043195944, 0.08296630251221992, 0.10537191697407866, 0.09255881729712823, 0.09760252426597649, 0.10572335722125936, 0.08577949490808423, 0.08361781586855577, 0.07604639220155185, 0.08211361485297497, 0.09432643353439052, 0.07915913830601384, 0.0813132535318899, 0.09096679068382074, 0.0831578702089224, 0.945703700579254, 0.9169952396487976, 0.9495845982189062, 0.8851050640319862, 0.9077339042579446, 0.9278029001094233, 0.9358868845303424, 0.9311238493669781, 0.9274962555348756, 0.2553751235311652, 0.2591874086178634, 0.29619147126383816, 0.2752221889072137, 0.1999451962773069, 0.2620814618888643, 0.2547234575119063, 0.2518479245737689, 0.2261330165744475, 0.38529406961335666, 0.23815432768038414, 0.4232599830732945, 0.45061425950205514, 0.4095478137517583, 0.2761800967321426, 0.3620474076847029, 0.3075280978870628, 0.2512305149651255, 0.1450470203084664, 0.15582342092395263, 0.11833089932637508, 0.1767687646857925, 0.14664137662441368, 0.17520930454425376, 0.1436195115031913, 0.1458383979585065, 0.19260333286723863, 0.12858232208246478, 0.11364584531960686, 0.14560127778993537, 0.1040741458218516, 0.14294853606315117, 0.21616686457307266, 0.14470930084420652, 0.13672945728811103, 0.14130404509358885, 0.08816145570977296, 0.054433207851465104, 0.061368766188830026, 0.08197694443940728, 0.0463867077658251, 0.041923905694181474, 0.05726335020328022, 0.05031417085544976, 0.048317931705559536, 0.1502148944899826, 0.1491536301262273, 0.21941313883665026, 0.18151062646575977, 0.16197748370046938, 0.18722579873662526, 0.1875473114848477, 0.19950459184359404, 0.1852897734044634, 0.007438526442103299, 0.0020247930085506294, 0.0030422101114049305, 0.0007610266703557134, 9.999999999998899e-05, 9.999999999998899e-05, 0.006201747696765958, 0.0036532862264062604, 0.02664427202356401, 0.09604596366552709, 0.09789826188002748, 0.09691531093600769, 0.12633122628614202, 0.14103272734938177, 0.14406486169470367, 0.11033877429915517, 0.11150324405317735, 0.09381520626666118, 0.40730017531978224, 0.4270209696731784, 0.43174436242841774, 0.41068645156237293, 0.4589905086751406, 0.4269029675509075, 0.43097718672270635, 0.40676945367418516, 0.387712386663183, 0.07987484023956115, 0.08555123855791646, 0.09158912359333515, 0.07050560023604613, 0.07982521894893402, 0.0938451275773814, 0.0808105581184555, 0.07772425785183967, 0.08120933489690119, 0.1615416068120492, 0.11618658455401076, 0.1538053856524686, 0.19796304969717715, 0.1417766546050696, 0.12668259884284638, 0.2015218685908886, 0.17327443115632346, 0.15962406522886485, 0.2557831311015245, 0.26178395215970174, 0.24062368410564716, 0.2559738069216273, 0.24835335146039683, 0.25401735532919734, 0.2748122009636754, 0.27958082820609187, 0.2842135482631408, 0.17223770684900863, 0.1895618706837765, 0.190753080906772, 0.20203635217202875, 0.18310282815019407, 0.17423512192273105, 0.1904776661594837, 0.1832536860268923, 0.1709505811096489, 0.17124759442349802, 0.16557386900932525, 0.1733728319538781, 0.1794942694892323, 0.16706324603992795, 0.1877519184342985, 0.16743692715178515, 0.18170648661067368, 0.16231085032388215, 0.1742081560329778, 0.1818501016015367, 0.18011924633945053, 0.1762203148709952, 0.17396886574447523, 0.1707607352302133, 0.17409811716603074, 0.1716030194964664, 0.16586027320690377, 0.6731614330409554, 0.48093870201528954, 0.15554932804611232, 0.16928531317193063, 0.18115892548042367, 0.1799948759490495, 0.3765788050828335, 0.33785753031469434, 0.6503054991836272, 0.1997157629249945, 0.18994103255170258, 0.15164525576098908, 0.1863181443151697, 0.24876132411981577, 0.3337819446771414, 0.20749336297557208, 0.46579144031154396, 0.40891049176376715, 0.16736192456879617, 0.18309658709016152, 0.17476688352252134, 0.1809733941768471, 0.18555242686975482, 0.19035624614678381, 0.17474025339341848, 0.19094444976365343, 0.2109937608801804, 0.0690518662505537, 0.05905302938733914, 0.06577181589475056, 0.06842547671732391, 0.0787760061952063, 0.06213491273281979, 0.07558364588706623, 0.07189189792819672, 0.06346183478347156]}, "mutation_prompt": null}
{"id": "0e0faa91-b5b9-45f6-b3da-732eb29bcc84", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "da66f7cc-08eb-4760-a4b5-d5150faf43c2", "metadata": {"aucs": [0.8548318385729348, 0.872653021443316, 0.8652536735112889, 0.8960424015381643, 0.8618573997873242, 0.898481482903389, 0.8916460748618078, 0.8395895177912309, 0.8614849515074394, 0.7832347976856403, 0.7812727217138351, 0.761678003804076, 0.766912193125078, 0.7742793114758036, 0.7908259298654678, 0.7865636735794322, 0.7117836086703349, 0.7720212242965693, 0.6617146979727642, 0.14748796721941582, 0.1450861292877016, 0.13851788236753293, 0.16997729346783474, 0.17611175246839772, 0.11249566391301213, 0.12704268620858583, 0.14972834149319225, 0.09276430119672219, 0.16479991406555416, 0.13028980597096584, 0.11271049728875027, 0.1171729071098151, 0.15183487480308266, 0.10725929301580583, 0.11355320224387633, 0.11750984654383845, 0.9833424689668839, 0.9654388062752698, 0.9650462295588489, 0.9752180238801252, 0.9777533358445616, 0.9926075243690655, 0.9770260779429703, 0.9896002674321291, 0.983901633138145, 0.606975557061285, 0.5156634547615945, 0.5837755942363012, 0.621574103386666, 0.6296580534177081, 0.6148050812267977, 0.6019218780310516, 0.6235849328680237, 0.6678229133126679, 0.22557620908533882, 0.7839059649206297, 0.8841260739400381, 0.17321701013800883, 0.2514621815814657, 0.8513894757080122, 0.7916687145249199, 0.7608605096398121, 0.8595745593017013, 0.12676823505718826, 0.13387539724167075, 0.4009095820146594, 0.12762934925869762, 0.4183289801457517, 0.43758382249047545, 0.44511925336579794, 0.33941978503492654, 0.1324958754344442, 0.37187630083756107, 0.31497161015486996, 0.2713487112167996, 0.13175148268917014, 0.12278842937778023, 0.34134175666956457, 0.3832512501442662, 0.29373917137407934, 0.5526834092103177, 0.07499757792106998, 0.033028783021207486, 0.12015090546269169, 0.05112619649586647, 0.14439085831215448, 0.08772845194281764, 0.2008748841006177, 0.04928704254459826, 0.11316990193349086, 0.10325038768722206, 0.09740302290511504, 0.1575658018961973, 0.2523018856595388, 0.2691067699579177, 0.2845178041791563, 0.5192483212057037, 0.18631575636953035, 0.14329047930071104, 0.21494476404576912, 0.058620860851931855, 0.05001180023498142, 0.09476294023547749, 0.10974958469389151, 0.14290504732295706, 0.2523294778235642, 0.19101399842763822, 0.07156976531758719, 0.2984843679013447, 0.2166503377545992, 0.3105191709301902, 0.35762319304981327, 0.2736671569005069, 0.3426995597142627, 0.2050072336624198, 0.23887188947544924, 0.23892535811074067, 0.6594723262387852, 0.673669847630006, 0.6844728086148513, 0.6241593308994504, 0.6288555770028349, 0.609330732140837, 0.7420212795479343, 0.648101512817916, 0.6293571777625386, 0.10811106375998791, 0.0964301121756369, 0.11272416942100372, 0.086735718170737, 0.08762716979984575, 0.08863345616221663, 0.07876179031338093, 0.08711501959326173, 0.13636899739975106, 0.7288151967493938, 0.24653946563393425, 0.16892088669115002, 0.1968681207119387, 0.321559933105111, 0.5889682095652952, 0.17633759488531164, 0.15436006900017984, 0.17320944187751175, 0.4538199159561146, 0.31181281961323737, 0.397465379030257, 0.3504804025047934, 0.42309067460723626, 0.3652615284811468, 0.5243362021654452, 0.4276947454060872, 0.5401146194457727, 0.2557371274356919, 0.2693477636611349, 0.19784070848552315, 0.30869566167569207, 0.2392425356733886, 0.23236312023037708, 0.3011240271377704, 0.28260298015165075, 0.27246688253099605, 0.19564735911117892, 0.16914847589560977, 0.19014833249503582, 0.20267393413063162, 0.1671794962689681, 0.19071192329076336, 0.17951590564453457, 0.20508383481160652, 0.1986995978087691, 0.24419725714418616, 0.19941785163382397, 0.18476689294996307, 0.23947431045187673, 0.2241324517684904, 0.2001797398005486, 0.2368582268078867, 0.1867700929180025, 0.20287994707968093, 0.8727280756692124, 0.8913286495526961, 0.15413543682634068, 0.9153001509334646, 0.8873429939036275, 0.19805283018761077, 0.0996744172654519, 0.16973365740239732, 0.16787331682078843, 0.08292643316707471, 0.20814120649932688, 0.1279211453614043, 0.35154373171240383, 0.14074905436744645, 0.8023213157910414, 0.2114627793463827, 0.15525174592892077, 0.213694147185007, 0.18214906348298632, 0.1822877546726026, 0.17852481874901982, 0.20436549616565303, 0.17692304829360983, 0.1873540754032671, 0.17939247563762806, 0.1772861508383572, 0.17561340544908766, 0.08124522158221226, 0.08978045675483393, 0.08111778013331272, 0.07709137007412015, 0.08352346779236342, 0.08193626253646868, 0.07110787016824849, 0.07796387241750014, 0.0824075881279116]}, "mutation_prompt": null}
{"id": "82b3263f-0864-4d76-b636-3d8caa56d8dd", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "da66f7cc-08eb-4760-a4b5-d5150faf43c2", "metadata": {"aucs": [0.8548318385729348, 0.872653021443316, 0.8652536735112889, 0.8960424015381643, 0.8618573997873242, 0.898481482903389, 0.8916460748618078, 0.8395895177912309, 0.8614849515074394, 0.7832347976856403, 0.7812727217138351, 0.761678003804076, 0.766912193125078, 0.7742793114758036, 0.7908259298654678, 0.7865636735794322, 0.7117836086703349, 0.7720212242965693, 0.6617146979727642, 0.14748796721941582, 0.1450861292877016, 0.13851788236753293, 0.16997729346783474, 0.17611175246839772, 0.11249566391301213, 0.12704268620858583, 0.14972834149319225, 0.09276430119672219, 0.16479991406555416, 0.13028980597096584, 0.11271049728875027, 0.1171729071098151, 0.15183487480308266, 0.10725929301580583, 0.11355320224387633, 0.11750984654383845, 0.9833424689668839, 0.9654388062752698, 0.9650462295588489, 0.9752180238801252, 0.9777533358445616, 0.9926075243690655, 0.9770260779429703, 0.9896002674321291, 0.983901633138145, 0.606975557061285, 0.5156634547615945, 0.5837755942363012, 0.621574103386666, 0.6296580534177081, 0.6148050812267977, 0.6019218780310516, 0.6235849328680237, 0.6678229133126679, 0.22557620908533882, 0.7839059649206297, 0.8841260739400381, 0.17321701013800883, 0.2514621815814657, 0.8513894757080122, 0.7916687145249199, 0.7608605096398121, 0.8595745593017013, 0.12676823505718826, 0.13387539724167075, 0.4009095820146594, 0.12762934925869762, 0.4183289801457517, 0.43758382249047545, 0.44511925336579794, 0.33941978503492654, 0.1324958754344442, 0.37187630083756107, 0.31497161015486996, 0.2713487112167996, 0.13175148268917014, 0.12278842937778023, 0.34134175666956457, 0.3832512501442662, 0.29373917137407934, 0.5526834092103177, 0.07499757792106998, 0.033028783021207486, 0.12015090546269169, 0.05112619649586647, 0.14439085831215448, 0.08772845194281764, 0.2008748841006177, 0.04928704254459826, 0.11316990193349086, 0.10325038768722206, 0.09740302290511504, 0.1575658018961973, 0.2523018856595388, 0.2691067699579177, 0.2845178041791563, 0.5192483212057037, 0.18631575636953035, 0.14329047930071104, 0.21494476404576912, 0.058620860851931855, 0.05001180023498142, 0.09476294023547749, 0.10974958469389151, 0.14290504732295706, 0.2523294778235642, 0.19101399842763822, 0.07156976531758719, 0.2984843679013447, 0.2166503377545992, 0.3105191709301902, 0.35762319304981327, 0.2736671569005069, 0.3426995597142627, 0.2050072336624198, 0.23887188947544924, 0.23892535811074067, 0.6594723262387852, 0.673669847630006, 0.6844728086148513, 0.6241593308994504, 0.6288555770028349, 0.609330732140837, 0.7420212795479343, 0.648101512817916, 0.6293571777625386, 0.10811106375998791, 0.0964301121756369, 0.11272416942100372, 0.086735718170737, 0.08762716979984575, 0.08863345616221663, 0.07876179031338093, 0.08711501959326173, 0.13636899739975106, 0.7288151967493938, 0.24653946563393425, 0.16892088669115002, 0.1968681207119387, 0.321559933105111, 0.5889682095652952, 0.17633759488531164, 0.15436006900017984, 0.17320944187751175, 0.4538199159561146, 0.31181281961323737, 0.397465379030257, 0.3504804025047934, 0.42309067460723626, 0.3652615284811468, 0.5243362021654452, 0.4276947454060872, 0.5401146194457727, 0.2557371274356919, 0.2693477636611349, 0.19784070848552315, 0.30869566167569207, 0.2392425356733886, 0.23236312023037708, 0.3011240271377704, 0.28260298015165075, 0.27246688253099605, 0.19564735911117892, 0.16914847589560977, 0.19014833249503582, 0.20267393413063162, 0.1671794962689681, 0.19071192329076336, 0.17951590564453457, 0.20508383481160652, 0.1986995978087691, 0.24419725714418616, 0.19941785163382397, 0.18476689294996307, 0.23947431045187673, 0.2241324517684904, 0.2001797398005486, 0.2368582268078867, 0.1867700929180025, 0.20287994707968093, 0.8727280756692124, 0.8913286495526961, 0.15413543682634068, 0.9153001509334646, 0.8873429939036275, 0.19805283018761077, 0.0996744172654519, 0.16973365740239732, 0.16787331682078843, 0.08292643316707471, 0.20814120649932688, 0.1279211453614043, 0.35154373171240383, 0.14074905436744645, 0.8023213157910414, 0.2114627793463827, 0.15525174592892077, 0.213694147185007, 0.18214906348298632, 0.1822877546726026, 0.17852481874901982, 0.20436549616565303, 0.17692304829360983, 0.1873540754032671, 0.17939247563762806, 0.1772861508383572, 0.17561340544908766, 0.08124522158221226, 0.08978045675483393, 0.08111778013331272, 0.07709137007412015, 0.08352346779236342, 0.08193626253646868, 0.07110787016824849, 0.07796387241750014, 0.0824075881279116]}, "mutation_prompt": null}
{"id": "f089e2ac-dab2-4478-8fbf-c3f4dbd6fc9c", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.4, 0.9)  # Modified F range for diverse strategies\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.8 - 0.4 * (self.num_evaluations / self.budget)  # Tuned crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.3):  # Adjusted Levy flight parameter\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.25 / (1 + np.exp(-0.1 * self.num_evaluations))  # Adjusted step size\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):  # Added dynamic strategy decision\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 12 + int(8 * (1 - (self.num_evaluations / self.budget)))  # Adjusted population size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Adaptive Scatter Search with Enhanced Exploration using Dynamic Strategy Selection for Diverse and Efficient Search.", "configspace": "", "generation": 75, "fitness": 0.3471379840052921, "feedback": "The algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.28.", "error": "", "parent_id": "da66f7cc-08eb-4760-a4b5-d5150faf43c2", "metadata": {"aucs": [0.8853626046754359, 0.9060389545494008, 0.8939958447102992, 0.8818027746518625, 0.8903279893752495, 0.8892906157367002, 0.8892192546425576, 0.8862672590720335, 0.8987523274140775, 0.7986375406311597, 0.7843054173097257, 0.04268801477354878, 0.7736472229424145, 0.7882709984913963, 0.7986853389589914, 0.7601239060616868, 0.7966271103507931, 0.7802137720669291, 0.15201777431318864, 0.1452940674741714, 0.14073055383495614, 0.10477201004453951, 0.1705681705965808, 0.11948462831417694, 0.13593112514503303, 0.6126834843047168, 0.17017718631276124, 0.14507820138578376, 0.1387563195319943, 0.17198403619098968, 0.13231894848650827, 0.0736220196159113, 0.0951090370359089, 0.13994996571131813, 0.12723051969108368, 0.13293865527934945, 0.9878181715041829, 0.9780183751504682, 0.9683417847921937, 0.9575612924000793, 0.9773658312888073, 0.9887668497308292, 0.9872657135769283, 0.9827307694624804, 0.9839716540455206, 0.6602269344593642, 0.6166093315893367, 0.6697540001582549, 0.5998432134156146, 0.682917238015825, 0.6667924340961234, 0.6044813525942195, 0.606913401998221, 0.6562675016015349, 0.36476177933179976, 0.7880370493516431, 0.8281826059337204, 0.20461076424414537, 0.21239982165709448, 0.26053832267293464, 0.30876136754657946, 0.7138145837902617, 0.22286130127842585, 0.32331617263700774, 0.31385602592265205, 0.2957200356515275, 0.6686978573426315, 0.13324910605683604, 0.35802297393994054, 0.3457679219535037, 0.7300733238340755, 0.4838013812191042, 0.1334538381342325, 0.1336442696073129, 0.16740590088860696, 0.3009406674700402, 0.41964250581706575, 0.6339291825844713, 0.13170246320094026, 0.1957193605099531, 0.2936375494517032, 0.06042563590370009, 9.999999999998899e-05, 0.04276766419425837, 0.0908638551483365, 0.04124238956879889, 0.06534022907891446, 0.010073759164980989, 0.026470484485223045, 0.1372942747553847, 0.08169661194624245, 0.11040117084710654, 0.16066524777115176, 0.18495698994094634, 0.013008081184797127, 0.20497896429944573, 0.10840733860538987, 0.18242358532535152, 0.21785465374669477, 0.049733072384811394, 0.057980172211577474, 0.25268437939053456, 0.26899476629766395, 0.10704827655724514, 0.11005772277537218, 0.07220715298925151, 0.1001582936975054, 0.10072349027887906, 0.20955388632486838, 0.2969696405626383, 0.30687871246378096, 0.20150444668287304, 0.3009358622879923, 0.2254826102278744, 0.2359046975576956, 0.21600358333889713, 0.16717171776697892, 0.6470116154198547, 0.6525384304625261, 0.7172075310204962, 0.6396292114531177, 0.5681036806562132, 0.5718543899520321, 0.5971331629804433, 0.6171399656587915, 0.7115015945654943, 0.1114013563121875, 0.0835599427970537, 0.07964272095246161, 0.13327381018621598, 0.11179748819805413, 0.1347611077377725, 0.10122612399438458, 0.10095105000115878, 0.1067607685968609, 0.2721489192597649, 0.1532735019072352, 0.15202932947682823, 0.19168525476281917, 0.2006359704248155, 0.21569525500592968, 0.26920036209289233, 0.17103978223791905, 0.16457557387204014, 0.4351402726412944, 0.37758595858785515, 0.3747764764087441, 0.2572504685874283, 0.3534835637706929, 0.42553862210746696, 0.32926138265821037, 0.48820087083311015, 0.36031963794516486, 0.2841062480415141, 0.23064590591891565, 0.20236596900703185, 0.3459876673304294, 0.28615771270833745, 0.3004133494100809, 0.34101507000631537, 0.3536564024557982, 0.23168525918574367, 0.22162819759614094, 0.2191236263756957, 0.1935237784173196, 0.19956363688272516, 0.2037519368172035, 0.18474354455847197, 0.20697759648985525, 0.2019451590854614, 0.21062111214848378, 0.19447488459138418, 0.18581450777958464, 0.19516871787646595, 0.22153497279324808, 0.21386162202463488, 0.24294189822442858, 0.7950936771977046, 0.6258957284255278, 0.6893593211186577, 0.16531366445406148, 0.8810745553258135, 0.11316743586270328, 0.8503449812375444, 0.198827555978085, 0.19460654887478257, 0.12423425307808644, 0.1689798573889586, 0.16738545235491398, 0.9026327240969891, 0.16722162708045185, 0.15106607810763728, 0.7624741336654502, 0.1538001952824103, 0.774928975873095, 0.1049763226384468, 0.10484450308091742, 0.21352034366036587, 0.1809587090035386, 0.22019305473487194, 0.17092153331923177, 0.1685306203351824, 0.16886090381420382, 0.17313483840106147, 0.17102295452606253, 0.17768504344414526, 0.17348745586368475, 0.08163071969972224, 0.08285895113466135, 0.08377018139218184, 0.07998794526479158, 0.07231783094230737, 0.08448256671012022, 0.07349630357150638, 0.07676423584783754, 0.06884778175019657]}, "mutation_prompt": null}
{"id": "2199e56e-f6df-47bb-8931-e4213467cce9", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "da66f7cc-08eb-4760-a4b5-d5150faf43c2", "metadata": {"aucs": [0.8548318385729348, 0.872653021443316, 0.8652536735112889, 0.8960424015381643, 0.8618573997873242, 0.898481482903389, 0.8916460748618078, 0.8395895177912309, 0.8614849515074394, 0.7832347976856403, 0.7812727217138351, 0.761678003804076, 0.766912193125078, 0.7742793114758036, 0.7908259298654678, 0.7865636735794322, 0.7117836086703349, 0.7720212242965693, 0.6617146979727642, 0.14748796721941582, 0.1450861292877016, 0.13851788236753293, 0.16997729346783474, 0.17611175246839772, 0.11249566391301213, 0.12704268620858583, 0.14972834149319225, 0.09276430119672219, 0.16479991406555416, 0.13028980597096584, 0.11271049728875027, 0.1171729071098151, 0.15183487480308266, 0.10725929301580583, 0.11355320224387633, 0.11750984654383845, 0.9833424689668839, 0.9654388062752698, 0.9650462295588489, 0.9752180238801252, 0.9777533358445616, 0.9926075243690655, 0.9770260779429703, 0.9896002674321291, 0.983901633138145, 0.606975557061285, 0.5156634547615945, 0.5837755942363012, 0.621574103386666, 0.6296580534177081, 0.6148050812267977, 0.6019218780310516, 0.6235849328680237, 0.6678229133126679, 0.22557620908533882, 0.7839059649206297, 0.8841260739400381, 0.17321701013800883, 0.2514621815814657, 0.8513894757080122, 0.7916687145249199, 0.7608605096398121, 0.8595745593017013, 0.12676823505718826, 0.13387539724167075, 0.4009095820146594, 0.12762934925869762, 0.4183289801457517, 0.43758382249047545, 0.44511925336579794, 0.33941978503492654, 0.1324958754344442, 0.37187630083756107, 0.31497161015486996, 0.2713487112167996, 0.13175148268917014, 0.12278842937778023, 0.34134175666956457, 0.3832512501442662, 0.29373917137407934, 0.5526834092103177, 0.07499757792106998, 0.033028783021207486, 0.12015090546269169, 0.05112619649586647, 0.14439085831215448, 0.08772845194281764, 0.2008748841006177, 0.04928704254459826, 0.11316990193349086, 0.10325038768722206, 0.09740302290511504, 0.1575658018961973, 0.2523018856595388, 0.2691067699579177, 0.2845178041791563, 0.5192483212057037, 0.18631575636953035, 0.14329047930071104, 0.21494476404576912, 0.058620860851931855, 0.05001180023498142, 0.09476294023547749, 0.10974958469389151, 0.14290504732295706, 0.2523294778235642, 0.19101399842763822, 0.07156976531758719, 0.2984843679013447, 0.2166503377545992, 0.3105191709301902, 0.35762319304981327, 0.2736671569005069, 0.3426995597142627, 0.2050072336624198, 0.23887188947544924, 0.23892535811074067, 0.6594723262387852, 0.673669847630006, 0.6844728086148513, 0.6241593308994504, 0.6288555770028349, 0.609330732140837, 0.7420212795479343, 0.648101512817916, 0.6293571777625386, 0.10811106375998791, 0.0964301121756369, 0.11272416942100372, 0.086735718170737, 0.08762716979984575, 0.08863345616221663, 0.07876179031338093, 0.08711501959326173, 0.13636899739975106, 0.7288151967493938, 0.24653946563393425, 0.16892088669115002, 0.1968681207119387, 0.321559933105111, 0.5889682095652952, 0.17633759488531164, 0.15436006900017984, 0.17320944187751175, 0.4538199159561146, 0.31181281961323737, 0.397465379030257, 0.3504804025047934, 0.42309067460723626, 0.3652615284811468, 0.5243362021654452, 0.4276947454060872, 0.5401146194457727, 0.2557371274356919, 0.2693477636611349, 0.19784070848552315, 0.30869566167569207, 0.2392425356733886, 0.23236312023037708, 0.3011240271377704, 0.28260298015165075, 0.27246688253099605, 0.19564735911117892, 0.16914847589560977, 0.19014833249503582, 0.20267393413063162, 0.1671794962689681, 0.19071192329076336, 0.17951590564453457, 0.20508383481160652, 0.1986995978087691, 0.24419725714418616, 0.19941785163382397, 0.18476689294996307, 0.23947431045187673, 0.2241324517684904, 0.2001797398005486, 0.2368582268078867, 0.1867700929180025, 0.20287994707968093, 0.8727280756692124, 0.8913286495526961, 0.15413543682634068, 0.9153001509334646, 0.8873429939036275, 0.19805283018761077, 0.0996744172654519, 0.16973365740239732, 0.16787331682078843, 0.08292643316707471, 0.20814120649932688, 0.1279211453614043, 0.35154373171240383, 0.14074905436744645, 0.8023213157910414, 0.2114627793463827, 0.15525174592892077, 0.213694147185007, 0.18214906348298632, 0.1822877546726026, 0.17852481874901982, 0.20436549616565303, 0.17692304829360983, 0.1873540754032671, 0.17939247563762806, 0.1772861508383572, 0.17561340544908766, 0.08124522158221226, 0.08978045675483393, 0.08111778013331272, 0.07709137007412015, 0.08352346779236342, 0.08193626253646868, 0.07110787016824849, 0.07796387241750014, 0.0824075881279116]}, "mutation_prompt": null}
{"id": "2c3bcc59-82f3-4875-8336-6afadc0dfc3f", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "da66f7cc-08eb-4760-a4b5-d5150faf43c2", "metadata": {"aucs": [0.8548318385729348, 0.872653021443316, 0.8652536735112889, 0.8960424015381643, 0.8618573997873242, 0.898481482903389, 0.8916460748618078, 0.8395895177912309, 0.8614849515074394, 0.7832347976856403, 0.7812727217138351, 0.761678003804076, 0.766912193125078, 0.7742793114758036, 0.7908259298654678, 0.7865636735794322, 0.7117836086703349, 0.7720212242965693, 0.6617146979727642, 0.14748796721941582, 0.1450861292877016, 0.13851788236753293, 0.16997729346783474, 0.17611175246839772, 0.11249566391301213, 0.12704268620858583, 0.14972834149319225, 0.09276430119672219, 0.16479991406555416, 0.13028980597096584, 0.11271049728875027, 0.1171729071098151, 0.15183487480308266, 0.10725929301580583, 0.11355320224387633, 0.11750984654383845, 0.9833424689668839, 0.9654388062752698, 0.9650462295588489, 0.9752180238801252, 0.9777533358445616, 0.9926075243690655, 0.9770260779429703, 0.9896002674321291, 0.983901633138145, 0.606975557061285, 0.5156634547615945, 0.5837755942363012, 0.621574103386666, 0.6296580534177081, 0.6148050812267977, 0.6019218780310516, 0.6235849328680237, 0.6678229133126679, 0.22557620908533882, 0.7839059649206297, 0.8841260739400381, 0.17321701013800883, 0.2514621815814657, 0.8513894757080122, 0.7916687145249199, 0.7608605096398121, 0.8595745593017013, 0.12676823505718826, 0.13387539724167075, 0.4009095820146594, 0.12762934925869762, 0.4183289801457517, 0.43758382249047545, 0.44511925336579794, 0.33941978503492654, 0.1324958754344442, 0.37187630083756107, 0.31497161015486996, 0.2713487112167996, 0.13175148268917014, 0.12278842937778023, 0.34134175666956457, 0.3832512501442662, 0.29373917137407934, 0.5526834092103177, 0.07499757792106998, 0.033028783021207486, 0.12015090546269169, 0.05112619649586647, 0.14439085831215448, 0.08772845194281764, 0.2008748841006177, 0.04928704254459826, 0.11316990193349086, 0.10325038768722206, 0.09740302290511504, 0.1575658018961973, 0.2523018856595388, 0.2691067699579177, 0.2845178041791563, 0.5192483212057037, 0.18631575636953035, 0.14329047930071104, 0.21494476404576912, 0.058620860851931855, 0.05001180023498142, 0.09476294023547749, 0.10974958469389151, 0.14290504732295706, 0.2523294778235642, 0.19101399842763822, 0.07156976531758719, 0.2984843679013447, 0.2166503377545992, 0.3105191709301902, 0.35762319304981327, 0.2736671569005069, 0.3426995597142627, 0.2050072336624198, 0.23887188947544924, 0.23892535811074067, 0.6594723262387852, 0.673669847630006, 0.6844728086148513, 0.6241593308994504, 0.6288555770028349, 0.609330732140837, 0.7420212795479343, 0.648101512817916, 0.6293571777625386, 0.10811106375998791, 0.0964301121756369, 0.11272416942100372, 0.086735718170737, 0.08762716979984575, 0.08863345616221663, 0.07876179031338093, 0.08711501959326173, 0.13636899739975106, 0.7288151967493938, 0.24653946563393425, 0.16892088669115002, 0.1968681207119387, 0.321559933105111, 0.5889682095652952, 0.17633759488531164, 0.15436006900017984, 0.17320944187751175, 0.4538199159561146, 0.31181281961323737, 0.397465379030257, 0.3504804025047934, 0.42309067460723626, 0.3652615284811468, 0.5243362021654452, 0.4276947454060872, 0.5401146194457727, 0.2557371274356919, 0.2693477636611349, 0.19784070848552315, 0.30869566167569207, 0.2392425356733886, 0.23236312023037708, 0.3011240271377704, 0.28260298015165075, 0.27246688253099605, 0.19564735911117892, 0.16914847589560977, 0.19014833249503582, 0.20267393413063162, 0.1671794962689681, 0.19071192329076336, 0.17951590564453457, 0.20508383481160652, 0.1986995978087691, 0.24419725714418616, 0.19941785163382397, 0.18476689294996307, 0.23947431045187673, 0.2241324517684904, 0.2001797398005486, 0.2368582268078867, 0.1867700929180025, 0.20287994707968093, 0.8727280756692124, 0.8913286495526961, 0.15413543682634068, 0.9153001509334646, 0.8873429939036275, 0.19805283018761077, 0.0996744172654519, 0.16973365740239732, 0.16787331682078843, 0.08292643316707471, 0.20814120649932688, 0.1279211453614043, 0.35154373171240383, 0.14074905436744645, 0.8023213157910414, 0.2114627793463827, 0.15525174592892077, 0.213694147185007, 0.18214906348298632, 0.1822877546726026, 0.17852481874901982, 0.20436549616565303, 0.17692304829360983, 0.1873540754032671, 0.17939247563762806, 0.1772861508383572, 0.17561340544908766, 0.08124522158221226, 0.08978045675483393, 0.08111778013331272, 0.07709137007412015, 0.08352346779236342, 0.08193626253646868, 0.07110787016824849, 0.07796387241750014, 0.0824075881279116]}, "mutation_prompt": null}
{"id": "3e1a7127-23cc-48c9-a0ac-c8f13ddae4f2", "solution": "import numpy as np\n\nclass EnhancedAdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.4, 1.0)  # Adjusted F range for more exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (c - a), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.6 + 0.4 * (1 - (self.num_evaluations / self.budget))  # Dynamic adjustment\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.3 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 20 + int(10 * (np.sin(self.num_evaluations / self.budget * np.pi)))  # Dynamic size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "EnhancedAdaptiveScatterSearch", "description": "Enhanced Adaptive Scatter Search with Dynamic Population Size Adjustment and Improved Selection for Robust Global Optimization.", "configspace": "", "generation": 78, "fitness": 0.3343602838492996, "feedback": "The algorithm EnhancedAdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.27.", "error": "", "parent_id": "da66f7cc-08eb-4760-a4b5-d5150faf43c2", "metadata": {"aucs": [0.9068313364792776, 0.8476087217558206, 0.8223403933161764, 0.861874052769632, 0.8637231588726707, 0.8817291641005043, 0.8496915470163605, 0.8727897956351963, 0.8721293099378932, 0.6032254507164903, 0.036690350706208075, 0.6791266383589851, 0.6659683566629476, 0.3649875936279172, 0.7486663515289433, 0.671032768540158, 0.7236380521339227, 0.5950515312578324, 0.11791581532881423, 0.13030230414615707, 0.130471262544958, 0.13624579141458837, 0.13013794248399646, 0.07022623189887034, 0.17705826313419526, 0.10872407838896248, 0.15119245690749372, 0.10787055830235914, 0.10962593656411879, 0.09429726209156764, 0.09823361938481845, 0.07869058513442528, 0.07803880607386271, 0.10844700319887324, 0.09848501991789016, 0.10620783363469177, 0.994512480288851, 0.9695961977530039, 0.992002012371052, 0.9842234574478858, 0.98605348210977, 0.9728661388149503, 0.9827000679173282, 0.9855673928334274, 0.9937642840038637, 0.673902650663337, 0.676084085326284, 0.6749290664994646, 0.5966888300973521, 0.7060897951365182, 0.5492541171128534, 0.5214358848066385, 0.6729250370217037, 0.6518232450684623, 0.5450524541051833, 0.26727381366289005, 0.39434533070786915, 0.2798015701133787, 0.909094332121002, 0.2114102113050058, 0.8452934768042186, 0.36450074565552404, 0.5173032651089003, 0.4893987887272122, 0.47773501206099367, 0.26185612221515686, 0.13314710056828682, 0.13322892574392553, 0.5634249798044899, 0.29382426743056667, 0.1330645267191659, 0.38060113246684135, 0.6868625134949076, 0.10450082187720633, 0.3264919911232289, 0.44128576543056564, 0.1309277319021529, 0.48237867432058223, 0.3027628149135546, 0.2471835044864168, 0.6086595716616585, 0.08709334368559829, 0.0763561834581411, 0.08868795259082995, 0.05812648323199898, 0.039523112463723864, 0.3417345826425604, 0.016393309997086325, 0.07883875269096785, 0.1641660018085881, 0.1170128290876089, 0.18983277866277126, 0.1461163095502529, 0.15601789716679737, 0.028158804284163508, 0.2397380771114015, 0.13935291811502226, 0.21916590938017222, 0.2396795756146778, 0.08985177268799649, 0.29418755121978435, 0.1274868306284621, 0.07671212885622647, 0.30186824923443334, 0.21671716649562978, 0.23824577519752788, 0.11201565119567147, 0.10582499633911979, 0.10350524085155632, 0.1701966959837624, 0.2707370651784825, 0.3720479983731223, 0.2568283716432981, 0.2782839037242276, 0.19241421791037994, 0.17630782412440804, 0.13127092404151985, 0.5458664462534082, 0.5939984234813811, 0.6006055972427042, 0.633792268855486, 0.6986726475450429, 0.5616252574490395, 0.5375273866586012, 0.7000021314881799, 0.5818087745692824, 0.13788577201219976, 0.0816130721973346, 0.10091845339519656, 0.10978814111081936, 0.1553145691744796, 0.07886030856270676, 0.1839315178254335, 0.15771709541266588, 0.08556455752508574, 0.2634300643361095, 0.21067147162332778, 0.1664953728182148, 0.22936949757304692, 0.22590660153293585, 0.1918349175176549, 0.1684205746995473, 0.16503640101568784, 0.19545600935989305, 0.33350735424713784, 0.28728577414816314, 0.20645921869010986, 0.26970254919398295, 0.2330854807518966, 0.39381809267997037, 0.4651051559949556, 0.25287088188696305, 0.14274424510144856, 0.28257007355230557, 0.22962253064127558, 0.21839303572905389, 0.31083010113423937, 0.20950758607708098, 0.1617538096521266, 0.38120064436961143, 0.21002734545905355, 0.08255390087422876, 0.20917595645934361, 0.2336582127795992, 0.1890790189786179, 0.17156722548081305, 0.20744021857204664, 0.22295003846904837, 0.17911137750540096, 0.22858468311617663, 0.20844615905345731, 0.20661135914514994, 0.19808702929052302, 0.2507778065442604, 0.2085195815735732, 0.8083094086310392, 0.20857062889425437, 0.20872355982779656, 0.8415531714334886, 0.2059818905454931, 0.8987534731071197, 0.1575149439323622, 0.15449261409241022, 0.8654651534597851, 0.19944203900678426, 0.13105017808604802, 0.09973368173338115, 0.16833705079380556, 0.19908109980797306, 0.1567974273736189, 0.21140394941419227, 0.07340531426979069, 0.7402006930091869, 0.16881173181406905, 0.2110968731231634, 0.21478719413083203, 0.15677623658698048, 0.853728553157818, 0.18093292985458975, 0.22448542606304223, 0.2315491900554617, 0.18336958477875065, 0.1781354119677997, 0.17489818149235636, 0.1795574160820661, 0.17757911763186585, 0.1770695586621629, 0.08790129202106767, 0.13438326410117407, 0.10464143287036443, 0.1250838211611246, 0.07961556830466421, 0.09233656237238774, 0.08233030796774488, 0.08725548047455178, 0.08391992196989817]}, "mutation_prompt": null}
{"id": "6d4221d6-11f7-4298-9689-800889b96239", "solution": "import numpy as np\n\nclass EnhancedAdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.6, 0.95)  # Adjusted F range for diversity\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.6 * (self.num_evaluations / self.budget)  # More adaptive crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.1 / (1 + np.exp(-0.05 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 8 + int(12 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "EnhancedAdaptiveScatterSearch", "description": "Enhanced Adaptive Scatter Search with Dynamic Population and Improved Mutation Strategy for Robust Optimization.", "configspace": "", "generation": 79, "fitness": 0.25357383544223616, "feedback": "The algorithm EnhancedAdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.21.", "error": "", "parent_id": "da66f7cc-08eb-4760-a4b5-d5150faf43c2", "metadata": {"aucs": [0.6419129597180455, 0.6226276265182253, 0.6366320583784464, 0.6195632957786947, 0.6164949503187582, 0.6670839878235397, 0.6550061843815413, 0.7266049286592055, 0.6460114687854184, 0.3888689017585627, 0.3613976297442889, 0.40589633004985215, 0.4297475334150146, 0.44334678441682973, 0.3777844137166647, 0.42093073255722424, 0.41930584759799394, 0.40426327192171596, 0.10613525592392759, 0.09247707021180662, 0.07714440460020122, 0.09279443606260107, 0.1064374977863799, 0.12532780644825492, 0.10525611170815374, 0.0961385473804699, 0.10480024959323586, 0.10271549015667314, 0.0724626994220382, 0.09177402433077309, 0.08223568569963113, 0.11513180904081965, 0.0924710924548865, 0.08808579032295438, 0.08658609221744629, 0.08570578467137746, 0.9322714609654756, 0.9308313888103703, 0.9716671270096722, 0.9490049723817854, 0.9138083966945044, 0.9498072950575576, 0.9694797691709076, 0.9219169600605933, 0.9458171554333564, 0.27947671810567265, 0.27068587060704374, 0.2821535385709816, 0.26912923627845153, 0.2733409673811581, 0.2991826284429824, 0.2382194974364099, 0.28566584724682165, 0.29235091488591236, 0.3122406189811192, 0.5027011091349965, 0.5165554164461383, 0.6396220832809036, 0.4067957214096849, 0.4001394957767296, 0.5242292944447532, 0.5799684917960171, 0.5239231824377162, 0.14664798534484724, 0.17777622109140012, 0.15618919599813075, 0.16143821959839255, 0.16840181745866534, 0.1630532452426251, 0.157580817342997, 0.15865139987234833, 0.17307807189686686, 0.16146627049662676, 0.11056046314727208, 0.1795414414603398, 0.17404622218557475, 0.1861339577752047, 0.1526032094208174, 0.17631449735018445, 0.08238815336425576, 0.15333216166271435, 0.028855612996513846, 0.0629010296269733, 0.0523533240781191, 0.06964743204487656, 0.06884517032732607, 0.06378716030378395, 0.05595519004245375, 0.0946465724171569, 0.07350940707591436, 0.15130861459166534, 0.16972255222948573, 0.1961000772276621, 0.21719770442250497, 0.17504742890571612, 0.19938282177903055, 0.2251934605594833, 0.21385486983876933, 0.23600965458914702, 0.0005145372363880574, 9.999999999998899e-05, 0.004547919237188891, 0.007274105724321855, 0.03611231156274042, 0.02543009759719206, 0.014491608399551437, 0.027039413424554515, 0.019423198907769224, 0.1394089364361898, 0.12201020735783674, 0.1245650778381352, 0.13415740840943358, 0.14880732834337107, 0.13485167159848988, 0.13846762234206034, 0.1393005390204518, 0.11415344915793191, 0.4534179154544675, 0.44601275757103753, 0.4419645359615323, 0.4281889903023136, 0.4608857968003166, 0.4636294724915003, 0.4440897779970806, 0.43493073266308946, 0.4724347247856783, 0.07422679832574863, 0.11716311020929882, 0.07476833853346287, 0.0912164282427449, 0.08916759285567244, 0.08597688227151645, 0.09729583473038039, 0.08049660977331974, 0.08337851488233372, 0.1514356679469503, 0.10796469793334507, 0.12654801270762617, 0.12141165089607553, 0.15870540901189434, 0.14384737034772133, 0.1309638484761061, 0.17880431348426573, 0.14309686632116958, 0.26052087096093646, 0.2685245714490505, 0.2660023725211971, 0.2829600817810165, 0.27082736042853617, 0.278469675777123, 0.2702740499463008, 0.3251572090800895, 0.2543335835273426, 0.22362308062950798, 0.2055714805832306, 0.19771314710168864, 0.18146709177003573, 0.22072216597512595, 0.18444843166209013, 0.214218246075625, 0.20848483179665223, 0.20260892537958464, 0.17241977529873043, 0.1924144743015549, 0.17518088390053488, 0.1774178508944957, 0.18094053463810478, 0.18592376639312835, 0.1941657607032734, 0.1784833961292246, 0.18669573587922894, 0.17860516499845203, 0.20743452107618265, 0.18865045929572133, 0.18258295223901522, 0.17392716175835232, 0.1919915691092159, 0.17852672899896793, 0.17139024855428775, 0.16874792031206054, 0.6232640009100783, 0.6394858436603634, 0.1662022870664599, 0.42438649768094927, 0.1703815302153313, 0.16626870047022546, 0.4856264823438903, 0.17587794661384737, 0.30251048609303843, 0.3464809371101828, 0.1652729777257178, 0.31181717241318374, 0.1808022571395116, 0.14079730433008775, 0.36578764761057636, 0.19215783976308254, 0.6257270618496285, 0.14768446134463975, 0.20923113511044267, 0.18639128342231237, 0.18233094423417473, 0.1703200744011376, 0.20591543974583282, 0.18288452317374482, 0.17446938095099596, 0.17271139842167793, 0.17646833062261325, 0.07456246637922026, 0.08658212541903232, 0.09718996745973252, 0.06639440508953698, 0.06957467699374098, 0.06526948217595618, 0.06324302693769146, 0.06623510378758146, 0.07587374677565728]}, "mutation_prompt": null}
{"id": "85eccc27-194a-4937-b3c6-374ffad53575", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "da66f7cc-08eb-4760-a4b5-d5150faf43c2", "metadata": {"aucs": [0.8548318385729348, 0.872653021443316, 0.8652536735112889, 0.8960424015381643, 0.8618573997873242, 0.898481482903389, 0.8916460748618078, 0.8395895177912309, 0.8614849515074394, 0.7832347976856403, 0.7812727217138351, 0.761678003804076, 0.766912193125078, 0.7742793114758036, 0.7908259298654678, 0.7865636735794322, 0.7117836086703349, 0.7720212242965693, 0.6617146979727642, 0.14748796721941582, 0.1450861292877016, 0.13851788236753293, 0.16997729346783474, 0.17611175246839772, 0.11249566391301213, 0.12704268620858583, 0.14972834149319225, 0.09276430119672219, 0.16479991406555416, 0.13028980597096584, 0.11271049728875027, 0.1171729071098151, 0.15183487480308266, 0.10725929301580583, 0.11355320224387633, 0.11750984654383845, 0.9833424689668839, 0.9654388062752698, 0.9650462295588489, 0.9752180238801252, 0.9777533358445616, 0.9926075243690655, 0.9770260779429703, 0.9896002674321291, 0.983901633138145, 0.606975557061285, 0.5156634547615945, 0.5837755942363012, 0.621574103386666, 0.6296580534177081, 0.6148050812267977, 0.6019218780310516, 0.6235849328680237, 0.6678229133126679, 0.22557620908533882, 0.7839059649206297, 0.8841260739400381, 0.17321701013800883, 0.2514621815814657, 0.8513894757080122, 0.7916687145249199, 0.7608605096398121, 0.8595745593017013, 0.12676823505718826, 0.13387539724167075, 0.4009095820146594, 0.12762934925869762, 0.4183289801457517, 0.43758382249047545, 0.44511925336579794, 0.33941978503492654, 0.1324958754344442, 0.37187630083756107, 0.31497161015486996, 0.2713487112167996, 0.13175148268917014, 0.12278842937778023, 0.34134175666956457, 0.3832512501442662, 0.29373917137407934, 0.5526834092103177, 0.07499757792106998, 0.033028783021207486, 0.12015090546269169, 0.05112619649586647, 0.14439085831215448, 0.08772845194281764, 0.2008748841006177, 0.04928704254459826, 0.11316990193349086, 0.10325038768722206, 0.09740302290511504, 0.1575658018961973, 0.2523018856595388, 0.2691067699579177, 0.2845178041791563, 0.5192483212057037, 0.18631575636953035, 0.14329047930071104, 0.21494476404576912, 0.058620860851931855, 0.05001180023498142, 0.09476294023547749, 0.10974958469389151, 0.14290504732295706, 0.2523294778235642, 0.19101399842763822, 0.07156976531758719, 0.2984843679013447, 0.2166503377545992, 0.3105191709301902, 0.35762319304981327, 0.2736671569005069, 0.3426995597142627, 0.2050072336624198, 0.23887188947544924, 0.23892535811074067, 0.6594723262387852, 0.673669847630006, 0.6844728086148513, 0.6241593308994504, 0.6288555770028349, 0.609330732140837, 0.7420212795479343, 0.648101512817916, 0.6293571777625386, 0.10811106375998791, 0.0964301121756369, 0.11272416942100372, 0.086735718170737, 0.08762716979984575, 0.08863345616221663, 0.07876179031338093, 0.08711501959326173, 0.13636899739975106, 0.7288151967493938, 0.24653946563393425, 0.16892088669115002, 0.1968681207119387, 0.321559933105111, 0.5889682095652952, 0.17633759488531164, 0.15436006900017984, 0.17320944187751175, 0.4538199159561146, 0.31181281961323737, 0.397465379030257, 0.3504804025047934, 0.42309067460723626, 0.3652615284811468, 0.5243362021654452, 0.4276947454060872, 0.5401146194457727, 0.2557371274356919, 0.2693477636611349, 0.19784070848552315, 0.30869566167569207, 0.2392425356733886, 0.23236312023037708, 0.3011240271377704, 0.28260298015165075, 0.27246688253099605, 0.19564735911117892, 0.16914847589560977, 0.19014833249503582, 0.20267393413063162, 0.1671794962689681, 0.19071192329076336, 0.17951590564453457, 0.20508383481160652, 0.1986995978087691, 0.24419725714418616, 0.19941785163382397, 0.18476689294996307, 0.23947431045187673, 0.2241324517684904, 0.2001797398005486, 0.2368582268078867, 0.1867700929180025, 0.20287994707968093, 0.8727280756692124, 0.8913286495526961, 0.15413543682634068, 0.9153001509334646, 0.8873429939036275, 0.19805283018761077, 0.0996744172654519, 0.16973365740239732, 0.16787331682078843, 0.08292643316707471, 0.20814120649932688, 0.1279211453614043, 0.35154373171240383, 0.14074905436744645, 0.8023213157910414, 0.2114627793463827, 0.15525174592892077, 0.213694147185007, 0.18214906348298632, 0.1822877546726026, 0.17852481874901982, 0.20436549616565303, 0.17692304829360983, 0.1873540754032671, 0.17939247563762806, 0.1772861508383572, 0.17561340544908766, 0.08124522158221226, 0.08978045675483393, 0.08111778013331272, 0.07709137007412015, 0.08352346779236342, 0.08193626253646868, 0.07110787016824849, 0.07796387241750014, 0.0824075881279116]}, "mutation_prompt": null}
{"id": "15fc99bc-5a99-4fd4-ae5e-260aac205f8c", "solution": "import numpy as np\n\nclass EnhancedAdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.4, 0.8)  # Adjusted F range for better balance\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.4 * (self.num_evaluations / self.budget)  # Enhanced dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.1 / (1 + np.exp(-0.1 * self.num_evaluations))  # Reduced step size for precision\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        initial_pop_size = 15  # Increased initial population size\n        population = self.initialize_population(initial_pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "EnhancedAdaptiveScatterSearch", "description": "Enhanced Adaptive Scatter Search with Dynamic Population Size and Improved Local Search for Robust Global Optimization.", "configspace": "", "generation": 81, "fitness": 0.32340495413343295, "feedback": "The algorithm EnhancedAdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.29.", "error": "", "parent_id": "da66f7cc-08eb-4760-a4b5-d5150faf43c2", "metadata": {"aucs": [0.9081547670026388, 0.9139931756034737, 0.9242476562419567, 0.9368545100194731, 0.929321352732555, 0.9001752872474902, 0.9194193148540024, 0.9293312161778412, 0.9108628217499634, 0.7935818044003539, 0.7286617994903213, 0.7045272377777803, 0.837974281408699, 0.8782852474788148, 0.8483371780183349, 0.8470924545558327, 0.8519802817848048, 0.7066171207345723, 0.06859405576561295, 0.07928315912403905, 0.07806120069283662, 0.13042508191893898, 0.12397342633664721, 0.15576541526517762, 0.10843976798370336, 0.12317895920072297, 0.10324572469796489, 0.11131149526663908, 0.11787191220772042, 0.09223275255937768, 0.10779483378401056, 0.1163542811862206, 0.1048807551225811, 0.10076799737300735, 0.08731050772173532, 0.09448954810139931, 0.9917439384096264, 0.9878136168452184, 0.9933579090967566, 0.9686532763026325, 0.9871749587969075, 0.971256734994129, 0.9719684439457367, 0.9787885816166286, 0.9719399095009958, 0.5988094226611398, 0.7840337404253256, 0.7052600200884933, 0.788736563204407, 0.734751690760236, 0.7851637369146486, 0.6398672332407267, 0.761119904723389, 0.7720878229544736, 0.3907639379667961, 0.20160390643750092, 0.2282461747373088, 0.27925390479980494, 0.38630586598231653, 0.21172507058043388, 0.23251258002408892, 0.23408887971624381, 0.1503463443243067, 0.1808582169462849, 0.5242140994321036, 0.4766231769932038, 0.47032387329853476, 0.517768673123909, 0.1280034218414905, 0.18838200950649597, 0.5260114680784655, 0.169639214262707, 0.2009581687494275, 0.20423020596742814, 0.10263163408855613, 0.6746637495797039, 0.14750495751515624, 0.7363145261344859, 0.28660951205032414, 0.8042332723673642, 0.11018485860872496, 0.07656577595850178, 0.08953575567836847, 0.12414146195250253, 0.06233088945163423, 0.055626473845959534, 0.06801443272361773, 0.04314004337766475, 0.09573473062598914, 0.09717207246187831, 0.13611940668684952, 0.11110147504277845, 0.2055843848827713, 0.17322968316576826, 0.13965119250301083, 0.11590678521626252, 0.17443941037018373, 0.1334851296979328, 0.132256048114626, 0.07274029321843267, 0.06983820243549066, 0.13759255681035465, 0.08185727155181444, 0.1000076179332946, 0.08319222840667184, 0.11320974593858357, 0.11661473256519972, 0.08479332448462462, 0.22463323290455672, 0.06341249325000353, 0.2951106941567161, 0.2172666757464039, 0.29662033901095797, 0.26474118802242286, 0.09290169457371411, 0.08719974551949672, 0.10560566044072439, 0.5564354460715937, 0.5634902893634509, 0.635170241292535, 0.575204167511833, 0.5420459935276458, 0.5401433751486266, 0.5573869191723457, 0.6658078714220028, 0.5841369849902794, 0.08680774134094027, 0.08852421260393417, 0.08959346586051908, 0.10516109988595435, 0.10294074719178514, 0.08106081173861335, 0.1503244571354453, 0.13101188478500225, 0.0871700454217238, 0.20269044948818293, 0.17365174128786043, 0.1595524259365385, 0.2506432697914952, 0.48627766825549157, 0.18717540659046594, 0.2031813247687162, 0.2898406833087429, 0.2029919552630538, 0.22463690558935145, 0.22523964860404855, 0.3099528267873919, 0.38276971256247216, 0.1829530017752894, 0.17069156493644355, 0.22474748946127188, 0.24027276253805108, 0.32391348104763906, 0.18422721069216685, 0.21612742329874057, 0.2889483401570949, 0.18645814974100516, 0.205957629307446, 0.1399367391120091, 0.13936848120168432, 0.2242907919451802, 0.14944626591138344, 0.2087637008342742, 0.21377803924583327, 0.205234727424914, 0.20190624815683766, 0.201859961495915, 0.1992752193915599, 0.21317603301654708, 0.20852317795455888, 0.22674803467407711, 0.2237955582966732, 0.20233394700303198, 0.18952763633248793, 0.2552077045775152, 0.20585232457558844, 0.18007465504338593, 0.2263735138425258, 0.18394633046470443, 0.22561585219843694, 0.17721885667800108, 0.2005012442577001, 0.1544880068013228, 0.17365979989041191, 0.20072046340962146, 0.11694814572483392, 0.1577239341411314, 0.12693723391709066, 0.15855066585867839, 0.1564947449891222, 0.21263336279117118, 0.888912023422105, 0.21225406168756467, 0.21184022155362403, 0.8672558572265261, 0.10502750269405603, 0.16680527828064118, 0.9152907693851218, 0.18263708983569482, 0.18174547566401944, 0.2062043295006829, 0.18590297813764178, 0.17666497121790958, 0.19937321753930626, 0.1779574432263462, 0.20487827851059826, 0.1896977228942005, 0.08337380564567043, 0.09336350217711409, 0.10105179438439249, 0.10081611326761408, 0.08851155086057083, 0.0811749900472234, 0.0919301628976622, 0.07713790667213594, 0.06813438137406558]}, "mutation_prompt": null}
{"id": "3a0f7638-b30e-409b-94a0-c17fb8c41abc", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "da66f7cc-08eb-4760-a4b5-d5150faf43c2", "metadata": {"aucs": [0.8548318385729348, 0.872653021443316, 0.8652536735112889, 0.8960424015381643, 0.8618573997873242, 0.898481482903389, 0.8916460748618078, 0.8395895177912309, 0.8614849515074394, 0.7832347976856403, 0.7812727217138351, 0.761678003804076, 0.766912193125078, 0.7742793114758036, 0.7908259298654678, 0.7865636735794322, 0.7117836086703349, 0.7720212242965693, 0.6617146979727642, 0.14748796721941582, 0.1450861292877016, 0.13851788236753293, 0.16997729346783474, 0.17611175246839772, 0.11249566391301213, 0.12704268620858583, 0.14972834149319225, 0.09276430119672219, 0.16479991406555416, 0.13028980597096584, 0.11271049728875027, 0.1171729071098151, 0.15183487480308266, 0.10725929301580583, 0.11355320224387633, 0.11750984654383845, 0.9833424689668839, 0.9654388062752698, 0.9650462295588489, 0.9752180238801252, 0.9777533358445616, 0.9926075243690655, 0.9770260779429703, 0.9896002674321291, 0.983901633138145, 0.606975557061285, 0.5156634547615945, 0.5837755942363012, 0.621574103386666, 0.6296580534177081, 0.6148050812267977, 0.6019218780310516, 0.6235849328680237, 0.6678229133126679, 0.22557620908533882, 0.7839059649206297, 0.8841260739400381, 0.17321701013800883, 0.2514621815814657, 0.8513894757080122, 0.7916687145249199, 0.7608605096398121, 0.8595745593017013, 0.12676823505718826, 0.13387539724167075, 0.4009095820146594, 0.12762934925869762, 0.4183289801457517, 0.43758382249047545, 0.44511925336579794, 0.33941978503492654, 0.1324958754344442, 0.37187630083756107, 0.31497161015486996, 0.2713487112167996, 0.13175148268917014, 0.12278842937778023, 0.34134175666956457, 0.3832512501442662, 0.29373917137407934, 0.5526834092103177, 0.07499757792106998, 0.033028783021207486, 0.12015090546269169, 0.05112619649586647, 0.14439085831215448, 0.08772845194281764, 0.2008748841006177, 0.04928704254459826, 0.11316990193349086, 0.10325038768722206, 0.09740302290511504, 0.1575658018961973, 0.2523018856595388, 0.2691067699579177, 0.2845178041791563, 0.5192483212057037, 0.18631575636953035, 0.14329047930071104, 0.21494476404576912, 0.058620860851931855, 0.05001180023498142, 0.09476294023547749, 0.10974958469389151, 0.14290504732295706, 0.2523294778235642, 0.19101399842763822, 0.07156976531758719, 0.2984843679013447, 0.2166503377545992, 0.3105191709301902, 0.35762319304981327, 0.2736671569005069, 0.3426995597142627, 0.2050072336624198, 0.23887188947544924, 0.23892535811074067, 0.6594723262387852, 0.673669847630006, 0.6844728086148513, 0.6241593308994504, 0.6288555770028349, 0.609330732140837, 0.7420212795479343, 0.648101512817916, 0.6293571777625386, 0.10811106375998791, 0.0964301121756369, 0.11272416942100372, 0.086735718170737, 0.08762716979984575, 0.08863345616221663, 0.07876179031338093, 0.08711501959326173, 0.13636899739975106, 0.7288151967493938, 0.24653946563393425, 0.16892088669115002, 0.1968681207119387, 0.321559933105111, 0.5889682095652952, 0.17633759488531164, 0.15436006900017984, 0.17320944187751175, 0.4538199159561146, 0.31181281961323737, 0.397465379030257, 0.3504804025047934, 0.42309067460723626, 0.3652615284811468, 0.5243362021654452, 0.4276947454060872, 0.5401146194457727, 0.2557371274356919, 0.2693477636611349, 0.19784070848552315, 0.30869566167569207, 0.2392425356733886, 0.23236312023037708, 0.3011240271377704, 0.28260298015165075, 0.27246688253099605, 0.19564735911117892, 0.16914847589560977, 0.19014833249503582, 0.20267393413063162, 0.1671794962689681, 0.19071192329076336, 0.17951590564453457, 0.20508383481160652, 0.1986995978087691, 0.24419725714418616, 0.19941785163382397, 0.18476689294996307, 0.23947431045187673, 0.2241324517684904, 0.2001797398005486, 0.2368582268078867, 0.1867700929180025, 0.20287994707968093, 0.8727280756692124, 0.8913286495526961, 0.15413543682634068, 0.9153001509334646, 0.8873429939036275, 0.19805283018761077, 0.0996744172654519, 0.16973365740239732, 0.16787331682078843, 0.08292643316707471, 0.20814120649932688, 0.1279211453614043, 0.35154373171240383, 0.14074905436744645, 0.8023213157910414, 0.2114627793463827, 0.15525174592892077, 0.213694147185007, 0.18214906348298632, 0.1822877546726026, 0.17852481874901982, 0.20436549616565303, 0.17692304829360983, 0.1873540754032671, 0.17939247563762806, 0.1772861508383572, 0.17561340544908766, 0.08124522158221226, 0.08978045675483393, 0.08111778013331272, 0.07709137007412015, 0.08352346779236342, 0.08193626253646868, 0.07110787016824849, 0.07796387241750014, 0.0824075881279116]}, "mutation_prompt": null}
{"id": "a8232592-4ff2-4174-8312-79219d2f6f5a", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "da66f7cc-08eb-4760-a4b5-d5150faf43c2", "metadata": {"aucs": [0.8548318385729348, 0.872653021443316, 0.8652536735112889, 0.8960424015381643, 0.8618573997873242, 0.898481482903389, 0.8916460748618078, 0.8395895177912309, 0.8614849515074394, 0.7832347976856403, 0.7812727217138351, 0.761678003804076, 0.766912193125078, 0.7742793114758036, 0.7908259298654678, 0.7865636735794322, 0.7117836086703349, 0.7720212242965693, 0.6617146979727642, 0.14748796721941582, 0.1450861292877016, 0.13851788236753293, 0.16997729346783474, 0.17611175246839772, 0.11249566391301213, 0.12704268620858583, 0.14972834149319225, 0.09276430119672219, 0.16479991406555416, 0.13028980597096584, 0.11271049728875027, 0.1171729071098151, 0.15183487480308266, 0.10725929301580583, 0.11355320224387633, 0.11750984654383845, 0.9833424689668839, 0.9654388062752698, 0.9650462295588489, 0.9752180238801252, 0.9777533358445616, 0.9926075243690655, 0.9770260779429703, 0.9896002674321291, 0.983901633138145, 0.606975557061285, 0.5156634547615945, 0.5837755942363012, 0.621574103386666, 0.6296580534177081, 0.6148050812267977, 0.6019218780310516, 0.6235849328680237, 0.6678229133126679, 0.22557620908533882, 0.7839059649206297, 0.8841260739400381, 0.17321701013800883, 0.2514621815814657, 0.8513894757080122, 0.7916687145249199, 0.7608605096398121, 0.8595745593017013, 0.12676823505718826, 0.13387539724167075, 0.4009095820146594, 0.12762934925869762, 0.4183289801457517, 0.43758382249047545, 0.44511925336579794, 0.33941978503492654, 0.1324958754344442, 0.37187630083756107, 0.31497161015486996, 0.2713487112167996, 0.13175148268917014, 0.12278842937778023, 0.34134175666956457, 0.3832512501442662, 0.29373917137407934, 0.5526834092103177, 0.07499757792106998, 0.033028783021207486, 0.12015090546269169, 0.05112619649586647, 0.14439085831215448, 0.08772845194281764, 0.2008748841006177, 0.04928704254459826, 0.11316990193349086, 0.10325038768722206, 0.09740302290511504, 0.1575658018961973, 0.2523018856595388, 0.2691067699579177, 0.2845178041791563, 0.5192483212057037, 0.18631575636953035, 0.14329047930071104, 0.21494476404576912, 0.058620860851931855, 0.05001180023498142, 0.09476294023547749, 0.10974958469389151, 0.14290504732295706, 0.2523294778235642, 0.19101399842763822, 0.07156976531758719, 0.2984843679013447, 0.2166503377545992, 0.3105191709301902, 0.35762319304981327, 0.2736671569005069, 0.3426995597142627, 0.2050072336624198, 0.23887188947544924, 0.23892535811074067, 0.6594723262387852, 0.673669847630006, 0.6844728086148513, 0.6241593308994504, 0.6288555770028349, 0.609330732140837, 0.7420212795479343, 0.648101512817916, 0.6293571777625386, 0.10811106375998791, 0.0964301121756369, 0.11272416942100372, 0.086735718170737, 0.08762716979984575, 0.08863345616221663, 0.07876179031338093, 0.08711501959326173, 0.13636899739975106, 0.7288151967493938, 0.24653946563393425, 0.16892088669115002, 0.1968681207119387, 0.321559933105111, 0.5889682095652952, 0.17633759488531164, 0.15436006900017984, 0.17320944187751175, 0.4538199159561146, 0.31181281961323737, 0.397465379030257, 0.3504804025047934, 0.42309067460723626, 0.3652615284811468, 0.5243362021654452, 0.4276947454060872, 0.5401146194457727, 0.2557371274356919, 0.2693477636611349, 0.19784070848552315, 0.30869566167569207, 0.2392425356733886, 0.23236312023037708, 0.3011240271377704, 0.28260298015165075, 0.27246688253099605, 0.19564735911117892, 0.16914847589560977, 0.19014833249503582, 0.20267393413063162, 0.1671794962689681, 0.19071192329076336, 0.17951590564453457, 0.20508383481160652, 0.1986995978087691, 0.24419725714418616, 0.19941785163382397, 0.18476689294996307, 0.23947431045187673, 0.2241324517684904, 0.2001797398005486, 0.2368582268078867, 0.1867700929180025, 0.20287994707968093, 0.8727280756692124, 0.8913286495526961, 0.15413543682634068, 0.9153001509334646, 0.8873429939036275, 0.19805283018761077, 0.0996744172654519, 0.16973365740239732, 0.16787331682078843, 0.08292643316707471, 0.20814120649932688, 0.1279211453614043, 0.35154373171240383, 0.14074905436744645, 0.8023213157910414, 0.2114627793463827, 0.15525174592892077, 0.213694147185007, 0.18214906348298632, 0.1822877546726026, 0.17852481874901982, 0.20436549616565303, 0.17692304829360983, 0.1873540754032671, 0.17939247563762806, 0.1772861508383572, 0.17561340544908766, 0.08124522158221226, 0.08978045675483393, 0.08111778013331272, 0.07709137007412015, 0.08352346779236342, 0.08193626253646868, 0.07110787016824849, 0.07796387241750014, 0.0824075881279116]}, "mutation_prompt": null}
{"id": "34c6aeeb-5bbb-4a77-b0f9-9f20a491bd79", "solution": "import numpy as np\n\nclass EnhancedAdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.6, 0.95)  # Slightly shifted F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (best - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.3 * (self.num_evaluations / self.budget)  # Adjusted dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def elite_exploitation(self, population, fitness, func):\n        elite_idx = np.argmin(fitness)\n        elite = population[elite_idx]\n        new_elite = self.local_search(elite, func)\n        if func(new_elite) < fitness[elite_idx]:\n            population[elite_idx] = new_elite\n            fitness[elite_idx] = func(new_elite)\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n            self.elite_exploitation(population, fitness, func)  # Added elite exploitation\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "EnhancedAdaptiveScatterSearch", "description": "Enhanced Adaptive Scatter Search with Dynamic Population Adjustments and Elite Exploitation for Improved Performance.", "configspace": "", "generation": 84, "fitness": 0.23425870442059626, "feedback": "The algorithm EnhancedAdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.22.", "error": "", "parent_id": "da66f7cc-08eb-4760-a4b5-d5150faf43c2", "metadata": {"aucs": [0.6236393693120164, 0.6392672522434371, 0.6697028346255645, 0.6884274072081538, 0.6242298138134521, 0.6616561608990761, 0.6678597767255801, 0.6556857845095054, 0.6332389500164329, 0.378737275626988, 0.35882232760278754, 0.3522697100627715, 0.43588683139176754, 0.3480916416008668, 0.3617289765132502, 0.05187457502642301, 0.3029474002303927, 0.34993845618948394, 0.08906390115503404, 0.0924556521344484, 0.09298684097078147, 0.07830907515057173, 0.09508634006724437, 0.0798483876496453, 0.07695963249681603, 0.07844026081976097, 0.08660413735638117, 0.0635946175845753, 0.07999869919449443, 0.08731824922613973, 0.09400760558440358, 0.08869451025961372, 0.08707243484052318, 0.09149089130381616, 0.06552307705147631, 0.08401528040166084, 0.9966007677016502, 0.9852614884193956, 0.9890045750661638, 0.9776455706419507, 0.9833477756485617, 0.9946536651676211, 0.9869779527444972, 0.985271152426799, 0.997129384985148, 0.16748788152628635, 0.18173181881982958, 0.17498695564846112, 0.17087855526580153, 0.18802960717758088, 0.18971140024679278, 0.21824632428421453, 0.23354308003057578, 0.18473826576760244, 0.21041360728639225, 0.1976238043475087, 0.46883653597099606, 0.42432637079402447, 0.2584787459324326, 0.6181768192351234, 0.23558694139722425, 0.4746893799990517, 0.4219995391997008, 0.21959217432697054, 0.0842668716371856, 0.1885347872955444, 0.15975312540153386, 0.12222629054446266, 0.22207921567252353, 0.18574213436540443, 0.1725482158734385, 0.17155666244748502, 0.11487784398244205, 0.18897086087311032, 0.1191517969228778, 0.1803487687612797, 0.08903913899773519, 0.192067075929793, 0.08234958309431006, 0.08055769371101773, 0.2206107613659285, 0.08557156595612958, 0.046640625684905124, 0.10935648881070048, 0.047828863119805054, 0.01676398582830496, 0.013620557280470402, 0.026107475627641707, 0.00704625552479432, 0.11582230472262856, 0.16074064539755728, 0.16330080649756074, 0.14503710746655873, 0.14389036104459174, 0.030769929947815022, 0.1055460527668396, 0.19402662902054868, 0.16482867363626297, 0.176985580029152, 0.021391737639230968, 0.025733572952552963, 0.03727737939166287, 0.027227997073999033, 0.021265120205707144, 0.021107588582225834, 0.08010314254942985, 0.0027514269598090113, 0.037477569377601716, 0.12085132395797427, 0.13069202359609677, 0.11598586868959504, 0.1426121588342576, 0.12322353922785112, 0.134508093990779, 0.11406323004451502, 0.053417633295584355, 0.09898629981993712, 0.42290000850616405, 0.4809718157479985, 0.4390885774204647, 0.42271326849919966, 0.47086943741558074, 0.5204792533846302, 0.46774443695377976, 0.41818396316513995, 0.4398969451790775, 0.07210941687864358, 0.08747651132218304, 0.08198692830375798, 0.07864948089512125, 0.08668737630175838, 0.07419426838865184, 0.07959556686370184, 0.07659672754649494, 0.07829005889418272, 0.15390256504037003, 0.1995535666136733, 0.18203475277941417, 0.1414274248754318, 0.15217357187353042, 0.18315871835157382, 0.17159394663388083, 0.26287829842457267, 0.29735634194470717, 0.2406953452892533, 0.23293580466377384, 0.2226181769378508, 0.19251977872878356, 0.2511435250365356, 0.2052311161821514, 0.26949116903617154, 0.2927219452644334, 0.2540189893184447, 0.19373705853390188, 0.20929352214160568, 0.1716016696772269, 0.169639064787648, 0.16210173051333077, 0.1838801674994025, 0.19315866881132016, 0.20658125640415437, 0.17095676530120563, 0.1606016277986555, 0.18279084174076077, 0.1751975142046336, 0.18358117979299637, 0.16461642125839715, 0.17176002668294277, 0.1866690222231494, 0.18502036080781636, 0.18402292551503807, 0.17248173182918813, 0.17507319140408695, 0.1627652372122006, 0.17980141475566724, 0.16507672288312447, 0.18588173127930363, 0.17245519599057113, 0.20333756468386632, 0.18380888417053554, 0.7147256064521879, 0.16358085813559442, 0.1543784368420309, 0.670132514568591, 0.19362259371093238, 0.16474146111612775, 0.09966318871426005, 0.16421917963108468, 0.19306572723785853, 0.12297455279421288, 0.1680548713669372, 0.19745960909982774, 0.6243914652343798, 0.15994612761709182, 0.4358406454704663, 0.2135246406589857, 0.1523658741571391, 0.10296019667064482, 0.18861555272463337, 0.17903932560182378, 0.18455936396273387, 0.19563317668011648, 0.18037776422547835, 0.18731810207299393, 0.18772410917832938, 0.18457544539032078, 0.17155335151104245, 0.06855319309521457, 0.06643709407007115, 0.07185294841888756, 0.06933517691706437, 0.06175357389030178, 0.06932015022341753, 0.06107299246142628, 0.059886984801594045, 0.0691590052503287]}, "mutation_prompt": null}
{"id": "64e58468-e486-4f0a-847b-6fcc8f403e24", "solution": "import numpy as np\n\nclass ImprovedAdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)  # Slightly reduced F range for balanced exploration\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)  # Updated mutation strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.6 * (self.num_evaluations / self.budget)  # Further dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.1 / (1 + np.exp(-0.05 * self.num_evaluations))  # Enhanced local search exploration\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        initial_pop_size = 12 + int(8 * (1 - (self.num_evaluations / self.budget)))  # Adjusted initial population size\n        population = self.initialize_population(initial_pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "ImprovedAdaptiveScatterSearch", "description": "Improved Adaptive Scatter Search with Dynamic Population Sizing and Enhanced Local Exploration for Robust Search Performance.", "configspace": "", "generation": 85, "fitness": 0.2994748194746801, "feedback": "The algorithm ImprovedAdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.23.", "error": "", "parent_id": "da66f7cc-08eb-4760-a4b5-d5150faf43c2", "metadata": {"aucs": [0.7724202200411253, 0.7630532686536062, 0.7368097261045112, 0.7618855476038662, 0.7548989198293461, 0.7587377795566789, 0.7578423308122489, 0.7702669963894121, 0.7678877407165048, 0.5486780719981997, 0.5470709376117828, 0.5743332825624349, 0.5525623726198581, 0.6048981797641702, 0.5752129350563611, 0.5982369027174017, 0.509785531909042, 0.5111485120046926, 0.11869530498768599, 0.09924226317398932, 0.10531943765867768, 0.16667614469320524, 0.11156709562649525, 0.12183904044912575, 0.13833500660686426, 0.11106289362823896, 0.17632405721550526, 0.10649696500883998, 0.11126944351042878, 0.10138321658136662, 0.11344602583623942, 0.12191605398763783, 0.10558667454575565, 0.0992075500873214, 0.118790519607892, 0.0969407541031122, 0.8899138537360651, 0.947497723210472, 0.9569080008180535, 0.9198964339592886, 0.8804230507997017, 0.9153996362762914, 0.9426963509719589, 0.9040594643833786, 0.9172843474930573, 0.3792827020367153, 0.3695858288104611, 0.3412331679333408, 0.3785017265469076, 0.4085639895428077, 0.3794198788593872, 0.3829032868196036, 0.37150791524949145, 0.33643126786877187, 0.7174900614318866, 0.6880904672973001, 0.674093264390909, 0.6642816871735074, 0.7127726227639535, 0.25732187251129024, 0.6712037370625827, 0.34905749628405935, 0.6433376721146411, 0.17105226161845477, 0.1796913531326776, 0.1346044160685086, 0.21780563874503267, 0.20360956719175416, 0.18354070978898818, 0.21081010122907295, 0.166436465134581, 0.17079632903243858, 0.17251876167700342, 0.14562982343703357, 0.21825527159403435, 0.16788303494374546, 0.20423852988572233, 0.18561897881401646, 0.19497407833098646, 0.1512641138621924, 0.15202203142275594, 0.10284324435799386, 0.09117965464178412, 0.2100115397561788, 0.1400342736320841, 0.1697075901899331, 0.16713878626717615, 0.1609549305131559, 0.007153090937196849, 0.08133026940068666, 0.34959340834888153, 0.2916461316114969, 0.3124549471006741, 0.25749509482686683, 0.19122393530898163, 0.08625207769192933, 0.23012808002250562, 0.3166774733988327, 0.19714373138764063, 0.08051264839680994, 0.07119957211885264, 0.10034257592976115, 0.07103497455333285, 0.04507680213262044, 0.07772096405359841, 0.10329654134563393, 0.09103258413608728, 0.1046995321021057, 0.18440294996224083, 0.19606380977307103, 0.17466856684952237, 0.20477523643680184, 0.2323034358303776, 0.20344679259149412, 0.17640820332888985, 0.1884226567114331, 0.18196433264341916, 0.5387865712371087, 0.5866371332995859, 0.5165097062502093, 0.5446204897043522, 0.5303511739092637, 0.5362179441027906, 0.5269237804659265, 0.5330019927165535, 0.5638693918612387, 0.08851488931427176, 0.07998361051178382, 0.08748429653863277, 0.08210976357376709, 0.1123481869873798, 0.08868103634122693, 0.0825106735993173, 0.0924082615451618, 0.09167566185464326, 0.1354449818575174, 0.16040940907543588, 0.14444214430487623, 0.23332129225326848, 0.1457020513141024, 0.13174686659561263, 0.153915519125999, 0.12064058235642006, 0.1848083254560665, 0.3404209146764797, 0.31418707658075296, 0.3234116198797725, 0.37897375575734116, 0.3527308708262893, 0.34846129279598936, 0.3697754968629884, 0.37887885321036363, 0.3212445702574849, 0.2580746119498627, 0.2377889310479755, 0.23825320499807234, 0.22612433598305515, 0.2554058690150397, 0.21910338118028871, 0.24919924724092368, 0.2507452519272362, 0.2735723285665309, 0.2128024476013377, 0.1870097046295699, 0.18569936508027285, 0.19420374576047017, 0.1769518746700227, 0.19269017117615672, 0.20239235000640365, 0.1984000220310579, 0.19975100170990445, 0.20064386021998526, 0.3871910844694003, 0.18827028536373513, 0.21416383110601378, 0.1979985932156395, 0.19388773073626586, 0.20366406591211061, 0.18149063072020533, 0.17528667937078213, 0.772296610417088, 0.16232181654511058, 0.1842903553170463, 0.1669461155559353, 0.6561921332301719, 0.19071412957202405, 0.5173966337941361, 0.17499706233982837, 0.6291094726891774, 0.47653385430131934, 0.19948098163537453, 0.19664005256245587, 0.45862925648512565, 0.19876804588435337, 0.17864476840366683, 0.6182271598407405, 0.20268715355566214, 0.19982731696050315, 0.1829691528506644, 0.1851170840855091, 0.17660452927368164, 0.17399795511314586, 0.1755582685106858, 0.19353955794316002, 0.18747163875796835, 0.18484301294802263, 0.176752925103559, 0.07320506169155927, 0.06957060235715273, 0.07567102081599952, 0.08222906261226415, 0.07153827591669815, 0.06255509932197201, 0.09131854581267618, 0.0797769592572024, 0.06814742857640654]}, "mutation_prompt": null}
{"id": "cc32af24-9a12-4cde-ab68-fd4a91342b36", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "da66f7cc-08eb-4760-a4b5-d5150faf43c2", "metadata": {"aucs": [0.8548318385729348, 0.872653021443316, 0.8652536735112889, 0.8960424015381643, 0.8618573997873242, 0.898481482903389, 0.8916460748618078, 0.8395895177912309, 0.8614849515074394, 0.7832347976856403, 0.7812727217138351, 0.761678003804076, 0.766912193125078, 0.7742793114758036, 0.7908259298654678, 0.7865636735794322, 0.7117836086703349, 0.7720212242965693, 0.6617146979727642, 0.14748796721941582, 0.1450861292877016, 0.13851788236753293, 0.16997729346783474, 0.17611175246839772, 0.11249566391301213, 0.12704268620858583, 0.14972834149319225, 0.09276430119672219, 0.16479991406555416, 0.13028980597096584, 0.11271049728875027, 0.1171729071098151, 0.15183487480308266, 0.10725929301580583, 0.11355320224387633, 0.11750984654383845, 0.9833424689668839, 0.9654388062752698, 0.9650462295588489, 0.9752180238801252, 0.9777533358445616, 0.9926075243690655, 0.9770260779429703, 0.9896002674321291, 0.983901633138145, 0.606975557061285, 0.5156634547615945, 0.5837755942363012, 0.621574103386666, 0.6296580534177081, 0.6148050812267977, 0.6019218780310516, 0.6235849328680237, 0.6678229133126679, 0.22557620908533882, 0.7839059649206297, 0.8841260739400381, 0.17321701013800883, 0.2514621815814657, 0.8513894757080122, 0.7916687145249199, 0.7608605096398121, 0.8595745593017013, 0.12676823505718826, 0.13387539724167075, 0.4009095820146594, 0.12762934925869762, 0.4183289801457517, 0.43758382249047545, 0.44511925336579794, 0.33941978503492654, 0.1324958754344442, 0.37187630083756107, 0.31497161015486996, 0.2713487112167996, 0.13175148268917014, 0.12278842937778023, 0.34134175666956457, 0.3832512501442662, 0.29373917137407934, 0.5526834092103177, 0.07499757792106998, 0.033028783021207486, 0.12015090546269169, 0.05112619649586647, 0.14439085831215448, 0.08772845194281764, 0.2008748841006177, 0.04928704254459826, 0.11316990193349086, 0.10325038768722206, 0.09740302290511504, 0.1575658018961973, 0.2523018856595388, 0.2691067699579177, 0.2845178041791563, 0.5192483212057037, 0.18631575636953035, 0.14329047930071104, 0.21494476404576912, 0.058620860851931855, 0.05001180023498142, 0.09476294023547749, 0.10974958469389151, 0.14290504732295706, 0.2523294778235642, 0.19101399842763822, 0.07156976531758719, 0.2984843679013447, 0.2166503377545992, 0.3105191709301902, 0.35762319304981327, 0.2736671569005069, 0.3426995597142627, 0.2050072336624198, 0.23887188947544924, 0.23892535811074067, 0.6594723262387852, 0.673669847630006, 0.6844728086148513, 0.6241593308994504, 0.6288555770028349, 0.609330732140837, 0.7420212795479343, 0.648101512817916, 0.6293571777625386, 0.10811106375998791, 0.0964301121756369, 0.11272416942100372, 0.086735718170737, 0.08762716979984575, 0.08863345616221663, 0.07876179031338093, 0.08711501959326173, 0.13636899739975106, 0.7288151967493938, 0.24653946563393425, 0.16892088669115002, 0.1968681207119387, 0.321559933105111, 0.5889682095652952, 0.17633759488531164, 0.15436006900017984, 0.17320944187751175, 0.4538199159561146, 0.31181281961323737, 0.397465379030257, 0.3504804025047934, 0.42309067460723626, 0.3652615284811468, 0.5243362021654452, 0.4276947454060872, 0.5401146194457727, 0.2557371274356919, 0.2693477636611349, 0.19784070848552315, 0.30869566167569207, 0.2392425356733886, 0.23236312023037708, 0.3011240271377704, 0.28260298015165075, 0.27246688253099605, 0.19564735911117892, 0.16914847589560977, 0.19014833249503582, 0.20267393413063162, 0.1671794962689681, 0.19071192329076336, 0.17951590564453457, 0.20508383481160652, 0.1986995978087691, 0.24419725714418616, 0.19941785163382397, 0.18476689294996307, 0.23947431045187673, 0.2241324517684904, 0.2001797398005486, 0.2368582268078867, 0.1867700929180025, 0.20287994707968093, 0.8727280756692124, 0.8913286495526961, 0.15413543682634068, 0.9153001509334646, 0.8873429939036275, 0.19805283018761077, 0.0996744172654519, 0.16973365740239732, 0.16787331682078843, 0.08292643316707471, 0.20814120649932688, 0.1279211453614043, 0.35154373171240383, 0.14074905436744645, 0.8023213157910414, 0.2114627793463827, 0.15525174592892077, 0.213694147185007, 0.18214906348298632, 0.1822877546726026, 0.17852481874901982, 0.20436549616565303, 0.17692304829360983, 0.1873540754032671, 0.17939247563762806, 0.1772861508383572, 0.17561340544908766, 0.08124522158221226, 0.08978045675483393, 0.08111778013331272, 0.07709137007412015, 0.08352346779236342, 0.08193626253646868, 0.07110787016824849, 0.07796387241750014, 0.0824075881279116]}, "mutation_prompt": null}
{"id": "8f25684e-86cf-4ca1-9d7e-4c897bef7a74", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12  # Adjusted population size\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.4, 0.9)  # Slightly adjusted F range\n        mutant_vector = np.clip(best + F * (a - b) + F * (c - a), self.lower_bound, self.upper_bound)  # New formula\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.75 - 0.4 * (self.num_evaluations / self.budget)  # Adjusted crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.1 / (1 + np.exp(-0.1 * self.num_evaluations))  # Adjusted step size\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def elite_exploitation(self, population, fitness, func):\n        best_idx = np.argmin(fitness)\n        elite = population[best_idx]\n        perturbed = elite + np.random.uniform(-0.1, 0.1, self.dim)  # Minor perturbation for exploitation\n        perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n        return perturbed if func(perturbed) < fitness[best_idx] else elite\n\n    def __call__(self, func):\n        population = self.initialize_population(self.pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n            population[np.argmin(fitness)] = self.elite_exploitation(population, fitness, func)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Enhanced Adaptive Scatter Search with Self-Adaptive Parameters and Elite Exploitation for Superior Convergence.", "configspace": "", "generation": 87, "fitness": 0.3234554563875344, "feedback": "The algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.28.", "error": "", "parent_id": "da66f7cc-08eb-4760-a4b5-d5150faf43c2", "metadata": {"aucs": [0.9109926363794485, 0.9082463403512453, 0.9046450287965246, 0.9242080719176876, 0.9239008199788442, 0.9323492867664123, 0.9134309383553362, 0.9127303421923539, 0.9287616969358569, 0.04283029320845999, 0.8139925256845414, 0.8121044145986898, 0.04951215217181704, 0.8651099392001461, 0.8388367617913215, 0.8327737456091944, 0.8403599662546651, 0.8342512906932107, 0.11490213499331114, 0.11827434746231169, 0.07741603084927651, 0.1436027612783981, 0.12301845020571833, 0.18632686920162145, 0.10584812728329684, 0.14423879068743772, 0.17674302944737097, 0.12234889831335582, 0.14183605688246792, 0.09724339000838644, 0.1108786294121652, 0.09117813028610566, 0.11735366884029785, 0.15427363393447902, 0.09573412834003725, 0.08714017989807432, 0.9737366893251621, 0.9806721497365954, 0.9738645304823604, 0.9855901383362505, 0.9962454527474612, 0.9868132056650787, 0.9838683804051194, 0.9865230391441256, 0.9829762017870307, 0.7481036051044248, 0.7108265892438781, 0.6914740908878945, 0.6662097086435617, 0.7359796559212863, 0.7266923244627463, 0.7113058799452971, 0.7472454910266004, 0.5756201058519758, 0.22889764813233515, 0.11723643332932021, 0.17165469349536566, 0.41154580680429453, 0.8807299153424637, 0.15307893020682384, 0.869839921659714, 0.24645082910890204, 0.39008952397352015, 0.35404064915582945, 0.3069078600136246, 0.4247312911705853, 0.22536941892261053, 0.2490180745076903, 0.24424077075246375, 0.21149410018434922, 0.21439433613863135, 0.2841379537985015, 0.28137987020967214, 0.13713248741664485, 0.23328553137325703, 0.26346388160907097, 0.13003908955346466, 0.1610382935970791, 0.26536676121494795, 0.18437707052968122, 0.30677685293102375, 0.11689913240716765, 0.043853089731297756, 0.05156921770875744, 0.006724307535453056, 0.14206515256391816, 0.12290573525202675, 0.12009356660634363, 0.07543355905640492, 0.009033746454036762, 0.12824016100575486, 0.10172396779358883, 0.20260887209449074, 0.22045552180187744, 0.1126519127333997, 0.12461859971877198, 0.20225430569169023, 0.1275586813297368, 0.14342559108448183, 0.04645567764399494, 0.12593833942342758, 0.053221485911829736, 0.2782890559715615, 0.20718236270487378, 0.20437878525498754, 0.20419888786030438, 0.22645025003677122, 0.09395347795449727, 0.14178739462093748, 0.1444805712556032, 0.09010123147861782, 0.27072630686788857, 0.2282285829375723, 0.3032482929514787, 0.1444009344199918, 0.10906945049620675, 0.15291837461915003, 0.6464305931745169, 0.6156116593239072, 0.5336436795308199, 0.547863932513982, 0.5718263619173365, 0.5975272793200883, 0.695128011293912, 0.601090467980349, 0.6043675141199459, 0.12207664936991436, 0.12733460181863088, 0.07861137473455759, 0.08926240724128276, 0.100833176178868, 0.12007076585940124, 0.14237448947282705, 0.10806079418866488, 0.11624557858116491, 0.17194319119544488, 0.250111876248703, 0.19318429254432934, 0.27344146489630716, 0.7277116744585971, 0.20257583254132483, 0.1991912581802039, 0.21739396946076794, 0.26910637057874287, 0.2202701847420362, 0.38265420808860495, 0.3882078607128039, 0.3408188932880345, 0.23949435349422632, 0.4109904223977583, 0.23627493168819846, 0.45991151736361335, 0.35571159196088586, 0.20183562955875511, 0.20043505641299975, 0.17972671747727087, 0.21889685672959835, 0.3010284455570835, 0.17889592584314595, 0.23950850576064908, 0.2957616346518833, 0.08838057768481378, 0.20704010785008964, 0.2088158810586368, 0.18755564788622792, 0.19280252961652988, 0.20352242121452535, 0.20793163787790703, 0.21717900088118502, 0.2187367475200388, 0.20334070876214383, 0.24822197398690304, 0.2516450774283804, 0.19303414759035142, 0.22143448746636885, 0.2427184386254001, 0.2519680772199052, 0.2073895754643844, 0.22145249204091555, 0.19964487904736705, 0.1589157882066491, 0.19919252586682878, 0.1543807609563177, 0.9373930512211892, 0.20082774659562908, 0.14851351827619275, 0.16623159887280614, 0.9128467950683251, 0.1597882719647138, 0.12826001123993325, 0.11206300942334435, 0.8481795465024908, 0.20795257541798773, 0.2107938006292579, 0.1051180772809095, 0.21276987766999778, 0.16655723927449873, 0.10494548464688447, 0.19037036457101209, 0.1773302068777437, 0.18758425602496287, 0.17042376238361523, 0.18946542477098893, 0.17536074195407003, 0.18441380789854278, 0.17702868640342495, 0.18230791959652293, 0.10263281261664137, 0.07360775180546131, 0.07188281841305744, 0.09524010394307736, 0.07459016639105887, 0.08272760988758399, 0.07719712070139706, 0.08862436493816495, 0.09960124470444676]}, "mutation_prompt": null}
{"id": "6b32b950-12aa-4b55-8c26-7e05aec1e19a", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "da66f7cc-08eb-4760-a4b5-d5150faf43c2", "metadata": {"aucs": [0.8548318385729348, 0.872653021443316, 0.8652536735112889, 0.8960424015381643, 0.8618573997873242, 0.898481482903389, 0.8916460748618078, 0.8395895177912309, 0.8614849515074394, 0.7832347976856403, 0.7812727217138351, 0.761678003804076, 0.766912193125078, 0.7742793114758036, 0.7908259298654678, 0.7865636735794322, 0.7117836086703349, 0.7720212242965693, 0.6617146979727642, 0.14748796721941582, 0.1450861292877016, 0.13851788236753293, 0.16997729346783474, 0.17611175246839772, 0.11249566391301213, 0.12704268620858583, 0.14972834149319225, 0.09276430119672219, 0.16479991406555416, 0.13028980597096584, 0.11271049728875027, 0.1171729071098151, 0.15183487480308266, 0.10725929301580583, 0.11355320224387633, 0.11750984654383845, 0.9833424689668839, 0.9654388062752698, 0.9650462295588489, 0.9752180238801252, 0.9777533358445616, 0.9926075243690655, 0.9770260779429703, 0.9896002674321291, 0.983901633138145, 0.606975557061285, 0.5156634547615945, 0.5837755942363012, 0.621574103386666, 0.6296580534177081, 0.6148050812267977, 0.6019218780310516, 0.6235849328680237, 0.6678229133126679, 0.22557620908533882, 0.7839059649206297, 0.8841260739400381, 0.17321701013800883, 0.2514621815814657, 0.8513894757080122, 0.7916687145249199, 0.7608605096398121, 0.8595745593017013, 0.12676823505718826, 0.13387539724167075, 0.4009095820146594, 0.12762934925869762, 0.4183289801457517, 0.43758382249047545, 0.44511925336579794, 0.33941978503492654, 0.1324958754344442, 0.37187630083756107, 0.31497161015486996, 0.2713487112167996, 0.13175148268917014, 0.12278842937778023, 0.34134175666956457, 0.3832512501442662, 0.29373917137407934, 0.5526834092103177, 0.07499757792106998, 0.033028783021207486, 0.12015090546269169, 0.05112619649586647, 0.14439085831215448, 0.08772845194281764, 0.2008748841006177, 0.04928704254459826, 0.11316990193349086, 0.10325038768722206, 0.09740302290511504, 0.1575658018961973, 0.2523018856595388, 0.2691067699579177, 0.2845178041791563, 0.5192483212057037, 0.18631575636953035, 0.14329047930071104, 0.21494476404576912, 0.058620860851931855, 0.05001180023498142, 0.09476294023547749, 0.10974958469389151, 0.14290504732295706, 0.2523294778235642, 0.19101399842763822, 0.07156976531758719, 0.2984843679013447, 0.2166503377545992, 0.3105191709301902, 0.35762319304981327, 0.2736671569005069, 0.3426995597142627, 0.2050072336624198, 0.23887188947544924, 0.23892535811074067, 0.6594723262387852, 0.673669847630006, 0.6844728086148513, 0.6241593308994504, 0.6288555770028349, 0.609330732140837, 0.7420212795479343, 0.648101512817916, 0.6293571777625386, 0.10811106375998791, 0.0964301121756369, 0.11272416942100372, 0.086735718170737, 0.08762716979984575, 0.08863345616221663, 0.07876179031338093, 0.08711501959326173, 0.13636899739975106, 0.7288151967493938, 0.24653946563393425, 0.16892088669115002, 0.1968681207119387, 0.321559933105111, 0.5889682095652952, 0.17633759488531164, 0.15436006900017984, 0.17320944187751175, 0.4538199159561146, 0.31181281961323737, 0.397465379030257, 0.3504804025047934, 0.42309067460723626, 0.3652615284811468, 0.5243362021654452, 0.4276947454060872, 0.5401146194457727, 0.2557371274356919, 0.2693477636611349, 0.19784070848552315, 0.30869566167569207, 0.2392425356733886, 0.23236312023037708, 0.3011240271377704, 0.28260298015165075, 0.27246688253099605, 0.19564735911117892, 0.16914847589560977, 0.19014833249503582, 0.20267393413063162, 0.1671794962689681, 0.19071192329076336, 0.17951590564453457, 0.20508383481160652, 0.1986995978087691, 0.24419725714418616, 0.19941785163382397, 0.18476689294996307, 0.23947431045187673, 0.2241324517684904, 0.2001797398005486, 0.2368582268078867, 0.1867700929180025, 0.20287994707968093, 0.8727280756692124, 0.8913286495526961, 0.15413543682634068, 0.9153001509334646, 0.8873429939036275, 0.19805283018761077, 0.0996744172654519, 0.16973365740239732, 0.16787331682078843, 0.08292643316707471, 0.20814120649932688, 0.1279211453614043, 0.35154373171240383, 0.14074905436744645, 0.8023213157910414, 0.2114627793463827, 0.15525174592892077, 0.213694147185007, 0.18214906348298632, 0.1822877546726026, 0.17852481874901982, 0.20436549616565303, 0.17692304829360983, 0.1873540754032671, 0.17939247563762806, 0.1772861508383572, 0.17561340544908766, 0.08124522158221226, 0.08978045675483393, 0.08111778013331272, 0.07709137007412015, 0.08352346779236342, 0.08193626253646868, 0.07110787016824849, 0.07796387241750014, 0.0824075881279116]}, "mutation_prompt": null}
{"id": "4b7ba9cc-aa0d-4e7e-9351-d84b3a4d22aa", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "da66f7cc-08eb-4760-a4b5-d5150faf43c2", "metadata": {"aucs": [0.8548318385729348, 0.872653021443316, 0.8652536735112889, 0.8960424015381643, 0.8618573997873242, 0.898481482903389, 0.8916460748618078, 0.8395895177912309, 0.8614849515074394, 0.7832347976856403, 0.7812727217138351, 0.761678003804076, 0.766912193125078, 0.7742793114758036, 0.7908259298654678, 0.7865636735794322, 0.7117836086703349, 0.7720212242965693, 0.6617146979727642, 0.14748796721941582, 0.1450861292877016, 0.13851788236753293, 0.16997729346783474, 0.17611175246839772, 0.11249566391301213, 0.12704268620858583, 0.14972834149319225, 0.09276430119672219, 0.16479991406555416, 0.13028980597096584, 0.11271049728875027, 0.1171729071098151, 0.15183487480308266, 0.10725929301580583, 0.11355320224387633, 0.11750984654383845, 0.9833424689668839, 0.9654388062752698, 0.9650462295588489, 0.9752180238801252, 0.9777533358445616, 0.9926075243690655, 0.9770260779429703, 0.9896002674321291, 0.983901633138145, 0.606975557061285, 0.5156634547615945, 0.5837755942363012, 0.621574103386666, 0.6296580534177081, 0.6148050812267977, 0.6019218780310516, 0.6235849328680237, 0.6678229133126679, 0.22557620908533882, 0.7839059649206297, 0.8841260739400381, 0.17321701013800883, 0.2514621815814657, 0.8513894757080122, 0.7916687145249199, 0.7608605096398121, 0.8595745593017013, 0.12676823505718826, 0.13387539724167075, 0.4009095820146594, 0.12762934925869762, 0.4183289801457517, 0.43758382249047545, 0.44511925336579794, 0.33941978503492654, 0.1324958754344442, 0.37187630083756107, 0.31497161015486996, 0.2713487112167996, 0.13175148268917014, 0.12278842937778023, 0.34134175666956457, 0.3832512501442662, 0.29373917137407934, 0.5526834092103177, 0.07499757792106998, 0.033028783021207486, 0.12015090546269169, 0.05112619649586647, 0.14439085831215448, 0.08772845194281764, 0.2008748841006177, 0.04928704254459826, 0.11316990193349086, 0.10325038768722206, 0.09740302290511504, 0.1575658018961973, 0.2523018856595388, 0.2691067699579177, 0.2845178041791563, 0.5192483212057037, 0.18631575636953035, 0.14329047930071104, 0.21494476404576912, 0.058620860851931855, 0.05001180023498142, 0.09476294023547749, 0.10974958469389151, 0.14290504732295706, 0.2523294778235642, 0.19101399842763822, 0.07156976531758719, 0.2984843679013447, 0.2166503377545992, 0.3105191709301902, 0.35762319304981327, 0.2736671569005069, 0.3426995597142627, 0.2050072336624198, 0.23887188947544924, 0.23892535811074067, 0.6594723262387852, 0.673669847630006, 0.6844728086148513, 0.6241593308994504, 0.6288555770028349, 0.609330732140837, 0.7420212795479343, 0.648101512817916, 0.6293571777625386, 0.10811106375998791, 0.0964301121756369, 0.11272416942100372, 0.086735718170737, 0.08762716979984575, 0.08863345616221663, 0.07876179031338093, 0.08711501959326173, 0.13636899739975106, 0.7288151967493938, 0.24653946563393425, 0.16892088669115002, 0.1968681207119387, 0.321559933105111, 0.5889682095652952, 0.17633759488531164, 0.15436006900017984, 0.17320944187751175, 0.4538199159561146, 0.31181281961323737, 0.397465379030257, 0.3504804025047934, 0.42309067460723626, 0.3652615284811468, 0.5243362021654452, 0.4276947454060872, 0.5401146194457727, 0.2557371274356919, 0.2693477636611349, 0.19784070848552315, 0.30869566167569207, 0.2392425356733886, 0.23236312023037708, 0.3011240271377704, 0.28260298015165075, 0.27246688253099605, 0.19564735911117892, 0.16914847589560977, 0.19014833249503582, 0.20267393413063162, 0.1671794962689681, 0.19071192329076336, 0.17951590564453457, 0.20508383481160652, 0.1986995978087691, 0.24419725714418616, 0.19941785163382397, 0.18476689294996307, 0.23947431045187673, 0.2241324517684904, 0.2001797398005486, 0.2368582268078867, 0.1867700929180025, 0.20287994707968093, 0.8727280756692124, 0.8913286495526961, 0.15413543682634068, 0.9153001509334646, 0.8873429939036275, 0.19805283018761077, 0.0996744172654519, 0.16973365740239732, 0.16787331682078843, 0.08292643316707471, 0.20814120649932688, 0.1279211453614043, 0.35154373171240383, 0.14074905436744645, 0.8023213157910414, 0.2114627793463827, 0.15525174592892077, 0.213694147185007, 0.18214906348298632, 0.1822877546726026, 0.17852481874901982, 0.20436549616565303, 0.17692304829360983, 0.1873540754032671, 0.17939247563762806, 0.1772861508383572, 0.17561340544908766, 0.08124522158221226, 0.08978045675483393, 0.08111778013331272, 0.07709137007412015, 0.08352346779236342, 0.08193626253646868, 0.07110787016824849, 0.07796387241750014, 0.0824075881279116]}, "mutation_prompt": null}
{"id": "535e98be-ae2a-4d2e-be77-dbc3bf5fcde9", "solution": "import numpy as np\n\nclass EnhancedAdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def adaptive_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = 0.5 + 0.5 * (self.num_evaluations / self.budget)  # Adaptive scaling factor\n        mutant_vector = np.clip(best + F * (a - b), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.7 * (self.num_evaluations / self.budget)  # Adjusted crossover probability for more exploration at the start\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = 0.1 / (1 + np.exp(-0.05 * self.num_evaluations))  # Reduced step size for finer local search\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.adaptive_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "EnhancedAdaptiveScatterSearch", "description": "Enhanced Adaptive Scatter Search with Dynamic Exploration-Exploitation Balance using Adaptive Mutation and Local Search Intensification.", "configspace": "", "generation": 90, "fitness": 0.3410052019658031, "feedback": "The algorithm EnhancedAdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.29.", "error": "", "parent_id": "da66f7cc-08eb-4760-a4b5-d5150faf43c2", "metadata": {"aucs": [0.9307401338831391, 0.9320354601866364, 0.9396034478145542, 0.9216180786779812, 0.9236241127293753, 0.9274306827869312, 0.9162272278956621, 0.9347131398791352, 0.9332830512287486, 0.7682898774005643, 0.8823271716656436, 0.8153398979447294, 0.811382193818575, 0.816448904503088, 0.8209169758415823, 0.7900734737610198, 0.7916804686661243, 0.8340709131515798, 0.144947061433932, 0.12432974967153676, 0.13296412059103424, 0.12104327456319464, 0.13242179432888768, 0.11852498131559097, 0.11758941401091072, 0.18315317146556265, 0.08701314224991497, 0.1814791379903682, 0.13011181784985548, 0.10585414003887095, 0.1052667453881253, 0.10466833142417786, 0.0961859470682952, 0.08948924671516012, 0.11119523758700323, 0.1051786729063815, 0.9856927006777643, 0.9617190490856891, 0.9487796662856374, 0.9853946370460119, 0.990689269723028, 0.9788256362441558, 0.9919105108991317, 0.972762771581892, 0.9799530119999404, 0.7743333928901033, 0.7697022671830837, 0.7965843550365743, 0.7495704794151519, 0.7509152644787993, 0.750213882659863, 0.7656854755137674, 0.7522867085549895, 0.7910750789637011, 0.20541605734634916, 0.12740050451554963, 0.3898838636676195, 0.22090706416745953, 0.19450660710252243, 0.18796845671840223, 0.22018431993862742, 0.17665842650348296, 0.23677132234250353, 0.3019464647803185, 0.4577844192131839, 0.5283984223781948, 0.13654294687582347, 0.5214394337897594, 0.3413236895750307, 0.46523682215904993, 0.49229259436145734, 0.13507517613283215, 0.5683862121964861, 0.33767397561271884, 0.36080493656727586, 0.5903751275881417, 0.2650046560143028, 0.5747587468708758, 0.525187777445012, 0.349642140175755, 0.12427156621960489, 0.05189241450770565, 0.11165541699156634, 0.1254095047627557, 0.03084021133513648, 0.02900847532781703, 0.016766302133795263, 0.03389293666829163, 0.05736500048475213, 0.04873061940831591, 0.16542206613749255, 0.10217977988753446, 0.1541626571441197, 0.14968719081573434, 0.1556163611815593, 0.035562500793490326, 0.15317954770794495, 0.2266185842410956, 0.19696122526613413, 0.10822945637220005, 0.05584069535955727, 0.07383413533557837, 0.13080035263226963, 0.14771745247963897, 0.129513041389265, 0.1907825077581179, 0.19709301389888811, 0.07735942027079978, 0.2301060068316677, 0.1987623654026679, 0.15813145556738895, 0.29121328893411214, 0.23206061539123324, 0.2919682694528245, 0.12862946776587791, 0.29810413268101665, 0.24525046307729337, 0.6335371940771022, 0.6807721068491197, 0.6804835624832761, 0.6501354838231546, 0.6395362414487877, 0.5752557211873084, 0.7220888402836048, 0.6614351832122797, 0.6988929148965572, 0.07672256172816938, 0.07636522286543346, 0.08370591048674214, 0.1857477869060894, 0.09158017880619806, 0.08986862970032894, 0.10949596515360138, 0.1381562969506358, 0.08200888431467335, 0.3961254412279591, 0.34066148513646477, 0.17334960113570252, 0.35956910160404243, 0.7385280345412133, 0.1689989612851046, 0.19559962730340708, 0.2133776184145285, 0.2477810749914463, 0.19401213444715426, 0.2198194406909153, 0.3524654424566428, 0.24100548979273095, 0.25046624229854686, 0.29958930365021774, 0.31906283018367676, 0.33896477973133865, 0.1983376307884286, 0.22977205785242705, 0.2774524877421636, 0.15437592213052664, 0.19145352478019673, 0.31764710079318825, 0.3013463954342319, 0.18434936223079224, 0.20345648613154022, 0.10064868571117858, 0.22103169961182556, 0.2274223438514016, 0.22265075623464292, 0.1907010664725184, 0.22194006020847223, 0.20169712615603785, 0.22113876999744841, 0.1971684205087031, 0.23336734116506952, 0.19827972516392678, 0.187800367463424, 0.22910670661407617, 0.19800119066662003, 0.2117218169222671, 0.17690265880295297, 0.1935336755626158, 0.21691584786994167, 0.2003798235622427, 0.10492595312540942, 0.18801875428924208, 0.1546979482206099, 0.9443444718933421, 0.20179649869069716, 0.14920492057063295, 0.12262693405616953, 0.1653000978067981, 0.16832890268248868, 0.08313731548322245, 0.21278003415895697, 0.051767241730081515, 0.21012340671667706, 0.9180613409157523, 0.212906455067279, 0.1048642353743795, 0.9039962112622654, 0.895162859708846, 0.17997071759967098, 0.18047472372849083, 0.2206196371974154, 0.1714554006504173, 0.1805567139301294, 0.19609854073367927, 0.18170839459273924, 0.17209772374061616, 0.19089217925021185, 0.08992558776848969, 0.09375769073778517, 0.09016473415784454, 0.080772390690931, 0.09064366071412411, 0.07553555322262673, 0.07021083671787798, 0.07723656192881534, 0.04569062867858864]}, "mutation_prompt": null}
{"id": "f6144827-bcd0-4d9c-9217-f185e078592e", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = 0.8 + 0.2 * (1 - self.num_evaluations / self.budget)  # Decrease F over time for exploitation\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)  # Adjusted strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.4 * (self.num_evaluations / self.budget)  # Adjusted dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.15 / (1 + np.exp(-0.1 * self.num_evaluations))  # Adjusted step size\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(20 * (1 - (self.num_evaluations / self.budget)))  # Increased population size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Enhanced Adaptive Scatter Search with Improved Diversity Control and Step Size Adaptation for Robust Global Optimization.", "configspace": "", "generation": 91, "fitness": 0.17199178826552405, "feedback": "The algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.18.", "error": "", "parent_id": "da66f7cc-08eb-4760-a4b5-d5150faf43c2", "metadata": {"aucs": [0.33879266334925806, 0.3725595606540466, 0.3243225853791878, 0.37146830257497854, 0.3955664510690281, 0.3930402706553383, 0.36735667901721913, 0.36852172130414473, 0.3881187371487227, 0.12341041655636398, 0.10521968711955654, 0.09352282423419456, 0.1039063959599329, 0.10619974113804764, 0.1162985508619917, 0.10281136394117407, 0.1620138246351589, 0.13312972487585994, 0.08626694319543826, 0.07345719739754664, 0.08410608354496141, 0.0884433705727462, 0.10603419504578526, 0.07941127141449411, 0.07324477011504382, 0.07785703733293936, 0.07853094875010957, 0.07948418236853172, 0.06576345345378465, 0.062429697965374675, 0.06237248472470658, 0.08058247965327159, 0.08258644242129431, 0.06732472463021366, 0.08147780377712266, 0.07140359677122032, 0.9489825408802885, 0.949203606511046, 0.9337573726870113, 0.9414092021284366, 0.8821378345392134, 0.9631591078490271, 0.9642963372551422, 0.9237320480356193, 0.9168499292038061, 0.14605057740234684, 0.14807798550489992, 0.1512026990738654, 0.12493668890932463, 0.14780181436036988, 0.14367907312759876, 0.1697750742275932, 0.17689992984121383, 0.14471545157094556, 0.19044480988039447, 0.19241784781590832, 0.15834485767499717, 0.19411424691794688, 0.2011669634642308, 0.1925561666607245, 0.21009079530158248, 0.19854633308327707, 0.1869499909117217, 0.07511816920532632, 0.0811125753240376, 0.07693797079975595, 0.06873779885493536, 0.07828473666458868, 0.08357547816229294, 0.0705548991476137, 0.08394277515739834, 0.07912224066000251, 0.11346505064659251, 0.11989332701031796, 0.09903374347534155, 0.08540727744764587, 0.07734800953893373, 0.08775481655645312, 0.08489539480525177, 0.07649691375871137, 0.08423908510824951, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005663081421727112, 9.999999999998899e-05, 0.002672350233892229, 0.024039322469233793, 9.999999999998899e-05, 0.002327263726153217, 0.10433754643709359, 0.09027510074364853, 0.08285644849500262, 0.11464552451872345, 0.1313342561702482, 0.0980781372315892, 0.10261484774029561, 0.08919937553588875, 0.10360284521318663, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04397005056579295, 0.05759500737008616, 0.04349638487256491, 0.043907434160215364, 0.05646015199353693, 0.05365165118326454, 0.06074978674005249, 0.05276228350621537, 0.04185685745239176, 0.3084550501150807, 0.32043982393294523, 0.315418336503533, 0.31466491925757, 0.3239443012651636, 0.3104125510996386, 0.31262145126938123, 0.2780159491043892, 0.3186615336927543, 0.07928410896994587, 0.06999246587296115, 0.07792158845764696, 0.0807868349449613, 0.071647210942829, 0.0769288318085164, 0.05846399069362995, 0.06366863466523154, 0.06304382036358092, 0.14054265644681285, 0.15461650845360542, 0.14283015873152705, 0.15994232054543422, 0.15437869659056702, 0.13698214320155422, 0.2023409194923138, 0.12743643822673112, 0.13226620387328658, 0.1852841790043831, 0.20748172277499932, 0.20184385283960948, 0.18904705346839057, 0.17626230802850174, 0.18485086782738835, 0.19417933907577578, 0.22279584717938583, 0.2277215046286527, 0.15822129948761554, 0.13802454857851587, 0.13706025619090867, 0.12435122237807861, 0.13951750230918036, 0.1408391311164272, 0.1434056891221831, 0.1576614061384255, 0.14645086505358562, 0.1663903935001021, 0.19273171190943328, 0.1729771942433408, 0.1767869716522702, 0.15708883971784648, 0.1661005222879075, 0.1635365800556987, 0.18729514231154099, 0.17024609075082886, 0.15743959242379957, 0.1647804729216087, 0.17033672291271929, 0.15107237091001335, 0.16634684947452993, 0.16320792580481447, 0.15989069515034549, 0.16096803763713452, 0.1741369271360319, 0.24910812053680298, 0.17245556223834124, 0.2931211315265734, 0.17890523815154324, 0.1662607566775901, 0.1793368565626452, 0.1580194014822104, 0.18944905562739245, 0.16122436811384055, 0.17358738795563877, 0.1642804361112965, 0.15783152825360014, 0.17150833966002632, 0.13312973015800633, 0.23570074202986002, 0.3380539065408247, 0.3540058362334183, 0.39599516921456257, 0.1720567657845702, 0.17633169386757763, 0.17304198836491635, 0.1898369279205152, 0.19170668101663624, 0.18702522199412686, 0.18281622658359797, 0.17370499145420604, 0.18215719435454347, 0.06777372923572456, 0.06065253291321038, 0.06390950514482296, 0.054949720621347065, 0.0628933934964847, 0.054442485500547644, 0.0676507243022263, 0.061113753157775674, 0.06239863951105218]}, "mutation_prompt": null}
{"id": "bed7af14-41c4-4578-bd6a-c5a0fb5734d0", "solution": "import numpy as np\n\nclass EnhancedAdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.6, 0.95)  # Adjusted F range for better diversity\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.75  # Adjusted to a fixed value for better stability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def sinusoidal_perturbation(self):\n        return np.sin(np.linspace(0, np.pi, self.dim)) * np.random.uniform(-0.5, 0.5, self.dim)\n\n    def local_search(self, solution, func):\n        perturbation = self.sinusoidal_perturbation()\n        new_solution = solution + perturbation\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 20  # Fixed population size for stability\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "EnhancedAdaptiveScatterSearch", "description": "Enhanced Adaptive Scatter Search with Dynamic Population Control and Improved Local Search using Sinusoidal Perturbation.", "configspace": "", "generation": 92, "fitness": 0.32195173128961163, "feedback": "The algorithm EnhancedAdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.25.", "error": "", "parent_id": "da66f7cc-08eb-4760-a4b5-d5150faf43c2", "metadata": {"aucs": [0.7989182436269477, 0.8061815103374745, 0.8713076562980742, 0.18984828870227521, 0.8341004891478889, 0.8145991937275872, 0.8283588143865803, 0.8572962045245424, 0.820717451562029, 0.6658879421710977, 0.04067631877162492, 0.68519111165592, 0.6242193096513536, 0.6579962696526986, 0.6539974173298374, 0.6866204194494656, 0.6901768622638267, 0.7080669229704921, 0.1699082177446899, 0.11858485797523266, 0.5248353875090175, 0.13195793514595966, 0.15939697095366212, 0.14564211507309555, 0.1626266119680464, 0.15612197919965842, 0.13165481710277271, 0.13382285520516324, 0.10339156089747936, 0.12227477015921051, 0.45923839296386415, 0.1299583415370389, 0.1582591768503353, 0.13786806861135714, 0.11378980804106764, 0.14631229473813123, 0.9796261589054753, 0.9758684866857713, 0.9706686825743709, 0.9755789890791045, 0.9768931655661781, 0.9761377852885553, 0.986167047848202, 0.9862307523197491, 0.9531624019368493, 0.4224222213401283, 0.3956257123511978, 0.4154536694729174, 0.39473801118555973, 0.43137947890342687, 0.4174489807080134, 0.42019290720902225, 0.510439750864125, 0.4081326612288505, 0.7327669714719435, 0.6751737821077228, 0.7205377956892242, 0.7888111852439246, 0.34145195880418977, 0.2703204129585852, 0.6993373448631801, 0.23219716667693546, 0.6988211935302907, 0.12190362136434474, 0.2959816243013512, 0.12834050523526241, 0.09914318635679265, 0.3461271305682997, 0.13109032771417117, 0.12660087293973632, 0.3623089568843476, 0.13016450880604824, 0.27947361403065674, 0.12059060084624906, 0.31332388127896504, 0.4584987340545744, 0.42596377319900325, 0.12917444959474578, 0.3522678313089914, 0.25661937912333554, 0.2793717012163536, 0.04865902319322157, 0.06963388922631653, 0.052680698948978755, 0.0494519899665431, 0.038101087960608626, 0.12850986661048103, 0.13025038513897724, 0.10247179573160736, 0.11851758372030397, 0.15098596673843334, 0.07570282741020751, 0.24579799143929693, 0.14272305751363834, 0.21633054095044657, 0.20946192998860602, 0.28138717732692364, 0.2732015686035013, 0.10438164871126232, 0.041671115256648794, 0.0377913719864188, 0.05370978221454348, 0.07140735789975572, 0.09776694350709514, 0.06950222857721677, 0.16444225851863048, 0.09774567191888395, 0.11383805305878647, 0.20283903491639588, 0.20028394343161215, 0.22125046478056487, 0.23803689282989526, 0.27565923438786555, 0.2116243675805326, 0.0478086260777425, 0.17984888773040786, 0.23380144823046212, 0.598334111934419, 0.5822771112016972, 0.566877629707196, 0.5444838442545394, 0.549607098763669, 0.5872940421320784, 0.5696908666326513, 0.54653005674809, 0.5971710024365028, 0.10168636703587108, 0.12379902014897148, 0.10887137728069429, 0.1071001125957689, 0.11935769177451816, 0.10497883230412897, 0.12112395593105008, 0.1336540562928058, 0.11471696028566836, 0.3491327799251053, 0.13198548467751847, 0.2866908701324159, 0.18611525520553984, 0.23510501228270186, 0.41300416409734675, 0.2887859605412023, 0.20547090276863123, 0.2233702266000518, 0.37292656085126263, 0.2434344304224687, 0.3462074175019142, 0.34630364572834127, 0.210563901771604, 0.4265912868712749, 0.38778585181772296, 0.4266374841878282, 0.4453257099009005, 0.2270553622309167, 0.22878042575280766, 0.2747068719521548, 0.3110259220954017, 0.2436630909162646, 0.2792351728101041, 0.2830429458102942, 0.3241869649632134, 0.3377678641875216, 0.19380783250895128, 0.19591039051500825, 0.1978880181463346, 0.21874379361657625, 0.2164291818636117, 0.1900835766861383, 0.19588089255467345, 0.20018403445652067, 0.18307722283381322, 0.23696395358363076, 0.2348747037373552, 0.22360339744435842, 0.5677854663638069, 0.5726863064841103, 0.2417307336611807, 0.23599756828958263, 0.20829623477499892, 0.20084783048334043, 0.16294432818491078, 0.19069729948367653, 0.15368963988969753, 0.8584818012027876, 0.19140892155345435, 0.18667801594899713, 0.16294155056790316, 0.1665811355915997, 0.16036168187763034, 0.15304283333929725, 0.20606399151996224, 0.6903783972726204, 0.12259494601873899, 0.14740056549379021, 0.6590929042891243, 0.21048292345552166, 0.7955224405548249, 0.7229443381153386, 0.18135450515165874, 0.1737886919467554, 0.18473770690113034, 0.1943649134253902, 0.16907449982847333, 0.17410127265894948, 0.178335852790655, 0.18077689934589292, 0.17964976759567708, 0.0801872745303357, 0.08608599326613875, 0.07873057046202903, 0.07952596417401381, 0.07627609860589146, 0.07083385405518983, 0.07722651632510591, 0.08126871346193076, 0.0770896345791654]}, "mutation_prompt": null}
{"id": "78512f62-5880-4b3f-81fc-81a36dac260b", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        chaotic_initialization = np.random.rand(size, self.dim)\n        chaotic_map = 0.4 + 0.6 * chaotic_initialization\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * chaotic_map\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        elite_idx = np.argmin(fitness)\n        elite = population[elite_idx]\n        F = np.random.uniform(0.5, 0.9)\n        mutant_vector = np.clip(elite + F * (a - b), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Refined Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability, integrating Elite Preservation and Chaotic Map Initialization for Robust Global Search.", "configspace": "", "generation": 93, "fitness": 0.3744332310295768, "feedback": "The algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.28.", "error": "", "parent_id": "da66f7cc-08eb-4760-a4b5-d5150faf43c2", "metadata": {"aucs": [0.8647330365179733, 0.8538938870264359, 0.8883030627280726, 0.87893147466306, 0.8730275681207329, 0.8655864430877314, 0.8651677416844676, 0.8751984084870799, 0.8628296444147894, 0.722462688350881, 0.7185800083257825, 0.770315677147486, 0.7812950856103118, 0.7915337708323544, 0.7616177547402718, 0.7171507487215175, 0.7291567788819054, 0.7455498335960338, 0.6127773147461685, 0.13438180254362253, 0.11687894459224846, 0.14617578067204196, 0.13179285269231245, 0.13424305217781896, 0.15046862681014916, 0.16811646284882187, 0.11739042244215436, 0.10170038505834855, 0.15156478745588498, 0.6259186328921875, 0.13161041854014877, 0.11795372773561963, 0.13953978569131975, 0.10048380091796238, 0.11212377164282317, 0.13497510712274619, 0.9877411969909206, 0.983235438584774, 0.9765760544732575, 0.9729247764225398, 0.9858310617933008, 0.9820437297089839, 0.9718488725895917, 0.9823817525430708, 0.9875129286547003, 0.6191797446974461, 0.6012880801216318, 0.6226040138497679, 0.6410723655608281, 0.6016951830514451, 0.6288922598449533, 0.607026281956627, 0.6490202957330358, 0.5962892805258408, 0.7394682012550353, 0.6648214216685113, 0.38528298448661424, 0.8613869300589084, 0.19435241385160773, 0.8129170654019027, 0.792603227134037, 0.3655352447251906, 0.20691759768170037, 0.1311614814752493, 0.3904555925408507, 0.12490670115986091, 0.1278784709693629, 0.5381870422048494, 0.38142982097225153, 0.12909169767992612, 0.3475341412464059, 0.12396415493911084, 0.2904498891311176, 0.35968064827306245, 0.5467156473731021, 0.4992460947611631, 0.5208942780531325, 0.13188658371316775, 0.4750398467502177, 0.4849777374264912, 0.4385676741945008, 0.22154527639454447, 0.08945366246013231, 0.10422404012897146, 0.052954827325189746, 0.0994867081294677, 0.11717686555568385, 0.023336838232162926, 0.07283456812131883, 0.02685324728970029, 0.09502045130331882, 0.10548770916500039, 0.10954834417038728, 0.2984865027216973, 0.12387135135473781, 0.15846867895148775, 0.25242658037205445, 0.3904128427084169, 0.3624084455776755, 0.05265993608160857, 0.2250632131539353, 0.04768869816928656, 0.1452589332066, 0.0769262680454803, 0.19174615133577955, 0.10008177178015776, 0.10330272431398457, 0.14262311593321064, 0.2544110528211079, 0.2531285687712713, 0.2899881051638147, 0.2883251920631791, 0.23456485852793996, 0.2673898463652902, 0.21550309861436712, 0.25969223795905494, 0.3074552285846961, 0.5920281376865923, 0.6572383251109235, 0.5978697785017274, 0.6204672325062939, 0.6695826374863141, 0.6372746235084628, 0.727467489481021, 0.7060418972817679, 0.6246620597072755, 0.10906263388072224, 0.6515680112173371, 0.13268843810499653, 0.09583651945660843, 0.1157618965063022, 0.14198433104576302, 0.10771526672452858, 0.08186225977581629, 0.08042175683046004, 0.39687406397138336, 0.2504688180353529, 0.383304056370659, 0.287374656004903, 0.23274752676459287, 0.47637195364370166, 0.39468898150304954, 0.1537728187090759, 0.32891949503298235, 0.3749907779030165, 0.4731327665585252, 0.4143451463118094, 0.4352593161427015, 0.4185103265997355, 0.40847521158041755, 0.3358427156056739, 0.527439286224592, 0.3541495306836966, 0.2983366995171962, 0.25961614232500163, 0.25291008643988133, 0.23387585834854818, 0.3158248550117493, 0.2297863208038864, 0.2415223989717189, 0.34976351235765235, 0.38192673454334314, 0.18322049472126023, 0.19496304121071328, 0.19679190854659812, 0.2292318066849074, 0.1915771287660003, 0.21727862744291493, 0.18888195310504474, 0.17365853138844034, 0.21477924724381692, 0.2296913199386178, 0.22282799179715485, 0.19421164045897232, 0.24135220221776255, 0.20551589439181706, 0.21914836888361222, 0.20582907796643946, 0.20708881114716138, 0.19856816839518154, 0.16930931383785552, 0.18551504186360557, 0.15781831109208688, 0.16428667683163478, 0.19706638810023336, 0.9154021798378739, 0.8969678979712128, 0.11707077657064979, 0.909897696605846, 0.809762161691562, 0.8723357992455956, 0.8491578685538376, 0.16926321469847339, 0.16784055433339584, 0.16848919458285783, 0.16582589867484598, 0.8491887308707138, 0.8977017100415476, 0.1798592753999061, 0.18068096020068192, 0.18559519711039474, 0.1760675711814521, 0.1930927473082792, 0.20246395308522336, 0.1981612220372072, 0.1808575261881158, 0.17867445039649887, 0.07468175368640717, 0.07932670601148895, 0.07283069169206446, 0.06883581202361855, 0.08083303194378444, 0.08981976465876162, 0.09338221965208482, 0.09510067049335447, 0.09428423222925086]}, "mutation_prompt": null}
{"id": "68b7948c-3669-4320-9488-da0170c0ed1f", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        chaotic_initialization = np.random.rand(size, self.dim)\n        chaotic_map = 0.4 + 0.6 * chaotic_initialization\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * chaotic_map\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        elite_idx = np.argmin(fitness)\n        elite = population[elite_idx]\n        F = 0.5 + 0.4 * np.random.rand()  # Self-adaptive component\n        mutant_vector = np.clip(elite + F * (a - b + c - elite), self.lower_bound, self.upper_bound)  # Enhanced mutation\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        initial_pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(initial_pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            current_pop_size = max(5, int(10 + 10 * (1 - (self.num_evaluations / self.budget))))\n            if len(population) != current_pop_size:\n                population = self.initialize_population(current_pop_size)\n                fitness = self.evaluate_population(population, func)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Enhanced Adaptive Scatter Search with Self-Adaptive Mutation Strategy and Dynamic Population Sizing for Improved Exploration and Exploitation Balance.", "configspace": "", "generation": 94, "fitness": 0.2768568167194773, "feedback": "The algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.23.", "error": "", "parent_id": "78512f62-5880-4b3f-81fc-81a36dac260b", "metadata": {"aucs": [0.7074033542597594, 0.7022859370928876, 0.7026789813951373, 0.714765850457378, 0.6923250633717641, 0.6845064672028768, 0.6802380766677136, 0.6775291698546737, 0.6409133812904473, 0.42369254882515583, 0.42404073053279967, 0.421134045721524, 0.41249658462910166, 0.3626333016160366, 0.3684559872073976, 0.3126512484245564, 0.38374293511067303, 0.3588293533789445, 0.08825643585191123, 0.11125663520091511, 0.11027400358091943, 0.11495604645362312, 0.10144337059597441, 0.12646585473440486, 0.1027420596372145, 0.12320673620704659, 0.11908950969426735, 0.09320715522315581, 0.10990761882042732, 0.1098227194079886, 0.09998249981811569, 0.10753949277795183, 0.11499597798996852, 0.09135864695034857, 0.09626215203945865, 0.0873451427598606, 0.9272388869222187, 0.9485678793505488, 0.9220669245119861, 0.9495604830301161, 0.9144125239527904, 0.9208084945988821, 0.9003308185577125, 0.9324039423848031, 0.9040693398005625, 0.29616139470221237, 0.2827035827632248, 0.28289991482164367, 0.2808198499943957, 0.30038611701391427, 0.2618491958885615, 0.32995958663424074, 0.3018932236302393, 0.28303242654551053, 0.3613395021607162, 0.8400839958385733, 0.7832415523564064, 0.7999857588620582, 0.6258788844689522, 0.4269465936412543, 0.37476129667703284, 0.3648611447082233, 0.353035256355946, 0.23250314281981022, 0.19157383146481166, 0.17195520120880614, 0.2158068650178805, 0.16158027050821833, 0.12569571101292154, 0.23507206045536466, 0.1771222329561467, 0.14190731685079372, 0.17328074286956308, 0.14659454794518645, 0.1762883975570323, 0.16041230121008487, 0.17828378277211598, 0.16694273713007513, 0.18984898792693872, 0.18185185653098956, 0.21719429624732212, 0.035933902418542885, 0.04113731713225699, 0.08830087733664482, 0.04584191047451458, 0.01834232267245406, 0.045511384068426586, 0.03987643078386793, 0.04100946662152671, 0.04702960686769553, 0.17815206667952266, 0.155780674448036, 0.16005982763919202, 0.21651819470397793, 0.25153757180899206, 0.16041744292900806, 0.20898351672906967, 0.1825809432489024, 0.14353813436621077, 0.12298675392678049, 0.03840276235453488, 0.029812275483911632, 0.016634791534862914, 0.018861206260198604, 0.06939164714455459, 0.06014727326222946, 0.02351801070900328, 0.040928447353891895, 0.14537522912875378, 0.13298387650047994, 0.12077173219041326, 0.19621960210713196, 0.18845642595961865, 0.13697580186089764, 0.14951347532315462, 0.1281721711024444, 0.14279927610310894, 0.5030242533764642, 0.4926955817777935, 0.5223368334739333, 0.49177347468234944, 0.493806405625022, 0.4932381055319167, 0.5040908964016699, 0.48698790179312756, 0.49059248855842663, 0.09984438425936482, 0.09331175573648831, 0.08414053166565116, 0.0890352928476299, 0.094270729156406, 0.1072829647412209, 0.08046468080358449, 0.09117306149946547, 0.10443235634032555, 0.13160329441259377, 0.14110707873903316, 0.12695870605090476, 0.1566689808093923, 0.1203240678481321, 0.1328333343108241, 0.15124489005030595, 0.2523201462534954, 0.117188137045519, 0.31938526586878413, 0.29843106081193604, 0.29294282712857833, 0.30048090276563966, 0.2844212102381499, 0.288764283252565, 0.3032320880512752, 0.30261210901321123, 0.3161533545100811, 0.22772777460960159, 0.2603763937641934, 0.2271152255702048, 0.22459004200770194, 0.2272909042609691, 0.2251354171940353, 0.19759897624970313, 0.2095608592568461, 0.22928632063777943, 0.2280005686656743, 0.19416983371390006, 0.19656450483559507, 0.21627383272471878, 0.20196154331245797, 0.19029342948020567, 0.1880569867753894, 0.20256565547429284, 0.19735491478276412, 0.17796479290271605, 0.18119812943452007, 0.18598244633999783, 0.18845907757103264, 0.18464395662579758, 0.182146852425502, 0.20863674418815203, 0.18778252179994692, 0.18391450091253891, 0.17920340348436747, 0.1838955091709339, 0.16940645036190838, 0.8496804555076312, 0.7791727656679225, 0.6281681784682722, 0.44304181522295016, 0.24802678832771896, 0.730728937727481, 0.523604921315208, 0.5628569440566895, 0.4266422695494867, 0.16826523135398075, 0.16637049303411566, 0.16795246468941294, 0.6206959413273558, 0.6294887654589663, 0.6129303821797182, 0.176642683470562, 0.17182024205411706, 0.17082292749500938, 0.16927548001100967, 0.1798283387464984, 0.18061063705674618, 0.17751419355993292, 0.17420845517778694, 0.18009244306994476, 0.08679024903219756, 0.07007501438781705, 0.0749973052500078, 0.08299253544787621, 0.08293929316570425, 0.07355101148759224, 0.08547846292558914, 0.08386328618595962, 0.0914622183571524]}, "mutation_prompt": null}
{"id": "bd2da91e-54e9-4575-bd4e-4afdb59935fb", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        chaotic_initialization = np.random.rand(size, self.dim)\n        chaotic_map = 0.4 + 0.6 * chaotic_initialization\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * chaotic_map\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        elite_idx = np.argmin(fitness)\n        elite = population[elite_idx]\n        F = 0.5 + ((self.budget - self.num_evaluations) / self.budget) * 0.4  # Dynamic F\n        mutant_vector = np.clip(elite + F * (a - b), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        adjustment = np.random.uniform(0.8, 1.2)  # Dynamic adjustment\n        new_solution = solution + self.levy_flight() * step_size * adjustment\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Adaptive Scatter Search with Enhanced Differential Mutation, Elite Preservation, and Dynamic Levy Flight to Boost Global Search.", "configspace": "", "generation": 95, "fitness": 0.3318711227945761, "feedback": "The algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.", "error": "", "parent_id": "78512f62-5880-4b3f-81fc-81a36dac260b", "metadata": {"aucs": [0.7587931461288164, 0.7542176140597332, 0.7540594251192048, 0.7683736792261628, 0.7305176739059417, 0.7949488151514392, 0.803739755135113, 0.7711979377153114, 0.7662991582343215, 0.6143152611977082, 0.6144363093563111, 0.5759045369375854, 0.5567310263552753, 0.5763748470168388, 0.5853550631067506, 0.5155447518198909, 0.5564739902484532, 0.5994990323683407, 0.14078529284147157, 0.13440437743275102, 0.1425701245954638, 0.1441001337485437, 0.1472617017815131, 0.1533961529239768, 0.1216306730521235, 0.1497607027741884, 0.13022224721292874, 0.13802933131240003, 0.15956665860477603, 0.37042646223502884, 0.12496079179692221, 0.17143194129095407, 0.11291916261959845, 0.13715249192725154, 0.12627663462328487, 0.11917440066356955, 0.9971504668384996, 0.9907344696246084, 0.9795298717322848, 0.9873861024511783, 0.994850301568939, 0.9833783902285262, 0.9862093882003131, 0.9824166697895453, 0.9824286755494309, 0.42176682828888257, 0.4343478158546571, 0.4004721824420947, 0.4288806584503081, 0.35724768929279094, 0.41183309696836823, 0.46516443077563785, 0.39085311504551024, 0.4181665058528169, 0.36945417475816755, 0.6862594052627454, 0.711481506190351, 0.3520330588649887, 0.332836687105718, 0.5700180459236843, 0.6940270142922993, 0.6285967108572815, 0.690430958495571, 0.23487943167976078, 0.312903365806137, 0.24724674001532654, 0.27853531607799886, 0.11511442982151532, 0.3706555251984224, 0.29643686746505404, 0.34560063123209583, 0.2641493871296908, 0.2595213504956265, 0.22973576228335357, 0.2973530139284307, 0.2598275945985976, 0.33020467954834454, 0.2894356887550381, 0.37306229389883916, 0.3352839212930072, 0.303306029679123, 0.14589824629301096, 0.09110874560320648, 0.07551845564740911, 0.0006032517314017438, 0.13773337288918974, 0.035958112307343026, 0.22205959836553002, 0.1309167672562408, 0.096239617119522, 0.30065801100802525, 0.2848312819910299, 0.21335417627432518, 0.10993167504191281, 0.28833798485553397, 0.19829058612082306, 0.2598470579948239, 0.16527607513012388, 0.2694792133843854, 0.05097762437050446, 0.043330417795215403, 0.07506143495528217, 0.0710434285697924, 0.075913177446147, 0.08288474517948374, 0.11095789014477031, 0.0665172713012091, 0.07009607416499875, 0.14811831120760433, 0.1716184704485304, 0.15512744444091864, 0.20093012454266923, 0.2037973130115751, 0.21214204209076404, 0.19244359461499816, 0.21832666315328686, 0.19252919383488576, 0.526565848635498, 0.5717912016627702, 0.5600113612795806, 0.6077110882832222, 0.5527901926370917, 0.5316231789858838, 0.5309607185404095, 0.5081120755055232, 0.5684474969023878, 0.1024552890148922, 0.10504421648633144, 0.10456636819732068, 0.10747683103849215, 0.11405443683951055, 0.10202986961373539, 0.1292384693043308, 0.09754977786792207, 0.07752163245632093, 0.22302723675381642, 0.20048624914413826, 0.1969741093073586, 0.4136714355125608, 0.14282335831856108, 0.20397782001275866, 0.4052393796847288, 0.5395039849000971, 0.21478264535021818, 0.30495682002663793, 0.3545638099522297, 0.38091811341348414, 0.3729810776819946, 0.3206225109396108, 0.35639519008429754, 0.3417416890510373, 0.3739780661115508, 0.3737987175324381, 0.26237174736771585, 0.23245962003036724, 0.2801526449398659, 0.2758228513327837, 0.26873157154869654, 0.26315724576075017, 0.2638986899597383, 0.2856066862092673, 0.26070622229036355, 0.17292334778858043, 0.16898578356716787, 0.19232081595978623, 0.17252614058929716, 0.1815252117022612, 0.1798380895086713, 0.178489061028842, 0.18972642537760787, 0.18728412257595373, 0.2057977960159414, 0.37606509549301814, 0.21844447846075665, 0.21024930253511964, 0.2060088100621842, 0.2005078284352162, 0.2135460920322817, 0.21675753768716266, 0.24194610194681487, 0.16748677495635111, 0.20633541352539653, 0.1518908141214964, 0.8023511983329562, 0.16373334054692967, 0.7667339418866699, 0.8167561073970571, 0.16903837923204978, 0.8060440086038144, 0.12493150400726805, 0.6560047709491068, 0.7503665565231146, 0.16775450260017422, 0.6911009798025942, 0.16735435728726045, 0.7503987871523297, 0.28123652097988183, 0.8148857806309395, 0.17406679608113285, 0.2124017741580415, 0.24151951632794233, 0.17593377524694298, 0.1867914153719552, 0.20369324296144609, 0.20413334429941266, 0.19244693205585528, 0.17165658366443381, 0.07365224095895795, 0.0761560987743144, 0.07607028405724725, 0.08262134069644322, 0.09679624980284973, 0.08007329473913938, 0.07013954766271802, 0.09506328156917021, 0.11238647501209797]}, "mutation_prompt": null}
{"id": "87c00c72-ac7d-415c-912e-c91f93171ed9", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        chaotic_initialization = np.random.rand(size, self.dim)\n        chaotic_map = 0.4 + 0.6 * chaotic_initialization\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * chaotic_map\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        elite_idx = np.argmin(fitness)\n        elite = population[elite_idx]\n        F = np.random.uniform(0.6, 0.95)  # Adjusted mutation factor\n        mutant_vector = np.clip(elite + F * (a - b), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.6 * (self.num_evaluations / self.budget)  # Adjusted crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.3 / (1 + np.exp(-0.05 * self.num_evaluations))  # Adjusted step size\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        initial_pop_size = 20  # Adjusted initial population size\n        pop_size_increment = 5  # Incremental step for population size\n        population = self.initialize_population(initial_pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n            if self.num_evaluations < self.budget:\n                population_size = initial_pop_size + (self.num_evaluations // self.budget) * pop_size_increment\n                population = np.vstack((population, self.initialize_population(pop_size_increment)))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Enhanced Adaptive Scatter Search with Dynamic Population Size and Adaptive Step Size Control for Efficient Exploitation-Exploration Balance.", "configspace": "", "generation": 96, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 20 is out of bounds for axis 0 with size 20').", "error": "IndexError('index 20 is out of bounds for axis 0 with size 20')", "parent_id": "78512f62-5880-4b3f-81fc-81a36dac260b", "metadata": {}, "mutation_prompt": null}
{"id": "f2e46b79-80cf-4a50-82ed-d6c57bd9762e", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        chaotic_initialization = np.random.rand(size, self.dim)\n        chaotic_map = 0.4 + 0.6 * chaotic_initialization\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * chaotic_map\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        elite_idx = np.argmin(fitness)\n        elite = population[elite_idx]\n        F = np.random.uniform(0.4, 1.0)  # Self-adaptive mutation factor\n        mutant_vector = np.clip(elite + F * (a - b), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        momentum = 0.9  # Added momentum term\n        step = self.levy_flight() * step_size * momentum\n        new_solution = solution + step\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(8 * (1 - (self.num_evaluations / self.budget)))  # Dynamically adjust population size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Enhanced Adaptive Scatter Search with Self-Adaptive Mutation Factor, Dynamic Population Resizing, and Momentum-Driven Local Search for Improved Exploration-Exploitation Balance.", "configspace": "", "generation": 97, "fitness": 0.3750471254926053, "feedback": "The algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.29.", "error": "", "parent_id": "78512f62-5880-4b3f-81fc-81a36dac260b", "metadata": {"aucs": [0.9046300645192077, 0.8925947353208766, 0.9112231653238989, 0.8874390039697793, 0.9027315766722045, 0.9126049317216786, 0.8955318850680622, 0.9021338172275706, 0.8726400450863986, 0.7596790270519176, 0.8045529734013982, 0.6302159798858212, 0.7634015372729461, 0.7866564066195716, 0.7699866825644212, 0.8037563256075979, 0.7924976449335467, 0.7806776088282612, 0.11616233245073093, 0.1579920278181688, 0.15955902798257737, 0.1564511058448952, 0.1695246450430583, 0.11261550562957001, 0.6241555008531321, 0.16729562437524415, 0.11065695804054543, 0.08705351426610508, 0.09836705910285948, 0.1578454458625076, 0.14219632475007693, 0.11886560530975754, 0.115337918910418, 0.07623020851970941, 0.10906534355613096, 0.1554510683749819, 0.9892617330813036, 0.9644791447424077, 0.9805135280272209, 0.9841181677353606, 0.9778049496806956, 0.981213527865441, 0.9770387770635286, 0.9709176808812817, 0.9837867070359219, 0.6040457678337925, 0.6173063024495954, 0.6914381372422967, 0.6920295364135832, 0.6210124963784459, 0.7028746281670684, 0.6135725576122022, 0.6672278636363767, 0.6647109295782733, 0.8672021370212111, 0.22732163170782071, 0.2284750251545823, 0.35790767045169936, 0.8476861338187374, 0.8972187470689414, 0.8410378858339219, 0.23428583139497428, 0.5885236241874832, 0.6504463840798305, 0.291005997184407, 0.17921565161073538, 0.5347342699078881, 0.4214657589764421, 0.36088686447603313, 0.6862243377888397, 0.12717388026800092, 0.450008487079817, 0.3678393603892758, 0.28342828124598307, 0.4195913573505312, 0.5761665415924615, 0.4527851898648628, 0.3034320430797325, 0.45979561005297065, 0.3954654396162106, 0.5185733343288695, 0.07871227064492892, 0.13886253263892245, 0.09877095522046564, 0.1766937690033239, 0.11099511296974374, 0.0005841903160124229, 0.040966496514433515, 0.06090363469948257, 0.01559888649650254, 0.2215095959582578, 0.24672349260170856, 0.09473255382340362, 0.15259776692229554, 0.1224252403039956, 0.26107422524512414, 0.4054263368249008, 0.11549706018319994, 0.18823766942663023, 0.10549162479296992, 0.15923000621953232, 0.055417293224169994, 0.19679875960828042, 0.11714739333147661, 0.15888902650938175, 0.08604051515616595, 0.15277692768056184, 0.11492740939698343, 0.29736965313611885, 0.17939706889308382, 0.25140331156019124, 0.21967843954749122, 0.27632999014210535, 0.24421355447436688, 0.1295841779417124, 0.1373165356605336, 0.26068405188435195, 0.6316412812309771, 0.63614090006606, 0.6764089377510283, 0.5992038268285295, 0.6202343190957266, 0.589579564477025, 0.6419904462178914, 0.6369205430509164, 0.6692886473656516, 0.11587613472008229, 0.11435704564402982, 0.08480023077151944, 0.09435409156587105, 0.07657648448626164, 0.12194028990015704, 0.13027987364558102, 0.08762802847028073, 0.07331111066734264, 0.23083954148181474, 0.1724109725002192, 0.20340108316205308, 0.3005409986385019, 0.5013462602267441, 0.20726989868503543, 0.3468628202981059, 0.27249428158442146, 0.6168789290565422, 0.5091716661775086, 0.34747181748496425, 0.5003628673490781, 0.23873771377091058, 0.4532556318193647, 0.3557749566246696, 0.36485496651802174, 0.3955870137344588, 0.2173954441365118, 0.25854495142542033, 0.3256969870830785, 0.37386460242952035, 0.2627365692903656, 0.29752723947182336, 0.27240450123916427, 0.3674158206457879, 0.28923108052211344, 0.1939828395414982, 0.1835544882986786, 0.18117735170378668, 0.20957064740385878, 0.199964194609344, 0.2328303151469855, 0.22492968701585447, 0.19480489518595012, 0.1825171839972186, 0.20021076943719718, 0.22144123464127363, 0.2027953316778771, 0.21050729336110896, 0.21146957292656599, 0.22083202514452993, 0.22380156563566134, 0.1851249890515526, 0.20014684338938582, 0.19196576977142332, 0.1586454660709169, 0.16917453010761963, 0.12580534079885308, 0.860549179143824, 0.14772447202587558, 0.17299993708608707, 0.9195366421191334, 0.11664074678968606, 0.935776057891821, 0.8059851197319557, 0.8894770456768356, 0.8951010656182716, 0.16846913166564714, 0.16895589122877408, 0.16908907073038992, 0.16670967484688082, 0.8801129537180749, 0.9147646301595239, 0.18833407924871404, 0.18214330287613423, 0.18503038425931972, 0.19601460765296674, 0.1693045773842814, 0.18710500342103809, 0.19998065023664835, 0.1715063499356746, 0.1785186251996569, 0.07677873689973125, 0.09475046158462463, 0.07771947072808127, 0.08170264032651486, 0.0760924978582822, 0.09830745573998412, 0.10118135552830188, 0.10461872822082119, 0.08929978696542673]}, "mutation_prompt": null}
{"id": "b5e7299b-d239-4e29-aad1-be0bc373d378", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        chaotic_initialization = np.random.rand(size, self.dim)\n        chaotic_map = 0.4 + 0.6 * chaotic_initialization\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * chaotic_map\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        elite_idx = np.argmin(fitness)\n        elite = population[elite_idx]\n        F = np.random.uniform(0.4, 1.0)  # Self-adaptive mutation factor\n        mutant_vector = np.clip(elite + F * (a - b), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        momentum = 0.9  # Added momentum term\n        step = self.levy_flight() * step_size * momentum\n        new_solution = solution + step\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(8 * (1 - (self.num_evaluations / self.budget)))  # Dynamically adjust population size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Enhanced Adaptive Scatter Search with Self-Adaptive Mutation Factor, Dynamic Population Resizing, and Momentum-Driven Local Search for Improved Exploration-Exploitation Balance.", "configspace": "", "generation": 98, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f2e46b79-80cf-4a50-82ed-d6c57bd9762e", "metadata": {"aucs": [0.9046300645192077, 0.8925947353208766, 0.9112231653238989, 0.8874390039697793, 0.9027315766722045, 0.9126049317216786, 0.8955318850680622, 0.9021338172275706, 0.8726400450863986, 0.7596790270519176, 0.8045529734013982, 0.6302159798858212, 0.7634015372729461, 0.7866564066195716, 0.7699866825644212, 0.8037563256075979, 0.7924976449335467, 0.7806776088282612, 0.11616233245073093, 0.1579920278181688, 0.15955902798257737, 0.1564511058448952, 0.1695246450430583, 0.11261550562957001, 0.6241555008531321, 0.16729562437524415, 0.11065695804054543, 0.08705351426610508, 0.09836705910285948, 0.1578454458625076, 0.14219632475007693, 0.11886560530975754, 0.115337918910418, 0.07623020851970941, 0.10906534355613096, 0.1554510683749819, 0.9892617330813036, 0.9644791447424077, 0.9805135280272209, 0.9841181677353606, 0.9778049496806956, 0.981213527865441, 0.9770387770635286, 0.9709176808812817, 0.9837867070359219, 0.6040457678337925, 0.6173063024495954, 0.6914381372422967, 0.6920295364135832, 0.6210124963784459, 0.7028746281670684, 0.6135725576122022, 0.6672278636363767, 0.6647109295782733, 0.8672021370212111, 0.22732163170782071, 0.2284750251545823, 0.35790767045169936, 0.8476861338187374, 0.8972187470689414, 0.8410378858339219, 0.23428583139497428, 0.5885236241874832, 0.6504463840798305, 0.291005997184407, 0.17921565161073538, 0.5347342699078881, 0.4214657589764421, 0.36088686447603313, 0.6862243377888397, 0.12717388026800092, 0.450008487079817, 0.3678393603892758, 0.28342828124598307, 0.4195913573505312, 0.5761665415924615, 0.4527851898648628, 0.3034320430797325, 0.45979561005297065, 0.3954654396162106, 0.5185733343288695, 0.07871227064492892, 0.13886253263892245, 0.09877095522046564, 0.1766937690033239, 0.11099511296974374, 0.0005841903160124229, 0.040966496514433515, 0.06090363469948257, 0.01559888649650254, 0.2215095959582578, 0.24672349260170856, 0.09473255382340362, 0.15259776692229554, 0.1224252403039956, 0.26107422524512414, 0.4054263368249008, 0.11549706018319994, 0.18823766942663023, 0.10549162479296992, 0.15923000621953232, 0.055417293224169994, 0.19679875960828042, 0.11714739333147661, 0.15888902650938175, 0.08604051515616595, 0.15277692768056184, 0.11492740939698343, 0.29736965313611885, 0.17939706889308382, 0.25140331156019124, 0.21967843954749122, 0.27632999014210535, 0.24421355447436688, 0.1295841779417124, 0.1373165356605336, 0.26068405188435195, 0.6316412812309771, 0.63614090006606, 0.6764089377510283, 0.5992038268285295, 0.6202343190957266, 0.589579564477025, 0.6419904462178914, 0.6369205430509164, 0.6692886473656516, 0.11587613472008229, 0.11435704564402982, 0.08480023077151944, 0.09435409156587105, 0.07657648448626164, 0.12194028990015704, 0.13027987364558102, 0.08762802847028073, 0.07331111066734264, 0.23083954148181474, 0.1724109725002192, 0.20340108316205308, 0.3005409986385019, 0.5013462602267441, 0.20726989868503543, 0.3468628202981059, 0.27249428158442146, 0.6168789290565422, 0.5091716661775086, 0.34747181748496425, 0.5003628673490781, 0.23873771377091058, 0.4532556318193647, 0.3557749566246696, 0.36485496651802174, 0.3955870137344588, 0.2173954441365118, 0.25854495142542033, 0.3256969870830785, 0.37386460242952035, 0.2627365692903656, 0.29752723947182336, 0.27240450123916427, 0.3674158206457879, 0.28923108052211344, 0.1939828395414982, 0.1835544882986786, 0.18117735170378668, 0.20957064740385878, 0.199964194609344, 0.2328303151469855, 0.22492968701585447, 0.19480489518595012, 0.1825171839972186, 0.20021076943719718, 0.22144123464127363, 0.2027953316778771, 0.21050729336110896, 0.21146957292656599, 0.22083202514452993, 0.22380156563566134, 0.1851249890515526, 0.20014684338938582, 0.19196576977142332, 0.1586454660709169, 0.16917453010761963, 0.12580534079885308, 0.860549179143824, 0.14772447202587558, 0.17299993708608707, 0.9195366421191334, 0.11664074678968606, 0.935776057891821, 0.8059851197319557, 0.8894770456768356, 0.8951010656182716, 0.16846913166564714, 0.16895589122877408, 0.16908907073038992, 0.16670967484688082, 0.8801129537180749, 0.9147646301595239, 0.18833407924871404, 0.18214330287613423, 0.18503038425931972, 0.19601460765296674, 0.1693045773842814, 0.18710500342103809, 0.19998065023664835, 0.1715063499356746, 0.1785186251996569, 0.07677873689973125, 0.09475046158462463, 0.07771947072808127, 0.08170264032651486, 0.0760924978582822, 0.09830745573998412, 0.10118135552830188, 0.10461872822082119, 0.08929978696542673]}, "mutation_prompt": null}
{"id": "2d5b4c1f-8c45-4ecf-ab9d-3e231454a9bb", "solution": "import numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        chaotic_initialization = np.random.rand(size, self.dim)\n        chaotic_map = 0.4 + 0.6 * chaotic_initialization\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * chaotic_map\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        elite_idx = np.argmin(fitness)\n        elite = population[elite_idx]\n        F = np.random.uniform(0.4, 1.0)  # Self-adaptive mutation factor\n        mutant_vector = np.clip(elite + F * (a - b), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        momentum = 0.9  # Added momentum term\n        step = self.levy_flight() * step_size * momentum\n        new_solution = solution + step\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(8 * (1 - (self.num_evaluations / self.budget)))  # Dynamically adjust population size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "AdaptiveScatterSearch", "description": "Enhanced Adaptive Scatter Search with Self-Adaptive Mutation Factor, Dynamic Population Resizing, and Momentum-Driven Local Search for Improved Exploration-Exploitation Balance.", "configspace": "", "generation": 98, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f2e46b79-80cf-4a50-82ed-d6c57bd9762e", "metadata": {"aucs": [0.9046300645192077, 0.8925947353208766, 0.9112231653238989, 0.8874390039697793, 0.9027315766722045, 0.9126049317216786, 0.8955318850680622, 0.9021338172275706, 0.8726400450863986, 0.7596790270519176, 0.8045529734013982, 0.6302159798858212, 0.7634015372729461, 0.7866564066195716, 0.7699866825644212, 0.8037563256075979, 0.7924976449335467, 0.7806776088282612, 0.11616233245073093, 0.1579920278181688, 0.15955902798257737, 0.1564511058448952, 0.1695246450430583, 0.11261550562957001, 0.6241555008531321, 0.16729562437524415, 0.11065695804054543, 0.08705351426610508, 0.09836705910285948, 0.1578454458625076, 0.14219632475007693, 0.11886560530975754, 0.115337918910418, 0.07623020851970941, 0.10906534355613096, 0.1554510683749819, 0.9892617330813036, 0.9644791447424077, 0.9805135280272209, 0.9841181677353606, 0.9778049496806956, 0.981213527865441, 0.9770387770635286, 0.9709176808812817, 0.9837867070359219, 0.6040457678337925, 0.6173063024495954, 0.6914381372422967, 0.6920295364135832, 0.6210124963784459, 0.7028746281670684, 0.6135725576122022, 0.6672278636363767, 0.6647109295782733, 0.8672021370212111, 0.22732163170782071, 0.2284750251545823, 0.35790767045169936, 0.8476861338187374, 0.8972187470689414, 0.8410378858339219, 0.23428583139497428, 0.5885236241874832, 0.6504463840798305, 0.291005997184407, 0.17921565161073538, 0.5347342699078881, 0.4214657589764421, 0.36088686447603313, 0.6862243377888397, 0.12717388026800092, 0.450008487079817, 0.3678393603892758, 0.28342828124598307, 0.4195913573505312, 0.5761665415924615, 0.4527851898648628, 0.3034320430797325, 0.45979561005297065, 0.3954654396162106, 0.5185733343288695, 0.07871227064492892, 0.13886253263892245, 0.09877095522046564, 0.1766937690033239, 0.11099511296974374, 0.0005841903160124229, 0.040966496514433515, 0.06090363469948257, 0.01559888649650254, 0.2215095959582578, 0.24672349260170856, 0.09473255382340362, 0.15259776692229554, 0.1224252403039956, 0.26107422524512414, 0.4054263368249008, 0.11549706018319994, 0.18823766942663023, 0.10549162479296992, 0.15923000621953232, 0.055417293224169994, 0.19679875960828042, 0.11714739333147661, 0.15888902650938175, 0.08604051515616595, 0.15277692768056184, 0.11492740939698343, 0.29736965313611885, 0.17939706889308382, 0.25140331156019124, 0.21967843954749122, 0.27632999014210535, 0.24421355447436688, 0.1295841779417124, 0.1373165356605336, 0.26068405188435195, 0.6316412812309771, 0.63614090006606, 0.6764089377510283, 0.5992038268285295, 0.6202343190957266, 0.589579564477025, 0.6419904462178914, 0.6369205430509164, 0.6692886473656516, 0.11587613472008229, 0.11435704564402982, 0.08480023077151944, 0.09435409156587105, 0.07657648448626164, 0.12194028990015704, 0.13027987364558102, 0.08762802847028073, 0.07331111066734264, 0.23083954148181474, 0.1724109725002192, 0.20340108316205308, 0.3005409986385019, 0.5013462602267441, 0.20726989868503543, 0.3468628202981059, 0.27249428158442146, 0.6168789290565422, 0.5091716661775086, 0.34747181748496425, 0.5003628673490781, 0.23873771377091058, 0.4532556318193647, 0.3557749566246696, 0.36485496651802174, 0.3955870137344588, 0.2173954441365118, 0.25854495142542033, 0.3256969870830785, 0.37386460242952035, 0.2627365692903656, 0.29752723947182336, 0.27240450123916427, 0.3674158206457879, 0.28923108052211344, 0.1939828395414982, 0.1835544882986786, 0.18117735170378668, 0.20957064740385878, 0.199964194609344, 0.2328303151469855, 0.22492968701585447, 0.19480489518595012, 0.1825171839972186, 0.20021076943719718, 0.22144123464127363, 0.2027953316778771, 0.21050729336110896, 0.21146957292656599, 0.22083202514452993, 0.22380156563566134, 0.1851249890515526, 0.20014684338938582, 0.19196576977142332, 0.1586454660709169, 0.16917453010761963, 0.12580534079885308, 0.860549179143824, 0.14772447202587558, 0.17299993708608707, 0.9195366421191334, 0.11664074678968606, 0.935776057891821, 0.8059851197319557, 0.8894770456768356, 0.8951010656182716, 0.16846913166564714, 0.16895589122877408, 0.16908907073038992, 0.16670967484688082, 0.8801129537180749, 0.9147646301595239, 0.18833407924871404, 0.18214330287613423, 0.18503038425931972, 0.19601460765296674, 0.1693045773842814, 0.18710500342103809, 0.19998065023664835, 0.1715063499356746, 0.1785186251996569, 0.07677873689973125, 0.09475046158462463, 0.07771947072808127, 0.08170264032651486, 0.0760924978582822, 0.09830745573998412, 0.10118135552830188, 0.10461872822082119, 0.08929978696542673]}, "mutation_prompt": null}
