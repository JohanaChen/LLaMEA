{"role": "LLaMEA", "time": "2024-11-04 13:18:52.173791", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# "}
{"role": "gpt-4o", "time": "2024-11-04 13:19:00.771275", "content": "\n# Description: Adaptive Scatter Search with Differential Mutation and Local Search Refinement for global optimization.\n# Code: \n```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = 0.8\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.7\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = 0.1\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 20\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(pop_size):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n                \n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-04 13:20:36.872038", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Adaptive Scatter Search with Differential Mutation and Local Search Refinement for global optimization. (Score: 0.22177403550670946)\n\nThe selected solution to update is:\nAdaptive Scatter Search with Differential Mutation and Local Search Refinement for global optimization.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = 0.8\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.7\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = 0.1\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 20\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(pop_size):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n                \n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.20.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 13:20:45.188555", "content": "# Description: Enhanced Adaptive Scatter Search with Probability-Based Dynamic Step Size for improved local refinement.\n# Code:\n# ```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = 0.8\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.7\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        prob_improvement = np.random.rand()\n        step_size = 0.1 if prob_improvement < 0.5 else 0.05\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 20\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(pop_size):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n                \n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-04 13:20:45.191575", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Adaptive Scatter Search with Differential Mutation and Local Search Refinement for global optimization. (Score: 0.22177403550670946)\n\nThe selected solution to update is:\nAdaptive Scatter Search with Differential Mutation and Local Search Refinement for global optimization.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = 0.8\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.7\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = 0.1\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 20\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(pop_size):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n                \n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.20.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 13:20:53.783613", "content": "# Description: Enhanced Adaptive Scatter Search using a dynamic crossover rate and adaptive step size for improved global optimization performance.\n# Code: \n# ```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = 0.8\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = min(1.0, 0.7 + 0.3 * (self.budget - self.num_evaluations) / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = max(0.01, 0.1 * (self.budget - self.num_evaluations) / self.budget)\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 20\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(pop_size):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n                \n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-04 13:20:53.786172", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Adaptive Scatter Search with Differential Mutation and Local Search Refinement for global optimization. (Score: 0.22177403550670946)\n\nThe selected solution to update is:\nAdaptive Scatter Search with Differential Mutation and Local Search Refinement for global optimization.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = 0.8\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.7\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = 0.1\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 20\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(pop_size):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n                \n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.20.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 13:21:01.891782", "content": "# Description: Enhanced Adaptive Scatter Search with adaptive crossover rates and dynamic step size in local search for improved exploration-exploitation balance.\n# Code: \n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = 0.8\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.5 + 0.2 * np.random.rand()  # Adaptive crossover rate\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = 0.1 * (1 - (self.num_evaluations / self.budget))  # Dynamic step size\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 20\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(pop_size):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n                \n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-04 13:21:01.894182", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Adaptive Scatter Search with Differential Mutation and Local Search Refinement for global optimization. (Score: 0.22177403550670946)\n\nThe selected solution to update is:\nAdaptive Scatter Search with Differential Mutation and Local Search Refinement for global optimization.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = 0.8\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.7\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = 0.1\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 20\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(pop_size):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n                \n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.20.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 13:21:09.753668", "content": "# Description: Enhanced Adaptive Scatter Search with Self-Adaptive Differential Mutation and Dynamic Local Search for improved convergence.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.5, 1.0)  # Self-adaptive F\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.7\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = np.random.uniform(0.05, 0.2)  # Dynamic step size\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 20\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(pop_size):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n                \n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-04 13:22:50.304656", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Enhanced Adaptive Scatter Search with Self-Adaptive Differential Mutation and Dynamic Local Search for improved convergence. (Score: 0.23468025634112552)\n\nThe selected solution to update is:\nEnhanced Adaptive Scatter Search with Self-Adaptive Differential Mutation and Dynamic Local Search for improved convergence.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.5, 1.0)  # Self-adaptive F\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.7\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = np.random.uniform(0.05, 0.2)  # Dynamic step size\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 20\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(pop_size):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n                \n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.21.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 13:22:58.369805", "content": "\n# Description: Improved Adaptive Scatter Search with Adaptive Local Search Intensity and Fitness-Based Crossover Probability for Enhanced Optimization.\n# Code:\n# ```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.5, 1.0)  # Self-adaptive F\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant, target_fitness):\n        fitness_scaled = target_fitness / max(1, np.sum(target_fitness))\n        cross_prob = 0.5 + (0.5 * fitness_scaled)  # Fitness-Based Probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def adaptive_local_search(self, solution, func, iteration):\n        step_size = np.random.uniform(0.05, min(0.2, 0.2 / (iteration + 1)))  # Adaptive Intensity\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 20\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        iteration = 0\n        while self.num_evaluations < self.budget:\n            for i in range(pop_size):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant, fitness[i])\n                trial = self.adaptive_local_search(trial, func, iteration)\n                \n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n            iteration += 1\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-04 13:22:58.372862", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Enhanced Adaptive Scatter Search with Self-Adaptive Differential Mutation and Dynamic Local Search for improved convergence. (Score: 0.23468025634112552)\n\nThe selected solution to update is:\nEnhanced Adaptive Scatter Search with Self-Adaptive Differential Mutation and Dynamic Local Search for improved convergence.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.5, 1.0)  # Self-adaptive F\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.7\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = np.random.uniform(0.05, 0.2)  # Dynamic step size\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 20\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(pop_size):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n                \n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.21.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 13:23:08.210117", "content": "# Description: Introduced adaptive population size and competitive local search to enhance convergence and diversity exploration.\n# Code:\n# ```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.5, 1.0)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.7\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = np.random.uniform(0.05, 0.2)\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def competitive_local_search(self, population, fitness, func):\n        for i in range(len(population)):\n            candidate = self.local_search(population[i], func)\n            candidate_fitness = func(candidate)\n            self.num_evaluations += 1\n            if candidate_fitness < fitness[i]:\n                population[i] = candidate\n                fitness[i] = candidate_fitness\n            if self.num_evaluations >= self.budget:\n                break\n\n    def __call__(self, func):\n        pop_size = max(10, min(30, self.dim))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(pop_size):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n                \n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n            self.competitive_local_search(population, fitness, func)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-04 13:23:08.212799", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Enhanced Adaptive Scatter Search with Self-Adaptive Differential Mutation and Dynamic Local Search for improved convergence. (Score: 0.23468025634112552)\n\nThe selected solution to update is:\nEnhanced Adaptive Scatter Search with Self-Adaptive Differential Mutation and Dynamic Local Search for improved convergence.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.5, 1.0)  # Self-adaptive F\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.7\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = np.random.uniform(0.05, 0.2)  # Dynamic step size\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 20\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(pop_size):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n                \n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.21.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 13:23:17.471793", "content": "# Description: Introducing adaptive population resizing and elite preservation to enhance convergence and diversity.\n# Code: \n# ```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.5, 1.0)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.7\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = np.random.uniform(0.05, 0.2)\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def adjust_population(self, population, fitness):\n        elite_size = max(1, int(0.1 * len(population)))\n        elite_indices = fitness.argsort()[:elite_size]\n        elite_pop = population[elite_indices]\n        self.pop_size = max(5, int(0.9 * self.pop_size))\n        return np.vstack((elite_pop, self.initialize_population(self.pop_size - len(elite_pop))))\n\n    def __call__(self, func):\n        population = self.initialize_population(self.pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(self.pop_size):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n                \n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n            \n            if self.num_evaluations < self.budget:\n                population = self.adjust_population(population, fitness)\n                fitness = self.evaluate_population(population, func)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-04 13:23:17.474559", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Enhanced Adaptive Scatter Search with Self-Adaptive Differential Mutation and Dynamic Local Search for improved convergence. (Score: 0.23468025634112552)\n\nThe selected solution to update is:\nEnhanced Adaptive Scatter Search with Self-Adaptive Differential Mutation and Dynamic Local Search for improved convergence.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.5, 1.0)  # Self-adaptive F\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.7\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = np.random.uniform(0.05, 0.2)  # Dynamic step size\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 20\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(pop_size):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n                \n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.21.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 13:23:26.160214", "content": "# Description: Refined Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Local Search for Better Convergence.\n# Code: \n# ```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c, d = population[np.random.choice(idxs, 4, replace=False)]\n        F1 = np.random.uniform(0.4, 0.9)\n        F2 = np.random.uniform(0.1, 0.5)\n        mutant_vector = np.clip(a + F1 * (b - c) + F2 * (d - a), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.75  # Slightly increased probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = np.random.uniform(0.03, 0.1)  # Reduced step size for more precise search\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 20\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(pop_size):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n                \n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n# ```\n"}
{"role": "LLaMEA", "time": "2024-11-04 13:23:26.163100", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Enhanced Adaptive Scatter Search with Self-Adaptive Differential Mutation and Dynamic Local Search for improved convergence. (Score: 0.23468025634112552)\n\nThe selected solution to update is:\nEnhanced Adaptive Scatter Search with Self-Adaptive Differential Mutation and Dynamic Local Search for improved convergence.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.5, 1.0)  # Self-adaptive F\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.7\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = np.random.uniform(0.05, 0.2)  # Dynamic step size\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 20\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(pop_size):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n                \n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.21.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 13:23:36.327024", "content": "# Description: Adaptive Scatter Search with Enhanced Self-Adaptive Differential Mutation and Improved Local Search using Adaptive Step Size.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.5, 1.0)  # Self-adaptive F\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = np.random.uniform(0.6, 0.9)  # Adaptive crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = 0.1 / (1 + np.exp(-0.1 * self.num_evaluations))  # Adaptive step size\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 20\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(pop_size):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n                \n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n```\n"}
{"role": "LLaMEA", "time": "2024-11-04 13:25:18.892538", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Adaptive Scatter Search with Enhanced Self-Adaptive Differential Mutation and Improved Local Search using Adaptive Step Size. (Score: 0.24996415491191895)\n\nThe selected solution to update is:\nAdaptive Scatter Search with Enhanced Self-Adaptive Differential Mutation and Improved Local Search using Adaptive Step Size.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.5, 1.0)  # Self-adaptive F\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = np.random.uniform(0.6, 0.9)  # Adaptive crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = 0.1 / (1 + np.exp(-0.1 * self.num_evaluations))  # Adaptive step size\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 20\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(pop_size):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n                \n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.21.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 13:25:25.989635", "content": "# Description: Enhanced Adaptive Scatter Search with Adaptive Learning Rates and Dynamic Population Size for Improved Exploration.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)  # Adjusted F for improved exploration\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)  # Dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))  # Adjusted step size\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))  # Dynamic population size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):  # Use current dynamic population size\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-04 13:27:07.525040", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Enhanced Adaptive Scatter Search with Adaptive Learning Rates and Dynamic Population Size for Improved Exploration. (Score: 0.31091926409241133)\n\nThe selected solution to update is:\nEnhanced Adaptive Scatter Search with Adaptive Learning Rates and Dynamic Population Size for Improved Exploration.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)  # Adjusted F for improved exploration\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)  # Dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))  # Adjusted step size\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))  # Dynamic population size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):  # Use current dynamic population size\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 13:27:23.106728", "content": "# Description: Enhanced Adaptive Scatter Search with Adaptive Diversity Maintenance and Multi-Phase Exploration Strategy to Improve Optimization Performance.\n# Code: \n```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.5, 0.9)  # Adjusted F for more robust exploration\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.8 - 0.3 * (self.num_evaluations / self.budget)  # More stable crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = 0.15 / (1 + np.exp(-0.1 * self.num_evaluations))  # Fine-tuned step size\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def adaptive_diversity_maintenance(self, population, func):\n        diversity_factor = 0.1 * (1 - (self.num_evaluations / self.budget))\n        for i in range(len(population)):\n            if np.random.rand() < diversity_factor:\n                perturbation = np.random.uniform(-0.5, 0.5, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                if func(candidate) < func(population[i]):\n                    population[i] = candidate\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            self.adaptive_diversity_maintenance(population, func)  # New diversity maintenance step\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-04 13:29:03.220310", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Enhanced Adaptive Scatter Search with Adaptive Learning Rates and Dynamic Population Size for Improved Exploration. (Score: 0.31091926409241133)\n\nThe selected solution to update is:\nEnhanced Adaptive Scatter Search with Adaptive Learning Rates and Dynamic Population Size for Improved Exploration.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)  # Adjusted F for improved exploration\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)  # Dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))  # Adjusted step size\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))  # Dynamic population size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):  # Use current dynamic population size\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 13:29:16.598361", "content": "# Description: Enhanced Adaptive Scatter Search with Adaptive Mutation Rates and Fitness-Based Population Reduction for Superior Exploration and Exploitation.\n# Code:\n# ```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = 0.5 + 0.3 * (1 - (self.num_evaluations / self.budget))  # Adaptive mutation factor\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)  # Dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))  # Adjusted step size\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))  # Dynamic population size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):  # Use current dynamic population size\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n            # Fitness-based population reduction\n            if len(population) > 3:\n                sorted_indices = np.argsort(fitness)\n                population = population[sorted_indices[:len(population)//2]]\n                fitness = fitness[sorted_indices[:len(fitness)//2]]\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-04 13:29:16.601455", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Enhanced Adaptive Scatter Search with Adaptive Learning Rates and Dynamic Population Size for Improved Exploration. (Score: 0.31091926409241133)\n\nThe selected solution to update is:\nEnhanced Adaptive Scatter Search with Adaptive Learning Rates and Dynamic Population Size for Improved Exploration.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)  # Adjusted F for improved exploration\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)  # Dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))  # Adjusted step size\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))  # Dynamic population size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):  # Use current dynamic population size\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 13:29:26.883345", "content": "# Description: Improved Adaptive Scatter Search with Dynamic Differential Mutation and Adaptive Crossover for Enhanced Convergence.\n# Code:\n# ```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = 0.5 + 0.3 * np.sin(np.pi * self.num_evaluations / self.budget)  # Dynamic mutation factor\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.8 - 0.5 * np.cos(np.pi * (self.num_evaluations / self.budget))  # Adaptive crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n# ```\n"}
{"role": "LLaMEA", "time": "2024-11-04 13:29:26.886344", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Enhanced Adaptive Scatter Search with Adaptive Learning Rates and Dynamic Population Size for Improved Exploration. (Score: 0.31091926409241133)\n\nThe selected solution to update is:\nEnhanced Adaptive Scatter Search with Adaptive Learning Rates and Dynamic Population Size for Improved Exploration.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)  # Adjusted F for improved exploration\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)  # Dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))  # Adjusted step size\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))  # Dynamic population size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):  # Use current dynamic population size\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 13:29:39.502342", "content": "# Description: Enhanced Adaptive Scatter Search with Stochastic Ranking and Adaptive Mutation for Better Handling of Multi-Modal Functions.\n# Code: \n```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        # Adaptive F for improved exploration and exploitation\n        F = 0.5 + 0.3 * np.sin(self.num_evaluations / self.budget * np.pi)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def stochastic_ranking(self, population, fitness):\n        # Stochastic ranking with bubble sort-like swaps\n        for _ in range(len(population)):\n            for i in range(len(population) - 1):\n                if (np.random.rand() < 0.45) or (fitness[i] > fitness[i + 1]):\n                    population[i], population[i + 1] = population[i + 1], population[i]\n                    fitness[i], fitness[i + 1] = fitness[i + 1], fitness[i]\n        return population, fitness\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            population, fitness = self.stochastic_ranking(population, fitness)  # New ranking\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-04 13:31:36.925577", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Enhanced Adaptive Scatter Search with Adaptive Learning Rates and Dynamic Population Size for Improved Exploration. (Score: 0.31091926409241133)\n\nThe selected solution to update is:\nEnhanced Adaptive Scatter Search with Adaptive Learning Rates and Dynamic Population Size for Improved Exploration.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)  # Adjusted F for improved exploration\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)  # Dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))  # Adjusted step size\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))  # Dynamic population size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):  # Use current dynamic population size\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 13:31:48.581955", "content": "# Description: Adaptive Scatter Search with Strategic Archiving and Improved Local Search.\n# Code:\n# ```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.archive = []\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.9)  # Expanded F range for better exploration\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.35 * (self.num_evaluations / self.budget)  # Adjusted dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        for _ in range(3):  # Perform multiple perturbations\n            new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n            new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n            new_fitness = func(new_solution)\n            if new_fitness < func(solution):\n                solution = new_solution\n        return solution\n\n    def update_archive(self, solution, fitness):\n        if len(self.archive) < 5 or fitness < max(self.archive, key=lambda x: x[1])[1]:\n            self.archive.append((solution, fitness))\n            self.archive.sort(key=lambda x: x[1])\n            if len(self.archive) > 5:\n                self.archive.pop()\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                self.update_archive(trial, trial_fitness)\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_in_archive = min(self.archive, key=lambda x: x[1])[0] if self.archive else population[np.argmin(fitness)]\n        return best_in_archive\n# ```"}
{"role": "LLaMEA", "time": "2024-11-04 13:31:48.585117", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Enhanced Adaptive Scatter Search with Adaptive Learning Rates and Dynamic Population Size for Improved Exploration. (Score: 0.31091926409241133)\n\nThe selected solution to update is:\nEnhanced Adaptive Scatter Search with Adaptive Learning Rates and Dynamic Population Size for Improved Exploration.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)  # Adjusted F for improved exploration\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)  # Dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))  # Adjusted step size\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))  # Dynamic population size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):  # Use current dynamic population size\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 13:32:00.945538", "content": "# Description: Enhanced Adaptive Scatter Search with Hybrid Search Strategy and Adaptive Crossover for Improved Convergence.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.5, 0.9)  # Slightly increased F for more aggressive exploration\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.8 - 0.2 * (self.num_evaluations / self.budget)  # Adjusted crossover probability for gradual convergence\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = 0.1 / (1 + np.exp(-0.1 * self.num_evaluations))  # Reduced step size for finer exploration\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def hybrid_search(self, solution, func):\n        # Hybrid search: combine local search with a random perturbation\n        hybrid_step = np.random.uniform(-0.05, 0.05, self.dim)\n        new_solution = np.clip(solution + hybrid_step, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 15 + int(10 * (1 - (self.num_evaluations / self.budget)))  # Increased dynamic population size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.hybrid_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-04 13:33:40.329981", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Enhanced Adaptive Scatter Search with Adaptive Learning Rates and Dynamic Population Size for Improved Exploration. (Score: 0.31091926409241133)\n\nThe selected solution to update is:\nEnhanced Adaptive Scatter Search with Adaptive Learning Rates and Dynamic Population Size for Improved Exploration.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)  # Adjusted F for improved exploration\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)  # Dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))  # Adjusted step size\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))  # Dynamic population size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):  # Use current dynamic population size\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 13:33:49.841991", "content": "# Description: Modified Adaptive Scatter Search with Stochastic Ranking for better balance between exploration and exploitation.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.9)  # Broader range for F to enhance exploration\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def stochastic_ranking(self, population, fitness):\n        probabilities = np.random.rand(len(fitness))\n        ranked = sorted(range(len(fitness)), key=lambda i: (fitness[i], probabilities[i]))\n        return [population[i] for i in ranked]\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            population = self.stochastic_ranking(population, fitness)\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-04 13:33:49.847910", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Enhanced Adaptive Scatter Search with Adaptive Learning Rates and Dynamic Population Size for Improved Exploration. (Score: 0.31091926409241133)\n\nThe selected solution to update is:\nEnhanced Adaptive Scatter Search with Adaptive Learning Rates and Dynamic Population Size for Improved Exploration.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)  # Adjusted F for improved exploration\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)  # Dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))  # Adjusted step size\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))  # Dynamic population size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):  # Use current dynamic population size\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 13:33:59.512546", "content": "# Description: Improved Adaptive Scatter Search with Hybrid Mutation Strategies and Adaptive Step Size for Enhanced Convergence.\n# Code:\n# ```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.5, 0.9)  # Slightly increased F for exploration\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def hybrid_mutation(self, target_idx, population, fitness):\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        a, b = population[np.random.choice(len(population), 2, replace=False)]\n        F1 = np.random.uniform(0.3, 0.7)\n        F2 = np.random.uniform(0.2, 0.5)\n        mutant_vector = np.clip(a + F1 * (b - target_idx) + F2 * (best - a), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = 0.1 / (1 + self.num_evaluations / (0.5 * self.budget))  # Adaptive step size\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                if np.random.rand() < 0.5:\n                    mutant = self.differential_mutation(i, population, fitness)\n                else:\n                    mutant = self.hybrid_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-04 13:33:59.515309", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Enhanced Adaptive Scatter Search with Adaptive Learning Rates and Dynamic Population Size for Improved Exploration. (Score: 0.31091926409241133)\n\nThe selected solution to update is:\nEnhanced Adaptive Scatter Search with Adaptive Learning Rates and Dynamic Population Size for Improved Exploration.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)  # Adjusted F for improved exploration\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)  # Dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))  # Adjusted step size\n        new_solution = solution + np.random.uniform(-step_size, step_size, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))  # Dynamic population size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):  # Use current dynamic population size\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 13:34:11.938878", "content": "# Description: Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.\n# Code: \n```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-04 13:36:01.629603", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency. (Score: 0.3185678771052579)\n\nThe selected solution to update is:\nImproved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 13:36:24.418123", "content": "# Description: Improved Adaptive Scatter Search with Stochastic Ranking for Balanced Exploration and Exploitation in Black Box Optimization.\n# Code: \n# ```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  \n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n    \n    def stochastic_ranking(self, population, fitness):\n        idxs = np.arange(len(population))\n        for i in range(len(population) - 1):\n            for j in range(len(population) - 1 - i):\n                p = np.random.rand()\n                if (p < 0.45 and fitness[idxs[j]] > fitness[idxs[j + 1]]) or (fitness[idxs[j]] > fitness[idxs[j + 1]]):\n                    idxs[j], idxs[j + 1] = idxs[j + 1], idxs[j]\n        return population[idxs], fitness[idxs]\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n            population, fitness = self.stochastic_ranking(population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-04 13:38:20.973793", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency. (Score: 0.3185678771052579)\n\nThe selected solution to update is:\nImproved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 13:38:32.588993", "content": "# Description: Enhanced Adaptive Scatter Search with Dynamic Mutation and Crossover Strategies for Improved Global Exploration.\n# Code:\n# ```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        mutation_factor = 0.5 + 0.3 * np.sin(np.pi * self.num_evaluations / self.budget)\n        mutant_vector = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-04 13:38:32.591842", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency. (Score: 0.3185678771052579)\n\nThe selected solution to update is:\nImproved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 13:38:43.604054", "content": "# Description: Enhanced Adaptive Scatter Search with Dynamic Crossover and Adaptive Step Size for Improved Exploration and Exploitation.\n# Code: \n```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.5, 0.9)  # Adjusted F for better exploration\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.8 + 0.1 * np.sin((self.num_evaluations / self.budget) * np.pi)  # Dynamic crossover\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.1 + 0.1 * (1 - self.num_evaluations / self.budget)  # Adaptive step size\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-04 13:40:33.518241", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency. (Score: 0.3185678771052579)\n\nThe selected solution to update is:\nImproved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 13:40:48.854938", "content": "# Description: Enhanced Adaptive Scatter Search with Dynamic Population Size and Selective Levy Flight Intensification for Improved Exploration and Exploitation Balance.\n# Code:\n# ```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.9)  # Slightly increased upper bound for F\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def selective_levy_intensification(self, solution, func):\n        if np.random.rand() < 0.5:  # Added selective intensification based on random chance\n            return self.local_search(solution, func)\n        return solution\n\n    def __call__(self, func):\n        while self.num_evaluations < self.budget:\n            pop_size = max(5, 10 + int(10 * (1 - (self.num_evaluations / self.budget))))  # Dynamic population size\n            population = self.initialize_population(pop_size)\n            fitness = self.evaluate_population(population, func)\n\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.selective_levy_intensification(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-04 13:40:48.858183", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency. (Score: 0.3185678771052579)\n\nThe selected solution to update is:\nImproved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 13:41:20.590940", "content": "# Description: Enhanced Adaptive Scatter Search with Dynamic Population Adjustment and Hybrid Mutation for Accelerated Convergence.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.9)  # Adjusted range\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.7 + 0.2 * (1 - (self.num_evaluations / self.budget))  # Inverted logic for diversity\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def hybrid_mutation(self, solution):  # Introduced hybrid mutation\n        perturbation = np.random.normal(0, 0.1, self.dim)\n        return solution + perturbation\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 15 + int(5 * (1 - (self.num_evaluations / self.budget)))  # Dynamic adjustment\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.hybrid_mutation(trial)  # Apply hybrid mutation\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-04 13:43:12.513155", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency. (Score: 0.3185678771052579)\n\nThe selected solution to update is:\nImproved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 13:43:30.412077", "content": "# Description: Enhanced Adaptive Scatter Search with Strategic Re-Ranking and Dynamic Crossover Probability for Improved Convergence.\n# Code:\n# ```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        dynamic_factor = (1 - np.tanh(0.01 * self.num_evaluations))\n        cross_prob = 0.6 + 0.3 * dynamic_factor\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def re_rank_population(self, population, fitness):\n        ranked_indices = np.argsort(fitness)\n        return population[ranked_indices], fitness[ranked_indices]\n    \n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            population, fitness = self.re_rank_population(population, fitness)\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-04 13:43:30.415068", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency. (Score: 0.3185678771052579)\n\nThe selected solution to update is:\nImproved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 13:43:45.066896", "content": "# Description: Enhanced Adaptive Scatter Search with Adaptive Crossover and Self-Adaptive Mutation for Improved Global Exploration.\n# Code:\n# ```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = 0.5 + 0.5 * np.random.rand()  # Self-adaptive F value\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        if np.random.rand() < 0.5:  # Adaptive crossover strategy\n            cross_prob += 0.1\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-04 13:43:45.069823", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency. (Score: 0.3185678771052579)\n\nThe selected solution to update is:\nImproved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 13:43:56.224994", "content": "# Description: Enhanced Adaptive Scatter Search with Adaptive Differential Mutation and Stochastic Local Search for Improved Exploration-Exploitation Balance.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def adaptive_differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 1.0) * (1 - (self.num_evaluations / self.budget))\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.8 - 0.2 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def stochastic_local_search(self, solution, func):\n        step_size = 0.15 / (1 + np.exp(-0.1 * self.num_evaluations))\n        perturbation = np.where(np.random.rand(self.dim) < 0.3, self.levy_flight() * step_size, 0)\n        new_solution = solution + perturbation\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.adaptive_differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.stochastic_local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n```\n"}
{"role": "LLaMEA", "time": "2024-11-04 13:45:52.354241", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency. (Score: 0.3185678771052579)\n\nThe selected solution to update is:\nImproved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 13:46:03.579802", "content": "# Description: Enhanced Adaptive Scatter Search with Strategic Exploitation Using Dynamic Mutation Scaling and Adaptive Levy Flight Step Size for Improved Search Efficiency.\n# Code: \n# ```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.5, 1.0)  # Changed mutation factor range for better exploration\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        # Dynamic step size for levy flight based on remaining budget\n        step_size = max(0.05, 0.2 * (1 - self.num_evaluations / self.budget))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-04 13:46:03.582835", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency. (Score: 0.3185678771052579)\n\nThe selected solution to update is:\nImproved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 13:46:19.743990", "content": "# Description: Enhanced Scatter Search with Dynamic Levy Exponent and Adaptive Population Size for Improved Exploration-Exploitation Balance.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        L = 1.5 - 0.5 * (self.num_evaluations / self.budget)  # Dynamic Levy exponent\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight(L) * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 15 + int(5 * (1 - (self.num_evaluations / self.budget)))  # Adjusted adaptive population size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n```\n"}
{"role": "LLaMEA", "time": "2024-11-04 13:48:09.611146", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency. (Score: 0.3185678771052579)\n\nThe selected solution to update is:\nImproved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 13:48:23.645699", "content": "# Description: Enhanced Adaptive Scatter Search with Adaptive Population Size, Strategic Crossover, and Memory Mechanism for Improved Global Exploration Efficiency.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = 0.7 + (0.3 * (self.num_evaluations / self.budget))  # Adaptive mutation factor\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.8 + 0.1 * np.cos(2 * np.pi * self.num_evaluations / self.budget)  # Cosine-modulated crossover\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.1 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 15 + int(5 * np.sin(np.pi * self.num_evaluations / self.budget))  # Adaptive population size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n        best_solution = np.copy(population[np.argmin(fitness)])\n        best_fitness = np.min(fitness)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if trial_fitness < best_fitness:\n                    best_solution = np.copy(trial)\n                    best_fitness = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        return best_solution\n# ```\n"}
{"role": "LLaMEA", "time": "2024-11-04 13:48:23.648760", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency. (Score: 0.3185678771052579)\n\nThe selected solution to update is:\nImproved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 13:48:37.910232", "content": "# Description: Enhanced Differential Mutation with Dynamic Step Size Adjustment for Adaptive Balance between Exploration and Exploitation.\n# Code:\n# ```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        success_rate = (np.sum(fitness < np.min(fitness)) / len(fitness))\n        F = np.random.uniform(0.4, 1.0) * (1 + success_rate)  # Adjusting mutation factor F\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.tanh(self.num_evaluations / self.budget))  # Changed step size dynamics\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-04 13:48:37.913564", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency. (Score: 0.3185678771052579)\n\nThe selected solution to update is:\nImproved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 13:48:51.405508", "content": "# Description: Enhanced Adaptive Scatter Search with Stochastic Perturbation and Dynamic Population Scale for Robust Exploration.\n# Code:\n# ```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.5, 0.9)  # Adjusted range\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        perturbation = np.random.uniform(-0.1, 0.1, self.dim)  # New stochastic perturbation\n        new_solution = np.clip(new_solution + perturbation, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(15 * (1 - (self.num_evaluations / self.budget)))  # Dynamic population scale\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-04 13:48:51.408581", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency. (Score: 0.3185678771052579)\n\nThe selected solution to update is:\nImproved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 13:49:06.157711", "content": "# Description: Enhanced Adaptive Scatter Search with Dynamic Population Size Adjustment and Intensified Local Search for Improved Exploration-Exploitation Balance.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.6, 0.9)  # Increased F for diversity\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.8 - 0.2 * (self.num_evaluations / self.budget)  # Adjusted crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.4 / (1 + np.exp(-0.1 * self.num_evaluations))  # Increased step size for intensified search\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        initial_pop_size = 15 + int(5 * (1 - (self.num_evaluations / self.budget)))  # Adjusted initial population size\n        population = self.initialize_population(initial_pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-04 13:50:55.611462", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency. (Score: 0.3185678771052579)\n\nThe selected solution to update is:\nImproved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 13:51:16.270481", "content": "# Description: Enhanced Adaptive Scatter Search with Dynamic Population and Step Size Adaptation for Improved Exploration and Exploitation Balance.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.5, 0.9)  # Adjusted mutation factor range\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.8 - 0.4 * (self.num_evaluations / self.budget)  # Adjusted crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.3 / (1 + np.exp(-0.1 * self.num_evaluations))  # Adjusted step size factor\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 15 + int(10 * (1 - (self.num_evaluations / self.budget)))  # Adjusted initial population size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-04 13:53:06.094964", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency. (Score: 0.3185678771052579)\n\nThe selected solution to update is:\nImproved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 13:53:18.015503", "content": "# Description: Enhanced Adaptive Scatter Search with Fitness-Based Dynamic Population Scaling and Hybrid Local Search for Robust Optimization.\n# Code: \n```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        candidates = np.random.choice(idxs, 3, replace=False)\n        a, b, c = population[candidates]\n        F = 0.5 + 0.3 * np.random.rand()  # Enhanced F value\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.8 + 0.2 * (1 - (self.num_evaluations / self.budget))  # Adjusted crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.1 / (1 + np.exp(-0.1 * self.num_evaluations))  # Reduced step size for finer adjustment\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(15 * (1 - (self.num_evaluations / self.budget)))  # Dynamic population size increase\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-04 13:55:06.382716", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency. (Score: 0.3185678771052579)\n\nThe selected solution to update is:\nImproved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 13:57:48.361585", "content": "# Description: Enhanced Adaptive Scatter Search with Dynamic Mutation Rate and Fitness Based Population Adjustment for Improved Exploration-Exploitation Balance.\n# Code:\n# ```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        # Dynamic mutation factor based on evaluations\n        F = 0.4 + 0.6 * (1 - self.num_evaluations / self.budget)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            # Fitness-based dynamic adjustment of population size\n            best_fitness = np.min(fitness)\n            pop_size = int(5 + (10 * (1 - best_fitness / max(fitness))))\n            population = population[:pop_size]\n            fitness = fitness[:pop_size]\n\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-04 13:57:48.365492", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency. (Score: 0.3185678771052579)\n\nThe selected solution to update is:\nImproved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 13:57:58.382707", "content": "# Description: Enhanced Adaptive Scatter Search with Dynamic Population Sizing and Adaptive Mutation for Balanced Exploration-Exploitation.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.5, 0.9)  # Adjusted mutation step\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.7 + 0.2 * (1 - (self.num_evaluations / self.budget))  # Dynamic crossover\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.1 / (1 + np.exp(-0.05 * self.num_evaluations))  # Adjusted step size control\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        initial_pop_size = 20  # Increased initial population size\n        population = self.initialize_population(initial_pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-04 13:59:48.218510", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency. (Score: 0.3185678771052579)\n\nThe selected solution to update is:\nImproved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:00:00.838727", "content": "# Description: Integrating Elite Recombination and Adaptive Differential Mutation for Enhanced Exploration and Exploitation Balance.\n# Code: \n# ```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.5, 1.0)  # Adjusted for better exploration\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def elite_recombination(self, population, fitness):\n        elites = population[np.argsort(fitness)[:2]]  # Select top 2\n        return 0.5 * (elites[0] + elites[1])  # Elite recombination\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n\n                elite_solution = self.elite_recombination(population, fitness)\n                trial = (trial + elite_solution) / 2  # Incorporate elite recombination\n\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-04 14:00:00.841654", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency. (Score: 0.3185678771052579)\n\nThe selected solution to update is:\nImproved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:00:20.377160", "content": "# Description: Enhanced Adaptive Scatter Search with Dynamic Population and Adaptive Crossover for Improved Exploration and Exploitation Balance.\n# Code: \n```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.5, 0.9)  # Adjusted lower bound\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.7 - 0.2 * (self.num_evaluations / self.budget)  # Adjusted starting probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.3 / (1 + np.exp(-0.1 * self.num_evaluations))  # Increased step size\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        initial_pop_size = 20  # Increased initial population size\n        population = self.initialize_population(initial_pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n```\n"}
{"role": "LLaMEA", "time": "2024-11-04 14:02:10.865536", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency. (Score: 0.3185678771052579)\n\nThe selected solution to update is:\nImproved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:02:22.548650", "content": "# Description: Enhanced Adaptive Scatter Search with Adaptive Population Size and Stochastic Restart for Broader Exploration.\n# Code:\n# ```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def stochastic_restart(self, func):\n        new_candidate = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        if func(new_candidate) < func(self.best_solution):\n            self.best_solution = new_candidate\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        self.best_solution = population[np.argmin(fitness)]\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < func(self.best_solution):\n                        self.best_solution = trial\n\n                if self.num_evaluations % (self.budget // 5) == 0:\n                    self.stochastic_restart(func)\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        return self.best_solution\n# ```\n\n"}
{"role": "LLaMEA", "time": "2024-11-04 14:02:22.551728", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency. (Score: 0.3185678771052579)\n\nThe selected solution to update is:\nImproved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:02:35.566296", "content": "# Description: Enhanced Adaptive Scatter Search with Dynamic Population Size Adjustment and Improved Diversity Mechanism for Robust Performance.\n# Code: \n```python\nimport numpy as np\n\nclass EnhancedAdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.5, 0.9)  # Changed to enhance exploration\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.8 - 0.3 * (self.num_evaluations / self.budget)  # Adjust to influence exploration/exploitation\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.1 / (1 + np.exp(-0.05 * self.num_evaluations))  # Adjust step size for more gradual changes\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        return new_solution if func(new_solution) < func(solution) else solution\n\n    def __call__(self, func):\n        initial_pop_size = 15  # Slightly increased population size for initial diversity\n        population = self.initialize_population(initial_pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n```\n"}
{"role": "LLaMEA", "time": "2024-11-04 14:04:24.871486", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency. (Score: 0.3185678771052579)\n\nThe selected solution to update is:\nImproved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:04:38.212126", "content": "# Description: Enhanced Adaptive Scatter Search with Dynamic Population Adjustment and Adaptive Crossover for Improved Exploration and Exploitation Balance.\n# Code: \n```python\nimport numpy as np\n\nclass EnhancedAdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.6, 0.9)  # Adjusted mutation factor range\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def adaptive_crossover(self, target, mutant):\n        cross_prob = 0.8 - 0.3 * np.exp(-0.005 * self.num_evaluations)  # Adaptive crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * np.exp(-0.0025 * self.num_evaluations))  # Dynamic population size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.adaptive_crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-04 14:06:28.770539", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency. (Score: 0.3185678771052579)\n\nThe selected solution to update is:\nImproved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:06:41.309079", "content": "# Description: Enhanced Adaptive Scatter Search with Dynamic Population Size Adjustment and Improved Local Search Intensification.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.5, 0.9)  # Adjusted range for F\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.8 - 0.2 * (self.num_evaluations / self.budget)  # Modified crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.2):  # Adjusted L for Levy flight\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.3 / (1 + np.exp(-0.1 * self.num_evaluations))  # Modified step size\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        initial_pop_size = 15  # Adjusted initial population size\n        population = self.initialize_population(initial_pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-04 14:08:30.695991", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency. (Score: 0.3185678771052579)\n\nThe selected solution to update is:\nImproved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:08:44.951035", "content": "# Description: Enhanced Adaptive Scatter Search with Dynamic Population Scaling and Hybrid Local Search for Improved Convergence.\n# Code:\n# ```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.9)  # Adjusted upper bound for F\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.8 - 0.3 * (self.num_evaluations / self.budget)  # Adjusted initial cross_prob\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n    \n    def hybrid_local_search(self, solution, func):  # Renamed and adjusted local search\n        step_size = 0.1 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Kept Levy flights\n        perturbation = np.random.normal(0, 0.05, self.dim)  # Added small Gaussian perturbation\n        new_solution += perturbation\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        initial_pop_size = 15  # Increased initial population size\n        population = self.initialize_population(initial_pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.hybrid_local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-04 14:08:44.954517", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency. (Score: 0.3185678771052579)\n\nThe selected solution to update is:\nImproved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:08:57.022171", "content": "# Description: Enhanced Adaptive Scatter Search with Dynamic Population Sizing and Adaptive Mutation for Balanced Exploration and Exploitation.\n# Code:\n# ```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.5, 1.0)  # Adjusted mutation factor range\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.8 - 0.2 * (self.num_evaluations / self.budget)  # Slightly adjusted\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.15 / (1 + np.exp(-0.1 * self.num_evaluations))  # Adjusted step size\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        initial_pop_size = 15  # Increased initial population size\n        population = self.initialize_population(initial_pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-04 14:08:57.025345", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency. (Score: 0.3185678771052579)\n\nThe selected solution to update is:\nImproved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:09:11.125378", "content": "# Description: Enhanced Adaptive Scatter Search with Dynamic Crossover Rate and Adaptive Levy Flight Scaling for Improved Exploration-Exploitation Balance.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = 0.5 + np.random.rand() * 0.3  # Adjusted mutation factor\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.8 + 0.2 * np.sin(np.pi * (self.num_evaluations / self.budget))  # Dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.1 + 0.1 * (1 - (self.num_evaluations / self.budget))  # Adaptive step size\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 12 + int(8 * (1 - (self.num_evaluations / self.budget)))  # Adjusted population size calculation\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-04 14:10:58.863499", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency. (Score: 0.3185678771052579)\n\nThe selected solution to update is:\nImproved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:11:17.310166", "content": "# Description: Enhanced Adaptive Scatter Search with Dynamic Population and Adaptive Levy Step for Better Exploration and Exploitation Balance.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.5, 0.9)  # Adjusted to enhance exploration\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.7 + 0.2 * np.sin(2 * np.pi * (self.num_evaluations / self.budget))  # Dynamic crossover rate\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.1 / (1 + np.exp(-0.05 * self.num_evaluations))  # Adjusted step size for adaptive levy\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 12 + int(8 * (1 - (self.num_evaluations / self.budget)))  # Dynamic population size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-04 14:13:08.978563", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency. (Score: 0.3185678771052579)\n\nThe selected solution to update is:\nImproved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:13:22.043521", "content": "# Description: Enhanced Adaptive Scatter Search Utilizing Dynamic Population Resizing and Adaptive Step Size for Improved Global Exploration and Local Exploitation.\n# Code: \n```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.dynamic_pop_size_factor = 0.1\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.5, 0.9)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        adaptive_step = 0.1 + 0.1 * (1 - (self.num_evaluations / self.budget))\n        new_solution = solution + self.levy_flight() * adaptive_step\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        initial_pop_size = 10 + int(10 * self.dynamic_pop_size_factor)\n        population = self.initialize_population(initial_pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-04 14:15:09.831151", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency. (Score: 0.3185678771052579)\n\nThe selected solution to update is:\nImproved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:15:26.371195", "content": "# Description: Enhanced Adaptive Scatter Search with Dynamic Levy Flights and Improved Local Search Mechanism for Optimized Exploration and Exploitation.\n# Code: \n# ```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.5, 0.9)  # Adjusted range for F\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.8 + 0.1 * np.sin(np.pi * self.num_evaluations / self.budget)  # Dynamic crossover strategy\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def dynamic_levy_flight(self, scale=0.1):  # New dynamic levy flight method\n        L = 1.5 + 0.5 * (self.num_evaluations / self.budget)\n        return self.levy_flight(L) * scale\n\n    def local_search(self, solution, func):\n        step_size = 0.1 / (1 + np.tanh(0.05 * self.num_evaluations))  # Improved step size calculation\n        new_solution = solution + self.dynamic_levy_flight(scale=step_size)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 12 + int(8 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-04 14:15:26.374598", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency. (Score: 0.3185678771052579)\n\nThe selected solution to update is:\nImproved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:15:43.948060", "content": "# Description: Enhanced Adaptive Scatter Search with Hybrid Mutation and Dynamic Population Adjustment for Improved Convergence.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def hybrid_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c, d = population[np.random.choice(idxs, 4, replace=False)]\n        F1 = np.random.uniform(0.4, 0.8)\n        F2 = np.random.uniform(0.1, 0.4)\n        mutant_vector = np.clip(a + F1 * (b - c) + F2 * (d - b), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        initial_pop_size = 15\n        population = self.initialize_population(initial_pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.hybrid_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n            if self.num_evaluations < self.budget * 0.5:\n                new_pop_size = len(population) + int(5 * (self.num_evaluations / self.budget))\n                population = np.vstack((population, self.initialize_population(new_pop_size - len(population))))\n                fitness = np.hstack((fitness, self.evaluate_population(population[len(fitness):], func)))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n```\n"}
{"role": "LLaMEA", "time": "2024-11-04 14:15:43.958852", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency. (Score: 0.3185678771052579)\n\nThe selected solution to update is:\nImproved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:16:02.302833", "content": "# Description: Enhanced Adaptive Scatter Search with Dynamic Archive for Diversity and Enhanced Exploitation.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.archive_size = 5  # Dynamic archive for diversity\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def update_archive(self, population, fitness):\n        top_indices = np.argsort(fitness)[:self.archive_size]\n        return population[top_indices]\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n        archive = self.update_archive(population, fitness)  # Maintain a diverse archive\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, archive, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n            archive = self.update_archive(population, fitness)  # Update archive dynamically\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n```\n"}
{"role": "LLaMEA", "time": "2024-11-04 14:17:51.488070", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency. (Score: 0.3185678771052579)\n\nThe selected solution to update is:\nImproved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:18:04.699505", "content": "# Description: Enhanced Adaptive Scatter Search with Dynamic Neighborhood Search for Improved Convergence.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.9)  # Slightly increased upper bound for exploration\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def dynamic_neighborhood_search(self, solution, func):\n        step_size = 0.1 + 0.1 * (1 - np.exp(-0.1 * self.num_evaluations))  # Adjusted step size\n        neighbors = [solution + np.random.uniform(-step_size, step_size, self.dim) for _ in range(3)]\n        neighbors = [np.clip(n, self.lower_bound, self.upper_bound) for n in neighbors]\n        evaluated_neighbors = [(n, func(n)) for n in neighbors]\n        self.num_evaluations += len(evaluated_neighbors)\n        return min(evaluated_neighbors, key=lambda x: x[1])[0]\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.dynamic_neighborhood_search(trial, func)  # Use dynamic neighborhood search\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-04 14:18:04.702928", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency. (Score: 0.3185678771052579)\n\nThe selected solution to update is:\nImproved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:18:15.929669", "content": "# Description: Enhanced Adaptive Scatter Search with Simulated Annealing-inspired Temperature Decay for Improved Exploration-Exploitation Balance.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        temperature = 1 - (self.num_evaluations / self.budget)  # New temperature-based crossover\n        cross_prob = 0.9 - 0.3 * temperature\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-04 14:20:06.400070", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency. (Score: 0.3185678771052579)\n\nThe selected solution to update is:\nImproved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:20:22.540091", "content": "# Description: Enhanced Scatter Search integrating Dynamic Population Size and Elite Preservation for Robust Optimization.\n# Code: \n```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.9)  # Adjusted mutation factor range\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.4 * (self.num_evaluations / self.budget)  # Adjusted dynamic cross probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.25 / (1 + np.exp(-0.05 * self.num_evaluations))  # Adjusted step size\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 15 + int(10 * (1 - (self.num_evaluations / self.budget)))  # Adjusted population size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            best_idx = np.argmin(fitness)\n            for i in range(len(population)):\n                if i == best_idx:  # Elite preservation\n                    continue\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        return population[np.argmin(fitness)]\n```"}
{"role": "LLaMEA", "time": "2024-11-04 14:22:13.059191", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency. (Score: 0.3185678771052579)\n\nThe selected solution to update is:\nImproved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:22:22.434535", "content": "# Description: Enhanced Adaptive Scatter Search with Dynamic Crossover and Adaptive Population for Improved Global Exploration.\n# Code:\n# ```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.9)  # Adjusted F for broader exploration\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.8 - 0.4 * (self.num_evaluations / self.budget)  # Adjusted for dynamic adaptation\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.1 / (1 + np.exp(-0.1 * self.num_evaluations))  # Reduced step size for finer tuning\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        initial_pop_size = 15 + int(5 * (1 - (self.num_evaluations / self.budget)))  # Adjusted initial population size\n        population = self.initialize_population(initial_pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-04 14:22:22.437329", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency. (Score: 0.3185678771052579)\n\nThe selected solution to update is:\nImproved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:22:35.249282", "content": "# Description: Enhanced Adaptive Scatter Search with Adaptive Population Sizing and Opposition-Based Learning for Improved Convergence on BBOB Functions.\n# Code:\n# ```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.5, 0.9)  # Slightly increased F range for diversity\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.7 + 0.2 * np.cos(np.pi * self.num_evaluations / self.budget)  # Adaptive crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.05 * self.num_evaluations))  # Adjusted step size scaling\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def opposite_learning(self, solution):\n        return self.lower_bound + self.upper_bound - solution  # Implementing opposition-based learning\n\n    def __call__(self, func):\n        pop_size = 20  # Fixed initial population size for consistency\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n                \n                opposite_trial = self.opposite_learning(trial)  # Integrate opposite learning\n                trial_fitness = func(trial)\n                opposite_fitness = func(opposite_trial)\n                self.num_evaluations += 2\n\n                if trial_fitness < fitness[i] or opposite_fitness < fitness[i]:\n                    if opposite_fitness < trial_fitness:\n                        population[i] = opposite_trial\n                        fitness[i] = opposite_fitness\n                    else:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-04 14:22:35.252078", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency. (Score: 0.3185678771052579)\n\nThe selected solution to update is:\nImproved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:22:48.494032", "content": "# Description: Enhanced Adaptive Scatter Search with Adaptive Parameter Control and Improved Local Search for Robust Global Optimization.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.5, 0.9)  # Adjusted mutation factor\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.8 - 0.2 * (self.num_evaluations / self.budget)  # Slightly adjusted probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.3 / (1 + np.exp(-0.1 * self.num_evaluations))  # Adjusted step size\n        new_solution = solution + (self.levy_flight() * step_size * np.random.rand())  # Added stochasticity\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 12 + int(12 * (1 - (self.num_evaluations / self.budget)))  # Increased population size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-04 14:22:48.496800", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Improved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency. (Score: 0.3185678771052579)\n\nThe selected solution to update is:\nImproved Adaptive Scatter Search with Strategic Exploitation Using Levy Flights for Enhanced Local Search Efficiency.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.3 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size  # Implementing Levy flights\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:23:02.036488", "content": "# Description: Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.\n# Code: \n# ```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-04 14:24:56.102469", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability. (Score: 0.36016074191880193)\n\nThe selected solution to update is:\nAdaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:25:08.409508", "content": "# Description: Improved Adaptive Scatter Search with Rebalanced Strategy for Exploration and Exploitation using Dynamic Population Resizing and Fitness-Based Local Search.\n# Code:\n```python\nimport numpy as np\n\nclass ImprovedAdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b), self.lower_bound, self.upper_bound)  # Simplified strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.6 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n    \n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n    \n    def local_search(self, solution, func, fitness_value):\n        step_size = 0.1 + 0.9 * (1 - fitness_value / np.max(fitness_value))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 15 + int(5 * (1 - (self.num_evaluations / self.budget)))  # Adjusted dynamic resizing\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func, fitness)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-04 14:25:08.415471", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability. (Score: 0.36016074191880193)\n\nThe selected solution to update is:\nAdaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:25:19.270721", "content": "# Description: Refined Adaptive Scatter Search with Dynamic Population Sizing and Enhanced Local Search to Improve Exploration and Exploitation Balance.\n# Code: \n# ```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.6, 1.0)  # Adjusted for better exploration\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)  # Simplified mutation\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.6 * (self.num_evaluations / self.budget)  # More aggressive crossover adaptation\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.1 / (1 + np.exp(-0.2 * self.num_evaluations))  # Adjusted step size for fine-tuning\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):  # Ensure improved fitness\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 8 + int(12 * (1 - (self.num_evaluations / self.budget)))  # Dynamic population sizing\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-04 14:25:19.273723", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability. (Score: 0.36016074191880193)\n\nThe selected solution to update is:\nAdaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:25:30.976118", "content": "# Description: Adaptive Scatter Search with Enhanced Differential Mutation, Adaptive Crossover Probability, and Periodic Reinitialization to Prevent Premature Convergence.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def reinitialize_population(self, current_population, best_solution):\n        # Reinitialize half the population randomly to prevent premature convergence\n        half_size = len(current_population) // 2\n        new_population = self.initialize_population(half_size)\n        new_population = np.vstack((current_population, new_population))\n        return new_population\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            if self.num_evaluations % (self.budget // 10) == 0:  # Periodically reinitialize\n                population = self.reinitialize_population(population, population[np.argmin(fitness)])\n                fitness = self.evaluate_population(population, func)\n            \n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-04 14:27:25.538335", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability. (Score: 0.36016074191880193)\n\nThe selected solution to update is:\nAdaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:27:39.450002", "content": "# Description: Enhanced Adaptive Scatter Search with Stochastic Gradient Descent-Inspired Local Search for Improved Convergence.\n# Code:\n# ```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        grad_step = np.random.uniform(0.01, 0.05)  # SGD-inspired dynamic step size\n        gradient = (func(solution + grad_step) - func(solution)) / grad_step\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution - grad_step * gradient + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-04 14:27:39.453124", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability. (Score: 0.36016074191880193)\n\nThe selected solution to update is:\nAdaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:27:52.511277", "content": "# Description: Enhanced Adaptive Scatter Search with Dynamic Search Space Reduction and Improved Local Search Heuristic.\n# Code: \n```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.shrink_factor = 0.99\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.6, 1.0)  # Slightly increased F for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (c - a), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.6 * (self.num_evaluations / self.budget)  # Adjusted dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.5 / (1 + np.exp(-0.15 * self.num_evaluations))  # Improved step size\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def shrink_search_space(self):\n        self.lower_bound *= self.shrink_factor\n        self.upper_bound *= self.shrink_factor\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations % (self.budget // 4) == 0:\n                    self.shrink_search_space()  # Occasional shrinkage\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-04 14:29:47.559732", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability. (Score: 0.36016074191880193)\n\nThe selected solution to update is:\nAdaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:30:03.529356", "content": "# Description: Improved Adaptive Scatter Search with Strategic Local Search and Adaptive Mutation for Enhanced Convergence Speed.\n# Code:\n# ```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.7, 1.2)  # Adjusted F range for better exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (c - a), self.lower_bound, self.upper_bound)  # Adjusted mutation strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.4 * (self.num_evaluations / self.budget)  # Adjusted crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.1 / (1 + np.exp(-0.05 * self.num_evaluations))  # Adjusted step size for local search\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        trial_fitness = func(new_solution)\n        self.num_evaluations += 1\n        if trial_fitness < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-04 14:30:03.532568", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability. (Score: 0.36016074191880193)\n\nThe selected solution to update is:\nAdaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:30:17.410883", "content": "# Description: Enhanced Adaptive Scatter Search with Strategic Elite Recombination and Dynamic Population Sizing for Improved Convergence.\n# Code:\n# ```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.4, 0.8)  # Adjusted F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.4 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.15 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def elite_recombination(self, population, fitness):\n        elite_size = max(2, len(population) // 5)  # Use top 20% as elite\n        elites = population[np.argsort(fitness)[:elite_size]]\n        return np.mean(elites, axis=0)  # Recombine to produce a new candidate\n\n    def __call__(self, func):\n        pop_size = 15 + int(5 * (1 - (self.num_evaluations / self.budget)))  # Adjusted population size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n            elite_candidate = self.elite_recombination(population, fitness)\n            elite_fitness = func(elite_candidate)\n            self.num_evaluations += 1\n            if elite_fitness < np.max(fitness):\n                worst_idx = np.argmax(fitness)\n                population[worst_idx] = elite_candidate\n                fitness[worst_idx] = elite_fitness\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-04 14:30:17.413926", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability. (Score: 0.36016074191880193)\n\nThe selected solution to update is:\nAdaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:30:34.366201", "content": "# Description: Enhanced Adaptive Scatter Search with Dynamic Population and Adaptive Step Size for Improved Global and Local Search.\n# Code:\n# ```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.6, 1.0)  # Changed F range for better exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.75 - 0.5 * (self.num_evaluations / self.budget)  # Updated dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.3 / (1 + np.exp(-0.1 * self.num_evaluations))  # Increased step size\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 12 + int(8 * (1 - (self.num_evaluations / self.budget)))  # Slightly larger dynamic population\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-04 14:30:34.369484", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability. (Score: 0.36016074191880193)\n\nThe selected solution to update is:\nAdaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:30:50.327394", "content": "# Description: Enhanced Adaptive Scatter Search with Dynamic Population Size and Optimized Crossover using Historical Best.\n# Code: \n```python\nimport numpy as np\n\nclass EnhancedAdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.4, 0.8)  # Adjusted F range for better stability\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.6 * (self.num_evaluations / self.budget)  # Enhanced dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.15 / (1 + np.exp(-0.1 * self.num_evaluations))  # Tighter step size for refined search\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        while self.num_evaluations < self.budget:\n            pop_size = 12 + int(8 * (1 - (self.num_evaluations / self.budget)))  # Dynamic pop size\n            population = self.initialize_population(pop_size)\n            fitness = self.evaluate_population(population, func)\n\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        return best_solution\n```"}
{"role": "LLaMEA", "time": "2024-11-04 14:32:30.940500", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability. (Score: 0.36016074191880193)\n\nThe selected solution to update is:\nAdaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:32:45.838517", "content": "# Description: Enhanced Adaptive Scatter Search with Dynamic Population Size and Adaptive Mutation Scale for Improved Convergence.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = 0.5 + 0.4 * (self.budget - self.num_evaluations) / self.budget  # Adaptive F scale\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.6 * (self.num_evaluations / self.budget)  # More aggressive adaptive crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.3 / (1 + np.exp(-0.1 * self.num_evaluations))  # Slightly increased step size\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        initial_pop_size = 15  # Increased initial population size\n        population = self.initialize_population(initial_pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            pop_size = max(5, 10 + int(10 * (1 - (self.num_evaluations / self.budget))))  # Dynamic population size\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-04 14:32:45.841767", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability. (Score: 0.36016074191880193)\n\nThe selected solution to update is:\nAdaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:33:00.677779", "content": "# Description: Improved Adaptive Scatter Search with Adaptive Population Size and Enhanced Exploration Using Jump Strategy.\n# Code:\n# ```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.4, 0.9)  # Slightly increased exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (c - b), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.75 - 0.5 * (self.num_evaluations / self.budget)  # Adjusted for exploration\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.3 / (1 + np.exp(-0.1 * self.num_evaluations))  # Increased step size\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def jump_strategy(self, solution):\n        if np.random.rand() < 0.1:\n            jump = np.random.uniform(-1.0, 1.0, self.dim)\n            solution = np.clip(solution + jump, self.lower_bound, self.upper_bound)\n        return solution\n\n    def __call__(self, func):\n        pop_size = 15 + int(5 * (1 - (self.num_evaluations / self.budget)))  # More dynamic size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n                trial = self.jump_strategy(trial)  # New jump strategy\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-04 14:33:00.680660", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability. (Score: 0.36016074191880193)\n\nThe selected solution to update is:\nAdaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:33:16.875897", "content": "# Description: Adaptive Scatter Search with Centralized Selection and Enhanced Levy Flight for Improved Convergence in Multi-modal Landscapes.\n# Code: \n```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.4, 0.8)  # Slightly modified F range\n        mutant_vector = np.clip(best + F * (a - c), self.lower_bound, self.upper_bound)  # Revised strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.75 - 0.45 * (self.num_evaluations / self.budget)  # Adjusted crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.8):  # Enhanced Levy flight\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.3 / (1 + np.exp(-0.1 * self.num_evaluations))  # Adjusted step size\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def centralized_selection(self, population, fitness):\n        central_point = np.mean(population, axis=0)\n        distances = np.linalg.norm(population - central_point, axis=1)\n        best_idx = np.argmin(fitness + distances * 0.1)  # Promote central convergence\n        return population[best_idx], fitness[best_idx]\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_solution, best_fitness = self.centralized_selection(population, fitness)\n        return best_solution\n```"}
{"role": "LLaMEA", "time": "2024-11-04 14:35:09.246452", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability. (Score: 0.36016074191880193)\n\nThe selected solution to update is:\nAdaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:35:24.059988", "content": "# Description: Enhanced Adaptive Scatter Search with Dynamic Population Sizing and Adaptive Mutation Strategy for Improved Convergence Robustness.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = 0.5 + 0.4 * (1 - self.num_evaluations / self.budget)  # Adaptive F for better exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (best - c), self.lower_bound, self.upper_bound)  # Adjusted strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.95 - 0.6 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        initial_pop_size = 12  # Increase initial population size\n        population = self.initialize_population(initial_pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-04 14:35:24.063039", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability. (Score: 0.36016074191880193)\n\nThe selected solution to update is:\nAdaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:35:37.481320", "content": "# Description: Enhanced Adaptive Scatter Search with Self-Adjusting Parameters and Reinforced Diversity for Robust Optimization.\n# Code:\n```python\nimport numpy as np\n\nclass EnhancedAdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = 0.8 + 0.1 * np.random.rand()  # Adjusted F range for better balance\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.4 * (self.num_evaluations / self.budget)  # Modified crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.15 / (1 + np.exp(-0.1 * self.num_evaluations))  # Slightly reduced step size for precision\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 12 + int(8 * (1 - (self.num_evaluations / self.budget)))  # Fine-tuned population size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-04 14:37:25.702794", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability. (Score: 0.36016074191880193)\n\nThe selected solution to update is:\nAdaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:37:45.434282", "content": "# Description: Enhanced Adaptive Scatter Search with Adaptive Population Size and Stochastic Local Search for Robust Exploration-Exploitation Balance.\n# Code:\n# ```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.6, 0.95)  # Adjusted F range for better control\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.6 * (self.num_evaluations / self.budget)  # Adjusted crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def stochastic_local_search(self, solution, func, p_local=0.3):\n        if np.random.rand() < p_local:\n            step_size = 0.1 / (1 + np.exp(-0.1 * self.num_evaluations))\n            new_solution = solution + self.levy_flight() * step_size\n            new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n            if func(new_solution) < func(solution):\n                return new_solution\n        return solution\n\n    def __call__(self, func):\n        initial_pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(initial_pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.stochastic_local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-04 14:37:45.437577", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability. (Score: 0.36016074191880193)\n\nThe selected solution to update is:\nAdaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:37:58.713597", "content": "# Description: Enhanced Adaptive Scatter Search with Dynamic Population Size Scaling and Advanced Local Search for Robust Global Optimization.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.4, 0.9)  # Adjusted F range for balance\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.6 * (self.num_evaluations / self.budget)  # More aggressive transition\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.1 / (1 + np.exp(-0.05 * self.num_evaluations))  # Refined step scaling\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        initial_pop_size = 15  # Adjusted initial population size for better diversity\n        population = self.initialize_population(initial_pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-04 14:37:58.716959", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability. (Score: 0.36016074191880193)\n\nThe selected solution to update is:\nAdaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:38:11.824025", "content": "# Description: Adaptive Scatter Search with Enhanced Exploration using Dynamic Strategy Selection for Diverse and Efficient Search.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.4, 0.9)  # Modified F range for diverse strategies\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.8 - 0.4 * (self.num_evaluations / self.budget)  # Tuned crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.3):  # Adjusted Levy flight parameter\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.25 / (1 + np.exp(-0.1 * self.num_evaluations))  # Adjusted step size\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):  # Added dynamic strategy decision\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 12 + int(8 * (1 - (self.num_evaluations / self.budget)))  # Adjusted population size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n```\n"}
{"role": "LLaMEA", "time": "2024-11-04 14:40:06.367891", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability. (Score: 0.36016074191880193)\n\nThe selected solution to update is:\nAdaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:40:22.865062", "content": "# Description: Incorporating Adaptive Learning Rate with Enhanced Exploration and Exploitation Balance for Improved Optimization Performance.\n# Code:\n# ```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.6, 0.8)  # Adjusted F range for better balance\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.4 * (self.num_evaluations / self.budget)  # Adjusted dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def adaptive_step_size(self):\n        return 0.1 + (0.5 - 0.1) * (1 - self.num_evaluations / self.budget)  # Adaptive learning rate\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = self.adaptive_step_size()  # Use adaptive step size\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-04 14:40:22.868024", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability. (Score: 0.36016074191880193)\n\nThe selected solution to update is:\nAdaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:40:37.210602", "content": "# Description: Improved Adaptive Scatter Search with Dynamic Population Size and Enhanced Local Search for Robust Global Optimization.\n# Code:\n# ```python\nimport numpy as np\n\nclass ImprovedAdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.6, 0.9)  # Slightly narrowed F range for stability\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.5 * (self.num_evaluations / self.budget)  # Adjusted probability for more exploration\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.1 / (1 + np.exp(-0.03 * self.num_evaluations))  # More gradual step size reduction\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        initial_pop_size = 15 + int(15 * (1 - (self.num_evaluations / self.budget)))  # Dynamic pop size\n        population = self.initialize_population(initial_pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-04 14:40:37.213536", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability. (Score: 0.36016074191880193)\n\nThe selected solution to update is:\nAdaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:40:55.460493", "content": "# Description: Enhanced Adaptive Scatter Search with Dynamic Population Size Adjustment and Improved Selection for Robust Global Optimization.\n# Code: \n```python\nimport numpy as np\n\nclass EnhancedAdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.4, 1.0)  # Adjusted F range for more exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (c - a), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.6 + 0.4 * (1 - (self.num_evaluations / self.budget))  # Dynamic adjustment\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.3 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 20 + int(10 * (np.sin(self.num_evaluations / self.budget * np.pi)))  # Dynamic size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n```\n"}
{"role": "LLaMEA", "time": "2024-11-04 14:42:50.549712", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability. (Score: 0.36016074191880193)\n\nThe selected solution to update is:\nAdaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:43:04.018332", "content": "Certainly! Below is the refined solution with the required modifications.\n\n# Description: Enhanced Adaptive Scatter Search with Dynamic Population and Improved Mutation Strategy for Robust Optimization.\n# Code: \n```python\nimport numpy as np\n\nclass EnhancedAdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.6, 0.95)  # Adjusted F range for diversity\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.6 * (self.num_evaluations / self.budget)  # More adaptive crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.1 / (1 + np.exp(-0.05 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 8 + int(12 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n```\n\nThis refined algorithm introduces a more adaptive mutation strategy and slightly adjusts the population dynamics to potentially enhance diversity and exploration capabilities."}
{"role": "LLaMEA", "time": "2024-11-04 14:44:53.925273", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability. (Score: 0.36016074191880193)\n\nThe selected solution to update is:\nAdaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:45:05.423208", "content": "# Description: Enhanced Adaptive Scatter Search with Dynamic Populations and Improved Local Search for Better Global Optimization.\n# Code: \n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.6, 0.95)  # Modified F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.75 - 0.4 * (self.num_evaluations / self.budget)  # Adjusted crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.15 / (1 + np.exp(-0.1 * self.num_evaluations))  # Adjusted step size\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 12 + int(8 * (1 - (self.num_evaluations / self.budget)))  # Dynamic population size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-04 14:45:05.426069", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability. (Score: 0.36016074191880193)\n\nThe selected solution to update is:\nAdaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:45:16.690100", "content": "# Description: Enhanced Adaptive Scatter Search with Dynamic Population Size and Improved Local Search for Robust Global Optimization.\n# Code:\n```python\nimport numpy as np\n\nclass EnhancedAdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.4, 0.8)  # Adjusted F range for better balance\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.4 * (self.num_evaluations / self.budget)  # Enhanced dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.1 / (1 + np.exp(-0.1 * self.num_evaluations))  # Reduced step size for precision\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        initial_pop_size = 15  # Increased initial population size\n        population = self.initialize_population(initial_pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n```\n"}
{"role": "LLaMEA", "time": "2024-11-04 14:47:11.592555", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability. (Score: 0.36016074191880193)\n\nThe selected solution to update is:\nAdaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:47:23.461737", "content": "# Description: Enhanced Scatter Search with Dynamic Population Control and Multi-Stage Mutation Strategy for Robust Optimization.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F1 = 0.8 + 0.2 * np.sin(np.pi * self.num_evaluations / self.budget)  # Dynamic F range\n        F2 = 0.5\n        mutant_vector = np.clip(best + F1 * (a - b) + F2 * (b - c), self.lower_bound, self.upper_bound)  # Multi-stage mutation\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.6 * (self.num_evaluations / self.budget)  # More aggressive crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.log(1 + self.num_evaluations))  # Logarithmic decay\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        initial_pop_size = 20  # Dynamic size control\n        population = self.initialize_population(initial_pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-04 14:47:23.464658", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability. (Score: 0.36016074191880193)\n\nThe selected solution to update is:\nAdaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:47:34.292700", "content": "# Description: Adaptive Scatter Search with Enhanced Diversity and Dynamic Mutation Rate Control for Robust Global Search Performance.\n# Code: \n# ```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.4, 0.8) + 0.3 * (1 - self.num_evaluations / self.budget)  # Dynamic F\n        mutant_vector = np.clip(best + F * (a - b) + F * (c - a), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.75 + 0.25 * np.sin(np.pi * self.num_evaluations / (2 * self.budget))  # Sinusoidal crossover\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.3 / (1 + np.exp(-0.1 * self.num_evaluations))  # Adjusted step size\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 12 + int(8 * (1 - (self.num_evaluations / self.budget)))  # Adjusted population size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-04 14:47:34.295554", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability. (Score: 0.36016074191880193)\n\nThe selected solution to update is:\nAdaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:47:46.023176", "content": "# Description: Enhanced Adaptive Scatter Search with Dynamic Population Adjustments and Elite Exploitation for Improved Performance.\n# Code: \n```python\nimport numpy as np\n\nclass EnhancedAdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.6, 0.95)  # Slightly shifted F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (best - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.3 * (self.num_evaluations / self.budget)  # Adjusted dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def elite_exploitation(self, population, fitness, func):\n        elite_idx = np.argmin(fitness)\n        elite = population[elite_idx]\n        new_elite = self.local_search(elite, func)\n        if func(new_elite) < fitness[elite_idx]:\n            population[elite_idx] = new_elite\n            fitness[elite_idx] = func(new_elite)\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n            self.elite_exploitation(population, fitness, func)  # Added elite exploitation\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-04 14:49:38.481071", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability. (Score: 0.36016074191880193)\n\nThe selected solution to update is:\nAdaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:49:52.097749", "content": "# Description: Improved Adaptive Scatter Search with Dynamic Population Sizing and Enhanced Local Exploration for Robust Search Performance.\n# Code: \n```python\nimport numpy as np\n\nclass ImprovedAdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = np.random.uniform(0.4, 0.8)  # Slightly reduced F range for balanced exploration\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)  # Updated mutation strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.6 * (self.num_evaluations / self.budget)  # Further dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.1 / (1 + np.exp(-0.05 * self.num_evaluations))  # Enhanced local search exploration\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        initial_pop_size = 12 + int(8 * (1 - (self.num_evaluations / self.budget)))  # Adjusted initial population size\n        population = self.initialize_population(initial_pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-04 14:51:41.923263", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability. (Score: 0.36016074191880193)\n\nThe selected solution to update is:\nAdaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:51:57.210869", "content": "# Description: Adaptive Scatter Search with Dynamic Search Space Reduction and Enhanced Local Search Using Gradient Estimation for Efficient Convergence.\n# Code:\n# ```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.6, 0.8)  # Adjusted F range for balanced exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.4 * (self.num_evaluations / self.budget)  # Slightly adjusted crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n    \n    def levy_flight(self, L=1.2):  # Slightly adjusted L for variability in step sizes\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        grad_approx = self.gradient_approximation(solution, func)  # Use gradient approximation\n        step_size = 0.1 / (1 + np.exp(-0.1 * self.num_evaluations))  # Adjusted step size for refinement\n        new_solution = solution - step_size * grad_approx  # Gradient descent step\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def gradient_approximation(self, solution, func, epsilon=1e-8):\n        grad = np.zeros(self.dim)\n        for i in range(self.dim):\n            perturbed = np.array(solution)\n            perturbed[i] += epsilon\n            grad[i] = (func(perturbed) - func(solution)) / epsilon\n        return grad\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-04 14:51:57.213944", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability. (Score: 0.36016074191880193)\n\nThe selected solution to update is:\nAdaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:52:13.108340", "content": "# Description: Enhanced Adaptive Scatter Search with Self-Adaptive Parameters and Elite Exploitation for Superior Convergence.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12  # Adjusted population size\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.4, 0.9)  # Slightly adjusted F range\n        mutant_vector = np.clip(best + F * (a - b) + F * (c - a), self.lower_bound, self.upper_bound)  # New formula\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.75 - 0.4 * (self.num_evaluations / self.budget)  # Adjusted crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.1 / (1 + np.exp(-0.1 * self.num_evaluations))  # Adjusted step size\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def elite_exploitation(self, population, fitness, func):\n        best_idx = np.argmin(fitness)\n        elite = population[best_idx]\n        perturbed = elite + np.random.uniform(-0.1, 0.1, self.dim)  # Minor perturbation for exploitation\n        perturbed = np.clip(perturbed, self.lower_bound, self.upper_bound)\n        return perturbed if func(perturbed) < fitness[best_idx] else elite\n\n    def __call__(self, func):\n        population = self.initialize_population(self.pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n            population[np.argmin(fitness)] = self.elite_exploitation(population, fitness, func)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-04 14:54:07.021700", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability. (Score: 0.36016074191880193)\n\nThe selected solution to update is:\nAdaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:54:24.902383", "content": "# Description: Enhanced Adaptive Scatter Search with Improved Mutation and Dynamic Population Sizing for Robust Global Optimization.\n# Code:\n# ```python\nimport numpy as np\n\nclass EnhancedAdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        d = population[np.random.choice(idxs, 1, replace=False)][0]  # Added\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)\n        mutant_vector = np.clip(best + F * (a - b) + F * (c - d), self.lower_bound, self.upper_bound)  # Modified\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(15 * (1 - (self.num_evaluations / self.budget)))  # Modified\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-04 14:54:24.905294", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability. (Score: 0.36016074191880193)\n\nThe selected solution to update is:\nAdaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:54:43.455664", "content": "# Description: Enhanced Adaptive Scatter Search with Adaptive Population Size and Elite-Based Levy Flight for Improved Convergence and Exploration.\n# Code:\n# ```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.4, 0.8)  # Slightly adjusted F range for balance\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.8 - 0.4 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5, best_solution=None):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        if best_solution is not None:\n            u += 0.1 * (best_solution - u)  # Bias towards the best solution\n        return u\n\n    def local_search(self, solution, func, best_solution):\n        step_size = 0.15 / (1 + np.exp(-0.1 * self.num_evaluations))  # Adjusted step size\n        new_solution = solution + self.levy_flight(best_solution=best_solution) * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 15 + int(5 * (1 - (self.num_evaluations / self.budget)))  # Adjusted population sizing\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n        best_idx = np.argmin(fitness)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func, population[best_idx])\n                \n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i  # Update the best index\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        return population[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-04 14:54:43.459144", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability. (Score: 0.36016074191880193)\n\nThe selected solution to update is:\nAdaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:54:56.168179", "content": "# Description: Enhanced Adaptive Scatter Search with Dynamic Exploration-Exploitation Balance using Adaptive Mutation and Local Search Intensification.\n# Code: \n```python\nimport numpy as np\n\nclass EnhancedAdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def adaptive_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = 0.5 + 0.5 * (self.num_evaluations / self.budget)  # Adaptive scaling factor\n        mutant_vector = np.clip(best + F * (a - b), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.7 * (self.num_evaluations / self.budget)  # Adjusted crossover probability for more exploration at the start\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def local_search(self, solution, func):\n        step_size = 0.1 / (1 + np.exp(-0.05 * self.num_evaluations))  # Reduced step size for finer local search\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.adaptive_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-04 14:56:47.334815", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability. (Score: 0.36016074191880193)\n\nThe selected solution to update is:\nAdaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:57:05.926833", "content": "# Description: Enhanced Adaptive Scatter Search with Improved Diversity Control and Step Size Adaptation for Robust Global Optimization.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        F = 0.8 + 0.2 * (1 - self.num_evaluations / self.budget)  # Decrease F over time for exploitation\n        mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)  # Adjusted strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.4 * (self.num_evaluations / self.budget)  # Adjusted dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.15 / (1 + np.exp(-0.1 * self.num_evaluations))  # Adjusted step size\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(20 * (1 - (self.num_evaluations / self.budget)))  # Increased population size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-04 14:58:54.482117", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability. (Score: 0.36016074191880193)\n\nThe selected solution to update is:\nAdaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 14:59:11.560181", "content": "# Description: Enhanced Adaptive Scatter Search with Dynamic Population Control and Improved Local Search using Sinusoidal Perturbation.\n# Code: \n```python\nimport numpy as np\n\nclass EnhancedAdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.6, 0.95)  # Adjusted F range for better diversity\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.75  # Adjusted to a fixed value for better stability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def sinusoidal_perturbation(self):\n        return np.sin(np.linspace(0, np.pi, self.dim)) * np.random.uniform(-0.5, 0.5, self.dim)\n\n    def local_search(self, solution, func):\n        perturbation = self.sinusoidal_perturbation()\n        new_solution = solution + perturbation\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 20  # Fixed population size for stability\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-04 15:01:13.699174", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability. (Score: 0.36016074191880193)\n\nThe selected solution to update is:\nAdaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability for Improved Global Search Capability.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        F = np.random.uniform(0.5, 0.9)  # Increased F range for exploration\n        mutant_vector = np.clip(best + F * (a - b) + F * (b - c), self.lower_bound, self.upper_bound)  # New strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)  # More dynamic crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 15:01:28.256150", "content": "# Description: Refined Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability, integrating Elite Preservation and Chaotic Map Initialization for Robust Global Search.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        chaotic_initialization = np.random.rand(size, self.dim)\n        chaotic_map = 0.4 + 0.6 * chaotic_initialization\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * chaotic_map\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        elite_idx = np.argmin(fitness)\n        elite = population[elite_idx]\n        F = np.random.uniform(0.5, 0.9)\n        mutant_vector = np.clip(elite + F * (a - b), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-04 15:03:21.334389", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Refined Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability, integrating Elite Preservation and Chaotic Map Initialization for Robust Global Search. (Score: 0.3744332310295768)\n\nThe selected solution to update is:\nRefined Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability, integrating Elite Preservation and Chaotic Map Initialization for Robust Global Search.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        chaotic_initialization = np.random.rand(size, self.dim)\n        chaotic_map = 0.4 + 0.6 * chaotic_initialization\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * chaotic_map\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        elite_idx = np.argmin(fitness)\n        elite = population[elite_idx]\n        F = np.random.uniform(0.5, 0.9)\n        mutant_vector = np.clip(elite + F * (a - b), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.28.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 15:03:34.120865", "content": "# Description: Enhanced Adaptive Scatter Search with Self-Adaptive Mutation Strategy and Dynamic Population Sizing for Improved Exploration and Exploitation Balance.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        chaotic_initialization = np.random.rand(size, self.dim)\n        chaotic_map = 0.4 + 0.6 * chaotic_initialization\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * chaotic_map\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        elite_idx = np.argmin(fitness)\n        elite = population[elite_idx]\n        F = 0.5 + 0.4 * np.random.rand()  # Self-adaptive component\n        mutant_vector = np.clip(elite + F * (a - b + c - elite), self.lower_bound, self.upper_bound)  # Enhanced mutation\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        initial_pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(initial_pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            current_pop_size = max(5, int(10 + 10 * (1 - (self.num_evaluations / self.budget))))\n            if len(population) != current_pop_size:\n                population = self.initialize_population(current_pop_size)\n                fitness = self.evaluate_population(population, func)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-04 15:05:25.076080", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Refined Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability, integrating Elite Preservation and Chaotic Map Initialization for Robust Global Search. (Score: 0.3744332310295768)\n\nThe selected solution to update is:\nRefined Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability, integrating Elite Preservation and Chaotic Map Initialization for Robust Global Search.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        chaotic_initialization = np.random.rand(size, self.dim)\n        chaotic_map = 0.4 + 0.6 * chaotic_initialization\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * chaotic_map\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        elite_idx = np.argmin(fitness)\n        elite = population[elite_idx]\n        F = np.random.uniform(0.5, 0.9)\n        mutant_vector = np.clip(elite + F * (a - b), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.28.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 15:05:39.617309", "content": "# Description: Adaptive Scatter Search with Enhanced Differential Mutation, Elite Preservation, and Dynamic Levy Flight to Boost Global Search.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        chaotic_initialization = np.random.rand(size, self.dim)\n        chaotic_map = 0.4 + 0.6 * chaotic_initialization\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * chaotic_map\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        elite_idx = np.argmin(fitness)\n        elite = population[elite_idx]\n        F = 0.5 + ((self.budget - self.num_evaluations) / self.budget) * 0.4  # Dynamic F\n        mutant_vector = np.clip(elite + F * (a - b), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        adjustment = np.random.uniform(0.8, 1.2)  # Dynamic adjustment\n        new_solution = solution + self.levy_flight() * step_size * adjustment\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-04 15:07:33.271928", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Refined Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability, integrating Elite Preservation and Chaotic Map Initialization for Robust Global Search. (Score: 0.3744332310295768)\n\nThe selected solution to update is:\nRefined Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability, integrating Elite Preservation and Chaotic Map Initialization for Robust Global Search.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        chaotic_initialization = np.random.rand(size, self.dim)\n        chaotic_map = 0.4 + 0.6 * chaotic_initialization\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * chaotic_map\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        elite_idx = np.argmin(fitness)\n        elite = population[elite_idx]\n        F = np.random.uniform(0.5, 0.9)\n        mutant_vector = np.clip(elite + F * (a - b), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.28.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 15:07:48.860843", "content": "# Description: Enhanced Adaptive Scatter Search with Dynamic Population Size and Adaptive Step Size Control for Efficient Exploitation-Exploration Balance.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        chaotic_initialization = np.random.rand(size, self.dim)\n        chaotic_map = 0.4 + 0.6 * chaotic_initialization\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * chaotic_map\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        elite_idx = np.argmin(fitness)\n        elite = population[elite_idx]\n        F = np.random.uniform(0.6, 0.95)  # Adjusted mutation factor\n        mutant_vector = np.clip(elite + F * (a - b), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.6 * (self.num_evaluations / self.budget)  # Adjusted crossover probability\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.3 / (1 + np.exp(-0.05 * self.num_evaluations))  # Adjusted step size\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        initial_pop_size = 20  # Adjusted initial population size\n        pop_size_increment = 5  # Incremental step for population size\n        population = self.initialize_population(initial_pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n            if self.num_evaluations < self.budget:\n                population_size = initial_pop_size + (self.num_evaluations // self.budget) * pop_size_increment\n                population = np.vstack((population, self.initialize_population(pop_size_increment)))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-04 15:07:48.877483", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Refined Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability, integrating Elite Preservation and Chaotic Map Initialization for Robust Global Search. (Score: 0.3744332310295768)\n\nThe selected solution to update is:\nRefined Adaptive Scatter Search with Enhanced Differential Mutation and Adaptive Crossover Probability, integrating Elite Preservation and Chaotic Map Initialization for Robust Global Search.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        chaotic_initialization = np.random.rand(size, self.dim)\n        chaotic_map = 0.4 + 0.6 * chaotic_initialization\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * chaotic_map\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        elite_idx = np.argmin(fitness)\n        elite = population[elite_idx]\n        F = np.random.uniform(0.5, 0.9)\n        mutant_vector = np.clip(elite + F * (a - b), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        new_solution = solution + self.levy_flight() * step_size\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(10 * (1 - (self.num_evaluations / self.budget)))\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.28.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 15:08:02.530965", "content": "# Description: Enhanced Adaptive Scatter Search with Self-Adaptive Mutation Factor, Dynamic Population Resizing, and Momentum-Driven Local Search for Improved Exploration-Exploitation Balance.\n# Code: \n```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        chaotic_initialization = np.random.rand(size, self.dim)\n        chaotic_map = 0.4 + 0.6 * chaotic_initialization\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * chaotic_map\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        elite_idx = np.argmin(fitness)\n        elite = population[elite_idx]\n        F = np.random.uniform(0.4, 1.0)  # Self-adaptive mutation factor\n        mutant_vector = np.clip(elite + F * (a - b), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        momentum = 0.9  # Added momentum term\n        step = self.levy_flight() * step_size * momentum\n        new_solution = solution + step\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(8 * (1 - (self.num_evaluations / self.budget)))  # Dynamically adjust population size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n```"}
{"role": "LLaMEA", "time": "2024-11-04 15:09:56.135575", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Enhanced Adaptive Scatter Search with Self-Adaptive Mutation Factor, Dynamic Population Resizing, and Momentum-Driven Local Search for Improved Exploration-Exploitation Balance. (Score: 0.3750471254926053)\n\nThe selected solution to update is:\nEnhanced Adaptive Scatter Search with Self-Adaptive Mutation Factor, Dynamic Population Resizing, and Momentum-Driven Local Search for Improved Exploration-Exploitation Balance.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        chaotic_initialization = np.random.rand(size, self.dim)\n        chaotic_map = 0.4 + 0.6 * chaotic_initialization\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * chaotic_map\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        elite_idx = np.argmin(fitness)\n        elite = population[elite_idx]\n        F = np.random.uniform(0.4, 1.0)  # Self-adaptive mutation factor\n        mutant_vector = np.clip(elite + F * (a - b), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        momentum = 0.9  # Added momentum term\n        step = self.levy_flight() * step_size * momentum\n        new_solution = solution + step\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(8 * (1 - (self.num_evaluations / self.budget)))  # Dynamically adjust population size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.29.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 15:10:09.575996", "content": "# Description: Introduce adaptive crossover probability and dynamic search radius in local search to improve exploration and convergence speed.\n# Code:\n# ```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        chaotic_initialization = np.random.rand(size, self.dim)\n        chaotic_map = 0.4 + 0.6 * chaotic_initialization\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * chaotic_map\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        elite_idx = np.argmin(fitness)\n        elite = population[elite_idx]\n        F = np.random.uniform(0.4, 1.0)  # Self-adaptive mutation factor\n        mutant_vector = np.clip(elite + F * (a - b), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.9 - 0.7 * (self.num_evaluations / self.budget)  # Increased adaptive range\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.5 / (1 + np.exp(-0.2 * self.num_evaluations))  # Dynamic step size\n        momentum = 0.9  # Preserved momentum term\n        step = self.levy_flight() * step_size * momentum\n        new_solution = solution + step\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(8 * (1 - (self.num_evaluations / self.budget)))  # Dynamic population size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n# ```"}
{"role": "LLaMEA", "time": "2024-11-04 15:10:09.579186", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\n\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the BBOB test suite of 24 noiseless functions. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nAdaptiveScatterSearch: Enhanced Adaptive Scatter Search with Self-Adaptive Mutation Factor, Dynamic Population Resizing, and Momentum-Driven Local Search for Improved Exploration-Exploitation Balance. (Score: 0.3750471254926053)\n\nThe selected solution to update is:\nEnhanced Adaptive Scatter Search with Self-Adaptive Mutation Factor, Dynamic Population Resizing, and Momentum-Driven Local Search for Improved Exploration-Exploitation Balance.\n\nWith code:\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        chaotic_initialization = np.random.rand(size, self.dim)\n        chaotic_map = 0.4 + 0.6 * chaotic_initialization\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * chaotic_map\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        elite_idx = np.argmin(fitness)\n        elite = population[elite_idx]\n        F = np.random.uniform(0.4, 1.0)  # Self-adaptive mutation factor\n        mutant_vector = np.clip(elite + F * (a - b), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.85 - 0.5 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        step_size = 0.2 / (1 + np.exp(-0.1 * self.num_evaluations))\n        momentum = 0.9  # Added momentum term\n        step = self.levy_flight() * step_size * momentum\n        new_solution = solution + step\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 10 + int(8 * (1 - (self.num_evaluations / self.budget)))  # Dynamically adjust population size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n\nThe algorithm AdaptiveScatterSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.29.\n\n\nNow, refine the strategy of the selected solution to improve it. Make sure you \nonly change 20.0% of the code, which means if the code has 100 lines, you \ncan only change 20.0 lines, and the rest lines should remain the same. \nThis changing rate 20.0% is the mandatory requirement, you cannot change \nmore or less than this rate.\n\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n# ```python\n# <code>\n# ```\n# \n"}
{"role": "gpt-4o", "time": "2024-11-04 15:10:25.139626", "content": "# Description: Hybridized Adaptive Scatter Search with Elite-based Local Refinement and Dynamic Mutation for Enhanced Optimization Efficiency.\n# Code: \n# ```python\nimport numpy as np\n\nclass AdaptiveScatterSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_evaluations = 0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def initialize_population(self, size):\n        chaotic_initialization = np.random.rand(size, self.dim)\n        chaotic_map = 0.4 + 0.6 * chaotic_initialization\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * chaotic_map\n\n    def evaluate_population(self, population, func):\n        fitness = np.apply_along_axis(func, 1, population)\n        self.num_evaluations += len(fitness)\n        return fitness\n\n    def differential_mutation(self, target_idx, population, fitness):\n        idxs = [idx for idx in range(len(population)) if idx != target_idx]\n        a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n        elite_idx = np.argmin(fitness)\n        elite = population[elite_idx]\n        F = np.random.uniform(0.5, 1.2)  # Adjusted adaptive mutation factor\n        mutant_vector = np.clip(elite + F * (a - b), self.lower_bound, self.upper_bound)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        cross_prob = 0.8 - 0.4 * (self.num_evaluations / self.budget)\n        return np.array([mutant[i] if np.random.rand() < cross_prob else target[i] for i in range(self.dim)])\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim) * (1 / np.power(np.abs(np.random.normal(0, 1, self.dim)), 1/L))\n        return u\n\n    def local_search(self, solution, func):\n        elite_step = 0.1  # Introduced elite-based refinement step\n        step_size = 0.15 / (1 + np.exp(-0.1 * self.num_evaluations))\n        momentum = 0.95  # Adjusted momentum term\n        step = self.levy_flight() * step_size * momentum\n        new_solution = solution + step + elite_step\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        if func(new_solution) < func(solution):\n            return new_solution\n        return solution\n\n    def __call__(self, func):\n        pop_size = 12 + int(6 * (1 - (self.num_evaluations / self.budget)))  # Slightly adjusted population size\n        population = self.initialize_population(pop_size)\n        fitness = self.evaluate_population(population, func)\n\n        while self.num_evaluations < self.budget:\n            for i in range(len(population)):\n                mutant = self.differential_mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial = self.local_search(trial, func)\n\n                trial_fitness = func(trial)\n                self.num_evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if self.num_evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]\n# ```"}
