{"id": "3ae4b628-0508-4d7d-8286-78d4024c8d52", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Common heuristic for DE\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.99\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _mutate(self, idx, population):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(population[a] + self.mutation_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one element is from mutant\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                # Simulated Annealing acceptance criteria\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate  # Cool down the temperature\n\n        return best_solution", "name": "HybridDESA", "description": "A novel hybrid algorithm combining Differential Evolution and Simulated Annealing for enhanced exploration and exploitation in continuous black box optimization.", "configspace": "", "generation": 0, "fitness": 0.1321447591121471, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.17.", "error": "", "parent_id": null, "metadata": {"aucs": [0.13425849757455965, 0.1381598539968769, 0.14490037312405224, 0.14908097925844266, 0.16364372344596612, 0.17080283455073153, 0.1373353801734013, 0.15181647266508047, 0.1434322924842838, 0.07355034912425451, 0.07828952414056622, 0.07814825637616818, 0.062155285455592124, 0.05100297935107756, 0.07652938978365542, 0.06856628881659066, 0.06623369611759067, 0.08672966709849661, 0.032271764582796125, 0.0386598559146103, 0.031354200422472944, 0.04087557190109259, 0.054438202545271985, 0.033265441671409324, 0.04548725569905476, 0.04340228294769677, 0.03749759183390999, 0.04797864868824109, 0.02275367111267279, 0.03153512105262524, 0.02386845305312213, 0.03392308226101559, 0.026669641872461236, 0.03653950507523096, 0.026547947185252108, 0.028262194327489443, 0.9290096287472159, 0.763818476304579, 0.85613145666422, 0.8375495146352231, 0.8007890584951443, 0.9506984094317505, 0.9390041283467817, 0.9844795152429242, 0.8839481847767507, 0.09039279942624268, 0.07937036833165656, 0.06803044667275537, 0.065317740929982, 0.05868480096531714, 0.08356932014055041, 0.11127848928635509, 0.08930161313246976, 0.10825146120048468, 0.14151756179723485, 0.09063849542036573, 0.10671949753025112, 0.12569517698936483, 0.12177764126630541, 0.13975140894117521, 0.1283241093942401, 0.11531962058382483, 0.11429381846640341, 0.06079465189529054, 0.09807415405931263, 0.06520284415534428, 0.06045379389826844, 0.06972112558917087, 0.07561358273359597, 0.07401951689414676, 0.06185976430082796, 0.07272410605842583, 0.07684223733211526, 0.07617751489934887, 0.10248290094244528, 0.07048008287968821, 0.09849024886412483, 0.09952749061707766, 0.07193018522521055, 0.06240432837988341, 0.06476258347919084, 0.029239585814539337, 0.042965310075783636, 0.04542320775358821, 0.0441141852583572, 0.06965758614375295, 0.030091996437255353, 0.060812197477901675, 0.043861112656721324, 0.03658167444911453, 0.12290564791314029, 0.10841088746015537, 0.16473819108195398, 0.10890106835378466, 0.11339457432568345, 0.1514132039449141, 0.10720748887214016, 0.12621215785382867, 0.1448901665534731, 0.031716544032152294, 0.020677155076420206, 0.02119501909665833, 0.024450114807489487, 0.03002245717026253, 0.01871460581163442, 0.02266762952726753, 0.021663722546297892, 0.04922782260020142, 0.013824290648283721, 0.0043195431876627, 0.0034332632302376265, 0.004993946031265684, 0.005062195361792532, 0.01297365038672893, 0.009827954775411096, 0.011121167175086488, 0.004595456615733906, 0.1904302292558525, 0.16866462861671827, 0.16856250879191415, 0.17280471280405185, 0.17359055442362747, 0.1673524122881721, 0.18864612006625847, 0.1714428134305901, 0.17405462013463602, 0.058763680225233705, 0.04286046697821255, 0.05514405398196687, 0.04763627332341425, 0.03429781522921571, 0.03464759086322067, 0.04153649622160793, 0.03018926604179928, 0.04404528975828492, 0.15955040034105328, 0.13289824674086248, 0.16202730939625087, 0.12993656417247368, 0.12954678450304546, 0.12031214410443447, 0.1357696948091871, 0.13516665634012737, 0.13157107640238774, 0.1375743848420441, 0.14249668484233402, 0.1613932299901244, 0.1692014763592824, 0.15684804528191998, 0.14129810551181543, 0.15013321579334793, 0.17377774300845283, 0.17752612777328447, 0.10045060415884677, 0.09733624860230117, 0.09279832588533632, 0.10255055811330693, 0.09607309500157735, 0.13604663650626736, 0.10577253636874173, 0.10607169036256314, 0.10293008727330089, 0.14415143342062564, 0.1332654230515411, 0.15617077573226912, 0.1606368559504623, 0.1376757996866783, 0.1440126636328496, 0.13550623933870487, 0.13196812223927568, 0.14149019520237327, 0.17596601796355005, 0.16982746649685831, 0.16496284837965502, 0.186367537807548, 0.16430786993558244, 0.1653457181491509, 0.16649888028482418, 0.16354347517240386, 0.17411455468907822, 0.15497406482978326, 0.14985711301377214, 0.13173446551933377, 0.1561973945679812, 0.12128628978671419, 0.11642613662784929, 0.24232265579054946, 0.15688404488978847, 0.11636174674523281, 0.14657275594725538, 0.12155840065350298, 0.1371404170603493, 0.12135609015012283, 0.13395471064511477, 0.09763794912939028, 0.13516486484906254, 0.13915942265309678, 0.12479731799872429, 0.19731881933969975, 0.19013314837067097, 0.18443174676694485, 0.19031487988444185, 0.18161599099850256, 0.17985400397873186, 0.1830300912544306, 0.19729744211786315, 0.1879882101548681, 0.04525785196699195, 0.03336307089262447, 0.05346343138998089, 0.039448333491558296, 0.035568970899336305, 0.038455284771352516, 0.037183256687706834, 0.04247072397480223, 0.03865087685924096]}, "mutation_prompt": null}
{"id": "79a4e4fa-fb17-4612-a325-bf8f564461d4", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Common heuristic for DE\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.99\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _mutate(self, idx, population):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(population[a] + self.mutation_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one element is from mutant\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                # Simulated Annealing acceptance criteria\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate  # Cool down the temperature\n\n        return best_solution", "name": "HybridDESA", "description": "A novel hybrid algorithm combining Differential Evolution and Simulated Annealing for enhanced exploration and exploitation in continuous black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3ae4b628-0508-4d7d-8286-78d4024c8d52", "metadata": {"aucs": [0.13425849757455965, 0.1381598539968769, 0.14490037312405224, 0.14908097925844266, 0.16364372344596612, 0.17080283455073153, 0.1373353801734013, 0.15181647266508047, 0.1434322924842838, 0.07355034912425451, 0.07828952414056622, 0.07814825637616818, 0.062155285455592124, 0.05100297935107756, 0.07652938978365542, 0.06856628881659066, 0.06623369611759067, 0.08672966709849661, 0.032271764582796125, 0.0386598559146103, 0.031354200422472944, 0.04087557190109259, 0.054438202545271985, 0.033265441671409324, 0.04548725569905476, 0.04340228294769677, 0.03749759183390999, 0.04797864868824109, 0.02275367111267279, 0.03153512105262524, 0.02386845305312213, 0.03392308226101559, 0.026669641872461236, 0.03653950507523096, 0.026547947185252108, 0.028262194327489443, 0.9290096287472159, 0.763818476304579, 0.85613145666422, 0.8375495146352231, 0.8007890584951443, 0.9506984094317505, 0.9390041283467817, 0.9844795152429242, 0.8839481847767507, 0.09039279942624268, 0.07937036833165656, 0.06803044667275537, 0.065317740929982, 0.05868480096531714, 0.08356932014055041, 0.11127848928635509, 0.08930161313246976, 0.10825146120048468, 0.14151756179723485, 0.09063849542036573, 0.10671949753025112, 0.12569517698936483, 0.12177764126630541, 0.13975140894117521, 0.1283241093942401, 0.11531962058382483, 0.11429381846640341, 0.06079465189529054, 0.09807415405931263, 0.06520284415534428, 0.06045379389826844, 0.06972112558917087, 0.07561358273359597, 0.07401951689414676, 0.06185976430082796, 0.07272410605842583, 0.07684223733211526, 0.07617751489934887, 0.10248290094244528, 0.07048008287968821, 0.09849024886412483, 0.09952749061707766, 0.07193018522521055, 0.06240432837988341, 0.06476258347919084, 0.029239585814539337, 0.042965310075783636, 0.04542320775358821, 0.0441141852583572, 0.06965758614375295, 0.030091996437255353, 0.060812197477901675, 0.043861112656721324, 0.03658167444911453, 0.12290564791314029, 0.10841088746015537, 0.16473819108195398, 0.10890106835378466, 0.11339457432568345, 0.1514132039449141, 0.10720748887214016, 0.12621215785382867, 0.1448901665534731, 0.031716544032152294, 0.020677155076420206, 0.02119501909665833, 0.024450114807489487, 0.03002245717026253, 0.01871460581163442, 0.02266762952726753, 0.021663722546297892, 0.04922782260020142, 0.013824290648283721, 0.0043195431876627, 0.0034332632302376265, 0.004993946031265684, 0.005062195361792532, 0.01297365038672893, 0.009827954775411096, 0.011121167175086488, 0.004595456615733906, 0.1904302292558525, 0.16866462861671827, 0.16856250879191415, 0.17280471280405185, 0.17359055442362747, 0.1673524122881721, 0.18864612006625847, 0.1714428134305901, 0.17405462013463602, 0.058763680225233705, 0.04286046697821255, 0.05514405398196687, 0.04763627332341425, 0.03429781522921571, 0.03464759086322067, 0.04153649622160793, 0.03018926604179928, 0.04404528975828492, 0.15955040034105328, 0.13289824674086248, 0.16202730939625087, 0.12993656417247368, 0.12954678450304546, 0.12031214410443447, 0.1357696948091871, 0.13516665634012737, 0.13157107640238774, 0.1375743848420441, 0.14249668484233402, 0.1613932299901244, 0.1692014763592824, 0.15684804528191998, 0.14129810551181543, 0.15013321579334793, 0.17377774300845283, 0.17752612777328447, 0.10045060415884677, 0.09733624860230117, 0.09279832588533632, 0.10255055811330693, 0.09607309500157735, 0.13604663650626736, 0.10577253636874173, 0.10607169036256314, 0.10293008727330089, 0.14415143342062564, 0.1332654230515411, 0.15617077573226912, 0.1606368559504623, 0.1376757996866783, 0.1440126636328496, 0.13550623933870487, 0.13196812223927568, 0.14149019520237327, 0.17596601796355005, 0.16982746649685831, 0.16496284837965502, 0.186367537807548, 0.16430786993558244, 0.1653457181491509, 0.16649888028482418, 0.16354347517240386, 0.17411455468907822, 0.15497406482978326, 0.14985711301377214, 0.13173446551933377, 0.1561973945679812, 0.12128628978671419, 0.11642613662784929, 0.24232265579054946, 0.15688404488978847, 0.11636174674523281, 0.14657275594725538, 0.12155840065350298, 0.1371404170603493, 0.12135609015012283, 0.13395471064511477, 0.09763794912939028, 0.13516486484906254, 0.13915942265309678, 0.12479731799872429, 0.19731881933969975, 0.19013314837067097, 0.18443174676694485, 0.19031487988444185, 0.18161599099850256, 0.17985400397873186, 0.1830300912544306, 0.19729744211786315, 0.1879882101548681, 0.04525785196699195, 0.03336307089262447, 0.05346343138998089, 0.039448333491558296, 0.035568970899336305, 0.038455284771352516, 0.037183256687706834, 0.04247072397480223, 0.03865087685924096]}, "mutation_prompt": null}
{"id": "c6d0a840-ac45-4ae9-b952-9ec1be79fe77", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Common heuristic for DE\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.99\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _mutate(self, idx, population):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(population[a] + self.mutation_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one element is from mutant\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                # Simulated Annealing acceptance criteria\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate  # Cool down the temperature\n\n        return best_solution", "name": "HybridDESA", "description": "A novel hybrid algorithm combining Differential Evolution and Simulated Annealing for enhanced exploration and exploitation in continuous black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3ae4b628-0508-4d7d-8286-78d4024c8d52", "metadata": {"aucs": [0.13425849757455965, 0.1381598539968769, 0.14490037312405224, 0.14908097925844266, 0.16364372344596612, 0.17080283455073153, 0.1373353801734013, 0.15181647266508047, 0.1434322924842838, 0.07355034912425451, 0.07828952414056622, 0.07814825637616818, 0.062155285455592124, 0.05100297935107756, 0.07652938978365542, 0.06856628881659066, 0.06623369611759067, 0.08672966709849661, 0.032271764582796125, 0.0386598559146103, 0.031354200422472944, 0.04087557190109259, 0.054438202545271985, 0.033265441671409324, 0.04548725569905476, 0.04340228294769677, 0.03749759183390999, 0.04797864868824109, 0.02275367111267279, 0.03153512105262524, 0.02386845305312213, 0.03392308226101559, 0.026669641872461236, 0.03653950507523096, 0.026547947185252108, 0.028262194327489443, 0.9290096287472159, 0.763818476304579, 0.85613145666422, 0.8375495146352231, 0.8007890584951443, 0.9506984094317505, 0.9390041283467817, 0.9844795152429242, 0.8839481847767507, 0.09039279942624268, 0.07937036833165656, 0.06803044667275537, 0.065317740929982, 0.05868480096531714, 0.08356932014055041, 0.11127848928635509, 0.08930161313246976, 0.10825146120048468, 0.14151756179723485, 0.09063849542036573, 0.10671949753025112, 0.12569517698936483, 0.12177764126630541, 0.13975140894117521, 0.1283241093942401, 0.11531962058382483, 0.11429381846640341, 0.06079465189529054, 0.09807415405931263, 0.06520284415534428, 0.06045379389826844, 0.06972112558917087, 0.07561358273359597, 0.07401951689414676, 0.06185976430082796, 0.07272410605842583, 0.07684223733211526, 0.07617751489934887, 0.10248290094244528, 0.07048008287968821, 0.09849024886412483, 0.09952749061707766, 0.07193018522521055, 0.06240432837988341, 0.06476258347919084, 0.029239585814539337, 0.042965310075783636, 0.04542320775358821, 0.0441141852583572, 0.06965758614375295, 0.030091996437255353, 0.060812197477901675, 0.043861112656721324, 0.03658167444911453, 0.12290564791314029, 0.10841088746015537, 0.16473819108195398, 0.10890106835378466, 0.11339457432568345, 0.1514132039449141, 0.10720748887214016, 0.12621215785382867, 0.1448901665534731, 0.031716544032152294, 0.020677155076420206, 0.02119501909665833, 0.024450114807489487, 0.03002245717026253, 0.01871460581163442, 0.02266762952726753, 0.021663722546297892, 0.04922782260020142, 0.013824290648283721, 0.0043195431876627, 0.0034332632302376265, 0.004993946031265684, 0.005062195361792532, 0.01297365038672893, 0.009827954775411096, 0.011121167175086488, 0.004595456615733906, 0.1904302292558525, 0.16866462861671827, 0.16856250879191415, 0.17280471280405185, 0.17359055442362747, 0.1673524122881721, 0.18864612006625847, 0.1714428134305901, 0.17405462013463602, 0.058763680225233705, 0.04286046697821255, 0.05514405398196687, 0.04763627332341425, 0.03429781522921571, 0.03464759086322067, 0.04153649622160793, 0.03018926604179928, 0.04404528975828492, 0.15955040034105328, 0.13289824674086248, 0.16202730939625087, 0.12993656417247368, 0.12954678450304546, 0.12031214410443447, 0.1357696948091871, 0.13516665634012737, 0.13157107640238774, 0.1375743848420441, 0.14249668484233402, 0.1613932299901244, 0.1692014763592824, 0.15684804528191998, 0.14129810551181543, 0.15013321579334793, 0.17377774300845283, 0.17752612777328447, 0.10045060415884677, 0.09733624860230117, 0.09279832588533632, 0.10255055811330693, 0.09607309500157735, 0.13604663650626736, 0.10577253636874173, 0.10607169036256314, 0.10293008727330089, 0.14415143342062564, 0.1332654230515411, 0.15617077573226912, 0.1606368559504623, 0.1376757996866783, 0.1440126636328496, 0.13550623933870487, 0.13196812223927568, 0.14149019520237327, 0.17596601796355005, 0.16982746649685831, 0.16496284837965502, 0.186367537807548, 0.16430786993558244, 0.1653457181491509, 0.16649888028482418, 0.16354347517240386, 0.17411455468907822, 0.15497406482978326, 0.14985711301377214, 0.13173446551933377, 0.1561973945679812, 0.12128628978671419, 0.11642613662784929, 0.24232265579054946, 0.15688404488978847, 0.11636174674523281, 0.14657275594725538, 0.12155840065350298, 0.1371404170603493, 0.12135609015012283, 0.13395471064511477, 0.09763794912939028, 0.13516486484906254, 0.13915942265309678, 0.12479731799872429, 0.19731881933969975, 0.19013314837067097, 0.18443174676694485, 0.19031487988444185, 0.18161599099850256, 0.17985400397873186, 0.1830300912544306, 0.19729744211786315, 0.1879882101548681, 0.04525785196699195, 0.03336307089262447, 0.05346343138998089, 0.039448333491558296, 0.035568970899336305, 0.038455284771352516, 0.037183256687706834, 0.04247072397480223, 0.03865087685924096]}, "mutation_prompt": null}
{"id": "badd169f-a77a-4da5-b7be-42750100a815", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Common heuristic for DE\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.99\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _mutate(self, idx, population):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(population[a] + self.mutation_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one element is from mutant\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                # Simulated Annealing acceptance criteria\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate  # Cool down the temperature\n\n        return best_solution", "name": "HybridDESA", "description": "A novel hybrid algorithm combining Differential Evolution and Simulated Annealing for enhanced exploration and exploitation in continuous black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3ae4b628-0508-4d7d-8286-78d4024c8d52", "metadata": {"aucs": [0.13425849757455965, 0.1381598539968769, 0.14490037312405224, 0.14908097925844266, 0.16364372344596612, 0.17080283455073153, 0.1373353801734013, 0.15181647266508047, 0.1434322924842838, 0.07355034912425451, 0.07828952414056622, 0.07814825637616818, 0.062155285455592124, 0.05100297935107756, 0.07652938978365542, 0.06856628881659066, 0.06623369611759067, 0.08672966709849661, 0.032271764582796125, 0.0386598559146103, 0.031354200422472944, 0.04087557190109259, 0.054438202545271985, 0.033265441671409324, 0.04548725569905476, 0.04340228294769677, 0.03749759183390999, 0.04797864868824109, 0.02275367111267279, 0.03153512105262524, 0.02386845305312213, 0.03392308226101559, 0.026669641872461236, 0.03653950507523096, 0.026547947185252108, 0.028262194327489443, 0.9290096287472159, 0.763818476304579, 0.85613145666422, 0.8375495146352231, 0.8007890584951443, 0.9506984094317505, 0.9390041283467817, 0.9844795152429242, 0.8839481847767507, 0.09039279942624268, 0.07937036833165656, 0.06803044667275537, 0.065317740929982, 0.05868480096531714, 0.08356932014055041, 0.11127848928635509, 0.08930161313246976, 0.10825146120048468, 0.14151756179723485, 0.09063849542036573, 0.10671949753025112, 0.12569517698936483, 0.12177764126630541, 0.13975140894117521, 0.1283241093942401, 0.11531962058382483, 0.11429381846640341, 0.06079465189529054, 0.09807415405931263, 0.06520284415534428, 0.06045379389826844, 0.06972112558917087, 0.07561358273359597, 0.07401951689414676, 0.06185976430082796, 0.07272410605842583, 0.07684223733211526, 0.07617751489934887, 0.10248290094244528, 0.07048008287968821, 0.09849024886412483, 0.09952749061707766, 0.07193018522521055, 0.06240432837988341, 0.06476258347919084, 0.029239585814539337, 0.042965310075783636, 0.04542320775358821, 0.0441141852583572, 0.06965758614375295, 0.030091996437255353, 0.060812197477901675, 0.043861112656721324, 0.03658167444911453, 0.12290564791314029, 0.10841088746015537, 0.16473819108195398, 0.10890106835378466, 0.11339457432568345, 0.1514132039449141, 0.10720748887214016, 0.12621215785382867, 0.1448901665534731, 0.031716544032152294, 0.020677155076420206, 0.02119501909665833, 0.024450114807489487, 0.03002245717026253, 0.01871460581163442, 0.02266762952726753, 0.021663722546297892, 0.04922782260020142, 0.013824290648283721, 0.0043195431876627, 0.0034332632302376265, 0.004993946031265684, 0.005062195361792532, 0.01297365038672893, 0.009827954775411096, 0.011121167175086488, 0.004595456615733906, 0.1904302292558525, 0.16866462861671827, 0.16856250879191415, 0.17280471280405185, 0.17359055442362747, 0.1673524122881721, 0.18864612006625847, 0.1714428134305901, 0.17405462013463602, 0.058763680225233705, 0.04286046697821255, 0.05514405398196687, 0.04763627332341425, 0.03429781522921571, 0.03464759086322067, 0.04153649622160793, 0.03018926604179928, 0.04404528975828492, 0.15955040034105328, 0.13289824674086248, 0.16202730939625087, 0.12993656417247368, 0.12954678450304546, 0.12031214410443447, 0.1357696948091871, 0.13516665634012737, 0.13157107640238774, 0.1375743848420441, 0.14249668484233402, 0.1613932299901244, 0.1692014763592824, 0.15684804528191998, 0.14129810551181543, 0.15013321579334793, 0.17377774300845283, 0.17752612777328447, 0.10045060415884677, 0.09733624860230117, 0.09279832588533632, 0.10255055811330693, 0.09607309500157735, 0.13604663650626736, 0.10577253636874173, 0.10607169036256314, 0.10293008727330089, 0.14415143342062564, 0.1332654230515411, 0.15617077573226912, 0.1606368559504623, 0.1376757996866783, 0.1440126636328496, 0.13550623933870487, 0.13196812223927568, 0.14149019520237327, 0.17596601796355005, 0.16982746649685831, 0.16496284837965502, 0.186367537807548, 0.16430786993558244, 0.1653457181491509, 0.16649888028482418, 0.16354347517240386, 0.17411455468907822, 0.15497406482978326, 0.14985711301377214, 0.13173446551933377, 0.1561973945679812, 0.12128628978671419, 0.11642613662784929, 0.24232265579054946, 0.15688404488978847, 0.11636174674523281, 0.14657275594725538, 0.12155840065350298, 0.1371404170603493, 0.12135609015012283, 0.13395471064511477, 0.09763794912939028, 0.13516486484906254, 0.13915942265309678, 0.12479731799872429, 0.19731881933969975, 0.19013314837067097, 0.18443174676694485, 0.19031487988444185, 0.18161599099850256, 0.17985400397873186, 0.1830300912544306, 0.19729744211786315, 0.1879882101548681, 0.04525785196699195, 0.03336307089262447, 0.05346343138998089, 0.039448333491558296, 0.035568970899336305, 0.038455284771352516, 0.037183256687706834, 0.04247072397480223, 0.03865087685924096]}, "mutation_prompt": null}
{"id": "35b9b235-e241-43c7-a456-90ce2e3c37a5", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Common heuristic for DE\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.99\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _mutate(self, idx, population):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(population[a] + self.mutation_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one element is from mutant\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                # Simulated Annealing acceptance criteria\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate  # Cool down the temperature\n\n        return best_solution", "name": "HybridDESA", "description": "A novel hybrid algorithm combining Differential Evolution and Simulated Annealing for enhanced exploration and exploitation in continuous black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3ae4b628-0508-4d7d-8286-78d4024c8d52", "metadata": {"aucs": [0.13425849757455965, 0.1381598539968769, 0.14490037312405224, 0.14908097925844266, 0.16364372344596612, 0.17080283455073153, 0.1373353801734013, 0.15181647266508047, 0.1434322924842838, 0.07355034912425451, 0.07828952414056622, 0.07814825637616818, 0.062155285455592124, 0.05100297935107756, 0.07652938978365542, 0.06856628881659066, 0.06623369611759067, 0.08672966709849661, 0.032271764582796125, 0.0386598559146103, 0.031354200422472944, 0.04087557190109259, 0.054438202545271985, 0.033265441671409324, 0.04548725569905476, 0.04340228294769677, 0.03749759183390999, 0.04797864868824109, 0.02275367111267279, 0.03153512105262524, 0.02386845305312213, 0.03392308226101559, 0.026669641872461236, 0.03653950507523096, 0.026547947185252108, 0.028262194327489443, 0.9290096287472159, 0.763818476304579, 0.85613145666422, 0.8375495146352231, 0.8007890584951443, 0.9506984094317505, 0.9390041283467817, 0.9844795152429242, 0.8839481847767507, 0.09039279942624268, 0.07937036833165656, 0.06803044667275537, 0.065317740929982, 0.05868480096531714, 0.08356932014055041, 0.11127848928635509, 0.08930161313246976, 0.10825146120048468, 0.14151756179723485, 0.09063849542036573, 0.10671949753025112, 0.12569517698936483, 0.12177764126630541, 0.13975140894117521, 0.1283241093942401, 0.11531962058382483, 0.11429381846640341, 0.06079465189529054, 0.09807415405931263, 0.06520284415534428, 0.06045379389826844, 0.06972112558917087, 0.07561358273359597, 0.07401951689414676, 0.06185976430082796, 0.07272410605842583, 0.07684223733211526, 0.07617751489934887, 0.10248290094244528, 0.07048008287968821, 0.09849024886412483, 0.09952749061707766, 0.07193018522521055, 0.06240432837988341, 0.06476258347919084, 0.029239585814539337, 0.042965310075783636, 0.04542320775358821, 0.0441141852583572, 0.06965758614375295, 0.030091996437255353, 0.060812197477901675, 0.043861112656721324, 0.03658167444911453, 0.12290564791314029, 0.10841088746015537, 0.16473819108195398, 0.10890106835378466, 0.11339457432568345, 0.1514132039449141, 0.10720748887214016, 0.12621215785382867, 0.1448901665534731, 0.031716544032152294, 0.020677155076420206, 0.02119501909665833, 0.024450114807489487, 0.03002245717026253, 0.01871460581163442, 0.02266762952726753, 0.021663722546297892, 0.04922782260020142, 0.013824290648283721, 0.0043195431876627, 0.0034332632302376265, 0.004993946031265684, 0.005062195361792532, 0.01297365038672893, 0.009827954775411096, 0.011121167175086488, 0.004595456615733906, 0.1904302292558525, 0.16866462861671827, 0.16856250879191415, 0.17280471280405185, 0.17359055442362747, 0.1673524122881721, 0.18864612006625847, 0.1714428134305901, 0.17405462013463602, 0.058763680225233705, 0.04286046697821255, 0.05514405398196687, 0.04763627332341425, 0.03429781522921571, 0.03464759086322067, 0.04153649622160793, 0.03018926604179928, 0.04404528975828492, 0.15955040034105328, 0.13289824674086248, 0.16202730939625087, 0.12993656417247368, 0.12954678450304546, 0.12031214410443447, 0.1357696948091871, 0.13516665634012737, 0.13157107640238774, 0.1375743848420441, 0.14249668484233402, 0.1613932299901244, 0.1692014763592824, 0.15684804528191998, 0.14129810551181543, 0.15013321579334793, 0.17377774300845283, 0.17752612777328447, 0.10045060415884677, 0.09733624860230117, 0.09279832588533632, 0.10255055811330693, 0.09607309500157735, 0.13604663650626736, 0.10577253636874173, 0.10607169036256314, 0.10293008727330089, 0.14415143342062564, 0.1332654230515411, 0.15617077573226912, 0.1606368559504623, 0.1376757996866783, 0.1440126636328496, 0.13550623933870487, 0.13196812223927568, 0.14149019520237327, 0.17596601796355005, 0.16982746649685831, 0.16496284837965502, 0.186367537807548, 0.16430786993558244, 0.1653457181491509, 0.16649888028482418, 0.16354347517240386, 0.17411455468907822, 0.15497406482978326, 0.14985711301377214, 0.13173446551933377, 0.1561973945679812, 0.12128628978671419, 0.11642613662784929, 0.24232265579054946, 0.15688404488978847, 0.11636174674523281, 0.14657275594725538, 0.12155840065350298, 0.1371404170603493, 0.12135609015012283, 0.13395471064511477, 0.09763794912939028, 0.13516486484906254, 0.13915942265309678, 0.12479731799872429, 0.19731881933969975, 0.19013314837067097, 0.18443174676694485, 0.19031487988444185, 0.18161599099850256, 0.17985400397873186, 0.1830300912544306, 0.19729744211786315, 0.1879882101548681, 0.04525785196699195, 0.03336307089262447, 0.05346343138998089, 0.039448333491558296, 0.035568970899336305, 0.038455284771352516, 0.037183256687706834, 0.04247072397480223, 0.03865087685924096]}, "mutation_prompt": null}
{"id": "30df15b4-1d1f-4b05-9b30-3ca42f0389ca", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Common heuristic for DE\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.99\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _mutate(self, idx, population):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(population[a] + self.mutation_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one element is from mutant\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                # Simulated Annealing acceptance criteria\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate  # Cool down the temperature\n\n        return best_solution", "name": "HybridDESA", "description": "A novel hybrid algorithm combining Differential Evolution and Simulated Annealing for enhanced exploration and exploitation in continuous black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3ae4b628-0508-4d7d-8286-78d4024c8d52", "metadata": {"aucs": [0.13425849757455965, 0.1381598539968769, 0.14490037312405224, 0.14908097925844266, 0.16364372344596612, 0.17080283455073153, 0.1373353801734013, 0.15181647266508047, 0.1434322924842838, 0.07355034912425451, 0.07828952414056622, 0.07814825637616818, 0.062155285455592124, 0.05100297935107756, 0.07652938978365542, 0.06856628881659066, 0.06623369611759067, 0.08672966709849661, 0.032271764582796125, 0.0386598559146103, 0.031354200422472944, 0.04087557190109259, 0.054438202545271985, 0.033265441671409324, 0.04548725569905476, 0.04340228294769677, 0.03749759183390999, 0.04797864868824109, 0.02275367111267279, 0.03153512105262524, 0.02386845305312213, 0.03392308226101559, 0.026669641872461236, 0.03653950507523096, 0.026547947185252108, 0.028262194327489443, 0.9290096287472159, 0.763818476304579, 0.85613145666422, 0.8375495146352231, 0.8007890584951443, 0.9506984094317505, 0.9390041283467817, 0.9844795152429242, 0.8839481847767507, 0.09039279942624268, 0.07937036833165656, 0.06803044667275537, 0.065317740929982, 0.05868480096531714, 0.08356932014055041, 0.11127848928635509, 0.08930161313246976, 0.10825146120048468, 0.14151756179723485, 0.09063849542036573, 0.10671949753025112, 0.12569517698936483, 0.12177764126630541, 0.13975140894117521, 0.1283241093942401, 0.11531962058382483, 0.11429381846640341, 0.06079465189529054, 0.09807415405931263, 0.06520284415534428, 0.06045379389826844, 0.06972112558917087, 0.07561358273359597, 0.07401951689414676, 0.06185976430082796, 0.07272410605842583, 0.07684223733211526, 0.07617751489934887, 0.10248290094244528, 0.07048008287968821, 0.09849024886412483, 0.09952749061707766, 0.07193018522521055, 0.06240432837988341, 0.06476258347919084, 0.029239585814539337, 0.042965310075783636, 0.04542320775358821, 0.0441141852583572, 0.06965758614375295, 0.030091996437255353, 0.060812197477901675, 0.043861112656721324, 0.03658167444911453, 0.12290564791314029, 0.10841088746015537, 0.16473819108195398, 0.10890106835378466, 0.11339457432568345, 0.1514132039449141, 0.10720748887214016, 0.12621215785382867, 0.1448901665534731, 0.031716544032152294, 0.020677155076420206, 0.02119501909665833, 0.024450114807489487, 0.03002245717026253, 0.01871460581163442, 0.02266762952726753, 0.021663722546297892, 0.04922782260020142, 0.013824290648283721, 0.0043195431876627, 0.0034332632302376265, 0.004993946031265684, 0.005062195361792532, 0.01297365038672893, 0.009827954775411096, 0.011121167175086488, 0.004595456615733906, 0.1904302292558525, 0.16866462861671827, 0.16856250879191415, 0.17280471280405185, 0.17359055442362747, 0.1673524122881721, 0.18864612006625847, 0.1714428134305901, 0.17405462013463602, 0.058763680225233705, 0.04286046697821255, 0.05514405398196687, 0.04763627332341425, 0.03429781522921571, 0.03464759086322067, 0.04153649622160793, 0.03018926604179928, 0.04404528975828492, 0.15955040034105328, 0.13289824674086248, 0.16202730939625087, 0.12993656417247368, 0.12954678450304546, 0.12031214410443447, 0.1357696948091871, 0.13516665634012737, 0.13157107640238774, 0.1375743848420441, 0.14249668484233402, 0.1613932299901244, 0.1692014763592824, 0.15684804528191998, 0.14129810551181543, 0.15013321579334793, 0.17377774300845283, 0.17752612777328447, 0.10045060415884677, 0.09733624860230117, 0.09279832588533632, 0.10255055811330693, 0.09607309500157735, 0.13604663650626736, 0.10577253636874173, 0.10607169036256314, 0.10293008727330089, 0.14415143342062564, 0.1332654230515411, 0.15617077573226912, 0.1606368559504623, 0.1376757996866783, 0.1440126636328496, 0.13550623933870487, 0.13196812223927568, 0.14149019520237327, 0.17596601796355005, 0.16982746649685831, 0.16496284837965502, 0.186367537807548, 0.16430786993558244, 0.1653457181491509, 0.16649888028482418, 0.16354347517240386, 0.17411455468907822, 0.15497406482978326, 0.14985711301377214, 0.13173446551933377, 0.1561973945679812, 0.12128628978671419, 0.11642613662784929, 0.24232265579054946, 0.15688404488978847, 0.11636174674523281, 0.14657275594725538, 0.12155840065350298, 0.1371404170603493, 0.12135609015012283, 0.13395471064511477, 0.09763794912939028, 0.13516486484906254, 0.13915942265309678, 0.12479731799872429, 0.19731881933969975, 0.19013314837067097, 0.18443174676694485, 0.19031487988444185, 0.18161599099850256, 0.17985400397873186, 0.1830300912544306, 0.19729744211786315, 0.1879882101548681, 0.04525785196699195, 0.03336307089262447, 0.05346343138998089, 0.039448333491558296, 0.035568970899336305, 0.038455284771352516, 0.037183256687706834, 0.04247072397480223, 0.03865087685924096]}, "mutation_prompt": null}
{"id": "8b221a05-03ab-44c8-921c-aa7ecd284478", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Common heuristic for DE\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.99\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _mutate(self, idx, population):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(population[a] + self.mutation_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one element is from mutant\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                # Simulated Annealing acceptance criteria\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate  # Cool down the temperature\n\n        return best_solution", "name": "HybridDESA", "description": "A novel hybrid algorithm combining Differential Evolution and Simulated Annealing for enhanced exploration and exploitation in continuous black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3ae4b628-0508-4d7d-8286-78d4024c8d52", "metadata": {"aucs": [0.13425849757455965, 0.1381598539968769, 0.14490037312405224, 0.14908097925844266, 0.16364372344596612, 0.17080283455073153, 0.1373353801734013, 0.15181647266508047, 0.1434322924842838, 0.07355034912425451, 0.07828952414056622, 0.07814825637616818, 0.062155285455592124, 0.05100297935107756, 0.07652938978365542, 0.06856628881659066, 0.06623369611759067, 0.08672966709849661, 0.032271764582796125, 0.0386598559146103, 0.031354200422472944, 0.04087557190109259, 0.054438202545271985, 0.033265441671409324, 0.04548725569905476, 0.04340228294769677, 0.03749759183390999, 0.04797864868824109, 0.02275367111267279, 0.03153512105262524, 0.02386845305312213, 0.03392308226101559, 0.026669641872461236, 0.03653950507523096, 0.026547947185252108, 0.028262194327489443, 0.9290096287472159, 0.763818476304579, 0.85613145666422, 0.8375495146352231, 0.8007890584951443, 0.9506984094317505, 0.9390041283467817, 0.9844795152429242, 0.8839481847767507, 0.09039279942624268, 0.07937036833165656, 0.06803044667275537, 0.065317740929982, 0.05868480096531714, 0.08356932014055041, 0.11127848928635509, 0.08930161313246976, 0.10825146120048468, 0.14151756179723485, 0.09063849542036573, 0.10671949753025112, 0.12569517698936483, 0.12177764126630541, 0.13975140894117521, 0.1283241093942401, 0.11531962058382483, 0.11429381846640341, 0.06079465189529054, 0.09807415405931263, 0.06520284415534428, 0.06045379389826844, 0.06972112558917087, 0.07561358273359597, 0.07401951689414676, 0.06185976430082796, 0.07272410605842583, 0.07684223733211526, 0.07617751489934887, 0.10248290094244528, 0.07048008287968821, 0.09849024886412483, 0.09952749061707766, 0.07193018522521055, 0.06240432837988341, 0.06476258347919084, 0.029239585814539337, 0.042965310075783636, 0.04542320775358821, 0.0441141852583572, 0.06965758614375295, 0.030091996437255353, 0.060812197477901675, 0.043861112656721324, 0.03658167444911453, 0.12290564791314029, 0.10841088746015537, 0.16473819108195398, 0.10890106835378466, 0.11339457432568345, 0.1514132039449141, 0.10720748887214016, 0.12621215785382867, 0.1448901665534731, 0.031716544032152294, 0.020677155076420206, 0.02119501909665833, 0.024450114807489487, 0.03002245717026253, 0.01871460581163442, 0.02266762952726753, 0.021663722546297892, 0.04922782260020142, 0.013824290648283721, 0.0043195431876627, 0.0034332632302376265, 0.004993946031265684, 0.005062195361792532, 0.01297365038672893, 0.009827954775411096, 0.011121167175086488, 0.004595456615733906, 0.1904302292558525, 0.16866462861671827, 0.16856250879191415, 0.17280471280405185, 0.17359055442362747, 0.1673524122881721, 0.18864612006625847, 0.1714428134305901, 0.17405462013463602, 0.058763680225233705, 0.04286046697821255, 0.05514405398196687, 0.04763627332341425, 0.03429781522921571, 0.03464759086322067, 0.04153649622160793, 0.03018926604179928, 0.04404528975828492, 0.15955040034105328, 0.13289824674086248, 0.16202730939625087, 0.12993656417247368, 0.12954678450304546, 0.12031214410443447, 0.1357696948091871, 0.13516665634012737, 0.13157107640238774, 0.1375743848420441, 0.14249668484233402, 0.1613932299901244, 0.1692014763592824, 0.15684804528191998, 0.14129810551181543, 0.15013321579334793, 0.17377774300845283, 0.17752612777328447, 0.10045060415884677, 0.09733624860230117, 0.09279832588533632, 0.10255055811330693, 0.09607309500157735, 0.13604663650626736, 0.10577253636874173, 0.10607169036256314, 0.10293008727330089, 0.14415143342062564, 0.1332654230515411, 0.15617077573226912, 0.1606368559504623, 0.1376757996866783, 0.1440126636328496, 0.13550623933870487, 0.13196812223927568, 0.14149019520237327, 0.17596601796355005, 0.16982746649685831, 0.16496284837965502, 0.186367537807548, 0.16430786993558244, 0.1653457181491509, 0.16649888028482418, 0.16354347517240386, 0.17411455468907822, 0.15497406482978326, 0.14985711301377214, 0.13173446551933377, 0.1561973945679812, 0.12128628978671419, 0.11642613662784929, 0.24232265579054946, 0.15688404488978847, 0.11636174674523281, 0.14657275594725538, 0.12155840065350298, 0.1371404170603493, 0.12135609015012283, 0.13395471064511477, 0.09763794912939028, 0.13516486484906254, 0.13915942265309678, 0.12479731799872429, 0.19731881933969975, 0.19013314837067097, 0.18443174676694485, 0.19031487988444185, 0.18161599099850256, 0.17985400397873186, 0.1830300912544306, 0.19729744211786315, 0.1879882101548681, 0.04525785196699195, 0.03336307089262447, 0.05346343138998089, 0.039448333491558296, 0.035568970899336305, 0.038455284771352516, 0.037183256687706834, 0.04247072397480223, 0.03865087685924096]}, "mutation_prompt": null}
{"id": "1fef3395-0a1a-4b9f-bb70-43bf968e62dd", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Common heuristic for DE\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.99\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _mutate(self, idx, population):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(population[a] + self.mutation_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one element is from mutant\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                # Simulated Annealing acceptance criteria\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate  # Cool down the temperature\n\n        return best_solution", "name": "HybridDESA", "description": "A novel hybrid algorithm combining Differential Evolution and Simulated Annealing for enhanced exploration and exploitation in continuous black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3ae4b628-0508-4d7d-8286-78d4024c8d52", "metadata": {"aucs": [0.13425849757455965, 0.1381598539968769, 0.14490037312405224, 0.14908097925844266, 0.16364372344596612, 0.17080283455073153, 0.1373353801734013, 0.15181647266508047, 0.1434322924842838, 0.07355034912425451, 0.07828952414056622, 0.07814825637616818, 0.062155285455592124, 0.05100297935107756, 0.07652938978365542, 0.06856628881659066, 0.06623369611759067, 0.08672966709849661, 0.032271764582796125, 0.0386598559146103, 0.031354200422472944, 0.04087557190109259, 0.054438202545271985, 0.033265441671409324, 0.04548725569905476, 0.04340228294769677, 0.03749759183390999, 0.04797864868824109, 0.02275367111267279, 0.03153512105262524, 0.02386845305312213, 0.03392308226101559, 0.026669641872461236, 0.03653950507523096, 0.026547947185252108, 0.028262194327489443, 0.9290096287472159, 0.763818476304579, 0.85613145666422, 0.8375495146352231, 0.8007890584951443, 0.9506984094317505, 0.9390041283467817, 0.9844795152429242, 0.8839481847767507, 0.09039279942624268, 0.07937036833165656, 0.06803044667275537, 0.065317740929982, 0.05868480096531714, 0.08356932014055041, 0.11127848928635509, 0.08930161313246976, 0.10825146120048468, 0.14151756179723485, 0.09063849542036573, 0.10671949753025112, 0.12569517698936483, 0.12177764126630541, 0.13975140894117521, 0.1283241093942401, 0.11531962058382483, 0.11429381846640341, 0.06079465189529054, 0.09807415405931263, 0.06520284415534428, 0.06045379389826844, 0.06972112558917087, 0.07561358273359597, 0.07401951689414676, 0.06185976430082796, 0.07272410605842583, 0.07684223733211526, 0.07617751489934887, 0.10248290094244528, 0.07048008287968821, 0.09849024886412483, 0.09952749061707766, 0.07193018522521055, 0.06240432837988341, 0.06476258347919084, 0.029239585814539337, 0.042965310075783636, 0.04542320775358821, 0.0441141852583572, 0.06965758614375295, 0.030091996437255353, 0.060812197477901675, 0.043861112656721324, 0.03658167444911453, 0.12290564791314029, 0.10841088746015537, 0.16473819108195398, 0.10890106835378466, 0.11339457432568345, 0.1514132039449141, 0.10720748887214016, 0.12621215785382867, 0.1448901665534731, 0.031716544032152294, 0.020677155076420206, 0.02119501909665833, 0.024450114807489487, 0.03002245717026253, 0.01871460581163442, 0.02266762952726753, 0.021663722546297892, 0.04922782260020142, 0.013824290648283721, 0.0043195431876627, 0.0034332632302376265, 0.004993946031265684, 0.005062195361792532, 0.01297365038672893, 0.009827954775411096, 0.011121167175086488, 0.004595456615733906, 0.1904302292558525, 0.16866462861671827, 0.16856250879191415, 0.17280471280405185, 0.17359055442362747, 0.1673524122881721, 0.18864612006625847, 0.1714428134305901, 0.17405462013463602, 0.058763680225233705, 0.04286046697821255, 0.05514405398196687, 0.04763627332341425, 0.03429781522921571, 0.03464759086322067, 0.04153649622160793, 0.03018926604179928, 0.04404528975828492, 0.15955040034105328, 0.13289824674086248, 0.16202730939625087, 0.12993656417247368, 0.12954678450304546, 0.12031214410443447, 0.1357696948091871, 0.13516665634012737, 0.13157107640238774, 0.1375743848420441, 0.14249668484233402, 0.1613932299901244, 0.1692014763592824, 0.15684804528191998, 0.14129810551181543, 0.15013321579334793, 0.17377774300845283, 0.17752612777328447, 0.10045060415884677, 0.09733624860230117, 0.09279832588533632, 0.10255055811330693, 0.09607309500157735, 0.13604663650626736, 0.10577253636874173, 0.10607169036256314, 0.10293008727330089, 0.14415143342062564, 0.1332654230515411, 0.15617077573226912, 0.1606368559504623, 0.1376757996866783, 0.1440126636328496, 0.13550623933870487, 0.13196812223927568, 0.14149019520237327, 0.17596601796355005, 0.16982746649685831, 0.16496284837965502, 0.186367537807548, 0.16430786993558244, 0.1653457181491509, 0.16649888028482418, 0.16354347517240386, 0.17411455468907822, 0.15497406482978326, 0.14985711301377214, 0.13173446551933377, 0.1561973945679812, 0.12128628978671419, 0.11642613662784929, 0.24232265579054946, 0.15688404488978847, 0.11636174674523281, 0.14657275594725538, 0.12155840065350298, 0.1371404170603493, 0.12135609015012283, 0.13395471064511477, 0.09763794912939028, 0.13516486484906254, 0.13915942265309678, 0.12479731799872429, 0.19731881933969975, 0.19013314837067097, 0.18443174676694485, 0.19031487988444185, 0.18161599099850256, 0.17985400397873186, 0.1830300912544306, 0.19729744211786315, 0.1879882101548681, 0.04525785196699195, 0.03336307089262447, 0.05346343138998089, 0.039448333491558296, 0.035568970899336305, 0.038455284771352516, 0.037183256687706834, 0.04247072397480223, 0.03865087685924096]}, "mutation_prompt": null}
{"id": "561b043e-828d-462e-8d38-155c8faffe8b", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Common heuristic for DE\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.99\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _mutate(self, idx, population):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(population[a] + self.mutation_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one element is from mutant\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                # Simulated Annealing acceptance criteria\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate  # Cool down the temperature\n\n        return best_solution", "name": "HybridDESA", "description": "A novel hybrid algorithm combining Differential Evolution and Simulated Annealing for enhanced exploration and exploitation in continuous black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3ae4b628-0508-4d7d-8286-78d4024c8d52", "metadata": {"aucs": [0.13425849757455965, 0.1381598539968769, 0.14490037312405224, 0.14908097925844266, 0.16364372344596612, 0.17080283455073153, 0.1373353801734013, 0.15181647266508047, 0.1434322924842838, 0.07355034912425451, 0.07828952414056622, 0.07814825637616818, 0.062155285455592124, 0.05100297935107756, 0.07652938978365542, 0.06856628881659066, 0.06623369611759067, 0.08672966709849661, 0.032271764582796125, 0.0386598559146103, 0.031354200422472944, 0.04087557190109259, 0.054438202545271985, 0.033265441671409324, 0.04548725569905476, 0.04340228294769677, 0.03749759183390999, 0.04797864868824109, 0.02275367111267279, 0.03153512105262524, 0.02386845305312213, 0.03392308226101559, 0.026669641872461236, 0.03653950507523096, 0.026547947185252108, 0.028262194327489443, 0.9290096287472159, 0.763818476304579, 0.85613145666422, 0.8375495146352231, 0.8007890584951443, 0.9506984094317505, 0.9390041283467817, 0.9844795152429242, 0.8839481847767507, 0.09039279942624268, 0.07937036833165656, 0.06803044667275537, 0.065317740929982, 0.05868480096531714, 0.08356932014055041, 0.11127848928635509, 0.08930161313246976, 0.10825146120048468, 0.14151756179723485, 0.09063849542036573, 0.10671949753025112, 0.12569517698936483, 0.12177764126630541, 0.13975140894117521, 0.1283241093942401, 0.11531962058382483, 0.11429381846640341, 0.06079465189529054, 0.09807415405931263, 0.06520284415534428, 0.06045379389826844, 0.06972112558917087, 0.07561358273359597, 0.07401951689414676, 0.06185976430082796, 0.07272410605842583, 0.07684223733211526, 0.07617751489934887, 0.10248290094244528, 0.07048008287968821, 0.09849024886412483, 0.09952749061707766, 0.07193018522521055, 0.06240432837988341, 0.06476258347919084, 0.029239585814539337, 0.042965310075783636, 0.04542320775358821, 0.0441141852583572, 0.06965758614375295, 0.030091996437255353, 0.060812197477901675, 0.043861112656721324, 0.03658167444911453, 0.12290564791314029, 0.10841088746015537, 0.16473819108195398, 0.10890106835378466, 0.11339457432568345, 0.1514132039449141, 0.10720748887214016, 0.12621215785382867, 0.1448901665534731, 0.031716544032152294, 0.020677155076420206, 0.02119501909665833, 0.024450114807489487, 0.03002245717026253, 0.01871460581163442, 0.02266762952726753, 0.021663722546297892, 0.04922782260020142, 0.013824290648283721, 0.0043195431876627, 0.0034332632302376265, 0.004993946031265684, 0.005062195361792532, 0.01297365038672893, 0.009827954775411096, 0.011121167175086488, 0.004595456615733906, 0.1904302292558525, 0.16866462861671827, 0.16856250879191415, 0.17280471280405185, 0.17359055442362747, 0.1673524122881721, 0.18864612006625847, 0.1714428134305901, 0.17405462013463602, 0.058763680225233705, 0.04286046697821255, 0.05514405398196687, 0.04763627332341425, 0.03429781522921571, 0.03464759086322067, 0.04153649622160793, 0.03018926604179928, 0.04404528975828492, 0.15955040034105328, 0.13289824674086248, 0.16202730939625087, 0.12993656417247368, 0.12954678450304546, 0.12031214410443447, 0.1357696948091871, 0.13516665634012737, 0.13157107640238774, 0.1375743848420441, 0.14249668484233402, 0.1613932299901244, 0.1692014763592824, 0.15684804528191998, 0.14129810551181543, 0.15013321579334793, 0.17377774300845283, 0.17752612777328447, 0.10045060415884677, 0.09733624860230117, 0.09279832588533632, 0.10255055811330693, 0.09607309500157735, 0.13604663650626736, 0.10577253636874173, 0.10607169036256314, 0.10293008727330089, 0.14415143342062564, 0.1332654230515411, 0.15617077573226912, 0.1606368559504623, 0.1376757996866783, 0.1440126636328496, 0.13550623933870487, 0.13196812223927568, 0.14149019520237327, 0.17596601796355005, 0.16982746649685831, 0.16496284837965502, 0.186367537807548, 0.16430786993558244, 0.1653457181491509, 0.16649888028482418, 0.16354347517240386, 0.17411455468907822, 0.15497406482978326, 0.14985711301377214, 0.13173446551933377, 0.1561973945679812, 0.12128628978671419, 0.11642613662784929, 0.24232265579054946, 0.15688404488978847, 0.11636174674523281, 0.14657275594725538, 0.12155840065350298, 0.1371404170603493, 0.12135609015012283, 0.13395471064511477, 0.09763794912939028, 0.13516486484906254, 0.13915942265309678, 0.12479731799872429, 0.19731881933969975, 0.19013314837067097, 0.18443174676694485, 0.19031487988444185, 0.18161599099850256, 0.17985400397873186, 0.1830300912544306, 0.19729744211786315, 0.1879882101548681, 0.04525785196699195, 0.03336307089262447, 0.05346343138998089, 0.039448333491558296, 0.035568970899336305, 0.038455284771352516, 0.037183256687706834, 0.04247072397480223, 0.03865087685924096]}, "mutation_prompt": null}
{"id": "cc1c0b4c-9601-4da2-84d1-b008fb5932f3", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Common heuristic for DE\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.99\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _mutate(self, idx, population):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(population[a] + self.mutation_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one element is from mutant\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                # Simulated Annealing acceptance criteria\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate  # Cool down the temperature\n\n        return best_solution", "name": "HybridDESA", "description": "A novel hybrid algorithm combining Differential Evolution and Simulated Annealing for enhanced exploration and exploitation in continuous black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3ae4b628-0508-4d7d-8286-78d4024c8d52", "metadata": {"aucs": [0.13425849757455965, 0.1381598539968769, 0.14490037312405224, 0.14908097925844266, 0.16364372344596612, 0.17080283455073153, 0.1373353801734013, 0.15181647266508047, 0.1434322924842838, 0.07355034912425451, 0.07828952414056622, 0.07814825637616818, 0.062155285455592124, 0.05100297935107756, 0.07652938978365542, 0.06856628881659066, 0.06623369611759067, 0.08672966709849661, 0.032271764582796125, 0.0386598559146103, 0.031354200422472944, 0.04087557190109259, 0.054438202545271985, 0.033265441671409324, 0.04548725569905476, 0.04340228294769677, 0.03749759183390999, 0.04797864868824109, 0.02275367111267279, 0.03153512105262524, 0.02386845305312213, 0.03392308226101559, 0.026669641872461236, 0.03653950507523096, 0.026547947185252108, 0.028262194327489443, 0.9290096287472159, 0.763818476304579, 0.85613145666422, 0.8375495146352231, 0.8007890584951443, 0.9506984094317505, 0.9390041283467817, 0.9844795152429242, 0.8839481847767507, 0.09039279942624268, 0.07937036833165656, 0.06803044667275537, 0.065317740929982, 0.05868480096531714, 0.08356932014055041, 0.11127848928635509, 0.08930161313246976, 0.10825146120048468, 0.14151756179723485, 0.09063849542036573, 0.10671949753025112, 0.12569517698936483, 0.12177764126630541, 0.13975140894117521, 0.1283241093942401, 0.11531962058382483, 0.11429381846640341, 0.06079465189529054, 0.09807415405931263, 0.06520284415534428, 0.06045379389826844, 0.06972112558917087, 0.07561358273359597, 0.07401951689414676, 0.06185976430082796, 0.07272410605842583, 0.07684223733211526, 0.07617751489934887, 0.10248290094244528, 0.07048008287968821, 0.09849024886412483, 0.09952749061707766, 0.07193018522521055, 0.06240432837988341, 0.06476258347919084, 0.029239585814539337, 0.042965310075783636, 0.04542320775358821, 0.0441141852583572, 0.06965758614375295, 0.030091996437255353, 0.060812197477901675, 0.043861112656721324, 0.03658167444911453, 0.12290564791314029, 0.10841088746015537, 0.16473819108195398, 0.10890106835378466, 0.11339457432568345, 0.1514132039449141, 0.10720748887214016, 0.12621215785382867, 0.1448901665534731, 0.031716544032152294, 0.020677155076420206, 0.02119501909665833, 0.024450114807489487, 0.03002245717026253, 0.01871460581163442, 0.02266762952726753, 0.021663722546297892, 0.04922782260020142, 0.013824290648283721, 0.0043195431876627, 0.0034332632302376265, 0.004993946031265684, 0.005062195361792532, 0.01297365038672893, 0.009827954775411096, 0.011121167175086488, 0.004595456615733906, 0.1904302292558525, 0.16866462861671827, 0.16856250879191415, 0.17280471280405185, 0.17359055442362747, 0.1673524122881721, 0.18864612006625847, 0.1714428134305901, 0.17405462013463602, 0.058763680225233705, 0.04286046697821255, 0.05514405398196687, 0.04763627332341425, 0.03429781522921571, 0.03464759086322067, 0.04153649622160793, 0.03018926604179928, 0.04404528975828492, 0.15955040034105328, 0.13289824674086248, 0.16202730939625087, 0.12993656417247368, 0.12954678450304546, 0.12031214410443447, 0.1357696948091871, 0.13516665634012737, 0.13157107640238774, 0.1375743848420441, 0.14249668484233402, 0.1613932299901244, 0.1692014763592824, 0.15684804528191998, 0.14129810551181543, 0.15013321579334793, 0.17377774300845283, 0.17752612777328447, 0.10045060415884677, 0.09733624860230117, 0.09279832588533632, 0.10255055811330693, 0.09607309500157735, 0.13604663650626736, 0.10577253636874173, 0.10607169036256314, 0.10293008727330089, 0.14415143342062564, 0.1332654230515411, 0.15617077573226912, 0.1606368559504623, 0.1376757996866783, 0.1440126636328496, 0.13550623933870487, 0.13196812223927568, 0.14149019520237327, 0.17596601796355005, 0.16982746649685831, 0.16496284837965502, 0.186367537807548, 0.16430786993558244, 0.1653457181491509, 0.16649888028482418, 0.16354347517240386, 0.17411455468907822, 0.15497406482978326, 0.14985711301377214, 0.13173446551933377, 0.1561973945679812, 0.12128628978671419, 0.11642613662784929, 0.24232265579054946, 0.15688404488978847, 0.11636174674523281, 0.14657275594725538, 0.12155840065350298, 0.1371404170603493, 0.12135609015012283, 0.13395471064511477, 0.09763794912939028, 0.13516486484906254, 0.13915942265309678, 0.12479731799872429, 0.19731881933969975, 0.19013314837067097, 0.18443174676694485, 0.19031487988444185, 0.18161599099850256, 0.17985400397873186, 0.1830300912544306, 0.19729744211786315, 0.1879882101548681, 0.04525785196699195, 0.03336307089262447, 0.05346343138998089, 0.039448333491558296, 0.035568970899336305, 0.038455284771352516, 0.037183256687706834, 0.04247072397480223, 0.03865087685924096]}, "mutation_prompt": null}
{"id": "faca9184-afc3-46b2-a83f-a29b80a9a2c5", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Common heuristic for DE\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.99\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _mutate(self, idx, population):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(population[a] + self.mutation_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one element is from mutant\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                # Simulated Annealing acceptance criteria\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate  # Cool down the temperature\n\n        return best_solution", "name": "HybridDESA", "description": "A novel hybrid algorithm combining Differential Evolution and Simulated Annealing for enhanced exploration and exploitation in continuous black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3ae4b628-0508-4d7d-8286-78d4024c8d52", "metadata": {"aucs": [0.13425849757455965, 0.1381598539968769, 0.14490037312405224, 0.14908097925844266, 0.16364372344596612, 0.17080283455073153, 0.1373353801734013, 0.15181647266508047, 0.1434322924842838, 0.07355034912425451, 0.07828952414056622, 0.07814825637616818, 0.062155285455592124, 0.05100297935107756, 0.07652938978365542, 0.06856628881659066, 0.06623369611759067, 0.08672966709849661, 0.032271764582796125, 0.0386598559146103, 0.031354200422472944, 0.04087557190109259, 0.054438202545271985, 0.033265441671409324, 0.04548725569905476, 0.04340228294769677, 0.03749759183390999, 0.04797864868824109, 0.02275367111267279, 0.03153512105262524, 0.02386845305312213, 0.03392308226101559, 0.026669641872461236, 0.03653950507523096, 0.026547947185252108, 0.028262194327489443, 0.9290096287472159, 0.763818476304579, 0.85613145666422, 0.8375495146352231, 0.8007890584951443, 0.9506984094317505, 0.9390041283467817, 0.9844795152429242, 0.8839481847767507, 0.09039279942624268, 0.07937036833165656, 0.06803044667275537, 0.065317740929982, 0.05868480096531714, 0.08356932014055041, 0.11127848928635509, 0.08930161313246976, 0.10825146120048468, 0.14151756179723485, 0.09063849542036573, 0.10671949753025112, 0.12569517698936483, 0.12177764126630541, 0.13975140894117521, 0.1283241093942401, 0.11531962058382483, 0.11429381846640341, 0.06079465189529054, 0.09807415405931263, 0.06520284415534428, 0.06045379389826844, 0.06972112558917087, 0.07561358273359597, 0.07401951689414676, 0.06185976430082796, 0.07272410605842583, 0.07684223733211526, 0.07617751489934887, 0.10248290094244528, 0.07048008287968821, 0.09849024886412483, 0.09952749061707766, 0.07193018522521055, 0.06240432837988341, 0.06476258347919084, 0.029239585814539337, 0.042965310075783636, 0.04542320775358821, 0.0441141852583572, 0.06965758614375295, 0.030091996437255353, 0.060812197477901675, 0.043861112656721324, 0.03658167444911453, 0.12290564791314029, 0.10841088746015537, 0.16473819108195398, 0.10890106835378466, 0.11339457432568345, 0.1514132039449141, 0.10720748887214016, 0.12621215785382867, 0.1448901665534731, 0.031716544032152294, 0.020677155076420206, 0.02119501909665833, 0.024450114807489487, 0.03002245717026253, 0.01871460581163442, 0.02266762952726753, 0.021663722546297892, 0.04922782260020142, 0.013824290648283721, 0.0043195431876627, 0.0034332632302376265, 0.004993946031265684, 0.005062195361792532, 0.01297365038672893, 0.009827954775411096, 0.011121167175086488, 0.004595456615733906, 0.1904302292558525, 0.16866462861671827, 0.16856250879191415, 0.17280471280405185, 0.17359055442362747, 0.1673524122881721, 0.18864612006625847, 0.1714428134305901, 0.17405462013463602, 0.058763680225233705, 0.04286046697821255, 0.05514405398196687, 0.04763627332341425, 0.03429781522921571, 0.03464759086322067, 0.04153649622160793, 0.03018926604179928, 0.04404528975828492, 0.15955040034105328, 0.13289824674086248, 0.16202730939625087, 0.12993656417247368, 0.12954678450304546, 0.12031214410443447, 0.1357696948091871, 0.13516665634012737, 0.13157107640238774, 0.1375743848420441, 0.14249668484233402, 0.1613932299901244, 0.1692014763592824, 0.15684804528191998, 0.14129810551181543, 0.15013321579334793, 0.17377774300845283, 0.17752612777328447, 0.10045060415884677, 0.09733624860230117, 0.09279832588533632, 0.10255055811330693, 0.09607309500157735, 0.13604663650626736, 0.10577253636874173, 0.10607169036256314, 0.10293008727330089, 0.14415143342062564, 0.1332654230515411, 0.15617077573226912, 0.1606368559504623, 0.1376757996866783, 0.1440126636328496, 0.13550623933870487, 0.13196812223927568, 0.14149019520237327, 0.17596601796355005, 0.16982746649685831, 0.16496284837965502, 0.186367537807548, 0.16430786993558244, 0.1653457181491509, 0.16649888028482418, 0.16354347517240386, 0.17411455468907822, 0.15497406482978326, 0.14985711301377214, 0.13173446551933377, 0.1561973945679812, 0.12128628978671419, 0.11642613662784929, 0.24232265579054946, 0.15688404488978847, 0.11636174674523281, 0.14657275594725538, 0.12155840065350298, 0.1371404170603493, 0.12135609015012283, 0.13395471064511477, 0.09763794912939028, 0.13516486484906254, 0.13915942265309678, 0.12479731799872429, 0.19731881933969975, 0.19013314837067097, 0.18443174676694485, 0.19031487988444185, 0.18161599099850256, 0.17985400397873186, 0.1830300912544306, 0.19729744211786315, 0.1879882101548681, 0.04525785196699195, 0.03336307089262447, 0.05346343138998089, 0.039448333491558296, 0.035568970899336305, 0.038455284771352516, 0.037183256687706834, 0.04247072397480223, 0.03865087685924096]}, "mutation_prompt": null}
{"id": "8ca98c3a-132a-4a27-bf92-6d5db63e70a7", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Common heuristic for DE\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.99\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _mutate(self, idx, population):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(population[a] + self.mutation_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one element is from mutant\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                # Simulated Annealing acceptance criteria\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate  # Cool down the temperature\n\n        return best_solution", "name": "HybridDESA", "description": "A novel hybrid algorithm combining Differential Evolution and Simulated Annealing for enhanced exploration and exploitation in continuous black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3ae4b628-0508-4d7d-8286-78d4024c8d52", "metadata": {"aucs": [0.13425849757455965, 0.1381598539968769, 0.14490037312405224, 0.14908097925844266, 0.16364372344596612, 0.17080283455073153, 0.1373353801734013, 0.15181647266508047, 0.1434322924842838, 0.07355034912425451, 0.07828952414056622, 0.07814825637616818, 0.062155285455592124, 0.05100297935107756, 0.07652938978365542, 0.06856628881659066, 0.06623369611759067, 0.08672966709849661, 0.032271764582796125, 0.0386598559146103, 0.031354200422472944, 0.04087557190109259, 0.054438202545271985, 0.033265441671409324, 0.04548725569905476, 0.04340228294769677, 0.03749759183390999, 0.04797864868824109, 0.02275367111267279, 0.03153512105262524, 0.02386845305312213, 0.03392308226101559, 0.026669641872461236, 0.03653950507523096, 0.026547947185252108, 0.028262194327489443, 0.9290096287472159, 0.763818476304579, 0.85613145666422, 0.8375495146352231, 0.8007890584951443, 0.9506984094317505, 0.9390041283467817, 0.9844795152429242, 0.8839481847767507, 0.09039279942624268, 0.07937036833165656, 0.06803044667275537, 0.065317740929982, 0.05868480096531714, 0.08356932014055041, 0.11127848928635509, 0.08930161313246976, 0.10825146120048468, 0.14151756179723485, 0.09063849542036573, 0.10671949753025112, 0.12569517698936483, 0.12177764126630541, 0.13975140894117521, 0.1283241093942401, 0.11531962058382483, 0.11429381846640341, 0.06079465189529054, 0.09807415405931263, 0.06520284415534428, 0.06045379389826844, 0.06972112558917087, 0.07561358273359597, 0.07401951689414676, 0.06185976430082796, 0.07272410605842583, 0.07684223733211526, 0.07617751489934887, 0.10248290094244528, 0.07048008287968821, 0.09849024886412483, 0.09952749061707766, 0.07193018522521055, 0.06240432837988341, 0.06476258347919084, 0.029239585814539337, 0.042965310075783636, 0.04542320775358821, 0.0441141852583572, 0.06965758614375295, 0.030091996437255353, 0.060812197477901675, 0.043861112656721324, 0.03658167444911453, 0.12290564791314029, 0.10841088746015537, 0.16473819108195398, 0.10890106835378466, 0.11339457432568345, 0.1514132039449141, 0.10720748887214016, 0.12621215785382867, 0.1448901665534731, 0.031716544032152294, 0.020677155076420206, 0.02119501909665833, 0.024450114807489487, 0.03002245717026253, 0.01871460581163442, 0.02266762952726753, 0.021663722546297892, 0.04922782260020142, 0.013824290648283721, 0.0043195431876627, 0.0034332632302376265, 0.004993946031265684, 0.005062195361792532, 0.01297365038672893, 0.009827954775411096, 0.011121167175086488, 0.004595456615733906, 0.1904302292558525, 0.16866462861671827, 0.16856250879191415, 0.17280471280405185, 0.17359055442362747, 0.1673524122881721, 0.18864612006625847, 0.1714428134305901, 0.17405462013463602, 0.058763680225233705, 0.04286046697821255, 0.05514405398196687, 0.04763627332341425, 0.03429781522921571, 0.03464759086322067, 0.04153649622160793, 0.03018926604179928, 0.04404528975828492, 0.15955040034105328, 0.13289824674086248, 0.16202730939625087, 0.12993656417247368, 0.12954678450304546, 0.12031214410443447, 0.1357696948091871, 0.13516665634012737, 0.13157107640238774, 0.1375743848420441, 0.14249668484233402, 0.1613932299901244, 0.1692014763592824, 0.15684804528191998, 0.14129810551181543, 0.15013321579334793, 0.17377774300845283, 0.17752612777328447, 0.10045060415884677, 0.09733624860230117, 0.09279832588533632, 0.10255055811330693, 0.09607309500157735, 0.13604663650626736, 0.10577253636874173, 0.10607169036256314, 0.10293008727330089, 0.14415143342062564, 0.1332654230515411, 0.15617077573226912, 0.1606368559504623, 0.1376757996866783, 0.1440126636328496, 0.13550623933870487, 0.13196812223927568, 0.14149019520237327, 0.17596601796355005, 0.16982746649685831, 0.16496284837965502, 0.186367537807548, 0.16430786993558244, 0.1653457181491509, 0.16649888028482418, 0.16354347517240386, 0.17411455468907822, 0.15497406482978326, 0.14985711301377214, 0.13173446551933377, 0.1561973945679812, 0.12128628978671419, 0.11642613662784929, 0.24232265579054946, 0.15688404488978847, 0.11636174674523281, 0.14657275594725538, 0.12155840065350298, 0.1371404170603493, 0.12135609015012283, 0.13395471064511477, 0.09763794912939028, 0.13516486484906254, 0.13915942265309678, 0.12479731799872429, 0.19731881933969975, 0.19013314837067097, 0.18443174676694485, 0.19031487988444185, 0.18161599099850256, 0.17985400397873186, 0.1830300912544306, 0.19729744211786315, 0.1879882101548681, 0.04525785196699195, 0.03336307089262447, 0.05346343138998089, 0.039448333491558296, 0.035568970899336305, 0.038455284771352516, 0.037183256687706834, 0.04247072397480223, 0.03865087685924096]}, "mutation_prompt": null}
{"id": "7fb63ee2-2015-44b4-a684-3c875f275722", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Common heuristic for DE\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.99\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _mutate(self, idx, population):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(population[a] + self.mutation_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one element is from mutant\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                # Simulated Annealing acceptance criteria\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate  # Cool down the temperature\n\n        return best_solution", "name": "HybridDESA", "description": "A novel hybrid algorithm combining Differential Evolution and Simulated Annealing for enhanced exploration and exploitation in continuous black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3ae4b628-0508-4d7d-8286-78d4024c8d52", "metadata": {"aucs": [0.13425849757455965, 0.1381598539968769, 0.14490037312405224, 0.14908097925844266, 0.16364372344596612, 0.17080283455073153, 0.1373353801734013, 0.15181647266508047, 0.1434322924842838, 0.07355034912425451, 0.07828952414056622, 0.07814825637616818, 0.062155285455592124, 0.05100297935107756, 0.07652938978365542, 0.06856628881659066, 0.06623369611759067, 0.08672966709849661, 0.032271764582796125, 0.0386598559146103, 0.031354200422472944, 0.04087557190109259, 0.054438202545271985, 0.033265441671409324, 0.04548725569905476, 0.04340228294769677, 0.03749759183390999, 0.04797864868824109, 0.02275367111267279, 0.03153512105262524, 0.02386845305312213, 0.03392308226101559, 0.026669641872461236, 0.03653950507523096, 0.026547947185252108, 0.028262194327489443, 0.9290096287472159, 0.763818476304579, 0.85613145666422, 0.8375495146352231, 0.8007890584951443, 0.9506984094317505, 0.9390041283467817, 0.9844795152429242, 0.8839481847767507, 0.09039279942624268, 0.07937036833165656, 0.06803044667275537, 0.065317740929982, 0.05868480096531714, 0.08356932014055041, 0.11127848928635509, 0.08930161313246976, 0.10825146120048468, 0.14151756179723485, 0.09063849542036573, 0.10671949753025112, 0.12569517698936483, 0.12177764126630541, 0.13975140894117521, 0.1283241093942401, 0.11531962058382483, 0.11429381846640341, 0.06079465189529054, 0.09807415405931263, 0.06520284415534428, 0.06045379389826844, 0.06972112558917087, 0.07561358273359597, 0.07401951689414676, 0.06185976430082796, 0.07272410605842583, 0.07684223733211526, 0.07617751489934887, 0.10248290094244528, 0.07048008287968821, 0.09849024886412483, 0.09952749061707766, 0.07193018522521055, 0.06240432837988341, 0.06476258347919084, 0.029239585814539337, 0.042965310075783636, 0.04542320775358821, 0.0441141852583572, 0.06965758614375295, 0.030091996437255353, 0.060812197477901675, 0.043861112656721324, 0.03658167444911453, 0.12290564791314029, 0.10841088746015537, 0.16473819108195398, 0.10890106835378466, 0.11339457432568345, 0.1514132039449141, 0.10720748887214016, 0.12621215785382867, 0.1448901665534731, 0.031716544032152294, 0.020677155076420206, 0.02119501909665833, 0.024450114807489487, 0.03002245717026253, 0.01871460581163442, 0.02266762952726753, 0.021663722546297892, 0.04922782260020142, 0.013824290648283721, 0.0043195431876627, 0.0034332632302376265, 0.004993946031265684, 0.005062195361792532, 0.01297365038672893, 0.009827954775411096, 0.011121167175086488, 0.004595456615733906, 0.1904302292558525, 0.16866462861671827, 0.16856250879191415, 0.17280471280405185, 0.17359055442362747, 0.1673524122881721, 0.18864612006625847, 0.1714428134305901, 0.17405462013463602, 0.058763680225233705, 0.04286046697821255, 0.05514405398196687, 0.04763627332341425, 0.03429781522921571, 0.03464759086322067, 0.04153649622160793, 0.03018926604179928, 0.04404528975828492, 0.15955040034105328, 0.13289824674086248, 0.16202730939625087, 0.12993656417247368, 0.12954678450304546, 0.12031214410443447, 0.1357696948091871, 0.13516665634012737, 0.13157107640238774, 0.1375743848420441, 0.14249668484233402, 0.1613932299901244, 0.1692014763592824, 0.15684804528191998, 0.14129810551181543, 0.15013321579334793, 0.17377774300845283, 0.17752612777328447, 0.10045060415884677, 0.09733624860230117, 0.09279832588533632, 0.10255055811330693, 0.09607309500157735, 0.13604663650626736, 0.10577253636874173, 0.10607169036256314, 0.10293008727330089, 0.14415143342062564, 0.1332654230515411, 0.15617077573226912, 0.1606368559504623, 0.1376757996866783, 0.1440126636328496, 0.13550623933870487, 0.13196812223927568, 0.14149019520237327, 0.17596601796355005, 0.16982746649685831, 0.16496284837965502, 0.186367537807548, 0.16430786993558244, 0.1653457181491509, 0.16649888028482418, 0.16354347517240386, 0.17411455468907822, 0.15497406482978326, 0.14985711301377214, 0.13173446551933377, 0.1561973945679812, 0.12128628978671419, 0.11642613662784929, 0.24232265579054946, 0.15688404488978847, 0.11636174674523281, 0.14657275594725538, 0.12155840065350298, 0.1371404170603493, 0.12135609015012283, 0.13395471064511477, 0.09763794912939028, 0.13516486484906254, 0.13915942265309678, 0.12479731799872429, 0.19731881933969975, 0.19013314837067097, 0.18443174676694485, 0.19031487988444185, 0.18161599099850256, 0.17985400397873186, 0.1830300912544306, 0.19729744211786315, 0.1879882101548681, 0.04525785196699195, 0.03336307089262447, 0.05346343138998089, 0.039448333491558296, 0.035568970899336305, 0.038455284771352516, 0.037183256687706834, 0.04247072397480223, 0.03865087685924096]}, "mutation_prompt": null}
{"id": "d242f37c-4df0-48f1-81a5-0fbda6119e5b", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Common heuristic for DE\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.99\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _mutate(self, idx, population):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(population[a] + self.mutation_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one element is from mutant\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                # Simulated Annealing acceptance criteria\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate  # Cool down the temperature\n\n        return best_solution", "name": "HybridDESA", "description": "A novel hybrid algorithm combining Differential Evolution and Simulated Annealing for enhanced exploration and exploitation in continuous black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3ae4b628-0508-4d7d-8286-78d4024c8d52", "metadata": {"aucs": [0.13425849757455965, 0.1381598539968769, 0.14490037312405224, 0.14908097925844266, 0.16364372344596612, 0.17080283455073153, 0.1373353801734013, 0.15181647266508047, 0.1434322924842838, 0.07355034912425451, 0.07828952414056622, 0.07814825637616818, 0.062155285455592124, 0.05100297935107756, 0.07652938978365542, 0.06856628881659066, 0.06623369611759067, 0.08672966709849661, 0.032271764582796125, 0.0386598559146103, 0.031354200422472944, 0.04087557190109259, 0.054438202545271985, 0.033265441671409324, 0.04548725569905476, 0.04340228294769677, 0.03749759183390999, 0.04797864868824109, 0.02275367111267279, 0.03153512105262524, 0.02386845305312213, 0.03392308226101559, 0.026669641872461236, 0.03653950507523096, 0.026547947185252108, 0.028262194327489443, 0.9290096287472159, 0.763818476304579, 0.85613145666422, 0.8375495146352231, 0.8007890584951443, 0.9506984094317505, 0.9390041283467817, 0.9844795152429242, 0.8839481847767507, 0.09039279942624268, 0.07937036833165656, 0.06803044667275537, 0.065317740929982, 0.05868480096531714, 0.08356932014055041, 0.11127848928635509, 0.08930161313246976, 0.10825146120048468, 0.14151756179723485, 0.09063849542036573, 0.10671949753025112, 0.12569517698936483, 0.12177764126630541, 0.13975140894117521, 0.1283241093942401, 0.11531962058382483, 0.11429381846640341, 0.06079465189529054, 0.09807415405931263, 0.06520284415534428, 0.06045379389826844, 0.06972112558917087, 0.07561358273359597, 0.07401951689414676, 0.06185976430082796, 0.07272410605842583, 0.07684223733211526, 0.07617751489934887, 0.10248290094244528, 0.07048008287968821, 0.09849024886412483, 0.09952749061707766, 0.07193018522521055, 0.06240432837988341, 0.06476258347919084, 0.029239585814539337, 0.042965310075783636, 0.04542320775358821, 0.0441141852583572, 0.06965758614375295, 0.030091996437255353, 0.060812197477901675, 0.043861112656721324, 0.03658167444911453, 0.12290564791314029, 0.10841088746015537, 0.16473819108195398, 0.10890106835378466, 0.11339457432568345, 0.1514132039449141, 0.10720748887214016, 0.12621215785382867, 0.1448901665534731, 0.031716544032152294, 0.020677155076420206, 0.02119501909665833, 0.024450114807489487, 0.03002245717026253, 0.01871460581163442, 0.02266762952726753, 0.021663722546297892, 0.04922782260020142, 0.013824290648283721, 0.0043195431876627, 0.0034332632302376265, 0.004993946031265684, 0.005062195361792532, 0.01297365038672893, 0.009827954775411096, 0.011121167175086488, 0.004595456615733906, 0.1904302292558525, 0.16866462861671827, 0.16856250879191415, 0.17280471280405185, 0.17359055442362747, 0.1673524122881721, 0.18864612006625847, 0.1714428134305901, 0.17405462013463602, 0.058763680225233705, 0.04286046697821255, 0.05514405398196687, 0.04763627332341425, 0.03429781522921571, 0.03464759086322067, 0.04153649622160793, 0.03018926604179928, 0.04404528975828492, 0.15955040034105328, 0.13289824674086248, 0.16202730939625087, 0.12993656417247368, 0.12954678450304546, 0.12031214410443447, 0.1357696948091871, 0.13516665634012737, 0.13157107640238774, 0.1375743848420441, 0.14249668484233402, 0.1613932299901244, 0.1692014763592824, 0.15684804528191998, 0.14129810551181543, 0.15013321579334793, 0.17377774300845283, 0.17752612777328447, 0.10045060415884677, 0.09733624860230117, 0.09279832588533632, 0.10255055811330693, 0.09607309500157735, 0.13604663650626736, 0.10577253636874173, 0.10607169036256314, 0.10293008727330089, 0.14415143342062564, 0.1332654230515411, 0.15617077573226912, 0.1606368559504623, 0.1376757996866783, 0.1440126636328496, 0.13550623933870487, 0.13196812223927568, 0.14149019520237327, 0.17596601796355005, 0.16982746649685831, 0.16496284837965502, 0.186367537807548, 0.16430786993558244, 0.1653457181491509, 0.16649888028482418, 0.16354347517240386, 0.17411455468907822, 0.15497406482978326, 0.14985711301377214, 0.13173446551933377, 0.1561973945679812, 0.12128628978671419, 0.11642613662784929, 0.24232265579054946, 0.15688404488978847, 0.11636174674523281, 0.14657275594725538, 0.12155840065350298, 0.1371404170603493, 0.12135609015012283, 0.13395471064511477, 0.09763794912939028, 0.13516486484906254, 0.13915942265309678, 0.12479731799872429, 0.19731881933969975, 0.19013314837067097, 0.18443174676694485, 0.19031487988444185, 0.18161599099850256, 0.17985400397873186, 0.1830300912544306, 0.19729744211786315, 0.1879882101548681, 0.04525785196699195, 0.03336307089262447, 0.05346343138998089, 0.039448333491558296, 0.035568970899336305, 0.038455284771352516, 0.037183256687706834, 0.04247072397480223, 0.03865087685924096]}, "mutation_prompt": null}
{"id": "f4d1a74e-043e-42be-bd86-f9753fed1df6", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Common heuristic for DE\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.99\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _mutate(self, idx, population):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = np.clip(population[a] + self.mutation_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one element is from mutant\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                # Simulated Annealing acceptance criteria\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate  # Cool down the temperature\n\n        return best_solution", "name": "HybridDESA", "description": "A novel hybrid algorithm combining Differential Evolution and Simulated Annealing for enhanced exploration and exploitation in continuous black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3ae4b628-0508-4d7d-8286-78d4024c8d52", "metadata": {"aucs": [0.13425849757455965, 0.1381598539968769, 0.14490037312405224, 0.14908097925844266, 0.16364372344596612, 0.17080283455073153, 0.1373353801734013, 0.15181647266508047, 0.1434322924842838, 0.07355034912425451, 0.07828952414056622, 0.07814825637616818, 0.062155285455592124, 0.05100297935107756, 0.07652938978365542, 0.06856628881659066, 0.06623369611759067, 0.08672966709849661, 0.032271764582796125, 0.0386598559146103, 0.031354200422472944, 0.04087557190109259, 0.054438202545271985, 0.033265441671409324, 0.04548725569905476, 0.04340228294769677, 0.03749759183390999, 0.04797864868824109, 0.02275367111267279, 0.03153512105262524, 0.02386845305312213, 0.03392308226101559, 0.026669641872461236, 0.03653950507523096, 0.026547947185252108, 0.028262194327489443, 0.9290096287472159, 0.763818476304579, 0.85613145666422, 0.8375495146352231, 0.8007890584951443, 0.9506984094317505, 0.9390041283467817, 0.9844795152429242, 0.8839481847767507, 0.09039279942624268, 0.07937036833165656, 0.06803044667275537, 0.065317740929982, 0.05868480096531714, 0.08356932014055041, 0.11127848928635509, 0.08930161313246976, 0.10825146120048468, 0.14151756179723485, 0.09063849542036573, 0.10671949753025112, 0.12569517698936483, 0.12177764126630541, 0.13975140894117521, 0.1283241093942401, 0.11531962058382483, 0.11429381846640341, 0.06079465189529054, 0.09807415405931263, 0.06520284415534428, 0.06045379389826844, 0.06972112558917087, 0.07561358273359597, 0.07401951689414676, 0.06185976430082796, 0.07272410605842583, 0.07684223733211526, 0.07617751489934887, 0.10248290094244528, 0.07048008287968821, 0.09849024886412483, 0.09952749061707766, 0.07193018522521055, 0.06240432837988341, 0.06476258347919084, 0.029239585814539337, 0.042965310075783636, 0.04542320775358821, 0.0441141852583572, 0.06965758614375295, 0.030091996437255353, 0.060812197477901675, 0.043861112656721324, 0.03658167444911453, 0.12290564791314029, 0.10841088746015537, 0.16473819108195398, 0.10890106835378466, 0.11339457432568345, 0.1514132039449141, 0.10720748887214016, 0.12621215785382867, 0.1448901665534731, 0.031716544032152294, 0.020677155076420206, 0.02119501909665833, 0.024450114807489487, 0.03002245717026253, 0.01871460581163442, 0.02266762952726753, 0.021663722546297892, 0.04922782260020142, 0.013824290648283721, 0.0043195431876627, 0.0034332632302376265, 0.004993946031265684, 0.005062195361792532, 0.01297365038672893, 0.009827954775411096, 0.011121167175086488, 0.004595456615733906, 0.1904302292558525, 0.16866462861671827, 0.16856250879191415, 0.17280471280405185, 0.17359055442362747, 0.1673524122881721, 0.18864612006625847, 0.1714428134305901, 0.17405462013463602, 0.058763680225233705, 0.04286046697821255, 0.05514405398196687, 0.04763627332341425, 0.03429781522921571, 0.03464759086322067, 0.04153649622160793, 0.03018926604179928, 0.04404528975828492, 0.15955040034105328, 0.13289824674086248, 0.16202730939625087, 0.12993656417247368, 0.12954678450304546, 0.12031214410443447, 0.1357696948091871, 0.13516665634012737, 0.13157107640238774, 0.1375743848420441, 0.14249668484233402, 0.1613932299901244, 0.1692014763592824, 0.15684804528191998, 0.14129810551181543, 0.15013321579334793, 0.17377774300845283, 0.17752612777328447, 0.10045060415884677, 0.09733624860230117, 0.09279832588533632, 0.10255055811330693, 0.09607309500157735, 0.13604663650626736, 0.10577253636874173, 0.10607169036256314, 0.10293008727330089, 0.14415143342062564, 0.1332654230515411, 0.15617077573226912, 0.1606368559504623, 0.1376757996866783, 0.1440126636328496, 0.13550623933870487, 0.13196812223927568, 0.14149019520237327, 0.17596601796355005, 0.16982746649685831, 0.16496284837965502, 0.186367537807548, 0.16430786993558244, 0.1653457181491509, 0.16649888028482418, 0.16354347517240386, 0.17411455468907822, 0.15497406482978326, 0.14985711301377214, 0.13173446551933377, 0.1561973945679812, 0.12128628978671419, 0.11642613662784929, 0.24232265579054946, 0.15688404488978847, 0.11636174674523281, 0.14657275594725538, 0.12155840065350298, 0.1371404170603493, 0.12135609015012283, 0.13395471064511477, 0.09763794912939028, 0.13516486484906254, 0.13915942265309678, 0.12479731799872429, 0.19731881933969975, 0.19013314837067097, 0.18443174676694485, 0.19031487988444185, 0.18161599099850256, 0.17985400397873186, 0.1830300912544306, 0.19729744211786315, 0.1879882101548681, 0.04525785196699195, 0.03336307089262447, 0.05346343138998089, 0.039448333491558296, 0.035568970899336305, 0.038455284771352516, 0.037183256687706834, 0.04247072397480223, 0.03865087685924096]}, "mutation_prompt": null}
{"id": "539d9954-0ba3-40eb-970d-a8e7500b9e3d", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Common heuristic for DE\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.99\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        # Adapt mutation factor based on the proportion of budget used\n        return 0.5 + 0.3 * (1 - evaluations / self.budget)\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one element is from mutant\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                # Simulated Annealing acceptance criteria\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate  # Cool down the temperature\n\n        return best_solution", "name": "HybridDESA", "description": "Enhanced HybridDESA with adaptive mutation factor for balanced exploration and exploitation.", "configspace": "", "generation": 15, "fitness": 0.13510707113707598, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.16.", "error": "", "parent_id": "3ae4b628-0508-4d7d-8286-78d4024c8d52", "metadata": {"aucs": [0.1595231469762015, 0.15870257574038893, 0.15123300257816774, 0.16783882177562448, 0.16706306112160962, 0.17299179595507197, 0.14241737083288009, 0.16315262795937746, 0.14558909840491285, 0.08626058454991814, 0.08186027160270859, 0.09603366015764092, 0.08067840183997521, 0.07560529924070702, 0.0742511162543158, 0.09519950263650467, 0.08282312942622394, 0.07204230261450562, 0.035815667534847995, 0.033623764023753555, 0.037744852864109224, 0.04937030631040784, 0.040460590399504115, 0.04404487796262635, 0.04552753096464113, 0.07298236753090537, 0.04020790583593403, 0.021969085981303982, 0.029172220899376433, 0.031020505555171773, 0.03363353062287444, 0.032239246351556505, 0.03576335049613277, 0.049405902271619895, 0.03791167406288043, 0.028365341973822122, 0.9281926923511408, 0.9476825401446106, 0.9532268218719124, 0.8421759607932073, 0.7494004287389515, 0.4047056092069692, 0.8767638054906958, 0.9844799627981027, 0.7201119299551153, 0.07187349540211196, 0.07359888746277943, 0.07978802264138629, 0.0711737334558804, 0.08507727874473825, 0.0836576880788854, 0.11948839190569183, 0.09955779580341728, 0.09986559928350636, 0.13687888684621996, 0.11957148069486956, 0.10920109026364933, 0.12327575400153767, 0.11561067463680297, 0.13856828594094384, 0.12235081388339897, 0.1321079091420162, 0.13657930536289076, 0.11407969166953202, 0.106096583768169, 0.08735166904632063, 0.09187687927100996, 0.08944889639367648, 0.08398558941503453, 0.07734038622119133, 0.0786725301424318, 0.08855684318898915, 0.0883800636315607, 0.08418004141965796, 0.08681412411251566, 0.09421465986358213, 0.09950322408184531, 0.08977142892814738, 0.09672637162780029, 0.07276818292183218, 0.07019031785193386, 0.07835316158750683, 0.05913321537483174, 0.07458904203208172, 0.05316759851907682, 0.09861820227747198, 0.07257155893580569, 0.06649790058800265, 0.06152244786736916, 0.06282138465914577, 0.12724685044576145, 0.11934569244497073, 0.14000639773076384, 0.12946985122014654, 0.11378370848763064, 0.13281711373259764, 0.1436002523487392, 0.1263053573070947, 0.13265201343200628, 0.04959619715254737, 0.04967062391732291, 0.0490008281288028, 0.04478200125238441, 0.04857954621739824, 0.06422843985391669, 0.05722901496002575, 0.044401142987471, 0.052790291465400485, 0.008433307734535989, 0.003292305913686455, 0.009952467693429945, 0.006047987314007908, 0.01221042897086122, 0.003524396589217438, 0.024738996463697926, 0.013598974036982181, 0.012861644816809736, 0.17031151133044664, 0.1693309911423777, 0.18337007704634933, 0.16956376795927486, 0.17019886658892613, 0.17106194864160118, 0.1772524343977493, 0.20569077720232043, 0.1732216500287348, 0.05937951953465326, 0.04594458901080889, 0.05627560353065453, 0.042155618378490356, 0.03755750012206738, 0.04882035019662412, 0.03910801782210438, 0.04085811023797081, 0.03751105453137238, 0.1513195110286486, 0.12173377669522889, 0.15294218772188817, 0.1367626903914414, 0.14526745947707476, 0.13982419165844928, 0.1213156238860913, 0.13445986643198427, 0.12682997251236516, 0.14566875288314773, 0.15021607925243985, 0.1613932299901244, 0.15795540940782815, 0.14709792400365607, 0.1576482934078589, 0.17143872540669547, 0.17401847515385815, 0.18110441326353277, 0.09703161296899032, 0.08985040198535621, 0.10860608288968399, 0.10423873869694655, 0.0985969565579018, 0.10796425077200711, 0.09915703873949733, 0.11110756964273061, 0.09408757901569276, 0.1486701750554672, 0.170208133442442, 0.15818330620708898, 0.14384469216379892, 0.14686029489466979, 0.14734829423090356, 0.14435921455381762, 0.1316546551294585, 0.1446668020112063, 0.17476683221455058, 0.1705111672444728, 0.16659046364884433, 0.16490687297450768, 0.16896672948595237, 0.1625221379743772, 0.1677429528099068, 0.1668231039301541, 0.16428913267964418, 0.14481318748468397, 0.13776603032429924, 0.16103159271567202, 0.13572471056588786, 0.1429185914279868, 0.1654821447605085, 0.12434595100405588, 0.16306631495680413, 0.13461865226088143, 0.11364533645257668, 0.124098961523322, 0.1339022656130735, 0.1565189579895463, 0.09426645782064746, 0.11251948988047844, 0.15107816818646025, 0.1992382975839958, 0.13240755538383842, 0.17867344192060464, 0.18205566685949182, 0.18099253546351957, 0.1886502495117678, 0.19308382176565142, 0.19036943307271303, 0.18065166525517307, 0.18808163368567887, 0.18649440032639586, 0.047980986054031005, 0.0367139045510132, 0.036461943239221584, 0.04212450709925819, 0.03841888633099155, 0.06642924327332134, 0.038094986058577196, 0.05837577218447154, 0.048980296602535556]}, "mutation_prompt": null}
{"id": "5e5f0994-f5d9-4a4e-ba0f-f0651e53868e", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Common heuristic for DE\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.99\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        # Adapt mutation factor based on the proportion of budget used\n        return 0.5 + 0.3 * (1 - evaluations / self.budget)\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one element is from mutant\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _stochastic_ranking(self, population, fitness):\n        # Implementing stochastic ranking to prioritize solutions\n        perm = np.random.permutation(self.population_size)\n        for i in perm:\n            for j in range(i+1, self.population_size):\n                if np.random.rand() < 0.45:  # Probability to prefer better fitness\n                    if fitness[i] > fitness[j]:\n                        fitness[i], fitness[j] = fitness[j], fitness[i]\n                        population[i], population[j] = population[j].copy(), population[i].copy()\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                # Simulated Annealing acceptance criteria\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate  # Cool down the temperature\n            self._stochastic_ranking(population, fitness)  # Apply stochastic ranking\n\n        return best_solution", "name": "HybridDESA", "description": "Enhanced HybridDESA with stochastic ranking for improved balance between exploration and exploitation.", "configspace": "", "generation": 16, "fitness": 0.11234811581467846, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.08.", "error": "", "parent_id": "539d9954-0ba3-40eb-970d-a8e7500b9e3d", "metadata": {"aucs": [0.15454203291594348, 0.15005405304015895, 0.13142529912938916, 0.14371561212260564, 0.13400028578156475, 0.17531131226975072, 0.15289342941387607, 0.13847396106172472, 0.13178136244358574, 0.10045221704820528, 0.057330259983816356, 0.06507733383561387, 0.0856444160857478, 0.06282643105656438, 0.0730628567670083, 0.0690757895734938, 0.08722329506756066, 0.06413398474053811, 0.04144776797634242, 0.04613015464289694, 0.03858617201615122, 0.035480237633468636, 0.03967280902352943, 0.04054653500187855, 0.042691578423514565, 0.04205525287246492, 0.04617175465992662, 0.02668467593610635, 0.035321482841177976, 0.02950139444780686, 0.041934249055634254, 0.02663406195267848, 0.036554208194224835, 0.03829417781112865, 0.02794447701855185, 0.036910437544327546, 0.3351965249808181, 0.1462834490308189, 0.14748784620255972, 0.19589663753201259, 0.15932586015527594, 0.4734075117982516, 0.733357475844334, 0.2516481419954829, 0.6498149317059682, 0.06277397187904876, 0.061808612117105644, 0.06090618461913744, 0.051581778369210185, 0.053890658841633354, 0.05463212162894393, 0.07624399474260501, 0.10571432997384766, 0.10936510514533604, 0.12280763697619945, 0.12313774825779533, 0.14095123090534667, 0.1227039655176494, 0.1453364374055316, 0.15494732012230028, 0.1512792829750228, 0.12683788504350246, 0.1382266675540177, 0.0818971935950833, 0.08062218924686115, 0.08173475064850722, 0.08417534869816445, 0.08210314583979506, 0.07473446375735404, 0.08500907272658609, 0.07327829586554513, 0.08028793242047871, 0.0809137311485949, 0.06891163773342468, 0.058819471672239, 0.07831072301737918, 0.11388420081539008, 0.07603716607169664, 0.07616136885010982, 0.08931938400015571, 0.08201565574349967, 0.09196334308414011, 0.06714168814199095, 0.041062602849738505, 0.07550113449580786, 0.061366242652241665, 0.06950639133340375, 0.0562447856123901, 0.06928360606314088, 0.055204784619324765, 0.15188937361635002, 0.1261390562654331, 0.13799127316106774, 0.12222226875960862, 0.12937020044744107, 0.12057722290586348, 0.15984584093947574, 0.12336226531192973, 0.12854604287989402, 0.053322183288447955, 0.0635402628362215, 0.046538514324126146, 0.04951744960986548, 0.054330343042739204, 0.05226443644304779, 0.04943977038656289, 0.052468851316977316, 0.047200942107125, 0.01140983465618206, 0.014120122461089735, 0.005284641576850824, 0.008350144315792618, 0.01822528805609691, 0.0067536318644135784, 0.013319196557142643, 0.026917828675093958, 0.010003982678812084, 0.1728181611631482, 0.16284027414989177, 0.1789753683019467, 0.17262677933261006, 0.18838839894332227, 0.17617767861218037, 0.17395265368867185, 0.173723391442428, 0.1721636964035761, 0.047866849709097714, 0.040956681955996777, 0.05343149433658856, 0.03831917076807745, 0.04495385261149443, 0.03496010753243428, 0.04182637466113115, 0.034572986390957294, 0.04541992414642482, 0.12703634500658534, 0.1392307772941882, 0.1319029722186833, 0.13678341440046093, 0.12668206978541297, 0.12763434979324995, 0.13867114109259804, 0.12743794640646045, 0.12322965736260505, 0.14188978975920485, 0.15302053661561021, 0.1680572287297517, 0.15010510451270076, 0.1515514964364938, 0.1503026722614268, 0.16337515846924322, 0.17377774300845283, 0.14039369090713205, 0.10794876132031661, 0.09599868912691922, 0.09080966396662404, 0.10239349641918905, 0.09604824773568166, 0.09698271813677017, 0.09858439761249171, 0.1003847839415637, 0.10064327889210012, 0.14137703756831177, 0.13010727697264612, 0.13600296798985057, 0.13506847934134858, 0.13050234097857627, 0.14733725707407086, 0.1346065607639253, 0.14200181122356936, 0.145300954769485, 0.1790017904460367, 0.17130893023895166, 0.16731643307910982, 0.1686046305674388, 0.1655472790780288, 0.1658134886116268, 0.16714076002824563, 0.16433633758465493, 0.1743687609270892, 0.18123906397977685, 0.13058131091148084, 0.15240578481876377, 0.12430202251140687, 0.13422100365307854, 0.13425323062889494, 0.15849573245969661, 0.1511608567802456, 0.13418786975596964, 0.15286491736532004, 0.1183288633751618, 0.15956495662690817, 0.11277316127169235, 0.18511553231433742, 0.13428636308984043, 0.1342774614973692, 0.14270659674431574, 0.1470899546006471, 0.1822150062051342, 0.19420516190775317, 0.17034551440748402, 0.17619136442249295, 0.17462900090715372, 0.18923914896583116, 0.19362628087743639, 0.18549873638674064, 0.1957435016225768, 0.03875645057090826, 0.034771997448513, 0.045828026324077786, 0.07624762051011569, 0.047922318223904026, 0.03507830059879102, 0.043077996013215825, 0.04778273835128588, 0.043996147341959446]}, "mutation_prompt": null}
{"id": "942f8e01-6d2c-422f-8d9b-99e0d10eb16a", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Common heuristic for DE\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.99\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.3 * (1 - evaluations / self.budget)\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.7 + 0.2 * (evaluations / self.budget)\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one element is from mutant\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "name": "HybridDESA", "description": "Improved HybridDESA with adaptive crossover rate for enhanced exploration and exploitation balance.", "configspace": "", "generation": 17, "fitness": 0.13009446373088074, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.15.", "error": "", "parent_id": "539d9954-0ba3-40eb-970d-a8e7500b9e3d", "metadata": {"aucs": [0.14214514261020483, 0.146365717837872, 0.1613533258155816, 0.17694214905499484, 0.1645392857852197, 0.16142899648576514, 0.15198461811655706, 0.1486699685724463, 0.14928115038512113, 0.08570519637075669, 0.07722842100450567, 0.08062146968126871, 0.08964695028737057, 0.06987505199789612, 0.06651173492258933, 0.07853705523480858, 0.06761536165044713, 0.06629428076066923, 0.035418095998812515, 0.051936494884146645, 0.049511968361192205, 0.041813622943620454, 0.045107409416111466, 0.045099204463662335, 0.04194931124355805, 0.037372984975962975, 0.04529230364733483, 0.024774576791050107, 0.032042912057990036, 0.025068599462410024, 0.031071098055279966, 0.027808429147083147, 0.025259222052636532, 0.04006011409509591, 0.028664972035768566, 0.036602179058443096, 0.9811613010327371, 0.9169636147135165, 0.8208911875360677, 0.7711483854249137, 0.861951179527292, 0.8233716293404716, 0.8520774794761778, 0.6586800656962007, 0.22784504849679188, 0.07268235815695767, 0.07612861268263604, 0.07301752670034511, 0.07614713878508406, 0.06279969077133796, 0.06602449458324444, 0.09988130551869945, 0.10460902220637347, 0.08833775608030359, 0.14335235793802026, 0.09953926171155925, 0.11938930932337699, 0.14596747689205292, 0.13584316921962147, 0.14378391979180338, 0.11650939781903802, 0.11507582776363001, 0.11834267302583357, 0.08224155470334482, 0.08805531990093984, 0.0820941727648038, 0.0872938259865903, 0.06800145867104368, 0.08224192360879967, 0.07693722962689553, 0.07834523444021291, 0.09386402374168679, 0.0824475518320884, 0.06444171517805375, 0.06729359264342161, 0.10677397248338694, 0.11023563191934538, 0.10137748447426331, 0.07786485746901561, 0.0949629715913356, 0.08185666189109109, 0.05220784554385227, 0.05288840469265832, 0.04874062780201349, 0.050003096229795485, 0.0436893693652155, 0.03810041140802478, 0.04591358124242306, 0.055852267728147886, 0.05835508322962524, 0.10487231098471872, 0.10599447706518295, 0.09401296835230821, 0.09437011177985588, 0.08624752113135548, 0.08675227710467603, 0.1274143535243536, 0.12460638426968329, 0.15025588891110164, 0.02550083018956395, 0.033191150538297354, 0.029402883403844338, 0.04639826201629693, 0.03359580745660218, 0.03183142373592218, 0.0421051107289091, 0.044792728713591745, 0.04006766987658317, 0.011824225702981694, 0.005328448277562514, 0.0036654978039638575, 0.015273337048223756, 0.006058298746459911, 0.005634608552458453, 0.01188863048969857, 0.01950402816138741, 0.01964688427265371, 0.16681761184349397, 0.17477012793143398, 0.19426530394018826, 0.17900993228813566, 0.17611243359832474, 0.19645630499978406, 0.1846689694143181, 0.1715969453023094, 0.16928760072378157, 0.05286070937074505, 0.05604121208107338, 0.05440159522996746, 0.06098514199856786, 0.04369238977556855, 0.04620666283045516, 0.04135489109368751, 0.042585763006146915, 0.04028091385608845, 0.16359705815312786, 0.13390630249821767, 0.1374293399042168, 0.14445170431938548, 0.121915948557348, 0.12931780823648464, 0.14075104295211327, 0.1381287874487933, 0.15223614753929837, 0.1476771541033104, 0.15395241460660414, 0.16193525367310868, 0.15813319241861168, 0.15346960159856404, 0.14545173532028288, 0.14589114945002835, 0.17377774300845283, 0.1480583015012411, 0.09849872158788553, 0.09024946419765223, 0.0940980353097931, 0.11090899101215723, 0.09729723456492267, 0.1270811319789643, 0.10653236863229743, 0.10467568695512341, 0.10829345901734555, 0.14107637580254506, 0.13462925682227456, 0.1537481963008306, 0.1469319951048801, 0.13582846320224617, 0.14049482214779252, 0.1484103322426199, 0.1599501775136174, 0.14055745895752847, 0.1770477348933679, 0.16566443135266218, 0.16352866725641524, 0.17271936803985444, 0.16991524348483977, 0.16576854840442878, 0.17175658987078746, 0.18705262731731387, 0.18375932796399563, 0.14671419736904823, 0.1669560104651402, 0.1792339317256466, 0.11871364825161657, 0.13584654823821418, 0.13620079431847976, 0.13801876471159724, 0.15544902179001363, 0.14830288175942874, 0.15166859616341066, 0.12816022394157423, 0.12394616131244363, 0.1512216183052717, 0.11784089058879121, 0.12759711509324256, 0.16319849618080184, 0.19034105260214151, 0.14314037565707172, 0.1852639965401902, 0.1836581862044171, 0.18572900662961578, 0.1913978342324295, 0.18175336793710362, 0.20196431807516046, 0.1874822369169521, 0.19877123148208098, 0.18076200205672177, 0.053295248426517006, 0.03803750890376123, 0.0430773639181552, 0.04369686374500181, 0.04252985304822776, 0.04135817223306004, 0.04731469444950076, 0.0411353848638375, 0.0392401087415416]}, "mutation_prompt": null}
{"id": "2eac7a43-cece-4020-a49b-8b8684e8c54e", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Common heuristic for DE\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.99\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        # Adapt mutation factor based on the proportion of budget used\n        return 0.5 + 0.3 * (1 - evaluations / self.budget)\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one element is from mutant\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n    \n    def _resize_population(self, evaluations):\n        # Dynamically adjust the population size\n        resize_factor = 0.5 + 0.5 * (evaluations / self.budget)\n        new_size = int(self.population_size * resize_factor)\n        return max(4, new_size)  # Ensure at least 4 solutions\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                # Simulated Annealing acceptance criteria\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate  # Cool down the temperature\n            self.population_size = self._resize_population(evaluations)  # Adjust population size dynamically\n\n        return best_solution", "name": "HybridDESA", "description": "HybridDESA with dynamic population resizing to balance exploration and exploitation throughout the optimization process.", "configspace": "", "generation": 18, "fitness": 0.06247559125998293, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.05.", "error": "", "parent_id": "539d9954-0ba3-40eb-970d-a8e7500b9e3d", "metadata": {"aucs": [0.11869729595922507, 0.10290893285919378, 0.09169502728636048, 0.11048491871708666, 0.12605062311204152, 0.17102252258747652, 0.0998473575412605, 0.1350182040050979, 0.13969096209163567, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.028036765031399735, 9.999999999998899e-05, 0.026525423817095217, 0.019030189527766028, 0.005375109906600173, 0.025079887074717977, 0.029932158264354025, 0.03602798057268175, 0.018248263482334326, 0.01847445043694118, 0.010674738340807233, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01959972157639278, 0.012661184033684325, 9.999999999998899e-05, 0.014763392921912755, 0.014094210082617575, 9.999999999998899e-05, 0.07514800289028012, 0.15212548937248993, 0.07427419986402362, 0.0907185039798245, 0.06102445229299336, 0.06365281184361515, 0.0995137425683208, 0.062251421569649024, 0.07370659562548465, 0.06274794416174423, 0.03788987790784337, 0.05564233910192273, 0.040093432562773534, 0.013417583510281883, 0.01919160475918702, 0.08786085748185235, 0.1160616414551956, 9.999999999998899e-05, 0.10027683525177622, 0.08224659834595494, 0.06930721048242938, 0.0667108215001172, 0.08399869911036872, 0.03827924504783753, 0.02685990271740646, 0.05931056463008866, 0.07380798700103675, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11704725528417825, 9.999999999998899e-05, 0.06057128728950589, 0.07716868848617109, 0.10348779007675857, 0.07019392287599402, 0.020837997182052814, 0.00010683330060923257, 0.049337724173426634, 0.06202537731932933, 0.04560802364200878, 9.999999999998899e-05, 0.1171344408140087, 0.07080119496640436, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04397425709856084, 0.0408169471641644, 0.012086952757341507, 0.09167189680975518, 0.042882746807787586, 0.0016379623915386832, 0.05710989612839934, 0.07704578906988391, 0.046567241012377636, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1314097520791775, 0.15756555760738078, 0.14838054695461433, 0.12269960422555981, 0.12184593013568612, 0.15370528821725893, 0.16112956940342849, 0.132633072185128, 0.12506542790914754, 0.02183730164374542, 0.022093431313719325, 0.02198412468535549, 0.03266886175302153, 0.008619671027914944, 0.019346061602711795, 0.001492951980312518, 0.018063975830473256, 0.0267656688986897, 0.09980082729610418, 0.08609370886951495, 0.16381483091261995, 0.11433014855367496, 0.10852972522114013, 0.11230849900433082, 0.10086695096724829, 0.10214146043305283, 0.07776310154077493, 0.12198483876407917, 0.10384580970233781, 0.1613932299901244, 0.13800672315110074, 0.12647766980904085, 0.10444782645124173, 0.12028165949079228, 0.17377774300845283, 0.12925454197245145, 0.06143773627221505, 0.04796026706618273, 0.08398582550377798, 0.07683802875642864, 0.08596739422958655, 0.0663154297644929, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.1467915968260306, 0.09388200728521401, 0.13345086981233123, 0.11045114110739418, 0.10994424699721694, 0.10896891037713907, 0.12245976138762271, 0.09200057450963872, 0.1261963614278906, 0.1786342325543716, 9.999999999998899e-05, 0.15728088642203386, 0.03702345300373655, 0.025892814714230772, 9.999999999998899e-05, 0.014268920764337278, 0.15054486956141522, 0.11494948231779312, 0.10294593914697636, 0.08644132379572966, 0.08167024703901915, 0.07327841830047488, 0.1207914665021157, 0.06680304169034534, 0.11151439274907426, 0.10511484148144368, 0.0693612576838919, 0.11040265245322212, 0.10267165755511809, 0.06932034027342138, 0.11018708736777971, 0.0461742749748113, 0.05903250263678039, 0.07890095439417533, 0.04019044166964181, 0.1082342746314271, 0.14537504174938642, 0.14444612204709917, 0.14763022729669195, 0.14324378208815702, 0.1501810653782022, 0.16922880818721497, 0.16045246304906846, 0.15041126949668837, 0.1783962016962236, 0.015988569272526676, 0.02335706528533321, 0.031393493129599714, 0.027015293023570086, 0.03425093938292756, 0.020045516730027746, 0.016228383701229143, 0.03803354422653826, 0.017643830485487344]}, "mutation_prompt": null}
{"id": "38cf0c9e-74b1-4a98-8f10-9cebc7b86da9", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Common heuristic for DE\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.99\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.3 * (1 - evaluations / self.budget)\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations % 100 == 0:  # Dynamically adjust population size\n                    self.population_size = max(5, self.population_size - 1)\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate * (1 - evaluations / self.budget)  # Adapt cooling rate\n\n        return best_solution", "name": "HybridDESA", "description": "HybridDESA with adaptive temperature cooling and dynamic population resizing for enhanced convergence.", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('list.remove(x): x not in list').", "error": "ValueError('list.remove(x): x not in list')", "parent_id": "539d9954-0ba3-40eb-970d-a8e7500b9e3d", "metadata": {}, "mutation_prompt": null}
{"id": "eb443515-0d75-4a2b-9601-0da38d2355e2", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = self._adaptive_population_size(10 * dim)  # Adaptive population size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n\n    def _adaptive_population_size(self, default_size):\n        # Adjust population size based on dimensionality and budget\n        return min(default_size, self.budget // self.dim)\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.3 * (1 - evaluations / self.budget)\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "name": "HybridDESA", "description": "Refined HybridDESA with adaptive population size adjustment for improved balance between exploration and exploitation.", "configspace": "", "generation": 20, "fitness": 0.13510707113707598, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.16.", "error": "", "parent_id": "539d9954-0ba3-40eb-970d-a8e7500b9e3d", "metadata": {"aucs": [0.1595231469762015, 0.15870257574038893, 0.15123300257816774, 0.16783882177562448, 0.16706306112160962, 0.17299179595507197, 0.14241737083288009, 0.16315262795937746, 0.14558909840491285, 0.08626058454991814, 0.08186027160270859, 0.09603366015764092, 0.08067840183997521, 0.07560529924070702, 0.0742511162543158, 0.09519950263650467, 0.08282312942622394, 0.07204230261450562, 0.035815667534847995, 0.033623764023753555, 0.037744852864109224, 0.04937030631040784, 0.040460590399504115, 0.04404487796262635, 0.04552753096464113, 0.07298236753090537, 0.04020790583593403, 0.021969085981303982, 0.029172220899376433, 0.031020505555171773, 0.03363353062287444, 0.032239246351556505, 0.03576335049613277, 0.049405902271619895, 0.03791167406288043, 0.028365341973822122, 0.9281926923511408, 0.9476825401446106, 0.9532268218719124, 0.8421759607932073, 0.7494004287389515, 0.4047056092069692, 0.8767638054906958, 0.9844799627981027, 0.7201119299551153, 0.07187349540211196, 0.07359888746277943, 0.07978802264138629, 0.0711737334558804, 0.08507727874473825, 0.0836576880788854, 0.11948839190569183, 0.09955779580341728, 0.09986559928350636, 0.13687888684621996, 0.11957148069486956, 0.10920109026364933, 0.12327575400153767, 0.11561067463680297, 0.13856828594094384, 0.12235081388339897, 0.1321079091420162, 0.13657930536289076, 0.11407969166953202, 0.106096583768169, 0.08735166904632063, 0.09187687927100996, 0.08944889639367648, 0.08398558941503453, 0.07734038622119133, 0.0786725301424318, 0.08855684318898915, 0.0883800636315607, 0.08418004141965796, 0.08681412411251566, 0.09421465986358213, 0.09950322408184531, 0.08977142892814738, 0.09672637162780029, 0.07276818292183218, 0.07019031785193386, 0.07835316158750683, 0.05913321537483174, 0.07458904203208172, 0.05316759851907682, 0.09861820227747198, 0.07257155893580569, 0.06649790058800265, 0.06152244786736916, 0.06282138465914577, 0.12724685044576145, 0.11934569244497073, 0.14000639773076384, 0.12946985122014654, 0.11378370848763064, 0.13281711373259764, 0.1436002523487392, 0.1263053573070947, 0.13265201343200628, 0.04959619715254737, 0.04967062391732291, 0.0490008281288028, 0.04478200125238441, 0.04857954621739824, 0.06422843985391669, 0.05722901496002575, 0.044401142987471, 0.052790291465400485, 0.008433307734535989, 0.003292305913686455, 0.009952467693429945, 0.006047987314007908, 0.01221042897086122, 0.003524396589217438, 0.024738996463697926, 0.013598974036982181, 0.012861644816809736, 0.17031151133044664, 0.1693309911423777, 0.18337007704634933, 0.16956376795927486, 0.17019886658892613, 0.17106194864160118, 0.1772524343977493, 0.20569077720232043, 0.1732216500287348, 0.05937951953465326, 0.04594458901080889, 0.05627560353065453, 0.042155618378490356, 0.03755750012206738, 0.04882035019662412, 0.03910801782210438, 0.04085811023797081, 0.03751105453137238, 0.1513195110286486, 0.12173377669522889, 0.15294218772188817, 0.1367626903914414, 0.14526745947707476, 0.13982419165844928, 0.1213156238860913, 0.13445986643198427, 0.12682997251236516, 0.14566875288314773, 0.15021607925243985, 0.1613932299901244, 0.15795540940782815, 0.14709792400365607, 0.1576482934078589, 0.17143872540669547, 0.17401847515385815, 0.18110441326353277, 0.09703161296899032, 0.08985040198535621, 0.10860608288968399, 0.10423873869694655, 0.0985969565579018, 0.10796425077200711, 0.09915703873949733, 0.11110756964273061, 0.09408757901569276, 0.1486701750554672, 0.170208133442442, 0.15818330620708898, 0.14384469216379892, 0.14686029489466979, 0.14734829423090356, 0.14435921455381762, 0.1316546551294585, 0.1446668020112063, 0.17476683221455058, 0.1705111672444728, 0.16659046364884433, 0.16490687297450768, 0.16896672948595237, 0.1625221379743772, 0.1677429528099068, 0.1668231039301541, 0.16428913267964418, 0.14481318748468397, 0.13776603032429924, 0.16103159271567202, 0.13572471056588786, 0.1429185914279868, 0.1654821447605085, 0.12434595100405588, 0.16306631495680413, 0.13461865226088143, 0.11364533645257668, 0.124098961523322, 0.1339022656130735, 0.1565189579895463, 0.09426645782064746, 0.11251948988047844, 0.15107816818646025, 0.1992382975839958, 0.13240755538383842, 0.17867344192060464, 0.18205566685949182, 0.18099253546351957, 0.1886502495117678, 0.19308382176565142, 0.19036943307271303, 0.18065166525517307, 0.18808163368567887, 0.18649440032639586, 0.047980986054031005, 0.0367139045510132, 0.036461943239221584, 0.04212450709925819, 0.03841888633099155, 0.06642924327332134, 0.038094986058577196, 0.05837577218447154, 0.048980296602535556]}, "mutation_prompt": null}
{"id": "fd2cd86a-df5b-4a2f-8159-a044537c35f8", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Common heuristic for DE\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.99\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        # Adapt mutation factor based on the proportion of budget used\n        return 0.5 + 0.3 * (1 - evaluations / self.budget)\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one element is from mutant\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                # Simulated Annealing acceptance criteria\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate  # Cool down the temperature\n\n        return best_solution", "name": "HybridDESA", "description": "Enhanced HybridDESA with adaptive mutation factor for balanced exploration and exploitation.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "539d9954-0ba3-40eb-970d-a8e7500b9e3d", "metadata": {"aucs": [0.1595231469762015, 0.15870257574038893, 0.15123300257816774, 0.16783882177562448, 0.16706306112160962, 0.17299179595507197, 0.14241737083288009, 0.16315262795937746, 0.14558909840491285, 0.08626058454991814, 0.08186027160270859, 0.09603366015764092, 0.08067840183997521, 0.07560529924070702, 0.0742511162543158, 0.09519950263650467, 0.08282312942622394, 0.07204230261450562, 0.035815667534847995, 0.033623764023753555, 0.037744852864109224, 0.04937030631040784, 0.040460590399504115, 0.04404487796262635, 0.04552753096464113, 0.07298236753090537, 0.04020790583593403, 0.021969085981303982, 0.029172220899376433, 0.031020505555171773, 0.03363353062287444, 0.032239246351556505, 0.03576335049613277, 0.049405902271619895, 0.03791167406288043, 0.028365341973822122, 0.9281926923511408, 0.9476825401446106, 0.9532268218719124, 0.8421759607932073, 0.7494004287389515, 0.4047056092069692, 0.8767638054906958, 0.9844799627981027, 0.7201119299551153, 0.07187349540211196, 0.07359888746277943, 0.07978802264138629, 0.0711737334558804, 0.08507727874473825, 0.0836576880788854, 0.11948839190569183, 0.09955779580341728, 0.09986559928350636, 0.13687888684621996, 0.11957148069486956, 0.10920109026364933, 0.12327575400153767, 0.11561067463680297, 0.13856828594094384, 0.12235081388339897, 0.1321079091420162, 0.13657930536289076, 0.11407969166953202, 0.106096583768169, 0.08735166904632063, 0.09187687927100996, 0.08944889639367648, 0.08398558941503453, 0.07734038622119133, 0.0786725301424318, 0.08855684318898915, 0.0883800636315607, 0.08418004141965796, 0.08681412411251566, 0.09421465986358213, 0.09950322408184531, 0.08977142892814738, 0.09672637162780029, 0.07276818292183218, 0.07019031785193386, 0.07835316158750683, 0.05913321537483174, 0.07458904203208172, 0.05316759851907682, 0.09861820227747198, 0.07257155893580569, 0.06649790058800265, 0.06152244786736916, 0.06282138465914577, 0.12724685044576145, 0.11934569244497073, 0.14000639773076384, 0.12946985122014654, 0.11378370848763064, 0.13281711373259764, 0.1436002523487392, 0.1263053573070947, 0.13265201343200628, 0.04959619715254737, 0.04967062391732291, 0.0490008281288028, 0.04478200125238441, 0.04857954621739824, 0.06422843985391669, 0.05722901496002575, 0.044401142987471, 0.052790291465400485, 0.008433307734535989, 0.003292305913686455, 0.009952467693429945, 0.006047987314007908, 0.01221042897086122, 0.003524396589217438, 0.024738996463697926, 0.013598974036982181, 0.012861644816809736, 0.17031151133044664, 0.1693309911423777, 0.18337007704634933, 0.16956376795927486, 0.17019886658892613, 0.17106194864160118, 0.1772524343977493, 0.20569077720232043, 0.1732216500287348, 0.05937951953465326, 0.04594458901080889, 0.05627560353065453, 0.042155618378490356, 0.03755750012206738, 0.04882035019662412, 0.03910801782210438, 0.04085811023797081, 0.03751105453137238, 0.1513195110286486, 0.12173377669522889, 0.15294218772188817, 0.1367626903914414, 0.14526745947707476, 0.13982419165844928, 0.1213156238860913, 0.13445986643198427, 0.12682997251236516, 0.14566875288314773, 0.15021607925243985, 0.1613932299901244, 0.15795540940782815, 0.14709792400365607, 0.1576482934078589, 0.17143872540669547, 0.17401847515385815, 0.18110441326353277, 0.09703161296899032, 0.08985040198535621, 0.10860608288968399, 0.10423873869694655, 0.0985969565579018, 0.10796425077200711, 0.09915703873949733, 0.11110756964273061, 0.09408757901569276, 0.1486701750554672, 0.170208133442442, 0.15818330620708898, 0.14384469216379892, 0.14686029489466979, 0.14734829423090356, 0.14435921455381762, 0.1316546551294585, 0.1446668020112063, 0.17476683221455058, 0.1705111672444728, 0.16659046364884433, 0.16490687297450768, 0.16896672948595237, 0.1625221379743772, 0.1677429528099068, 0.1668231039301541, 0.16428913267964418, 0.14481318748468397, 0.13776603032429924, 0.16103159271567202, 0.13572471056588786, 0.1429185914279868, 0.1654821447605085, 0.12434595100405588, 0.16306631495680413, 0.13461865226088143, 0.11364533645257668, 0.124098961523322, 0.1339022656130735, 0.1565189579895463, 0.09426645782064746, 0.11251948988047844, 0.15107816818646025, 0.1992382975839958, 0.13240755538383842, 0.17867344192060464, 0.18205566685949182, 0.18099253546351957, 0.1886502495117678, 0.19308382176565142, 0.19036943307271303, 0.18065166525517307, 0.18808163368567887, 0.18649440032639586, 0.047980986054031005, 0.0367139045510132, 0.036461943239221584, 0.04212450709925819, 0.03841888633099155, 0.06642924327332134, 0.038094986058577196, 0.05837577218447154, 0.048980296602535556]}, "mutation_prompt": null}
{"id": "66bebabf-247d-411a-8a08-c7569201b4f9", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Common heuristic for DE\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.99\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        # Adapt mutation factor based on the proportion of budget used\n        return 0.5 + 0.3 * (1 - evaluations / self.budget)\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one element is from mutant\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                # Simulated Annealing acceptance criteria\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate  # Cool down the temperature\n\n        return best_solution", "name": "HybridDESA", "description": "Enhanced HybridDESA with adaptive mutation factor for balanced exploration and exploitation.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "539d9954-0ba3-40eb-970d-a8e7500b9e3d", "metadata": {"aucs": [0.1595231469762015, 0.15870257574038893, 0.15123300257816774, 0.16783882177562448, 0.16706306112160962, 0.17299179595507197, 0.14241737083288009, 0.16315262795937746, 0.14558909840491285, 0.08626058454991814, 0.08186027160270859, 0.09603366015764092, 0.08067840183997521, 0.07560529924070702, 0.0742511162543158, 0.09519950263650467, 0.08282312942622394, 0.07204230261450562, 0.035815667534847995, 0.033623764023753555, 0.037744852864109224, 0.04937030631040784, 0.040460590399504115, 0.04404487796262635, 0.04552753096464113, 0.07298236753090537, 0.04020790583593403, 0.021969085981303982, 0.029172220899376433, 0.031020505555171773, 0.03363353062287444, 0.032239246351556505, 0.03576335049613277, 0.049405902271619895, 0.03791167406288043, 0.028365341973822122, 0.9281926923511408, 0.9476825401446106, 0.9532268218719124, 0.8421759607932073, 0.7494004287389515, 0.4047056092069692, 0.8767638054906958, 0.9844799627981027, 0.7201119299551153, 0.07187349540211196, 0.07359888746277943, 0.07978802264138629, 0.0711737334558804, 0.08507727874473825, 0.0836576880788854, 0.11948839190569183, 0.09955779580341728, 0.09986559928350636, 0.13687888684621996, 0.11957148069486956, 0.10920109026364933, 0.12327575400153767, 0.11561067463680297, 0.13856828594094384, 0.12235081388339897, 0.1321079091420162, 0.13657930536289076, 0.11407969166953202, 0.106096583768169, 0.08735166904632063, 0.09187687927100996, 0.08944889639367648, 0.08398558941503453, 0.07734038622119133, 0.0786725301424318, 0.08855684318898915, 0.0883800636315607, 0.08418004141965796, 0.08681412411251566, 0.09421465986358213, 0.09950322408184531, 0.08977142892814738, 0.09672637162780029, 0.07276818292183218, 0.07019031785193386, 0.07835316158750683, 0.05913321537483174, 0.07458904203208172, 0.05316759851907682, 0.09861820227747198, 0.07257155893580569, 0.06649790058800265, 0.06152244786736916, 0.06282138465914577, 0.12724685044576145, 0.11934569244497073, 0.14000639773076384, 0.12946985122014654, 0.11378370848763064, 0.13281711373259764, 0.1436002523487392, 0.1263053573070947, 0.13265201343200628, 0.04959619715254737, 0.04967062391732291, 0.0490008281288028, 0.04478200125238441, 0.04857954621739824, 0.06422843985391669, 0.05722901496002575, 0.044401142987471, 0.052790291465400485, 0.008433307734535989, 0.003292305913686455, 0.009952467693429945, 0.006047987314007908, 0.01221042897086122, 0.003524396589217438, 0.024738996463697926, 0.013598974036982181, 0.012861644816809736, 0.17031151133044664, 0.1693309911423777, 0.18337007704634933, 0.16956376795927486, 0.17019886658892613, 0.17106194864160118, 0.1772524343977493, 0.20569077720232043, 0.1732216500287348, 0.05937951953465326, 0.04594458901080889, 0.05627560353065453, 0.042155618378490356, 0.03755750012206738, 0.04882035019662412, 0.03910801782210438, 0.04085811023797081, 0.03751105453137238, 0.1513195110286486, 0.12173377669522889, 0.15294218772188817, 0.1367626903914414, 0.14526745947707476, 0.13982419165844928, 0.1213156238860913, 0.13445986643198427, 0.12682997251236516, 0.14566875288314773, 0.15021607925243985, 0.1613932299901244, 0.15795540940782815, 0.14709792400365607, 0.1576482934078589, 0.17143872540669547, 0.17401847515385815, 0.18110441326353277, 0.09703161296899032, 0.08985040198535621, 0.10860608288968399, 0.10423873869694655, 0.0985969565579018, 0.10796425077200711, 0.09915703873949733, 0.11110756964273061, 0.09408757901569276, 0.1486701750554672, 0.170208133442442, 0.15818330620708898, 0.14384469216379892, 0.14686029489466979, 0.14734829423090356, 0.14435921455381762, 0.1316546551294585, 0.1446668020112063, 0.17476683221455058, 0.1705111672444728, 0.16659046364884433, 0.16490687297450768, 0.16896672948595237, 0.1625221379743772, 0.1677429528099068, 0.1668231039301541, 0.16428913267964418, 0.14481318748468397, 0.13776603032429924, 0.16103159271567202, 0.13572471056588786, 0.1429185914279868, 0.1654821447605085, 0.12434595100405588, 0.16306631495680413, 0.13461865226088143, 0.11364533645257668, 0.124098961523322, 0.1339022656130735, 0.1565189579895463, 0.09426645782064746, 0.11251948988047844, 0.15107816818646025, 0.1992382975839958, 0.13240755538383842, 0.17867344192060464, 0.18205566685949182, 0.18099253546351957, 0.1886502495117678, 0.19308382176565142, 0.19036943307271303, 0.18065166525517307, 0.18808163368567887, 0.18649440032639586, 0.047980986054031005, 0.0367139045510132, 0.036461943239221584, 0.04212450709925819, 0.03841888633099155, 0.06642924327332134, 0.038094986058577196, 0.05837577218447154, 0.048980296602535556]}, "mutation_prompt": null}
{"id": "c9e18685-fcab-455f-a10e-a5ba8b802d5c", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Common heuristic for DE\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.99\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        # Adapt mutation factor based on the proportion of budget used\n        return 0.5 + 0.3 * (1 - evaluations / self.budget)\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one element is from mutant\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                # Simulated Annealing acceptance criteria\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate  # Cool down the temperature\n\n        return best_solution", "name": "HybridDESA", "description": "Enhanced HybridDESA with adaptive mutation factor for balanced exploration and exploitation.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "539d9954-0ba3-40eb-970d-a8e7500b9e3d", "metadata": {"aucs": [0.1595231469762015, 0.15870257574038893, 0.15123300257816774, 0.16783882177562448, 0.16706306112160962, 0.17299179595507197, 0.14241737083288009, 0.16315262795937746, 0.14558909840491285, 0.08626058454991814, 0.08186027160270859, 0.09603366015764092, 0.08067840183997521, 0.07560529924070702, 0.0742511162543158, 0.09519950263650467, 0.08282312942622394, 0.07204230261450562, 0.035815667534847995, 0.033623764023753555, 0.037744852864109224, 0.04937030631040784, 0.040460590399504115, 0.04404487796262635, 0.04552753096464113, 0.07298236753090537, 0.04020790583593403, 0.021969085981303982, 0.029172220899376433, 0.031020505555171773, 0.03363353062287444, 0.032239246351556505, 0.03576335049613277, 0.049405902271619895, 0.03791167406288043, 0.028365341973822122, 0.9281926923511408, 0.9476825401446106, 0.9532268218719124, 0.8421759607932073, 0.7494004287389515, 0.4047056092069692, 0.8767638054906958, 0.9844799627981027, 0.7201119299551153, 0.07187349540211196, 0.07359888746277943, 0.07978802264138629, 0.0711737334558804, 0.08507727874473825, 0.0836576880788854, 0.11948839190569183, 0.09955779580341728, 0.09986559928350636, 0.13687888684621996, 0.11957148069486956, 0.10920109026364933, 0.12327575400153767, 0.11561067463680297, 0.13856828594094384, 0.12235081388339897, 0.1321079091420162, 0.13657930536289076, 0.11407969166953202, 0.106096583768169, 0.08735166904632063, 0.09187687927100996, 0.08944889639367648, 0.08398558941503453, 0.07734038622119133, 0.0786725301424318, 0.08855684318898915, 0.0883800636315607, 0.08418004141965796, 0.08681412411251566, 0.09421465986358213, 0.09950322408184531, 0.08977142892814738, 0.09672637162780029, 0.07276818292183218, 0.07019031785193386, 0.07835316158750683, 0.05913321537483174, 0.07458904203208172, 0.05316759851907682, 0.09861820227747198, 0.07257155893580569, 0.06649790058800265, 0.06152244786736916, 0.06282138465914577, 0.12724685044576145, 0.11934569244497073, 0.14000639773076384, 0.12946985122014654, 0.11378370848763064, 0.13281711373259764, 0.1436002523487392, 0.1263053573070947, 0.13265201343200628, 0.04959619715254737, 0.04967062391732291, 0.0490008281288028, 0.04478200125238441, 0.04857954621739824, 0.06422843985391669, 0.05722901496002575, 0.044401142987471, 0.052790291465400485, 0.008433307734535989, 0.003292305913686455, 0.009952467693429945, 0.006047987314007908, 0.01221042897086122, 0.003524396589217438, 0.024738996463697926, 0.013598974036982181, 0.012861644816809736, 0.17031151133044664, 0.1693309911423777, 0.18337007704634933, 0.16956376795927486, 0.17019886658892613, 0.17106194864160118, 0.1772524343977493, 0.20569077720232043, 0.1732216500287348, 0.05937951953465326, 0.04594458901080889, 0.05627560353065453, 0.042155618378490356, 0.03755750012206738, 0.04882035019662412, 0.03910801782210438, 0.04085811023797081, 0.03751105453137238, 0.1513195110286486, 0.12173377669522889, 0.15294218772188817, 0.1367626903914414, 0.14526745947707476, 0.13982419165844928, 0.1213156238860913, 0.13445986643198427, 0.12682997251236516, 0.14566875288314773, 0.15021607925243985, 0.1613932299901244, 0.15795540940782815, 0.14709792400365607, 0.1576482934078589, 0.17143872540669547, 0.17401847515385815, 0.18110441326353277, 0.09703161296899032, 0.08985040198535621, 0.10860608288968399, 0.10423873869694655, 0.0985969565579018, 0.10796425077200711, 0.09915703873949733, 0.11110756964273061, 0.09408757901569276, 0.1486701750554672, 0.170208133442442, 0.15818330620708898, 0.14384469216379892, 0.14686029489466979, 0.14734829423090356, 0.14435921455381762, 0.1316546551294585, 0.1446668020112063, 0.17476683221455058, 0.1705111672444728, 0.16659046364884433, 0.16490687297450768, 0.16896672948595237, 0.1625221379743772, 0.1677429528099068, 0.1668231039301541, 0.16428913267964418, 0.14481318748468397, 0.13776603032429924, 0.16103159271567202, 0.13572471056588786, 0.1429185914279868, 0.1654821447605085, 0.12434595100405588, 0.16306631495680413, 0.13461865226088143, 0.11364533645257668, 0.124098961523322, 0.1339022656130735, 0.1565189579895463, 0.09426645782064746, 0.11251948988047844, 0.15107816818646025, 0.1992382975839958, 0.13240755538383842, 0.17867344192060464, 0.18205566685949182, 0.18099253546351957, 0.1886502495117678, 0.19308382176565142, 0.19036943307271303, 0.18065166525517307, 0.18808163368567887, 0.18649440032639586, 0.047980986054031005, 0.0367139045510132, 0.036461943239221584, 0.04212450709925819, 0.03841888633099155, 0.06642924327332134, 0.038094986058577196, 0.05837577218447154, 0.048980296602535556]}, "mutation_prompt": null}
{"id": "905f67aa-60a3-4672-a277-bce517429527", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Common heuristic for DE\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.99\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        # Adapt mutation factor based on the proportion of budget used\n        return 0.5 + 0.3 * (1 - evaluations / self.budget)\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one element is from mutant\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                # Simulated Annealing acceptance criteria\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate  # Cool down the temperature\n\n        return best_solution", "name": "HybridDESA", "description": "Enhanced HybridDESA with adaptive mutation factor for balanced exploration and exploitation.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "539d9954-0ba3-40eb-970d-a8e7500b9e3d", "metadata": {"aucs": [0.1595231469762015, 0.15870257574038893, 0.15123300257816774, 0.16783882177562448, 0.16706306112160962, 0.17299179595507197, 0.14241737083288009, 0.16315262795937746, 0.14558909840491285, 0.08626058454991814, 0.08186027160270859, 0.09603366015764092, 0.08067840183997521, 0.07560529924070702, 0.0742511162543158, 0.09519950263650467, 0.08282312942622394, 0.07204230261450562, 0.035815667534847995, 0.033623764023753555, 0.037744852864109224, 0.04937030631040784, 0.040460590399504115, 0.04404487796262635, 0.04552753096464113, 0.07298236753090537, 0.04020790583593403, 0.021969085981303982, 0.029172220899376433, 0.031020505555171773, 0.03363353062287444, 0.032239246351556505, 0.03576335049613277, 0.049405902271619895, 0.03791167406288043, 0.028365341973822122, 0.9281926923511408, 0.9476825401446106, 0.9532268218719124, 0.8421759607932073, 0.7494004287389515, 0.4047056092069692, 0.8767638054906958, 0.9844799627981027, 0.7201119299551153, 0.07187349540211196, 0.07359888746277943, 0.07978802264138629, 0.0711737334558804, 0.08507727874473825, 0.0836576880788854, 0.11948839190569183, 0.09955779580341728, 0.09986559928350636, 0.13687888684621996, 0.11957148069486956, 0.10920109026364933, 0.12327575400153767, 0.11561067463680297, 0.13856828594094384, 0.12235081388339897, 0.1321079091420162, 0.13657930536289076, 0.11407969166953202, 0.106096583768169, 0.08735166904632063, 0.09187687927100996, 0.08944889639367648, 0.08398558941503453, 0.07734038622119133, 0.0786725301424318, 0.08855684318898915, 0.0883800636315607, 0.08418004141965796, 0.08681412411251566, 0.09421465986358213, 0.09950322408184531, 0.08977142892814738, 0.09672637162780029, 0.07276818292183218, 0.07019031785193386, 0.07835316158750683, 0.05913321537483174, 0.07458904203208172, 0.05316759851907682, 0.09861820227747198, 0.07257155893580569, 0.06649790058800265, 0.06152244786736916, 0.06282138465914577, 0.12724685044576145, 0.11934569244497073, 0.14000639773076384, 0.12946985122014654, 0.11378370848763064, 0.13281711373259764, 0.1436002523487392, 0.1263053573070947, 0.13265201343200628, 0.04959619715254737, 0.04967062391732291, 0.0490008281288028, 0.04478200125238441, 0.04857954621739824, 0.06422843985391669, 0.05722901496002575, 0.044401142987471, 0.052790291465400485, 0.008433307734535989, 0.003292305913686455, 0.009952467693429945, 0.006047987314007908, 0.01221042897086122, 0.003524396589217438, 0.024738996463697926, 0.013598974036982181, 0.012861644816809736, 0.17031151133044664, 0.1693309911423777, 0.18337007704634933, 0.16956376795927486, 0.17019886658892613, 0.17106194864160118, 0.1772524343977493, 0.20569077720232043, 0.1732216500287348, 0.05937951953465326, 0.04594458901080889, 0.05627560353065453, 0.042155618378490356, 0.03755750012206738, 0.04882035019662412, 0.03910801782210438, 0.04085811023797081, 0.03751105453137238, 0.1513195110286486, 0.12173377669522889, 0.15294218772188817, 0.1367626903914414, 0.14526745947707476, 0.13982419165844928, 0.1213156238860913, 0.13445986643198427, 0.12682997251236516, 0.14566875288314773, 0.15021607925243985, 0.1613932299901244, 0.15795540940782815, 0.14709792400365607, 0.1576482934078589, 0.17143872540669547, 0.17401847515385815, 0.18110441326353277, 0.09703161296899032, 0.08985040198535621, 0.10860608288968399, 0.10423873869694655, 0.0985969565579018, 0.10796425077200711, 0.09915703873949733, 0.11110756964273061, 0.09408757901569276, 0.1486701750554672, 0.170208133442442, 0.15818330620708898, 0.14384469216379892, 0.14686029489466979, 0.14734829423090356, 0.14435921455381762, 0.1316546551294585, 0.1446668020112063, 0.17476683221455058, 0.1705111672444728, 0.16659046364884433, 0.16490687297450768, 0.16896672948595237, 0.1625221379743772, 0.1677429528099068, 0.1668231039301541, 0.16428913267964418, 0.14481318748468397, 0.13776603032429924, 0.16103159271567202, 0.13572471056588786, 0.1429185914279868, 0.1654821447605085, 0.12434595100405588, 0.16306631495680413, 0.13461865226088143, 0.11364533645257668, 0.124098961523322, 0.1339022656130735, 0.1565189579895463, 0.09426645782064746, 0.11251948988047844, 0.15107816818646025, 0.1992382975839958, 0.13240755538383842, 0.17867344192060464, 0.18205566685949182, 0.18099253546351957, 0.1886502495117678, 0.19308382176565142, 0.19036943307271303, 0.18065166525517307, 0.18808163368567887, 0.18649440032639586, 0.047980986054031005, 0.0367139045510132, 0.036461943239221584, 0.04212450709925819, 0.03841888633099155, 0.06642924327332134, 0.038094986058577196, 0.05837577218447154, 0.048980296602535556]}, "mutation_prompt": null}
{"id": "664e0db9-c445-410c-9b77-eaa9f66fb565", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Common heuristic for DE\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.97\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        # Adapt mutation factor based on the proportion of budget used\n        return 0.5 + 0.3 * (1 - evaluations / self.budget)\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        # Adapt crossover rate to increase exploration in early stages\n        return 0.6 + 0.3 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one element is from mutant\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                # Simulated Annealing acceptance criteria\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate  # Cool down the temperature\n\n        return best_solution", "name": "HybridDESA", "description": "Enhanced HybridDESA with differential temperature cooling and adaptive crossover for improved convergence.", "configspace": "", "generation": 25, "fitness": 0.15368672724374358, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.16.", "error": "", "parent_id": "539d9954-0ba3-40eb-970d-a8e7500b9e3d", "metadata": {"aucs": [0.18750458032591932, 0.18640641137420777, 0.17464371771143739, 0.20410221043691013, 0.1980248980445073, 0.2017433155201267, 0.1793910268950354, 0.18399717499552926, 0.18805593256893394, 0.1308922059521176, 0.134053049244089, 0.13429321442330422, 0.13264562282177517, 0.14151702304180414, 0.1369121348655643, 0.13817987607570847, 0.14488746319524393, 0.1430700953998203, 0.06870357599984223, 0.059051800316132, 0.05901117083500562, 0.06655230669552925, 0.06424037844474861, 0.05873950105864334, 0.06088284065500538, 0.06101592928901556, 0.061181409255593455, 0.05037859269309608, 0.05522162480688275, 0.06021754096445142, 0.061412421828727526, 0.056017898703259794, 0.056734478032471114, 0.04958675610822816, 0.07357287541035262, 0.05176447022621833, 0.9410423272536779, 0.9291287053148716, 0.908675991977274, 0.8946068129361576, 0.9039768124827403, 0.9467340565867365, 0.7829213039576046, 0.872377165698714, 0.8994074494075321, 0.12115189790078762, 0.11268912261579533, 0.10836045435325814, 0.0991141484515512, 0.1026306026822873, 0.11410829818273249, 0.1252254283371772, 0.13341483850939473, 0.11401966752547199, 0.14727693538423914, 0.1521235218184911, 0.15060922162947987, 0.14922873917208834, 0.17461489361478055, 0.15472090501976543, 0.16870532906095526, 0.16008023823452344, 0.15664464072748274, 0.11101903084958065, 0.1090843540876042, 0.11486087864662953, 0.11253841785677599, 0.12878177805125302, 0.11113271561375748, 0.13748748678542688, 0.13185383848691867, 0.10796621917157956, 0.1245557200854277, 0.07233883724930257, 0.09954231581898876, 0.10774631180889904, 0.11268966438649475, 0.10370995562880636, 0.10706114058915683, 0.09158448310528788, 0.1030428799430485, 0.05904833523789843, 0.07141650256917276, 0.07204177056337979, 0.07730597654319371, 0.0738371247113151, 0.06952993262187723, 0.06762705163027638, 0.07620198827710756, 0.062249781531964254, 0.15803700609688642, 0.1456819397118475, 0.14954728730759748, 0.11253369890809606, 0.12040034327216087, 0.12409746886959605, 0.13382726220479468, 0.145277164866921, 0.14372154203844512, 0.022639570258900843, 0.034202040521864374, 0.029406440346597118, 0.04264419848028933, 0.03652994164950141, 0.0531586482409242, 0.040859425996249366, 0.05098298085416919, 0.05780217809439059, 0.045791677736021996, 0.05681192894800735, 0.057448714100912235, 0.051310281879730635, 0.0532825212989777, 0.056643215396702695, 0.06668854949006309, 0.05280426743203337, 0.056186267885092955, 0.18553304106225388, 0.20475443443500074, 0.20029141720477306, 0.19494997804339032, 0.18525464851440343, 0.20524055060569446, 0.20120211225957385, 0.19571123060495588, 0.17062018401759338, 0.06789540685113749, 0.0624086258143538, 0.06810789230749903, 0.06188935663800876, 0.06280100099130237, 0.06183131200407865, 0.05698451574498009, 0.06442556795880905, 0.05214145194370157, 0.1321329888285191, 0.14114002900990053, 0.14031085477043614, 0.14346925395073562, 0.15309419861215723, 0.14056801405498498, 0.14777753808882788, 0.13770183775404443, 0.13116192670672822, 0.15422465816683184, 0.1636413498549627, 0.18200643146729567, 0.15348467370740726, 0.15265653861872563, 0.1533761388602849, 0.16078123275221645, 0.1756470164798355, 0.16380257544742782, 0.10915767154035916, 0.1259285124040458, 0.11157687883211853, 0.1092900134011412, 0.10899791099022083, 0.11927421264822091, 0.11366265561899414, 0.12586529267553093, 0.10881932375335068, 0.16953087073817064, 0.14421554016410865, 0.15380270552386932, 0.1354208671894256, 0.14389189034213157, 0.14615712945221604, 0.15211659921341014, 0.15579371871530512, 0.15981289816927036, 0.1678641142206836, 0.16991818139998793, 0.17542342449277515, 0.17132775148301083, 0.16545639060350736, 0.16879095317357096, 0.17636701920887832, 0.168399465918742, 0.16566621299026174, 0.1602520301705892, 0.1560715640581125, 0.1707880173950792, 0.19075866401773378, 0.16713930175952796, 0.15677091992776682, 0.15872414114184463, 0.15715848624890405, 0.16457821299885855, 0.15778886927936708, 0.1446800075747562, 0.14824543165496906, 0.14016808367724953, 0.11907722797734277, 0.17027265630941835, 0.19158488365912762, 0.14312082036525897, 0.1486868713157391, 0.18786849082330803, 0.18581310781990845, 0.18188857093062427, 0.19247543938132783, 0.18476755331872863, 0.18270639727766502, 0.1980032028500095, 0.1771811703002999, 0.18078912852912, 0.0498368038087752, 0.0499497436654317, 0.053414262315565786, 0.061460000810223736, 0.050319944703321795, 0.05997326101934908, 0.04757729694639856, 0.051872056318989834, 0.05025618851308211]}, "mutation_prompt": null}
{"id": "9c479906-26e9-48d6-8a87-beab8146d875", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Common heuristic for DE\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.97\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        # Adapt mutation factor based on the proportion of budget used\n        return 0.5 + 0.3 * (1 - evaluations / self.budget)\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        # Adapt crossover rate to increase exploration in early stages\n        return 0.6 + 0.3 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one element is from mutant\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                # Simulated Annealing acceptance criteria\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate  # Cool down the temperature\n\n        return best_solution", "name": "HybridDESA", "description": "Enhanced HybridDESA with differential temperature cooling and adaptive crossover for improved convergence.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "664e0db9-c445-410c-9b77-eaa9f66fb565", "metadata": {"aucs": [0.18750458032591932, 0.18640641137420777, 0.17464371771143739, 0.20410221043691013, 0.1980248980445073, 0.2017433155201267, 0.1793910268950354, 0.18399717499552926, 0.18805593256893394, 0.1308922059521176, 0.134053049244089, 0.13429321442330422, 0.13264562282177517, 0.14151702304180414, 0.1369121348655643, 0.13817987607570847, 0.14488746319524393, 0.1430700953998203, 0.06870357599984223, 0.059051800316132, 0.05901117083500562, 0.06655230669552925, 0.06424037844474861, 0.05873950105864334, 0.06088284065500538, 0.06101592928901556, 0.061181409255593455, 0.05037859269309608, 0.05522162480688275, 0.06021754096445142, 0.061412421828727526, 0.056017898703259794, 0.056734478032471114, 0.04958675610822816, 0.07357287541035262, 0.05176447022621833, 0.9410423272536779, 0.9291287053148716, 0.908675991977274, 0.8946068129361576, 0.9039768124827403, 0.9467340565867365, 0.7829213039576046, 0.872377165698714, 0.8994074494075321, 0.12115189790078762, 0.11268912261579533, 0.10836045435325814, 0.0991141484515512, 0.1026306026822873, 0.11410829818273249, 0.1252254283371772, 0.13341483850939473, 0.11401966752547199, 0.14727693538423914, 0.1521235218184911, 0.15060922162947987, 0.14922873917208834, 0.17461489361478055, 0.15472090501976543, 0.16870532906095526, 0.16008023823452344, 0.15664464072748274, 0.11101903084958065, 0.1090843540876042, 0.11486087864662953, 0.11253841785677599, 0.12878177805125302, 0.11113271561375748, 0.13748748678542688, 0.13185383848691867, 0.10796621917157956, 0.1245557200854277, 0.07233883724930257, 0.09954231581898876, 0.10774631180889904, 0.11268966438649475, 0.10370995562880636, 0.10706114058915683, 0.09158448310528788, 0.1030428799430485, 0.05904833523789843, 0.07141650256917276, 0.07204177056337979, 0.07730597654319371, 0.0738371247113151, 0.06952993262187723, 0.06762705163027638, 0.07620198827710756, 0.062249781531964254, 0.15803700609688642, 0.1456819397118475, 0.14954728730759748, 0.11253369890809606, 0.12040034327216087, 0.12409746886959605, 0.13382726220479468, 0.145277164866921, 0.14372154203844512, 0.022639570258900843, 0.034202040521864374, 0.029406440346597118, 0.04264419848028933, 0.03652994164950141, 0.0531586482409242, 0.040859425996249366, 0.05098298085416919, 0.05780217809439059, 0.045791677736021996, 0.05681192894800735, 0.057448714100912235, 0.051310281879730635, 0.0532825212989777, 0.056643215396702695, 0.06668854949006309, 0.05280426743203337, 0.056186267885092955, 0.18553304106225388, 0.20475443443500074, 0.20029141720477306, 0.19494997804339032, 0.18525464851440343, 0.20524055060569446, 0.20120211225957385, 0.19571123060495588, 0.17062018401759338, 0.06789540685113749, 0.0624086258143538, 0.06810789230749903, 0.06188935663800876, 0.06280100099130237, 0.06183131200407865, 0.05698451574498009, 0.06442556795880905, 0.05214145194370157, 0.1321329888285191, 0.14114002900990053, 0.14031085477043614, 0.14346925395073562, 0.15309419861215723, 0.14056801405498498, 0.14777753808882788, 0.13770183775404443, 0.13116192670672822, 0.15422465816683184, 0.1636413498549627, 0.18200643146729567, 0.15348467370740726, 0.15265653861872563, 0.1533761388602849, 0.16078123275221645, 0.1756470164798355, 0.16380257544742782, 0.10915767154035916, 0.1259285124040458, 0.11157687883211853, 0.1092900134011412, 0.10899791099022083, 0.11927421264822091, 0.11366265561899414, 0.12586529267553093, 0.10881932375335068, 0.16953087073817064, 0.14421554016410865, 0.15380270552386932, 0.1354208671894256, 0.14389189034213157, 0.14615712945221604, 0.15211659921341014, 0.15579371871530512, 0.15981289816927036, 0.1678641142206836, 0.16991818139998793, 0.17542342449277515, 0.17132775148301083, 0.16545639060350736, 0.16879095317357096, 0.17636701920887832, 0.168399465918742, 0.16566621299026174, 0.1602520301705892, 0.1560715640581125, 0.1707880173950792, 0.19075866401773378, 0.16713930175952796, 0.15677091992776682, 0.15872414114184463, 0.15715848624890405, 0.16457821299885855, 0.15778886927936708, 0.1446800075747562, 0.14824543165496906, 0.14016808367724953, 0.11907722797734277, 0.17027265630941835, 0.19158488365912762, 0.14312082036525897, 0.1486868713157391, 0.18786849082330803, 0.18581310781990845, 0.18188857093062427, 0.19247543938132783, 0.18476755331872863, 0.18270639727766502, 0.1980032028500095, 0.1771811703002999, 0.18078912852912, 0.0498368038087752, 0.0499497436654317, 0.053414262315565786, 0.061460000810223736, 0.050319944703321795, 0.05997326101934908, 0.04757729694639856, 0.051872056318989834, 0.05025618851308211]}, "mutation_prompt": null}
{"id": "5df21ba2-e97a-4b63-963b-2684ba3765ed", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim  # Common heuristic for DE\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.97\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        # Adapt mutation factor based on the proportion of budget used\n        return 0.5 + 0.3 * (1 - evaluations / self.budget)\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        # Adapt crossover rate to increase exploration in early stages\n        return 0.6 + 0.3 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True  # Ensure at least one element is from mutant\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        # Adapt population size based on progress\n        return max(4, int(self.initial_population_size * (1 - evaluations / self.budget)**0.5))\n\n    def _stochastic_ranking(self, fitness):\n        # Rank population using stochastic ranking\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                # Simulated Annealing acceptance criteria\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate  # Cool down the temperature\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = population[ranked_indices[:self.population_size]]\n            fitness = fitness[ranked_indices[:self.population_size]]\n\n        return best_solution", "name": "HybridDESA", "description": "Enhanced HybridDESA with adaptive population size scaling and stochastic ranking for improved convergence.", "configspace": "", "generation": 27, "fitness": 0.16222030766706902, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.12.", "error": "", "parent_id": "664e0db9-c445-410c-9b77-eaa9f66fb565", "metadata": {"aucs": [0.22808518573619685, 0.19379017117596908, 0.22631764626423534, 0.21687563863306236, 0.2132317190180898, 0.21212218389851578, 0.21761999052270287, 0.2086938741426403, 0.22268560020070904, 0.1658280043536392, 0.1687287421668341, 0.17175716974918342, 0.1644531835112799, 0.1726963034153869, 0.17432317301412836, 0.1777685420125461, 0.17615307079965836, 0.17160507148506798, 0.08655237307412444, 0.06846138728271167, 0.07617157224936344, 0.08026211782262871, 0.0708646194994692, 0.08034705494757977, 0.08201224138607754, 0.06547923684219348, 0.06950629265488295, 0.06633337329765965, 0.062070752460107514, 0.06535609390826014, 0.0635149846678682, 0.07394560823269714, 0.10609504240962653, 0.06280109464441141, 0.06739427143916077, 0.07091409112023661, 0.7142813446032894, 0.5946276369032477, 0.6080166215229208, 0.7237928090628591, 0.4152353608388114, 0.7046490067686016, 0.9599361076372843, 0.7063772815504279, 0.7795064275888877, 0.14125984491390742, 0.12955717074427398, 0.144105449426831, 0.12964098618278586, 0.12127863353060453, 0.12421477642182521, 0.1514777745850472, 0.14526491496298422, 0.15070638767695343, 0.18389879482639793, 0.19641421092445444, 0.22150814596595547, 0.18501964936032134, 0.17648634213260084, 0.17397685967748222, 0.2303667770468555, 0.2551914151350415, 0.18456122206735004, 0.1270235529121776, 0.13614665422102423, 0.1306962041995393, 0.12077124984406218, 0.12147684393547864, 0.12718237211596228, 0.12310071184320281, 0.1202928085776015, 0.12842561484889592, 0.12232641530580746, 0.10372358091112432, 0.13691819855733633, 0.12706706953071933, 0.12234357757329617, 0.11598807321729188, 0.1255749732967315, 0.10775728446665256, 0.12070428828708901, 0.1205804524412355, 0.12691284011934478, 0.104268710416626, 0.12226497410324844, 0.09468165607131107, 0.12927271957684694, 0.11623735765922005, 0.09723174441989757, 0.13370427347240943, 0.17881785310638076, 0.1817504486754029, 0.1510746725387151, 0.16889427809027546, 0.16966197824234364, 0.17323704314024313, 0.161686769082227, 0.1613650182073637, 0.15836667792230297, 0.057079883883798366, 0.07177605081924499, 0.05905062290560925, 0.09487431805738211, 0.08804984721233866, 0.07800499716843357, 0.059340661000634065, 0.08839440394613562, 0.07215046994111562, 0.08201153801860306, 0.09191270523984807, 0.09966091491301432, 0.09388796837988633, 0.09157460500737236, 0.08230458169746302, 0.0908405328601144, 0.09380172856350633, 0.09773584932670087, 0.2248458167497246, 0.21257165392853927, 0.20764879964634542, 0.2240166074673713, 0.21178585574599906, 0.2191638245361761, 0.22041466135596244, 0.20742871356487924, 0.21999644198835344, 0.06598521912585764, 0.08180753281395792, 0.08790901527217598, 0.06083508624203515, 0.07048797376398508, 0.06824797080894063, 0.07416718286610668, 0.06519384095669978, 0.07226874648220816, 0.12669034349258623, 0.14209800062787048, 0.1388317459713746, 0.13088053306054204, 0.1454724247738748, 0.1339152325468158, 0.12514604470854485, 0.13503780394867404, 0.1336517488439899, 0.17208968525715518, 0.18136256376847093, 0.18737372898585491, 0.1795707898582659, 0.16586215785759972, 0.18072606544398184, 0.18065719912631306, 0.197547918656638, 0.18012848995963682, 0.13681742392794838, 0.14168798645924818, 0.1445722270209575, 0.13879713405290328, 0.1302310738097252, 0.1336535229808622, 0.1661643667649889, 0.15064907497464752, 0.14722422160835846, 0.16537745598990572, 0.1463199755015665, 0.17257741279203787, 0.14873372626502745, 0.15365975546646637, 0.16073312614602286, 0.1580210285305531, 0.15632239990891106, 0.15330638712425648, 0.17098055007093205, 0.17149726713249092, 0.18382400613523442, 0.1803556593170047, 0.1683364895585875, 0.1724030483367175, 0.19522641066402158, 0.1681174341943521, 0.1768186437492827, 0.14929657189897005, 0.14007873707801577, 0.1596221330705463, 0.15917297643279305, 0.1501231356125985, 0.15538681785109798, 0.22588330618014985, 0.14335081016027884, 0.16276011479413888, 0.14013326416071037, 0.15308203061015935, 0.1390221104360999, 0.11958367809306181, 0.1809904564589786, 0.119894914398607, 0.1726968102170704, 0.15611035139095453, 0.16274360756041184, 0.16633886052433222, 0.19853544498165854, 0.16671827616861978, 0.1887202171230249, 0.23236444710158333, 0.18631659158720637, 0.18940439668490616, 0.18621187765866887, 0.18170473030645484, 0.054803879071798844, 0.05244028716074978, 0.0571457337817719, 0.05306790664800498, 0.05617996119125579, 0.06660981026309165, 0.06346604150603219, 0.056379479198288895, 0.0568714100708021]}, "mutation_prompt": null}
{"id": "4f6ec361-dc60-4268-a841-0a76fb0226a8", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim  # Common heuristic for DE\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.97\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.3 * (1 - evaluations / self.budget)\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.3 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (1 - evaluations / self.budget)**0.5))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            # Local search enhancement\n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.1, self.dim), \n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = population[ranked_indices[:self.population_size]]\n            fitness = fitness[ranked_indices[:self.population_size]]\n\n        return best_solution", "name": "HybridDESA", "description": "Enhanced HybridDESA with adaptive local search and population diversity maintenance for improved exploration.", "configspace": "", "generation": 28, "fitness": 0.16384084113493458, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.13.", "error": "", "parent_id": "5df21ba2-e97a-4b63-963b-2684ba3765ed", "metadata": {"aucs": [0.22168137202904403, 0.1945220151505862, 0.20871502741270143, 0.21428354594195775, 0.2122378304737953, 0.2179641812167682, 0.20480069787041744, 0.21450485484976922, 0.20869934794437517, 0.16886192132948186, 0.16577694236617613, 0.16612374577555789, 0.1628113712866116, 0.16705513555373996, 0.16321010466386088, 0.16472128240023864, 0.1795872561544969, 0.1701952322878929, 0.08704547736322132, 0.07477008441520028, 0.07030435882474628, 0.06777346392694672, 0.07619098233578281, 0.07914717876181365, 0.07554871675421948, 0.07788530699867113, 0.07667040830108895, 0.06568409452498747, 0.059154136986644845, 0.05885944736284543, 0.07274182699759191, 0.055689194820865096, 0.05553314066583448, 0.06798780110389746, 0.06172518979078434, 0.07698063450361681, 0.7523994373442551, 0.91568771295195, 0.535856305842577, 0.7365528593782021, 0.8649542348407342, 0.5869974731842214, 0.7733493917853803, 0.8055820190254931, 0.642085475528172, 0.13905020632413512, 0.13409465606760218, 0.13641696110716073, 0.13431146329457444, 0.12691586773282548, 0.12859449679366952, 0.14991026008710617, 0.13815028403066631, 0.15270884854788835, 0.18860294160972635, 0.2021665953902455, 0.23808109571236946, 0.1944810596933354, 0.19792380423426104, 0.1777406065490068, 0.2256286112071253, 0.18560360006210475, 0.1901442205979843, 0.1248366049171562, 0.12711184134010833, 0.13533213161391544, 0.11364409367227613, 0.1228147795127923, 0.13894900285681921, 0.12305060736728823, 0.12275948034704431, 0.12216686692017398, 0.13257308518679345, 0.10288695268911019, 0.1406788662418228, 0.15847797553451204, 0.1380253507061321, 0.12332779962369189, 0.11822531371059486, 0.11454787982388903, 0.1290705827724531, 0.11352079036092333, 0.11982659644412286, 0.11380136579459199, 0.11305875272900268, 0.12441768392505004, 0.102019214007122, 0.10823771498324108, 0.1208443501088936, 0.1146579227689557, 0.15309977866054303, 0.16988785079656554, 0.15235685968831203, 0.13890642841867595, 0.17429601005715412, 0.1416837534293467, 0.16764501217469552, 0.15307670693321285, 0.18223555041423656, 0.04238098794859724, 0.049610530468772396, 0.049458779918428064, 0.08287397336453162, 0.09513415042574747, 0.07497148724111191, 0.08788771569198439, 0.08500472092176004, 0.06024165746026533, 0.09263993570356122, 0.09287536981442157, 0.09147819846172056, 0.0892122809023389, 0.08498202239557684, 0.09221477785750154, 0.09616920307137355, 0.08207212102204908, 0.09724031908242581, 0.22278676980958312, 0.22825573413996947, 0.2123355972462485, 0.21534932677597785, 0.22554329888414193, 0.205275149560446, 0.21431467240068458, 0.20527041731493567, 0.2018614716280085, 0.07969057661138645, 0.0679531753166922, 0.07167988901383304, 0.059714300719211355, 0.06539527628566388, 0.06560289450657508, 0.06278293137759461, 0.056944854597550165, 0.06424791180319389, 0.1437362786651606, 0.1476810646036011, 0.16708762182317094, 0.16932287366749332, 0.14819164106520988, 0.14394077485091894, 0.13450909992262916, 0.1722320802645232, 0.17148402775993965, 0.17238492742343392, 0.17547674232499355, 0.1916139240555732, 0.17662505227749792, 0.175571321501788, 0.16476698823323155, 0.17334583994206898, 0.19539300293079664, 0.17507142981206758, 0.1454039868561604, 0.14466733785661434, 0.14047270476913887, 0.14175961765246925, 0.13680822089807776, 0.13320790456915033, 0.14594201481624425, 0.14417319962163255, 0.14496615093462295, 0.1568179901454425, 0.15443777102493228, 0.1543626785119, 0.1481348197693575, 0.15442448207922843, 0.1629524633026722, 0.1503953175117424, 0.15103132307455958, 0.17665470956624596, 0.18656256933916548, 0.18576185099862974, 0.16691012119899118, 0.18094297496511713, 0.17569375708455082, 0.18450652975378057, 0.17814377560752037, 0.17102659032626344, 0.1860001164602555, 0.14266808568623268, 0.15465804420089757, 0.15050941789671746, 0.23382885135704456, 0.15238131711048042, 0.13172871090336924, 0.14554674895396746, 0.19919572258114726, 0.15574415810971132, 0.14436515008990025, 0.14900508670539225, 0.14209523925606315, 0.14346317887509763, 0.1663439195905101, 0.13850047046907454, 0.1407632670533605, 0.16638434713578643, 0.15516045173480975, 0.1754023015063203, 0.2059798968583254, 0.18708927660899033, 0.21519804020914957, 0.1959198331131684, 0.18826289962573473, 0.19168038894204176, 0.18226787866694216, 0.2008325511521869, 0.0512024655363299, 0.04997288130439792, 0.05587953901118414, 0.052943304008972736, 0.05763802423314757, 0.05589026947271536, 0.05877117136869925, 0.057074363981023946, 0.05174092767433136]}, "mutation_prompt": null}
{"id": "318f2514-2355-4782-b7fd-d8c68bbbefae", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim  # Common heuristic for DE\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.98  # Slightly adjusted cooling rate\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.3 * (1 - evaluations / self.budget)\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.3 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (1 - evaluations / self.budget)**0.5))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            # Local search enhancement\n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.1, self.dim), \n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            culling_threshold = int(self.population_size * 0.8)  # Strategic culling\n            population = population[ranked_indices[:culling_threshold]]\n            fitness = fitness[ranked_indices[:culling_threshold]]\n\n        return best_solution", "name": "HybridDESA", "description": "Enhanced HybridDESA with dynamic temperature cooling and strategic population culling for robust exploration.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 39').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 39')", "parent_id": "4f6ec361-dc60-4268-a841-0a76fb0226a8", "metadata": {}, "mutation_prompt": null}
{"id": "d4095fb4-1857-4dbe-8509-2868c6b13725", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim  # Common heuristic for DE\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.97\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.3 * (1 - evaluations / self.budget)\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.3 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (1 - evaluations / self.budget)**0.5))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            # Local search enhancement\n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.1, self.dim), \n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = population[ranked_indices[:self.population_size]]\n            fitness = fitness[ranked_indices[:self.population_size]]\n\n        return best_solution", "name": "HybridDESA", "description": "Enhanced HybridDESA with adaptive local search and population diversity maintenance for improved exploration.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4f6ec361-dc60-4268-a841-0a76fb0226a8", "metadata": {"aucs": [0.22168137202904403, 0.1945220151505862, 0.20871502741270143, 0.21428354594195775, 0.2122378304737953, 0.2179641812167682, 0.20480069787041744, 0.21450485484976922, 0.20869934794437517, 0.16886192132948186, 0.16577694236617613, 0.16612374577555789, 0.1628113712866116, 0.16705513555373996, 0.16321010466386088, 0.16472128240023864, 0.1795872561544969, 0.1701952322878929, 0.08704547736322132, 0.07477008441520028, 0.07030435882474628, 0.06777346392694672, 0.07619098233578281, 0.07914717876181365, 0.07554871675421948, 0.07788530699867113, 0.07667040830108895, 0.06568409452498747, 0.059154136986644845, 0.05885944736284543, 0.07274182699759191, 0.055689194820865096, 0.05553314066583448, 0.06798780110389746, 0.06172518979078434, 0.07698063450361681, 0.7523994373442551, 0.91568771295195, 0.535856305842577, 0.7365528593782021, 0.8649542348407342, 0.5869974731842214, 0.7733493917853803, 0.8055820190254931, 0.642085475528172, 0.13905020632413512, 0.13409465606760218, 0.13641696110716073, 0.13431146329457444, 0.12691586773282548, 0.12859449679366952, 0.14991026008710617, 0.13815028403066631, 0.15270884854788835, 0.18860294160972635, 0.2021665953902455, 0.23808109571236946, 0.1944810596933354, 0.19792380423426104, 0.1777406065490068, 0.2256286112071253, 0.18560360006210475, 0.1901442205979843, 0.1248366049171562, 0.12711184134010833, 0.13533213161391544, 0.11364409367227613, 0.1228147795127923, 0.13894900285681921, 0.12305060736728823, 0.12275948034704431, 0.12216686692017398, 0.13257308518679345, 0.10288695268911019, 0.1406788662418228, 0.15847797553451204, 0.1380253507061321, 0.12332779962369189, 0.11822531371059486, 0.11454787982388903, 0.1290705827724531, 0.11352079036092333, 0.11982659644412286, 0.11380136579459199, 0.11305875272900268, 0.12441768392505004, 0.102019214007122, 0.10823771498324108, 0.1208443501088936, 0.1146579227689557, 0.15309977866054303, 0.16988785079656554, 0.15235685968831203, 0.13890642841867595, 0.17429601005715412, 0.1416837534293467, 0.16764501217469552, 0.15307670693321285, 0.18223555041423656, 0.04238098794859724, 0.049610530468772396, 0.049458779918428064, 0.08287397336453162, 0.09513415042574747, 0.07497148724111191, 0.08788771569198439, 0.08500472092176004, 0.06024165746026533, 0.09263993570356122, 0.09287536981442157, 0.09147819846172056, 0.0892122809023389, 0.08498202239557684, 0.09221477785750154, 0.09616920307137355, 0.08207212102204908, 0.09724031908242581, 0.22278676980958312, 0.22825573413996947, 0.2123355972462485, 0.21534932677597785, 0.22554329888414193, 0.205275149560446, 0.21431467240068458, 0.20527041731493567, 0.2018614716280085, 0.07969057661138645, 0.0679531753166922, 0.07167988901383304, 0.059714300719211355, 0.06539527628566388, 0.06560289450657508, 0.06278293137759461, 0.056944854597550165, 0.06424791180319389, 0.1437362786651606, 0.1476810646036011, 0.16708762182317094, 0.16932287366749332, 0.14819164106520988, 0.14394077485091894, 0.13450909992262916, 0.1722320802645232, 0.17148402775993965, 0.17238492742343392, 0.17547674232499355, 0.1916139240555732, 0.17662505227749792, 0.175571321501788, 0.16476698823323155, 0.17334583994206898, 0.19539300293079664, 0.17507142981206758, 0.1454039868561604, 0.14466733785661434, 0.14047270476913887, 0.14175961765246925, 0.13680822089807776, 0.13320790456915033, 0.14594201481624425, 0.14417319962163255, 0.14496615093462295, 0.1568179901454425, 0.15443777102493228, 0.1543626785119, 0.1481348197693575, 0.15442448207922843, 0.1629524633026722, 0.1503953175117424, 0.15103132307455958, 0.17665470956624596, 0.18656256933916548, 0.18576185099862974, 0.16691012119899118, 0.18094297496511713, 0.17569375708455082, 0.18450652975378057, 0.17814377560752037, 0.17102659032626344, 0.1860001164602555, 0.14266808568623268, 0.15465804420089757, 0.15050941789671746, 0.23382885135704456, 0.15238131711048042, 0.13172871090336924, 0.14554674895396746, 0.19919572258114726, 0.15574415810971132, 0.14436515008990025, 0.14900508670539225, 0.14209523925606315, 0.14346317887509763, 0.1663439195905101, 0.13850047046907454, 0.1407632670533605, 0.16638434713578643, 0.15516045173480975, 0.1754023015063203, 0.2059798968583254, 0.18708927660899033, 0.21519804020914957, 0.1959198331131684, 0.18826289962573473, 0.19168038894204176, 0.18226787866694216, 0.2008325511521869, 0.0512024655363299, 0.04997288130439792, 0.05587953901118414, 0.052943304008972736, 0.05763802423314757, 0.05589026947271536, 0.05877117136869925, 0.057074363981023946, 0.05174092767433136]}, "mutation_prompt": null}
{"id": "6b736916-602b-4af8-b3eb-e246053255b1", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim  # Common heuristic for DE\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.97\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.3 * (1 - evaluations / self.budget)\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.3 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (1 - evaluations / self.budget)**0.5))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            # Local search enhancement\n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.1, self.dim), \n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = population[ranked_indices[:self.population_size]]\n            fitness = fitness[ranked_indices[:self.population_size]]\n\n        return best_solution", "name": "HybridDESA", "description": "Enhanced HybridDESA with adaptive local search and population diversity maintenance for improved exploration.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4f6ec361-dc60-4268-a841-0a76fb0226a8", "metadata": {"aucs": [0.22168137202904403, 0.1945220151505862, 0.20871502741270143, 0.21428354594195775, 0.2122378304737953, 0.2179641812167682, 0.20480069787041744, 0.21450485484976922, 0.20869934794437517, 0.16886192132948186, 0.16577694236617613, 0.16612374577555789, 0.1628113712866116, 0.16705513555373996, 0.16321010466386088, 0.16472128240023864, 0.1795872561544969, 0.1701952322878929, 0.08704547736322132, 0.07477008441520028, 0.07030435882474628, 0.06777346392694672, 0.07619098233578281, 0.07914717876181365, 0.07554871675421948, 0.07788530699867113, 0.07667040830108895, 0.06568409452498747, 0.059154136986644845, 0.05885944736284543, 0.07274182699759191, 0.055689194820865096, 0.05553314066583448, 0.06798780110389746, 0.06172518979078434, 0.07698063450361681, 0.7523994373442551, 0.91568771295195, 0.535856305842577, 0.7365528593782021, 0.8649542348407342, 0.5869974731842214, 0.7733493917853803, 0.8055820190254931, 0.642085475528172, 0.13905020632413512, 0.13409465606760218, 0.13641696110716073, 0.13431146329457444, 0.12691586773282548, 0.12859449679366952, 0.14991026008710617, 0.13815028403066631, 0.15270884854788835, 0.18860294160972635, 0.2021665953902455, 0.23808109571236946, 0.1944810596933354, 0.19792380423426104, 0.1777406065490068, 0.2256286112071253, 0.18560360006210475, 0.1901442205979843, 0.1248366049171562, 0.12711184134010833, 0.13533213161391544, 0.11364409367227613, 0.1228147795127923, 0.13894900285681921, 0.12305060736728823, 0.12275948034704431, 0.12216686692017398, 0.13257308518679345, 0.10288695268911019, 0.1406788662418228, 0.15847797553451204, 0.1380253507061321, 0.12332779962369189, 0.11822531371059486, 0.11454787982388903, 0.1290705827724531, 0.11352079036092333, 0.11982659644412286, 0.11380136579459199, 0.11305875272900268, 0.12441768392505004, 0.102019214007122, 0.10823771498324108, 0.1208443501088936, 0.1146579227689557, 0.15309977866054303, 0.16988785079656554, 0.15235685968831203, 0.13890642841867595, 0.17429601005715412, 0.1416837534293467, 0.16764501217469552, 0.15307670693321285, 0.18223555041423656, 0.04238098794859724, 0.049610530468772396, 0.049458779918428064, 0.08287397336453162, 0.09513415042574747, 0.07497148724111191, 0.08788771569198439, 0.08500472092176004, 0.06024165746026533, 0.09263993570356122, 0.09287536981442157, 0.09147819846172056, 0.0892122809023389, 0.08498202239557684, 0.09221477785750154, 0.09616920307137355, 0.08207212102204908, 0.09724031908242581, 0.22278676980958312, 0.22825573413996947, 0.2123355972462485, 0.21534932677597785, 0.22554329888414193, 0.205275149560446, 0.21431467240068458, 0.20527041731493567, 0.2018614716280085, 0.07969057661138645, 0.0679531753166922, 0.07167988901383304, 0.059714300719211355, 0.06539527628566388, 0.06560289450657508, 0.06278293137759461, 0.056944854597550165, 0.06424791180319389, 0.1437362786651606, 0.1476810646036011, 0.16708762182317094, 0.16932287366749332, 0.14819164106520988, 0.14394077485091894, 0.13450909992262916, 0.1722320802645232, 0.17148402775993965, 0.17238492742343392, 0.17547674232499355, 0.1916139240555732, 0.17662505227749792, 0.175571321501788, 0.16476698823323155, 0.17334583994206898, 0.19539300293079664, 0.17507142981206758, 0.1454039868561604, 0.14466733785661434, 0.14047270476913887, 0.14175961765246925, 0.13680822089807776, 0.13320790456915033, 0.14594201481624425, 0.14417319962163255, 0.14496615093462295, 0.1568179901454425, 0.15443777102493228, 0.1543626785119, 0.1481348197693575, 0.15442448207922843, 0.1629524633026722, 0.1503953175117424, 0.15103132307455958, 0.17665470956624596, 0.18656256933916548, 0.18576185099862974, 0.16691012119899118, 0.18094297496511713, 0.17569375708455082, 0.18450652975378057, 0.17814377560752037, 0.17102659032626344, 0.1860001164602555, 0.14266808568623268, 0.15465804420089757, 0.15050941789671746, 0.23382885135704456, 0.15238131711048042, 0.13172871090336924, 0.14554674895396746, 0.19919572258114726, 0.15574415810971132, 0.14436515008990025, 0.14900508670539225, 0.14209523925606315, 0.14346317887509763, 0.1663439195905101, 0.13850047046907454, 0.1407632670533605, 0.16638434713578643, 0.15516045173480975, 0.1754023015063203, 0.2059798968583254, 0.18708927660899033, 0.21519804020914957, 0.1959198331131684, 0.18826289962573473, 0.19168038894204176, 0.18226787866694216, 0.2008325511521869, 0.0512024655363299, 0.04997288130439792, 0.05587953901118414, 0.052943304008972736, 0.05763802423314757, 0.05589026947271536, 0.05877117136869925, 0.057074363981023946, 0.05174092767433136]}, "mutation_prompt": null}
{"id": "ec03f85a-c9cc-496d-ba50-0fd786041bab", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim  # Common heuristic for DE\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.97\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.3 * (1 - evaluations / self.budget)\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.3 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (1 - evaluations / self.budget)**0.5))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            # Local search enhancement\n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.1, self.dim), \n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = population[ranked_indices[:self.population_size]]\n            fitness = fitness[ranked_indices[:self.population_size]]\n\n        return best_solution", "name": "HybridDESA", "description": "Enhanced HybridDESA with adaptive local search and population diversity maintenance for improved exploration.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4f6ec361-dc60-4268-a841-0a76fb0226a8", "metadata": {"aucs": [0.22168137202904403, 0.1945220151505862, 0.20871502741270143, 0.21428354594195775, 0.2122378304737953, 0.2179641812167682, 0.20480069787041744, 0.21450485484976922, 0.20869934794437517, 0.16886192132948186, 0.16577694236617613, 0.16612374577555789, 0.1628113712866116, 0.16705513555373996, 0.16321010466386088, 0.16472128240023864, 0.1795872561544969, 0.1701952322878929, 0.08704547736322132, 0.07477008441520028, 0.07030435882474628, 0.06777346392694672, 0.07619098233578281, 0.07914717876181365, 0.07554871675421948, 0.07788530699867113, 0.07667040830108895, 0.06568409452498747, 0.059154136986644845, 0.05885944736284543, 0.07274182699759191, 0.055689194820865096, 0.05553314066583448, 0.06798780110389746, 0.06172518979078434, 0.07698063450361681, 0.7523994373442551, 0.91568771295195, 0.535856305842577, 0.7365528593782021, 0.8649542348407342, 0.5869974731842214, 0.7733493917853803, 0.8055820190254931, 0.642085475528172, 0.13905020632413512, 0.13409465606760218, 0.13641696110716073, 0.13431146329457444, 0.12691586773282548, 0.12859449679366952, 0.14991026008710617, 0.13815028403066631, 0.15270884854788835, 0.18860294160972635, 0.2021665953902455, 0.23808109571236946, 0.1944810596933354, 0.19792380423426104, 0.1777406065490068, 0.2256286112071253, 0.18560360006210475, 0.1901442205979843, 0.1248366049171562, 0.12711184134010833, 0.13533213161391544, 0.11364409367227613, 0.1228147795127923, 0.13894900285681921, 0.12305060736728823, 0.12275948034704431, 0.12216686692017398, 0.13257308518679345, 0.10288695268911019, 0.1406788662418228, 0.15847797553451204, 0.1380253507061321, 0.12332779962369189, 0.11822531371059486, 0.11454787982388903, 0.1290705827724531, 0.11352079036092333, 0.11982659644412286, 0.11380136579459199, 0.11305875272900268, 0.12441768392505004, 0.102019214007122, 0.10823771498324108, 0.1208443501088936, 0.1146579227689557, 0.15309977866054303, 0.16988785079656554, 0.15235685968831203, 0.13890642841867595, 0.17429601005715412, 0.1416837534293467, 0.16764501217469552, 0.15307670693321285, 0.18223555041423656, 0.04238098794859724, 0.049610530468772396, 0.049458779918428064, 0.08287397336453162, 0.09513415042574747, 0.07497148724111191, 0.08788771569198439, 0.08500472092176004, 0.06024165746026533, 0.09263993570356122, 0.09287536981442157, 0.09147819846172056, 0.0892122809023389, 0.08498202239557684, 0.09221477785750154, 0.09616920307137355, 0.08207212102204908, 0.09724031908242581, 0.22278676980958312, 0.22825573413996947, 0.2123355972462485, 0.21534932677597785, 0.22554329888414193, 0.205275149560446, 0.21431467240068458, 0.20527041731493567, 0.2018614716280085, 0.07969057661138645, 0.0679531753166922, 0.07167988901383304, 0.059714300719211355, 0.06539527628566388, 0.06560289450657508, 0.06278293137759461, 0.056944854597550165, 0.06424791180319389, 0.1437362786651606, 0.1476810646036011, 0.16708762182317094, 0.16932287366749332, 0.14819164106520988, 0.14394077485091894, 0.13450909992262916, 0.1722320802645232, 0.17148402775993965, 0.17238492742343392, 0.17547674232499355, 0.1916139240555732, 0.17662505227749792, 0.175571321501788, 0.16476698823323155, 0.17334583994206898, 0.19539300293079664, 0.17507142981206758, 0.1454039868561604, 0.14466733785661434, 0.14047270476913887, 0.14175961765246925, 0.13680822089807776, 0.13320790456915033, 0.14594201481624425, 0.14417319962163255, 0.14496615093462295, 0.1568179901454425, 0.15443777102493228, 0.1543626785119, 0.1481348197693575, 0.15442448207922843, 0.1629524633026722, 0.1503953175117424, 0.15103132307455958, 0.17665470956624596, 0.18656256933916548, 0.18576185099862974, 0.16691012119899118, 0.18094297496511713, 0.17569375708455082, 0.18450652975378057, 0.17814377560752037, 0.17102659032626344, 0.1860001164602555, 0.14266808568623268, 0.15465804420089757, 0.15050941789671746, 0.23382885135704456, 0.15238131711048042, 0.13172871090336924, 0.14554674895396746, 0.19919572258114726, 0.15574415810971132, 0.14436515008990025, 0.14900508670539225, 0.14209523925606315, 0.14346317887509763, 0.1663439195905101, 0.13850047046907454, 0.1407632670533605, 0.16638434713578643, 0.15516045173480975, 0.1754023015063203, 0.2059798968583254, 0.18708927660899033, 0.21519804020914957, 0.1959198331131684, 0.18826289962573473, 0.19168038894204176, 0.18226787866694216, 0.2008325511521869, 0.0512024655363299, 0.04997288130439792, 0.05587953901118414, 0.052943304008972736, 0.05763802423314757, 0.05589026947271536, 0.05877117136869925, 0.057074363981023946, 0.05174092767433136]}, "mutation_prompt": null}
{"id": "e9993b55-7f9d-47bb-8f47-7c45aa759a59", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim  # Common heuristic for DE\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.97\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.3 * (1 - evaluations / self.budget)\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.3 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (1 - evaluations / self.budget)**0.5))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            # Local search enhancement\n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.1, self.dim), \n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = population[ranked_indices[:self.population_size]]\n            fitness = fitness[ranked_indices[:self.population_size]]\n\n        return best_solution", "name": "HybridDESA", "description": "Enhanced HybridDESA with adaptive local search and population diversity maintenance for improved exploration.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4f6ec361-dc60-4268-a841-0a76fb0226a8", "metadata": {"aucs": [0.22168137202904403, 0.1945220151505862, 0.20871502741270143, 0.21428354594195775, 0.2122378304737953, 0.2179641812167682, 0.20480069787041744, 0.21450485484976922, 0.20869934794437517, 0.16886192132948186, 0.16577694236617613, 0.16612374577555789, 0.1628113712866116, 0.16705513555373996, 0.16321010466386088, 0.16472128240023864, 0.1795872561544969, 0.1701952322878929, 0.08704547736322132, 0.07477008441520028, 0.07030435882474628, 0.06777346392694672, 0.07619098233578281, 0.07914717876181365, 0.07554871675421948, 0.07788530699867113, 0.07667040830108895, 0.06568409452498747, 0.059154136986644845, 0.05885944736284543, 0.07274182699759191, 0.055689194820865096, 0.05553314066583448, 0.06798780110389746, 0.06172518979078434, 0.07698063450361681, 0.7523994373442551, 0.91568771295195, 0.535856305842577, 0.7365528593782021, 0.8649542348407342, 0.5869974731842214, 0.7733493917853803, 0.8055820190254931, 0.642085475528172, 0.13905020632413512, 0.13409465606760218, 0.13641696110716073, 0.13431146329457444, 0.12691586773282548, 0.12859449679366952, 0.14991026008710617, 0.13815028403066631, 0.15270884854788835, 0.18860294160972635, 0.2021665953902455, 0.23808109571236946, 0.1944810596933354, 0.19792380423426104, 0.1777406065490068, 0.2256286112071253, 0.18560360006210475, 0.1901442205979843, 0.1248366049171562, 0.12711184134010833, 0.13533213161391544, 0.11364409367227613, 0.1228147795127923, 0.13894900285681921, 0.12305060736728823, 0.12275948034704431, 0.12216686692017398, 0.13257308518679345, 0.10288695268911019, 0.1406788662418228, 0.15847797553451204, 0.1380253507061321, 0.12332779962369189, 0.11822531371059486, 0.11454787982388903, 0.1290705827724531, 0.11352079036092333, 0.11982659644412286, 0.11380136579459199, 0.11305875272900268, 0.12441768392505004, 0.102019214007122, 0.10823771498324108, 0.1208443501088936, 0.1146579227689557, 0.15309977866054303, 0.16988785079656554, 0.15235685968831203, 0.13890642841867595, 0.17429601005715412, 0.1416837534293467, 0.16764501217469552, 0.15307670693321285, 0.18223555041423656, 0.04238098794859724, 0.049610530468772396, 0.049458779918428064, 0.08287397336453162, 0.09513415042574747, 0.07497148724111191, 0.08788771569198439, 0.08500472092176004, 0.06024165746026533, 0.09263993570356122, 0.09287536981442157, 0.09147819846172056, 0.0892122809023389, 0.08498202239557684, 0.09221477785750154, 0.09616920307137355, 0.08207212102204908, 0.09724031908242581, 0.22278676980958312, 0.22825573413996947, 0.2123355972462485, 0.21534932677597785, 0.22554329888414193, 0.205275149560446, 0.21431467240068458, 0.20527041731493567, 0.2018614716280085, 0.07969057661138645, 0.0679531753166922, 0.07167988901383304, 0.059714300719211355, 0.06539527628566388, 0.06560289450657508, 0.06278293137759461, 0.056944854597550165, 0.06424791180319389, 0.1437362786651606, 0.1476810646036011, 0.16708762182317094, 0.16932287366749332, 0.14819164106520988, 0.14394077485091894, 0.13450909992262916, 0.1722320802645232, 0.17148402775993965, 0.17238492742343392, 0.17547674232499355, 0.1916139240555732, 0.17662505227749792, 0.175571321501788, 0.16476698823323155, 0.17334583994206898, 0.19539300293079664, 0.17507142981206758, 0.1454039868561604, 0.14466733785661434, 0.14047270476913887, 0.14175961765246925, 0.13680822089807776, 0.13320790456915033, 0.14594201481624425, 0.14417319962163255, 0.14496615093462295, 0.1568179901454425, 0.15443777102493228, 0.1543626785119, 0.1481348197693575, 0.15442448207922843, 0.1629524633026722, 0.1503953175117424, 0.15103132307455958, 0.17665470956624596, 0.18656256933916548, 0.18576185099862974, 0.16691012119899118, 0.18094297496511713, 0.17569375708455082, 0.18450652975378057, 0.17814377560752037, 0.17102659032626344, 0.1860001164602555, 0.14266808568623268, 0.15465804420089757, 0.15050941789671746, 0.23382885135704456, 0.15238131711048042, 0.13172871090336924, 0.14554674895396746, 0.19919572258114726, 0.15574415810971132, 0.14436515008990025, 0.14900508670539225, 0.14209523925606315, 0.14346317887509763, 0.1663439195905101, 0.13850047046907454, 0.1407632670533605, 0.16638434713578643, 0.15516045173480975, 0.1754023015063203, 0.2059798968583254, 0.18708927660899033, 0.21519804020914957, 0.1959198331131684, 0.18826289962573473, 0.19168038894204176, 0.18226787866694216, 0.2008325511521869, 0.0512024655363299, 0.04997288130439792, 0.05587953901118414, 0.052943304008972736, 0.05763802423314757, 0.05589026947271536, 0.05877117136869925, 0.057074363981023946, 0.05174092767433136]}, "mutation_prompt": null}
{"id": "8f563f80-dc38-48de-aed3-943ac856936f", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim  # Common heuristic for DE\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.97\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.3 * (1 - evaluations / self.budget)\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.3 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (1 - evaluations / self.budget)**0.5))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            # Local search enhancement\n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.1, self.dim), \n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = population[ranked_indices[:self.population_size]]\n            fitness = fitness[ranked_indices[:self.population_size]]\n\n        return best_solution", "name": "HybridDESA", "description": "Enhanced HybridDESA with adaptive local search and population diversity maintenance for improved exploration.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4f6ec361-dc60-4268-a841-0a76fb0226a8", "metadata": {"aucs": [0.22168137202904403, 0.1945220151505862, 0.20871502741270143, 0.21428354594195775, 0.2122378304737953, 0.2179641812167682, 0.20480069787041744, 0.21450485484976922, 0.20869934794437517, 0.16886192132948186, 0.16577694236617613, 0.16612374577555789, 0.1628113712866116, 0.16705513555373996, 0.16321010466386088, 0.16472128240023864, 0.1795872561544969, 0.1701952322878929, 0.08704547736322132, 0.07477008441520028, 0.07030435882474628, 0.06777346392694672, 0.07619098233578281, 0.07914717876181365, 0.07554871675421948, 0.07788530699867113, 0.07667040830108895, 0.06568409452498747, 0.059154136986644845, 0.05885944736284543, 0.07274182699759191, 0.055689194820865096, 0.05553314066583448, 0.06798780110389746, 0.06172518979078434, 0.07698063450361681, 0.7523994373442551, 0.91568771295195, 0.535856305842577, 0.7365528593782021, 0.8649542348407342, 0.5869974731842214, 0.7733493917853803, 0.8055820190254931, 0.642085475528172, 0.13905020632413512, 0.13409465606760218, 0.13641696110716073, 0.13431146329457444, 0.12691586773282548, 0.12859449679366952, 0.14991026008710617, 0.13815028403066631, 0.15270884854788835, 0.18860294160972635, 0.2021665953902455, 0.23808109571236946, 0.1944810596933354, 0.19792380423426104, 0.1777406065490068, 0.2256286112071253, 0.18560360006210475, 0.1901442205979843, 0.1248366049171562, 0.12711184134010833, 0.13533213161391544, 0.11364409367227613, 0.1228147795127923, 0.13894900285681921, 0.12305060736728823, 0.12275948034704431, 0.12216686692017398, 0.13257308518679345, 0.10288695268911019, 0.1406788662418228, 0.15847797553451204, 0.1380253507061321, 0.12332779962369189, 0.11822531371059486, 0.11454787982388903, 0.1290705827724531, 0.11352079036092333, 0.11982659644412286, 0.11380136579459199, 0.11305875272900268, 0.12441768392505004, 0.102019214007122, 0.10823771498324108, 0.1208443501088936, 0.1146579227689557, 0.15309977866054303, 0.16988785079656554, 0.15235685968831203, 0.13890642841867595, 0.17429601005715412, 0.1416837534293467, 0.16764501217469552, 0.15307670693321285, 0.18223555041423656, 0.04238098794859724, 0.049610530468772396, 0.049458779918428064, 0.08287397336453162, 0.09513415042574747, 0.07497148724111191, 0.08788771569198439, 0.08500472092176004, 0.06024165746026533, 0.09263993570356122, 0.09287536981442157, 0.09147819846172056, 0.0892122809023389, 0.08498202239557684, 0.09221477785750154, 0.09616920307137355, 0.08207212102204908, 0.09724031908242581, 0.22278676980958312, 0.22825573413996947, 0.2123355972462485, 0.21534932677597785, 0.22554329888414193, 0.205275149560446, 0.21431467240068458, 0.20527041731493567, 0.2018614716280085, 0.07969057661138645, 0.0679531753166922, 0.07167988901383304, 0.059714300719211355, 0.06539527628566388, 0.06560289450657508, 0.06278293137759461, 0.056944854597550165, 0.06424791180319389, 0.1437362786651606, 0.1476810646036011, 0.16708762182317094, 0.16932287366749332, 0.14819164106520988, 0.14394077485091894, 0.13450909992262916, 0.1722320802645232, 0.17148402775993965, 0.17238492742343392, 0.17547674232499355, 0.1916139240555732, 0.17662505227749792, 0.175571321501788, 0.16476698823323155, 0.17334583994206898, 0.19539300293079664, 0.17507142981206758, 0.1454039868561604, 0.14466733785661434, 0.14047270476913887, 0.14175961765246925, 0.13680822089807776, 0.13320790456915033, 0.14594201481624425, 0.14417319962163255, 0.14496615093462295, 0.1568179901454425, 0.15443777102493228, 0.1543626785119, 0.1481348197693575, 0.15442448207922843, 0.1629524633026722, 0.1503953175117424, 0.15103132307455958, 0.17665470956624596, 0.18656256933916548, 0.18576185099862974, 0.16691012119899118, 0.18094297496511713, 0.17569375708455082, 0.18450652975378057, 0.17814377560752037, 0.17102659032626344, 0.1860001164602555, 0.14266808568623268, 0.15465804420089757, 0.15050941789671746, 0.23382885135704456, 0.15238131711048042, 0.13172871090336924, 0.14554674895396746, 0.19919572258114726, 0.15574415810971132, 0.14436515008990025, 0.14900508670539225, 0.14209523925606315, 0.14346317887509763, 0.1663439195905101, 0.13850047046907454, 0.1407632670533605, 0.16638434713578643, 0.15516045173480975, 0.1754023015063203, 0.2059798968583254, 0.18708927660899033, 0.21519804020914957, 0.1959198331131684, 0.18826289962573473, 0.19168038894204176, 0.18226787866694216, 0.2008325511521869, 0.0512024655363299, 0.04997288130439792, 0.05587953901118414, 0.052943304008972736, 0.05763802423314757, 0.05589026947271536, 0.05877117136869925, 0.057074363981023946, 0.05174092767433136]}, "mutation_prompt": null}
{"id": "59dc2a07-ec35-49cd-891d-64baec0859eb", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.97\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.3 * (1 - evaluations / self.budget)\n\n    # Enhanced diversity with chaos maps\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.3 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (1 - evaluations / self.budget)**0.5))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.1, self.dim), \n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = population[ranked_indices[:self.population_size]]\n            fitness = fitness[ranked_indices[:self.population_size]]\n\n        return best_solution", "name": "HybridDESA", "description": "HybridDESA with enhanced diversity through chaos maps for better exploration and exploitation balance.", "configspace": "", "generation": 35, "fitness": 0.16517995237320737, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.13.", "error": "", "parent_id": "4f6ec361-dc60-4268-a841-0a76fb0226a8", "metadata": {"aucs": [0.197577167422057, 0.20869322720538908, 0.1973740551827099, 0.21377331280496614, 0.21801139755842047, 0.2004637080560081, 0.2009361803098627, 0.20557339878789394, 0.19968590460089253, 0.1589272453880709, 0.15972383830720194, 0.17110111461888078, 0.16798177735646946, 0.1754049200427399, 0.174656388163152, 0.1672059352918548, 0.17286367850358753, 0.16658504741548208, 0.07459881044398464, 0.06057773456030224, 0.07754527989693505, 0.08475526626419527, 0.08081425439157541, 0.07262091475612598, 0.07798625634244671, 0.08797024956100974, 0.08208514997694494, 0.06808782214267717, 0.06191888442495819, 0.07413172068010643, 0.062231856802884455, 0.0566149736219439, 0.06334977852288282, 0.05875400854626145, 0.06688790743858786, 0.06303161784577604, 0.7882172902884284, 0.8289272811287576, 0.7684815558922026, 0.6168879154266469, 0.7535188154097752, 0.6128228448327597, 0.8088214732249621, 0.9767540943714939, 0.635618505511243, 0.12711822049004873, 0.13626445456208836, 0.1417846943524621, 0.1316891663208004, 0.13538442646394122, 0.13540965976175068, 0.14676577640511712, 0.146080082898701, 0.15249548074956798, 0.1684637240993332, 0.17128529265954762, 0.16581790461088752, 0.2054905652110678, 0.19054692847378063, 0.21175349125598875, 0.18908102498750223, 0.1849428065998392, 0.18733112739727853, 0.12125995506208687, 0.13194485090438302, 0.12741514393496567, 0.11243839209864159, 0.11973749442226256, 0.11734923207247994, 0.12209590890826638, 0.11467109696083899, 0.11625797991841813, 0.07078734203891379, 0.13195528057025263, 0.14661402256594502, 0.11371457625031267, 0.11596148397329031, 0.11736347565293659, 0.11527859825690989, 0.12213424099390702, 0.1403411992478354, 0.11829369303552484, 0.09661902870416872, 0.0978151830489089, 0.10721994344375452, 0.1312362608822969, 0.09371342421195972, 0.1079588619537073, 0.11456234893383554, 0.10817830441704479, 0.17193614114344669, 0.165285113634144, 0.17088937923502412, 0.130202178526171, 0.14024321251180172, 0.1519010092758366, 0.15633205884500656, 0.17141462409398844, 0.17077061720832698, 0.05220157568068384, 0.05359229623311512, 0.06128303693907855, 0.08205765330375236, 0.0806708474238188, 0.0672262581431241, 0.09537414351334605, 0.12425905417055949, 0.0684629466541039, 0.09103274949170315, 0.09284552121971645, 0.08433894980337531, 0.10182811385961399, 0.09287103769985938, 0.09109006852059975, 0.08413701969084453, 0.0917368711747577, 0.09286991335612127, 0.20399286885178303, 0.21351704034257535, 0.2107962384385993, 0.2250744469735686, 0.2070347715014862, 0.20778884613315285, 0.20796785041489352, 0.2168522299140272, 0.21065238934301378, 0.06301905617728809, 0.07770730049309116, 0.07953807131669377, 0.062401242421670444, 0.062486643156439814, 0.06146103256792412, 0.055487535617683714, 0.07260194001538145, 0.06185538916993227, 0.13263857843986315, 0.1808930677139533, 0.15787367791265328, 0.15489743037383852, 0.19830691091489305, 0.1555729270340247, 0.16714852697350924, 0.1621872312937026, 0.18333055071798976, 0.17876934780972353, 0.1886469700678256, 0.1784341050405448, 0.1860217194859618, 0.17923346420102793, 0.1787924522194546, 0.17403688993417255, 0.17347024523249444, 0.19986504823439677, 0.13755976217320787, 0.14201140862254158, 0.14088788814612274, 0.12954578487154844, 0.1421169100576355, 0.13775897847665297, 0.13720616627506954, 0.14495976963109902, 0.1458756822248115, 0.1578686781890205, 0.14902598862639538, 0.1401476487119051, 0.14659976955442255, 0.1642085301689149, 0.1547533403649186, 0.16791303114914935, 0.14599321894971706, 0.1523868617444627, 0.1695465748558359, 0.17051681310636835, 0.17339354661073103, 0.17499394330456342, 0.17086189069022728, 0.1745496286788064, 0.17193471388508696, 0.17674469057995523, 0.17453856999162742, 0.14580903068147455, 0.2491415313604396, 0.24801356472574754, 0.15229880887455416, 0.14314753048232487, 0.15710488490500174, 0.20511064480922148, 0.15666440216104494, 0.2766513229663278, 0.16028334874250227, 0.1271974068002628, 0.13285341794807848, 0.23027849560703728, 0.1829556749517539, 0.1409455290800795, 0.17900307509550206, 0.19377299022147332, 0.1499534944028823, 0.1899203870405125, 0.18244985048882034, 0.19697752796755363, 0.18150303331751638, 0.18217202348673367, 0.18578350360109397, 0.19742407334324408, 0.178914929416097, 0.20832483489778364, 0.06274432867584634, 0.06086286718485756, 0.05655980733177768, 0.057352182486843595, 0.05106817836274136, 0.05225032550779429, 0.04958115303176924, 0.060078043541649806, 0.05143858258744405]}, "mutation_prompt": null}
{"id": "4207ab59-5452-4076-8f8c-3ca8d46c62ba", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.97\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.3 * (1 - evaluations / self.budget)\n\n    # Enhanced diversity with chaos maps\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.3 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (1 - evaluations / self.budget)**0.5))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.1, self.dim), \n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = population[ranked_indices[:self.population_size]]\n            fitness = fitness[ranked_indices[:self.population_size]]\n\n        return best_solution", "name": "HybridDESA", "description": "HybridDESA with enhanced diversity through chaos maps for better exploration and exploitation balance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "59dc2a07-ec35-49cd-891d-64baec0859eb", "metadata": {"aucs": [0.197577167422057, 0.20869322720538908, 0.1973740551827099, 0.21377331280496614, 0.21801139755842047, 0.2004637080560081, 0.2009361803098627, 0.20557339878789394, 0.19968590460089253, 0.1589272453880709, 0.15972383830720194, 0.17110111461888078, 0.16798177735646946, 0.1754049200427399, 0.174656388163152, 0.1672059352918548, 0.17286367850358753, 0.16658504741548208, 0.07459881044398464, 0.06057773456030224, 0.07754527989693505, 0.08475526626419527, 0.08081425439157541, 0.07262091475612598, 0.07798625634244671, 0.08797024956100974, 0.08208514997694494, 0.06808782214267717, 0.06191888442495819, 0.07413172068010643, 0.062231856802884455, 0.0566149736219439, 0.06334977852288282, 0.05875400854626145, 0.06688790743858786, 0.06303161784577604, 0.7882172902884284, 0.8289272811287576, 0.7684815558922026, 0.6168879154266469, 0.7535188154097752, 0.6128228448327597, 0.8088214732249621, 0.9767540943714939, 0.635618505511243, 0.12711822049004873, 0.13626445456208836, 0.1417846943524621, 0.1316891663208004, 0.13538442646394122, 0.13540965976175068, 0.14676577640511712, 0.146080082898701, 0.15249548074956798, 0.1684637240993332, 0.17128529265954762, 0.16581790461088752, 0.2054905652110678, 0.19054692847378063, 0.21175349125598875, 0.18908102498750223, 0.1849428065998392, 0.18733112739727853, 0.12125995506208687, 0.13194485090438302, 0.12741514393496567, 0.11243839209864159, 0.11973749442226256, 0.11734923207247994, 0.12209590890826638, 0.11467109696083899, 0.11625797991841813, 0.07078734203891379, 0.13195528057025263, 0.14661402256594502, 0.11371457625031267, 0.11596148397329031, 0.11736347565293659, 0.11527859825690989, 0.12213424099390702, 0.1403411992478354, 0.11829369303552484, 0.09661902870416872, 0.0978151830489089, 0.10721994344375452, 0.1312362608822969, 0.09371342421195972, 0.1079588619537073, 0.11456234893383554, 0.10817830441704479, 0.17193614114344669, 0.165285113634144, 0.17088937923502412, 0.130202178526171, 0.14024321251180172, 0.1519010092758366, 0.15633205884500656, 0.17141462409398844, 0.17077061720832698, 0.05220157568068384, 0.05359229623311512, 0.06128303693907855, 0.08205765330375236, 0.0806708474238188, 0.0672262581431241, 0.09537414351334605, 0.12425905417055949, 0.0684629466541039, 0.09103274949170315, 0.09284552121971645, 0.08433894980337531, 0.10182811385961399, 0.09287103769985938, 0.09109006852059975, 0.08413701969084453, 0.0917368711747577, 0.09286991335612127, 0.20399286885178303, 0.21351704034257535, 0.2107962384385993, 0.2250744469735686, 0.2070347715014862, 0.20778884613315285, 0.20796785041489352, 0.2168522299140272, 0.21065238934301378, 0.06301905617728809, 0.07770730049309116, 0.07953807131669377, 0.062401242421670444, 0.062486643156439814, 0.06146103256792412, 0.055487535617683714, 0.07260194001538145, 0.06185538916993227, 0.13263857843986315, 0.1808930677139533, 0.15787367791265328, 0.15489743037383852, 0.19830691091489305, 0.1555729270340247, 0.16714852697350924, 0.1621872312937026, 0.18333055071798976, 0.17876934780972353, 0.1886469700678256, 0.1784341050405448, 0.1860217194859618, 0.17923346420102793, 0.1787924522194546, 0.17403688993417255, 0.17347024523249444, 0.19986504823439677, 0.13755976217320787, 0.14201140862254158, 0.14088788814612274, 0.12954578487154844, 0.1421169100576355, 0.13775897847665297, 0.13720616627506954, 0.14495976963109902, 0.1458756822248115, 0.1578686781890205, 0.14902598862639538, 0.1401476487119051, 0.14659976955442255, 0.1642085301689149, 0.1547533403649186, 0.16791303114914935, 0.14599321894971706, 0.1523868617444627, 0.1695465748558359, 0.17051681310636835, 0.17339354661073103, 0.17499394330456342, 0.17086189069022728, 0.1745496286788064, 0.17193471388508696, 0.17674469057995523, 0.17453856999162742, 0.14580903068147455, 0.2491415313604396, 0.24801356472574754, 0.15229880887455416, 0.14314753048232487, 0.15710488490500174, 0.20511064480922148, 0.15666440216104494, 0.2766513229663278, 0.16028334874250227, 0.1271974068002628, 0.13285341794807848, 0.23027849560703728, 0.1829556749517539, 0.1409455290800795, 0.17900307509550206, 0.19377299022147332, 0.1499534944028823, 0.1899203870405125, 0.18244985048882034, 0.19697752796755363, 0.18150303331751638, 0.18217202348673367, 0.18578350360109397, 0.19742407334324408, 0.178914929416097, 0.20832483489778364, 0.06274432867584634, 0.06086286718485756, 0.05655980733177768, 0.057352182486843595, 0.05106817836274136, 0.05225032550779429, 0.04958115303176924, 0.060078043541649806, 0.05143858258744405]}, "mutation_prompt": null}
{"id": "8d326bc8-0b21-4f7d-bb92-2cddcd8e06ab", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.97\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.3 * (1 - evaluations / self.budget)\n\n    # Enhanced diversity with chaos maps\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.3 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (1 - evaluations / self.budget)**0.5))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.1, self.dim), \n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = population[ranked_indices[:self.population_size]]\n            fitness = fitness[ranked_indices[:self.population_size]]\n\n        return best_solution", "name": "HybridDESA", "description": "HybridDESA with enhanced diversity through chaos maps for better exploration and exploitation balance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "59dc2a07-ec35-49cd-891d-64baec0859eb", "metadata": {"aucs": [0.197577167422057, 0.20869322720538908, 0.1973740551827099, 0.21377331280496614, 0.21801139755842047, 0.2004637080560081, 0.2009361803098627, 0.20557339878789394, 0.19968590460089253, 0.1589272453880709, 0.15972383830720194, 0.17110111461888078, 0.16798177735646946, 0.1754049200427399, 0.174656388163152, 0.1672059352918548, 0.17286367850358753, 0.16658504741548208, 0.07459881044398464, 0.06057773456030224, 0.07754527989693505, 0.08475526626419527, 0.08081425439157541, 0.07262091475612598, 0.07798625634244671, 0.08797024956100974, 0.08208514997694494, 0.06808782214267717, 0.06191888442495819, 0.07413172068010643, 0.062231856802884455, 0.0566149736219439, 0.06334977852288282, 0.05875400854626145, 0.06688790743858786, 0.06303161784577604, 0.7882172902884284, 0.8289272811287576, 0.7684815558922026, 0.6168879154266469, 0.7535188154097752, 0.6128228448327597, 0.8088214732249621, 0.9767540943714939, 0.635618505511243, 0.12711822049004873, 0.13626445456208836, 0.1417846943524621, 0.1316891663208004, 0.13538442646394122, 0.13540965976175068, 0.14676577640511712, 0.146080082898701, 0.15249548074956798, 0.1684637240993332, 0.17128529265954762, 0.16581790461088752, 0.2054905652110678, 0.19054692847378063, 0.21175349125598875, 0.18908102498750223, 0.1849428065998392, 0.18733112739727853, 0.12125995506208687, 0.13194485090438302, 0.12741514393496567, 0.11243839209864159, 0.11973749442226256, 0.11734923207247994, 0.12209590890826638, 0.11467109696083899, 0.11625797991841813, 0.07078734203891379, 0.13195528057025263, 0.14661402256594502, 0.11371457625031267, 0.11596148397329031, 0.11736347565293659, 0.11527859825690989, 0.12213424099390702, 0.1403411992478354, 0.11829369303552484, 0.09661902870416872, 0.0978151830489089, 0.10721994344375452, 0.1312362608822969, 0.09371342421195972, 0.1079588619537073, 0.11456234893383554, 0.10817830441704479, 0.17193614114344669, 0.165285113634144, 0.17088937923502412, 0.130202178526171, 0.14024321251180172, 0.1519010092758366, 0.15633205884500656, 0.17141462409398844, 0.17077061720832698, 0.05220157568068384, 0.05359229623311512, 0.06128303693907855, 0.08205765330375236, 0.0806708474238188, 0.0672262581431241, 0.09537414351334605, 0.12425905417055949, 0.0684629466541039, 0.09103274949170315, 0.09284552121971645, 0.08433894980337531, 0.10182811385961399, 0.09287103769985938, 0.09109006852059975, 0.08413701969084453, 0.0917368711747577, 0.09286991335612127, 0.20399286885178303, 0.21351704034257535, 0.2107962384385993, 0.2250744469735686, 0.2070347715014862, 0.20778884613315285, 0.20796785041489352, 0.2168522299140272, 0.21065238934301378, 0.06301905617728809, 0.07770730049309116, 0.07953807131669377, 0.062401242421670444, 0.062486643156439814, 0.06146103256792412, 0.055487535617683714, 0.07260194001538145, 0.06185538916993227, 0.13263857843986315, 0.1808930677139533, 0.15787367791265328, 0.15489743037383852, 0.19830691091489305, 0.1555729270340247, 0.16714852697350924, 0.1621872312937026, 0.18333055071798976, 0.17876934780972353, 0.1886469700678256, 0.1784341050405448, 0.1860217194859618, 0.17923346420102793, 0.1787924522194546, 0.17403688993417255, 0.17347024523249444, 0.19986504823439677, 0.13755976217320787, 0.14201140862254158, 0.14088788814612274, 0.12954578487154844, 0.1421169100576355, 0.13775897847665297, 0.13720616627506954, 0.14495976963109902, 0.1458756822248115, 0.1578686781890205, 0.14902598862639538, 0.1401476487119051, 0.14659976955442255, 0.1642085301689149, 0.1547533403649186, 0.16791303114914935, 0.14599321894971706, 0.1523868617444627, 0.1695465748558359, 0.17051681310636835, 0.17339354661073103, 0.17499394330456342, 0.17086189069022728, 0.1745496286788064, 0.17193471388508696, 0.17674469057995523, 0.17453856999162742, 0.14580903068147455, 0.2491415313604396, 0.24801356472574754, 0.15229880887455416, 0.14314753048232487, 0.15710488490500174, 0.20511064480922148, 0.15666440216104494, 0.2766513229663278, 0.16028334874250227, 0.1271974068002628, 0.13285341794807848, 0.23027849560703728, 0.1829556749517539, 0.1409455290800795, 0.17900307509550206, 0.19377299022147332, 0.1499534944028823, 0.1899203870405125, 0.18244985048882034, 0.19697752796755363, 0.18150303331751638, 0.18217202348673367, 0.18578350360109397, 0.19742407334324408, 0.178914929416097, 0.20832483489778364, 0.06274432867584634, 0.06086286718485756, 0.05655980733177768, 0.057352182486843595, 0.05106817836274136, 0.05225032550779429, 0.04958115303176924, 0.060078043541649806, 0.05143858258744405]}, "mutation_prompt": null}
{"id": "8075d807-97b5-4cec-a5cd-50bc5c692382", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.97\n\n    def _localized_chaos_initialization(self):\n        x = np.random.rand(self.population_size, self.dim)\n        localized_center = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        return localized_center + (self.upper_bound - localized_center) * np.abs(np.sin(np.pi * x))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.5 + 0.4 * np.sin(evaluations * np.pi / (2 * self.budget))\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (1 - evaluations / self.budget)**0.5))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._localized_chaos_initialization()\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.1, self.dim), \n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = population[ranked_indices[:self.population_size]]\n            fitness = fitness[ranked_indices[:self.population_size]]\n\n        return best_solution", "name": "HybridDESA", "description": "Enhanced HybridDESA with localized chaos map for initial population and dynamic crossover to improve exploration-exploitation balance.", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'HybridDESA' object has no attribute '_adaptive_mutation_factor'\").", "error": "AttributeError(\"'HybridDESA' object has no attribute '_adaptive_mutation_factor'\")", "parent_id": "59dc2a07-ec35-49cd-891d-64baec0859eb", "metadata": {}, "mutation_prompt": null}
{"id": "d202f0c5-d49d-45d3-ae68-21f21e90a79e", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.97\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.3 * (1 - evaluations / self.budget)\n\n    # Enhanced diversity with chaos maps\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.3 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (1 - evaluations / self.budget)**0.5))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.1, self.dim), \n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = population[ranked_indices[:self.population_size]]\n            fitness = fitness[ranked_indices[:self.population_size]]\n\n        return best_solution", "name": "HybridDESA", "description": "HybridDESA with enhanced diversity through chaos maps for better exploration and exploitation balance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "59dc2a07-ec35-49cd-891d-64baec0859eb", "metadata": {"aucs": [0.197577167422057, 0.20869322720538908, 0.1973740551827099, 0.21377331280496614, 0.21801139755842047, 0.2004637080560081, 0.2009361803098627, 0.20557339878789394, 0.19968590460089253, 0.1589272453880709, 0.15972383830720194, 0.17110111461888078, 0.16798177735646946, 0.1754049200427399, 0.174656388163152, 0.1672059352918548, 0.17286367850358753, 0.16658504741548208, 0.07459881044398464, 0.06057773456030224, 0.07754527989693505, 0.08475526626419527, 0.08081425439157541, 0.07262091475612598, 0.07798625634244671, 0.08797024956100974, 0.08208514997694494, 0.06808782214267717, 0.06191888442495819, 0.07413172068010643, 0.062231856802884455, 0.0566149736219439, 0.06334977852288282, 0.05875400854626145, 0.06688790743858786, 0.06303161784577604, 0.7882172902884284, 0.8289272811287576, 0.7684815558922026, 0.6168879154266469, 0.7535188154097752, 0.6128228448327597, 0.8088214732249621, 0.9767540943714939, 0.635618505511243, 0.12711822049004873, 0.13626445456208836, 0.1417846943524621, 0.1316891663208004, 0.13538442646394122, 0.13540965976175068, 0.14676577640511712, 0.146080082898701, 0.15249548074956798, 0.1684637240993332, 0.17128529265954762, 0.16581790461088752, 0.2054905652110678, 0.19054692847378063, 0.21175349125598875, 0.18908102498750223, 0.1849428065998392, 0.18733112739727853, 0.12125995506208687, 0.13194485090438302, 0.12741514393496567, 0.11243839209864159, 0.11973749442226256, 0.11734923207247994, 0.12209590890826638, 0.11467109696083899, 0.11625797991841813, 0.07078734203891379, 0.13195528057025263, 0.14661402256594502, 0.11371457625031267, 0.11596148397329031, 0.11736347565293659, 0.11527859825690989, 0.12213424099390702, 0.1403411992478354, 0.11829369303552484, 0.09661902870416872, 0.0978151830489089, 0.10721994344375452, 0.1312362608822969, 0.09371342421195972, 0.1079588619537073, 0.11456234893383554, 0.10817830441704479, 0.17193614114344669, 0.165285113634144, 0.17088937923502412, 0.130202178526171, 0.14024321251180172, 0.1519010092758366, 0.15633205884500656, 0.17141462409398844, 0.17077061720832698, 0.05220157568068384, 0.05359229623311512, 0.06128303693907855, 0.08205765330375236, 0.0806708474238188, 0.0672262581431241, 0.09537414351334605, 0.12425905417055949, 0.0684629466541039, 0.09103274949170315, 0.09284552121971645, 0.08433894980337531, 0.10182811385961399, 0.09287103769985938, 0.09109006852059975, 0.08413701969084453, 0.0917368711747577, 0.09286991335612127, 0.20399286885178303, 0.21351704034257535, 0.2107962384385993, 0.2250744469735686, 0.2070347715014862, 0.20778884613315285, 0.20796785041489352, 0.2168522299140272, 0.21065238934301378, 0.06301905617728809, 0.07770730049309116, 0.07953807131669377, 0.062401242421670444, 0.062486643156439814, 0.06146103256792412, 0.055487535617683714, 0.07260194001538145, 0.06185538916993227, 0.13263857843986315, 0.1808930677139533, 0.15787367791265328, 0.15489743037383852, 0.19830691091489305, 0.1555729270340247, 0.16714852697350924, 0.1621872312937026, 0.18333055071798976, 0.17876934780972353, 0.1886469700678256, 0.1784341050405448, 0.1860217194859618, 0.17923346420102793, 0.1787924522194546, 0.17403688993417255, 0.17347024523249444, 0.19986504823439677, 0.13755976217320787, 0.14201140862254158, 0.14088788814612274, 0.12954578487154844, 0.1421169100576355, 0.13775897847665297, 0.13720616627506954, 0.14495976963109902, 0.1458756822248115, 0.1578686781890205, 0.14902598862639538, 0.1401476487119051, 0.14659976955442255, 0.1642085301689149, 0.1547533403649186, 0.16791303114914935, 0.14599321894971706, 0.1523868617444627, 0.1695465748558359, 0.17051681310636835, 0.17339354661073103, 0.17499394330456342, 0.17086189069022728, 0.1745496286788064, 0.17193471388508696, 0.17674469057995523, 0.17453856999162742, 0.14580903068147455, 0.2491415313604396, 0.24801356472574754, 0.15229880887455416, 0.14314753048232487, 0.15710488490500174, 0.20511064480922148, 0.15666440216104494, 0.2766513229663278, 0.16028334874250227, 0.1271974068002628, 0.13285341794807848, 0.23027849560703728, 0.1829556749517539, 0.1409455290800795, 0.17900307509550206, 0.19377299022147332, 0.1499534944028823, 0.1899203870405125, 0.18244985048882034, 0.19697752796755363, 0.18150303331751638, 0.18217202348673367, 0.18578350360109397, 0.19742407334324408, 0.178914929416097, 0.20832483489778364, 0.06274432867584634, 0.06086286718485756, 0.05655980733177768, 0.057352182486843595, 0.05106817836274136, 0.05225032550779429, 0.04958115303176924, 0.060078043541649806, 0.05143858258744405]}, "mutation_prompt": null}
{"id": "e5bf370b-96ed-4c9d-8e9c-6e169bbf6a5a", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.97\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.3 * (1 - evaluations / self.budget)\n\n    # Enhanced diversity with chaos maps\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.3 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (1 - evaluations / self.budget)**0.5))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.1, self.dim), \n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = population[ranked_indices[:self.population_size]]\n            fitness = fitness[ranked_indices[:self.population_size]]\n\n        return best_solution", "name": "HybridDESA", "description": "HybridDESA with enhanced diversity through chaos maps for better exploration and exploitation balance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "59dc2a07-ec35-49cd-891d-64baec0859eb", "metadata": {"aucs": [0.197577167422057, 0.20869322720538908, 0.1973740551827099, 0.21377331280496614, 0.21801139755842047, 0.2004637080560081, 0.2009361803098627, 0.20557339878789394, 0.19968590460089253, 0.1589272453880709, 0.15972383830720194, 0.17110111461888078, 0.16798177735646946, 0.1754049200427399, 0.174656388163152, 0.1672059352918548, 0.17286367850358753, 0.16658504741548208, 0.07459881044398464, 0.06057773456030224, 0.07754527989693505, 0.08475526626419527, 0.08081425439157541, 0.07262091475612598, 0.07798625634244671, 0.08797024956100974, 0.08208514997694494, 0.06808782214267717, 0.06191888442495819, 0.07413172068010643, 0.062231856802884455, 0.0566149736219439, 0.06334977852288282, 0.05875400854626145, 0.06688790743858786, 0.06303161784577604, 0.7882172902884284, 0.8289272811287576, 0.7684815558922026, 0.6168879154266469, 0.7535188154097752, 0.6128228448327597, 0.8088214732249621, 0.9767540943714939, 0.635618505511243, 0.12711822049004873, 0.13626445456208836, 0.1417846943524621, 0.1316891663208004, 0.13538442646394122, 0.13540965976175068, 0.14676577640511712, 0.146080082898701, 0.15249548074956798, 0.1684637240993332, 0.17128529265954762, 0.16581790461088752, 0.2054905652110678, 0.19054692847378063, 0.21175349125598875, 0.18908102498750223, 0.1849428065998392, 0.18733112739727853, 0.12125995506208687, 0.13194485090438302, 0.12741514393496567, 0.11243839209864159, 0.11973749442226256, 0.11734923207247994, 0.12209590890826638, 0.11467109696083899, 0.11625797991841813, 0.07078734203891379, 0.13195528057025263, 0.14661402256594502, 0.11371457625031267, 0.11596148397329031, 0.11736347565293659, 0.11527859825690989, 0.12213424099390702, 0.1403411992478354, 0.11829369303552484, 0.09661902870416872, 0.0978151830489089, 0.10721994344375452, 0.1312362608822969, 0.09371342421195972, 0.1079588619537073, 0.11456234893383554, 0.10817830441704479, 0.17193614114344669, 0.165285113634144, 0.17088937923502412, 0.130202178526171, 0.14024321251180172, 0.1519010092758366, 0.15633205884500656, 0.17141462409398844, 0.17077061720832698, 0.05220157568068384, 0.05359229623311512, 0.06128303693907855, 0.08205765330375236, 0.0806708474238188, 0.0672262581431241, 0.09537414351334605, 0.12425905417055949, 0.0684629466541039, 0.09103274949170315, 0.09284552121971645, 0.08433894980337531, 0.10182811385961399, 0.09287103769985938, 0.09109006852059975, 0.08413701969084453, 0.0917368711747577, 0.09286991335612127, 0.20399286885178303, 0.21351704034257535, 0.2107962384385993, 0.2250744469735686, 0.2070347715014862, 0.20778884613315285, 0.20796785041489352, 0.2168522299140272, 0.21065238934301378, 0.06301905617728809, 0.07770730049309116, 0.07953807131669377, 0.062401242421670444, 0.062486643156439814, 0.06146103256792412, 0.055487535617683714, 0.07260194001538145, 0.06185538916993227, 0.13263857843986315, 0.1808930677139533, 0.15787367791265328, 0.15489743037383852, 0.19830691091489305, 0.1555729270340247, 0.16714852697350924, 0.1621872312937026, 0.18333055071798976, 0.17876934780972353, 0.1886469700678256, 0.1784341050405448, 0.1860217194859618, 0.17923346420102793, 0.1787924522194546, 0.17403688993417255, 0.17347024523249444, 0.19986504823439677, 0.13755976217320787, 0.14201140862254158, 0.14088788814612274, 0.12954578487154844, 0.1421169100576355, 0.13775897847665297, 0.13720616627506954, 0.14495976963109902, 0.1458756822248115, 0.1578686781890205, 0.14902598862639538, 0.1401476487119051, 0.14659976955442255, 0.1642085301689149, 0.1547533403649186, 0.16791303114914935, 0.14599321894971706, 0.1523868617444627, 0.1695465748558359, 0.17051681310636835, 0.17339354661073103, 0.17499394330456342, 0.17086189069022728, 0.1745496286788064, 0.17193471388508696, 0.17674469057995523, 0.17453856999162742, 0.14580903068147455, 0.2491415313604396, 0.24801356472574754, 0.15229880887455416, 0.14314753048232487, 0.15710488490500174, 0.20511064480922148, 0.15666440216104494, 0.2766513229663278, 0.16028334874250227, 0.1271974068002628, 0.13285341794807848, 0.23027849560703728, 0.1829556749517539, 0.1409455290800795, 0.17900307509550206, 0.19377299022147332, 0.1499534944028823, 0.1899203870405125, 0.18244985048882034, 0.19697752796755363, 0.18150303331751638, 0.18217202348673367, 0.18578350360109397, 0.19742407334324408, 0.178914929416097, 0.20832483489778364, 0.06274432867584634, 0.06086286718485756, 0.05655980733177768, 0.057352182486843595, 0.05106817836274136, 0.05225032550779429, 0.04958115303176924, 0.060078043541649806, 0.05143858258744405]}, "mutation_prompt": null}
{"id": "0926612a-7ce8-4f52-8f98-cb02d19916c9", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.97\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.3 * (1 - evaluations / self.budget)\n\n    # Enhanced diversity with chaos maps\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.3 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (1 - evaluations / self.budget)**0.5))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.1, self.dim), \n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = population[ranked_indices[:self.population_size]]\n            fitness = fitness[ranked_indices[:self.population_size]]\n\n        return best_solution", "name": "HybridDESA", "description": "HybridDESA with enhanced diversity through chaos maps for better exploration and exploitation balance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "59dc2a07-ec35-49cd-891d-64baec0859eb", "metadata": {"aucs": [0.197577167422057, 0.20869322720538908, 0.1973740551827099, 0.21377331280496614, 0.21801139755842047, 0.2004637080560081, 0.2009361803098627, 0.20557339878789394, 0.19968590460089253, 0.1589272453880709, 0.15972383830720194, 0.17110111461888078, 0.16798177735646946, 0.1754049200427399, 0.174656388163152, 0.1672059352918548, 0.17286367850358753, 0.16658504741548208, 0.07459881044398464, 0.06057773456030224, 0.07754527989693505, 0.08475526626419527, 0.08081425439157541, 0.07262091475612598, 0.07798625634244671, 0.08797024956100974, 0.08208514997694494, 0.06808782214267717, 0.06191888442495819, 0.07413172068010643, 0.062231856802884455, 0.0566149736219439, 0.06334977852288282, 0.05875400854626145, 0.06688790743858786, 0.06303161784577604, 0.7882172902884284, 0.8289272811287576, 0.7684815558922026, 0.6168879154266469, 0.7535188154097752, 0.6128228448327597, 0.8088214732249621, 0.9767540943714939, 0.635618505511243, 0.12711822049004873, 0.13626445456208836, 0.1417846943524621, 0.1316891663208004, 0.13538442646394122, 0.13540965976175068, 0.14676577640511712, 0.146080082898701, 0.15249548074956798, 0.1684637240993332, 0.17128529265954762, 0.16581790461088752, 0.2054905652110678, 0.19054692847378063, 0.21175349125598875, 0.18908102498750223, 0.1849428065998392, 0.18733112739727853, 0.12125995506208687, 0.13194485090438302, 0.12741514393496567, 0.11243839209864159, 0.11973749442226256, 0.11734923207247994, 0.12209590890826638, 0.11467109696083899, 0.11625797991841813, 0.07078734203891379, 0.13195528057025263, 0.14661402256594502, 0.11371457625031267, 0.11596148397329031, 0.11736347565293659, 0.11527859825690989, 0.12213424099390702, 0.1403411992478354, 0.11829369303552484, 0.09661902870416872, 0.0978151830489089, 0.10721994344375452, 0.1312362608822969, 0.09371342421195972, 0.1079588619537073, 0.11456234893383554, 0.10817830441704479, 0.17193614114344669, 0.165285113634144, 0.17088937923502412, 0.130202178526171, 0.14024321251180172, 0.1519010092758366, 0.15633205884500656, 0.17141462409398844, 0.17077061720832698, 0.05220157568068384, 0.05359229623311512, 0.06128303693907855, 0.08205765330375236, 0.0806708474238188, 0.0672262581431241, 0.09537414351334605, 0.12425905417055949, 0.0684629466541039, 0.09103274949170315, 0.09284552121971645, 0.08433894980337531, 0.10182811385961399, 0.09287103769985938, 0.09109006852059975, 0.08413701969084453, 0.0917368711747577, 0.09286991335612127, 0.20399286885178303, 0.21351704034257535, 0.2107962384385993, 0.2250744469735686, 0.2070347715014862, 0.20778884613315285, 0.20796785041489352, 0.2168522299140272, 0.21065238934301378, 0.06301905617728809, 0.07770730049309116, 0.07953807131669377, 0.062401242421670444, 0.062486643156439814, 0.06146103256792412, 0.055487535617683714, 0.07260194001538145, 0.06185538916993227, 0.13263857843986315, 0.1808930677139533, 0.15787367791265328, 0.15489743037383852, 0.19830691091489305, 0.1555729270340247, 0.16714852697350924, 0.1621872312937026, 0.18333055071798976, 0.17876934780972353, 0.1886469700678256, 0.1784341050405448, 0.1860217194859618, 0.17923346420102793, 0.1787924522194546, 0.17403688993417255, 0.17347024523249444, 0.19986504823439677, 0.13755976217320787, 0.14201140862254158, 0.14088788814612274, 0.12954578487154844, 0.1421169100576355, 0.13775897847665297, 0.13720616627506954, 0.14495976963109902, 0.1458756822248115, 0.1578686781890205, 0.14902598862639538, 0.1401476487119051, 0.14659976955442255, 0.1642085301689149, 0.1547533403649186, 0.16791303114914935, 0.14599321894971706, 0.1523868617444627, 0.1695465748558359, 0.17051681310636835, 0.17339354661073103, 0.17499394330456342, 0.17086189069022728, 0.1745496286788064, 0.17193471388508696, 0.17674469057995523, 0.17453856999162742, 0.14580903068147455, 0.2491415313604396, 0.24801356472574754, 0.15229880887455416, 0.14314753048232487, 0.15710488490500174, 0.20511064480922148, 0.15666440216104494, 0.2766513229663278, 0.16028334874250227, 0.1271974068002628, 0.13285341794807848, 0.23027849560703728, 0.1829556749517539, 0.1409455290800795, 0.17900307509550206, 0.19377299022147332, 0.1499534944028823, 0.1899203870405125, 0.18244985048882034, 0.19697752796755363, 0.18150303331751638, 0.18217202348673367, 0.18578350360109397, 0.19742407334324408, 0.178914929416097, 0.20832483489778364, 0.06274432867584634, 0.06086286718485756, 0.05655980733177768, 0.057352182486843595, 0.05106817836274136, 0.05225032550779429, 0.04958115303176924, 0.060078043541649806, 0.05143858258744405]}, "mutation_prompt": null}
{"id": "3126bacb-2a69-4135-9ad7-803050b9ee46", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.97\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.3 * (1 - evaluations / self.budget)\n\n    # Enhanced diversity with chaos maps\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.3 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (1 - evaluations / self.budget)**0.5))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.1, self.dim), \n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = population[ranked_indices[:self.population_size]]\n            fitness = fitness[ranked_indices[:self.population_size]]\n\n        return best_solution", "name": "HybridDESA", "description": "HybridDESA with enhanced diversity through chaos maps for better exploration and exploitation balance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "59dc2a07-ec35-49cd-891d-64baec0859eb", "metadata": {"aucs": [0.197577167422057, 0.20869322720538908, 0.1973740551827099, 0.21377331280496614, 0.21801139755842047, 0.2004637080560081, 0.2009361803098627, 0.20557339878789394, 0.19968590460089253, 0.1589272453880709, 0.15972383830720194, 0.17110111461888078, 0.16798177735646946, 0.1754049200427399, 0.174656388163152, 0.1672059352918548, 0.17286367850358753, 0.16658504741548208, 0.07459881044398464, 0.06057773456030224, 0.07754527989693505, 0.08475526626419527, 0.08081425439157541, 0.07262091475612598, 0.07798625634244671, 0.08797024956100974, 0.08208514997694494, 0.06808782214267717, 0.06191888442495819, 0.07413172068010643, 0.062231856802884455, 0.0566149736219439, 0.06334977852288282, 0.05875400854626145, 0.06688790743858786, 0.06303161784577604, 0.7882172902884284, 0.8289272811287576, 0.7684815558922026, 0.6168879154266469, 0.7535188154097752, 0.6128228448327597, 0.8088214732249621, 0.9767540943714939, 0.635618505511243, 0.12711822049004873, 0.13626445456208836, 0.1417846943524621, 0.1316891663208004, 0.13538442646394122, 0.13540965976175068, 0.14676577640511712, 0.146080082898701, 0.15249548074956798, 0.1684637240993332, 0.17128529265954762, 0.16581790461088752, 0.2054905652110678, 0.19054692847378063, 0.21175349125598875, 0.18908102498750223, 0.1849428065998392, 0.18733112739727853, 0.12125995506208687, 0.13194485090438302, 0.12741514393496567, 0.11243839209864159, 0.11973749442226256, 0.11734923207247994, 0.12209590890826638, 0.11467109696083899, 0.11625797991841813, 0.07078734203891379, 0.13195528057025263, 0.14661402256594502, 0.11371457625031267, 0.11596148397329031, 0.11736347565293659, 0.11527859825690989, 0.12213424099390702, 0.1403411992478354, 0.11829369303552484, 0.09661902870416872, 0.0978151830489089, 0.10721994344375452, 0.1312362608822969, 0.09371342421195972, 0.1079588619537073, 0.11456234893383554, 0.10817830441704479, 0.17193614114344669, 0.165285113634144, 0.17088937923502412, 0.130202178526171, 0.14024321251180172, 0.1519010092758366, 0.15633205884500656, 0.17141462409398844, 0.17077061720832698, 0.05220157568068384, 0.05359229623311512, 0.06128303693907855, 0.08205765330375236, 0.0806708474238188, 0.0672262581431241, 0.09537414351334605, 0.12425905417055949, 0.0684629466541039, 0.09103274949170315, 0.09284552121971645, 0.08433894980337531, 0.10182811385961399, 0.09287103769985938, 0.09109006852059975, 0.08413701969084453, 0.0917368711747577, 0.09286991335612127, 0.20399286885178303, 0.21351704034257535, 0.2107962384385993, 0.2250744469735686, 0.2070347715014862, 0.20778884613315285, 0.20796785041489352, 0.2168522299140272, 0.21065238934301378, 0.06301905617728809, 0.07770730049309116, 0.07953807131669377, 0.062401242421670444, 0.062486643156439814, 0.06146103256792412, 0.055487535617683714, 0.07260194001538145, 0.06185538916993227, 0.13263857843986315, 0.1808930677139533, 0.15787367791265328, 0.15489743037383852, 0.19830691091489305, 0.1555729270340247, 0.16714852697350924, 0.1621872312937026, 0.18333055071798976, 0.17876934780972353, 0.1886469700678256, 0.1784341050405448, 0.1860217194859618, 0.17923346420102793, 0.1787924522194546, 0.17403688993417255, 0.17347024523249444, 0.19986504823439677, 0.13755976217320787, 0.14201140862254158, 0.14088788814612274, 0.12954578487154844, 0.1421169100576355, 0.13775897847665297, 0.13720616627506954, 0.14495976963109902, 0.1458756822248115, 0.1578686781890205, 0.14902598862639538, 0.1401476487119051, 0.14659976955442255, 0.1642085301689149, 0.1547533403649186, 0.16791303114914935, 0.14599321894971706, 0.1523868617444627, 0.1695465748558359, 0.17051681310636835, 0.17339354661073103, 0.17499394330456342, 0.17086189069022728, 0.1745496286788064, 0.17193471388508696, 0.17674469057995523, 0.17453856999162742, 0.14580903068147455, 0.2491415313604396, 0.24801356472574754, 0.15229880887455416, 0.14314753048232487, 0.15710488490500174, 0.20511064480922148, 0.15666440216104494, 0.2766513229663278, 0.16028334874250227, 0.1271974068002628, 0.13285341794807848, 0.23027849560703728, 0.1829556749517539, 0.1409455290800795, 0.17900307509550206, 0.19377299022147332, 0.1499534944028823, 0.1899203870405125, 0.18244985048882034, 0.19697752796755363, 0.18150303331751638, 0.18217202348673367, 0.18578350360109397, 0.19742407334324408, 0.178914929416097, 0.20832483489778364, 0.06274432867584634, 0.06086286718485756, 0.05655980733177768, 0.057352182486843595, 0.05106817836274136, 0.05225032550779429, 0.04958115303176924, 0.060078043541649806, 0.05143858258744405]}, "mutation_prompt": null}
{"id": "0615d6e0-1c4a-4e0a-ad3e-36016856eced", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.97\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.3 * (1 - evaluations / self.budget)\n\n    # Enhanced diversity with chaos maps\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.3 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (1 - evaluations / self.budget)**0.5))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.1, self.dim), \n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = population[ranked_indices[:self.population_size]]\n            fitness = fitness[ranked_indices[:self.population_size]]\n\n        return best_solution", "name": "HybridDESA", "description": "HybridDESA with enhanced diversity through chaos maps for better exploration and exploitation balance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "59dc2a07-ec35-49cd-891d-64baec0859eb", "metadata": {"aucs": [0.197577167422057, 0.20869322720538908, 0.1973740551827099, 0.21377331280496614, 0.21801139755842047, 0.2004637080560081, 0.2009361803098627, 0.20557339878789394, 0.19968590460089253, 0.1589272453880709, 0.15972383830720194, 0.17110111461888078, 0.16798177735646946, 0.1754049200427399, 0.174656388163152, 0.1672059352918548, 0.17286367850358753, 0.16658504741548208, 0.07459881044398464, 0.06057773456030224, 0.07754527989693505, 0.08475526626419527, 0.08081425439157541, 0.07262091475612598, 0.07798625634244671, 0.08797024956100974, 0.08208514997694494, 0.06808782214267717, 0.06191888442495819, 0.07413172068010643, 0.062231856802884455, 0.0566149736219439, 0.06334977852288282, 0.05875400854626145, 0.06688790743858786, 0.06303161784577604, 0.7882172902884284, 0.8289272811287576, 0.7684815558922026, 0.6168879154266469, 0.7535188154097752, 0.6128228448327597, 0.8088214732249621, 0.9767540943714939, 0.635618505511243, 0.12711822049004873, 0.13626445456208836, 0.1417846943524621, 0.1316891663208004, 0.13538442646394122, 0.13540965976175068, 0.14676577640511712, 0.146080082898701, 0.15249548074956798, 0.1684637240993332, 0.17128529265954762, 0.16581790461088752, 0.2054905652110678, 0.19054692847378063, 0.21175349125598875, 0.18908102498750223, 0.1849428065998392, 0.18733112739727853, 0.12125995506208687, 0.13194485090438302, 0.12741514393496567, 0.11243839209864159, 0.11973749442226256, 0.11734923207247994, 0.12209590890826638, 0.11467109696083899, 0.11625797991841813, 0.07078734203891379, 0.13195528057025263, 0.14661402256594502, 0.11371457625031267, 0.11596148397329031, 0.11736347565293659, 0.11527859825690989, 0.12213424099390702, 0.1403411992478354, 0.11829369303552484, 0.09661902870416872, 0.0978151830489089, 0.10721994344375452, 0.1312362608822969, 0.09371342421195972, 0.1079588619537073, 0.11456234893383554, 0.10817830441704479, 0.17193614114344669, 0.165285113634144, 0.17088937923502412, 0.130202178526171, 0.14024321251180172, 0.1519010092758366, 0.15633205884500656, 0.17141462409398844, 0.17077061720832698, 0.05220157568068384, 0.05359229623311512, 0.06128303693907855, 0.08205765330375236, 0.0806708474238188, 0.0672262581431241, 0.09537414351334605, 0.12425905417055949, 0.0684629466541039, 0.09103274949170315, 0.09284552121971645, 0.08433894980337531, 0.10182811385961399, 0.09287103769985938, 0.09109006852059975, 0.08413701969084453, 0.0917368711747577, 0.09286991335612127, 0.20399286885178303, 0.21351704034257535, 0.2107962384385993, 0.2250744469735686, 0.2070347715014862, 0.20778884613315285, 0.20796785041489352, 0.2168522299140272, 0.21065238934301378, 0.06301905617728809, 0.07770730049309116, 0.07953807131669377, 0.062401242421670444, 0.062486643156439814, 0.06146103256792412, 0.055487535617683714, 0.07260194001538145, 0.06185538916993227, 0.13263857843986315, 0.1808930677139533, 0.15787367791265328, 0.15489743037383852, 0.19830691091489305, 0.1555729270340247, 0.16714852697350924, 0.1621872312937026, 0.18333055071798976, 0.17876934780972353, 0.1886469700678256, 0.1784341050405448, 0.1860217194859618, 0.17923346420102793, 0.1787924522194546, 0.17403688993417255, 0.17347024523249444, 0.19986504823439677, 0.13755976217320787, 0.14201140862254158, 0.14088788814612274, 0.12954578487154844, 0.1421169100576355, 0.13775897847665297, 0.13720616627506954, 0.14495976963109902, 0.1458756822248115, 0.1578686781890205, 0.14902598862639538, 0.1401476487119051, 0.14659976955442255, 0.1642085301689149, 0.1547533403649186, 0.16791303114914935, 0.14599321894971706, 0.1523868617444627, 0.1695465748558359, 0.17051681310636835, 0.17339354661073103, 0.17499394330456342, 0.17086189069022728, 0.1745496286788064, 0.17193471388508696, 0.17674469057995523, 0.17453856999162742, 0.14580903068147455, 0.2491415313604396, 0.24801356472574754, 0.15229880887455416, 0.14314753048232487, 0.15710488490500174, 0.20511064480922148, 0.15666440216104494, 0.2766513229663278, 0.16028334874250227, 0.1271974068002628, 0.13285341794807848, 0.23027849560703728, 0.1829556749517539, 0.1409455290800795, 0.17900307509550206, 0.19377299022147332, 0.1499534944028823, 0.1899203870405125, 0.18244985048882034, 0.19697752796755363, 0.18150303331751638, 0.18217202348673367, 0.18578350360109397, 0.19742407334324408, 0.178914929416097, 0.20832483489778364, 0.06274432867584634, 0.06086286718485756, 0.05655980733177768, 0.057352182486843595, 0.05106817836274136, 0.05225032550779429, 0.04958115303176924, 0.060078043541649806, 0.05143858258744405]}, "mutation_prompt": null}
{"id": "e6ee9347-239a-4f5a-be45-c5189277a73e", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.97\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.3 * (1 - evaluations / self.budget)\n\n    # Enhanced diversity with chaos maps\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.3 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (1 - evaluations / self.budget)**0.5))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    # Lévy flight for exploration \n    def _levy_flight(self, step):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.1, self.dim), \n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                \n                # Apply Lévy flight to trial vector\n                trial = np.clip(trial + self._levy_flight(1), self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = population[ranked_indices[:self.population_size]]\n            fitness = fitness[ranked_indices[:self.population_size]]\n\n        return best_solution", "name": "HybridDESA", "description": "HybridDESA refined with Lévy flight for improved exploration and convergence speed.", "configspace": "", "generation": 44, "fitness": 0.14388092702449173, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.09.", "error": "", "parent_id": "59dc2a07-ec35-49cd-891d-64baec0859eb", "metadata": {"aucs": [0.20490475935384878, 0.19764779678382927, 0.19800239642444661, 0.21157344522298238, 0.21773814415972526, 0.21975152875931503, 0.22203767731334556, 0.23081032953453684, 0.20981930787525271, 0.12759378366622254, 0.1272064076222139, 0.12858315793202635, 0.13244589042170996, 0.1243770713533866, 0.13734508763449926, 0.12482360698155914, 0.13447136459008158, 0.13210230594880668, 0.06742249824162139, 0.06295511042828839, 0.07620130394986246, 0.07455739103608372, 0.07208274446915908, 0.07124002734318402, 0.07874065126264429, 0.0787078360263509, 0.07523861512349417, 0.057991796936536, 0.06380215377400877, 0.07329590271320208, 0.06556601840193221, 0.06498474932671139, 0.07153107547607107, 0.06396028304564916, 0.06468018901668715, 0.0736435369955345, 0.4381445996219636, 0.3240205350185206, 0.37152917631384685, 0.2841739249019982, 0.9384007309819193, 0.37581529366667143, 0.35753705452753726, 0.3009429684195156, 0.43470121858862, 0.13119102386991022, 0.14014372753283133, 0.142661074316914, 0.13039820535319946, 0.14951337601697445, 0.13363692602921673, 0.14547505664788618, 0.1555880380456458, 0.14749677686885587, 0.17585060403317443, 0.192606797112143, 0.18624166928190922, 0.1983624517239282, 0.2010778781305671, 0.1856796671652049, 0.20306304802046693, 0.21687096018735297, 0.19630399768740614, 0.11230648436623292, 0.12146680847815061, 0.13594458368393247, 0.11124688748518041, 0.12745489315900327, 0.1339666625201995, 0.1328094652337326, 0.13093439210585456, 0.12687124010678874, 0.14321699427338697, 0.11396603754902479, 0.15912765873815993, 0.11765634893812216, 0.12365201723359753, 0.11760180620707283, 0.12594460070182834, 0.11680762779153087, 0.11500393905128181, 0.06201906497255094, 0.056862929699661224, 0.05153171784292432, 0.055245021959115514, 0.058128998458432224, 0.0621501817646638, 0.08010598918381762, 0.06374754936798965, 0.07290891652102072, 0.127720819630456, 0.11811943728318619, 0.128405445916964, 0.12458908590269968, 0.12636249043326553, 0.12128190387665361, 0.12867824656983773, 0.11936334464577181, 0.11532223620205773, 0.018004469841982784, 0.022304172301763847, 0.014521256021949425, 0.023837816682728774, 0.024833728472887562, 0.027650581803586594, 0.06001506079832364, 0.018944089260160224, 0.01702530841451666, 0.08146802038326262, 0.08044214108190773, 0.07406032504652527, 0.07461439015749316, 0.08011067706638642, 0.07608540071148595, 0.07672700358851703, 0.07457866904854271, 0.07693015603974185, 0.23156489981150175, 0.2107729590355507, 0.2127927504966185, 0.21322682302667118, 0.21740932027653548, 0.2177127355576849, 0.2092196351266612, 0.20977924654468139, 0.20530549590104352, 0.06606200505613691, 0.06788456123337416, 0.08207215670441237, 0.05937720122419665, 0.06283772758525463, 0.06357215567788621, 0.05814884810861132, 0.06791911029246145, 0.06551517431644682, 0.13746026918048104, 0.15763222874424987, 0.1639222082767703, 0.14764372740591758, 0.15058609875545448, 0.15700772455235035, 0.15588261644249746, 0.1657933330548722, 0.12370096275685338, 0.17665156889663758, 0.1798442527592048, 0.17326500668855338, 0.18121792498539102, 0.17821544750439955, 0.18251166367291138, 0.19057892175991742, 0.17715283161976458, 0.1809947044722663, 0.13729635797794004, 0.12754368053563048, 0.1399559020458826, 0.13127050243248028, 0.1405836403161782, 0.1371363596502786, 0.1386417803033705, 0.13962764360802338, 0.14864947990672261, 0.16249838128514238, 0.15671740805487266, 0.1443127670869555, 0.14684089858745542, 0.1475225235447888, 0.15183567772788742, 0.15550212150762854, 0.15805979825952632, 0.15600655005703634, 0.19490032345187225, 0.18037043023768895, 0.1788337482020883, 0.16979599384575217, 0.1734151583543193, 0.17295233847365832, 0.17183273654527165, 0.17310488864285545, 0.17891284658758688, 0.16327209170754353, 0.2593330037480027, 0.17770319376546873, 0.1369164863506649, 0.15570407380363682, 0.1472769770675877, 0.23682775846551396, 0.23258324838722533, 0.1388318469031652, 0.13055237325504654, 0.1366976413792328, 0.1360578416967091, 0.20047022426959937, 0.21333089894417967, 0.14575686519758657, 0.16316140065768936, 0.18140423692532748, 0.1756627390780432, 0.17786408035301615, 0.19571831667930706, 0.1813268460570513, 0.18563244569086235, 0.19696551878820723, 0.1852766999614771, 0.19122999006665364, 0.18205187747966411, 0.17408203592309834, 0.056459645214209764, 0.060738854394902786, 0.06054125413415201, 0.053547291683954445, 0.05387794884797059, 0.055947096671244756, 0.05561913729514112, 0.04923929882652045, 0.05932694310254283]}, "mutation_prompt": null}
{"id": "2221ea20-4058-4629-8821-b66a732ea6bd", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.97\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        # Dynamic mutation factor with sinusoidal variation\n        return 0.5 + 0.3 * np.sin(np.pi * evaluations / self.budget)\n\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.3 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (1 - evaluations / self.budget)**0.5))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.1, self.dim), \n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            # Improved selection: Select best individuals\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = population[ranked_indices[:self.population_size]]\n            fitness = fitness[ranked_indices[:self.population_size]]\n\n        return best_solution", "name": "HybridDESA", "description": "Enhanced HybridDESA with dynamic mutation strategy and improved selection mechanism to improve convergence.", "configspace": "", "generation": 45, "fitness": 0.16087151294682958, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.13.", "error": "", "parent_id": "59dc2a07-ec35-49cd-891d-64baec0859eb", "metadata": {"aucs": [0.1924216243237581, 0.19757638743848438, 0.20937094772908926, 0.2110924877479302, 0.22109694094804977, 0.20651624833513105, 0.19266737046775795, 0.19559696654797143, 0.20259546922258065, 0.16325125537954677, 0.159299859094983, 0.15630646177509666, 0.15751168023858741, 0.186710202123043, 0.16058856509424058, 0.15864234024401636, 0.15914427589065394, 0.16355507416873172, 0.07571095417256657, 0.06388668584765889, 0.06755567715384514, 0.058508909723781866, 0.05882848641946181, 0.07278069657490427, 0.0723924348416164, 0.06663171787554767, 0.06879857544082624, 0.06479135026169047, 0.055434811523624505, 0.06340272968656502, 0.06934258819705663, 0.05885794644384901, 0.06205690474220105, 0.05457300351382022, 0.06619581437630384, 0.061362485165430525, 0.743775259057216, 0.5756701426472914, 0.6853263003447316, 0.9424829742126996, 0.9901362927094097, 0.584930608722499, 0.6135001482663005, 0.5946400549605879, 0.5938383267005474, 0.1329816184651823, 0.12919616961553637, 0.17287968522268382, 0.1323368676425114, 0.12403442419864208, 0.1229765518269813, 0.144620368182657, 0.14810595573744523, 0.15185709206873577, 0.20732622524977362, 0.15559627104667018, 0.18046796547168742, 0.19412192681268514, 0.17643813463342306, 0.18195208568648136, 0.2086108169533739, 0.2442471591640576, 0.19312878692199587, 0.11972882693382492, 0.11670951013705966, 0.11580389549835401, 0.11984801341931128, 0.13327271102523341, 0.125575841396657, 0.11443602482191872, 0.10610541069063906, 0.1134693224541039, 0.12340336677513919, 0.13869666446514806, 0.1319614109463002, 0.1141699591351869, 0.1337392601919224, 0.13191214329374013, 0.12987212996655817, 0.13751617369403812, 0.14465913709720812, 0.09274584144398046, 0.12014810810999721, 0.10043105552150755, 0.09980191440879227, 0.10520836532930555, 0.09795997703082393, 0.08751369288419142, 0.11086460113601171, 0.09415478725220183, 0.16095454954359267, 0.15674255602551734, 0.15915993299962083, 0.14999287093795233, 0.12487358902194379, 0.15497654120364202, 0.16295332339226276, 0.16581347180479356, 0.17441266801302113, 0.03526634062226763, 0.06915602520067099, 0.054843652588926095, 0.09475279122169411, 0.10635564075197801, 0.07753057759787352, 0.07707984696013914, 0.0681773101874793, 0.06704740836977219, 0.08515359796829547, 0.07872325654849133, 0.08568218738226474, 0.08212723197217497, 0.08507966058851724, 0.08183173421619216, 0.08092639725782569, 0.08493732223284389, 0.09248648369168444, 0.20705951060764194, 0.2170979668597134, 0.23002807809576575, 0.20240343714337528, 0.2150430933068025, 0.21128706992007495, 0.20352051839353713, 0.2059488272651534, 0.22904564096102975, 0.06272885732074407, 0.06785224366675324, 0.06472959201851192, 0.06171434300868073, 0.05999609843320053, 0.06779800691599125, 0.060932045411263736, 0.06464911154315722, 0.063868207698343, 0.15298862726842, 0.13835369518903828, 0.15523300949334173, 0.1834071687882347, 0.18763190834006604, 0.16410239773941793, 0.14618238946170536, 0.15716963964620356, 0.14657058587625615, 0.17760324425943075, 0.16739966660533467, 0.18414822440328826, 0.16719271074302267, 0.16971868936501033, 0.17364108126763256, 0.16951410654659527, 0.18580999444807744, 0.170447877388766, 0.1357792095904109, 0.1431579710596652, 0.13470573300629962, 0.13167793491160995, 0.13564392303268868, 0.12973164207570476, 0.1397156828794518, 0.1335514287082773, 0.14777729503195713, 0.15233665215081094, 0.14692200245138998, 0.1768017430780363, 0.15534197001069694, 0.14777888649739157, 0.16213972356111206, 0.16384387730456218, 0.15566939028775084, 0.15240625656016749, 0.16935306962028518, 0.17285966487889926, 0.17704472762652823, 0.1745598497562545, 0.17381681745009103, 0.16866940928506757, 0.18479902312169105, 0.17255152075845048, 0.17598518413958486, 0.1316704713026816, 0.23116168866193865, 0.1554120425394796, 0.16006870656020455, 0.1494957331773643, 0.1603399548043304, 0.14444503671849218, 0.1588090062523011, 0.13968746177824687, 0.1566689331640213, 0.32481475562595186, 0.1574796152467769, 0.19308146310115493, 0.16490325115606608, 0.1825335717929153, 0.15602300934412072, 0.15594447997316896, 0.2220834750576769, 0.1802482690030871, 0.1747869464510995, 0.18281788894074824, 0.17706818008347014, 0.18025621779547307, 0.18018423137218165, 0.21754627641499757, 0.1810685782732816, 0.17943425849466088, 0.04820052586542134, 0.05158938812633074, 0.05503107234558824, 0.0611135594737372, 0.05740548577450333, 0.05276604517953942, 0.05372028983362476, 0.05071128089561805, 0.0552581370877111]}, "mutation_prompt": null}
{"id": "f13d0729-ac17-41cb-935c-5c672675c10a", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.97\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.3 * (1 - evaluations / self.budget)\n\n    # Enhanced diversity with chaos maps\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.3 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (1 - evaluations / self.budget)**0.5))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.1, self.dim), \n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = population[ranked_indices[:self.population_size]]\n            fitness = fitness[ranked_indices[:self.population_size]]\n\n        return best_solution", "name": "HybridDESA", "description": "HybridDESA with enhanced diversity through chaos maps for better exploration and exploitation balance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "59dc2a07-ec35-49cd-891d-64baec0859eb", "metadata": {"aucs": [0.197577167422057, 0.20869322720538908, 0.1973740551827099, 0.21377331280496614, 0.21801139755842047, 0.2004637080560081, 0.2009361803098627, 0.20557339878789394, 0.19968590460089253, 0.1589272453880709, 0.15972383830720194, 0.17110111461888078, 0.16798177735646946, 0.1754049200427399, 0.174656388163152, 0.1672059352918548, 0.17286367850358753, 0.16658504741548208, 0.07459881044398464, 0.06057773456030224, 0.07754527989693505, 0.08475526626419527, 0.08081425439157541, 0.07262091475612598, 0.07798625634244671, 0.08797024956100974, 0.08208514997694494, 0.06808782214267717, 0.06191888442495819, 0.07413172068010643, 0.062231856802884455, 0.0566149736219439, 0.06334977852288282, 0.05875400854626145, 0.06688790743858786, 0.06303161784577604, 0.7882172902884284, 0.8289272811287576, 0.7684815558922026, 0.6168879154266469, 0.7535188154097752, 0.6128228448327597, 0.8088214732249621, 0.9767540943714939, 0.635618505511243, 0.12711822049004873, 0.13626445456208836, 0.1417846943524621, 0.1316891663208004, 0.13538442646394122, 0.13540965976175068, 0.14676577640511712, 0.146080082898701, 0.15249548074956798, 0.1684637240993332, 0.17128529265954762, 0.16581790461088752, 0.2054905652110678, 0.19054692847378063, 0.21175349125598875, 0.18908102498750223, 0.1849428065998392, 0.18733112739727853, 0.12125995506208687, 0.13194485090438302, 0.12741514393496567, 0.11243839209864159, 0.11973749442226256, 0.11734923207247994, 0.12209590890826638, 0.11467109696083899, 0.11625797991841813, 0.07078734203891379, 0.13195528057025263, 0.14661402256594502, 0.11371457625031267, 0.11596148397329031, 0.11736347565293659, 0.11527859825690989, 0.12213424099390702, 0.1403411992478354, 0.11829369303552484, 0.09661902870416872, 0.0978151830489089, 0.10721994344375452, 0.1312362608822969, 0.09371342421195972, 0.1079588619537073, 0.11456234893383554, 0.10817830441704479, 0.17193614114344669, 0.165285113634144, 0.17088937923502412, 0.130202178526171, 0.14024321251180172, 0.1519010092758366, 0.15633205884500656, 0.17141462409398844, 0.17077061720832698, 0.05220157568068384, 0.05359229623311512, 0.06128303693907855, 0.08205765330375236, 0.0806708474238188, 0.0672262581431241, 0.09537414351334605, 0.12425905417055949, 0.0684629466541039, 0.09103274949170315, 0.09284552121971645, 0.08433894980337531, 0.10182811385961399, 0.09287103769985938, 0.09109006852059975, 0.08413701969084453, 0.0917368711747577, 0.09286991335612127, 0.20399286885178303, 0.21351704034257535, 0.2107962384385993, 0.2250744469735686, 0.2070347715014862, 0.20778884613315285, 0.20796785041489352, 0.2168522299140272, 0.21065238934301378, 0.06301905617728809, 0.07770730049309116, 0.07953807131669377, 0.062401242421670444, 0.062486643156439814, 0.06146103256792412, 0.055487535617683714, 0.07260194001538145, 0.06185538916993227, 0.13263857843986315, 0.1808930677139533, 0.15787367791265328, 0.15489743037383852, 0.19830691091489305, 0.1555729270340247, 0.16714852697350924, 0.1621872312937026, 0.18333055071798976, 0.17876934780972353, 0.1886469700678256, 0.1784341050405448, 0.1860217194859618, 0.17923346420102793, 0.1787924522194546, 0.17403688993417255, 0.17347024523249444, 0.19986504823439677, 0.13755976217320787, 0.14201140862254158, 0.14088788814612274, 0.12954578487154844, 0.1421169100576355, 0.13775897847665297, 0.13720616627506954, 0.14495976963109902, 0.1458756822248115, 0.1578686781890205, 0.14902598862639538, 0.1401476487119051, 0.14659976955442255, 0.1642085301689149, 0.1547533403649186, 0.16791303114914935, 0.14599321894971706, 0.1523868617444627, 0.1695465748558359, 0.17051681310636835, 0.17339354661073103, 0.17499394330456342, 0.17086189069022728, 0.1745496286788064, 0.17193471388508696, 0.17674469057995523, 0.17453856999162742, 0.14580903068147455, 0.2491415313604396, 0.24801356472574754, 0.15229880887455416, 0.14314753048232487, 0.15710488490500174, 0.20511064480922148, 0.15666440216104494, 0.2766513229663278, 0.16028334874250227, 0.1271974068002628, 0.13285341794807848, 0.23027849560703728, 0.1829556749517539, 0.1409455290800795, 0.17900307509550206, 0.19377299022147332, 0.1499534944028823, 0.1899203870405125, 0.18244985048882034, 0.19697752796755363, 0.18150303331751638, 0.18217202348673367, 0.18578350360109397, 0.19742407334324408, 0.178914929416097, 0.20832483489778364, 0.06274432867584634, 0.06086286718485756, 0.05655980733177768, 0.057352182486843595, 0.05106817836274136, 0.05225032550779429, 0.04958115303176924, 0.060078043541649806, 0.05143858258744405]}, "mutation_prompt": null}
{"id": "ff4d3c1a-f4bb-4b4b-8a05-d60f7d471bee", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.97\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.3 * (1 - evaluations / self.budget)\n\n    # Enhanced diversity with chaos maps\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.3 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (1 - evaluations / self.budget)**0.5))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.1, self.dim), \n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = population[ranked_indices[:self.population_size]]\n            fitness = fitness[ranked_indices[:self.population_size]]\n\n        return best_solution", "name": "HybridDESA", "description": "HybridDESA with enhanced diversity through chaos maps for better exploration and exploitation balance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "59dc2a07-ec35-49cd-891d-64baec0859eb", "metadata": {"aucs": [0.197577167422057, 0.20869322720538908, 0.1973740551827099, 0.21377331280496614, 0.21801139755842047, 0.2004637080560081, 0.2009361803098627, 0.20557339878789394, 0.19968590460089253, 0.1589272453880709, 0.15972383830720194, 0.17110111461888078, 0.16798177735646946, 0.1754049200427399, 0.174656388163152, 0.1672059352918548, 0.17286367850358753, 0.16658504741548208, 0.07459881044398464, 0.06057773456030224, 0.07754527989693505, 0.08475526626419527, 0.08081425439157541, 0.07262091475612598, 0.07798625634244671, 0.08797024956100974, 0.08208514997694494, 0.06808782214267717, 0.06191888442495819, 0.07413172068010643, 0.062231856802884455, 0.0566149736219439, 0.06334977852288282, 0.05875400854626145, 0.06688790743858786, 0.06303161784577604, 0.7882172902884284, 0.8289272811287576, 0.7684815558922026, 0.6168879154266469, 0.7535188154097752, 0.6128228448327597, 0.8088214732249621, 0.9767540943714939, 0.635618505511243, 0.12711822049004873, 0.13626445456208836, 0.1417846943524621, 0.1316891663208004, 0.13538442646394122, 0.13540965976175068, 0.14676577640511712, 0.146080082898701, 0.15249548074956798, 0.1684637240993332, 0.17128529265954762, 0.16581790461088752, 0.2054905652110678, 0.19054692847378063, 0.21175349125598875, 0.18908102498750223, 0.1849428065998392, 0.18733112739727853, 0.12125995506208687, 0.13194485090438302, 0.12741514393496567, 0.11243839209864159, 0.11973749442226256, 0.11734923207247994, 0.12209590890826638, 0.11467109696083899, 0.11625797991841813, 0.07078734203891379, 0.13195528057025263, 0.14661402256594502, 0.11371457625031267, 0.11596148397329031, 0.11736347565293659, 0.11527859825690989, 0.12213424099390702, 0.1403411992478354, 0.11829369303552484, 0.09661902870416872, 0.0978151830489089, 0.10721994344375452, 0.1312362608822969, 0.09371342421195972, 0.1079588619537073, 0.11456234893383554, 0.10817830441704479, 0.17193614114344669, 0.165285113634144, 0.17088937923502412, 0.130202178526171, 0.14024321251180172, 0.1519010092758366, 0.15633205884500656, 0.17141462409398844, 0.17077061720832698, 0.05220157568068384, 0.05359229623311512, 0.06128303693907855, 0.08205765330375236, 0.0806708474238188, 0.0672262581431241, 0.09537414351334605, 0.12425905417055949, 0.0684629466541039, 0.09103274949170315, 0.09284552121971645, 0.08433894980337531, 0.10182811385961399, 0.09287103769985938, 0.09109006852059975, 0.08413701969084453, 0.0917368711747577, 0.09286991335612127, 0.20399286885178303, 0.21351704034257535, 0.2107962384385993, 0.2250744469735686, 0.2070347715014862, 0.20778884613315285, 0.20796785041489352, 0.2168522299140272, 0.21065238934301378, 0.06301905617728809, 0.07770730049309116, 0.07953807131669377, 0.062401242421670444, 0.062486643156439814, 0.06146103256792412, 0.055487535617683714, 0.07260194001538145, 0.06185538916993227, 0.13263857843986315, 0.1808930677139533, 0.15787367791265328, 0.15489743037383852, 0.19830691091489305, 0.1555729270340247, 0.16714852697350924, 0.1621872312937026, 0.18333055071798976, 0.17876934780972353, 0.1886469700678256, 0.1784341050405448, 0.1860217194859618, 0.17923346420102793, 0.1787924522194546, 0.17403688993417255, 0.17347024523249444, 0.19986504823439677, 0.13755976217320787, 0.14201140862254158, 0.14088788814612274, 0.12954578487154844, 0.1421169100576355, 0.13775897847665297, 0.13720616627506954, 0.14495976963109902, 0.1458756822248115, 0.1578686781890205, 0.14902598862639538, 0.1401476487119051, 0.14659976955442255, 0.1642085301689149, 0.1547533403649186, 0.16791303114914935, 0.14599321894971706, 0.1523868617444627, 0.1695465748558359, 0.17051681310636835, 0.17339354661073103, 0.17499394330456342, 0.17086189069022728, 0.1745496286788064, 0.17193471388508696, 0.17674469057995523, 0.17453856999162742, 0.14580903068147455, 0.2491415313604396, 0.24801356472574754, 0.15229880887455416, 0.14314753048232487, 0.15710488490500174, 0.20511064480922148, 0.15666440216104494, 0.2766513229663278, 0.16028334874250227, 0.1271974068002628, 0.13285341794807848, 0.23027849560703728, 0.1829556749517539, 0.1409455290800795, 0.17900307509550206, 0.19377299022147332, 0.1499534944028823, 0.1899203870405125, 0.18244985048882034, 0.19697752796755363, 0.18150303331751638, 0.18217202348673367, 0.18578350360109397, 0.19742407334324408, 0.178914929416097, 0.20832483489778364, 0.06274432867584634, 0.06086286718485756, 0.05655980733177768, 0.057352182486843595, 0.05106817836274136, 0.05225032550779429, 0.04958115303176924, 0.060078043541649806, 0.05143858258744405]}, "mutation_prompt": null}
{"id": "acd467c9-9464-446c-a11a-824e2bcb5de7", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.97\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.3 * (1 - evaluations / self.budget)\n\n    # Enhanced diversity with chaos maps\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.3 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (1 - evaluations / self.budget)**0.5))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.1, self.dim), \n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = population[ranked_indices[:self.population_size]]\n            fitness = fitness[ranked_indices[:self.population_size]]\n\n        return best_solution", "name": "HybridDESA", "description": "HybridDESA with enhanced diversity through chaos maps for better exploration and exploitation balance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "59dc2a07-ec35-49cd-891d-64baec0859eb", "metadata": {"aucs": [0.197577167422057, 0.20869322720538908, 0.1973740551827099, 0.21377331280496614, 0.21801139755842047, 0.2004637080560081, 0.2009361803098627, 0.20557339878789394, 0.19968590460089253, 0.1589272453880709, 0.15972383830720194, 0.17110111461888078, 0.16798177735646946, 0.1754049200427399, 0.174656388163152, 0.1672059352918548, 0.17286367850358753, 0.16658504741548208, 0.07459881044398464, 0.06057773456030224, 0.07754527989693505, 0.08475526626419527, 0.08081425439157541, 0.07262091475612598, 0.07798625634244671, 0.08797024956100974, 0.08208514997694494, 0.06808782214267717, 0.06191888442495819, 0.07413172068010643, 0.062231856802884455, 0.0566149736219439, 0.06334977852288282, 0.05875400854626145, 0.06688790743858786, 0.06303161784577604, 0.7882172902884284, 0.8289272811287576, 0.7684815558922026, 0.6168879154266469, 0.7535188154097752, 0.6128228448327597, 0.8088214732249621, 0.9767540943714939, 0.635618505511243, 0.12711822049004873, 0.13626445456208836, 0.1417846943524621, 0.1316891663208004, 0.13538442646394122, 0.13540965976175068, 0.14676577640511712, 0.146080082898701, 0.15249548074956798, 0.1684637240993332, 0.17128529265954762, 0.16581790461088752, 0.2054905652110678, 0.19054692847378063, 0.21175349125598875, 0.18908102498750223, 0.1849428065998392, 0.18733112739727853, 0.12125995506208687, 0.13194485090438302, 0.12741514393496567, 0.11243839209864159, 0.11973749442226256, 0.11734923207247994, 0.12209590890826638, 0.11467109696083899, 0.11625797991841813, 0.07078734203891379, 0.13195528057025263, 0.14661402256594502, 0.11371457625031267, 0.11596148397329031, 0.11736347565293659, 0.11527859825690989, 0.12213424099390702, 0.1403411992478354, 0.11829369303552484, 0.09661902870416872, 0.0978151830489089, 0.10721994344375452, 0.1312362608822969, 0.09371342421195972, 0.1079588619537073, 0.11456234893383554, 0.10817830441704479, 0.17193614114344669, 0.165285113634144, 0.17088937923502412, 0.130202178526171, 0.14024321251180172, 0.1519010092758366, 0.15633205884500656, 0.17141462409398844, 0.17077061720832698, 0.05220157568068384, 0.05359229623311512, 0.06128303693907855, 0.08205765330375236, 0.0806708474238188, 0.0672262581431241, 0.09537414351334605, 0.12425905417055949, 0.0684629466541039, 0.09103274949170315, 0.09284552121971645, 0.08433894980337531, 0.10182811385961399, 0.09287103769985938, 0.09109006852059975, 0.08413701969084453, 0.0917368711747577, 0.09286991335612127, 0.20399286885178303, 0.21351704034257535, 0.2107962384385993, 0.2250744469735686, 0.2070347715014862, 0.20778884613315285, 0.20796785041489352, 0.2168522299140272, 0.21065238934301378, 0.06301905617728809, 0.07770730049309116, 0.07953807131669377, 0.062401242421670444, 0.062486643156439814, 0.06146103256792412, 0.055487535617683714, 0.07260194001538145, 0.06185538916993227, 0.13263857843986315, 0.1808930677139533, 0.15787367791265328, 0.15489743037383852, 0.19830691091489305, 0.1555729270340247, 0.16714852697350924, 0.1621872312937026, 0.18333055071798976, 0.17876934780972353, 0.1886469700678256, 0.1784341050405448, 0.1860217194859618, 0.17923346420102793, 0.1787924522194546, 0.17403688993417255, 0.17347024523249444, 0.19986504823439677, 0.13755976217320787, 0.14201140862254158, 0.14088788814612274, 0.12954578487154844, 0.1421169100576355, 0.13775897847665297, 0.13720616627506954, 0.14495976963109902, 0.1458756822248115, 0.1578686781890205, 0.14902598862639538, 0.1401476487119051, 0.14659976955442255, 0.1642085301689149, 0.1547533403649186, 0.16791303114914935, 0.14599321894971706, 0.1523868617444627, 0.1695465748558359, 0.17051681310636835, 0.17339354661073103, 0.17499394330456342, 0.17086189069022728, 0.1745496286788064, 0.17193471388508696, 0.17674469057995523, 0.17453856999162742, 0.14580903068147455, 0.2491415313604396, 0.24801356472574754, 0.15229880887455416, 0.14314753048232487, 0.15710488490500174, 0.20511064480922148, 0.15666440216104494, 0.2766513229663278, 0.16028334874250227, 0.1271974068002628, 0.13285341794807848, 0.23027849560703728, 0.1829556749517539, 0.1409455290800795, 0.17900307509550206, 0.19377299022147332, 0.1499534944028823, 0.1899203870405125, 0.18244985048882034, 0.19697752796755363, 0.18150303331751638, 0.18217202348673367, 0.18578350360109397, 0.19742407334324408, 0.178914929416097, 0.20832483489778364, 0.06274432867584634, 0.06086286718485756, 0.05655980733177768, 0.057352182486843595, 0.05106817836274136, 0.05225032550779429, 0.04958115303176924, 0.060078043541649806, 0.05143858258744405]}, "mutation_prompt": null}
{"id": "62e82111-b3d2-4db9-90f7-8df321c983ca", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.97\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.3 * (1 - evaluations / self.budget)\n\n    # Enhanced diversity with chaos maps\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.3 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (1 - evaluations / self.budget)**0.5))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.1, self.dim), \n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = population[ranked_indices[:self.population_size]]\n            fitness = fitness[ranked_indices[:self.population_size]]\n\n        return best_solution", "name": "HybridDESA", "description": "HybridDESA with enhanced diversity through chaos maps for better exploration and exploitation balance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "59dc2a07-ec35-49cd-891d-64baec0859eb", "metadata": {"aucs": [0.197577167422057, 0.20869322720538908, 0.1973740551827099, 0.21377331280496614, 0.21801139755842047, 0.2004637080560081, 0.2009361803098627, 0.20557339878789394, 0.19968590460089253, 0.1589272453880709, 0.15972383830720194, 0.17110111461888078, 0.16798177735646946, 0.1754049200427399, 0.174656388163152, 0.1672059352918548, 0.17286367850358753, 0.16658504741548208, 0.07459881044398464, 0.06057773456030224, 0.07754527989693505, 0.08475526626419527, 0.08081425439157541, 0.07262091475612598, 0.07798625634244671, 0.08797024956100974, 0.08208514997694494, 0.06808782214267717, 0.06191888442495819, 0.07413172068010643, 0.062231856802884455, 0.0566149736219439, 0.06334977852288282, 0.05875400854626145, 0.06688790743858786, 0.06303161784577604, 0.7882172902884284, 0.8289272811287576, 0.7684815558922026, 0.6168879154266469, 0.7535188154097752, 0.6128228448327597, 0.8088214732249621, 0.9767540943714939, 0.635618505511243, 0.12711822049004873, 0.13626445456208836, 0.1417846943524621, 0.1316891663208004, 0.13538442646394122, 0.13540965976175068, 0.14676577640511712, 0.146080082898701, 0.15249548074956798, 0.1684637240993332, 0.17128529265954762, 0.16581790461088752, 0.2054905652110678, 0.19054692847378063, 0.21175349125598875, 0.18908102498750223, 0.1849428065998392, 0.18733112739727853, 0.12125995506208687, 0.13194485090438302, 0.12741514393496567, 0.11243839209864159, 0.11973749442226256, 0.11734923207247994, 0.12209590890826638, 0.11467109696083899, 0.11625797991841813, 0.07078734203891379, 0.13195528057025263, 0.14661402256594502, 0.11371457625031267, 0.11596148397329031, 0.11736347565293659, 0.11527859825690989, 0.12213424099390702, 0.1403411992478354, 0.11829369303552484, 0.09661902870416872, 0.0978151830489089, 0.10721994344375452, 0.1312362608822969, 0.09371342421195972, 0.1079588619537073, 0.11456234893383554, 0.10817830441704479, 0.17193614114344669, 0.165285113634144, 0.17088937923502412, 0.130202178526171, 0.14024321251180172, 0.1519010092758366, 0.15633205884500656, 0.17141462409398844, 0.17077061720832698, 0.05220157568068384, 0.05359229623311512, 0.06128303693907855, 0.08205765330375236, 0.0806708474238188, 0.0672262581431241, 0.09537414351334605, 0.12425905417055949, 0.0684629466541039, 0.09103274949170315, 0.09284552121971645, 0.08433894980337531, 0.10182811385961399, 0.09287103769985938, 0.09109006852059975, 0.08413701969084453, 0.0917368711747577, 0.09286991335612127, 0.20399286885178303, 0.21351704034257535, 0.2107962384385993, 0.2250744469735686, 0.2070347715014862, 0.20778884613315285, 0.20796785041489352, 0.2168522299140272, 0.21065238934301378, 0.06301905617728809, 0.07770730049309116, 0.07953807131669377, 0.062401242421670444, 0.062486643156439814, 0.06146103256792412, 0.055487535617683714, 0.07260194001538145, 0.06185538916993227, 0.13263857843986315, 0.1808930677139533, 0.15787367791265328, 0.15489743037383852, 0.19830691091489305, 0.1555729270340247, 0.16714852697350924, 0.1621872312937026, 0.18333055071798976, 0.17876934780972353, 0.1886469700678256, 0.1784341050405448, 0.1860217194859618, 0.17923346420102793, 0.1787924522194546, 0.17403688993417255, 0.17347024523249444, 0.19986504823439677, 0.13755976217320787, 0.14201140862254158, 0.14088788814612274, 0.12954578487154844, 0.1421169100576355, 0.13775897847665297, 0.13720616627506954, 0.14495976963109902, 0.1458756822248115, 0.1578686781890205, 0.14902598862639538, 0.1401476487119051, 0.14659976955442255, 0.1642085301689149, 0.1547533403649186, 0.16791303114914935, 0.14599321894971706, 0.1523868617444627, 0.1695465748558359, 0.17051681310636835, 0.17339354661073103, 0.17499394330456342, 0.17086189069022728, 0.1745496286788064, 0.17193471388508696, 0.17674469057995523, 0.17453856999162742, 0.14580903068147455, 0.2491415313604396, 0.24801356472574754, 0.15229880887455416, 0.14314753048232487, 0.15710488490500174, 0.20511064480922148, 0.15666440216104494, 0.2766513229663278, 0.16028334874250227, 0.1271974068002628, 0.13285341794807848, 0.23027849560703728, 0.1829556749517539, 0.1409455290800795, 0.17900307509550206, 0.19377299022147332, 0.1499534944028823, 0.1899203870405125, 0.18244985048882034, 0.19697752796755363, 0.18150303331751638, 0.18217202348673367, 0.18578350360109397, 0.19742407334324408, 0.178914929416097, 0.20832483489778364, 0.06274432867584634, 0.06086286718485756, 0.05655980733177768, 0.057352182486843595, 0.05106817836274136, 0.05225032550779429, 0.04958115303176924, 0.060078043541649806, 0.05143858258744405]}, "mutation_prompt": null}
{"id": "dca7b1cc-3068-48eb-9b2d-29cfcb4794b2", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.97\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.3 * (1 - evaluations / self.budget)\n\n    # Enhanced diversity with chaos maps\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.3 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (1 - evaluations / self.budget)**0.5))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def _levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * (2 ** ((beta - 1) / 2)))) ** (1/beta)\n        u = np.random.randn(size) * sigma\n        v = np.random.randn(size)\n        step = u / (np.abs(v) ** (1/beta))\n        return step\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             self._levy_flight(self.dim), \n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = population[ranked_indices[:self.population_size]]\n            fitness = fitness[ranked_indices[:self.population_size]]\n\n        return best_solution", "name": "HybridDESA", "description": "HybridDESA with enhanced local exploration using Lévy flights for better exploration of the search space.", "configspace": "", "generation": 50, "fitness": 0.16453578776771863, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.14.", "error": "", "parent_id": "59dc2a07-ec35-49cd-891d-64baec0859eb", "metadata": {"aucs": [0.21185199716205727, 0.21616284192454827, 0.19665501557786347, 0.2182023486980893, 0.20959033679656214, 0.21196373299653815, 0.2203720250478216, 0.2119967697886771, 0.19759178785597598, 0.17946746456251295, 0.16540821622508906, 0.16920147439836897, 0.1712799177905424, 0.16583871627573443, 0.16904940982878758, 0.14955805412504486, 0.1744544490698332, 0.17632699487495285, 0.07278481625082134, 0.0718212945592942, 0.07212418788610908, 0.07112654815760511, 0.07459128222982458, 0.07472364359180206, 0.0848843562674454, 0.07070185884339464, 0.07295274935578733, 0.0631001215057786, 0.05929112390146529, 0.07136198360615575, 0.06068368082692721, 0.0685766078521085, 0.0629224128525544, 0.07452327676310855, 0.064967589613256, 0.06498745674795459, 0.9588467880305732, 0.9142248310722467, 0.5754802916618633, 0.9132616210825966, 0.596459820973691, 0.6218098677818644, 0.7611643425278224, 0.5952042270279427, 0.9124416429504565, 0.13941522929085626, 0.1321405740444741, 0.14173991749309767, 0.12806063899877373, 0.1299861778020358, 0.11416888706678274, 0.16702052538908652, 0.1434925244712415, 0.15029768549018063, 0.18280696970723642, 0.18787520807945557, 0.1631468933091068, 0.20773155843421254, 0.20512032159528215, 0.1971769741883107, 0.23890709061610127, 0.1888264370662056, 0.18401595502760815, 0.1163878617793156, 0.12050100111908979, 0.11573908854901949, 0.10895031539538891, 0.12382256324644825, 0.1340337976479795, 0.11699216954897906, 0.12237238243318393, 0.11313446541122685, 0.11561600533762317, 0.13752217036337555, 0.08431354306412175, 0.11005266229787591, 0.12027335948591278, 0.12893033158826106, 0.10695134250965987, 0.10360438020126639, 0.11251121095608563, 0.13006531013545886, 0.10742830487428201, 0.09352230056805055, 0.1191345556094422, 0.11697539201140839, 0.1113130461324805, 0.09439615194807216, 0.07984457046583426, 0.13696367916874186, 0.15341365499091864, 0.15028235740060703, 0.1850906883195952, 0.13359147250034042, 0.1494015682154033, 0.14157260510889247, 0.1688623965672994, 0.17076713886484451, 0.1784512674216403, 0.05793547250196285, 0.04195285372606572, 0.0920975258762492, 0.09383573852018856, 0.08721618599814951, 0.0920409081333311, 0.0641743365502303, 0.06846752530042255, 0.07467303299145811, 0.09525312044954204, 0.08860087690397267, 0.0903162979062132, 0.08511626160114116, 0.09144305644680495, 0.0870279743550676, 0.09056944212264884, 0.0914915881579551, 0.09386753282051596, 0.21513263620548095, 0.23482608930988624, 0.20620310566344213, 0.20899039550339837, 0.2157385023231253, 0.22328789975525354, 0.19128458222076028, 0.21730115391598415, 0.24126256640958843, 0.06517122651873797, 0.07849792793632737, 0.07862799086899863, 0.058414165874946966, 0.06370731332732049, 0.06929611811283543, 0.06755639120588408, 0.060957286815963574, 0.060119997570996064, 0.16920505657953233, 0.14176393744499982, 0.19640998803622312, 0.14548629263881052, 0.1533095425491805, 0.13572462098301663, 0.15795560756186244, 0.13044398986787242, 0.147973874431382, 0.18411263209105433, 0.18293816905876514, 0.1864710476291105, 0.17585767176498535, 0.18991346809858733, 0.17396863449990474, 0.18246773231940527, 0.17340716457588756, 0.1785905604405561, 0.14681015731464064, 0.13422508039851289, 0.1399476786877507, 0.119855458763796, 0.1427649734908205, 0.13769895159098866, 0.14980203896998578, 0.13307513732150678, 0.14207637165811138, 0.17993207569124592, 0.18143437222293646, 0.18176793157290638, 0.16880114726232054, 0.1540743490319244, 0.15880397571595894, 0.14774792076359244, 0.16341670541118658, 0.1572943664948756, 0.19182822461495852, 0.17243163015393626, 0.16940923550916942, 0.1733789280653395, 0.16323648176585936, 0.17275859756796585, 0.16596026175740985, 0.16859963588883475, 0.1683068094217609, 0.16309110913453806, 0.2396272827453496, 0.1592305437955014, 0.13696393784759564, 0.13407129110432892, 0.1315562720284097, 0.15047714580199623, 0.1566495445804439, 0.24109074286150622, 0.13358635370242278, 0.1398700141080209, 0.13008481995596444, 0.18099129234975309, 0.12950448897723332, 0.1382812911961221, 0.2009210149671199, 0.1862572967759374, 0.20295118252341748, 0.18179136031107856, 0.18479069745000942, 0.1930324168741333, 0.19196475887016906, 0.18841129179990512, 0.19763556130747906, 0.1780428555634055, 0.1830509156327882, 0.18249292580147325, 0.05976678272093594, 0.05671857607888342, 0.06400882683056175, 0.04964436752629009, 0.06211657420516736, 0.06205679059719127, 0.05639668581873225, 0.06636035496115877, 0.05764456721430178]}, "mutation_prompt": null}
{"id": "b4d7ce2d-d72b-42dc-979b-fdd563d88196", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.97\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.3 * (1 - evaluations / self.budget)\n\n    # Enhanced diversity with chaos maps\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.3 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (1 - evaluations / self.budget)**0.5))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.1, self.dim), \n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = population[ranked_indices[:self.population_size]]\n            fitness = fitness[ranked_indices[:self.population_size]]\n\n        return best_solution", "name": "HybridDESA", "description": "HybridDESA with enhanced diversity through chaos maps for better exploration and exploitation balance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "59dc2a07-ec35-49cd-891d-64baec0859eb", "metadata": {"aucs": [0.197577167422057, 0.20869322720538908, 0.1973740551827099, 0.21377331280496614, 0.21801139755842047, 0.2004637080560081, 0.2009361803098627, 0.20557339878789394, 0.19968590460089253, 0.1589272453880709, 0.15972383830720194, 0.17110111461888078, 0.16798177735646946, 0.1754049200427399, 0.174656388163152, 0.1672059352918548, 0.17286367850358753, 0.16658504741548208, 0.07459881044398464, 0.06057773456030224, 0.07754527989693505, 0.08475526626419527, 0.08081425439157541, 0.07262091475612598, 0.07798625634244671, 0.08797024956100974, 0.08208514997694494, 0.06808782214267717, 0.06191888442495819, 0.07413172068010643, 0.062231856802884455, 0.0566149736219439, 0.06334977852288282, 0.05875400854626145, 0.06688790743858786, 0.06303161784577604, 0.7882172902884284, 0.8289272811287576, 0.7684815558922026, 0.6168879154266469, 0.7535188154097752, 0.6128228448327597, 0.8088214732249621, 0.9767540943714939, 0.635618505511243, 0.12711822049004873, 0.13626445456208836, 0.1417846943524621, 0.1316891663208004, 0.13538442646394122, 0.13540965976175068, 0.14676577640511712, 0.146080082898701, 0.15249548074956798, 0.1684637240993332, 0.17128529265954762, 0.16581790461088752, 0.2054905652110678, 0.19054692847378063, 0.21175349125598875, 0.18908102498750223, 0.1849428065998392, 0.18733112739727853, 0.12125995506208687, 0.13194485090438302, 0.12741514393496567, 0.11243839209864159, 0.11973749442226256, 0.11734923207247994, 0.12209590890826638, 0.11467109696083899, 0.11625797991841813, 0.07078734203891379, 0.13195528057025263, 0.14661402256594502, 0.11371457625031267, 0.11596148397329031, 0.11736347565293659, 0.11527859825690989, 0.12213424099390702, 0.1403411992478354, 0.11829369303552484, 0.09661902870416872, 0.0978151830489089, 0.10721994344375452, 0.1312362608822969, 0.09371342421195972, 0.1079588619537073, 0.11456234893383554, 0.10817830441704479, 0.17193614114344669, 0.165285113634144, 0.17088937923502412, 0.130202178526171, 0.14024321251180172, 0.1519010092758366, 0.15633205884500656, 0.17141462409398844, 0.17077061720832698, 0.05220157568068384, 0.05359229623311512, 0.06128303693907855, 0.08205765330375236, 0.0806708474238188, 0.0672262581431241, 0.09537414351334605, 0.12425905417055949, 0.0684629466541039, 0.09103274949170315, 0.09284552121971645, 0.08433894980337531, 0.10182811385961399, 0.09287103769985938, 0.09109006852059975, 0.08413701969084453, 0.0917368711747577, 0.09286991335612127, 0.20399286885178303, 0.21351704034257535, 0.2107962384385993, 0.2250744469735686, 0.2070347715014862, 0.20778884613315285, 0.20796785041489352, 0.2168522299140272, 0.21065238934301378, 0.06301905617728809, 0.07770730049309116, 0.07953807131669377, 0.062401242421670444, 0.062486643156439814, 0.06146103256792412, 0.055487535617683714, 0.07260194001538145, 0.06185538916993227, 0.13263857843986315, 0.1808930677139533, 0.15787367791265328, 0.15489743037383852, 0.19830691091489305, 0.1555729270340247, 0.16714852697350924, 0.1621872312937026, 0.18333055071798976, 0.17876934780972353, 0.1886469700678256, 0.1784341050405448, 0.1860217194859618, 0.17923346420102793, 0.1787924522194546, 0.17403688993417255, 0.17347024523249444, 0.19986504823439677, 0.13755976217320787, 0.14201140862254158, 0.14088788814612274, 0.12954578487154844, 0.1421169100576355, 0.13775897847665297, 0.13720616627506954, 0.14495976963109902, 0.1458756822248115, 0.1578686781890205, 0.14902598862639538, 0.1401476487119051, 0.14659976955442255, 0.1642085301689149, 0.1547533403649186, 0.16791303114914935, 0.14599321894971706, 0.1523868617444627, 0.1695465748558359, 0.17051681310636835, 0.17339354661073103, 0.17499394330456342, 0.17086189069022728, 0.1745496286788064, 0.17193471388508696, 0.17674469057995523, 0.17453856999162742, 0.14580903068147455, 0.2491415313604396, 0.24801356472574754, 0.15229880887455416, 0.14314753048232487, 0.15710488490500174, 0.20511064480922148, 0.15666440216104494, 0.2766513229663278, 0.16028334874250227, 0.1271974068002628, 0.13285341794807848, 0.23027849560703728, 0.1829556749517539, 0.1409455290800795, 0.17900307509550206, 0.19377299022147332, 0.1499534944028823, 0.1899203870405125, 0.18244985048882034, 0.19697752796755363, 0.18150303331751638, 0.18217202348673367, 0.18578350360109397, 0.19742407334324408, 0.178914929416097, 0.20832483489778364, 0.06274432867584634, 0.06086286718485756, 0.05655980733177768, 0.057352182486843595, 0.05106817836274136, 0.05225032550779429, 0.04958115303176924, 0.060078043541649806, 0.05143858258744405]}, "mutation_prompt": null}
{"id": "d5370951-a7b0-440a-b968-33d488afb1c3", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.97\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.3 * (1 - evaluations / self.budget)\n\n    # Enhanced diversity with chaos maps\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.3 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (1 - evaluations / self.budget)**0.5))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.1, self.dim), \n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = population[ranked_indices[:self.population_size]]\n            fitness = fitness[ranked_indices[:self.population_size]]\n\n        return best_solution", "name": "HybridDESA", "description": "HybridDESA with enhanced diversity through chaos maps for better exploration and exploitation balance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "59dc2a07-ec35-49cd-891d-64baec0859eb", "metadata": {"aucs": [0.197577167422057, 0.20869322720538908, 0.1973740551827099, 0.21377331280496614, 0.21801139755842047, 0.2004637080560081, 0.2009361803098627, 0.20557339878789394, 0.19968590460089253, 0.1589272453880709, 0.15972383830720194, 0.17110111461888078, 0.16798177735646946, 0.1754049200427399, 0.174656388163152, 0.1672059352918548, 0.17286367850358753, 0.16658504741548208, 0.07459881044398464, 0.06057773456030224, 0.07754527989693505, 0.08475526626419527, 0.08081425439157541, 0.07262091475612598, 0.07798625634244671, 0.08797024956100974, 0.08208514997694494, 0.06808782214267717, 0.06191888442495819, 0.07413172068010643, 0.062231856802884455, 0.0566149736219439, 0.06334977852288282, 0.05875400854626145, 0.06688790743858786, 0.06303161784577604, 0.7882172902884284, 0.8289272811287576, 0.7684815558922026, 0.6168879154266469, 0.7535188154097752, 0.6128228448327597, 0.8088214732249621, 0.9767540943714939, 0.635618505511243, 0.12711822049004873, 0.13626445456208836, 0.1417846943524621, 0.1316891663208004, 0.13538442646394122, 0.13540965976175068, 0.14676577640511712, 0.146080082898701, 0.15249548074956798, 0.1684637240993332, 0.17128529265954762, 0.16581790461088752, 0.2054905652110678, 0.19054692847378063, 0.21175349125598875, 0.18908102498750223, 0.1849428065998392, 0.18733112739727853, 0.12125995506208687, 0.13194485090438302, 0.12741514393496567, 0.11243839209864159, 0.11973749442226256, 0.11734923207247994, 0.12209590890826638, 0.11467109696083899, 0.11625797991841813, 0.07078734203891379, 0.13195528057025263, 0.14661402256594502, 0.11371457625031267, 0.11596148397329031, 0.11736347565293659, 0.11527859825690989, 0.12213424099390702, 0.1403411992478354, 0.11829369303552484, 0.09661902870416872, 0.0978151830489089, 0.10721994344375452, 0.1312362608822969, 0.09371342421195972, 0.1079588619537073, 0.11456234893383554, 0.10817830441704479, 0.17193614114344669, 0.165285113634144, 0.17088937923502412, 0.130202178526171, 0.14024321251180172, 0.1519010092758366, 0.15633205884500656, 0.17141462409398844, 0.17077061720832698, 0.05220157568068384, 0.05359229623311512, 0.06128303693907855, 0.08205765330375236, 0.0806708474238188, 0.0672262581431241, 0.09537414351334605, 0.12425905417055949, 0.0684629466541039, 0.09103274949170315, 0.09284552121971645, 0.08433894980337531, 0.10182811385961399, 0.09287103769985938, 0.09109006852059975, 0.08413701969084453, 0.0917368711747577, 0.09286991335612127, 0.20399286885178303, 0.21351704034257535, 0.2107962384385993, 0.2250744469735686, 0.2070347715014862, 0.20778884613315285, 0.20796785041489352, 0.2168522299140272, 0.21065238934301378, 0.06301905617728809, 0.07770730049309116, 0.07953807131669377, 0.062401242421670444, 0.062486643156439814, 0.06146103256792412, 0.055487535617683714, 0.07260194001538145, 0.06185538916993227, 0.13263857843986315, 0.1808930677139533, 0.15787367791265328, 0.15489743037383852, 0.19830691091489305, 0.1555729270340247, 0.16714852697350924, 0.1621872312937026, 0.18333055071798976, 0.17876934780972353, 0.1886469700678256, 0.1784341050405448, 0.1860217194859618, 0.17923346420102793, 0.1787924522194546, 0.17403688993417255, 0.17347024523249444, 0.19986504823439677, 0.13755976217320787, 0.14201140862254158, 0.14088788814612274, 0.12954578487154844, 0.1421169100576355, 0.13775897847665297, 0.13720616627506954, 0.14495976963109902, 0.1458756822248115, 0.1578686781890205, 0.14902598862639538, 0.1401476487119051, 0.14659976955442255, 0.1642085301689149, 0.1547533403649186, 0.16791303114914935, 0.14599321894971706, 0.1523868617444627, 0.1695465748558359, 0.17051681310636835, 0.17339354661073103, 0.17499394330456342, 0.17086189069022728, 0.1745496286788064, 0.17193471388508696, 0.17674469057995523, 0.17453856999162742, 0.14580903068147455, 0.2491415313604396, 0.24801356472574754, 0.15229880887455416, 0.14314753048232487, 0.15710488490500174, 0.20511064480922148, 0.15666440216104494, 0.2766513229663278, 0.16028334874250227, 0.1271974068002628, 0.13285341794807848, 0.23027849560703728, 0.1829556749517539, 0.1409455290800795, 0.17900307509550206, 0.19377299022147332, 0.1499534944028823, 0.1899203870405125, 0.18244985048882034, 0.19697752796755363, 0.18150303331751638, 0.18217202348673367, 0.18578350360109397, 0.19742407334324408, 0.178914929416097, 0.20832483489778364, 0.06274432867584634, 0.06086286718485756, 0.05655980733177768, 0.057352182486843595, 0.05106817836274136, 0.05225032550779429, 0.04958115303176924, 0.060078043541649806, 0.05143858258744405]}, "mutation_prompt": null}
{"id": "e8363d38-f9fd-4125-adbb-08f59f531d24", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.97\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.3 * (1 - evaluations / self.budget)\n\n    # Enhanced diversity with chaos maps\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.3 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (1 - evaluations / self.budget)**0.5))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.1, self.dim), \n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = population[ranked_indices[:self.population_size]]\n            fitness = fitness[ranked_indices[:self.population_size]]\n\n        return best_solution", "name": "HybridDESA", "description": "HybridDESA with enhanced diversity through chaos maps for better exploration and exploitation balance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "59dc2a07-ec35-49cd-891d-64baec0859eb", "metadata": {"aucs": [0.197577167422057, 0.20869322720538908, 0.1973740551827099, 0.21377331280496614, 0.21801139755842047, 0.2004637080560081, 0.2009361803098627, 0.20557339878789394, 0.19968590460089253, 0.1589272453880709, 0.15972383830720194, 0.17110111461888078, 0.16798177735646946, 0.1754049200427399, 0.174656388163152, 0.1672059352918548, 0.17286367850358753, 0.16658504741548208, 0.07459881044398464, 0.06057773456030224, 0.07754527989693505, 0.08475526626419527, 0.08081425439157541, 0.07262091475612598, 0.07798625634244671, 0.08797024956100974, 0.08208514997694494, 0.06808782214267717, 0.06191888442495819, 0.07413172068010643, 0.062231856802884455, 0.0566149736219439, 0.06334977852288282, 0.05875400854626145, 0.06688790743858786, 0.06303161784577604, 0.7882172902884284, 0.8289272811287576, 0.7684815558922026, 0.6168879154266469, 0.7535188154097752, 0.6128228448327597, 0.8088214732249621, 0.9767540943714939, 0.635618505511243, 0.12711822049004873, 0.13626445456208836, 0.1417846943524621, 0.1316891663208004, 0.13538442646394122, 0.13540965976175068, 0.14676577640511712, 0.146080082898701, 0.15249548074956798, 0.1684637240993332, 0.17128529265954762, 0.16581790461088752, 0.2054905652110678, 0.19054692847378063, 0.21175349125598875, 0.18908102498750223, 0.1849428065998392, 0.18733112739727853, 0.12125995506208687, 0.13194485090438302, 0.12741514393496567, 0.11243839209864159, 0.11973749442226256, 0.11734923207247994, 0.12209590890826638, 0.11467109696083899, 0.11625797991841813, 0.07078734203891379, 0.13195528057025263, 0.14661402256594502, 0.11371457625031267, 0.11596148397329031, 0.11736347565293659, 0.11527859825690989, 0.12213424099390702, 0.1403411992478354, 0.11829369303552484, 0.09661902870416872, 0.0978151830489089, 0.10721994344375452, 0.1312362608822969, 0.09371342421195972, 0.1079588619537073, 0.11456234893383554, 0.10817830441704479, 0.17193614114344669, 0.165285113634144, 0.17088937923502412, 0.130202178526171, 0.14024321251180172, 0.1519010092758366, 0.15633205884500656, 0.17141462409398844, 0.17077061720832698, 0.05220157568068384, 0.05359229623311512, 0.06128303693907855, 0.08205765330375236, 0.0806708474238188, 0.0672262581431241, 0.09537414351334605, 0.12425905417055949, 0.0684629466541039, 0.09103274949170315, 0.09284552121971645, 0.08433894980337531, 0.10182811385961399, 0.09287103769985938, 0.09109006852059975, 0.08413701969084453, 0.0917368711747577, 0.09286991335612127, 0.20399286885178303, 0.21351704034257535, 0.2107962384385993, 0.2250744469735686, 0.2070347715014862, 0.20778884613315285, 0.20796785041489352, 0.2168522299140272, 0.21065238934301378, 0.06301905617728809, 0.07770730049309116, 0.07953807131669377, 0.062401242421670444, 0.062486643156439814, 0.06146103256792412, 0.055487535617683714, 0.07260194001538145, 0.06185538916993227, 0.13263857843986315, 0.1808930677139533, 0.15787367791265328, 0.15489743037383852, 0.19830691091489305, 0.1555729270340247, 0.16714852697350924, 0.1621872312937026, 0.18333055071798976, 0.17876934780972353, 0.1886469700678256, 0.1784341050405448, 0.1860217194859618, 0.17923346420102793, 0.1787924522194546, 0.17403688993417255, 0.17347024523249444, 0.19986504823439677, 0.13755976217320787, 0.14201140862254158, 0.14088788814612274, 0.12954578487154844, 0.1421169100576355, 0.13775897847665297, 0.13720616627506954, 0.14495976963109902, 0.1458756822248115, 0.1578686781890205, 0.14902598862639538, 0.1401476487119051, 0.14659976955442255, 0.1642085301689149, 0.1547533403649186, 0.16791303114914935, 0.14599321894971706, 0.1523868617444627, 0.1695465748558359, 0.17051681310636835, 0.17339354661073103, 0.17499394330456342, 0.17086189069022728, 0.1745496286788064, 0.17193471388508696, 0.17674469057995523, 0.17453856999162742, 0.14580903068147455, 0.2491415313604396, 0.24801356472574754, 0.15229880887455416, 0.14314753048232487, 0.15710488490500174, 0.20511064480922148, 0.15666440216104494, 0.2766513229663278, 0.16028334874250227, 0.1271974068002628, 0.13285341794807848, 0.23027849560703728, 0.1829556749517539, 0.1409455290800795, 0.17900307509550206, 0.19377299022147332, 0.1499534944028823, 0.1899203870405125, 0.18244985048882034, 0.19697752796755363, 0.18150303331751638, 0.18217202348673367, 0.18578350360109397, 0.19742407334324408, 0.178914929416097, 0.20832483489778364, 0.06274432867584634, 0.06086286718485756, 0.05655980733177768, 0.057352182486843595, 0.05106817836274136, 0.05225032550779429, 0.04958115303176924, 0.060078043541649806, 0.05143858258744405]}, "mutation_prompt": null}
{"id": "d4185027-be16-408f-8181-3b76a1279e65", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.97\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.3 * (1 - evaluations / self.budget)\n\n    # Enhanced diversity with chaos maps\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.3 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (1 - evaluations / self.budget)**0.5))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.1, self.dim), \n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = population[ranked_indices[:self.population_size]]\n            fitness = fitness[ranked_indices[:self.population_size]]\n\n        return best_solution", "name": "HybridDESA", "description": "HybridDESA with enhanced diversity through chaos maps for better exploration and exploitation balance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "59dc2a07-ec35-49cd-891d-64baec0859eb", "metadata": {"aucs": [0.197577167422057, 0.20869322720538908, 0.1973740551827099, 0.21377331280496614, 0.21801139755842047, 0.2004637080560081, 0.2009361803098627, 0.20557339878789394, 0.19968590460089253, 0.1589272453880709, 0.15972383830720194, 0.17110111461888078, 0.16798177735646946, 0.1754049200427399, 0.174656388163152, 0.1672059352918548, 0.17286367850358753, 0.16658504741548208, 0.07459881044398464, 0.06057773456030224, 0.07754527989693505, 0.08475526626419527, 0.08081425439157541, 0.07262091475612598, 0.07798625634244671, 0.08797024956100974, 0.08208514997694494, 0.06808782214267717, 0.06191888442495819, 0.07413172068010643, 0.062231856802884455, 0.0566149736219439, 0.06334977852288282, 0.05875400854626145, 0.06688790743858786, 0.06303161784577604, 0.7882172902884284, 0.8289272811287576, 0.7684815558922026, 0.6168879154266469, 0.7535188154097752, 0.6128228448327597, 0.8088214732249621, 0.9767540943714939, 0.635618505511243, 0.12711822049004873, 0.13626445456208836, 0.1417846943524621, 0.1316891663208004, 0.13538442646394122, 0.13540965976175068, 0.14676577640511712, 0.146080082898701, 0.15249548074956798, 0.1684637240993332, 0.17128529265954762, 0.16581790461088752, 0.2054905652110678, 0.19054692847378063, 0.21175349125598875, 0.18908102498750223, 0.1849428065998392, 0.18733112739727853, 0.12125995506208687, 0.13194485090438302, 0.12741514393496567, 0.11243839209864159, 0.11973749442226256, 0.11734923207247994, 0.12209590890826638, 0.11467109696083899, 0.11625797991841813, 0.07078734203891379, 0.13195528057025263, 0.14661402256594502, 0.11371457625031267, 0.11596148397329031, 0.11736347565293659, 0.11527859825690989, 0.12213424099390702, 0.1403411992478354, 0.11829369303552484, 0.09661902870416872, 0.0978151830489089, 0.10721994344375452, 0.1312362608822969, 0.09371342421195972, 0.1079588619537073, 0.11456234893383554, 0.10817830441704479, 0.17193614114344669, 0.165285113634144, 0.17088937923502412, 0.130202178526171, 0.14024321251180172, 0.1519010092758366, 0.15633205884500656, 0.17141462409398844, 0.17077061720832698, 0.05220157568068384, 0.05359229623311512, 0.06128303693907855, 0.08205765330375236, 0.0806708474238188, 0.0672262581431241, 0.09537414351334605, 0.12425905417055949, 0.0684629466541039, 0.09103274949170315, 0.09284552121971645, 0.08433894980337531, 0.10182811385961399, 0.09287103769985938, 0.09109006852059975, 0.08413701969084453, 0.0917368711747577, 0.09286991335612127, 0.20399286885178303, 0.21351704034257535, 0.2107962384385993, 0.2250744469735686, 0.2070347715014862, 0.20778884613315285, 0.20796785041489352, 0.2168522299140272, 0.21065238934301378, 0.06301905617728809, 0.07770730049309116, 0.07953807131669377, 0.062401242421670444, 0.062486643156439814, 0.06146103256792412, 0.055487535617683714, 0.07260194001538145, 0.06185538916993227, 0.13263857843986315, 0.1808930677139533, 0.15787367791265328, 0.15489743037383852, 0.19830691091489305, 0.1555729270340247, 0.16714852697350924, 0.1621872312937026, 0.18333055071798976, 0.17876934780972353, 0.1886469700678256, 0.1784341050405448, 0.1860217194859618, 0.17923346420102793, 0.1787924522194546, 0.17403688993417255, 0.17347024523249444, 0.19986504823439677, 0.13755976217320787, 0.14201140862254158, 0.14088788814612274, 0.12954578487154844, 0.1421169100576355, 0.13775897847665297, 0.13720616627506954, 0.14495976963109902, 0.1458756822248115, 0.1578686781890205, 0.14902598862639538, 0.1401476487119051, 0.14659976955442255, 0.1642085301689149, 0.1547533403649186, 0.16791303114914935, 0.14599321894971706, 0.1523868617444627, 0.1695465748558359, 0.17051681310636835, 0.17339354661073103, 0.17499394330456342, 0.17086189069022728, 0.1745496286788064, 0.17193471388508696, 0.17674469057995523, 0.17453856999162742, 0.14580903068147455, 0.2491415313604396, 0.24801356472574754, 0.15229880887455416, 0.14314753048232487, 0.15710488490500174, 0.20511064480922148, 0.15666440216104494, 0.2766513229663278, 0.16028334874250227, 0.1271974068002628, 0.13285341794807848, 0.23027849560703728, 0.1829556749517539, 0.1409455290800795, 0.17900307509550206, 0.19377299022147332, 0.1499534944028823, 0.1899203870405125, 0.18244985048882034, 0.19697752796755363, 0.18150303331751638, 0.18217202348673367, 0.18578350360109397, 0.19742407334324408, 0.178914929416097, 0.20832483489778364, 0.06274432867584634, 0.06086286718485756, 0.05655980733177768, 0.057352182486843595, 0.05106817836274136, 0.05225032550779429, 0.04958115303176924, 0.060078043541649806, 0.05143858258744405]}, "mutation_prompt": null}
{"id": "5061b96c-305f-42b7-835b-9043df745134", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.97\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.3 * (1 - evaluations / self.budget)\n\n    # Enhanced diversity with chaos maps\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.3 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (1 - evaluations / self.budget)**0.5))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.1, self.dim), \n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = population[ranked_indices[:self.population_size]]\n            fitness = fitness[ranked_indices[:self.population_size]]\n\n        return best_solution", "name": "HybridDESA", "description": "HybridDESA with enhanced diversity through chaos maps for better exploration and exploitation balance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "59dc2a07-ec35-49cd-891d-64baec0859eb", "metadata": {"aucs": [0.197577167422057, 0.20869322720538908, 0.1973740551827099, 0.21377331280496614, 0.21801139755842047, 0.2004637080560081, 0.2009361803098627, 0.20557339878789394, 0.19968590460089253, 0.1589272453880709, 0.15972383830720194, 0.17110111461888078, 0.16798177735646946, 0.1754049200427399, 0.174656388163152, 0.1672059352918548, 0.17286367850358753, 0.16658504741548208, 0.07459881044398464, 0.06057773456030224, 0.07754527989693505, 0.08475526626419527, 0.08081425439157541, 0.07262091475612598, 0.07798625634244671, 0.08797024956100974, 0.08208514997694494, 0.06808782214267717, 0.06191888442495819, 0.07413172068010643, 0.062231856802884455, 0.0566149736219439, 0.06334977852288282, 0.05875400854626145, 0.06688790743858786, 0.06303161784577604, 0.7882172902884284, 0.8289272811287576, 0.7684815558922026, 0.6168879154266469, 0.7535188154097752, 0.6128228448327597, 0.8088214732249621, 0.9767540943714939, 0.635618505511243, 0.12711822049004873, 0.13626445456208836, 0.1417846943524621, 0.1316891663208004, 0.13538442646394122, 0.13540965976175068, 0.14676577640511712, 0.146080082898701, 0.15249548074956798, 0.1684637240993332, 0.17128529265954762, 0.16581790461088752, 0.2054905652110678, 0.19054692847378063, 0.21175349125598875, 0.18908102498750223, 0.1849428065998392, 0.18733112739727853, 0.12125995506208687, 0.13194485090438302, 0.12741514393496567, 0.11243839209864159, 0.11973749442226256, 0.11734923207247994, 0.12209590890826638, 0.11467109696083899, 0.11625797991841813, 0.07078734203891379, 0.13195528057025263, 0.14661402256594502, 0.11371457625031267, 0.11596148397329031, 0.11736347565293659, 0.11527859825690989, 0.12213424099390702, 0.1403411992478354, 0.11829369303552484, 0.09661902870416872, 0.0978151830489089, 0.10721994344375452, 0.1312362608822969, 0.09371342421195972, 0.1079588619537073, 0.11456234893383554, 0.10817830441704479, 0.17193614114344669, 0.165285113634144, 0.17088937923502412, 0.130202178526171, 0.14024321251180172, 0.1519010092758366, 0.15633205884500656, 0.17141462409398844, 0.17077061720832698, 0.05220157568068384, 0.05359229623311512, 0.06128303693907855, 0.08205765330375236, 0.0806708474238188, 0.0672262581431241, 0.09537414351334605, 0.12425905417055949, 0.0684629466541039, 0.09103274949170315, 0.09284552121971645, 0.08433894980337531, 0.10182811385961399, 0.09287103769985938, 0.09109006852059975, 0.08413701969084453, 0.0917368711747577, 0.09286991335612127, 0.20399286885178303, 0.21351704034257535, 0.2107962384385993, 0.2250744469735686, 0.2070347715014862, 0.20778884613315285, 0.20796785041489352, 0.2168522299140272, 0.21065238934301378, 0.06301905617728809, 0.07770730049309116, 0.07953807131669377, 0.062401242421670444, 0.062486643156439814, 0.06146103256792412, 0.055487535617683714, 0.07260194001538145, 0.06185538916993227, 0.13263857843986315, 0.1808930677139533, 0.15787367791265328, 0.15489743037383852, 0.19830691091489305, 0.1555729270340247, 0.16714852697350924, 0.1621872312937026, 0.18333055071798976, 0.17876934780972353, 0.1886469700678256, 0.1784341050405448, 0.1860217194859618, 0.17923346420102793, 0.1787924522194546, 0.17403688993417255, 0.17347024523249444, 0.19986504823439677, 0.13755976217320787, 0.14201140862254158, 0.14088788814612274, 0.12954578487154844, 0.1421169100576355, 0.13775897847665297, 0.13720616627506954, 0.14495976963109902, 0.1458756822248115, 0.1578686781890205, 0.14902598862639538, 0.1401476487119051, 0.14659976955442255, 0.1642085301689149, 0.1547533403649186, 0.16791303114914935, 0.14599321894971706, 0.1523868617444627, 0.1695465748558359, 0.17051681310636835, 0.17339354661073103, 0.17499394330456342, 0.17086189069022728, 0.1745496286788064, 0.17193471388508696, 0.17674469057995523, 0.17453856999162742, 0.14580903068147455, 0.2491415313604396, 0.24801356472574754, 0.15229880887455416, 0.14314753048232487, 0.15710488490500174, 0.20511064480922148, 0.15666440216104494, 0.2766513229663278, 0.16028334874250227, 0.1271974068002628, 0.13285341794807848, 0.23027849560703728, 0.1829556749517539, 0.1409455290800795, 0.17900307509550206, 0.19377299022147332, 0.1499534944028823, 0.1899203870405125, 0.18244985048882034, 0.19697752796755363, 0.18150303331751638, 0.18217202348673367, 0.18578350360109397, 0.19742407334324408, 0.178914929416097, 0.20832483489778364, 0.06274432867584634, 0.06086286718485756, 0.05655980733177768, 0.057352182486843595, 0.05106817836274136, 0.05225032550779429, 0.04958115303176924, 0.060078043541649806, 0.05143858258744405]}, "mutation_prompt": null}
{"id": "aeaba5c2-9bc9-4b6b-a94b-463afb78182f", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.97\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.3 * (1 - evaluations / self.budget)\n\n    # Enhanced diversity with chaos maps\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.3 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (1 - evaluations / self.budget)**0.5))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.1, self.dim), \n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = population[ranked_indices[:self.population_size]]\n            fitness = fitness[ranked_indices[:self.population_size]]\n\n        return best_solution", "name": "HybridDESA", "description": "HybridDESA with enhanced diversity through chaos maps for better exploration and exploitation balance.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "59dc2a07-ec35-49cd-891d-64baec0859eb", "metadata": {"aucs": [0.197577167422057, 0.20869322720538908, 0.1973740551827099, 0.21377331280496614, 0.21801139755842047, 0.2004637080560081, 0.2009361803098627, 0.20557339878789394, 0.19968590460089253, 0.1589272453880709, 0.15972383830720194, 0.17110111461888078, 0.16798177735646946, 0.1754049200427399, 0.174656388163152, 0.1672059352918548, 0.17286367850358753, 0.16658504741548208, 0.07459881044398464, 0.06057773456030224, 0.07754527989693505, 0.08475526626419527, 0.08081425439157541, 0.07262091475612598, 0.07798625634244671, 0.08797024956100974, 0.08208514997694494, 0.06808782214267717, 0.06191888442495819, 0.07413172068010643, 0.062231856802884455, 0.0566149736219439, 0.06334977852288282, 0.05875400854626145, 0.06688790743858786, 0.06303161784577604, 0.7882172902884284, 0.8289272811287576, 0.7684815558922026, 0.6168879154266469, 0.7535188154097752, 0.6128228448327597, 0.8088214732249621, 0.9767540943714939, 0.635618505511243, 0.12711822049004873, 0.13626445456208836, 0.1417846943524621, 0.1316891663208004, 0.13538442646394122, 0.13540965976175068, 0.14676577640511712, 0.146080082898701, 0.15249548074956798, 0.1684637240993332, 0.17128529265954762, 0.16581790461088752, 0.2054905652110678, 0.19054692847378063, 0.21175349125598875, 0.18908102498750223, 0.1849428065998392, 0.18733112739727853, 0.12125995506208687, 0.13194485090438302, 0.12741514393496567, 0.11243839209864159, 0.11973749442226256, 0.11734923207247994, 0.12209590890826638, 0.11467109696083899, 0.11625797991841813, 0.07078734203891379, 0.13195528057025263, 0.14661402256594502, 0.11371457625031267, 0.11596148397329031, 0.11736347565293659, 0.11527859825690989, 0.12213424099390702, 0.1403411992478354, 0.11829369303552484, 0.09661902870416872, 0.0978151830489089, 0.10721994344375452, 0.1312362608822969, 0.09371342421195972, 0.1079588619537073, 0.11456234893383554, 0.10817830441704479, 0.17193614114344669, 0.165285113634144, 0.17088937923502412, 0.130202178526171, 0.14024321251180172, 0.1519010092758366, 0.15633205884500656, 0.17141462409398844, 0.17077061720832698, 0.05220157568068384, 0.05359229623311512, 0.06128303693907855, 0.08205765330375236, 0.0806708474238188, 0.0672262581431241, 0.09537414351334605, 0.12425905417055949, 0.0684629466541039, 0.09103274949170315, 0.09284552121971645, 0.08433894980337531, 0.10182811385961399, 0.09287103769985938, 0.09109006852059975, 0.08413701969084453, 0.0917368711747577, 0.09286991335612127, 0.20399286885178303, 0.21351704034257535, 0.2107962384385993, 0.2250744469735686, 0.2070347715014862, 0.20778884613315285, 0.20796785041489352, 0.2168522299140272, 0.21065238934301378, 0.06301905617728809, 0.07770730049309116, 0.07953807131669377, 0.062401242421670444, 0.062486643156439814, 0.06146103256792412, 0.055487535617683714, 0.07260194001538145, 0.06185538916993227, 0.13263857843986315, 0.1808930677139533, 0.15787367791265328, 0.15489743037383852, 0.19830691091489305, 0.1555729270340247, 0.16714852697350924, 0.1621872312937026, 0.18333055071798976, 0.17876934780972353, 0.1886469700678256, 0.1784341050405448, 0.1860217194859618, 0.17923346420102793, 0.1787924522194546, 0.17403688993417255, 0.17347024523249444, 0.19986504823439677, 0.13755976217320787, 0.14201140862254158, 0.14088788814612274, 0.12954578487154844, 0.1421169100576355, 0.13775897847665297, 0.13720616627506954, 0.14495976963109902, 0.1458756822248115, 0.1578686781890205, 0.14902598862639538, 0.1401476487119051, 0.14659976955442255, 0.1642085301689149, 0.1547533403649186, 0.16791303114914935, 0.14599321894971706, 0.1523868617444627, 0.1695465748558359, 0.17051681310636835, 0.17339354661073103, 0.17499394330456342, 0.17086189069022728, 0.1745496286788064, 0.17193471388508696, 0.17674469057995523, 0.17453856999162742, 0.14580903068147455, 0.2491415313604396, 0.24801356472574754, 0.15229880887455416, 0.14314753048232487, 0.15710488490500174, 0.20511064480922148, 0.15666440216104494, 0.2766513229663278, 0.16028334874250227, 0.1271974068002628, 0.13285341794807848, 0.23027849560703728, 0.1829556749517539, 0.1409455290800795, 0.17900307509550206, 0.19377299022147332, 0.1499534944028823, 0.1899203870405125, 0.18244985048882034, 0.19697752796755363, 0.18150303331751638, 0.18217202348673367, 0.18578350360109397, 0.19742407334324408, 0.178914929416097, 0.20832483489778364, 0.06274432867584634, 0.06086286718485756, 0.05655980733177768, 0.057352182486843595, 0.05106817836274136, 0.05225032550779429, 0.04958115303176924, 0.060078043541649806, 0.05143858258744405]}, "mutation_prompt": null}
{"id": "dbd95bdd-188d-4833-81a4-83e68dd09594", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.95  # Reduced cooling rate for slower temperature decrease\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)  # Increased adaptation range\n\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.3 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (1 - evaluations / self.budget)**0.5))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.1, self.dim), \n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = population[ranked_indices[:self.population_size]]\n            fitness = fitness[ranked_indices[:self.population_size]]\n\n        return best_solution", "name": "HybridDESA", "description": "Improved HybridDESA with adaptive mutation factor and temperature scaling for enhanced exploration-exploitation balance.", "configspace": "", "generation": 57, "fitness": 0.20203381321131225, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.16.", "error": "", "parent_id": "59dc2a07-ec35-49cd-891d-64baec0859eb", "metadata": {"aucs": [0.286851493699115, 0.28360691309449837, 0.2966150706643059, 0.2912077760271926, 0.3104092569759894, 0.2912196378431028, 0.2975346672303877, 0.2892994094102882, 0.29818349717324877, 0.2529673968649647, 0.2488874278058837, 0.25443674755118617, 0.2420428507711314, 0.2630657778249229, 0.2567537591023441, 0.2520480674604926, 0.2590955978819216, 0.2531524724413112, 0.08241416252331979, 0.09230591795232157, 0.08094133063632103, 0.07913022768456868, 0.08073471420711054, 0.07457670921712656, 0.07875622029294915, 0.08551895456572534, 0.12392439965748236, 0.074004172501422, 0.07778630357547645, 0.06986667834515359, 0.07583311848497065, 0.06577930819760713, 0.07847583585740525, 0.11719428110134344, 0.07823327356596343, 0.07746824328023738, 0.7166330789997972, 0.851371879812479, 0.9089455948564618, 0.8271642259893173, 0.9723410698359263, 0.9329538451679165, 0.8467481914961019, 0.8441670640744945, 0.7324914746708957, 0.21473030595953602, 0.21061697999808915, 0.21058023971290907, 0.20715466167040208, 0.21084674432163297, 0.20603889281195875, 0.23395484786399845, 0.21793487655199917, 0.20927955251287922, 0.3383714415423731, 0.3794114397968703, 0.36264304238657774, 0.3872007834533119, 0.35906447887222437, 0.3387686099901933, 0.37773651109034245, 0.34274247227820964, 0.3261127893173311, 0.14195246737701495, 0.14645792838696292, 0.17365905516450275, 0.20846495066357285, 0.16833729778184225, 0.14315914275564956, 0.15421497855301092, 0.13043096221601014, 0.14759275589515541, 0.13430995820266778, 0.1927107948379213, 0.17217398669465056, 0.16244627048309246, 0.18610907985845992, 0.15469334367147314, 0.14570681047675682, 0.16975350439376546, 0.14804169843755777, 0.1385043706364829, 0.09569866023062112, 0.10735333559713578, 0.12086807654285348, 0.12240485854008964, 0.11896921937781335, 0.13489015702536777, 0.12208839465753285, 0.12147791220816728, 0.1887725801324165, 0.2039280033839892, 0.2100074872846851, 0.19156432833174886, 0.2023990080759348, 0.21063723956633473, 0.21723028149046364, 0.2208333642931375, 0.2342180401021341, 0.07235494389332997, 0.04803676821221092, 0.029736148845739496, 0.07049886075196443, 0.0664491729378065, 0.06911002312220826, 0.06726229700364916, 0.04531066539530726, 0.05663991171911931, 0.1448638256475162, 0.14018894547710659, 0.13206250879398618, 0.13639309511252684, 0.15132098081107326, 0.14378833146179637, 0.14830807428296777, 0.1325982568118499, 0.1443186841066617, 0.2756985278057509, 0.2683543173586801, 0.27517073177268614, 0.276451034038817, 0.2785469404891846, 0.2842718160832325, 0.2724840825069661, 0.2825899246279143, 0.2788697306498561, 0.07849218995119522, 0.08204907011266116, 0.08150845547661834, 0.07746037618851842, 0.06211233557650542, 0.06682268687338311, 0.07300634586506782, 0.07015600519041909, 0.06607072004289949, 0.14742968195229045, 0.16258306274692835, 0.16492111958357802, 0.14778456428661702, 0.17551592296457907, 0.16589322573690457, 0.15089585414816153, 0.17128908934102616, 0.18334354497445415, 0.23304394620557523, 0.22819851046345052, 0.22435799694889236, 0.22419419081448866, 0.22847967362773725, 0.23036128197439953, 0.24404305116750102, 0.2375070764327355, 0.23898078359816122, 0.17242448617351025, 0.17920453512621004, 0.17728159311336844, 0.1743889112048992, 0.16429103662440336, 0.16469674733525486, 0.17989071092113718, 0.19393352441319345, 0.1782868558508821, 0.1699239954698194, 0.16599505526265257, 0.1473465572933884, 0.1624000096722531, 0.14911238945523564, 0.15704426967396645, 0.16531847573482705, 0.18881585811124268, 0.15400160544552055, 0.1663454627697336, 0.17205547464762327, 0.17241561447695153, 0.18802365233613005, 0.16430630697518522, 0.17516921501371885, 0.17799156192640786, 0.19584673028959, 0.18346552963842966, 0.14376037610199421, 0.1525604982602886, 0.2722581198976649, 0.15104109615859074, 0.16090304591097304, 0.15569000076368333, 0.15211379980042417, 0.24911484026584607, 0.2443032832576011, 0.160788418989964, 0.1444891178984401, 0.17558022861899136, 0.2600278514220308, 0.14834721373540194, 0.14623960845012207, 0.1701212364609178, 0.20289851083714605, 0.17100702209557928, 0.19040760559837, 0.17942567484969896, 0.17842525853104785, 0.18423791523750288, 0.18292564718654492, 0.2073141218215956, 0.18400112734898189, 0.18932835655685065, 0.18696596841968982, 0.051266938527038675, 0.06097473079515292, 0.05568542955510003, 0.06313438558135198, 0.05783199971786945, 0.05637666237513039, 0.05979652229171095, 0.05421294923701647, 0.059205494336949105]}, "mutation_prompt": null}
{"id": "fe471661-83b6-4f20-9800-f9b37e1519d8", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.95\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x**2))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.35 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (1 - evaluations / self.budget)**0.5))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.1, self.dim), \n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = population[ranked_indices[:self.population_size]]\n            fitness = fitness[ranked_indices[:self.population_size]]\n\n        return best_solution", "name": "HybridDESA", "description": "Refined HybridDESA with enhanced chaotic initialization and dynamic crossover rate adjustment for improved convergence.", "configspace": "", "generation": 58, "fitness": 0.20797019858547697, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.17.", "error": "", "parent_id": "dbd95bdd-188d-4833-81a4-83e68dd09594", "metadata": {"aucs": [0.2770187529309198, 0.26787602177142467, 0.28336658827129846, 0.2884545002430081, 0.29113605036304413, 0.2873880919313718, 0.28194970586921764, 0.2929582803039915, 0.30036843783274736, 0.24386061614093069, 0.2578717431471562, 0.25470637603278035, 0.24882320009026393, 0.2555745819843118, 0.2473258942299157, 0.26805172171554204, 0.26236011492579314, 0.24536610067122466, 0.1272822956175239, 0.08154385561707678, 0.09680141947225651, 0.08846919137727005, 0.07715501894874288, 0.0736636673398462, 0.08206691981345071, 0.07320418402380457, 0.08521918649289095, 0.0674140783363869, 0.07465577048156224, 0.09999870845110559, 0.08188797872085474, 0.08877009582970763, 0.08093736973943721, 0.0775553358074601, 0.07490529677374902, 0.07093094395841204, 0.9416738573465391, 0.920348732546589, 0.8795838466043651, 0.9313062642661573, 0.9009686522423297, 0.9009468272968262, 0.9336317894835042, 0.9762667149166918, 0.8735521423180275, 0.20546744155092733, 0.2060385318208674, 0.21002804635956795, 0.20524807093284303, 0.19702258096806158, 0.19655730642666025, 0.22263489439690265, 0.24692779368941498, 0.22588499972157683, 0.34997757743910807, 0.3556287807565244, 0.3437637329047808, 0.34740209578994385, 0.36708351716625176, 0.34366449151583345, 0.32443452876894974, 0.36065321934067207, 0.34695861500057856, 0.2004243691692308, 0.15976539449633487, 0.1427940621895346, 0.1676363119163201, 0.1539386007125091, 0.1700307177424797, 0.2338499395686211, 0.18257123897469185, 0.15646125020208623, 0.14240396129833788, 0.18685270635242368, 0.1200888783433578, 0.1491715609782266, 0.1426485344653895, 0.17531636437582254, 0.19506017964819067, 0.1451610204470749, 0.18393369549701255, 0.15112741023472975, 0.15165336991932687, 0.1490377708508458, 0.14956301499533275, 0.14550096623746722, 0.13050086934459393, 0.15121620365718413, 0.12834569471896162, 0.1494719754483107, 0.2242522284306131, 0.23862358095165315, 0.20895432386812363, 0.20432292415882325, 0.20561530088960567, 0.20734083831503003, 0.23163866972507485, 0.20940286230155758, 0.2277329758935428, 0.051952745234634445, 0.05873502005341724, 0.05626905149085959, 0.08207655871673158, 0.11639210115840504, 0.09518668499467509, 0.04423629493933845, 0.06439210701768061, 0.06644267696541051, 0.1384603544148707, 0.12799242065033145, 0.14305600544239627, 0.14968854981393342, 0.15866355224642104, 0.14403064818665645, 0.14681592058403525, 0.147211839804549, 0.16174057468340908, 0.2696280915897935, 0.28176697619959357, 0.27272162439509107, 0.2942558255980705, 0.2826691401952991, 0.2853759693763718, 0.26309238640452604, 0.27343019604730256, 0.2745542416856047, 0.07880054219702892, 0.07024897402989949, 0.07492842626166929, 0.074944291286832, 0.06719091467372196, 0.06589435107234076, 0.07115630168603237, 0.07241053102655803, 0.06238179095517449, 0.16102103087562913, 0.14386557053926952, 0.14391449614218377, 0.16512079727356976, 0.16378984588140444, 0.13996660870020283, 0.20145444837553905, 0.18144686035028734, 0.15061525582203272, 0.23259612493342796, 0.22614278924601727, 0.21772844420772164, 0.21709376833253513, 0.22207423309494212, 0.22631424559486157, 0.24243742809903468, 0.23765305790630664, 0.2390941704851297, 0.19438561157484358, 0.17997365232688478, 0.19176172559330285, 0.18198633984934343, 0.17591076252365023, 0.19220260252727261, 0.20639012164736792, 0.18393393011056458, 0.1827201311301443, 0.1711048839834468, 0.1570887871009039, 0.16489368873227483, 0.15777949089238097, 0.16416774012710866, 0.16632256683542468, 0.1480373001733466, 0.14913390768121304, 0.1552048037949848, 0.16970837006710482, 0.20060400775866294, 0.20373421407682124, 0.1870400105177128, 0.16536015258523817, 0.1707032911525984, 0.17527863284787693, 0.1839554087024693, 0.16940244978608476, 0.14291703387892796, 0.14232419795660567, 0.17206012093666834, 0.14728111192868076, 0.31614632710302726, 0.15934606352330904, 0.3282582759416691, 0.14863459665533352, 0.14791026067030977, 0.13730883128131277, 0.16538253758003651, 0.13814973838722255, 0.12008280155529483, 0.30842216277693746, 0.24859425500985277, 0.20596260386837728, 0.18920711645068555, 0.18770513943026346, 0.1781216985978703, 0.19426675505396784, 0.18088485539206745, 0.20560813658793564, 0.1748683943143975, 0.17867285072984673, 0.19407038606877913, 0.19258060059066506, 0.19382905150216256, 0.0544699227266785, 0.05978126176520471, 0.06399209362504477, 0.06194260120301276, 0.06080335327219688, 0.061146373700409096, 0.055397784777215575, 0.05766572009311499, 0.05487752534475243]}, "mutation_prompt": null}
{"id": "2617f172-201e-4cb0-8410-66c4aa712154", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.95\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x**2))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.35 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (1 - evaluations / self.budget)**0.5))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.1, self.dim), \n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = population[ranked_indices[:self.population_size]]\n            fitness = fitness[ranked_indices[:self.population_size]]\n\n        return best_solution", "name": "HybridDESA", "description": "Refined HybridDESA with enhanced chaotic initialization and dynamic crossover rate adjustment for improved convergence.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fe471661-83b6-4f20-9800-f9b37e1519d8", "metadata": {"aucs": [0.2770187529309198, 0.26787602177142467, 0.28336658827129846, 0.2884545002430081, 0.29113605036304413, 0.2873880919313718, 0.28194970586921764, 0.2929582803039915, 0.30036843783274736, 0.24386061614093069, 0.2578717431471562, 0.25470637603278035, 0.24882320009026393, 0.2555745819843118, 0.2473258942299157, 0.26805172171554204, 0.26236011492579314, 0.24536610067122466, 0.1272822956175239, 0.08154385561707678, 0.09680141947225651, 0.08846919137727005, 0.07715501894874288, 0.0736636673398462, 0.08206691981345071, 0.07320418402380457, 0.08521918649289095, 0.0674140783363869, 0.07465577048156224, 0.09999870845110559, 0.08188797872085474, 0.08877009582970763, 0.08093736973943721, 0.0775553358074601, 0.07490529677374902, 0.07093094395841204, 0.9416738573465391, 0.920348732546589, 0.8795838466043651, 0.9313062642661573, 0.9009686522423297, 0.9009468272968262, 0.9336317894835042, 0.9762667149166918, 0.8735521423180275, 0.20546744155092733, 0.2060385318208674, 0.21002804635956795, 0.20524807093284303, 0.19702258096806158, 0.19655730642666025, 0.22263489439690265, 0.24692779368941498, 0.22588499972157683, 0.34997757743910807, 0.3556287807565244, 0.3437637329047808, 0.34740209578994385, 0.36708351716625176, 0.34366449151583345, 0.32443452876894974, 0.36065321934067207, 0.34695861500057856, 0.2004243691692308, 0.15976539449633487, 0.1427940621895346, 0.1676363119163201, 0.1539386007125091, 0.1700307177424797, 0.2338499395686211, 0.18257123897469185, 0.15646125020208623, 0.14240396129833788, 0.18685270635242368, 0.1200888783433578, 0.1491715609782266, 0.1426485344653895, 0.17531636437582254, 0.19506017964819067, 0.1451610204470749, 0.18393369549701255, 0.15112741023472975, 0.15165336991932687, 0.1490377708508458, 0.14956301499533275, 0.14550096623746722, 0.13050086934459393, 0.15121620365718413, 0.12834569471896162, 0.1494719754483107, 0.2242522284306131, 0.23862358095165315, 0.20895432386812363, 0.20432292415882325, 0.20561530088960567, 0.20734083831503003, 0.23163866972507485, 0.20940286230155758, 0.2277329758935428, 0.051952745234634445, 0.05873502005341724, 0.05626905149085959, 0.08207655871673158, 0.11639210115840504, 0.09518668499467509, 0.04423629493933845, 0.06439210701768061, 0.06644267696541051, 0.1384603544148707, 0.12799242065033145, 0.14305600544239627, 0.14968854981393342, 0.15866355224642104, 0.14403064818665645, 0.14681592058403525, 0.147211839804549, 0.16174057468340908, 0.2696280915897935, 0.28176697619959357, 0.27272162439509107, 0.2942558255980705, 0.2826691401952991, 0.2853759693763718, 0.26309238640452604, 0.27343019604730256, 0.2745542416856047, 0.07880054219702892, 0.07024897402989949, 0.07492842626166929, 0.074944291286832, 0.06719091467372196, 0.06589435107234076, 0.07115630168603237, 0.07241053102655803, 0.06238179095517449, 0.16102103087562913, 0.14386557053926952, 0.14391449614218377, 0.16512079727356976, 0.16378984588140444, 0.13996660870020283, 0.20145444837553905, 0.18144686035028734, 0.15061525582203272, 0.23259612493342796, 0.22614278924601727, 0.21772844420772164, 0.21709376833253513, 0.22207423309494212, 0.22631424559486157, 0.24243742809903468, 0.23765305790630664, 0.2390941704851297, 0.19438561157484358, 0.17997365232688478, 0.19176172559330285, 0.18198633984934343, 0.17591076252365023, 0.19220260252727261, 0.20639012164736792, 0.18393393011056458, 0.1827201311301443, 0.1711048839834468, 0.1570887871009039, 0.16489368873227483, 0.15777949089238097, 0.16416774012710866, 0.16632256683542468, 0.1480373001733466, 0.14913390768121304, 0.1552048037949848, 0.16970837006710482, 0.20060400775866294, 0.20373421407682124, 0.1870400105177128, 0.16536015258523817, 0.1707032911525984, 0.17527863284787693, 0.1839554087024693, 0.16940244978608476, 0.14291703387892796, 0.14232419795660567, 0.17206012093666834, 0.14728111192868076, 0.31614632710302726, 0.15934606352330904, 0.3282582759416691, 0.14863459665533352, 0.14791026067030977, 0.13730883128131277, 0.16538253758003651, 0.13814973838722255, 0.12008280155529483, 0.30842216277693746, 0.24859425500985277, 0.20596260386837728, 0.18920711645068555, 0.18770513943026346, 0.1781216985978703, 0.19426675505396784, 0.18088485539206745, 0.20560813658793564, 0.1748683943143975, 0.17867285072984673, 0.19407038606877913, 0.19258060059066506, 0.19382905150216256, 0.0544699227266785, 0.05978126176520471, 0.06399209362504477, 0.06194260120301276, 0.06080335327219688, 0.061146373700409096, 0.055397784777215575, 0.05766572009311499, 0.05487752534475243]}, "mutation_prompt": null}
{"id": "8e5ca0f7-e2ed-4a65-bf09-3673b96c1be1", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.95\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x**2))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.35 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (1 - evaluations / self.budget)**0.5))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.1, self.dim), \n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = population[ranked_indices[:self.population_size]]\n            fitness = fitness[ranked_indices[:self.population_size]]\n\n        return best_solution", "name": "HybridDESA", "description": "Refined HybridDESA with enhanced chaotic initialization and dynamic crossover rate adjustment for improved convergence.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fe471661-83b6-4f20-9800-f9b37e1519d8", "metadata": {"aucs": [0.2770187529309198, 0.26787602177142467, 0.28336658827129846, 0.2884545002430081, 0.29113605036304413, 0.2873880919313718, 0.28194970586921764, 0.2929582803039915, 0.30036843783274736, 0.24386061614093069, 0.2578717431471562, 0.25470637603278035, 0.24882320009026393, 0.2555745819843118, 0.2473258942299157, 0.26805172171554204, 0.26236011492579314, 0.24536610067122466, 0.1272822956175239, 0.08154385561707678, 0.09680141947225651, 0.08846919137727005, 0.07715501894874288, 0.0736636673398462, 0.08206691981345071, 0.07320418402380457, 0.08521918649289095, 0.0674140783363869, 0.07465577048156224, 0.09999870845110559, 0.08188797872085474, 0.08877009582970763, 0.08093736973943721, 0.0775553358074601, 0.07490529677374902, 0.07093094395841204, 0.9416738573465391, 0.920348732546589, 0.8795838466043651, 0.9313062642661573, 0.9009686522423297, 0.9009468272968262, 0.9336317894835042, 0.9762667149166918, 0.8735521423180275, 0.20546744155092733, 0.2060385318208674, 0.21002804635956795, 0.20524807093284303, 0.19702258096806158, 0.19655730642666025, 0.22263489439690265, 0.24692779368941498, 0.22588499972157683, 0.34997757743910807, 0.3556287807565244, 0.3437637329047808, 0.34740209578994385, 0.36708351716625176, 0.34366449151583345, 0.32443452876894974, 0.36065321934067207, 0.34695861500057856, 0.2004243691692308, 0.15976539449633487, 0.1427940621895346, 0.1676363119163201, 0.1539386007125091, 0.1700307177424797, 0.2338499395686211, 0.18257123897469185, 0.15646125020208623, 0.14240396129833788, 0.18685270635242368, 0.1200888783433578, 0.1491715609782266, 0.1426485344653895, 0.17531636437582254, 0.19506017964819067, 0.1451610204470749, 0.18393369549701255, 0.15112741023472975, 0.15165336991932687, 0.1490377708508458, 0.14956301499533275, 0.14550096623746722, 0.13050086934459393, 0.15121620365718413, 0.12834569471896162, 0.1494719754483107, 0.2242522284306131, 0.23862358095165315, 0.20895432386812363, 0.20432292415882325, 0.20561530088960567, 0.20734083831503003, 0.23163866972507485, 0.20940286230155758, 0.2277329758935428, 0.051952745234634445, 0.05873502005341724, 0.05626905149085959, 0.08207655871673158, 0.11639210115840504, 0.09518668499467509, 0.04423629493933845, 0.06439210701768061, 0.06644267696541051, 0.1384603544148707, 0.12799242065033145, 0.14305600544239627, 0.14968854981393342, 0.15866355224642104, 0.14403064818665645, 0.14681592058403525, 0.147211839804549, 0.16174057468340908, 0.2696280915897935, 0.28176697619959357, 0.27272162439509107, 0.2942558255980705, 0.2826691401952991, 0.2853759693763718, 0.26309238640452604, 0.27343019604730256, 0.2745542416856047, 0.07880054219702892, 0.07024897402989949, 0.07492842626166929, 0.074944291286832, 0.06719091467372196, 0.06589435107234076, 0.07115630168603237, 0.07241053102655803, 0.06238179095517449, 0.16102103087562913, 0.14386557053926952, 0.14391449614218377, 0.16512079727356976, 0.16378984588140444, 0.13996660870020283, 0.20145444837553905, 0.18144686035028734, 0.15061525582203272, 0.23259612493342796, 0.22614278924601727, 0.21772844420772164, 0.21709376833253513, 0.22207423309494212, 0.22631424559486157, 0.24243742809903468, 0.23765305790630664, 0.2390941704851297, 0.19438561157484358, 0.17997365232688478, 0.19176172559330285, 0.18198633984934343, 0.17591076252365023, 0.19220260252727261, 0.20639012164736792, 0.18393393011056458, 0.1827201311301443, 0.1711048839834468, 0.1570887871009039, 0.16489368873227483, 0.15777949089238097, 0.16416774012710866, 0.16632256683542468, 0.1480373001733466, 0.14913390768121304, 0.1552048037949848, 0.16970837006710482, 0.20060400775866294, 0.20373421407682124, 0.1870400105177128, 0.16536015258523817, 0.1707032911525984, 0.17527863284787693, 0.1839554087024693, 0.16940244978608476, 0.14291703387892796, 0.14232419795660567, 0.17206012093666834, 0.14728111192868076, 0.31614632710302726, 0.15934606352330904, 0.3282582759416691, 0.14863459665533352, 0.14791026067030977, 0.13730883128131277, 0.16538253758003651, 0.13814973838722255, 0.12008280155529483, 0.30842216277693746, 0.24859425500985277, 0.20596260386837728, 0.18920711645068555, 0.18770513943026346, 0.1781216985978703, 0.19426675505396784, 0.18088485539206745, 0.20560813658793564, 0.1748683943143975, 0.17867285072984673, 0.19407038606877913, 0.19258060059066506, 0.19382905150216256, 0.0544699227266785, 0.05978126176520471, 0.06399209362504477, 0.06194260120301276, 0.06080335327219688, 0.061146373700409096, 0.055397784777215575, 0.05766572009311499, 0.05487752534475243]}, "mutation_prompt": null}
{"id": "c67289eb-93f7-4d96-98f6-5ca304e63d35", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.95\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x**2))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]) + 0.1 * (population[np.argmin(fitness)] - population[a]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.35 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (1 - evaluations / self.budget)**0.5))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.1, self.dim), \n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = population[ranked_indices[:self.population_size]]\n            fitness = fitness[ranked_indices[:self.population_size]]\n\n        return best_solution", "name": "HybridDESA", "description": "Enhanced HybridDESA with improved chaotic initialization and adaptive differential mutation for better exploration and convergence.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'fitness' is not defined\").", "error": "NameError(\"name 'fitness' is not defined\")", "parent_id": "fe471661-83b6-4f20-9800-f9b37e1519d8", "metadata": {}, "mutation_prompt": null}
{"id": "3dba4f9a-e81d-4133-b23c-cc80bd5c48ea", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.95\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x**2))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.35 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (1 - evaluations / self.budget)**0.5))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.2, self.dim),  # Modified from 0.1 to 0.2\n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = np.vstack((population[ranked_indices[:self.population_size]], best_solution))  # Add best solution for elitism\n            fitness = np.append(fitness[ranked_indices[:self.population_size]], best_fitness)  # Maintain corresponding fitness\n\n        return best_solution", "name": "HybridDESA", "description": "Enhanced HybridDESA with improved elitism strategy and diversifying dynamic local search for robust global convergence.", "configspace": "", "generation": 62, "fitness": 0.23887224640697843, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.17.", "error": "", "parent_id": "fe471661-83b6-4f20-9800-f9b37e1519d8", "metadata": {"aucs": [0.30071329535355584, 0.2988367075241427, 0.29866449660308736, 0.3214838188455157, 0.3199616995904605, 0.31872477144355593, 0.31228457901814977, 0.3047658491923141, 0.30886976696926327, 0.2912693426114772, 0.2871680251930576, 0.2841522493878912, 0.2793748801410997, 0.282134640549472, 0.29250873850788595, 0.29721360752025405, 0.28406156456496, 0.27713711233305016, 0.12452867104334198, 0.10985235612329247, 0.10531295866537382, 0.10805475226761974, 0.11478019660135108, 0.25403891085202535, 0.10328023061627412, 0.11011148247563629, 0.11283181757083915, 0.10572339783121765, 0.12252363168927893, 0.11800470547774844, 0.09025860148029818, 0.09674646723117242, 0.1016342435459856, 0.10007217255079304, 0.0997320881388094, 0.2329668167668909, 0.9070642416363115, 0.8334763113551038, 0.8122540873534254, 0.9258778819418978, 0.9732644077565413, 0.9408602638105261, 0.9417567368177465, 0.8774674520988633, 0.8923029219850557, 0.2642247324180699, 0.25323399447903905, 0.26026338721157827, 0.2566263826153017, 0.25702077010244917, 0.24844438850430228, 0.25243992176245567, 0.2633794473290624, 0.2534790570575214, 0.39492601019796636, 0.40927570762575893, 0.3747461227302671, 0.392645853535902, 0.3683393353200236, 0.4221467684080237, 0.41173092228978625, 0.37968459279823574, 0.40022872290102174, 0.24396783979273107, 0.16298804475162343, 0.21609307591337035, 0.22619364817274412, 0.11732853928528875, 0.20464035576477613, 0.22354718413649566, 0.24432382856211265, 0.24238626605691094, 0.21727603322137434, 0.18539859010385196, 0.1495416952287062, 0.2639562724254465, 0.15924024898364264, 0.23443779765772743, 0.17491898057097677, 0.268298796599861, 0.22327753110559556, 0.24645934029488414, 0.26607924972158925, 0.22260628084769818, 0.0004939550350738786, 0.03606953511179545, 0.17673061877463336, 0.19671184574735834, 0.06173170981194309, 9.999999999998899e-05, 0.2706498731714301, 0.2613460026338451, 0.2848385428768112, 0.28094773021694575, 0.28788912321176807, 0.23941608290003746, 0.29105098745388036, 0.28495568105117086, 0.28514242245925825, 0.049939170335724925, 0.048636059046008984, 0.03130862838647441, 0.10669983750957712, 0.10412491291118131, 0.21505340262815176, 0.08572108435505821, 0.21960221421382564, 0.2181620517357976, 0.1964209993332846, 0.17457330996331244, 0.17459229812224586, 0.2014839616280426, 0.19839208594063518, 0.17254228173467057, 0.19917685914683314, 0.17814757502077772, 0.18570044401004981, 0.2981868717357411, 0.2900707991637409, 0.2925081613247973, 0.3001706746916285, 0.3065980456172722, 0.29525868805526145, 0.29104052573660877, 0.27658307404222804, 0.28731704663130797, 0.08115667425795459, 0.08495671171726749, 0.07789573058659405, 0.06033859400079111, 0.07066916205737195, 0.09241021716486852, 0.09158436754032462, 0.08621775752446514, 0.05993064873396381, 0.14221239407905906, 0.3088481981155211, 0.28490280455513417, 0.319842064186701, 0.17264077899128893, 0.1495353051982551, 0.16661851980439701, 0.2929680588621294, 0.16384880307788097, 0.2576751822580019, 0.2513576550276603, 0.25233367033041, 0.2583255256979373, 0.257292806482632, 0.2483376790560884, 0.25329126362880694, 0.2568471792039705, 0.2576652753157994, 0.232807666689958, 0.2206430718148149, 0.22946390702686714, 0.15791597987985206, 0.2336990998972296, 0.20040562851188937, 0.2174980300915298, 0.21319236340981496, 0.20153636423335286, 0.15454962266298877, 0.1670553856993533, 0.16457313478100355, 0.18955484634074304, 0.160989725983965, 0.15348931607348804, 0.15407683854174326, 0.1515514160105964, 0.15875751111934444, 0.18800111269991915, 0.1762940503027045, 0.1960818646509901, 0.18846538007303093, 0.2416073311190562, 0.20999230670934543, 0.28575961407877926, 0.18233787603125695, 0.17085296246645099, 0.18116031217399586, 0.15191243147653477, 0.16194420588950265, 0.15842552620416062, 0.15409655506977193, 0.41172960269199654, 0.15404412818947733, 0.4033473081633696, 0.4201758013719178, 0.14713413430682942, 0.35416836000890095, 0.13692701785712724, 0.3978172466242258, 0.15551325224884638, 0.3829101638798321, 0.3497472422030018, 0.38114574301204096, 0.17940490378530727, 0.20650419545553722, 0.18684021668214312, 0.18285726375771927, 0.20086546070366795, 0.18561242934668598, 0.1810138463090254, 0.199781658626783, 0.18910421302391645, 0.19829203050628263, 0.08012557510504759, 0.06530219689158989, 0.07093463688459634, 0.08227644907152465, 0.06358629041360797, 0.04677563005080809, 0.06108413171270677, 0.04976218859022408, 0.07724360027031629]}, "mutation_prompt": null}
{"id": "1f9869fa-954a-4ce3-a5bd-e6bfd1e21e7e", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.95\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def _chaotic_initialization(self, size, evaluations):\n        chaos_intensity = 1 + 0.2 * (evaluations / self.budget)\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(chaos_intensity * np.pi * x**2))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.35 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (1 - evaluations / self.budget)**0.5))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size, 0)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.2, self.dim),\n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = np.vstack((population[ranked_indices[:self.population_size]], best_solution))\n            fitness = np.append(fitness[ranked_indices[:self.population_size]], best_fitness)\n\n        return best_solution", "name": "HybridDESA", "description": "Enhanced HybridDESA with adaptive chaotic initialization and diversity preservation for improved exploration-exploitation balance.", "configspace": "", "generation": 63, "fitness": 0.23887224640697843, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.17.", "error": "", "parent_id": "3dba4f9a-e81d-4133-b23c-cc80bd5c48ea", "metadata": {"aucs": [0.30071329535355584, 0.2988367075241427, 0.29866449660308736, 0.3214838188455157, 0.3199616995904605, 0.31872477144355593, 0.31228457901814977, 0.3047658491923141, 0.30886976696926327, 0.2912693426114772, 0.2871680251930576, 0.2841522493878912, 0.2793748801410997, 0.282134640549472, 0.29250873850788595, 0.29721360752025405, 0.28406156456496, 0.27713711233305016, 0.12452867104334198, 0.10985235612329247, 0.10531295866537382, 0.10805475226761974, 0.11478019660135108, 0.25403891085202535, 0.10328023061627412, 0.11011148247563629, 0.11283181757083915, 0.10572339783121765, 0.12252363168927893, 0.11800470547774844, 0.09025860148029818, 0.09674646723117242, 0.1016342435459856, 0.10007217255079304, 0.0997320881388094, 0.2329668167668909, 0.9070642416363115, 0.8334763113551038, 0.8122540873534254, 0.9258778819418978, 0.9732644077565413, 0.9408602638105261, 0.9417567368177465, 0.8774674520988633, 0.8923029219850557, 0.2642247324180699, 0.25323399447903905, 0.26026338721157827, 0.2566263826153017, 0.25702077010244917, 0.24844438850430228, 0.25243992176245567, 0.2633794473290624, 0.2534790570575214, 0.39492601019796636, 0.40927570762575893, 0.3747461227302671, 0.392645853535902, 0.3683393353200236, 0.4221467684080237, 0.41173092228978625, 0.37968459279823574, 0.40022872290102174, 0.24396783979273107, 0.16298804475162343, 0.21609307591337035, 0.22619364817274412, 0.11732853928528875, 0.20464035576477613, 0.22354718413649566, 0.24432382856211265, 0.24238626605691094, 0.21727603322137434, 0.18539859010385196, 0.1495416952287062, 0.2639562724254465, 0.15924024898364264, 0.23443779765772743, 0.17491898057097677, 0.268298796599861, 0.22327753110559556, 0.24645934029488414, 0.26607924972158925, 0.22260628084769818, 0.0004939550350738786, 0.03606953511179545, 0.17673061877463336, 0.19671184574735834, 0.06173170981194309, 9.999999999998899e-05, 0.2706498731714301, 0.2613460026338451, 0.2848385428768112, 0.28094773021694575, 0.28788912321176807, 0.23941608290003746, 0.29105098745388036, 0.28495568105117086, 0.28514242245925825, 0.049939170335724925, 0.048636059046008984, 0.03130862838647441, 0.10669983750957712, 0.10412491291118131, 0.21505340262815176, 0.08572108435505821, 0.21960221421382564, 0.2181620517357976, 0.1964209993332846, 0.17457330996331244, 0.17459229812224586, 0.2014839616280426, 0.19839208594063518, 0.17254228173467057, 0.19917685914683314, 0.17814757502077772, 0.18570044401004981, 0.2981868717357411, 0.2900707991637409, 0.2925081613247973, 0.3001706746916285, 0.3065980456172722, 0.29525868805526145, 0.29104052573660877, 0.27658307404222804, 0.28731704663130797, 0.08115667425795459, 0.08495671171726749, 0.07789573058659405, 0.06033859400079111, 0.07066916205737195, 0.09241021716486852, 0.09158436754032462, 0.08621775752446514, 0.05993064873396381, 0.14221239407905906, 0.3088481981155211, 0.28490280455513417, 0.319842064186701, 0.17264077899128893, 0.1495353051982551, 0.16661851980439701, 0.2929680588621294, 0.16384880307788097, 0.2576751822580019, 0.2513576550276603, 0.25233367033041, 0.2583255256979373, 0.257292806482632, 0.2483376790560884, 0.25329126362880694, 0.2568471792039705, 0.2576652753157994, 0.232807666689958, 0.2206430718148149, 0.22946390702686714, 0.15791597987985206, 0.2336990998972296, 0.20040562851188937, 0.2174980300915298, 0.21319236340981496, 0.20153636423335286, 0.15454962266298877, 0.1670553856993533, 0.16457313478100355, 0.18955484634074304, 0.160989725983965, 0.15348931607348804, 0.15407683854174326, 0.1515514160105964, 0.15875751111934444, 0.18800111269991915, 0.1762940503027045, 0.1960818646509901, 0.18846538007303093, 0.2416073311190562, 0.20999230670934543, 0.28575961407877926, 0.18233787603125695, 0.17085296246645099, 0.18116031217399586, 0.15191243147653477, 0.16194420588950265, 0.15842552620416062, 0.15409655506977193, 0.41172960269199654, 0.15404412818947733, 0.4033473081633696, 0.4201758013719178, 0.14713413430682942, 0.35416836000890095, 0.13692701785712724, 0.3978172466242258, 0.15551325224884638, 0.3829101638798321, 0.3497472422030018, 0.38114574301204096, 0.17940490378530727, 0.20650419545553722, 0.18684021668214312, 0.18285726375771927, 0.20086546070366795, 0.18561242934668598, 0.1810138463090254, 0.199781658626783, 0.18910421302391645, 0.19829203050628263, 0.08012557510504759, 0.06530219689158989, 0.07093463688459634, 0.08227644907152465, 0.06358629041360797, 0.04677563005080809, 0.06108413171270677, 0.04976218859022408, 0.07724360027031629]}, "mutation_prompt": null}
{"id": "b349e77b-b50a-4265-afee-b2584d63d763", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.95\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x**2))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations) + np.random.normal(0, 0.05)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.7 + 0.25 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (1 - evaluations / self.budget)**0.5))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.2, self.dim),  # Modified from 0.1 to 0.2\n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = np.vstack((population[ranked_indices[:self.population_size]], best_solution))  # Add best solution for elitism\n            fitness = np.append(fitness[ranked_indices[:self.population_size]], best_fitness)  # Maintain corresponding fitness\n\n        return best_solution", "name": "HybridDESA", "description": "Enhanced HybridDESA with strategic mutation and crossover adjustments improving convergence speed and exploration-exploitation balance.", "configspace": "", "generation": 64, "fitness": 0.23552679981665825, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.17.", "error": "", "parent_id": "3dba4f9a-e81d-4133-b23c-cc80bd5c48ea", "metadata": {"aucs": [0.291483405439397, 0.3096416295321964, 0.30801807662730984, 0.31863562293525316, 0.3211525228564467, 0.32656436900595265, 0.31238675408370187, 0.32219952055239653, 0.30185054872387884, 0.2795711801484422, 0.286165540990702, 0.2797186631826476, 0.2901699285672994, 0.2840726883202297, 0.281060073918285, 0.2740709564359558, 0.2737139451866214, 0.2873272628064678, 0.11490747076079044, 0.08896666831457112, 0.12888133677256097, 0.0985268573266872, 0.09487042588846928, 0.11364723358473261, 0.10269225433958273, 0.15437846981993475, 0.08286573485276894, 0.24563595753233103, 0.22937828081387435, 0.12346191704359155, 0.10465805066748213, 0.1074981892214375, 0.12333590456577381, 0.10245530950018222, 0.1196155281893132, 0.09835413367230372, 0.9707877834997444, 0.891786040340084, 0.963416306805774, 0.963567884809131, 0.8689599138092667, 0.8707668017872975, 0.8165282122301164, 0.9852660718600522, 0.9273054079315786, 0.24121758245977742, 0.2606190914606311, 0.26296759150517823, 0.26308633326716535, 0.2563589176824367, 0.2562720904822743, 0.2540273860579316, 0.2727487453308426, 0.26141869707134346, 0.3746626049114835, 0.3790304663671401, 0.3777354596320044, 0.43084158750203505, 0.420222872485837, 0.4427258893704422, 0.40796887594466913, 0.3948128350258925, 0.42256807055630596, 0.18490717331776285, 0.22087840865396124, 0.26506735966279893, 0.2665622522853024, 0.1819244615114859, 0.2204023386064372, 0.24200544458361306, 0.23939061713483856, 0.2536245622544212, 0.2578564879751508, 0.25297633133354125, 0.26613607515407967, 0.22088316503208094, 0.2511883226390029, 0.2021097141090178, 0.10694345694632434, 0.26813292280924517, 0.2667708266418527, 0.25966883415380393, 0.05214967808840698, 0.05891078115509096, 0.013889155838378242, 0.21116692952338467, 9.999999999998899e-05, 0.23751859468579872, 0.2638521884998447, 0.2596854366689506, 0.3043351943079313, 0.25154299063851504, 0.2796205383708752, 0.2762868684331654, 0.2841775417648017, 0.29218276463114934, 0.2660567551208336, 0.2690458780041306, 0.26709931942345444, 0.10340240228943642, 0.2000899294965287, 0.08810361833088498, 0.20998291944336112, 0.20010802326715404, 0.22431994311588266, 0.20484580612790104, 0.10399992290440618, 0.14961667388273148, 0.20297374265989465, 0.18166666935382514, 0.16626806260259042, 0.2108697703111736, 0.1864198239085899, 0.2009734206824001, 0.20646306421764427, 0.2012942622733993, 0.17679173736985543, 0.28184864194828174, 0.308371317430586, 0.2915677461939443, 0.3157979670070207, 0.2878331430780594, 0.29592363228546503, 0.2968893066235978, 0.2849343697452684, 0.2956112509641583, 0.07799273739957002, 0.07594256168212399, 0.08018906446074436, 0.10349152652643245, 0.08146172948639219, 0.08194434864588496, 0.06899080292008097, 0.08482755716991486, 0.06924343193610893, 0.22285380033792002, 0.22187081913404105, 0.16057112524338446, 0.201757276723469, 0.15371342307121272, 0.20868835564096067, 0.1461242590740396, 0.164418773552798, 0.16801593138690496, 0.24155586866664713, 0.25522922072259446, 0.23496988258712082, 0.2522126153218094, 0.1782383625293542, 0.24453771819847558, 0.2584183433194822, 0.252190502808475, 0.27026127922920773, 0.19139239031118138, 0.21711713607131145, 0.2222251322936385, 0.22010471230244444, 0.16855010987591124, 0.1464469055500771, 0.22733357990586434, 0.21690359911422696, 0.22680081332851476, 0.1444518705958353, 0.14737605767391793, 0.16179546091545838, 0.18018609003113983, 0.15198973664597726, 0.15905896142333553, 0.17578555097306237, 0.1694471906345365, 0.157202020723623, 0.17822969289285306, 0.1961469301886435, 0.1831993742260437, 0.17696107843609077, 0.1926814832687076, 0.20540097065251617, 0.17643355636733593, 0.2840375317342735, 0.28826417546792493, 0.15603149811480743, 0.16474334491074327, 0.13957551734098905, 0.1418143262806678, 0.47867999062535327, 0.1659634713797855, 0.15333554191197984, 0.15973248023029807, 0.17916970172530022, 0.14509189219501717, 0.17158956416285198, 0.13957282970594753, 0.12601072845123473, 0.15820312730028074, 0.17033505534222126, 0.19619826603935353, 0.18978739379684229, 0.18110058839418364, 0.17937721813056962, 0.18881742939429924, 0.19175440147562195, 0.1871851978495388, 0.1759406026421959, 0.19637344178817173, 0.1867677960997306, 0.18691738272077663, 0.17880410286806914, 0.05353701951928069, 0.06701904703366768, 0.059138661906166456, 0.04826267837437914, 0.07743474181114729, 0.064674093674426, 0.068003226334174, 0.056407667350611645, 0.05358683429842981]}, "mutation_prompt": null}
{"id": "59d87586-5ff3-4fcf-9fcb-276b982053e6", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.95\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x**2))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.35 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (1 - evaluations / self.budget)**0.5))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.2, self.dim),  # Modified from 0.1 to 0.2\n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = np.vstack((population[ranked_indices[:self.population_size]], best_solution))  # Add best solution for elitism\n            fitness = np.append(fitness[ranked_indices[:self.population_size]], best_fitness)  # Maintain corresponding fitness\n\n        return best_solution", "name": "HybridDESA", "description": "Enhanced HybridDESA with improved elitism strategy and diversifying dynamic local search for robust global convergence.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3dba4f9a-e81d-4133-b23c-cc80bd5c48ea", "metadata": {"aucs": [0.30071329535355584, 0.2988367075241427, 0.29866449660308736, 0.3214838188455157, 0.3199616995904605, 0.31872477144355593, 0.31228457901814977, 0.3047658491923141, 0.30886976696926327, 0.2912693426114772, 0.2871680251930576, 0.2841522493878912, 0.2793748801410997, 0.282134640549472, 0.29250873850788595, 0.29721360752025405, 0.28406156456496, 0.27713711233305016, 0.12452867104334198, 0.10985235612329247, 0.10531295866537382, 0.10805475226761974, 0.11478019660135108, 0.25403891085202535, 0.10328023061627412, 0.11011148247563629, 0.11283181757083915, 0.10572339783121765, 0.12252363168927893, 0.11800470547774844, 0.09025860148029818, 0.09674646723117242, 0.1016342435459856, 0.10007217255079304, 0.0997320881388094, 0.2329668167668909, 0.9070642416363115, 0.8334763113551038, 0.8122540873534254, 0.9258778819418978, 0.9732644077565413, 0.9408602638105261, 0.9417567368177465, 0.8774674520988633, 0.8923029219850557, 0.2642247324180699, 0.25323399447903905, 0.26026338721157827, 0.2566263826153017, 0.25702077010244917, 0.24844438850430228, 0.25243992176245567, 0.2633794473290624, 0.2534790570575214, 0.39492601019796636, 0.40927570762575893, 0.3747461227302671, 0.392645853535902, 0.3683393353200236, 0.4221467684080237, 0.41173092228978625, 0.37968459279823574, 0.40022872290102174, 0.24396783979273107, 0.16298804475162343, 0.21609307591337035, 0.22619364817274412, 0.11732853928528875, 0.20464035576477613, 0.22354718413649566, 0.24432382856211265, 0.24238626605691094, 0.21727603322137434, 0.18539859010385196, 0.1495416952287062, 0.2639562724254465, 0.15924024898364264, 0.23443779765772743, 0.17491898057097677, 0.268298796599861, 0.22327753110559556, 0.24645934029488414, 0.26607924972158925, 0.22260628084769818, 0.0004939550350738786, 0.03606953511179545, 0.17673061877463336, 0.19671184574735834, 0.06173170981194309, 9.999999999998899e-05, 0.2706498731714301, 0.2613460026338451, 0.2848385428768112, 0.28094773021694575, 0.28788912321176807, 0.23941608290003746, 0.29105098745388036, 0.28495568105117086, 0.28514242245925825, 0.049939170335724925, 0.048636059046008984, 0.03130862838647441, 0.10669983750957712, 0.10412491291118131, 0.21505340262815176, 0.08572108435505821, 0.21960221421382564, 0.2181620517357976, 0.1964209993332846, 0.17457330996331244, 0.17459229812224586, 0.2014839616280426, 0.19839208594063518, 0.17254228173467057, 0.19917685914683314, 0.17814757502077772, 0.18570044401004981, 0.2981868717357411, 0.2900707991637409, 0.2925081613247973, 0.3001706746916285, 0.3065980456172722, 0.29525868805526145, 0.29104052573660877, 0.27658307404222804, 0.28731704663130797, 0.08115667425795459, 0.08495671171726749, 0.07789573058659405, 0.06033859400079111, 0.07066916205737195, 0.09241021716486852, 0.09158436754032462, 0.08621775752446514, 0.05993064873396381, 0.14221239407905906, 0.3088481981155211, 0.28490280455513417, 0.319842064186701, 0.17264077899128893, 0.1495353051982551, 0.16661851980439701, 0.2929680588621294, 0.16384880307788097, 0.2576751822580019, 0.2513576550276603, 0.25233367033041, 0.2583255256979373, 0.257292806482632, 0.2483376790560884, 0.25329126362880694, 0.2568471792039705, 0.2576652753157994, 0.232807666689958, 0.2206430718148149, 0.22946390702686714, 0.15791597987985206, 0.2336990998972296, 0.20040562851188937, 0.2174980300915298, 0.21319236340981496, 0.20153636423335286, 0.15454962266298877, 0.1670553856993533, 0.16457313478100355, 0.18955484634074304, 0.160989725983965, 0.15348931607348804, 0.15407683854174326, 0.1515514160105964, 0.15875751111934444, 0.18800111269991915, 0.1762940503027045, 0.1960818646509901, 0.18846538007303093, 0.2416073311190562, 0.20999230670934543, 0.28575961407877926, 0.18233787603125695, 0.17085296246645099, 0.18116031217399586, 0.15191243147653477, 0.16194420588950265, 0.15842552620416062, 0.15409655506977193, 0.41172960269199654, 0.15404412818947733, 0.4033473081633696, 0.4201758013719178, 0.14713413430682942, 0.35416836000890095, 0.13692701785712724, 0.3978172466242258, 0.15551325224884638, 0.3829101638798321, 0.3497472422030018, 0.38114574301204096, 0.17940490378530727, 0.20650419545553722, 0.18684021668214312, 0.18285726375771927, 0.20086546070366795, 0.18561242934668598, 0.1810138463090254, 0.199781658626783, 0.18910421302391645, 0.19829203050628263, 0.08012557510504759, 0.06530219689158989, 0.07093463688459634, 0.08227644907152465, 0.06358629041360797, 0.04677563005080809, 0.06108413171270677, 0.04976218859022408, 0.07724360027031629]}, "mutation_prompt": null}
{"id": "0ca9c96e-5225-427e-aacd-f9f72aecf3fe", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.95\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x**2))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.35 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (1 - evaluations / self.budget)**0.5))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            chaos_term = np.sin(evaluations / self.budget * np.pi)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.2, self.dim) * chaos_term,\n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = np.vstack((population[ranked_indices[:self.population_size]], best_solution))  # Add best solution for elitism\n            fitness = np.append(fitness[ranked_indices[:self.population_size]], best_fitness)  # Maintain corresponding fitness\n\n        return best_solution", "name": "HybridDESA", "description": "Enhanced HybridDESA with dynamic scaling factor and chaos-enhanced local search for improved convergence.", "configspace": "", "generation": 66, "fitness": 0.23524109861948406, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.16.", "error": "", "parent_id": "3dba4f9a-e81d-4133-b23c-cc80bd5c48ea", "metadata": {"aucs": [0.30886606937837646, 0.3142142862997943, 0.30013798560978033, 0.32448789704490255, 0.33001360030814597, 0.3115908560240013, 0.30583768654981125, 0.3166413005533396, 0.31629487544556845, 0.2772064781928204, 0.28896091331423235, 0.29386148464021167, 0.27332979033866334, 0.27614590338957645, 0.26823911444077086, 0.2842462998907366, 0.2753662640249913, 0.2888200939287724, 0.10620375673866167, 0.12446596522990638, 0.10861524228991415, 0.10333034835143518, 0.10984441543140677, 0.10553916738456615, 0.11808738318723266, 0.09390153848395588, 0.12569630004188637, 0.0948454806911122, 0.10465186876051225, 0.1066174917331173, 0.11917324478772695, 0.10924171918722314, 0.12424869140410555, 0.10674810377724586, 0.08526037177119583, 0.10003926677054698, 0.9188121584143204, 0.869783088293677, 0.9712738156808366, 0.800908942440015, 0.9658618926779325, 0.9384786517526413, 0.9314465927637717, 0.9180280064047704, 0.9100875551338181, 0.26898617135754477, 0.24812847326067544, 0.2745415799698543, 0.25647752448223515, 0.24902827079798595, 0.2485842335356132, 0.25664294671575494, 0.25689114450100903, 0.2621520224685988, 0.3678087109079815, 0.39499237548129595, 0.41618378221958174, 0.3961778219346761, 0.4169415582194722, 0.4057080890963547, 0.38230935801994825, 0.40819166067264023, 0.4362262421504862, 0.2822533943103849, 0.2749067761597038, 0.20806774915965542, 0.1740139605826977, 0.25443588431776565, 0.22961321899232867, 0.24463118987652943, 0.18788316508011227, 0.25374991895638555, 0.1096846115859289, 0.28684490367967075, 0.14415804633106966, 0.10374875677889195, 0.2470436577056977, 0.2521897159407611, 0.22132336993331703, 0.19213425054195254, 0.21171296953594543, 0.2654593845295339, 0.05249401353625549, 0.22114772916084902, 0.062146216097251794, 0.23604183490994368, 0.21996609973324588, 0.2859167100759562, 0.23412918983403253, 0.2226775592890976, 0.26478636419823, 0.31273247209240296, 0.25461473647889776, 0.30850689600471326, 0.26116859527433545, 0.27640740590307455, 0.28132412087929115, 0.27124073863682296, 0.28075846517623004, 0.0442078623158737, 0.09067466344654496, 0.19161744671256875, 0.16208014987736785, 0.0846918953806638, 0.17536678927680283, 0.20842127353770834, 0.17170471521806507, 0.18766956224877995, 0.18350634889812079, 0.1993547565402617, 0.18839346745821905, 0.18985909290497482, 0.20807520109943378, 0.19021679019428916, 0.20266465446144588, 0.1661397255531385, 0.187393431424544, 0.29036027366522954, 0.2934869963685779, 0.3056812852794616, 0.2933526109822917, 0.29775362816535633, 0.3046168204660815, 0.29244313490883256, 0.28269208732928386, 0.31168363867228677, 0.0825441098198948, 0.07535213816930209, 0.07329265647927719, 0.09841641967747905, 0.07239174109193769, 0.08126696498646757, 0.09187135481151731, 0.10074838465137814, 0.08349086447821552, 0.14363281216889812, 0.18505196390714962, 0.24327973439910078, 0.15759006828390398, 0.1523713231592403, 0.23425498292446623, 0.20739788179307295, 0.16104103736768427, 0.19006449034395345, 0.2505924682873757, 0.24556433079933282, 0.25841949965882693, 0.2541798991340124, 0.2484337398143277, 0.1684587370724714, 0.26772448335601784, 0.24339681966440363, 0.26358552340721764, 0.22184400805873528, 0.19241305396028918, 0.1996873541041393, 0.21971112264075732, 0.21165296389547106, 0.23440655561913504, 0.21522863676205417, 0.2292877064472042, 0.21194186901750822, 0.15815006403813547, 0.16587561414844398, 0.1595157907999616, 0.172802054478699, 0.16495549056945946, 0.16621284086628607, 0.15357796211956554, 0.16152540081619904, 0.16366237648770965, 0.17033396051911365, 0.203563611410999, 0.1816863881627626, 0.17960521127925055, 0.19915798470619506, 0.18635248441560948, 0.19374429891871214, 0.30652794562162566, 0.19022307796943527, 0.17396524523983148, 0.18274345077716525, 0.18086934601537819, 0.15650729668253538, 0.1734291699530457, 0.1708588625186248, 0.16529052059200344, 0.17758299270208466, 0.1590366979562179, 0.3290582097612148, 0.14201071422573308, 0.14349976097971706, 0.16115264375860083, 0.3206841898149082, 0.15357283079928696, 0.19079362138438483, 0.18619094652979462, 0.17497559535725526, 0.19229811795707397, 0.18409412288027394, 0.19728287862375637, 0.20127122019264565, 0.19406492615120752, 0.1780981236841166, 0.19466241676404739, 0.1921081712798649, 0.17883714540163786, 0.06329878450355686, 0.06502826035444942, 0.0641828794385334, 0.05831011418000376, 0.056695113488141935, 0.05688672206649148, 0.0569980357369303, 0.05118932490776262, 0.07104229319499666]}, "mutation_prompt": null}
{"id": "0d7ab908-e5a0-4fc9-b7b9-45e991a4319c", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.95\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x**2))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.35 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        # Adjusted: added rotational invariance for crossover\n        rotation_matrix = np.eye(self.dim) + 0.1 * (np.random.rand(self.dim, self.dim) - 0.5)\n        rotated_target = np.dot(rotation_matrix, target)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, rotated_target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (1 - evaluations / self.budget)**0.5))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.2, self.dim),\n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = np.vstack((population[ranked_indices[:self.population_size]], best_solution))\n            fitness = np.append(fitness[ranked_indices[:self.population_size]], best_fitness)\n\n        return best_solution", "name": "HybridDESA", "description": "Improved HybridDESA with adaptive mutation and crossover mechanisms incorporating rotational invariance.", "configspace": "", "generation": 67, "fitness": 0.2307189739877174, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.15.", "error": "", "parent_id": "3dba4f9a-e81d-4133-b23c-cc80bd5c48ea", "metadata": {"aucs": [0.30203676925514245, 0.3033162222580973, 0.29217766255478517, 0.29971835653973733, 0.3192428118725653, 0.30833820168634973, 0.31354160735186687, 0.30794732282009674, 0.31203499729342243, 0.29656963762156807, 0.267977299164871, 0.2865310185603931, 0.28293022573454085, 0.2890105091854328, 0.283897056833477, 0.264191687136751, 0.26359232274460764, 0.23650369743710675, 0.11620766631502888, 0.1203903564139116, 0.10456172306646316, 0.09725833061791311, 0.2093920452991168, 0.10925403187402827, 0.10337975922815423, 0.09651779411352945, 0.11557140260718535, 0.09477818987921005, 0.07488804593450027, 0.08469441300376568, 0.1186647723999158, 0.095969947834039, 0.10147975925017894, 0.10427677450483985, 0.10245593329274438, 0.07611342593556603, 0.9180222186886378, 0.8167853258734532, 0.8381969987364958, 0.7715208582125987, 0.750340806883159, 0.7675406948840638, 0.8516345673400171, 0.8738218954875667, 0.8251855314459483, 0.24845380689051333, 0.24237776305420566, 0.24810506217034323, 0.2386468203413501, 0.24868945809349097, 0.2671956893165027, 0.2555809322867634, 0.24264613875568763, 0.26465960055981363, 0.37469286803805624, 0.4370715784794825, 0.3870029600073752, 0.405524640648234, 0.40149648417072137, 0.35506927140097866, 0.4021116497242281, 0.39097279470903123, 0.4505312336340799, 0.20751129919599065, 0.19811818188684638, 0.25406148777748916, 0.24618707757590064, 0.23569384870055865, 0.11087983607171936, 0.24427465791335234, 0.10955067206497682, 0.18404392313433504, 0.27418842480994565, 0.12821548716454145, 0.179506274229303, 0.19645771127829803, 0.2431681069681637, 0.1898955991734963, 0.26781131722240803, 0.09208682806885427, 0.15379727053680092, 0.16433888164838684, 0.14346583173516303, 0.19389036362865097, 0.20593343065613057, 0.2236564099224031, 0.04009561790206373, 0.07796970932651515, 0.21605209651283908, 0.22888622080273024, 0.2652278045178529, 0.27221707128959793, 0.2817955955087891, 0.28679519742080173, 0.29129084966051055, 0.2776296250929766, 0.29477719321841456, 0.2673915816968382, 0.2883086605233519, 0.028025500738898534, 0.05800877905202939, 0.035967214018227445, 0.09493361659436883, 0.10286679728149228, 0.12845670210093763, 0.09407909468848707, 0.13633250135349406, 0.14705447006957706, 0.17808280819624123, 0.15705842706171003, 0.17853249020276796, 0.1650703329036094, 0.18599504487727458, 0.1725850807386976, 0.1694268024423472, 0.19047107048098944, 0.19377441656421535, 0.28661183552534175, 0.30181451285459393, 0.3018874101534027, 0.29809722393560156, 0.29512055887519195, 0.30916582560716044, 0.28601091050685723, 0.27624422070519206, 0.34568263388219944, 0.07415742387116409, 0.08269833370113977, 0.08150827425688367, 0.10072092071339378, 0.09971737888258503, 0.10741866313698845, 0.08298760443320952, 0.10382589808769005, 0.08917856963699855, 0.2937178827008097, 0.2724604726465918, 0.14229320988013783, 0.1780683520066224, 0.2884903483435374, 0.20868464927979447, 0.3000064676784886, 0.19748275260203385, 0.20301663983224494, 0.22505300714576026, 0.24138342744617924, 0.23326709560305958, 0.23667500079473835, 0.23617208432128323, 0.23272409471954703, 0.24487190910882717, 0.25440490987592046, 0.2460634087482586, 0.19225455114945644, 0.19500065469666972, 0.20960785476789456, 0.20481698863939557, 0.21475734709448657, 0.22889629098827802, 0.2067115236359267, 0.21008469958097375, 0.19284289877265792, 0.16824387343933778, 0.14944399235627293, 0.1814913356459682, 0.16086012102327663, 0.15470269929750669, 0.163584941321415, 0.20021388797619555, 0.15892973564291535, 0.16970569911614075, 0.28006814106785227, 0.28443892282953154, 0.1988701122744797, 0.3051563287571627, 0.19477870720826418, 0.19147836285733377, 0.19161410127411238, 0.18580045752132268, 0.20003329790416502, 0.3587346203519075, 0.3809639627368373, 0.3908782793869744, 0.1775223070769545, 0.15941780372262782, 0.16999113626697604, 0.14720984093287803, 0.17197232773378524, 0.16588596129914368, 0.16003467815950279, 0.16043359256151812, 0.13931553747120395, 0.37121174476607655, 0.15856796126212425, 0.14176570243812425, 0.19270824568827616, 0.1875122621951858, 0.1801697836529602, 0.19522075910046566, 0.21877049980912733, 0.22529566078049068, 0.20071935221521175, 0.18568744112876057, 0.23233076632247307, 0.19133782180123982, 0.1909678165660713, 0.2149756245187242, 0.07430133335888656, 0.07418055805635937, 0.06698537268256366, 0.06505481066217089, 0.06026458808548474, 0.06351951688624358, 0.06908145375861863, 0.08571471533314978, 0.07334238258337611]}, "mutation_prompt": null}
{"id": "34df365b-abe0-4c84-8734-700ad2ab6e44", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.95\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x**2))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.35 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (1 - evaluations / self.budget)**0.5))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.2, self.dim),  # Modified from 0.1 to 0.2\n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = np.vstack((population[ranked_indices[:self.population_size]], best_solution))  # Add best solution for elitism\n            fitness = np.append(fitness[ranked_indices[:self.population_size]], best_fitness)  # Maintain corresponding fitness\n\n        return best_solution", "name": "HybridDESA", "description": "Enhanced HybridDESA with improved elitism strategy and diversifying dynamic local search for robust global convergence.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3dba4f9a-e81d-4133-b23c-cc80bd5c48ea", "metadata": {"aucs": [0.30071329535355584, 0.2988367075241427, 0.29866449660308736, 0.3214838188455157, 0.3199616995904605, 0.31872477144355593, 0.31228457901814977, 0.3047658491923141, 0.30886976696926327, 0.2912693426114772, 0.2871680251930576, 0.2841522493878912, 0.2793748801410997, 0.282134640549472, 0.29250873850788595, 0.29721360752025405, 0.28406156456496, 0.27713711233305016, 0.12452867104334198, 0.10985235612329247, 0.10531295866537382, 0.10805475226761974, 0.11478019660135108, 0.25403891085202535, 0.10328023061627412, 0.11011148247563629, 0.11283181757083915, 0.10572339783121765, 0.12252363168927893, 0.11800470547774844, 0.09025860148029818, 0.09674646723117242, 0.1016342435459856, 0.10007217255079304, 0.0997320881388094, 0.2329668167668909, 0.9070642416363115, 0.8334763113551038, 0.8122540873534254, 0.9258778819418978, 0.9732644077565413, 0.9408602638105261, 0.9417567368177465, 0.8774674520988633, 0.8923029219850557, 0.2642247324180699, 0.25323399447903905, 0.26026338721157827, 0.2566263826153017, 0.25702077010244917, 0.24844438850430228, 0.25243992176245567, 0.2633794473290624, 0.2534790570575214, 0.39492601019796636, 0.40927570762575893, 0.3747461227302671, 0.392645853535902, 0.3683393353200236, 0.4221467684080237, 0.41173092228978625, 0.37968459279823574, 0.40022872290102174, 0.24396783979273107, 0.16298804475162343, 0.21609307591337035, 0.22619364817274412, 0.11732853928528875, 0.20464035576477613, 0.22354718413649566, 0.24432382856211265, 0.24238626605691094, 0.21727603322137434, 0.18539859010385196, 0.1495416952287062, 0.2639562724254465, 0.15924024898364264, 0.23443779765772743, 0.17491898057097677, 0.268298796599861, 0.22327753110559556, 0.24645934029488414, 0.26607924972158925, 0.22260628084769818, 0.0004939550350738786, 0.03606953511179545, 0.17673061877463336, 0.19671184574735834, 0.06173170981194309, 9.999999999998899e-05, 0.2706498731714301, 0.2613460026338451, 0.2848385428768112, 0.28094773021694575, 0.28788912321176807, 0.23941608290003746, 0.29105098745388036, 0.28495568105117086, 0.28514242245925825, 0.049939170335724925, 0.048636059046008984, 0.03130862838647441, 0.10669983750957712, 0.10412491291118131, 0.21505340262815176, 0.08572108435505821, 0.21960221421382564, 0.2181620517357976, 0.1964209993332846, 0.17457330996331244, 0.17459229812224586, 0.2014839616280426, 0.19839208594063518, 0.17254228173467057, 0.19917685914683314, 0.17814757502077772, 0.18570044401004981, 0.2981868717357411, 0.2900707991637409, 0.2925081613247973, 0.3001706746916285, 0.3065980456172722, 0.29525868805526145, 0.29104052573660877, 0.27658307404222804, 0.28731704663130797, 0.08115667425795459, 0.08495671171726749, 0.07789573058659405, 0.06033859400079111, 0.07066916205737195, 0.09241021716486852, 0.09158436754032462, 0.08621775752446514, 0.05993064873396381, 0.14221239407905906, 0.3088481981155211, 0.28490280455513417, 0.319842064186701, 0.17264077899128893, 0.1495353051982551, 0.16661851980439701, 0.2929680588621294, 0.16384880307788097, 0.2576751822580019, 0.2513576550276603, 0.25233367033041, 0.2583255256979373, 0.257292806482632, 0.2483376790560884, 0.25329126362880694, 0.2568471792039705, 0.2576652753157994, 0.232807666689958, 0.2206430718148149, 0.22946390702686714, 0.15791597987985206, 0.2336990998972296, 0.20040562851188937, 0.2174980300915298, 0.21319236340981496, 0.20153636423335286, 0.15454962266298877, 0.1670553856993533, 0.16457313478100355, 0.18955484634074304, 0.160989725983965, 0.15348931607348804, 0.15407683854174326, 0.1515514160105964, 0.15875751111934444, 0.18800111269991915, 0.1762940503027045, 0.1960818646509901, 0.18846538007303093, 0.2416073311190562, 0.20999230670934543, 0.28575961407877926, 0.18233787603125695, 0.17085296246645099, 0.18116031217399586, 0.15191243147653477, 0.16194420588950265, 0.15842552620416062, 0.15409655506977193, 0.41172960269199654, 0.15404412818947733, 0.4033473081633696, 0.4201758013719178, 0.14713413430682942, 0.35416836000890095, 0.13692701785712724, 0.3978172466242258, 0.15551325224884638, 0.3829101638798321, 0.3497472422030018, 0.38114574301204096, 0.17940490378530727, 0.20650419545553722, 0.18684021668214312, 0.18285726375771927, 0.20086546070366795, 0.18561242934668598, 0.1810138463090254, 0.199781658626783, 0.18910421302391645, 0.19829203050628263, 0.08012557510504759, 0.06530219689158989, 0.07093463688459634, 0.08227644907152465, 0.06358629041360797, 0.04677563005080809, 0.06108413171270677, 0.04976218859022408, 0.07724360027031629]}, "mutation_prompt": null}
{"id": "34678645-b4aa-4f61-a40e-139fdac6ee5f", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.95\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x**2))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        chaotic_component = np.sin(population[idx] * np.random.randn(self.dim))\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]) + 0.1 * chaotic_component,\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.35 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (1 - evaluations / self.budget)**0.5))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.2, self.dim),  # Modified from 0.1 to 0.2\n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = np.vstack((population[ranked_indices[:self.population_size]], best_solution))  # Add best solution for elitism\n            fitness = np.append(fitness[ranked_indices[:self.population_size]], best_fitness)  # Maintain corresponding fitness\n\n        return best_solution", "name": "HybridDESA", "description": "Enhanced HybridDESA with adaptive elitism and chaotic mutation to improve convergence.", "configspace": "", "generation": 69, "fitness": 0.19354223781178892, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.17.", "error": "", "parent_id": "3dba4f9a-e81d-4133-b23c-cc80bd5c48ea", "metadata": {"aucs": [0.2753758557043676, 0.29234065180356883, 0.2715531207330113, 0.28484270132327427, 0.2875208375022721, 0.28728869459080075, 0.29665942755577657, 0.2759885990127503, 0.2840916039978534, 0.11216890635285248, 0.11501625405199134, 0.12242012873969998, 0.20329853574964596, 0.1623326134316465, 0.18855427947147574, 0.13541233493465643, 0.1346513835992793, 0.14525674396472876, 0.11781482614068695, 0.10552800857657041, 0.11210897001725573, 0.09789082836240581, 0.111193270677725, 0.09383798454902648, 0.1046936983579777, 0.10163260819836484, 0.11150749549081718, 0.09059179898329783, 0.0815762870387241, 0.10236283578523797, 0.08518166686899675, 0.09322122239310082, 0.09121907706311938, 0.1024317090290442, 0.08610435030384123, 0.08636157768029773, 0.9179681935596108, 0.8503569527816308, 0.9045097732950379, 0.9557567547937453, 0.9138880123900214, 0.878124242160012, 0.916752227845317, 0.8644965686281102, 0.8513187055792777, 0.21595710172382876, 0.2085818570004977, 0.20615576137668057, 0.22240102919452542, 0.20103160568685619, 0.22394414064123003, 0.2168779727288065, 0.21827924395001308, 0.22798892323044495, 0.36995311979925083, 0.3445220492265455, 0.4146439467613138, 0.24576073404066157, 0.4307783406226411, 0.27264737712680265, 0.2532563683384569, 0.3665771560309108, 0.41288735574734703, 0.1480034142178729, 0.1499505146132606, 0.17035338229864505, 0.14600644742309377, 0.1518374322605709, 0.15236923049748508, 0.14282886484425106, 0.140641567549882, 0.1482659174925015, 0.16522219664884363, 0.17654269896710617, 0.1687741660644846, 0.17341551541963984, 0.188332879104666, 0.18112277948311184, 0.18187304972555907, 0.16640605560727395, 0.19488776991021028, 0.005717379735699635, 0.033820645103465496, 0.008685533680366286, 0.021226601933267975, 0.05688705896901303, 0.017402110313543884, 9.999999999998899e-05, 0.11428455650136349, 0.024725748400506342, 0.05710814497280281, 0.12475157966586525, 0.088711737167803, 0.061175918414172914, 0.07709799757915203, 0.030123174071238656, 0.07579587903529006, 0.13056315390313233, 0.13503366027018293, 0.016510999556499484, 9.999999999998899e-05, 0.000805452576018828, 0.017200574993323947, 0.008506940559713239, 0.016379821876962297, 0.006625163874025786, 0.0014092710750376325, 9.999999999998899e-05, 0.09103281030038124, 0.08892469939570635, 0.10346226596692454, 0.08286359052520254, 0.08305204269106303, 0.08590043284464244, 0.08869046354933274, 0.08305306773744892, 0.07873381037779514, 0.29171605544617774, 0.2614865194495408, 0.2787040534755537, 0.26839724261121367, 0.2709486066524234, 0.2674270653894931, 0.2779333641061239, 0.27565825571945535, 0.2640186180996297, 0.08028959538959357, 0.08293605583701735, 0.07044373975534057, 0.08720519764401069, 0.08085367130832422, 0.07712484089749083, 0.06906186785616009, 0.0822094935810237, 0.10737927566307404, 0.17617311523142487, 0.1740275696420509, 0.2536340623336314, 0.1586626717747005, 0.24749238774475568, 0.13762929378726385, 0.1632313779248541, 0.18402092293488936, 0.14841563177830652, 0.21126415324236136, 0.21816888880627516, 0.2122080017041068, 0.21334230277084854, 0.2260079510740134, 0.21762448265013634, 0.211196317746844, 0.21290807766930453, 0.22355921369631182, 0.17260009525046338, 0.1613001714343092, 0.1674469886975437, 0.14613919009516962, 0.17731408598051712, 0.1757921904841453, 0.1668607758997821, 0.1768933616601044, 0.1788606139801212, 0.16500566645609382, 0.1615004079952932, 0.15359681864979302, 0.1560065956414266, 0.1652103757632587, 0.16534712925559503, 0.15755024044570343, 0.18003013022555847, 0.17489689981492051, 0.18295967369260702, 0.18631747516233388, 0.22197934361913363, 0.19934335164245875, 0.18272929150266604, 0.22975119869760474, 0.17637899505983934, 0.2466043306810497, 0.20967915662702408, 0.3732249267497898, 0.3657276308002949, 0.38577688627068163, 0.16629322891075116, 0.11376534724331744, 0.16677329762506865, 0.15765741375019293, 0.16042997321854668, 0.40790483238864916, 0.1704370566794916, 0.14517457774401632, 0.17197563784603376, 0.15269203226083505, 0.3658647443178862, 0.35734851416737257, 0.18853802441012535, 0.20186847411116116, 0.18127110971146665, 0.17622139711894436, 0.1931990633019286, 0.19663016048630388, 0.18977995051875363, 0.20817283914183637, 0.1751663308076058, 0.18558310140589895, 0.2264628197723172, 0.1877588728148466, 0.06706093969422222, 0.0515074386455624, 0.0692259291101085, 0.06708037974845993, 0.07314293480128109, 0.06993800400116146, 0.0611805414125296, 0.06308231124314478, 0.07090957726645664]}, "mutation_prompt": null}
{"id": "7b8effb9-0cf7-4c5c-a369-a1d0c100e58d", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.95\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x**2))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.35 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (1 - evaluations / self.budget)**0.5))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.2, self.dim),  # Modified from 0.1 to 0.2\n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = np.vstack((population[ranked_indices[:self.population_size]], best_solution))  # Add best solution for elitism\n            fitness = np.append(fitness[ranked_indices[:self.population_size]], best_fitness)  # Maintain corresponding fitness\n\n        return best_solution", "name": "HybridDESA", "description": "Enhanced HybridDESA with improved elitism strategy and diversifying dynamic local search for robust global convergence.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3dba4f9a-e81d-4133-b23c-cc80bd5c48ea", "metadata": {"aucs": [0.30071329535355584, 0.2988367075241427, 0.29866449660308736, 0.3214838188455157, 0.3199616995904605, 0.31872477144355593, 0.31228457901814977, 0.3047658491923141, 0.30886976696926327, 0.2912693426114772, 0.2871680251930576, 0.2841522493878912, 0.2793748801410997, 0.282134640549472, 0.29250873850788595, 0.29721360752025405, 0.28406156456496, 0.27713711233305016, 0.12452867104334198, 0.10985235612329247, 0.10531295866537382, 0.10805475226761974, 0.11478019660135108, 0.25403891085202535, 0.10328023061627412, 0.11011148247563629, 0.11283181757083915, 0.10572339783121765, 0.12252363168927893, 0.11800470547774844, 0.09025860148029818, 0.09674646723117242, 0.1016342435459856, 0.10007217255079304, 0.0997320881388094, 0.2329668167668909, 0.9070642416363115, 0.8334763113551038, 0.8122540873534254, 0.9258778819418978, 0.9732644077565413, 0.9408602638105261, 0.9417567368177465, 0.8774674520988633, 0.8923029219850557, 0.2642247324180699, 0.25323399447903905, 0.26026338721157827, 0.2566263826153017, 0.25702077010244917, 0.24844438850430228, 0.25243992176245567, 0.2633794473290624, 0.2534790570575214, 0.39492601019796636, 0.40927570762575893, 0.3747461227302671, 0.392645853535902, 0.3683393353200236, 0.4221467684080237, 0.41173092228978625, 0.37968459279823574, 0.40022872290102174, 0.24396783979273107, 0.16298804475162343, 0.21609307591337035, 0.22619364817274412, 0.11732853928528875, 0.20464035576477613, 0.22354718413649566, 0.24432382856211265, 0.24238626605691094, 0.21727603322137434, 0.18539859010385196, 0.1495416952287062, 0.2639562724254465, 0.15924024898364264, 0.23443779765772743, 0.17491898057097677, 0.268298796599861, 0.22327753110559556, 0.24645934029488414, 0.26607924972158925, 0.22260628084769818, 0.0004939550350738786, 0.03606953511179545, 0.17673061877463336, 0.19671184574735834, 0.06173170981194309, 9.999999999998899e-05, 0.2706498731714301, 0.2613460026338451, 0.2848385428768112, 0.28094773021694575, 0.28788912321176807, 0.23941608290003746, 0.29105098745388036, 0.28495568105117086, 0.28514242245925825, 0.049939170335724925, 0.048636059046008984, 0.03130862838647441, 0.10669983750957712, 0.10412491291118131, 0.21505340262815176, 0.08572108435505821, 0.21960221421382564, 0.2181620517357976, 0.1964209993332846, 0.17457330996331244, 0.17459229812224586, 0.2014839616280426, 0.19839208594063518, 0.17254228173467057, 0.19917685914683314, 0.17814757502077772, 0.18570044401004981, 0.2981868717357411, 0.2900707991637409, 0.2925081613247973, 0.3001706746916285, 0.3065980456172722, 0.29525868805526145, 0.29104052573660877, 0.27658307404222804, 0.28731704663130797, 0.08115667425795459, 0.08495671171726749, 0.07789573058659405, 0.06033859400079111, 0.07066916205737195, 0.09241021716486852, 0.09158436754032462, 0.08621775752446514, 0.05993064873396381, 0.14221239407905906, 0.3088481981155211, 0.28490280455513417, 0.319842064186701, 0.17264077899128893, 0.1495353051982551, 0.16661851980439701, 0.2929680588621294, 0.16384880307788097, 0.2576751822580019, 0.2513576550276603, 0.25233367033041, 0.2583255256979373, 0.257292806482632, 0.2483376790560884, 0.25329126362880694, 0.2568471792039705, 0.2576652753157994, 0.232807666689958, 0.2206430718148149, 0.22946390702686714, 0.15791597987985206, 0.2336990998972296, 0.20040562851188937, 0.2174980300915298, 0.21319236340981496, 0.20153636423335286, 0.15454962266298877, 0.1670553856993533, 0.16457313478100355, 0.18955484634074304, 0.160989725983965, 0.15348931607348804, 0.15407683854174326, 0.1515514160105964, 0.15875751111934444, 0.18800111269991915, 0.1762940503027045, 0.1960818646509901, 0.18846538007303093, 0.2416073311190562, 0.20999230670934543, 0.28575961407877926, 0.18233787603125695, 0.17085296246645099, 0.18116031217399586, 0.15191243147653477, 0.16194420588950265, 0.15842552620416062, 0.15409655506977193, 0.41172960269199654, 0.15404412818947733, 0.4033473081633696, 0.4201758013719178, 0.14713413430682942, 0.35416836000890095, 0.13692701785712724, 0.3978172466242258, 0.15551325224884638, 0.3829101638798321, 0.3497472422030018, 0.38114574301204096, 0.17940490378530727, 0.20650419545553722, 0.18684021668214312, 0.18285726375771927, 0.20086546070366795, 0.18561242934668598, 0.1810138463090254, 0.199781658626783, 0.18910421302391645, 0.19829203050628263, 0.08012557510504759, 0.06530219689158989, 0.07093463688459634, 0.08227644907152465, 0.06358629041360797, 0.04677563005080809, 0.06108413171270677, 0.04976218859022408, 0.07724360027031629]}, "mutation_prompt": null}
{"id": "8df25ee2-6ef1-41af-91f5-80f84045a764", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.95\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x**2 * (1 + np.tanh(evaluations/self.budget))))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.35 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (1 - evaluations / self.budget)**0.5))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.3, self.dim),  # Modified from 0.2 to 0.3\n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = np.vstack((population[ranked_indices[:self.population_size]], best_solution))\n            fitness = np.append(fitness[ranked_indices[:self.population_size]], best_fitness)\n\n        return best_solution", "name": "HybridDESA", "description": "Refined HybridDESA with adaptive chaotic initialization and improved local search step for enhanced convergence.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'evaluations' is not defined\").", "error": "NameError(\"name 'evaluations' is not defined\")", "parent_id": "3dba4f9a-e81d-4133-b23c-cc80bd5c48ea", "metadata": {}, "mutation_prompt": null}
{"id": "6bca5b6d-33bb-47fc-bea0-96335df847a9", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.95\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x**2))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.35 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (1 - evaluations / self.budget)**0.5))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.2, self.dim),  # Modified from 0.1 to 0.2\n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = np.vstack((population[ranked_indices[:self.population_size]], best_solution))  # Add best solution for elitism\n            fitness = np.append(fitness[ranked_indices[:self.population_size]], best_fitness)  # Maintain corresponding fitness\n\n        return best_solution", "name": "HybridDESA", "description": "Enhanced HybridDESA with improved elitism strategy and diversifying dynamic local search for robust global convergence.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3dba4f9a-e81d-4133-b23c-cc80bd5c48ea", "metadata": {"aucs": [0.30071329535355584, 0.2988367075241427, 0.29866449660308736, 0.3214838188455157, 0.3199616995904605, 0.31872477144355593, 0.31228457901814977, 0.3047658491923141, 0.30886976696926327, 0.2912693426114772, 0.2871680251930576, 0.2841522493878912, 0.2793748801410997, 0.282134640549472, 0.29250873850788595, 0.29721360752025405, 0.28406156456496, 0.27713711233305016, 0.12452867104334198, 0.10985235612329247, 0.10531295866537382, 0.10805475226761974, 0.11478019660135108, 0.25403891085202535, 0.10328023061627412, 0.11011148247563629, 0.11283181757083915, 0.10572339783121765, 0.12252363168927893, 0.11800470547774844, 0.09025860148029818, 0.09674646723117242, 0.1016342435459856, 0.10007217255079304, 0.0997320881388094, 0.2329668167668909, 0.9070642416363115, 0.8334763113551038, 0.8122540873534254, 0.9258778819418978, 0.9732644077565413, 0.9408602638105261, 0.9417567368177465, 0.8774674520988633, 0.8923029219850557, 0.2642247324180699, 0.25323399447903905, 0.26026338721157827, 0.2566263826153017, 0.25702077010244917, 0.24844438850430228, 0.25243992176245567, 0.2633794473290624, 0.2534790570575214, 0.39492601019796636, 0.40927570762575893, 0.3747461227302671, 0.392645853535902, 0.3683393353200236, 0.4221467684080237, 0.41173092228978625, 0.37968459279823574, 0.40022872290102174, 0.24396783979273107, 0.16298804475162343, 0.21609307591337035, 0.22619364817274412, 0.11732853928528875, 0.20464035576477613, 0.22354718413649566, 0.24432382856211265, 0.24238626605691094, 0.21727603322137434, 0.18539859010385196, 0.1495416952287062, 0.2639562724254465, 0.15924024898364264, 0.23443779765772743, 0.17491898057097677, 0.268298796599861, 0.22327753110559556, 0.24645934029488414, 0.26607924972158925, 0.22260628084769818, 0.0004939550350738786, 0.03606953511179545, 0.17673061877463336, 0.19671184574735834, 0.06173170981194309, 9.999999999998899e-05, 0.2706498731714301, 0.2613460026338451, 0.2848385428768112, 0.28094773021694575, 0.28788912321176807, 0.23941608290003746, 0.29105098745388036, 0.28495568105117086, 0.28514242245925825, 0.049939170335724925, 0.048636059046008984, 0.03130862838647441, 0.10669983750957712, 0.10412491291118131, 0.21505340262815176, 0.08572108435505821, 0.21960221421382564, 0.2181620517357976, 0.1964209993332846, 0.17457330996331244, 0.17459229812224586, 0.2014839616280426, 0.19839208594063518, 0.17254228173467057, 0.19917685914683314, 0.17814757502077772, 0.18570044401004981, 0.2981868717357411, 0.2900707991637409, 0.2925081613247973, 0.3001706746916285, 0.3065980456172722, 0.29525868805526145, 0.29104052573660877, 0.27658307404222804, 0.28731704663130797, 0.08115667425795459, 0.08495671171726749, 0.07789573058659405, 0.06033859400079111, 0.07066916205737195, 0.09241021716486852, 0.09158436754032462, 0.08621775752446514, 0.05993064873396381, 0.14221239407905906, 0.3088481981155211, 0.28490280455513417, 0.319842064186701, 0.17264077899128893, 0.1495353051982551, 0.16661851980439701, 0.2929680588621294, 0.16384880307788097, 0.2576751822580019, 0.2513576550276603, 0.25233367033041, 0.2583255256979373, 0.257292806482632, 0.2483376790560884, 0.25329126362880694, 0.2568471792039705, 0.2576652753157994, 0.232807666689958, 0.2206430718148149, 0.22946390702686714, 0.15791597987985206, 0.2336990998972296, 0.20040562851188937, 0.2174980300915298, 0.21319236340981496, 0.20153636423335286, 0.15454962266298877, 0.1670553856993533, 0.16457313478100355, 0.18955484634074304, 0.160989725983965, 0.15348931607348804, 0.15407683854174326, 0.1515514160105964, 0.15875751111934444, 0.18800111269991915, 0.1762940503027045, 0.1960818646509901, 0.18846538007303093, 0.2416073311190562, 0.20999230670934543, 0.28575961407877926, 0.18233787603125695, 0.17085296246645099, 0.18116031217399586, 0.15191243147653477, 0.16194420588950265, 0.15842552620416062, 0.15409655506977193, 0.41172960269199654, 0.15404412818947733, 0.4033473081633696, 0.4201758013719178, 0.14713413430682942, 0.35416836000890095, 0.13692701785712724, 0.3978172466242258, 0.15551325224884638, 0.3829101638798321, 0.3497472422030018, 0.38114574301204096, 0.17940490378530727, 0.20650419545553722, 0.18684021668214312, 0.18285726375771927, 0.20086546070366795, 0.18561242934668598, 0.1810138463090254, 0.199781658626783, 0.18910421302391645, 0.19829203050628263, 0.08012557510504759, 0.06530219689158989, 0.07093463688459634, 0.08227644907152465, 0.06358629041360797, 0.04677563005080809, 0.06108413171270677, 0.04976218859022408, 0.07724360027031629]}, "mutation_prompt": null}
{"id": "6e2b4642-e9a0-4367-89a3-a6b4dcf7b7bd", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.95\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x**2))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        # Introduce a new strategy based on fitness dispersion\n        dispersion = np.std([population[a], population[b], population[c]], axis=0)\n        mutant = np.clip(population[a] + adaptive_factor * dispersion * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.7 + 0.25 * (evaluations / self.budget)  # Adjusted coefficients\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (1 - evaluations / self.budget)**0.5))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.2, self.dim),\n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = np.vstack((population[ranked_indices[:self.population_size]], best_solution))\n            fitness = np.append(fitness[ranked_indices[:self.population_size]], best_fitness)\n\n        return best_solution", "name": "HybridDESA", "description": "Improved HybridDESA with accelerated convergence through a dynamic strategy for mutation and crossover, leveraging function landscape information.", "configspace": "", "generation": 73, "fitness": 0.13060750912942765, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "3dba4f9a-e81d-4133-b23c-cc80bd5c48ea", "metadata": {"aucs": [0.1430455682796723, 0.27111077677314976, 0.23357380215141155, 0.21759805115594344, 0.22934210984362635, 0.25235424451230337, 0.21384845422986787, 0.21616952672961065, 0.22239789352903994, 9.999999999998899e-05, 0.06200663959088015, 0.044327931387223685, 0.04598596212199424, 9.999999999998899e-05, 9.999999999998899e-05, 0.001836082150718954, 0.0032674510809838075, 9.999999999998899e-05, 0.03614930112845671, 0.09381614350969336, 0.03441337723019822, 0.036271891112466426, 0.015131765910851969, 0.08131231149370666, 0.015728405546674762, 0.03307730872227044, 0.032559267626955046, 0.007621796225956157, 0.06415192968517025, 0.08026226046951834, 0.09036783992081532, 0.02915218853486934, 0.03591614529155818, 0.07445661174099694, 0.03203951192992227, 0.05340874936552176, 0.9911406765654531, 0.9852595500660583, 0.9666558326328225, 0.9720676192258325, 0.9798319216669492, 0.9715626866876826, 0.9877328404412404, 0.9843948314446551, 0.9885455055505233, 0.10544639011484702, 0.08460316549403557, 0.11279250107678218, 0.0870554327851043, 0.14181189161781327, 0.056498457500692933, 0.10990490022584531, 0.12851509446111742, 0.1291557266556228, 0.04952423790371363, 0.12330012429347503, 0.1318849631648551, 0.1105596629803931, 0.11153460579566477, 0.14015999661327283, 0.10966486637950834, 0.10913094699995729, 0.08874427188972478, 0.08519316420746004, 0.12866450937970053, 0.10749505180346264, 9.999999999998899e-05, 0.09968171383810676, 0.09104703404453485, 0.1327546621429574, 0.09885625854975588, 0.13351403767816405, 0.0792939491191823, 0.0856117102125874, 0.04335667796622855, 0.10957150062807008, 0.12520364131446093, 0.14141472287481172, 0.12507513007568527, 0.03504684078093545, 0.09484798904073666, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.019785839104613623, 0.0498758780870272, 0.03409589697953708, 0.002953080156492094, 0.05365172173222532, 0.013542449801462908, 0.027549257258641213, 0.039667296629763205, 0.02329380003436121, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.013084854033495352, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03597365911188555, 0.08749338019745523, 0.028435159046540703, 0.026814427794619733, 0.01829680058971317, 0.03754885162543886, 0.03840402560931311, 0.028940709036602286, 0.05864912320536131, 0.21851138879043996, 0.13756620391627516, 0.187165866212898, 0.22133143576166692, 0.20274941374272326, 0.17456910532584757, 0.16033166522120446, 0.15786923533708308, 0.19319320000799522, 0.04417252221612744, 0.03874035346350391, 0.028325543402657916, 0.03206099236912652, 0.030133375929440653, 0.008012923928025106, 9.999999999998899e-05, 0.07243247403707886, 0.01674008201728061, 0.14785098816829778, 0.14507804736806107, 0.13878123517208096, 0.17400204683621268, 0.10686448371734236, 0.1378975515788372, 0.13830371197018, 0.1583568557424363, 0.12509331160937232, 0.12952087253029299, 0.13287971433442147, 0.12209561262411694, 0.1667286891827272, 0.1196585924387138, 0.11724179302873527, 0.13029284888974524, 0.20883086738360324, 0.149167865683287, 0.04698551334479706, 0.07290584400932021, 0.054465991391218216, 0.08034566864455661, 0.07441838973515857, 0.07196570619867448, 0.1279927492496974, 0.100604790101678, 0.09388338583759337, 0.12177819125245737, 0.12771292364522746, 0.15459988361874766, 0.1338309091774187, 0.13122002633779706, 0.12620225406995067, 0.12153448246860876, 0.14740917358390948, 0.14727769079589093, 0.18766897847125497, 0.17960082793453747, 0.17665602043013207, 0.17707730141477096, 0.16167147856178776, 0.16656051225553747, 0.1588971374215613, 0.15636156071443896, 0.16911703586563143, 0.16834711275965697, 0.15595149966381683, 0.11960424494013933, 0.1447996436419391, 0.10158149280649342, 0.1679053256719013, 0.11329086990074577, 0.09993058348012895, 0.12836872320681092, 0.1603593110514323, 0.1585875458069258, 0.13312946573328333, 0.12150797594760498, 0.03738786474436273, 0.057832964207543025, 0.11097773407803035, 0.16423540846056384, 0.18226969118070557, 0.17371724637681707, 0.16790499823241933, 0.16128444734079728, 0.17116157247112873, 0.15968796422977483, 0.18458404194306033, 0.15539349409436198, 0.16534084098004842, 0.18050533159279492, 0.022066851592232206, 0.03955996688870311, 0.04197652963591103, 0.029390786522467183, 0.03637318117852795, 0.055624771737998846, 0.023086683605523683, 0.03156958201468807, 0.027466124859780727]}, "mutation_prompt": null}
{"id": "0dfe89a2-31ec-49c8-aa65-7134230a38db", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.95\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x**2))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.35 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (1 - evaluations / self.budget)**0.5))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.2, self.dim),  # Modified from 0.1 to 0.2\n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = np.vstack((population[ranked_indices[:self.population_size]], best_solution))  # Add best solution for elitism\n            fitness = np.append(fitness[ranked_indices[:self.population_size]], best_fitness)  # Maintain corresponding fitness\n\n        return best_solution", "name": "HybridDESA", "description": "Enhanced HybridDESA with improved elitism strategy and diversifying dynamic local search for robust global convergence.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3dba4f9a-e81d-4133-b23c-cc80bd5c48ea", "metadata": {"aucs": [0.30071329535355584, 0.2988367075241427, 0.29866449660308736, 0.3214838188455157, 0.3199616995904605, 0.31872477144355593, 0.31228457901814977, 0.3047658491923141, 0.30886976696926327, 0.2912693426114772, 0.2871680251930576, 0.2841522493878912, 0.2793748801410997, 0.282134640549472, 0.29250873850788595, 0.29721360752025405, 0.28406156456496, 0.27713711233305016, 0.12452867104334198, 0.10985235612329247, 0.10531295866537382, 0.10805475226761974, 0.11478019660135108, 0.25403891085202535, 0.10328023061627412, 0.11011148247563629, 0.11283181757083915, 0.10572339783121765, 0.12252363168927893, 0.11800470547774844, 0.09025860148029818, 0.09674646723117242, 0.1016342435459856, 0.10007217255079304, 0.0997320881388094, 0.2329668167668909, 0.9070642416363115, 0.8334763113551038, 0.8122540873534254, 0.9258778819418978, 0.9732644077565413, 0.9408602638105261, 0.9417567368177465, 0.8774674520988633, 0.8923029219850557, 0.2642247324180699, 0.25323399447903905, 0.26026338721157827, 0.2566263826153017, 0.25702077010244917, 0.24844438850430228, 0.25243992176245567, 0.2633794473290624, 0.2534790570575214, 0.39492601019796636, 0.40927570762575893, 0.3747461227302671, 0.392645853535902, 0.3683393353200236, 0.4221467684080237, 0.41173092228978625, 0.37968459279823574, 0.40022872290102174, 0.24396783979273107, 0.16298804475162343, 0.21609307591337035, 0.22619364817274412, 0.11732853928528875, 0.20464035576477613, 0.22354718413649566, 0.24432382856211265, 0.24238626605691094, 0.21727603322137434, 0.18539859010385196, 0.1495416952287062, 0.2639562724254465, 0.15924024898364264, 0.23443779765772743, 0.17491898057097677, 0.268298796599861, 0.22327753110559556, 0.24645934029488414, 0.26607924972158925, 0.22260628084769818, 0.0004939550350738786, 0.03606953511179545, 0.17673061877463336, 0.19671184574735834, 0.06173170981194309, 9.999999999998899e-05, 0.2706498731714301, 0.2613460026338451, 0.2848385428768112, 0.28094773021694575, 0.28788912321176807, 0.23941608290003746, 0.29105098745388036, 0.28495568105117086, 0.28514242245925825, 0.049939170335724925, 0.048636059046008984, 0.03130862838647441, 0.10669983750957712, 0.10412491291118131, 0.21505340262815176, 0.08572108435505821, 0.21960221421382564, 0.2181620517357976, 0.1964209993332846, 0.17457330996331244, 0.17459229812224586, 0.2014839616280426, 0.19839208594063518, 0.17254228173467057, 0.19917685914683314, 0.17814757502077772, 0.18570044401004981, 0.2981868717357411, 0.2900707991637409, 0.2925081613247973, 0.3001706746916285, 0.3065980456172722, 0.29525868805526145, 0.29104052573660877, 0.27658307404222804, 0.28731704663130797, 0.08115667425795459, 0.08495671171726749, 0.07789573058659405, 0.06033859400079111, 0.07066916205737195, 0.09241021716486852, 0.09158436754032462, 0.08621775752446514, 0.05993064873396381, 0.14221239407905906, 0.3088481981155211, 0.28490280455513417, 0.319842064186701, 0.17264077899128893, 0.1495353051982551, 0.16661851980439701, 0.2929680588621294, 0.16384880307788097, 0.2576751822580019, 0.2513576550276603, 0.25233367033041, 0.2583255256979373, 0.257292806482632, 0.2483376790560884, 0.25329126362880694, 0.2568471792039705, 0.2576652753157994, 0.232807666689958, 0.2206430718148149, 0.22946390702686714, 0.15791597987985206, 0.2336990998972296, 0.20040562851188937, 0.2174980300915298, 0.21319236340981496, 0.20153636423335286, 0.15454962266298877, 0.1670553856993533, 0.16457313478100355, 0.18955484634074304, 0.160989725983965, 0.15348931607348804, 0.15407683854174326, 0.1515514160105964, 0.15875751111934444, 0.18800111269991915, 0.1762940503027045, 0.1960818646509901, 0.18846538007303093, 0.2416073311190562, 0.20999230670934543, 0.28575961407877926, 0.18233787603125695, 0.17085296246645099, 0.18116031217399586, 0.15191243147653477, 0.16194420588950265, 0.15842552620416062, 0.15409655506977193, 0.41172960269199654, 0.15404412818947733, 0.4033473081633696, 0.4201758013719178, 0.14713413430682942, 0.35416836000890095, 0.13692701785712724, 0.3978172466242258, 0.15551325224884638, 0.3829101638798321, 0.3497472422030018, 0.38114574301204096, 0.17940490378530727, 0.20650419545553722, 0.18684021668214312, 0.18285726375771927, 0.20086546070366795, 0.18561242934668598, 0.1810138463090254, 0.199781658626783, 0.18910421302391645, 0.19829203050628263, 0.08012557510504759, 0.06530219689158989, 0.07093463688459634, 0.08227644907152465, 0.06358629041360797, 0.04677563005080809, 0.06108413171270677, 0.04976218859022408, 0.07724360027031629]}, "mutation_prompt": null}
{"id": "97aec39a-06f4-406c-b072-0fe6a66600cb", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.95\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x**2))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.35 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget))))  # Modified dynamic adaptation\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.25, self.dim),  # Modified from 0.2 to 0.25\n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = np.vstack((population[ranked_indices[:self.population_size]], best_solution))  # Add best solution for elitism\n            fitness = np.append(fitness[ranked_indices[:self.population_size]], best_fitness)  # Maintain corresponding fitness\n\n        return best_solution", "name": "HybridDESA", "description": "Improved dynamic population adaptation and refined local search to enhance exploration and convergence.", "configspace": "", "generation": 75, "fitness": 0.24705786210559852, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.18.", "error": "", "parent_id": "3dba4f9a-e81d-4133-b23c-cc80bd5c48ea", "metadata": {"aucs": [0.38558279940440066, 0.3609503798038901, 0.3791100187406563, 0.37165266215160475, 0.38999180788037124, 0.3871134905578162, 0.3842147971693174, 0.3827804354706522, 0.37048786575858594, 0.37708018172181734, 0.34428376400991934, 0.35734872155395436, 0.3680661052415707, 0.3758876208516555, 0.38720338661262144, 0.3219505285050154, 0.3295189922233256, 0.3608783087021509, 0.11115610563140976, 0.09908915671666019, 0.11049796396595224, 0.10399744370061448, 0.1305424994142539, 0.11339181349994865, 0.11410905539947258, 0.3272060953007032, 0.10668621877750428, 0.097119647191106, 0.31555653205737355, 0.1066189875512682, 0.1096620489590856, 0.07995079765568514, 0.09997425407650662, 0.08819741632640521, 0.08689528943462987, 0.11181669251809145, 0.9855044408535428, 0.9490778590710266, 0.9554756351964058, 0.8953902141647986, 0.9732644077565413, 0.9053038102148867, 0.8145665313692394, 0.963560974260261, 0.9065833018858803, 0.32136742904932536, 0.2525887188280115, 0.2969909826398506, 0.2953519465609691, 0.2977356962408224, 0.3093143131796341, 0.3353097164828992, 0.28752682111657735, 0.32232703827610676, 0.4923653636460419, 0.4912604313326253, 0.25261030972929244, 0.4834335177549848, 0.46558961298266666, 0.4870099880004952, 0.4666578709685061, 0.473799313393244, 0.4886752127701931, 0.19148957532340216, 0.20627481945919546, 0.2958516352775179, 0.15122491047808528, 0.23620872626032807, 0.26318122337586247, 0.26061438024934247, 0.17096745058966967, 0.24898584449878203, 0.24482549497580008, 0.21074757010603384, 0.10238267377895505, 0.18653876956799165, 0.2786500721233667, 0.21470096893039048, 0.21550725645778612, 0.18719478151872482, 0.17364175670543702, 0.05033484828355772, 0.24029899392974563, 0.05841463667988045, 0.04714755210604782, 0.0737680105947347, 0.14257713286722196, 0.30240915076768105, 0.21548573678118443, 0.010085476949776018, 0.19924228826192825, 0.2718602343066092, 0.19169052073071136, 0.12100729663601528, 0.21856156282212857, 0.2410592921696737, 0.32249219900927384, 0.2696968773636642, 0.27383115304388284, 0.02721298272462258, 0.04236757585505946, 0.026755752323254778, 0.14018984921781208, 0.02953043616537221, 0.14565809746465308, 0.07996565159905256, 0.11166437396084217, 0.08007655168808814, 0.1868004482804253, 0.202424787175995, 0.1691603285143214, 0.18374084442464966, 0.21128505657328245, 0.21617201136005437, 0.17295313359432563, 0.1811343973372871, 0.152667918050154, 0.3397286833695359, 0.29837021107268047, 0.31255343579613526, 0.3170858179924362, 0.33183974651513837, 0.3057191395393466, 0.37314218187823744, 0.3472297650492424, 0.3288386262777845, 0.11859054119150747, 0.06838324830648257, 0.07334772972723491, 0.06529738333371238, 0.09586032090980101, 0.060127435664957374, 0.06711811236362386, 0.0653520706631352, 0.0751152261657384, 0.13157166540084764, 0.15762577769546715, 0.22389013106589628, 0.15971207719954306, 0.17065583660711747, 0.21800359372996325, 0.2176111451718984, 0.3162693249937646, 0.17738190747136107, 0.29599492750971135, 0.2840079399736276, 0.24759501185723787, 0.2999697797106864, 0.26131337731955073, 0.25960658224417943, 0.2547544010265941, 0.3168241330506947, 0.27931639263466856, 0.20986808251689182, 0.26168448011925394, 0.19190425832620872, 0.1842673575833944, 0.263217702915734, 0.16548679536904398, 0.26069123060496, 0.21047322383348988, 0.23121316790053204, 0.15055071830264866, 0.1729592916001631, 0.15026432453230754, 0.1616447851653917, 0.17085387427175613, 0.15199760306213395, 0.17540669454915436, 0.1538046162261868, 0.16874507257072802, 0.17760135785960285, 0.18749434646649288, 0.20249241746920754, 0.20690032188396368, 0.34416960397673324, 0.18171262061645, 0.185538090787139, 0.16877490528832606, 0.20030594276709246, 0.1576085046399074, 0.14812125737108073, 0.4385825256208198, 0.15974211591676646, 0.16007421948220268, 0.18293468799220414, 0.17901440984497874, 0.46696878007168063, 0.46607971886379884, 0.14005996875482174, 0.14385177591177722, 0.4192714915108856, 0.16920856276918517, 0.12931705541008176, 0.4707556582468152, 0.1925934546980077, 0.16725466960283863, 0.18108742825659974, 0.1870368800811104, 0.16990068678429615, 0.18161485489670848, 0.2197641556397223, 0.1765483828890272, 0.16770283394056718, 0.19499890763862315, 0.17960162274204816, 0.1768751088804542, 0.05662666702409225, 0.06509878423820714, 0.06520166790820969, 0.06014754764266472, 0.06052801331681712, 0.0750463158024599, 0.06066943877128139, 0.056358931704133974, 0.0685021513494134]}, "mutation_prompt": null}
{"id": "38cbf992-ce4b-4938-97fa-46c1b2d16a70", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.95\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x**2))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.35 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget))))  # Modified dynamic adaptation\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.25, self.dim),  # Modified from 0.2 to 0.25\n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = np.vstack((population[ranked_indices[:self.population_size]], best_solution))  # Add best solution for elitism\n            fitness = np.append(fitness[ranked_indices[:self.population_size]], best_fitness)  # Maintain corresponding fitness\n\n        return best_solution", "name": "HybridDESA", "description": "Improved dynamic population adaptation and refined local search to enhance exploration and convergence.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "97aec39a-06f4-406c-b072-0fe6a66600cb", "metadata": {"aucs": [0.38558279940440066, 0.3609503798038901, 0.3791100187406563, 0.37165266215160475, 0.38999180788037124, 0.3871134905578162, 0.3842147971693174, 0.3827804354706522, 0.37048786575858594, 0.37708018172181734, 0.34428376400991934, 0.35734872155395436, 0.3680661052415707, 0.3758876208516555, 0.38720338661262144, 0.3219505285050154, 0.3295189922233256, 0.3608783087021509, 0.11115610563140976, 0.09908915671666019, 0.11049796396595224, 0.10399744370061448, 0.1305424994142539, 0.11339181349994865, 0.11410905539947258, 0.3272060953007032, 0.10668621877750428, 0.097119647191106, 0.31555653205737355, 0.1066189875512682, 0.1096620489590856, 0.07995079765568514, 0.09997425407650662, 0.08819741632640521, 0.08689528943462987, 0.11181669251809145, 0.9855044408535428, 0.9490778590710266, 0.9554756351964058, 0.8953902141647986, 0.9732644077565413, 0.9053038102148867, 0.8145665313692394, 0.963560974260261, 0.9065833018858803, 0.32136742904932536, 0.2525887188280115, 0.2969909826398506, 0.2953519465609691, 0.2977356962408224, 0.3093143131796341, 0.3353097164828992, 0.28752682111657735, 0.32232703827610676, 0.4923653636460419, 0.4912604313326253, 0.25261030972929244, 0.4834335177549848, 0.46558961298266666, 0.4870099880004952, 0.4666578709685061, 0.473799313393244, 0.4886752127701931, 0.19148957532340216, 0.20627481945919546, 0.2958516352775179, 0.15122491047808528, 0.23620872626032807, 0.26318122337586247, 0.26061438024934247, 0.17096745058966967, 0.24898584449878203, 0.24482549497580008, 0.21074757010603384, 0.10238267377895505, 0.18653876956799165, 0.2786500721233667, 0.21470096893039048, 0.21550725645778612, 0.18719478151872482, 0.17364175670543702, 0.05033484828355772, 0.24029899392974563, 0.05841463667988045, 0.04714755210604782, 0.0737680105947347, 0.14257713286722196, 0.30240915076768105, 0.21548573678118443, 0.010085476949776018, 0.19924228826192825, 0.2718602343066092, 0.19169052073071136, 0.12100729663601528, 0.21856156282212857, 0.2410592921696737, 0.32249219900927384, 0.2696968773636642, 0.27383115304388284, 0.02721298272462258, 0.04236757585505946, 0.026755752323254778, 0.14018984921781208, 0.02953043616537221, 0.14565809746465308, 0.07996565159905256, 0.11166437396084217, 0.08007655168808814, 0.1868004482804253, 0.202424787175995, 0.1691603285143214, 0.18374084442464966, 0.21128505657328245, 0.21617201136005437, 0.17295313359432563, 0.1811343973372871, 0.152667918050154, 0.3397286833695359, 0.29837021107268047, 0.31255343579613526, 0.3170858179924362, 0.33183974651513837, 0.3057191395393466, 0.37314218187823744, 0.3472297650492424, 0.3288386262777845, 0.11859054119150747, 0.06838324830648257, 0.07334772972723491, 0.06529738333371238, 0.09586032090980101, 0.060127435664957374, 0.06711811236362386, 0.0653520706631352, 0.0751152261657384, 0.13157166540084764, 0.15762577769546715, 0.22389013106589628, 0.15971207719954306, 0.17065583660711747, 0.21800359372996325, 0.2176111451718984, 0.3162693249937646, 0.17738190747136107, 0.29599492750971135, 0.2840079399736276, 0.24759501185723787, 0.2999697797106864, 0.26131337731955073, 0.25960658224417943, 0.2547544010265941, 0.3168241330506947, 0.27931639263466856, 0.20986808251689182, 0.26168448011925394, 0.19190425832620872, 0.1842673575833944, 0.263217702915734, 0.16548679536904398, 0.26069123060496, 0.21047322383348988, 0.23121316790053204, 0.15055071830264866, 0.1729592916001631, 0.15026432453230754, 0.1616447851653917, 0.17085387427175613, 0.15199760306213395, 0.17540669454915436, 0.1538046162261868, 0.16874507257072802, 0.17760135785960285, 0.18749434646649288, 0.20249241746920754, 0.20690032188396368, 0.34416960397673324, 0.18171262061645, 0.185538090787139, 0.16877490528832606, 0.20030594276709246, 0.1576085046399074, 0.14812125737108073, 0.4385825256208198, 0.15974211591676646, 0.16007421948220268, 0.18293468799220414, 0.17901440984497874, 0.46696878007168063, 0.46607971886379884, 0.14005996875482174, 0.14385177591177722, 0.4192714915108856, 0.16920856276918517, 0.12931705541008176, 0.4707556582468152, 0.1925934546980077, 0.16725466960283863, 0.18108742825659974, 0.1870368800811104, 0.16990068678429615, 0.18161485489670848, 0.2197641556397223, 0.1765483828890272, 0.16770283394056718, 0.19499890763862315, 0.17960162274204816, 0.1768751088804542, 0.05662666702409225, 0.06509878423820714, 0.06520166790820969, 0.06014754764266472, 0.06052801331681712, 0.0750463158024599, 0.06066943877128139, 0.056358931704133974, 0.0685021513494134]}, "mutation_prompt": null}
{"id": "89306840-77cd-4c1b-ab9e-d5c195ee1df8", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.95\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x**2))\n\n    def _levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / (np.abs(v) ** (1 / beta))\n        return 0.1 * step  # Levy flight multiplier\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.35 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget))))  # Modified dynamic adaptation\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.25, self.dim) + self._levy_flight(self.dim),  # Added Lévy flight\n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = np.vstack((population[ranked_indices[:self.population_size]], best_solution))  # Add best solution for elitism\n            fitness = np.append(fitness[ranked_indices[:self.population_size]], best_fitness)  # Maintain corresponding fitness\n\n        return best_solution", "name": "HybridDESA", "description": "Enhanced exploration through Lévy flight strategy and adaptive mutation scaling to improve global search capabilities.", "configspace": "", "generation": 77, "fitness": 0.23288814069618788, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.17.", "error": "", "parent_id": "97aec39a-06f4-406c-b072-0fe6a66600cb", "metadata": {"aucs": [0.36572180763018847, 0.3915957844907084, 0.40158499151686233, 0.3827043658882774, 0.36919998026044454, 0.4108905571089283, 0.3772762335348241, 0.3805564771652161, 0.3709781985693771, 0.3457492109293141, 0.34952892281797776, 0.36160722951227076, 0.3558404665503888, 0.36932221509835284, 0.356207535840079, 0.31669350138650476, 0.32309190011481237, 0.3714115087913098, 0.07985494482859756, 0.11353524428471995, 0.107421104509134, 0.10763271889428128, 0.35891301138086795, 0.10416665778395962, 0.08751343006857537, 0.09221805292294794, 0.11324098059811061, 0.10772025274218999, 0.09767285106694767, 0.09977412353820436, 0.10398411246797701, 0.08765994348189399, 0.09777319082407121, 0.12109884931043202, 0.126365263495398, 0.10918216074712928, 0.8808007463919141, 0.9190857529647222, 0.9504634565823914, 0.9021850006401684, 0.8918163874138348, 0.8824543624249119, 0.796583983329798, 0.8231164491578378, 0.9726244253315295, 0.29488813171029804, 0.30528448251242, 0.2827867959032543, 0.29985967250596945, 0.3105803821779778, 0.292039554029475, 0.30069996348622985, 0.2803783575678539, 0.29648992880643166, 0.2593420699572646, 0.4756622968138391, 0.4878450905826518, 0.24092149095420268, 0.25004922175823774, 0.4662971279982173, 0.48460403004159036, 0.5129788126164678, 0.2639372853605204, 0.14596376727456695, 0.15738283799926178, 0.2720012456645454, 0.2688685445184157, 0.17175022930943018, 0.15576309124387366, 0.28412256280294945, 0.19696562803246187, 0.17788827640087657, 0.12138738559925699, 0.07055851958501402, 0.16374507447727105, 0.17452852946729236, 0.23896451634718474, 0.31217036170446766, 0.2072505723829322, 0.29614347855323486, 0.1879551227573032, 0.11946980173361166, 0.15442830233357563, 0.004980067204403915, 0.1013570907646103, 0.03595876574303314, 0.0644678665095193, 0.07563795293777142, 0.03354483397125385, 9.999999999998899e-05, 0.13146013822329095, 0.26665537376895754, 0.2859096365903129, 0.27295185650889076, 0.1872230636223028, 0.2693406071821436, 0.24769434450861183, 0.23705149237456713, 0.3001026202847408, 0.1565234833873579, 0.034879362078061416, 0.10826560582438216, 0.07584110862083249, 0.14338024306267816, 0.1762959950753109, 0.1640186734918485, 0.07726544386818335, 0.082189200220667, 0.1778239493313224, 0.14972992909803906, 0.17416241988511771, 0.20289409221832522, 0.20601624998245838, 0.20190423521831713, 0.18554283529784443, 0.1726826868208463, 0.1409889453427262, 0.3248440822242805, 0.33876860498264993, 0.3357032012974883, 0.3527987894419151, 0.32448419420609875, 0.32026149493181755, 0.30476182548020214, 0.32048819553151975, 0.3073913912063089, 0.10500973748305265, 0.09530798601950885, 0.09021410200722513, 0.07948656918231123, 0.08771437892845102, 0.09367219175193764, 0.06742210261223847, 0.07550040196311236, 0.10971242719832985, 0.22089716346789523, 0.1409955862557526, 0.14813364783869332, 0.1671906553387531, 0.13687815130592063, 0.13043032717644842, 0.15091315525645332, 0.14554221456800354, 0.25600850866791447, 0.24598477643746997, 0.31579139919116495, 0.18679639188975694, 0.2547955104750723, 0.24812887823200103, 0.28791035217334704, 0.26591646064889163, 0.29179703706718796, 0.2545173827867486, 0.23892758253388013, 0.1636142009444046, 0.18827716518843018, 0.15399780924076134, 0.14729871473012213, 0.1736203694384092, 0.1660665435500145, 0.1954267599433056, 0.216371652023301, 0.1526051637143846, 0.14482765937983766, 0.14949673317793588, 0.1862242615572518, 0.15733639478403982, 0.15976745353435695, 0.19464590172130924, 0.16184942813512737, 0.15258233763496332, 0.18462830823446752, 0.20546813980652812, 0.20556729273911423, 0.20527465870715322, 0.18361458939095443, 0.18675008500774382, 0.1752002686100972, 0.37987392991467017, 0.3934319586311036, 0.15661397636574326, 0.14217215332954913, 0.18427882628743597, 0.1654199258513538, 0.16599223662033624, 0.1659168074200812, 0.16817396476594515, 0.17933725375385456, 0.17227852272490363, 0.4549302404386, 0.3825214103703183, 0.14974030260949334, 0.10975259619391786, 0.12848819113873033, 0.10593807826471324, 0.18958849043646042, 0.1891533228854969, 0.1823462661785611, 0.17996574713999414, 0.18341326871044328, 0.18316865507788227, 0.17414252276828834, 0.1776673984909336, 0.19240862354568866, 0.18776038187004584, 0.18184723242842582, 0.17576931948649743, 0.05055646343709319, 0.06971612640935965, 0.06162166301608363, 0.06899057309888612, 0.06903116637668483, 0.0656802235632944, 0.07021969245005055, 0.08095093960776722, 0.07176013338654519]}, "mutation_prompt": null}
{"id": "f4b139e0-fb5e-406c-8132-54ee4ffcb3d3", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.95\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x**2))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.35 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget))))  # Modified dynamic adaptation\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.25, self.dim),  # Modified from 0.2 to 0.25\n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = np.vstack((population[ranked_indices[:self.population_size]], best_solution))  # Add best solution for elitism\n            fitness = np.append(fitness[ranked_indices[:self.population_size]], best_fitness)  # Maintain corresponding fitness\n\n        return best_solution", "name": "HybridDESA", "description": "Improved dynamic population adaptation and refined local search to enhance exploration and convergence.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "97aec39a-06f4-406c-b072-0fe6a66600cb", "metadata": {"aucs": [0.38558279940440066, 0.3609503798038901, 0.3791100187406563, 0.37165266215160475, 0.38999180788037124, 0.3871134905578162, 0.3842147971693174, 0.3827804354706522, 0.37048786575858594, 0.37708018172181734, 0.34428376400991934, 0.35734872155395436, 0.3680661052415707, 0.3758876208516555, 0.38720338661262144, 0.3219505285050154, 0.3295189922233256, 0.3608783087021509, 0.11115610563140976, 0.09908915671666019, 0.11049796396595224, 0.10399744370061448, 0.1305424994142539, 0.11339181349994865, 0.11410905539947258, 0.3272060953007032, 0.10668621877750428, 0.097119647191106, 0.31555653205737355, 0.1066189875512682, 0.1096620489590856, 0.07995079765568514, 0.09997425407650662, 0.08819741632640521, 0.08689528943462987, 0.11181669251809145, 0.9855044408535428, 0.9490778590710266, 0.9554756351964058, 0.8953902141647986, 0.9732644077565413, 0.9053038102148867, 0.8145665313692394, 0.963560974260261, 0.9065833018858803, 0.32136742904932536, 0.2525887188280115, 0.2969909826398506, 0.2953519465609691, 0.2977356962408224, 0.3093143131796341, 0.3353097164828992, 0.28752682111657735, 0.32232703827610676, 0.4923653636460419, 0.4912604313326253, 0.25261030972929244, 0.4834335177549848, 0.46558961298266666, 0.4870099880004952, 0.4666578709685061, 0.473799313393244, 0.4886752127701931, 0.19148957532340216, 0.20627481945919546, 0.2958516352775179, 0.15122491047808528, 0.23620872626032807, 0.26318122337586247, 0.26061438024934247, 0.17096745058966967, 0.24898584449878203, 0.24482549497580008, 0.21074757010603384, 0.10238267377895505, 0.18653876956799165, 0.2786500721233667, 0.21470096893039048, 0.21550725645778612, 0.18719478151872482, 0.17364175670543702, 0.05033484828355772, 0.24029899392974563, 0.05841463667988045, 0.04714755210604782, 0.0737680105947347, 0.14257713286722196, 0.30240915076768105, 0.21548573678118443, 0.010085476949776018, 0.19924228826192825, 0.2718602343066092, 0.19169052073071136, 0.12100729663601528, 0.21856156282212857, 0.2410592921696737, 0.32249219900927384, 0.2696968773636642, 0.27383115304388284, 0.02721298272462258, 0.04236757585505946, 0.026755752323254778, 0.14018984921781208, 0.02953043616537221, 0.14565809746465308, 0.07996565159905256, 0.11166437396084217, 0.08007655168808814, 0.1868004482804253, 0.202424787175995, 0.1691603285143214, 0.18374084442464966, 0.21128505657328245, 0.21617201136005437, 0.17295313359432563, 0.1811343973372871, 0.152667918050154, 0.3397286833695359, 0.29837021107268047, 0.31255343579613526, 0.3170858179924362, 0.33183974651513837, 0.3057191395393466, 0.37314218187823744, 0.3472297650492424, 0.3288386262777845, 0.11859054119150747, 0.06838324830648257, 0.07334772972723491, 0.06529738333371238, 0.09586032090980101, 0.060127435664957374, 0.06711811236362386, 0.0653520706631352, 0.0751152261657384, 0.13157166540084764, 0.15762577769546715, 0.22389013106589628, 0.15971207719954306, 0.17065583660711747, 0.21800359372996325, 0.2176111451718984, 0.3162693249937646, 0.17738190747136107, 0.29599492750971135, 0.2840079399736276, 0.24759501185723787, 0.2999697797106864, 0.26131337731955073, 0.25960658224417943, 0.2547544010265941, 0.3168241330506947, 0.27931639263466856, 0.20986808251689182, 0.26168448011925394, 0.19190425832620872, 0.1842673575833944, 0.263217702915734, 0.16548679536904398, 0.26069123060496, 0.21047322383348988, 0.23121316790053204, 0.15055071830264866, 0.1729592916001631, 0.15026432453230754, 0.1616447851653917, 0.17085387427175613, 0.15199760306213395, 0.17540669454915436, 0.1538046162261868, 0.16874507257072802, 0.17760135785960285, 0.18749434646649288, 0.20249241746920754, 0.20690032188396368, 0.34416960397673324, 0.18171262061645, 0.185538090787139, 0.16877490528832606, 0.20030594276709246, 0.1576085046399074, 0.14812125737108073, 0.4385825256208198, 0.15974211591676646, 0.16007421948220268, 0.18293468799220414, 0.17901440984497874, 0.46696878007168063, 0.46607971886379884, 0.14005996875482174, 0.14385177591177722, 0.4192714915108856, 0.16920856276918517, 0.12931705541008176, 0.4707556582468152, 0.1925934546980077, 0.16725466960283863, 0.18108742825659974, 0.1870368800811104, 0.16990068678429615, 0.18161485489670848, 0.2197641556397223, 0.1765483828890272, 0.16770283394056718, 0.19499890763862315, 0.17960162274204816, 0.1768751088804542, 0.05662666702409225, 0.06509878423820714, 0.06520166790820969, 0.06014754764266472, 0.06052801331681712, 0.0750463158024599, 0.06066943877128139, 0.056358931704133974, 0.0685021513494134]}, "mutation_prompt": null}
{"id": "371e806c-0641-4fa3-be64-2b90ea9cd185", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.95\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x**2))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.35 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget))))  # Modified dynamic adaptation\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.25, self.dim),  # Modified from 0.2 to 0.25\n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = np.vstack((population[ranked_indices[:self.population_size]], best_solution))  # Add best solution for elitism\n            fitness = np.append(fitness[ranked_indices[:self.population_size]], best_fitness)  # Maintain corresponding fitness\n\n        return best_solution", "name": "HybridDESA", "description": "Improved dynamic population adaptation and refined local search to enhance exploration and convergence.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "97aec39a-06f4-406c-b072-0fe6a66600cb", "metadata": {"aucs": [0.38558279940440066, 0.3609503798038901, 0.3791100187406563, 0.37165266215160475, 0.38999180788037124, 0.3871134905578162, 0.3842147971693174, 0.3827804354706522, 0.37048786575858594, 0.37708018172181734, 0.34428376400991934, 0.35734872155395436, 0.3680661052415707, 0.3758876208516555, 0.38720338661262144, 0.3219505285050154, 0.3295189922233256, 0.3608783087021509, 0.11115610563140976, 0.09908915671666019, 0.11049796396595224, 0.10399744370061448, 0.1305424994142539, 0.11339181349994865, 0.11410905539947258, 0.3272060953007032, 0.10668621877750428, 0.097119647191106, 0.31555653205737355, 0.1066189875512682, 0.1096620489590856, 0.07995079765568514, 0.09997425407650662, 0.08819741632640521, 0.08689528943462987, 0.11181669251809145, 0.9855044408535428, 0.9490778590710266, 0.9554756351964058, 0.8953902141647986, 0.9732644077565413, 0.9053038102148867, 0.8145665313692394, 0.963560974260261, 0.9065833018858803, 0.32136742904932536, 0.2525887188280115, 0.2969909826398506, 0.2953519465609691, 0.2977356962408224, 0.3093143131796341, 0.3353097164828992, 0.28752682111657735, 0.32232703827610676, 0.4923653636460419, 0.4912604313326253, 0.25261030972929244, 0.4834335177549848, 0.46558961298266666, 0.4870099880004952, 0.4666578709685061, 0.473799313393244, 0.4886752127701931, 0.19148957532340216, 0.20627481945919546, 0.2958516352775179, 0.15122491047808528, 0.23620872626032807, 0.26318122337586247, 0.26061438024934247, 0.17096745058966967, 0.24898584449878203, 0.24482549497580008, 0.21074757010603384, 0.10238267377895505, 0.18653876956799165, 0.2786500721233667, 0.21470096893039048, 0.21550725645778612, 0.18719478151872482, 0.17364175670543702, 0.05033484828355772, 0.24029899392974563, 0.05841463667988045, 0.04714755210604782, 0.0737680105947347, 0.14257713286722196, 0.30240915076768105, 0.21548573678118443, 0.010085476949776018, 0.19924228826192825, 0.2718602343066092, 0.19169052073071136, 0.12100729663601528, 0.21856156282212857, 0.2410592921696737, 0.32249219900927384, 0.2696968773636642, 0.27383115304388284, 0.02721298272462258, 0.04236757585505946, 0.026755752323254778, 0.14018984921781208, 0.02953043616537221, 0.14565809746465308, 0.07996565159905256, 0.11166437396084217, 0.08007655168808814, 0.1868004482804253, 0.202424787175995, 0.1691603285143214, 0.18374084442464966, 0.21128505657328245, 0.21617201136005437, 0.17295313359432563, 0.1811343973372871, 0.152667918050154, 0.3397286833695359, 0.29837021107268047, 0.31255343579613526, 0.3170858179924362, 0.33183974651513837, 0.3057191395393466, 0.37314218187823744, 0.3472297650492424, 0.3288386262777845, 0.11859054119150747, 0.06838324830648257, 0.07334772972723491, 0.06529738333371238, 0.09586032090980101, 0.060127435664957374, 0.06711811236362386, 0.0653520706631352, 0.0751152261657384, 0.13157166540084764, 0.15762577769546715, 0.22389013106589628, 0.15971207719954306, 0.17065583660711747, 0.21800359372996325, 0.2176111451718984, 0.3162693249937646, 0.17738190747136107, 0.29599492750971135, 0.2840079399736276, 0.24759501185723787, 0.2999697797106864, 0.26131337731955073, 0.25960658224417943, 0.2547544010265941, 0.3168241330506947, 0.27931639263466856, 0.20986808251689182, 0.26168448011925394, 0.19190425832620872, 0.1842673575833944, 0.263217702915734, 0.16548679536904398, 0.26069123060496, 0.21047322383348988, 0.23121316790053204, 0.15055071830264866, 0.1729592916001631, 0.15026432453230754, 0.1616447851653917, 0.17085387427175613, 0.15199760306213395, 0.17540669454915436, 0.1538046162261868, 0.16874507257072802, 0.17760135785960285, 0.18749434646649288, 0.20249241746920754, 0.20690032188396368, 0.34416960397673324, 0.18171262061645, 0.185538090787139, 0.16877490528832606, 0.20030594276709246, 0.1576085046399074, 0.14812125737108073, 0.4385825256208198, 0.15974211591676646, 0.16007421948220268, 0.18293468799220414, 0.17901440984497874, 0.46696878007168063, 0.46607971886379884, 0.14005996875482174, 0.14385177591177722, 0.4192714915108856, 0.16920856276918517, 0.12931705541008176, 0.4707556582468152, 0.1925934546980077, 0.16725466960283863, 0.18108742825659974, 0.1870368800811104, 0.16990068678429615, 0.18161485489670848, 0.2197641556397223, 0.1765483828890272, 0.16770283394056718, 0.19499890763862315, 0.17960162274204816, 0.1768751088804542, 0.05662666702409225, 0.06509878423820714, 0.06520166790820969, 0.06014754764266472, 0.06052801331681712, 0.0750463158024599, 0.06066943877128139, 0.056358931704133974, 0.0685021513494134]}, "mutation_prompt": null}
{"id": "f08c1b8a-4f46-4960-a55e-7a806fb326b3", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.98  # Modified from 0.95 to 0.98\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x**2))\n\n    def _levy_flight(self, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]) + self._levy_flight(),  # Added Levy flight\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.35 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget))))  # Modified dynamic adaptation\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.25, self.dim),  # Modified from 0.2 to 0.25\n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = np.vstack((population[ranked_indices[:self.population_size]], best_solution))  # Add best solution for elitism\n            fitness = np.append(fitness[ranked_indices[:self.population_size]], best_fitness)  # Maintain corresponding fitness\n\n        return best_solution", "name": "HybridDESA", "description": "Enhanced exploration by introducing Levy flight for global search and hyperbolic cooling for annealing.", "configspace": "", "generation": 80, "fitness": 0.1455197200423919, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.17.", "error": "", "parent_id": "97aec39a-06f4-406c-b072-0fe6a66600cb", "metadata": {"aucs": [0.19781670240336047, 0.2022293739136548, 0.20019959315624047, 0.2177786455295493, 0.2232805438255535, 0.22417962932019186, 0.21296300139708513, 0.20497501987041278, 0.20082771066218175, 0.020648221571779368, 0.07166311297253214, 0.058640673853770586, 0.01225389289266765, 0.019277523575072508, 0.0016812247335415975, 0.020594409136526104, 0.047623906453450604, 0.021551473277972577, 0.05060281096710095, 0.06222932639367096, 0.07316733589274849, 0.05641467658677635, 0.0672668634512642, 0.06223832436975174, 0.06306971888995283, 0.05850703973167459, 0.0598717054158171, 0.050509903676708934, 0.050300215503139234, 0.05138512978200305, 0.05828478838306872, 0.06047825403198459, 0.05724568338305758, 0.05792143014077411, 0.04983194187908102, 0.052306498385231825, 0.9413664344143514, 0.8828760952885046, 0.9715472035983836, 0.920894004449696, 0.7428028862179584, 0.8725843998493621, 0.973968695969569, 0.9726043635267766, 0.9321711954966316, 0.1218895968735133, 0.1574430096529028, 0.13936385048807465, 0.13737944563340243, 0.1432319308070502, 0.14102503307252268, 0.14495581700404714, 0.14757143369689307, 0.1403496973253312, 0.15482964148643785, 0.15008176848823984, 0.15331906127669714, 0.1434947429937089, 0.1746581207451412, 0.1595161712975458, 0.17579924992488338, 0.15606921429601917, 0.16151996049252337, 0.07298898147952226, 0.09540439055413386, 0.0759887392619607, 0.08736969900750524, 0.09797727335226303, 0.11155088001188473, 0.08968202804631531, 0.10501735653070321, 0.11180005318630082, 0.09881444337685641, 0.08983413637062398, 0.049942885401074055, 0.09003483269809842, 0.11200186473673379, 0.0866022961812416, 0.05237132572978642, 0.046579304087540185, 0.03409214953726192, 0.026457042380980456, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0407176377663927, 0.07929953395429279, 0.07614949515490466, 0.08771917721074185, 0.1033892397015912, 0.08558937499070762, 0.0498845376926651, 0.06574351099787834, 0.0711471808952332, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.029942184553502393, 0.03831032955726443, 0.014182493510517813, 0.037718966462736314, 0.0369883845597998, 0.03346521755535381, 0.024978125378030014, 0.041169270154661874, 0.028478156389072917, 0.20797329357823546, 0.22420477784716109, 0.21817391421821386, 0.20026894734002998, 0.22188529301416837, 0.23083720450620648, 0.22021334910992085, 0.2195334731236147, 0.20969016174398913, 0.06279893340122067, 0.05920726928668485, 0.06205732471595149, 0.04957475058415417, 0.04876321193943445, 0.05543616548597219, 0.04808865884107294, 0.04693197147359629, 0.05435910385567799, 0.14951825151927112, 0.1424148945728091, 0.1872428191822436, 0.1423669112867334, 0.183051995048631, 0.1736566640105217, 0.18423874291643239, 0.14553562449944168, 0.14790170476740916, 0.15826499120453152, 0.17980561122647265, 0.17211274747589145, 0.18733609770028126, 0.16342260731345848, 0.17370787948555466, 0.1776062305866557, 0.17979882546181725, 0.18116914197743006, 0.11576723364450259, 0.1085570863016534, 0.12024657818515916, 0.11420877511850447, 0.15218405728877316, 0.11134227602332025, 0.13204624706836332, 0.13794863825599846, 0.11848183264157763, 0.1389935508250406, 0.14005310173866037, 0.13715739804890037, 0.15382618340001175, 0.15683064263617164, 0.15724416967795385, 0.14867401055871798, 0.15115026998880754, 0.1403717272593411, 0.16539315479090022, 0.17051500990428992, 0.1777688790686307, 0.1621111535149341, 0.16630627930637076, 0.17451752855962333, 0.16661224987668388, 0.16620629512928775, 0.16944866856464813, 0.16373120215958514, 0.26378236985702175, 0.15301509440587946, 0.17196771397296018, 0.25462570569628595, 0.15894804618461256, 0.16039498194534463, 0.16763952122872883, 0.163234294593131, 0.19873635129095935, 0.211654164654571, 0.13956645885647545, 0.18783321164403766, 0.15871557028519634, 0.1427948047378348, 0.187349779607611, 0.18813163103749997, 0.1568830306827309, 0.19445561503216002, 0.1933905172005319, 0.1860825078311371, 0.1933917038241546, 0.18140048969264055, 0.19407418418210232, 0.1852076451109287, 0.20007608111865716, 0.19264735510377717, 0.052945756757106555, 0.05208065677021845, 0.06656711308572516, 0.04653368315194806, 0.046885370235159485, 0.04989764412043696, 0.049945947391683565, 0.050674866865233925, 0.04967408897321424]}, "mutation_prompt": null}
{"id": "214c7afc-9016-433f-92c4-0a5b965a4ebd", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.95\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x**2))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.35 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget))))  # Modified dynamic adaptation\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.25, self.dim),  # Modified from 0.2 to 0.25\n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = np.vstack((population[ranked_indices[:self.population_size]], best_solution))  # Add best solution for elitism\n            fitness = np.append(fitness[ranked_indices[:self.population_size]], best_fitness)  # Maintain corresponding fitness\n\n        return best_solution", "name": "HybridDESA", "description": "Improved dynamic population adaptation and refined local search to enhance exploration and convergence.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "97aec39a-06f4-406c-b072-0fe6a66600cb", "metadata": {"aucs": [0.38558279940440066, 0.3609503798038901, 0.3791100187406563, 0.37165266215160475, 0.38999180788037124, 0.3871134905578162, 0.3842147971693174, 0.3827804354706522, 0.37048786575858594, 0.37708018172181734, 0.34428376400991934, 0.35734872155395436, 0.3680661052415707, 0.3758876208516555, 0.38720338661262144, 0.3219505285050154, 0.3295189922233256, 0.3608783087021509, 0.11115610563140976, 0.09908915671666019, 0.11049796396595224, 0.10399744370061448, 0.1305424994142539, 0.11339181349994865, 0.11410905539947258, 0.3272060953007032, 0.10668621877750428, 0.097119647191106, 0.31555653205737355, 0.1066189875512682, 0.1096620489590856, 0.07995079765568514, 0.09997425407650662, 0.08819741632640521, 0.08689528943462987, 0.11181669251809145, 0.9855044408535428, 0.9490778590710266, 0.9554756351964058, 0.8953902141647986, 0.9732644077565413, 0.9053038102148867, 0.8145665313692394, 0.963560974260261, 0.9065833018858803, 0.32136742904932536, 0.2525887188280115, 0.2969909826398506, 0.2953519465609691, 0.2977356962408224, 0.3093143131796341, 0.3353097164828992, 0.28752682111657735, 0.32232703827610676, 0.4923653636460419, 0.4912604313326253, 0.25261030972929244, 0.4834335177549848, 0.46558961298266666, 0.4870099880004952, 0.4666578709685061, 0.473799313393244, 0.4886752127701931, 0.19148957532340216, 0.20627481945919546, 0.2958516352775179, 0.15122491047808528, 0.23620872626032807, 0.26318122337586247, 0.26061438024934247, 0.17096745058966967, 0.24898584449878203, 0.24482549497580008, 0.21074757010603384, 0.10238267377895505, 0.18653876956799165, 0.2786500721233667, 0.21470096893039048, 0.21550725645778612, 0.18719478151872482, 0.17364175670543702, 0.05033484828355772, 0.24029899392974563, 0.05841463667988045, 0.04714755210604782, 0.0737680105947347, 0.14257713286722196, 0.30240915076768105, 0.21548573678118443, 0.010085476949776018, 0.19924228826192825, 0.2718602343066092, 0.19169052073071136, 0.12100729663601528, 0.21856156282212857, 0.2410592921696737, 0.32249219900927384, 0.2696968773636642, 0.27383115304388284, 0.02721298272462258, 0.04236757585505946, 0.026755752323254778, 0.14018984921781208, 0.02953043616537221, 0.14565809746465308, 0.07996565159905256, 0.11166437396084217, 0.08007655168808814, 0.1868004482804253, 0.202424787175995, 0.1691603285143214, 0.18374084442464966, 0.21128505657328245, 0.21617201136005437, 0.17295313359432563, 0.1811343973372871, 0.152667918050154, 0.3397286833695359, 0.29837021107268047, 0.31255343579613526, 0.3170858179924362, 0.33183974651513837, 0.3057191395393466, 0.37314218187823744, 0.3472297650492424, 0.3288386262777845, 0.11859054119150747, 0.06838324830648257, 0.07334772972723491, 0.06529738333371238, 0.09586032090980101, 0.060127435664957374, 0.06711811236362386, 0.0653520706631352, 0.0751152261657384, 0.13157166540084764, 0.15762577769546715, 0.22389013106589628, 0.15971207719954306, 0.17065583660711747, 0.21800359372996325, 0.2176111451718984, 0.3162693249937646, 0.17738190747136107, 0.29599492750971135, 0.2840079399736276, 0.24759501185723787, 0.2999697797106864, 0.26131337731955073, 0.25960658224417943, 0.2547544010265941, 0.3168241330506947, 0.27931639263466856, 0.20986808251689182, 0.26168448011925394, 0.19190425832620872, 0.1842673575833944, 0.263217702915734, 0.16548679536904398, 0.26069123060496, 0.21047322383348988, 0.23121316790053204, 0.15055071830264866, 0.1729592916001631, 0.15026432453230754, 0.1616447851653917, 0.17085387427175613, 0.15199760306213395, 0.17540669454915436, 0.1538046162261868, 0.16874507257072802, 0.17760135785960285, 0.18749434646649288, 0.20249241746920754, 0.20690032188396368, 0.34416960397673324, 0.18171262061645, 0.185538090787139, 0.16877490528832606, 0.20030594276709246, 0.1576085046399074, 0.14812125737108073, 0.4385825256208198, 0.15974211591676646, 0.16007421948220268, 0.18293468799220414, 0.17901440984497874, 0.46696878007168063, 0.46607971886379884, 0.14005996875482174, 0.14385177591177722, 0.4192714915108856, 0.16920856276918517, 0.12931705541008176, 0.4707556582468152, 0.1925934546980077, 0.16725466960283863, 0.18108742825659974, 0.1870368800811104, 0.16990068678429615, 0.18161485489670848, 0.2197641556397223, 0.1765483828890272, 0.16770283394056718, 0.19499890763862315, 0.17960162274204816, 0.1768751088804542, 0.05662666702409225, 0.06509878423820714, 0.06520166790820969, 0.06014754764266472, 0.06052801331681712, 0.0750463158024599, 0.06066943877128139, 0.056358931704133974, 0.0685021513494134]}, "mutation_prompt": null}
{"id": "64761a03-3749-4b38-b06b-3326a61b9414", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.95\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x**2))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.35 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget))))  # Modified dynamic adaptation\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.25, self.dim),  # Modified from 0.2 to 0.25\n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = np.vstack((population[ranked_indices[:self.population_size]], best_solution))  # Add best solution for elitism\n            fitness = np.append(fitness[ranked_indices[:self.population_size]], best_fitness)  # Maintain corresponding fitness\n\n        return best_solution", "name": "HybridDESA", "description": "Improved dynamic population adaptation and refined local search to enhance exploration and convergence.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "97aec39a-06f4-406c-b072-0fe6a66600cb", "metadata": {"aucs": [0.38558279940440066, 0.3609503798038901, 0.3791100187406563, 0.37165266215160475, 0.38999180788037124, 0.3871134905578162, 0.3842147971693174, 0.3827804354706522, 0.37048786575858594, 0.37708018172181734, 0.34428376400991934, 0.35734872155395436, 0.3680661052415707, 0.3758876208516555, 0.38720338661262144, 0.3219505285050154, 0.3295189922233256, 0.3608783087021509, 0.11115610563140976, 0.09908915671666019, 0.11049796396595224, 0.10399744370061448, 0.1305424994142539, 0.11339181349994865, 0.11410905539947258, 0.3272060953007032, 0.10668621877750428, 0.097119647191106, 0.31555653205737355, 0.1066189875512682, 0.1096620489590856, 0.07995079765568514, 0.09997425407650662, 0.08819741632640521, 0.08689528943462987, 0.11181669251809145, 0.9855044408535428, 0.9490778590710266, 0.9554756351964058, 0.8953902141647986, 0.9732644077565413, 0.9053038102148867, 0.8145665313692394, 0.963560974260261, 0.9065833018858803, 0.32136742904932536, 0.2525887188280115, 0.2969909826398506, 0.2953519465609691, 0.2977356962408224, 0.3093143131796341, 0.3353097164828992, 0.28752682111657735, 0.32232703827610676, 0.4923653636460419, 0.4912604313326253, 0.25261030972929244, 0.4834335177549848, 0.46558961298266666, 0.4870099880004952, 0.4666578709685061, 0.473799313393244, 0.4886752127701931, 0.19148957532340216, 0.20627481945919546, 0.2958516352775179, 0.15122491047808528, 0.23620872626032807, 0.26318122337586247, 0.26061438024934247, 0.17096745058966967, 0.24898584449878203, 0.24482549497580008, 0.21074757010603384, 0.10238267377895505, 0.18653876956799165, 0.2786500721233667, 0.21470096893039048, 0.21550725645778612, 0.18719478151872482, 0.17364175670543702, 0.05033484828355772, 0.24029899392974563, 0.05841463667988045, 0.04714755210604782, 0.0737680105947347, 0.14257713286722196, 0.30240915076768105, 0.21548573678118443, 0.010085476949776018, 0.19924228826192825, 0.2718602343066092, 0.19169052073071136, 0.12100729663601528, 0.21856156282212857, 0.2410592921696737, 0.32249219900927384, 0.2696968773636642, 0.27383115304388284, 0.02721298272462258, 0.04236757585505946, 0.026755752323254778, 0.14018984921781208, 0.02953043616537221, 0.14565809746465308, 0.07996565159905256, 0.11166437396084217, 0.08007655168808814, 0.1868004482804253, 0.202424787175995, 0.1691603285143214, 0.18374084442464966, 0.21128505657328245, 0.21617201136005437, 0.17295313359432563, 0.1811343973372871, 0.152667918050154, 0.3397286833695359, 0.29837021107268047, 0.31255343579613526, 0.3170858179924362, 0.33183974651513837, 0.3057191395393466, 0.37314218187823744, 0.3472297650492424, 0.3288386262777845, 0.11859054119150747, 0.06838324830648257, 0.07334772972723491, 0.06529738333371238, 0.09586032090980101, 0.060127435664957374, 0.06711811236362386, 0.0653520706631352, 0.0751152261657384, 0.13157166540084764, 0.15762577769546715, 0.22389013106589628, 0.15971207719954306, 0.17065583660711747, 0.21800359372996325, 0.2176111451718984, 0.3162693249937646, 0.17738190747136107, 0.29599492750971135, 0.2840079399736276, 0.24759501185723787, 0.2999697797106864, 0.26131337731955073, 0.25960658224417943, 0.2547544010265941, 0.3168241330506947, 0.27931639263466856, 0.20986808251689182, 0.26168448011925394, 0.19190425832620872, 0.1842673575833944, 0.263217702915734, 0.16548679536904398, 0.26069123060496, 0.21047322383348988, 0.23121316790053204, 0.15055071830264866, 0.1729592916001631, 0.15026432453230754, 0.1616447851653917, 0.17085387427175613, 0.15199760306213395, 0.17540669454915436, 0.1538046162261868, 0.16874507257072802, 0.17760135785960285, 0.18749434646649288, 0.20249241746920754, 0.20690032188396368, 0.34416960397673324, 0.18171262061645, 0.185538090787139, 0.16877490528832606, 0.20030594276709246, 0.1576085046399074, 0.14812125737108073, 0.4385825256208198, 0.15974211591676646, 0.16007421948220268, 0.18293468799220414, 0.17901440984497874, 0.46696878007168063, 0.46607971886379884, 0.14005996875482174, 0.14385177591177722, 0.4192714915108856, 0.16920856276918517, 0.12931705541008176, 0.4707556582468152, 0.1925934546980077, 0.16725466960283863, 0.18108742825659974, 0.1870368800811104, 0.16990068678429615, 0.18161485489670848, 0.2197641556397223, 0.1765483828890272, 0.16770283394056718, 0.19499890763862315, 0.17960162274204816, 0.1768751088804542, 0.05662666702409225, 0.06509878423820714, 0.06520166790820969, 0.06014754764266472, 0.06052801331681712, 0.0750463158024599, 0.06066943877128139, 0.056358931704133974, 0.0685021513494134]}, "mutation_prompt": null}
{"id": "b05d5fc8-53fc-4cf1-8679-d2ab5f7fcc76", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.95\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x**2))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.35 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget))))  # Modified dynamic adaptation\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.25, self.dim),  # Modified from 0.2 to 0.25\n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = np.vstack((population[ranked_indices[:self.population_size]], best_solution))  # Add best solution for elitism\n            fitness = np.append(fitness[ranked_indices[:self.population_size]], best_fitness)  # Maintain corresponding fitness\n\n        return best_solution", "name": "HybridDESA", "description": "Improved dynamic population adaptation and refined local search to enhance exploration and convergence.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "97aec39a-06f4-406c-b072-0fe6a66600cb", "metadata": {"aucs": [0.38558279940440066, 0.3609503798038901, 0.3791100187406563, 0.37165266215160475, 0.38999180788037124, 0.3871134905578162, 0.3842147971693174, 0.3827804354706522, 0.37048786575858594, 0.37708018172181734, 0.34428376400991934, 0.35734872155395436, 0.3680661052415707, 0.3758876208516555, 0.38720338661262144, 0.3219505285050154, 0.3295189922233256, 0.3608783087021509, 0.11115610563140976, 0.09908915671666019, 0.11049796396595224, 0.10399744370061448, 0.1305424994142539, 0.11339181349994865, 0.11410905539947258, 0.3272060953007032, 0.10668621877750428, 0.097119647191106, 0.31555653205737355, 0.1066189875512682, 0.1096620489590856, 0.07995079765568514, 0.09997425407650662, 0.08819741632640521, 0.08689528943462987, 0.11181669251809145, 0.9855044408535428, 0.9490778590710266, 0.9554756351964058, 0.8953902141647986, 0.9732644077565413, 0.9053038102148867, 0.8145665313692394, 0.963560974260261, 0.9065833018858803, 0.32136742904932536, 0.2525887188280115, 0.2969909826398506, 0.2953519465609691, 0.2977356962408224, 0.3093143131796341, 0.3353097164828992, 0.28752682111657735, 0.32232703827610676, 0.4923653636460419, 0.4912604313326253, 0.25261030972929244, 0.4834335177549848, 0.46558961298266666, 0.4870099880004952, 0.4666578709685061, 0.473799313393244, 0.4886752127701931, 0.19148957532340216, 0.20627481945919546, 0.2958516352775179, 0.15122491047808528, 0.23620872626032807, 0.26318122337586247, 0.26061438024934247, 0.17096745058966967, 0.24898584449878203, 0.24482549497580008, 0.21074757010603384, 0.10238267377895505, 0.18653876956799165, 0.2786500721233667, 0.21470096893039048, 0.21550725645778612, 0.18719478151872482, 0.17364175670543702, 0.05033484828355772, 0.24029899392974563, 0.05841463667988045, 0.04714755210604782, 0.0737680105947347, 0.14257713286722196, 0.30240915076768105, 0.21548573678118443, 0.010085476949776018, 0.19924228826192825, 0.2718602343066092, 0.19169052073071136, 0.12100729663601528, 0.21856156282212857, 0.2410592921696737, 0.32249219900927384, 0.2696968773636642, 0.27383115304388284, 0.02721298272462258, 0.04236757585505946, 0.026755752323254778, 0.14018984921781208, 0.02953043616537221, 0.14565809746465308, 0.07996565159905256, 0.11166437396084217, 0.08007655168808814, 0.1868004482804253, 0.202424787175995, 0.1691603285143214, 0.18374084442464966, 0.21128505657328245, 0.21617201136005437, 0.17295313359432563, 0.1811343973372871, 0.152667918050154, 0.3397286833695359, 0.29837021107268047, 0.31255343579613526, 0.3170858179924362, 0.33183974651513837, 0.3057191395393466, 0.37314218187823744, 0.3472297650492424, 0.3288386262777845, 0.11859054119150747, 0.06838324830648257, 0.07334772972723491, 0.06529738333371238, 0.09586032090980101, 0.060127435664957374, 0.06711811236362386, 0.0653520706631352, 0.0751152261657384, 0.13157166540084764, 0.15762577769546715, 0.22389013106589628, 0.15971207719954306, 0.17065583660711747, 0.21800359372996325, 0.2176111451718984, 0.3162693249937646, 0.17738190747136107, 0.29599492750971135, 0.2840079399736276, 0.24759501185723787, 0.2999697797106864, 0.26131337731955073, 0.25960658224417943, 0.2547544010265941, 0.3168241330506947, 0.27931639263466856, 0.20986808251689182, 0.26168448011925394, 0.19190425832620872, 0.1842673575833944, 0.263217702915734, 0.16548679536904398, 0.26069123060496, 0.21047322383348988, 0.23121316790053204, 0.15055071830264866, 0.1729592916001631, 0.15026432453230754, 0.1616447851653917, 0.17085387427175613, 0.15199760306213395, 0.17540669454915436, 0.1538046162261868, 0.16874507257072802, 0.17760135785960285, 0.18749434646649288, 0.20249241746920754, 0.20690032188396368, 0.34416960397673324, 0.18171262061645, 0.185538090787139, 0.16877490528832606, 0.20030594276709246, 0.1576085046399074, 0.14812125737108073, 0.4385825256208198, 0.15974211591676646, 0.16007421948220268, 0.18293468799220414, 0.17901440984497874, 0.46696878007168063, 0.46607971886379884, 0.14005996875482174, 0.14385177591177722, 0.4192714915108856, 0.16920856276918517, 0.12931705541008176, 0.4707556582468152, 0.1925934546980077, 0.16725466960283863, 0.18108742825659974, 0.1870368800811104, 0.16990068678429615, 0.18161485489670848, 0.2197641556397223, 0.1765483828890272, 0.16770283394056718, 0.19499890763862315, 0.17960162274204816, 0.1768751088804542, 0.05662666702409225, 0.06509878423820714, 0.06520166790820969, 0.06014754764266472, 0.06052801331681712, 0.0750463158024599, 0.06066943877128139, 0.056358931704133974, 0.0685021513494134]}, "mutation_prompt": null}
{"id": "1eea6c87-ff23-4e01-87c3-b0cba6827fac", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.95\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x**2))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.35 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget))))  # Modified dynamic adaptation\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.25, self.dim),  # Modified from 0.2 to 0.25\n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = np.vstack((population[ranked_indices[:self.population_size]], best_solution))  # Add best solution for elitism\n            fitness = np.append(fitness[ranked_indices[:self.population_size]], best_fitness)  # Maintain corresponding fitness\n\n        return best_solution", "name": "HybridDESA", "description": "Improved dynamic population adaptation and refined local search to enhance exploration and convergence.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "97aec39a-06f4-406c-b072-0fe6a66600cb", "metadata": {"aucs": [0.38558279940440066, 0.3609503798038901, 0.3791100187406563, 0.37165266215160475, 0.38999180788037124, 0.3871134905578162, 0.3842147971693174, 0.3827804354706522, 0.37048786575858594, 0.37708018172181734, 0.34428376400991934, 0.35734872155395436, 0.3680661052415707, 0.3758876208516555, 0.38720338661262144, 0.3219505285050154, 0.3295189922233256, 0.3608783087021509, 0.11115610563140976, 0.09908915671666019, 0.11049796396595224, 0.10399744370061448, 0.1305424994142539, 0.11339181349994865, 0.11410905539947258, 0.3272060953007032, 0.10668621877750428, 0.097119647191106, 0.31555653205737355, 0.1066189875512682, 0.1096620489590856, 0.07995079765568514, 0.09997425407650662, 0.08819741632640521, 0.08689528943462987, 0.11181669251809145, 0.9855044408535428, 0.9490778590710266, 0.9554756351964058, 0.8953902141647986, 0.9732644077565413, 0.9053038102148867, 0.8145665313692394, 0.963560974260261, 0.9065833018858803, 0.32136742904932536, 0.2525887188280115, 0.2969909826398506, 0.2953519465609691, 0.2977356962408224, 0.3093143131796341, 0.3353097164828992, 0.28752682111657735, 0.32232703827610676, 0.4923653636460419, 0.4912604313326253, 0.25261030972929244, 0.4834335177549848, 0.46558961298266666, 0.4870099880004952, 0.4666578709685061, 0.473799313393244, 0.4886752127701931, 0.19148957532340216, 0.20627481945919546, 0.2958516352775179, 0.15122491047808528, 0.23620872626032807, 0.26318122337586247, 0.26061438024934247, 0.17096745058966967, 0.24898584449878203, 0.24482549497580008, 0.21074757010603384, 0.10238267377895505, 0.18653876956799165, 0.2786500721233667, 0.21470096893039048, 0.21550725645778612, 0.18719478151872482, 0.17364175670543702, 0.05033484828355772, 0.24029899392974563, 0.05841463667988045, 0.04714755210604782, 0.0737680105947347, 0.14257713286722196, 0.30240915076768105, 0.21548573678118443, 0.010085476949776018, 0.19924228826192825, 0.2718602343066092, 0.19169052073071136, 0.12100729663601528, 0.21856156282212857, 0.2410592921696737, 0.32249219900927384, 0.2696968773636642, 0.27383115304388284, 0.02721298272462258, 0.04236757585505946, 0.026755752323254778, 0.14018984921781208, 0.02953043616537221, 0.14565809746465308, 0.07996565159905256, 0.11166437396084217, 0.08007655168808814, 0.1868004482804253, 0.202424787175995, 0.1691603285143214, 0.18374084442464966, 0.21128505657328245, 0.21617201136005437, 0.17295313359432563, 0.1811343973372871, 0.152667918050154, 0.3397286833695359, 0.29837021107268047, 0.31255343579613526, 0.3170858179924362, 0.33183974651513837, 0.3057191395393466, 0.37314218187823744, 0.3472297650492424, 0.3288386262777845, 0.11859054119150747, 0.06838324830648257, 0.07334772972723491, 0.06529738333371238, 0.09586032090980101, 0.060127435664957374, 0.06711811236362386, 0.0653520706631352, 0.0751152261657384, 0.13157166540084764, 0.15762577769546715, 0.22389013106589628, 0.15971207719954306, 0.17065583660711747, 0.21800359372996325, 0.2176111451718984, 0.3162693249937646, 0.17738190747136107, 0.29599492750971135, 0.2840079399736276, 0.24759501185723787, 0.2999697797106864, 0.26131337731955073, 0.25960658224417943, 0.2547544010265941, 0.3168241330506947, 0.27931639263466856, 0.20986808251689182, 0.26168448011925394, 0.19190425832620872, 0.1842673575833944, 0.263217702915734, 0.16548679536904398, 0.26069123060496, 0.21047322383348988, 0.23121316790053204, 0.15055071830264866, 0.1729592916001631, 0.15026432453230754, 0.1616447851653917, 0.17085387427175613, 0.15199760306213395, 0.17540669454915436, 0.1538046162261868, 0.16874507257072802, 0.17760135785960285, 0.18749434646649288, 0.20249241746920754, 0.20690032188396368, 0.34416960397673324, 0.18171262061645, 0.185538090787139, 0.16877490528832606, 0.20030594276709246, 0.1576085046399074, 0.14812125737108073, 0.4385825256208198, 0.15974211591676646, 0.16007421948220268, 0.18293468799220414, 0.17901440984497874, 0.46696878007168063, 0.46607971886379884, 0.14005996875482174, 0.14385177591177722, 0.4192714915108856, 0.16920856276918517, 0.12931705541008176, 0.4707556582468152, 0.1925934546980077, 0.16725466960283863, 0.18108742825659974, 0.1870368800811104, 0.16990068678429615, 0.18161485489670848, 0.2197641556397223, 0.1765483828890272, 0.16770283394056718, 0.19499890763862315, 0.17960162274204816, 0.1768751088804542, 0.05662666702409225, 0.06509878423820714, 0.06520166790820969, 0.06014754764266472, 0.06052801331681712, 0.0750463158024599, 0.06066943877128139, 0.056358931704133974, 0.0685021513494134]}, "mutation_prompt": null}
{"id": "6941c316-a57f-44a1-ad62-dc4695e4bc7f", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.95\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x**2)) * np.sin(2 * np.pi * x)  # Added sine term for diversity\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.35 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget))))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.3, self.dim),  # Changed perturbation from 0.25 to 0.3\n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = np.vstack((population[ranked_indices[:self.population_size]], best_solution))  # Add best solution for elitism\n            fitness = np.append(fitness[ranked_indices[:self.population_size]], best_fitness)  # Maintain corresponding fitness\n\n        return best_solution", "name": "HybridDESA", "description": "Introduced a diversity-enhanced population initialization and tuned local perturbation for improved global exploration and local exploitation balance.", "configspace": "", "generation": 85, "fitness": 0.2441454363477613, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.18.", "error": "", "parent_id": "97aec39a-06f4-406c-b072-0fe6a66600cb", "metadata": {"aucs": [0.34602475571096636, 0.35750788661649935, 0.38598192221876526, 0.36940897894264424, 0.3890038113017469, 0.3791070993775194, 0.42561638598693075, 0.37712069236784007, 0.38031835036275596, 0.32130165360994, 0.37348573970783083, 0.3485647201735842, 0.3504944847489878, 0.35282255040739297, 0.38224132747644923, 0.33688663888372183, 0.3729844237309504, 0.2922429897940798, 0.12637317489360944, 0.10079825838799628, 0.13329060700995088, 0.11038584675326601, 0.11366788268193762, 0.19155904062350604, 0.1076713277012119, 0.10176609674194403, 0.11041556151855125, 0.07976406058680385, 0.10911937932267268, 0.09917861719454757, 0.10379121318162232, 0.08528916011355392, 0.10972737878113659, 0.12331723406112616, 0.12226482876197065, 0.11185746940914665, 0.9317300900015987, 0.9307060066617863, 0.8755503597331827, 0.9149004876815311, 0.9443423033710069, 0.8847286596610346, 0.9871103530194416, 0.967412078658959, 0.9904552236847092, 0.2683558002356605, 0.2904549857746239, 0.2901051603318803, 0.2932429709884151, 0.3052950678732703, 0.3040424321602576, 0.26468879396736233, 0.30594912357607895, 0.2972983914589177, 0.4472251752484405, 0.2520120868271406, 0.4853953550120629, 0.46876204660213294, 0.4399192571637077, 0.47898431217013127, 0.46282027368292533, 0.4602998736327145, 0.4735866365275633, 0.23045662818538726, 0.1839244133966993, 0.22424701766124244, 0.1922518088272599, 0.1726657388830405, 0.19299361486826117, 0.1624382113475369, 0.1819080700352228, 0.14368783843868438, 0.1191232120788529, 0.11815948823474154, 0.10165294490667676, 0.15465009951461028, 0.2305531139918472, 0.2451638189486448, 0.08934364569441355, 0.23084819722870975, 0.18444952471062648, 0.0261571093569819, 0.1508820690992888, 0.05877508515492569, 0.16049317193802215, 0.2355565592890858, 0.013459703963462522, 0.1374742852673715, 0.06510609336206685, 0.05326315970689832, 0.1225289342048752, 0.2638731014702299, 0.22542143740520038, 0.07131215230220644, 0.25674191038898075, 0.2783703432424418, 0.24655006620935715, 0.2562441166390217, 0.275053027235005, 0.05198175457719245, 0.06269089856473187, 0.03249821853223134, 0.0928682608708783, 0.06584867400188488, 0.06239603256989812, 0.10096606395464336, 0.19405055217704714, 0.12461112428542165, 0.16629694776303972, 0.1890625017590123, 0.17986089681288198, 0.1974295343210779, 0.1868807081552437, 0.21259852904718368, 0.15988843767912786, 0.21467811088384448, 0.17166013721798512, 0.3320068995722055, 0.31219470045872444, 0.342356760904569, 0.32144817289726724, 0.348776468017033, 0.33712696022849065, 0.3035239942735798, 0.327053889777255, 0.3491515468488867, 0.07402216773178005, 0.07939527188265927, 0.07584194828760882, 0.059611703345674116, 0.07453131264584312, 0.33520472618421027, 0.07140930675409451, 0.0796251214554945, 0.060397599916036215, 0.15536570490076773, 0.13512229169748935, 0.20942271697084913, 0.14414902417883846, 0.17457187156515497, 0.3518249014470748, 0.19131407680245027, 0.14083310348498357, 0.21747278741219156, 0.29274214302995316, 0.2848187018974512, 0.27108849190928974, 0.24001055219544665, 0.24866630336098394, 0.3107451611123234, 0.2690227421847692, 0.2683427384236877, 0.2746663265159014, 0.23202313888879555, 0.13744635357344281, 0.22518341891475635, 0.19991557622974898, 0.16034696738298204, 0.15522766487917183, 0.19870606125118784, 0.24064551937349443, 0.19753676635833783, 0.14011629975138185, 0.15713688294000372, 0.143378186325834, 0.19124880579222348, 0.1597401305220788, 0.14675582522765984, 0.16856851769650782, 0.15991164123932144, 0.14773871753359036, 0.19055082395201373, 0.17454126855056784, 0.17209598276590277, 0.2033707047881187, 0.194166613096168, 0.20569190487784483, 0.18091802086138142, 0.29820676161737103, 0.18910877717182029, 0.45290660038358366, 0.1579625561166833, 0.14298943180431034, 0.18455283925236476, 0.4132449083627642, 0.1590222956559172, 0.510548522249638, 0.17746165173802908, 0.16839854763307305, 0.42036278110431435, 0.13793616018064536, 0.43365226395775847, 0.35534302007221263, 0.4405881058189025, 0.42375865727202333, 0.41100036884721025, 0.17563688043037595, 0.1811473189074576, 0.1889057361181935, 0.17024368453186856, 0.2085088372699977, 0.20450520063275945, 0.18356921705155782, 0.19329257153285717, 0.18510569554437606, 0.17952604745561762, 0.2034950899784842, 0.06018545208735626, 0.06186745131997684, 0.058341448352999814, 0.059243022444993576, 0.05577773782287532, 0.04775487402897438, 0.06091734351268019, 0.05529690620236738, 0.05945755239761896]}, "mutation_prompt": null}
{"id": "2d93c005-62a5-436d-90fc-e800d8f365c2", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.95\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x**2))\n\n    def _levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(size, self.dim) * sigma\n        v = np.random.randn(size, self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.35 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget))))  # Modified dynamic adaptation\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            if np.random.rand() < 0.1:  # Levy flight with a probability of 0.1\n                levy_step = self._levy_flight(1)[0]\n                candidate = np.clip(best_solution + levy_step, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                evaluations += 1\n                if candidate_fitness < best_fitness:\n                    best_solution = candidate\n                    best_fitness = candidate_fitness\n\n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.25, self.dim),  # Modified from 0.2 to 0.25\n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = np.vstack((population[ranked_indices[:self.population_size]], best_solution))  # Add best solution for elitism\n            fitness = np.append(fitness[ranked_indices[:self.population_size]], best_fitness)  # Maintain corresponding fitness\n\n        return best_solution", "name": "HybridDESA", "description": "Introduced guided global exploration using Levy flights to enhance diversity and escape local optima.", "configspace": "", "generation": 86, "fitness": 0.23555004440738753, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.18.", "error": "", "parent_id": "97aec39a-06f4-406c-b072-0fe6a66600cb", "metadata": {"aucs": [0.35794001814108156, 0.3602480587062872, 0.3710072649666396, 0.3782754983706126, 0.376243655405036, 0.37649013849945046, 0.3586751554681431, 0.3780298754657748, 0.38752360612995707, 0.3599401604628836, 0.3378551716605519, 0.3395991643391434, 0.3548874302394761, 0.40047952195194625, 0.38052998213225586, 0.3423706888582866, 0.34956798809834266, 0.38081065179248486, 0.09279689977730354, 0.10322469215895558, 0.10287115811706482, 0.1024490895357969, 0.1109000573825748, 0.10002337422599306, 0.10630540385257059, 0.10552670289237631, 0.08109446829155587, 0.09275536908099569, 0.10902938636357973, 0.1053462745127679, 0.12180738262342061, 0.12468792108388482, 0.10034555784669807, 0.08912715678391525, 0.12898833003343801, 0.10243797041772873, 0.8029149088765537, 0.9082502182605521, 0.9080936630909776, 0.8667370404030639, 0.9764232716639555, 0.9207252303910862, 0.8899371445940848, 0.8994325796011999, 0.9096232572844065, 0.29644244250980223, 0.30980921503843295, 0.31007639792859354, 0.2621879937783549, 0.28804644767797616, 0.2707591164848472, 0.2795497102411384, 0.29599198025904183, 0.23034603798846298, 0.49345689096442846, 0.4542984966481195, 0.45938683145263326, 0.49114644765402005, 0.48405577359020346, 0.4995700447257857, 0.18431624643454603, 0.4723648239330692, 0.45527268069516946, 0.23479524570836607, 0.18368214786634407, 0.29414089220779915, 0.14577169234557807, 0.21667226546392904, 0.19102621292663136, 0.22255293123112607, 0.19576769231713242, 0.32543787077513053, 0.1007744686228702, 0.13586126880653915, 0.23459584577110149, 0.20789621580928885, 0.21366700226321822, 0.19746188900293216, 0.0941750089731449, 0.1784987438775566, 0.15105008614892668, 0.24405289325046797, 0.09137295194932393, 0.05961455777547331, 9.999999999998899e-05, 9.999999999998899e-05, 0.03342843585502364, 0.1504134466075977, 0.11858140784116589, 0.0372286559963686, 0.14859620825050934, 0.2114861532902116, 0.26450278565143626, 0.23778909476309906, 0.22279641278530216, 0.23876303445258773, 0.20212973311542326, 0.29674130799015297, 0.24177877465956554, 0.041131133966542666, 0.04220525295528421, 0.05768554218301303, 0.11680353855685621, 0.12145749988730858, 0.08963148017445932, 0.07865765581523632, 0.053007164301044574, 0.08281861317713224, 0.20214514460831057, 0.19708552365016685, 0.20617274296103827, 0.2211299733866987, 0.204134999817978, 0.1768393226677526, 0.23090716456381055, 0.2615259201677098, 0.18048660082041879, 0.3472364551979693, 0.3245727152271263, 0.3356402367384491, 0.33082517025393254, 0.32599735427442167, 0.3190351604071062, 0.3060697708439861, 0.3120555089950895, 0.3530647639946467, 0.0911535717221521, 0.09494022267892666, 0.07775970259859111, 0.1052533617829795, 0.07053335064817823, 0.07350388098328409, 0.08342991136549482, 0.07279623669848079, 0.05253579268981534, 0.1449486679498112, 0.1826363177548994, 0.20211358356961528, 0.1915508225462248, 0.16631653490068765, 0.1782600126116426, 0.17755887405722937, 0.18568796404815635, 0.21120457365407797, 0.3118838265285465, 0.2555701562076088, 0.29022097352032206, 0.28619716908850434, 0.22911819023278868, 0.23747047050426917, 0.2751021474737091, 0.2610042377708278, 0.2920769407396089, 0.16974385686086169, 0.2207567333594962, 0.20129603398726437, 0.16261820257198523, 0.1879315758593917, 0.24006580541207345, 0.20856357610654408, 0.1826334537414105, 0.16399394438989423, 0.1794107717928417, 0.16968463230217024, 0.14024626258086137, 0.1762544546158028, 0.16238777579733266, 0.16613564445436801, 0.1672190398677259, 0.18141374789835507, 0.16957169414817075, 0.18213029247951062, 0.37665762036331407, 0.20266320537526405, 0.19295380009797114, 0.18805565878490604, 0.1924464924824446, 0.18242134800013143, 0.1939190474295689, 0.17992684779841273, 0.1689652647116605, 0.15558372235951445, 0.14527851600901542, 0.15885260859344508, 0.158826019202858, 0.16704381585216166, 0.1615891530650686, 0.1640465080684047, 0.16089970660561304, 0.39849560207421053, 0.4567366895687245, 0.17206251782608706, 0.45370065477120314, 0.18402807679543243, 0.11123543073673248, 0.18845363274493476, 0.18811977908111022, 0.18415269601681306, 0.17223928296935942, 0.17808297889674163, 0.19208920402919694, 0.19254998758713315, 0.19410466388236758, 0.18642649438856018, 0.18913949141157604, 0.2036442858929709, 0.1843128448423046, 0.04999892749864632, 0.06011911140079751, 0.07110485167880665, 0.055723342873942094, 0.05573704065530416, 0.06332287145876958, 0.05128036553587101, 0.07128718831619552, 0.05661538992537696]}, "mutation_prompt": null}
{"id": "d964b711-6f09-423f-a0eb-75a9ff820876", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.95\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x**2))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.35 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget))))  # Modified dynamic adaptation\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.25, self.dim),  # Modified from 0.2 to 0.25\n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = np.vstack((population[ranked_indices[:self.population_size]], best_solution))  # Add best solution for elitism\n            fitness = np.append(fitness[ranked_indices[:self.population_size]], best_fitness)  # Maintain corresponding fitness\n\n        return best_solution", "name": "HybridDESA", "description": "Improved dynamic population adaptation and refined local search to enhance exploration and convergence.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "97aec39a-06f4-406c-b072-0fe6a66600cb", "metadata": {"aucs": [0.38558279940440066, 0.3609503798038901, 0.3791100187406563, 0.37165266215160475, 0.38999180788037124, 0.3871134905578162, 0.3842147971693174, 0.3827804354706522, 0.37048786575858594, 0.37708018172181734, 0.34428376400991934, 0.35734872155395436, 0.3680661052415707, 0.3758876208516555, 0.38720338661262144, 0.3219505285050154, 0.3295189922233256, 0.3608783087021509, 0.11115610563140976, 0.09908915671666019, 0.11049796396595224, 0.10399744370061448, 0.1305424994142539, 0.11339181349994865, 0.11410905539947258, 0.3272060953007032, 0.10668621877750428, 0.097119647191106, 0.31555653205737355, 0.1066189875512682, 0.1096620489590856, 0.07995079765568514, 0.09997425407650662, 0.08819741632640521, 0.08689528943462987, 0.11181669251809145, 0.9855044408535428, 0.9490778590710266, 0.9554756351964058, 0.8953902141647986, 0.9732644077565413, 0.9053038102148867, 0.8145665313692394, 0.963560974260261, 0.9065833018858803, 0.32136742904932536, 0.2525887188280115, 0.2969909826398506, 0.2953519465609691, 0.2977356962408224, 0.3093143131796341, 0.3353097164828992, 0.28752682111657735, 0.32232703827610676, 0.4923653636460419, 0.4912604313326253, 0.25261030972929244, 0.4834335177549848, 0.46558961298266666, 0.4870099880004952, 0.4666578709685061, 0.473799313393244, 0.4886752127701931, 0.19148957532340216, 0.20627481945919546, 0.2958516352775179, 0.15122491047808528, 0.23620872626032807, 0.26318122337586247, 0.26061438024934247, 0.17096745058966967, 0.24898584449878203, 0.24482549497580008, 0.21074757010603384, 0.10238267377895505, 0.18653876956799165, 0.2786500721233667, 0.21470096893039048, 0.21550725645778612, 0.18719478151872482, 0.17364175670543702, 0.05033484828355772, 0.24029899392974563, 0.05841463667988045, 0.04714755210604782, 0.0737680105947347, 0.14257713286722196, 0.30240915076768105, 0.21548573678118443, 0.010085476949776018, 0.19924228826192825, 0.2718602343066092, 0.19169052073071136, 0.12100729663601528, 0.21856156282212857, 0.2410592921696737, 0.32249219900927384, 0.2696968773636642, 0.27383115304388284, 0.02721298272462258, 0.04236757585505946, 0.026755752323254778, 0.14018984921781208, 0.02953043616537221, 0.14565809746465308, 0.07996565159905256, 0.11166437396084217, 0.08007655168808814, 0.1868004482804253, 0.202424787175995, 0.1691603285143214, 0.18374084442464966, 0.21128505657328245, 0.21617201136005437, 0.17295313359432563, 0.1811343973372871, 0.152667918050154, 0.3397286833695359, 0.29837021107268047, 0.31255343579613526, 0.3170858179924362, 0.33183974651513837, 0.3057191395393466, 0.37314218187823744, 0.3472297650492424, 0.3288386262777845, 0.11859054119150747, 0.06838324830648257, 0.07334772972723491, 0.06529738333371238, 0.09586032090980101, 0.060127435664957374, 0.06711811236362386, 0.0653520706631352, 0.0751152261657384, 0.13157166540084764, 0.15762577769546715, 0.22389013106589628, 0.15971207719954306, 0.17065583660711747, 0.21800359372996325, 0.2176111451718984, 0.3162693249937646, 0.17738190747136107, 0.29599492750971135, 0.2840079399736276, 0.24759501185723787, 0.2999697797106864, 0.26131337731955073, 0.25960658224417943, 0.2547544010265941, 0.3168241330506947, 0.27931639263466856, 0.20986808251689182, 0.26168448011925394, 0.19190425832620872, 0.1842673575833944, 0.263217702915734, 0.16548679536904398, 0.26069123060496, 0.21047322383348988, 0.23121316790053204, 0.15055071830264866, 0.1729592916001631, 0.15026432453230754, 0.1616447851653917, 0.17085387427175613, 0.15199760306213395, 0.17540669454915436, 0.1538046162261868, 0.16874507257072802, 0.17760135785960285, 0.18749434646649288, 0.20249241746920754, 0.20690032188396368, 0.34416960397673324, 0.18171262061645, 0.185538090787139, 0.16877490528832606, 0.20030594276709246, 0.1576085046399074, 0.14812125737108073, 0.4385825256208198, 0.15974211591676646, 0.16007421948220268, 0.18293468799220414, 0.17901440984497874, 0.46696878007168063, 0.46607971886379884, 0.14005996875482174, 0.14385177591177722, 0.4192714915108856, 0.16920856276918517, 0.12931705541008176, 0.4707556582468152, 0.1925934546980077, 0.16725466960283863, 0.18108742825659974, 0.1870368800811104, 0.16990068678429615, 0.18161485489670848, 0.2197641556397223, 0.1765483828890272, 0.16770283394056718, 0.19499890763862315, 0.17960162274204816, 0.1768751088804542, 0.05662666702409225, 0.06509878423820714, 0.06520166790820969, 0.06014754764266472, 0.06052801331681712, 0.0750463158024599, 0.06066943877128139, 0.056358931704133974, 0.0685021513494134]}, "mutation_prompt": null}
{"id": "6d225fd5-ffa1-4f5f-a0c6-28716ec7e1cd", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1200.0  # Adjusted initial temperature\n        self.cooling_rate = 0.92  # Adjusted cooling rate\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x**2))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.35 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget))))  # Modified dynamic adaptation\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.3, self.dim),  # Intensified local search modification\n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = np.vstack((population[ranked_indices[:self.population_size]], best_solution))  # Add best solution for elitism\n            fitness = np.append(fitness[ranked_indices[:self.population_size]], best_fitness)  # Maintain corresponding fitness\n\n        return best_solution", "name": "HybridDESA", "description": "Enhanced HybridDESA with strategic focus on local search intensification and adaptive exploration.", "configspace": "", "generation": 88, "fitness": 0.2723459950385418, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.20.", "error": "", "parent_id": "97aec39a-06f4-406c-b072-0fe6a66600cb", "metadata": {"aucs": [0.5157494887235639, 0.5153002745266304, 0.4982368444097516, 0.5235129035480534, 0.5136746180417748, 0.524035452560347, 0.522796185619437, 0.5239348596268683, 0.5270697503105206, 0.45617094850330697, 0.49359871538651845, 0.4941535264036051, 0.4908588771401756, 0.49576697557301663, 0.4952828882432928, 0.49508358948671916, 0.496192793846424, 0.49126698440249406, 0.10329934126423301, 0.11771152153922015, 0.135599107332393, 0.12122227876772285, 0.16941408052993834, 0.11630685922571826, 0.12230495236405259, 0.09274439396960987, 0.12490431707570349, 0.09066041149776904, 0.1274423981719086, 0.13800632629687992, 0.12406578832262238, 0.47367824737153497, 0.1051444497146169, 0.11470498122364514, 0.09247553529802299, 0.12111823042357861, 0.9855044408535428, 0.8841268048877505, 0.9326925369354726, 0.9346199444134956, 0.8682193750928945, 0.958633405069286, 0.9428304944988267, 0.8933385580466958, 0.9157076554219764, 0.3964478682903264, 0.3807836739780839, 0.38889866821029917, 0.42984883747535685, 0.3309178750444839, 0.3401478200270983, 0.42989814054204034, 0.4266569495273823, 0.358618008913953, 0.557250339088329, 0.5623494196315266, 0.5615322182009495, 0.5507682750506171, 0.572579149442827, 0.5864671839096263, 0.1966243043679926, 0.5675497227280828, 0.5865552739694011, 0.17578616030875038, 0.2034049953397311, 0.24686521569721998, 0.24450246309178403, 0.27369379646338543, 0.11252720809244421, 0.19922750652701504, 0.23821644041174328, 0.21021516039782595, 0.10209896733185875, 0.19912847854081106, 0.10693025788166066, 0.18077684763243274, 0.15696197030033088, 0.17646836109988673, 0.2541252717177501, 0.2880882900060562, 0.2639948856531378, 0.13939372383385484, 0.018969863889256144, 0.026337775815741815, 0.1365052555989349, 0.18872143309299516, 0.05001068739714187, 0.17991379377309624, 0.07008482000002969, 0.1479361180617934, 0.16550231105818825, 0.09459543092785427, 0.1814478398639775, 0.10539156359396873, 0.3541851052194216, 0.23501351338720777, 0.31801235541879036, 0.12813759447695505, 0.3716469743774339, 0.11104027603469346, 0.16611403053234552, 0.05430776142762883, 9.999999999998899e-05, 0.08700343686001766, 0.060763509184622144, 0.1320193652889402, 0.07497004092457193, 0.08603622837883018, 0.26152188493658257, 0.17307620434394688, 0.2667907752346925, 0.2694430248623043, 0.23527388619782375, 0.2552011576858856, 0.15582181752931978, 0.1504890168527061, 0.2098946741648724, 0.43678867884009953, 0.4163385913569013, 0.4048974483896106, 0.3748472858601358, 0.4416290442174381, 0.41280588346103664, 0.4159688666109749, 0.3908976250934695, 0.39063451069561606, 0.07900695134437918, 0.08244541152833351, 0.14478576817914413, 0.06090798923924723, 0.08003680613151132, 0.09812051923512877, 0.0941944251754272, 0.11008394644421948, 0.13705048609152437, 0.17295910563399142, 0.1652788930968767, 0.15409969173594984, 0.1791390818863252, 0.2377777426420623, 0.23018653033073844, 0.1955988732517372, 0.18647174251189724, 0.15498049599106056, 0.217800133846609, 0.3234766724023347, 0.24196530501983038, 0.29719833112361516, 0.2427146743313029, 0.3016773612694926, 0.3164865261963645, 0.30421867882706743, 0.308493890516748, 0.26659710566559003, 0.23061661936236344, 0.24405573083969234, 0.16112154729818862, 0.17384434963464623, 0.1673703449825532, 0.23906782944102223, 0.224558380499554, 0.234125991638108, 0.14607952328707052, 0.160722688453232, 0.16352266830795614, 0.15103962227233236, 0.16107352401930586, 0.16833331262717988, 0.1619603494111499, 0.16497383066545823, 0.15449120071285216, 0.2128851634805825, 0.20282225121286146, 0.19332085681652966, 0.508537816101725, 0.18813840177088315, 0.21549304938220815, 0.2131262722424604, 0.1856006440443656, 0.5037840545161478, 0.591731551241863, 0.1519370838273857, 0.15819579306867304, 0.1655998398786538, 0.5490101805523993, 0.1925992000217076, 0.16550155628176177, 0.5552615353856454, 0.16368057841518402, 0.14704411675139162, 0.15030124336005246, 0.1499659729245323, 0.17355951040784634, 0.1470987451260577, 0.5198792249713269, 0.18705701499971472, 0.1911926033218344, 0.18809603785143658, 0.2004169855001563, 0.1893080699717603, 0.18365773873612867, 0.18950413976333136, 0.1825096407851624, 0.19082876535298032, 0.19051958204159458, 0.2022459202789405, 0.18435756093444355, 0.06441591557098036, 0.050818558001691994, 0.06580322647712566, 0.07278198064461772, 0.06835428458354509, 0.06757280671302901, 0.06008503685676514, 0.05680885327546348, 0.06206561017537737]}, "mutation_prompt": null}
{"id": "e84a894d-04b1-4853-ad99-978712326946", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1200.0  # Adjusted initial temperature\n        self.cooling_rate = 0.92  # Adjusted cooling rate\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x**2))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.35 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (0.4 + 0.6 * np.cos(np.pi * evaluations / self.budget))))  # Enhanced dynamic adaptation\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.5, self.dim),  # Enhanced local search modification\n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = np.vstack((population[ranked_indices[:self.population_size]], best_solution))  # Add best solution for elitism\n            fitness = np.append(fitness[ranked_indices[:self.population_size]], best_fitness)  # Maintain corresponding fitness\n\n        return best_solution", "name": "HybridDESA", "description": "Enhanced HybridDESA with improved adaptive population resizing and chaotic local search exploitation.", "configspace": "", "generation": 89, "fitness": 0.2729088820550294, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "6d225fd5-ffa1-4f5f-a0c6-28716ec7e1cd", "metadata": {"aucs": [0.5396092196869418, 0.5077085388044724, 0.5172405296833367, 0.540148060836587, 0.5473880672435043, 0.5557213104158443, 0.5439013597905231, 0.547312548098804, 0.5441956268378774, 0.4905888666928915, 0.46762776127487427, 0.5240969095766554, 0.5187042670343935, 0.5043328340550304, 0.4560981763450159, 0.5145741165592255, 0.524141191107373, 0.5211297620507342, 0.14378776347473288, 0.14112127135262198, 0.11265708109485417, 0.09384480384159255, 0.09651884040013647, 0.14440210745135407, 0.1253037290688246, 0.12277901621533005, 0.12544806626023963, 0.138908484483227, 0.09255196180731218, 0.11760626925745532, 0.11071761847631356, 0.12143597730615108, 0.11230889143032441, 0.12618467897021124, 0.10328445472510372, 0.10686794269244948, 0.9855044408535428, 0.9187113217488253, 0.9266842668899798, 0.9223184915121061, 0.9216872770258423, 0.9476506338654214, 0.9325964503388863, 0.8489117649341402, 0.9717612573983417, 0.36322302179682553, 0.3765275820043831, 0.4218004597307746, 0.3916645395455386, 0.4057751351416451, 0.38518165467626986, 0.4057169896114855, 0.37935469936506483, 0.4151863615491116, 0.5820643721881709, 0.5690715716572091, 0.29171054825433473, 0.5925042814622185, 0.28257370020304207, 0.5778450879550681, 0.636330845297465, 0.5944573479984574, 0.6075416258970483, 0.1632811806624912, 0.11347849693754886, 0.2630939429185615, 0.2102351133992555, 0.17196206706890427, 0.27906576299536134, 0.19166029327769984, 0.1909211238248354, 0.24480630701530348, 0.050417397935929364, 0.12933528690658225, 0.13506794308263181, 0.2201332200925833, 0.2437401700796339, 0.195208629512987, 0.09498899797777316, 0.23052907496915398, 0.44119959926682273, 0.05122477595862329, 0.08094261090375987, 0.1320354306436553, 0.0050207618948965305, 0.0005814699679409507, 0.06522996688068561, 0.1729306124738671, 0.06233225161645317, 0.1290548326988752, 0.11817038837890614, 0.24522176057535472, 0.12331713671728106, 0.3608610020576547, 0.1472481379870011, 0.11940191263753863, 0.374028401616083, 0.20486393620478116, 0.35575397058737435, 0.028712085828330403, 0.0298449469428842, 0.029485468846230267, 0.08729491475363027, 0.11676549026517691, 0.1311735049792293, 0.1867206095195998, 0.0868047491611511, 0.13853132095552356, 0.2679272579651166, 0.16309035136008276, 0.23449233307363482, 0.19147118278434372, 0.2613498752196898, 0.22572659252427485, 0.2103476989289328, 0.26882542020709854, 0.10667394318416612, 0.40689444596215185, 0.40291501769430316, 0.38563364469843264, 0.4024161752953036, 0.41417961324000974, 0.39749395482567373, 0.39154969866753886, 0.42928120638136735, 0.41964168878410457, 0.11806678874008225, 0.0756933055728699, 0.0587465008860345, 0.07212552434615482, 0.06481295808965437, 0.11051493561329206, 0.07339825244085496, 0.06206998851915346, 0.07319855715411772, 0.1451774003104911, 0.15331501318206397, 0.17802978161131466, 0.15608004274486464, 0.14796035146937025, 0.13226868845640616, 0.17720751480850572, 0.13187131447472056, 0.13601847517527854, 0.3047987824910592, 0.22088866258308704, 0.32476640157489456, 0.28104855913766413, 0.32612635462641104, 0.25432839216089387, 0.3496401584370531, 0.3205936205281651, 0.24799817879243458, 0.2049044175449346, 0.2050406885952042, 0.19339595528285414, 0.23014267289000723, 0.1591455203936355, 0.17392836692168145, 0.30115092105501995, 0.24771614897992256, 0.2505107578850698, 0.16810014560305575, 0.1856725083675328, 0.17527192379479273, 0.16175044539165884, 0.16657358148037293, 0.14734273924494123, 0.1742166734559858, 0.152908668773309, 0.18684345007287406, 0.22654612260702467, 0.1924535659973019, 0.20592139985138724, 0.2189481584682912, 0.18662936683958098, 0.19381843944332589, 0.18699353413887998, 0.5413186978626977, 0.1796777889253004, 0.15801772200873165, 0.19170821710855357, 0.5759800765975858, 0.16376423444023203, 0.5573179701922764, 0.1726549834837593, 0.15079576322443355, 0.15487500205542493, 0.5853343264323381, 0.1516597131264893, 0.5537231104510113, 0.422404051394737, 0.3728332272804241, 0.13356910718768633, 0.5657539020167981, 0.19262406803765975, 0.19086877080587206, 0.18482420377761422, 0.18032875447261743, 0.17721668211656072, 0.20723180638489458, 0.17084502257251188, 0.1951814417039991, 0.19980754776874943, 0.20960076210591794, 0.20039741323267568, 0.18602509204204187, 0.05750849385164325, 0.055965362101724314, 0.06114928867892233, 0.062193936825302054, 0.0649436742097188, 0.05355304262872429, 0.06194916570401021, 0.06904637505292288, 0.05580805594196281]}, "mutation_prompt": null}
{"id": "b9a48513-c6e9-4829-abf9-ac9a0a4c0c5c", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1200.0\n        self.cooling_rate = 0.92\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x**2))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        if np.random.rand() < 0.5:  # Multi-strategy mutation\n            mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                             self.lower_bound, self.upper_bound)\n        else:\n            mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[idx]), \n                             self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.35 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (0.4 + 0.6 * np.cos(np.pi * evaluations / self.budget))))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.5, self.dim),\n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = np.vstack((population[ranked_indices[:self.population_size]], best_solution))\n            fitness = np.append(fitness[ranked_indices[:self.population_size]], best_fitness)\n\n        return best_solution", "name": "HybridDESA", "description": "Improved HybridDESA by adding a multi-strategy mutation and enhancing exploration via adaptive chaos-based sampling.", "configspace": "", "generation": 90, "fitness": 0.2682671800007886, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.20.", "error": "", "parent_id": "e84a894d-04b1-4853-ad99-978712326946", "metadata": {"aucs": [0.45366721257680187, 0.537789744429841, 0.5153719434446584, 0.5083616072059087, 0.49333977125248496, 0.5014172009637932, 0.5504009796762142, 0.5480012434274513, 0.545724933261002, 0.46126677081356715, 0.517246594963527, 0.4453523543059962, 0.4860445629182405, 0.5030980316621912, 0.47656384530760765, 0.47230389818772534, 0.5165423240256177, 0.5250371501724039, 0.13592210677736405, 0.11768759106770654, 0.1284486181949831, 0.1375945086388285, 0.0888544596596943, 0.12821230527297467, 0.11386665936462836, 0.12835908280116437, 0.14205303113605294, 0.1342764287273711, 0.1112216361864723, 0.11662450809338665, 0.11196045246801789, 0.14121596197609088, 0.11758266922877558, 0.12045009713621624, 0.07704750252409687, 0.11205482593272809, 0.9377220747755733, 0.8709123394184285, 0.8848739072028999, 0.9612103762308595, 0.8798818545631525, 0.9455527500606448, 0.8887070873208034, 0.8617489630451034, 0.9790767542098179, 0.362894939664429, 0.30825704663744136, 0.3548432169041653, 0.3686384837994777, 0.42680041845154804, 0.3773892281999528, 0.29744425501227956, 0.33973064192480407, 0.32223684261695185, 0.580800586523375, 0.57508704674254, 0.5975441503563816, 0.5734271149865556, 0.21270577438781968, 0.5768008067678452, 0.5692389769331858, 0.6177110102252057, 0.5733899222794481, 0.17959098625298753, 0.18066359602191095, 0.2033881393895114, 0.28087345710945444, 0.44036889307199767, 0.19313659618269508, 0.1121760402998987, 0.1890284355235864, 0.2419740648722699, 0.035242745119450025, 0.07426416303227346, 0.12658798015931438, 0.2700806663202193, 0.2182452328027934, 0.44199594798777064, 0.26284186816225996, 0.2055102465832327, 0.18371149238689477, 0.06371546275909656, 9.999999999998899e-05, 9.999999999998899e-05, 0.205865385042742, 9.999999999998899e-05, 9.999999999998899e-05, 0.15882329885756385, 0.07932133548968268, 0.03379233978797347, 0.3375702979128733, 0.16259921785792597, 0.2519712232046528, 0.23997168037205852, 0.07989748567119137, 0.16231226391179365, 0.3102834762329846, 0.21056461744498178, 0.3393501696414676, 0.16140328324192976, 0.06536139505386729, 0.042396515030414195, 0.170950646228209, 0.07663596548105178, 0.16415782278928748, 0.12864852317694153, 0.12391844080563752, 0.23275118754935697, 0.3156437864861049, 0.12377184867717694, 0.14331802786694936, 0.20507653893243294, 0.21954859108512315, 0.23583682257136784, 0.33422879076695267, 0.20458774223291154, 0.19404806986107137, 0.4243426494970265, 0.46662096081352566, 0.4040439758583644, 0.41996038460736596, 0.3772426841960932, 0.4652673035081093, 0.40200900203974044, 0.39338874278592384, 0.4197404242301245, 0.09305835604766055, 0.08307313721495813, 0.09189787558797613, 0.10252408669088198, 0.06372443170834508, 0.0707720135765989, 0.06318594857256488, 0.07884977444713093, 0.06544115096795233, 0.16565916963176786, 0.14370650699245557, 0.2450048864767448, 0.1615094465213266, 0.20533702489173522, 0.16726236117718873, 0.13542863766548796, 0.15051431737311738, 0.13857843239716727, 0.3450289722081731, 0.2733216645766422, 0.33347809974102616, 0.317948932608088, 0.34401070856594296, 0.2922908579928212, 0.26674170518321216, 0.3641549067750086, 0.2778083534176976, 0.1992075535659107, 0.1871052688568674, 0.21600855130779972, 0.17871589545594146, 0.22062789066466315, 0.20553487006079763, 0.18426676877237014, 0.26370683388078675, 0.27173918289614707, 0.17787208041637148, 0.1866888141600499, 0.1815923969169687, 0.18168119009868744, 0.15548626420985368, 0.1655941915129273, 0.146908219739175, 0.18318723769778433, 0.16917582045434387, 0.17999843156779516, 0.16961047384518502, 0.520079145370278, 0.2123685410752959, 0.17431117234078863, 0.21504649499569373, 0.21140380765636835, 0.214640237180991, 0.18573603870540079, 0.5830458654941222, 0.15720281498445676, 0.14989556786576486, 0.16126470578684726, 0.17305247464302342, 0.17178456961538668, 0.14564248499617805, 0.5556007316582494, 0.590938542307636, 0.17594090640691862, 0.17389443450968955, 0.17434643749051593, 0.1722811065640033, 0.14458603488723598, 0.1757551035745053, 0.18724929359601972, 0.19075320519400907, 0.19097888236225857, 0.19081521378376576, 0.17397464227038595, 0.19216089928230062, 0.18605582483921157, 0.18212903956712434, 0.2001426960781687, 0.19059077218250875, 0.17741022240142557, 0.16374845845365693, 0.057085804593357325, 0.06233330310912466, 0.07786277986883283, 0.05345300440376721, 0.061636995578101095, 0.060989487094132655, 0.0539228659101304, 0.07724918530390801, 0.05472327723784898]}, "mutation_prompt": null}
{"id": "41bcfcc5-835d-4eb6-be6b-46c60133fc36", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1200.0  # Adjusted initial temperature\n        self.cooling_rate = 0.92  # Adjusted cooling rate\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x**2))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.35 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (0.4 + 0.6 * np.cos(np.pi * evaluations / self.budget))))  # Enhanced dynamic adaptation\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.5, self.dim),  # Enhanced local search modification\n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = np.vstack((population[ranked_indices[:self.population_size]], best_solution))  # Add best solution for elitism\n            fitness = np.append(fitness[ranked_indices[:self.population_size]], best_fitness)  # Maintain corresponding fitness\n\n        return best_solution", "name": "HybridDESA", "description": "Enhanced HybridDESA with improved adaptive population resizing and chaotic local search exploitation.", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e84a894d-04b1-4853-ad99-978712326946", "metadata": {"aucs": [0.5396092196869418, 0.5077085388044724, 0.5172405296833367, 0.540148060836587, 0.5473880672435043, 0.5557213104158443, 0.5439013597905231, 0.547312548098804, 0.5441956268378774, 0.4905888666928915, 0.46762776127487427, 0.5240969095766554, 0.5187042670343935, 0.5043328340550304, 0.4560981763450159, 0.5145741165592255, 0.524141191107373, 0.5211297620507342, 0.14378776347473288, 0.14112127135262198, 0.11265708109485417, 0.09384480384159255, 0.09651884040013647, 0.14440210745135407, 0.1253037290688246, 0.12277901621533005, 0.12544806626023963, 0.138908484483227, 0.09255196180731218, 0.11760626925745532, 0.11071761847631356, 0.12143597730615108, 0.11230889143032441, 0.12618467897021124, 0.10328445472510372, 0.10686794269244948, 0.9855044408535428, 0.9187113217488253, 0.9266842668899798, 0.9223184915121061, 0.9216872770258423, 0.9476506338654214, 0.9325964503388863, 0.8489117649341402, 0.9717612573983417, 0.36322302179682553, 0.3765275820043831, 0.4218004597307746, 0.3916645395455386, 0.4057751351416451, 0.38518165467626986, 0.4057169896114855, 0.37935469936506483, 0.4151863615491116, 0.5820643721881709, 0.5690715716572091, 0.29171054825433473, 0.5925042814622185, 0.28257370020304207, 0.5778450879550681, 0.636330845297465, 0.5944573479984574, 0.6075416258970483, 0.1632811806624912, 0.11347849693754886, 0.2630939429185615, 0.2102351133992555, 0.17196206706890427, 0.27906576299536134, 0.19166029327769984, 0.1909211238248354, 0.24480630701530348, 0.050417397935929364, 0.12933528690658225, 0.13506794308263181, 0.2201332200925833, 0.2437401700796339, 0.195208629512987, 0.09498899797777316, 0.23052907496915398, 0.44119959926682273, 0.05122477595862329, 0.08094261090375987, 0.1320354306436553, 0.0050207618948965305, 0.0005814699679409507, 0.06522996688068561, 0.1729306124738671, 0.06233225161645317, 0.1290548326988752, 0.11817038837890614, 0.24522176057535472, 0.12331713671728106, 0.3608610020576547, 0.1472481379870011, 0.11940191263753863, 0.374028401616083, 0.20486393620478116, 0.35575397058737435, 0.028712085828330403, 0.0298449469428842, 0.029485468846230267, 0.08729491475363027, 0.11676549026517691, 0.1311735049792293, 0.1867206095195998, 0.0868047491611511, 0.13853132095552356, 0.2679272579651166, 0.16309035136008276, 0.23449233307363482, 0.19147118278434372, 0.2613498752196898, 0.22572659252427485, 0.2103476989289328, 0.26882542020709854, 0.10667394318416612, 0.40689444596215185, 0.40291501769430316, 0.38563364469843264, 0.4024161752953036, 0.41417961324000974, 0.39749395482567373, 0.39154969866753886, 0.42928120638136735, 0.41964168878410457, 0.11806678874008225, 0.0756933055728699, 0.0587465008860345, 0.07212552434615482, 0.06481295808965437, 0.11051493561329206, 0.07339825244085496, 0.06206998851915346, 0.07319855715411772, 0.1451774003104911, 0.15331501318206397, 0.17802978161131466, 0.15608004274486464, 0.14796035146937025, 0.13226868845640616, 0.17720751480850572, 0.13187131447472056, 0.13601847517527854, 0.3047987824910592, 0.22088866258308704, 0.32476640157489456, 0.28104855913766413, 0.32612635462641104, 0.25432839216089387, 0.3496401584370531, 0.3205936205281651, 0.24799817879243458, 0.2049044175449346, 0.2050406885952042, 0.19339595528285414, 0.23014267289000723, 0.1591455203936355, 0.17392836692168145, 0.30115092105501995, 0.24771614897992256, 0.2505107578850698, 0.16810014560305575, 0.1856725083675328, 0.17527192379479273, 0.16175044539165884, 0.16657358148037293, 0.14734273924494123, 0.1742166734559858, 0.152908668773309, 0.18684345007287406, 0.22654612260702467, 0.1924535659973019, 0.20592139985138724, 0.2189481584682912, 0.18662936683958098, 0.19381843944332589, 0.18699353413887998, 0.5413186978626977, 0.1796777889253004, 0.15801772200873165, 0.19170821710855357, 0.5759800765975858, 0.16376423444023203, 0.5573179701922764, 0.1726549834837593, 0.15079576322443355, 0.15487500205542493, 0.5853343264323381, 0.1516597131264893, 0.5537231104510113, 0.422404051394737, 0.3728332272804241, 0.13356910718768633, 0.5657539020167981, 0.19262406803765975, 0.19086877080587206, 0.18482420377761422, 0.18032875447261743, 0.17721668211656072, 0.20723180638489458, 0.17084502257251188, 0.1951814417039991, 0.19980754776874943, 0.20960076210591794, 0.20039741323267568, 0.18602509204204187, 0.05750849385164325, 0.055965362101724314, 0.06114928867892233, 0.062193936825302054, 0.0649436742097188, 0.05355304262872429, 0.06194916570401021, 0.06904637505292288, 0.05580805594196281]}, "mutation_prompt": null}
{"id": "6134bcaf-48b1-403a-add9-b88e97f41738", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1200.0  # Adjusted initial temperature\n        self.cooling_rate = 0.92  # Adjusted cooling rate\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x**2))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.35 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (0.4 + 0.6 * np.cos(np.pi * evaluations / self.budget))))  # Enhanced dynamic adaptation\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def _crowding_distance(self, population):\n        distances = np.zeros(self.population_size)\n        for i in range(self.dim):\n            sorted_idx = np.argsort(population[:, i])\n            sorted_population = population[sorted_idx, i]\n            distances[sorted_idx[0]] = distances[sorted_idx[-1]] = float('inf')\n            for j in range(1, self.population_size - 1):\n                distances[sorted_idx[j]] += (sorted_population[j + 1] - sorted_population[j - 1])\n        return distances\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        local_search_frequency = max(1, int(0.1 * self.budget / self.initial_population_size))\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            if evaluations % local_search_frequency == 0:\n                local_search_idx = np.random.randint(self.population_size)\n                local_search_candidate = np.clip(population[local_search_idx] + \n                                                 np.random.normal(0, 0.5, self.dim),  # Enhanced local search modification\n                                                 self.lower_bound, self.upper_bound)\n                local_search_fitness = func(local_search_candidate)\n                evaluations += 1\n                if local_search_fitness < fitness[local_search_idx]:\n                    population[local_search_idx] = local_search_candidate\n                    fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            crowd_indices = np.argsort(self._crowding_distance(population))\n            combined_indices = np.lexsort((crowd_indices, ranked_indices))\n            population = np.vstack((population[combined_indices[:self.population_size]], best_solution))  # Add best solution for elitism\n            fitness = np.append(fitness[combined_indices[:self.population_size]], best_fitness)  # Maintain corresponding fitness\n\n        return best_solution", "name": "HybridDESA", "description": "Enhanced HybridDESA with diversity-preserving crowding distance and adaptive local search frequency.", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 49 is out of bounds for axis 0 with size 49').", "error": "IndexError('index 49 is out of bounds for axis 0 with size 49')", "parent_id": "e84a894d-04b1-4853-ad99-978712326946", "metadata": {}, "mutation_prompt": null}
{"id": "e039e0a2-d3be-4dbe-99ab-67c18eea7eed", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1200.0  # Adjusted initial temperature\n        self.cooling_rate = 0.92  # Adjusted cooling rate\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x**2))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.35 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (0.4 + 0.6 * np.cos(np.pi * evaluations / self.budget))))  # Enhanced dynamic adaptation\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.5, self.dim),  # Enhanced local search modification\n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = np.vstack((population[ranked_indices[:self.population_size]], best_solution))  # Add best solution for elitism\n            fitness = np.append(fitness[ranked_indices[:self.population_size]], best_fitness)  # Maintain corresponding fitness\n\n        return best_solution", "name": "HybridDESA", "description": "Enhanced HybridDESA with improved adaptive population resizing and chaotic local search exploitation.", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e84a894d-04b1-4853-ad99-978712326946", "metadata": {"aucs": [0.5396092196869418, 0.5077085388044724, 0.5172405296833367, 0.540148060836587, 0.5473880672435043, 0.5557213104158443, 0.5439013597905231, 0.547312548098804, 0.5441956268378774, 0.4905888666928915, 0.46762776127487427, 0.5240969095766554, 0.5187042670343935, 0.5043328340550304, 0.4560981763450159, 0.5145741165592255, 0.524141191107373, 0.5211297620507342, 0.14378776347473288, 0.14112127135262198, 0.11265708109485417, 0.09384480384159255, 0.09651884040013647, 0.14440210745135407, 0.1253037290688246, 0.12277901621533005, 0.12544806626023963, 0.138908484483227, 0.09255196180731218, 0.11760626925745532, 0.11071761847631356, 0.12143597730615108, 0.11230889143032441, 0.12618467897021124, 0.10328445472510372, 0.10686794269244948, 0.9855044408535428, 0.9187113217488253, 0.9266842668899798, 0.9223184915121061, 0.9216872770258423, 0.9476506338654214, 0.9325964503388863, 0.8489117649341402, 0.9717612573983417, 0.36322302179682553, 0.3765275820043831, 0.4218004597307746, 0.3916645395455386, 0.4057751351416451, 0.38518165467626986, 0.4057169896114855, 0.37935469936506483, 0.4151863615491116, 0.5820643721881709, 0.5690715716572091, 0.29171054825433473, 0.5925042814622185, 0.28257370020304207, 0.5778450879550681, 0.636330845297465, 0.5944573479984574, 0.6075416258970483, 0.1632811806624912, 0.11347849693754886, 0.2630939429185615, 0.2102351133992555, 0.17196206706890427, 0.27906576299536134, 0.19166029327769984, 0.1909211238248354, 0.24480630701530348, 0.050417397935929364, 0.12933528690658225, 0.13506794308263181, 0.2201332200925833, 0.2437401700796339, 0.195208629512987, 0.09498899797777316, 0.23052907496915398, 0.44119959926682273, 0.05122477595862329, 0.08094261090375987, 0.1320354306436553, 0.0050207618948965305, 0.0005814699679409507, 0.06522996688068561, 0.1729306124738671, 0.06233225161645317, 0.1290548326988752, 0.11817038837890614, 0.24522176057535472, 0.12331713671728106, 0.3608610020576547, 0.1472481379870011, 0.11940191263753863, 0.374028401616083, 0.20486393620478116, 0.35575397058737435, 0.028712085828330403, 0.0298449469428842, 0.029485468846230267, 0.08729491475363027, 0.11676549026517691, 0.1311735049792293, 0.1867206095195998, 0.0868047491611511, 0.13853132095552356, 0.2679272579651166, 0.16309035136008276, 0.23449233307363482, 0.19147118278434372, 0.2613498752196898, 0.22572659252427485, 0.2103476989289328, 0.26882542020709854, 0.10667394318416612, 0.40689444596215185, 0.40291501769430316, 0.38563364469843264, 0.4024161752953036, 0.41417961324000974, 0.39749395482567373, 0.39154969866753886, 0.42928120638136735, 0.41964168878410457, 0.11806678874008225, 0.0756933055728699, 0.0587465008860345, 0.07212552434615482, 0.06481295808965437, 0.11051493561329206, 0.07339825244085496, 0.06206998851915346, 0.07319855715411772, 0.1451774003104911, 0.15331501318206397, 0.17802978161131466, 0.15608004274486464, 0.14796035146937025, 0.13226868845640616, 0.17720751480850572, 0.13187131447472056, 0.13601847517527854, 0.3047987824910592, 0.22088866258308704, 0.32476640157489456, 0.28104855913766413, 0.32612635462641104, 0.25432839216089387, 0.3496401584370531, 0.3205936205281651, 0.24799817879243458, 0.2049044175449346, 0.2050406885952042, 0.19339595528285414, 0.23014267289000723, 0.1591455203936355, 0.17392836692168145, 0.30115092105501995, 0.24771614897992256, 0.2505107578850698, 0.16810014560305575, 0.1856725083675328, 0.17527192379479273, 0.16175044539165884, 0.16657358148037293, 0.14734273924494123, 0.1742166734559858, 0.152908668773309, 0.18684345007287406, 0.22654612260702467, 0.1924535659973019, 0.20592139985138724, 0.2189481584682912, 0.18662936683958098, 0.19381843944332589, 0.18699353413887998, 0.5413186978626977, 0.1796777889253004, 0.15801772200873165, 0.19170821710855357, 0.5759800765975858, 0.16376423444023203, 0.5573179701922764, 0.1726549834837593, 0.15079576322443355, 0.15487500205542493, 0.5853343264323381, 0.1516597131264893, 0.5537231104510113, 0.422404051394737, 0.3728332272804241, 0.13356910718768633, 0.5657539020167981, 0.19262406803765975, 0.19086877080587206, 0.18482420377761422, 0.18032875447261743, 0.17721668211656072, 0.20723180638489458, 0.17084502257251188, 0.1951814417039991, 0.19980754776874943, 0.20960076210591794, 0.20039741323267568, 0.18602509204204187, 0.05750849385164325, 0.055965362101724314, 0.06114928867892233, 0.062193936825302054, 0.0649436742097188, 0.05355304262872429, 0.06194916570401021, 0.06904637505292288, 0.05580805594196281]}, "mutation_prompt": null}
{"id": "d1c0fc5a-981d-421f-9b06-f9d18d7fe9ad", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1200.0  # Adjusted initial temperature\n        self.cooling_rate = 0.92  # Adjusted cooling rate\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x**2))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.35 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (0.4 + 0.6 * np.cos(np.pi * evaluations / self.budget))))  # Enhanced dynamic adaptation\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.5, self.dim),  # Enhanced local search modification\n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = np.vstack((population[ranked_indices[:self.population_size]], best_solution))  # Add best solution for elitism\n            fitness = np.append(fitness[ranked_indices[:self.population_size]], best_fitness)  # Maintain corresponding fitness\n\n        return best_solution", "name": "HybridDESA", "description": "Enhanced HybridDESA with improved adaptive population resizing and chaotic local search exploitation.", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e84a894d-04b1-4853-ad99-978712326946", "metadata": {"aucs": [0.5396092196869418, 0.5077085388044724, 0.5172405296833367, 0.540148060836587, 0.5473880672435043, 0.5557213104158443, 0.5439013597905231, 0.547312548098804, 0.5441956268378774, 0.4905888666928915, 0.46762776127487427, 0.5240969095766554, 0.5187042670343935, 0.5043328340550304, 0.4560981763450159, 0.5145741165592255, 0.524141191107373, 0.5211297620507342, 0.14378776347473288, 0.14112127135262198, 0.11265708109485417, 0.09384480384159255, 0.09651884040013647, 0.14440210745135407, 0.1253037290688246, 0.12277901621533005, 0.12544806626023963, 0.138908484483227, 0.09255196180731218, 0.11760626925745532, 0.11071761847631356, 0.12143597730615108, 0.11230889143032441, 0.12618467897021124, 0.10328445472510372, 0.10686794269244948, 0.9855044408535428, 0.9187113217488253, 0.9266842668899798, 0.9223184915121061, 0.9216872770258423, 0.9476506338654214, 0.9325964503388863, 0.8489117649341402, 0.9717612573983417, 0.36322302179682553, 0.3765275820043831, 0.4218004597307746, 0.3916645395455386, 0.4057751351416451, 0.38518165467626986, 0.4057169896114855, 0.37935469936506483, 0.4151863615491116, 0.5820643721881709, 0.5690715716572091, 0.29171054825433473, 0.5925042814622185, 0.28257370020304207, 0.5778450879550681, 0.636330845297465, 0.5944573479984574, 0.6075416258970483, 0.1632811806624912, 0.11347849693754886, 0.2630939429185615, 0.2102351133992555, 0.17196206706890427, 0.27906576299536134, 0.19166029327769984, 0.1909211238248354, 0.24480630701530348, 0.050417397935929364, 0.12933528690658225, 0.13506794308263181, 0.2201332200925833, 0.2437401700796339, 0.195208629512987, 0.09498899797777316, 0.23052907496915398, 0.44119959926682273, 0.05122477595862329, 0.08094261090375987, 0.1320354306436553, 0.0050207618948965305, 0.0005814699679409507, 0.06522996688068561, 0.1729306124738671, 0.06233225161645317, 0.1290548326988752, 0.11817038837890614, 0.24522176057535472, 0.12331713671728106, 0.3608610020576547, 0.1472481379870011, 0.11940191263753863, 0.374028401616083, 0.20486393620478116, 0.35575397058737435, 0.028712085828330403, 0.0298449469428842, 0.029485468846230267, 0.08729491475363027, 0.11676549026517691, 0.1311735049792293, 0.1867206095195998, 0.0868047491611511, 0.13853132095552356, 0.2679272579651166, 0.16309035136008276, 0.23449233307363482, 0.19147118278434372, 0.2613498752196898, 0.22572659252427485, 0.2103476989289328, 0.26882542020709854, 0.10667394318416612, 0.40689444596215185, 0.40291501769430316, 0.38563364469843264, 0.4024161752953036, 0.41417961324000974, 0.39749395482567373, 0.39154969866753886, 0.42928120638136735, 0.41964168878410457, 0.11806678874008225, 0.0756933055728699, 0.0587465008860345, 0.07212552434615482, 0.06481295808965437, 0.11051493561329206, 0.07339825244085496, 0.06206998851915346, 0.07319855715411772, 0.1451774003104911, 0.15331501318206397, 0.17802978161131466, 0.15608004274486464, 0.14796035146937025, 0.13226868845640616, 0.17720751480850572, 0.13187131447472056, 0.13601847517527854, 0.3047987824910592, 0.22088866258308704, 0.32476640157489456, 0.28104855913766413, 0.32612635462641104, 0.25432839216089387, 0.3496401584370531, 0.3205936205281651, 0.24799817879243458, 0.2049044175449346, 0.2050406885952042, 0.19339595528285414, 0.23014267289000723, 0.1591455203936355, 0.17392836692168145, 0.30115092105501995, 0.24771614897992256, 0.2505107578850698, 0.16810014560305575, 0.1856725083675328, 0.17527192379479273, 0.16175044539165884, 0.16657358148037293, 0.14734273924494123, 0.1742166734559858, 0.152908668773309, 0.18684345007287406, 0.22654612260702467, 0.1924535659973019, 0.20592139985138724, 0.2189481584682912, 0.18662936683958098, 0.19381843944332589, 0.18699353413887998, 0.5413186978626977, 0.1796777889253004, 0.15801772200873165, 0.19170821710855357, 0.5759800765975858, 0.16376423444023203, 0.5573179701922764, 0.1726549834837593, 0.15079576322443355, 0.15487500205542493, 0.5853343264323381, 0.1516597131264893, 0.5537231104510113, 0.422404051394737, 0.3728332272804241, 0.13356910718768633, 0.5657539020167981, 0.19262406803765975, 0.19086877080587206, 0.18482420377761422, 0.18032875447261743, 0.17721668211656072, 0.20723180638489458, 0.17084502257251188, 0.1951814417039991, 0.19980754776874943, 0.20960076210591794, 0.20039741323267568, 0.18602509204204187, 0.05750849385164325, 0.055965362101724314, 0.06114928867892233, 0.062193936825302054, 0.0649436742097188, 0.05355304262872429, 0.06194916570401021, 0.06904637505292288, 0.05580805594196281]}, "mutation_prompt": null}
{"id": "5914a2b2-98e9-4f73-9fd8-25cf3ecba12f", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1200.0  # Adjusted initial temperature\n        self.cooling_rate = 0.92  # Adjusted cooling rate\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x**2))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        mutant = np.clip(population[a] + adaptive_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.35 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (0.4 + 0.6 * np.cos(np.pi * evaluations / self.budget))))  # Enhanced dynamic adaptation\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] + \n                                             np.random.normal(0, 0.5, self.dim),  # Enhanced local search modification\n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            population = np.vstack((population[ranked_indices[:self.population_size]], best_solution))  # Add best solution for elitism\n            fitness = np.append(fitness[ranked_indices[:self.population_size]], best_fitness)  # Maintain corresponding fitness\n\n        return best_solution", "name": "HybridDESA", "description": "Enhanced HybridDESA with improved adaptive population resizing and chaotic local search exploitation.", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e84a894d-04b1-4853-ad99-978712326946", "metadata": {"aucs": [0.5396092196869418, 0.5077085388044724, 0.5172405296833367, 0.540148060836587, 0.5473880672435043, 0.5557213104158443, 0.5439013597905231, 0.547312548098804, 0.5441956268378774, 0.4905888666928915, 0.46762776127487427, 0.5240969095766554, 0.5187042670343935, 0.5043328340550304, 0.4560981763450159, 0.5145741165592255, 0.524141191107373, 0.5211297620507342, 0.14378776347473288, 0.14112127135262198, 0.11265708109485417, 0.09384480384159255, 0.09651884040013647, 0.14440210745135407, 0.1253037290688246, 0.12277901621533005, 0.12544806626023963, 0.138908484483227, 0.09255196180731218, 0.11760626925745532, 0.11071761847631356, 0.12143597730615108, 0.11230889143032441, 0.12618467897021124, 0.10328445472510372, 0.10686794269244948, 0.9855044408535428, 0.9187113217488253, 0.9266842668899798, 0.9223184915121061, 0.9216872770258423, 0.9476506338654214, 0.9325964503388863, 0.8489117649341402, 0.9717612573983417, 0.36322302179682553, 0.3765275820043831, 0.4218004597307746, 0.3916645395455386, 0.4057751351416451, 0.38518165467626986, 0.4057169896114855, 0.37935469936506483, 0.4151863615491116, 0.5820643721881709, 0.5690715716572091, 0.29171054825433473, 0.5925042814622185, 0.28257370020304207, 0.5778450879550681, 0.636330845297465, 0.5944573479984574, 0.6075416258970483, 0.1632811806624912, 0.11347849693754886, 0.2630939429185615, 0.2102351133992555, 0.17196206706890427, 0.27906576299536134, 0.19166029327769984, 0.1909211238248354, 0.24480630701530348, 0.050417397935929364, 0.12933528690658225, 0.13506794308263181, 0.2201332200925833, 0.2437401700796339, 0.195208629512987, 0.09498899797777316, 0.23052907496915398, 0.44119959926682273, 0.05122477595862329, 0.08094261090375987, 0.1320354306436553, 0.0050207618948965305, 0.0005814699679409507, 0.06522996688068561, 0.1729306124738671, 0.06233225161645317, 0.1290548326988752, 0.11817038837890614, 0.24522176057535472, 0.12331713671728106, 0.3608610020576547, 0.1472481379870011, 0.11940191263753863, 0.374028401616083, 0.20486393620478116, 0.35575397058737435, 0.028712085828330403, 0.0298449469428842, 0.029485468846230267, 0.08729491475363027, 0.11676549026517691, 0.1311735049792293, 0.1867206095195998, 0.0868047491611511, 0.13853132095552356, 0.2679272579651166, 0.16309035136008276, 0.23449233307363482, 0.19147118278434372, 0.2613498752196898, 0.22572659252427485, 0.2103476989289328, 0.26882542020709854, 0.10667394318416612, 0.40689444596215185, 0.40291501769430316, 0.38563364469843264, 0.4024161752953036, 0.41417961324000974, 0.39749395482567373, 0.39154969866753886, 0.42928120638136735, 0.41964168878410457, 0.11806678874008225, 0.0756933055728699, 0.0587465008860345, 0.07212552434615482, 0.06481295808965437, 0.11051493561329206, 0.07339825244085496, 0.06206998851915346, 0.07319855715411772, 0.1451774003104911, 0.15331501318206397, 0.17802978161131466, 0.15608004274486464, 0.14796035146937025, 0.13226868845640616, 0.17720751480850572, 0.13187131447472056, 0.13601847517527854, 0.3047987824910592, 0.22088866258308704, 0.32476640157489456, 0.28104855913766413, 0.32612635462641104, 0.25432839216089387, 0.3496401584370531, 0.3205936205281651, 0.24799817879243458, 0.2049044175449346, 0.2050406885952042, 0.19339595528285414, 0.23014267289000723, 0.1591455203936355, 0.17392836692168145, 0.30115092105501995, 0.24771614897992256, 0.2505107578850698, 0.16810014560305575, 0.1856725083675328, 0.17527192379479273, 0.16175044539165884, 0.16657358148037293, 0.14734273924494123, 0.1742166734559858, 0.152908668773309, 0.18684345007287406, 0.22654612260702467, 0.1924535659973019, 0.20592139985138724, 0.2189481584682912, 0.18662936683958098, 0.19381843944332589, 0.18699353413887998, 0.5413186978626977, 0.1796777889253004, 0.15801772200873165, 0.19170821710855357, 0.5759800765975858, 0.16376423444023203, 0.5573179701922764, 0.1726549834837593, 0.15079576322443355, 0.15487500205542493, 0.5853343264323381, 0.1516597131264893, 0.5537231104510113, 0.422404051394737, 0.3728332272804241, 0.13356910718768633, 0.5657539020167981, 0.19262406803765975, 0.19086877080587206, 0.18482420377761422, 0.18032875447261743, 0.17721668211656072, 0.20723180638489458, 0.17084502257251188, 0.1951814417039991, 0.19980754776874943, 0.20960076210591794, 0.20039741323267568, 0.18602509204204187, 0.05750849385164325, 0.055965362101724314, 0.06114928867892233, 0.062193936825302054, 0.0649436742097188, 0.05355304262872429, 0.06194916570401021, 0.06904637505292288, 0.05580805594196281]}, "mutation_prompt": null}
{"id": "84a7217b-f44f-4bb3-8af1-7af38553152c", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1200.0\n        self.cooling_rate = 0.92\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x**2))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        # Multi-scale mutation strategy\n        scale_factor = 0.5 if evaluations < self.budget / 2 else 1.0\n        mutant = np.clip(population[a] + adaptive_factor * scale_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.35 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (0.4 + 0.6 * np.cos(np.pi * evaluations / self.budget))))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] +\n                                             np.random.normal(0, 0.5, self.dim),\n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            # Adaptive elitism adjustment\n            elite_size = max(1, int(0.1 * self.population_size))\n            population = np.vstack((population[ranked_indices[:self.population_size]], best_solution))\n            fitness = np.append(fitness[ranked_indices[:self.population_size]], best_fitness)\n\n        return best_solution", "name": "HybridDESA", "description": "Improved HybridDESA with a novel multi-scale mutation strategy and adaptive elitism for better convergence and exploration-exploitation balance.", "configspace": "", "generation": 96, "fitness": 0.29157832089994806, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.", "error": "", "parent_id": "e84a894d-04b1-4853-ad99-978712326946", "metadata": {"aucs": [0.5646128820531178, 0.5291710976199564, 0.5517459143733991, 0.569500550814708, 0.564576759938727, 0.5478628486242345, 0.5705573935098592, 0.5690403475876753, 0.5367325981411455, 0.5535012896646314, 0.5056127165523281, 0.5258216657293336, 0.4951093762480193, 0.4885163048029807, 0.5535333351600265, 0.5434455086413881, 0.5425756054431363, 0.5516804398083025, 0.15166729547652846, 0.13218481234371704, 0.12214561715768324, 0.49959694110600705, 0.11552739535853396, 0.1414812511908462, 0.12705749289619384, 0.14278330932747374, 0.4224461073976238, 0.11937022386460483, 0.14938813693790653, 0.09609443009266538, 0.12922777407255015, 0.12699175667420481, 0.11707960501536585, 0.13090567902715045, 0.13574685195551317, 0.14611406616630596, 0.715047255808344, 0.6938548068722188, 0.8544047158834586, 0.7535043772504, 0.8046318437834253, 0.6953149473821464, 0.7659849428028772, 0.7889728135386966, 0.6719957970087554, 0.3920838330911429, 0.4024660802575156, 0.3808859262493276, 0.33248858656514235, 0.39527543896509376, 0.31766344403708635, 0.37112202239167336, 0.328832798055259, 0.3688758006391625, 0.637783473281669, 0.6313538838663354, 0.31146248082038597, 0.2368642546589249, 0.6271860503191369, 0.2426326591887502, 0.6342272862525431, 0.6185673861687839, 0.6187029237423087, 0.17540771183304082, 0.15447416224886124, 0.1394022608208365, 0.1659528581094093, 0.15371276065162676, 0.18579368831700638, 0.1543919397529866, 0.17110010578088897, 0.19718945300115653, 0.17446217484941462, 0.17164261344357779, 0.12225745165788027, 0.15270977314542666, 0.2245666176045239, 0.1518473376943693, 0.16231630327603486, 0.15151061910640928, 0.2046958125610413, 0.0653638363144986, 0.10252481683613845, 0.06559984637471661, 0.05545418953971715, 0.09934049937043488, 0.4532157916368855, 0.31254994191852725, 0.12027376609775675, 0.13577836351425465, 0.38129035568779845, 0.3555588363093467, 0.3837599224810151, 0.15445407774972342, 0.12969063917094703, 0.2760983092252437, 0.29578068070162045, 0.3291516529306626, 0.4541456005301776, 0.04045261107172049, 0.0443541447648691, 0.05811207490987058, 0.10259291529995718, 0.16160270530359389, 0.17919325389609408, 0.12160665739570964, 0.07679946871065402, 0.16349140129467765, 0.2027046989982627, 0.32517538347199637, 0.1724024972964442, 0.3335713583542259, 0.3070280619699127, 0.26755751092085567, 0.10236122358307254, 0.200360845935033, 0.20619370297331985, 0.42715841890010686, 0.433237893477899, 0.42529747302174215, 0.4479937849885154, 0.3913657824923492, 0.431842356944358, 0.4066585388085415, 0.4527319083381647, 0.4305346973500713, 0.13341435065158058, 0.13688944179375906, 0.08666038544083388, 0.10121903874256732, 0.11404391084407639, 0.12717078604232868, 0.1303050556589005, 0.08237405656010122, 0.09174007257407724, 0.1808181360269404, 0.5435461518024316, 0.1497326979871485, 0.2404696837458099, 0.3094516166020501, 0.17582774494317233, 0.21372322832164647, 0.19331312883255702, 0.13952704274013117, 0.28271194807292077, 0.31837602876337945, 0.38181751808651265, 0.31586663958043926, 0.324045599415397, 0.2757003264283878, 0.40302516923842946, 0.34782082797753167, 0.3179147941935102, 0.33616418895076394, 0.2596410417547711, 0.24303800977490775, 0.23033508900075383, 0.32053550415663346, 0.2672368995591554, 0.25351426202802263, 0.26155435817301353, 0.2483543106224233, 0.1721578417174533, 0.17999872028937536, 0.19619419139050265, 0.1763719835878006, 0.18981036045192456, 0.1866002116467227, 0.15742778789215406, 0.16322199837329332, 0.19584260985214397, 0.5564236118299026, 0.19141426186941768, 0.18578989888623854, 0.19231302839204623, 0.2221976285892977, 0.22139109428996684, 0.5434680417308446, 0.2045513508426341, 0.1864236137837919, 0.615481256767562, 0.1912808932668052, 0.6064284713526322, 0.15520248448366036, 0.6165882112128088, 0.1853031430267953, 0.6356433404659684, 0.15876293160291788, 0.6433637989972492, 0.5782705936484794, 0.5774289950352283, 0.11989429635009785, 0.5456167504863576, 0.15749040373306633, 0.1842350914079648, 0.19784156086239102, 0.18929201402915752, 0.1934823946175913, 0.17006350734239872, 0.1838688242398474, 0.17633445823347538, 0.1958614487242909, 0.1900201885082402, 0.17830996239324215, 0.16880137597562805, 0.1690547720166995, 0.2043399056102051, 0.07616615594413811, 0.06651671703111783, 0.09148355522233009, 0.07320819464411399, 0.0672216969204732, 0.07732940734719418, 0.07017390736881934, 0.07738405230393441, 0.0762579223429406]}, "mutation_prompt": null}
{"id": "a528c6e5-26f2-443a-b138-29b3b92e7604", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1200.0\n        self.cooling_rate = 0.92\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x**2))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        # Multi-scale mutation strategy\n        scale_factor = 0.5 if evaluations < self.budget / 2 else 1.0\n        mutant = np.clip(population[a] + adaptive_factor * scale_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.35 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (0.4 + 0.6 * np.cos(np.pi * evaluations / self.budget))))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] +\n                                             np.random.normal(0, 0.5, self.dim),\n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            # Adaptive elitism adjustment\n            elite_size = max(1, int(0.1 * self.population_size))\n            population = np.vstack((population[ranked_indices[:self.population_size]], best_solution))\n            fitness = np.append(fitness[ranked_indices[:self.population_size]], best_fitness)\n\n        return best_solution", "name": "HybridDESA", "description": "Improved HybridDESA with a novel multi-scale mutation strategy and adaptive elitism for better convergence and exploration-exploitation balance.", "configspace": "", "generation": 97, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "84a7217b-f44f-4bb3-8af1-7af38553152c", "metadata": {"aucs": [0.5646128820531178, 0.5291710976199564, 0.5517459143733991, 0.569500550814708, 0.564576759938727, 0.5478628486242345, 0.5705573935098592, 0.5690403475876753, 0.5367325981411455, 0.5535012896646314, 0.5056127165523281, 0.5258216657293336, 0.4951093762480193, 0.4885163048029807, 0.5535333351600265, 0.5434455086413881, 0.5425756054431363, 0.5516804398083025, 0.15166729547652846, 0.13218481234371704, 0.12214561715768324, 0.49959694110600705, 0.11552739535853396, 0.1414812511908462, 0.12705749289619384, 0.14278330932747374, 0.4224461073976238, 0.11937022386460483, 0.14938813693790653, 0.09609443009266538, 0.12922777407255015, 0.12699175667420481, 0.11707960501536585, 0.13090567902715045, 0.13574685195551317, 0.14611406616630596, 0.715047255808344, 0.6938548068722188, 0.8544047158834586, 0.7535043772504, 0.8046318437834253, 0.6953149473821464, 0.7659849428028772, 0.7889728135386966, 0.6719957970087554, 0.3920838330911429, 0.4024660802575156, 0.3808859262493276, 0.33248858656514235, 0.39527543896509376, 0.31766344403708635, 0.37112202239167336, 0.328832798055259, 0.3688758006391625, 0.637783473281669, 0.6313538838663354, 0.31146248082038597, 0.2368642546589249, 0.6271860503191369, 0.2426326591887502, 0.6342272862525431, 0.6185673861687839, 0.6187029237423087, 0.17540771183304082, 0.15447416224886124, 0.1394022608208365, 0.1659528581094093, 0.15371276065162676, 0.18579368831700638, 0.1543919397529866, 0.17110010578088897, 0.19718945300115653, 0.17446217484941462, 0.17164261344357779, 0.12225745165788027, 0.15270977314542666, 0.2245666176045239, 0.1518473376943693, 0.16231630327603486, 0.15151061910640928, 0.2046958125610413, 0.0653638363144986, 0.10252481683613845, 0.06559984637471661, 0.05545418953971715, 0.09934049937043488, 0.4532157916368855, 0.31254994191852725, 0.12027376609775675, 0.13577836351425465, 0.38129035568779845, 0.3555588363093467, 0.3837599224810151, 0.15445407774972342, 0.12969063917094703, 0.2760983092252437, 0.29578068070162045, 0.3291516529306626, 0.4541456005301776, 0.04045261107172049, 0.0443541447648691, 0.05811207490987058, 0.10259291529995718, 0.16160270530359389, 0.17919325389609408, 0.12160665739570964, 0.07679946871065402, 0.16349140129467765, 0.2027046989982627, 0.32517538347199637, 0.1724024972964442, 0.3335713583542259, 0.3070280619699127, 0.26755751092085567, 0.10236122358307254, 0.200360845935033, 0.20619370297331985, 0.42715841890010686, 0.433237893477899, 0.42529747302174215, 0.4479937849885154, 0.3913657824923492, 0.431842356944358, 0.4066585388085415, 0.4527319083381647, 0.4305346973500713, 0.13341435065158058, 0.13688944179375906, 0.08666038544083388, 0.10121903874256732, 0.11404391084407639, 0.12717078604232868, 0.1303050556589005, 0.08237405656010122, 0.09174007257407724, 0.1808181360269404, 0.5435461518024316, 0.1497326979871485, 0.2404696837458099, 0.3094516166020501, 0.17582774494317233, 0.21372322832164647, 0.19331312883255702, 0.13952704274013117, 0.28271194807292077, 0.31837602876337945, 0.38181751808651265, 0.31586663958043926, 0.324045599415397, 0.2757003264283878, 0.40302516923842946, 0.34782082797753167, 0.3179147941935102, 0.33616418895076394, 0.2596410417547711, 0.24303800977490775, 0.23033508900075383, 0.32053550415663346, 0.2672368995591554, 0.25351426202802263, 0.26155435817301353, 0.2483543106224233, 0.1721578417174533, 0.17999872028937536, 0.19619419139050265, 0.1763719835878006, 0.18981036045192456, 0.1866002116467227, 0.15742778789215406, 0.16322199837329332, 0.19584260985214397, 0.5564236118299026, 0.19141426186941768, 0.18578989888623854, 0.19231302839204623, 0.2221976285892977, 0.22139109428996684, 0.5434680417308446, 0.2045513508426341, 0.1864236137837919, 0.615481256767562, 0.1912808932668052, 0.6064284713526322, 0.15520248448366036, 0.6165882112128088, 0.1853031430267953, 0.6356433404659684, 0.15876293160291788, 0.6433637989972492, 0.5782705936484794, 0.5774289950352283, 0.11989429635009785, 0.5456167504863576, 0.15749040373306633, 0.1842350914079648, 0.19784156086239102, 0.18929201402915752, 0.1934823946175913, 0.17006350734239872, 0.1838688242398474, 0.17633445823347538, 0.1958614487242909, 0.1900201885082402, 0.17830996239324215, 0.16880137597562805, 0.1690547720166995, 0.2043399056102051, 0.07616615594413811, 0.06651671703111783, 0.09148355522233009, 0.07320819464411399, 0.0672216969204732, 0.07732940734719418, 0.07017390736881934, 0.07738405230393441, 0.0762579223429406]}, "mutation_prompt": null}
{"id": "a62feef9-95eb-4729-8703-392afa80c44a", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1200.0\n        self.cooling_rate = 0.92\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x**2))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        # Multi-scale mutation strategy\n        scale_factor = 0.5 if evaluations < self.budget / 2 else 1.0\n        mutant = np.clip(population[a] + adaptive_factor * scale_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.35 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (0.4 + 0.6 * np.cos(np.pi * evaluations / self.budget))))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] +\n                                             np.random.normal(0, 0.5, self.dim),\n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            # Adaptive elitism adjustment\n            elite_size = max(1, int(0.1 * self.population_size))\n            population = np.vstack((population[ranked_indices[:self.population_size]], best_solution))\n            fitness = np.append(fitness[ranked_indices[:self.population_size]], best_fitness)\n\n        return best_solution", "name": "HybridDESA", "description": "Improved HybridDESA with a novel multi-scale mutation strategy and adaptive elitism for better convergence and exploration-exploitation balance.", "configspace": "", "generation": 97, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "84a7217b-f44f-4bb3-8af1-7af38553152c", "metadata": {"aucs": [0.5646128820531178, 0.5291710976199564, 0.5517459143733991, 0.569500550814708, 0.564576759938727, 0.5478628486242345, 0.5705573935098592, 0.5690403475876753, 0.5367325981411455, 0.5535012896646314, 0.5056127165523281, 0.5258216657293336, 0.4951093762480193, 0.4885163048029807, 0.5535333351600265, 0.5434455086413881, 0.5425756054431363, 0.5516804398083025, 0.15166729547652846, 0.13218481234371704, 0.12214561715768324, 0.49959694110600705, 0.11552739535853396, 0.1414812511908462, 0.12705749289619384, 0.14278330932747374, 0.4224461073976238, 0.11937022386460483, 0.14938813693790653, 0.09609443009266538, 0.12922777407255015, 0.12699175667420481, 0.11707960501536585, 0.13090567902715045, 0.13574685195551317, 0.14611406616630596, 0.715047255808344, 0.6938548068722188, 0.8544047158834586, 0.7535043772504, 0.8046318437834253, 0.6953149473821464, 0.7659849428028772, 0.7889728135386966, 0.6719957970087554, 0.3920838330911429, 0.4024660802575156, 0.3808859262493276, 0.33248858656514235, 0.39527543896509376, 0.31766344403708635, 0.37112202239167336, 0.328832798055259, 0.3688758006391625, 0.637783473281669, 0.6313538838663354, 0.31146248082038597, 0.2368642546589249, 0.6271860503191369, 0.2426326591887502, 0.6342272862525431, 0.6185673861687839, 0.6187029237423087, 0.17540771183304082, 0.15447416224886124, 0.1394022608208365, 0.1659528581094093, 0.15371276065162676, 0.18579368831700638, 0.1543919397529866, 0.17110010578088897, 0.19718945300115653, 0.17446217484941462, 0.17164261344357779, 0.12225745165788027, 0.15270977314542666, 0.2245666176045239, 0.1518473376943693, 0.16231630327603486, 0.15151061910640928, 0.2046958125610413, 0.0653638363144986, 0.10252481683613845, 0.06559984637471661, 0.05545418953971715, 0.09934049937043488, 0.4532157916368855, 0.31254994191852725, 0.12027376609775675, 0.13577836351425465, 0.38129035568779845, 0.3555588363093467, 0.3837599224810151, 0.15445407774972342, 0.12969063917094703, 0.2760983092252437, 0.29578068070162045, 0.3291516529306626, 0.4541456005301776, 0.04045261107172049, 0.0443541447648691, 0.05811207490987058, 0.10259291529995718, 0.16160270530359389, 0.17919325389609408, 0.12160665739570964, 0.07679946871065402, 0.16349140129467765, 0.2027046989982627, 0.32517538347199637, 0.1724024972964442, 0.3335713583542259, 0.3070280619699127, 0.26755751092085567, 0.10236122358307254, 0.200360845935033, 0.20619370297331985, 0.42715841890010686, 0.433237893477899, 0.42529747302174215, 0.4479937849885154, 0.3913657824923492, 0.431842356944358, 0.4066585388085415, 0.4527319083381647, 0.4305346973500713, 0.13341435065158058, 0.13688944179375906, 0.08666038544083388, 0.10121903874256732, 0.11404391084407639, 0.12717078604232868, 0.1303050556589005, 0.08237405656010122, 0.09174007257407724, 0.1808181360269404, 0.5435461518024316, 0.1497326979871485, 0.2404696837458099, 0.3094516166020501, 0.17582774494317233, 0.21372322832164647, 0.19331312883255702, 0.13952704274013117, 0.28271194807292077, 0.31837602876337945, 0.38181751808651265, 0.31586663958043926, 0.324045599415397, 0.2757003264283878, 0.40302516923842946, 0.34782082797753167, 0.3179147941935102, 0.33616418895076394, 0.2596410417547711, 0.24303800977490775, 0.23033508900075383, 0.32053550415663346, 0.2672368995591554, 0.25351426202802263, 0.26155435817301353, 0.2483543106224233, 0.1721578417174533, 0.17999872028937536, 0.19619419139050265, 0.1763719835878006, 0.18981036045192456, 0.1866002116467227, 0.15742778789215406, 0.16322199837329332, 0.19584260985214397, 0.5564236118299026, 0.19141426186941768, 0.18578989888623854, 0.19231302839204623, 0.2221976285892977, 0.22139109428996684, 0.5434680417308446, 0.2045513508426341, 0.1864236137837919, 0.615481256767562, 0.1912808932668052, 0.6064284713526322, 0.15520248448366036, 0.6165882112128088, 0.1853031430267953, 0.6356433404659684, 0.15876293160291788, 0.6433637989972492, 0.5782705936484794, 0.5774289950352283, 0.11989429635009785, 0.5456167504863576, 0.15749040373306633, 0.1842350914079648, 0.19784156086239102, 0.18929201402915752, 0.1934823946175913, 0.17006350734239872, 0.1838688242398474, 0.17633445823347538, 0.1958614487242909, 0.1900201885082402, 0.17830996239324215, 0.16880137597562805, 0.1690547720166995, 0.2043399056102051, 0.07616615594413811, 0.06651671703111783, 0.09148355522233009, 0.07320819464411399, 0.0672216969204732, 0.07732940734719418, 0.07017390736881934, 0.07738405230393441, 0.0762579223429406]}, "mutation_prompt": null}
{"id": "1c6a8d3b-c73c-46f8-88d3-7090ea5f9639", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1200.0\n        self.cooling_rate = 0.92\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound,\n                                 (self.population_size, self.dim))\n\n    def _adaptive_mutation_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def _chaotic_initialization(self, size):\n        x = np.random.rand(size, self.dim)\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.abs(np.sin(np.pi * x**2))\n\n    def _mutate(self, idx, population, evaluations):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = self._adaptive_mutation_factor(evaluations)\n        scale_factor = np.random.uniform(0.5, 1.5)  # Dynamic scale factor\n        mutant = np.clip(population[a] + adaptive_factor * scale_factor * (population[b] - population[c]),\n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _adaptive_crossover_rate(self, evaluations):\n        return 0.6 + 0.35 * (evaluations / self.budget)\n\n    def _crossover(self, target, mutant, evaluations):\n        crossover_rate = self._adaptive_crossover_rate(evaluations)\n        crossover_mask = np.random.rand(self.dim) < crossover_rate\n        crossover_mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def _acceptance_probability(self, old_cost, new_cost, temperature):\n        if new_cost < old_cost:\n            return 1.0\n        else:\n            return np.exp((old_cost - new_cost) / temperature)\n\n    def _adaptive_population_size(self, evaluations):\n        return max(4, int(self.initial_population_size * (0.4 + 0.6 * np.cos(np.pi * evaluations / self.budget))))\n\n    def _stochastic_ranking(self, fitness):\n        indices = np.argsort(fitness)\n        return indices\n\n    def __call__(self, func):\n        population = self._chaotic_initialization(self.population_size)\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.population_size = self._adaptive_population_size(evaluations)\n            \n            local_search_idx = np.random.randint(self.population_size)\n            local_search_candidate = np.clip(population[local_search_idx] +\n                                             np.random.normal(0, 0.5, self.dim),\n                                             self.lower_bound, self.upper_bound)\n            local_search_fitness = func(local_search_candidate)\n            evaluations += 1\n            if local_search_fitness < fitness[local_search_idx]:\n                population[local_search_idx] = local_search_candidate\n                fitness[local_search_idx] = local_search_fitness\n\n            for i in range(self.population_size):\n                mutant = self._mutate(i, population, evaluations)\n                trial = self._crossover(population[i], mutant, evaluations)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n                if trial_fitness < fitness[i] or np.random.rand() < self._acceptance_probability(fitness[i], trial_fitness, self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n            ranked_indices = self._stochastic_ranking(fitness)\n            elite_size = max(1, int(0.15 * self.population_size))  # Enhanced elitism\n            population = np.vstack((population[ranked_indices[:self.population_size]], best_solution))\n            fitness = np.append(fitness[ranked_indices[:self.population_size]], best_fitness)\n\n        return best_solution", "name": "HybridDESA", "description": "Enhanced HybridDESA with dynamic mutation strategy and enriched selection mechanism for improved exploration.", "configspace": "", "generation": 99, "fitness": 0.28121178293573634, "feedback": "The algorithm HybridDESA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.20.", "error": "", "parent_id": "84a7217b-f44f-4bb3-8af1-7af38553152c", "metadata": {"aucs": [0.4854090946022197, 0.5186540133142801, 0.5218674384711859, 0.5583471688864188, 0.5323782191055864, 0.5430198752085165, 0.5227076858446738, 0.5734543606313494, 0.5366071162264066, 0.5309676937873609, 0.5261468158900593, 0.4750960253644434, 0.5060378973236082, 0.5051219944842349, 0.5288301588091708, 0.48555780238456503, 0.5257343623027684, 0.4858563778317937, 0.4984861553763399, 0.4944078783847117, 0.22707804986393043, 0.14471055397105448, 0.1285990936231447, 0.1426136046366142, 0.14781785527101965, 0.14284845713204974, 0.4639496671628216, 0.13512885614961212, 0.17663354968655676, 0.13904490265893943, 0.11497293841605094, 0.14169665984574964, 0.14106942739203243, 0.11847935969160805, 0.11734426385490737, 0.10376218260685655, 0.9238930720022988, 0.9544345494693453, 0.9537868267220547, 0.9190634338459474, 0.8651144267670114, 0.92705877702002, 0.8922863150158852, 0.8885115688062285, 0.98203877898673, 0.3595020019255242, 0.3976863992065418, 0.3709295141585376, 0.4184930391833487, 0.3941961521831938, 0.338757604787865, 0.3840166957246458, 0.37540075218101787, 0.29720243852296147, 0.6010069364590478, 0.2968800320539233, 0.5623621917433201, 0.5856966743791675, 0.29021891780596043, 0.5804038877655365, 0.30831423370231315, 0.597504030540891, 0.5960821410493868, 0.21291459277792701, 0.20172831118153212, 0.11347463119567891, 0.2765793683406681, 0.248104937948455, 0.21343364292489064, 0.23330801003218793, 0.2029855729835096, 0.17023314398516376, 0.33781234125605863, 0.17677537040631397, 0.0571023820140395, 0.16413320667441256, 0.22072133720208742, 0.19216495387968946, 0.2540660762298764, 0.1887309082491747, 0.17172741876887754, 0.034816542680125684, 0.06657045349920732, 0.14126335786534416, 0.2033005379465933, 0.000529212596880102, 0.03150427555997626, 0.3987066918833989, 0.07263181292929788, 0.022300869605595852, 0.09698563740611388, 0.10862655848831781, 0.20550775653017472, 0.31111310174091755, 0.0950935306430929, 0.09867241720082509, 0.2732150312146142, 0.32341997935989675, 0.4380215131951549, 0.09394256494290332, 0.043554155060371524, 0.0682773509063942, 0.1355546305951193, 0.16575057461486953, 0.18466850893653453, 0.10032949865160357, 0.09660249683964794, 0.1738139565269179, 0.16057721944673198, 0.24246658618799455, 0.17201773094090045, 0.248065344811351, 0.28879226558807014, 0.22383106286186072, 0.2095318880339634, 0.15656600204505355, 0.186948518603945, 0.39578879411548884, 0.42809135364777695, 0.39279888917894346, 0.41009168472071145, 0.45332768554166947, 0.4294787564614859, 0.4253123656292973, 0.4070551105706849, 0.40406129985447126, 0.07723573344644152, 0.10214531032954821, 0.11178191809948712, 0.06355398806431145, 0.08975178317248467, 0.09676556115294987, 0.12411114775815224, 0.10106852378973508, 0.08311185165948176, 0.1763728734902097, 0.148526041467422, 0.16047143262176777, 0.1407525509569425, 0.13505465067633615, 0.20651727762749283, 0.14152995883387032, 0.2234929392226631, 0.2588210788298899, 0.3257032900073088, 0.2885808580524888, 0.30629807686710997, 0.17933488893682792, 0.3409599951537392, 0.25069332818178625, 0.378236876316428, 0.3569639547533723, 0.2938513467289736, 0.2522012191691656, 0.26491256482072245, 0.19776247076895925, 0.2000541970059836, 0.16159581163668135, 0.19411712445544793, 0.2470995920338389, 0.18197054440052718, 0.24168512418948207, 0.18519618951362526, 0.16211516620801392, 0.15583795542851586, 0.14681251733590128, 0.16728920639648515, 0.1419975600997021, 0.16221978431366402, 0.16404923858407439, 0.17801636923623243, 0.2133524381380988, 0.19255743632237854, 0.18660443029053053, 0.16387957826773758, 0.50346880501264, 0.2274590501297188, 0.2171176571172423, 0.18966672777358284, 0.5381462433291813, 0.1571920608375854, 0.5976218276647152, 0.1581251796396207, 0.16346915476966684, 0.5902382461061038, 0.6213655983149948, 0.15102472483424045, 0.16765560030651727, 0.1720156561096079, 0.553596614898809, 0.14936534035654747, 0.17908112630583417, 0.18177134742492485, 0.13888356553571723, 0.10545435151444438, 0.18736726496197587, 0.579729767106085, 0.19199905977531606, 0.18173299864827452, 0.17842112968720725, 0.18100687054308673, 0.1773824087823701, 0.20006694109253342, 0.2132519567281228, 0.23603914912488821, 0.20215399186709027, 0.18624709376303838, 0.09010906288211151, 0.09161299969040082, 0.06578269743688947, 0.06936779168869112, 0.07583769385926065, 0.08543189685576513, 0.0688141600183424, 0.07122046664058601, 0.06558635026016435]}, "mutation_prompt": null}
