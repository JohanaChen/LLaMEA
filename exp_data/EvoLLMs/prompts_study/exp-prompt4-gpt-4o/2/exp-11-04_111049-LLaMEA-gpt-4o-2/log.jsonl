{"id": "573879b8-f911-49f9-9153-4234bbe30840", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < func(individual):\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "An adaptive memetic algorithm combining differential evolution and local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 0, "fitness": 0.2571886914764419, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": null, "metadata": {"aucs": [0.6039350122729534, 0.5952149621674756, 0.6218478021831451, 0.6066630408194239, 0.6410371186691097, 0.6250534507472101, 0.6110678013542424, 0.5462917611669991, 0.629531872114435, 0.3697174040268528, 0.3669369290391955, 0.4524530442300271, 0.36164383666659783, 0.2769612590971303, 0.3336918637821805, 0.3247551550984854, 0.33654628769671024, 0.3379682845930576, 0.09477728701841825, 0.08271421337741736, 0.11231637514104587, 0.09356977415278056, 0.0892542648042145, 0.08989707427332905, 0.10320401729032003, 0.10830789148685749, 0.10324872849930322, 0.08067480376289371, 0.09196378062600674, 0.09327228328148485, 0.09001932268209256, 0.09169295916113829, 0.09232249238013335, 0.09449479886523571, 0.0910318126761076, 0.10024689043006385, 0.9121908029517921, 0.8603554023836044, 0.9223364481206701, 0.9153504724989995, 0.8772081427059671, 0.8634184514173824, 0.8790013730987266, 0.9193135768160452, 0.9155872866498785, 0.2655551842298197, 0.30186043113594696, 0.29191407158930793, 0.2844264073629097, 0.30778365538890295, 0.2586134536025092, 0.28729692623503456, 0.29174159101256114, 0.28455758665450637, 0.4964939138682587, 0.3872629284311222, 0.46016311080729944, 0.6281896929792871, 0.5354453117286729, 0.5726856406894725, 0.598841715263642, 0.5797062703810036, 0.42270483935256065, 0.24737386016839635, 0.1780987028623604, 0.2163965432809548, 0.1651501444569119, 0.17278006986960537, 0.19824346985808272, 0.14897059360603837, 0.21100440870938098, 0.16666454449678458, 0.15477033024359188, 0.11095627414031128, 0.16110400721807383, 0.15414800672223916, 0.2145587529968439, 0.16604708204478902, 0.11418820329195312, 0.19416914092181037, 0.15080173052390766, 0.11194337599634419, 0.08788358645254024, 0.09183664146208337, 0.1266601758544149, 0.16023091900932906, 0.14536676167524643, 0.16852831191652007, 0.11973259343520781, 0.12575461458273163, 0.23198001087166797, 0.29954107148060216, 0.24320778461917292, 0.28367599719913184, 0.25299668969604094, 0.2200423447327291, 0.28743783281545343, 0.3151500805310947, 0.17013253254683913, 0.04080109116538355, 0.06205722043098161, 0.023854766385587256, 0.05759260154840251, 0.04295206088178061, 0.029444889726949475, 0.026717016246022074, 0.04101862094707098, 0.04444323759201818, 0.1637103837055034, 0.13614779551858047, 0.16225079143436838, 0.16917409754168844, 0.16596426125889552, 0.13037896254773929, 0.1600492199724255, 0.1613735909506775, 0.1395289218362703, 0.47198586876842596, 0.4374989566784385, 0.4747771154362329, 0.453741851186619, 0.4319842328715139, 0.47729015577752476, 0.4387169173809595, 0.47478728678075366, 0.49856439817029574, 0.08809721095602197, 0.09583711914775872, 0.10736012794248984, 0.08238234543862144, 0.10151763154105375, 0.08978587150041817, 0.08347606739999935, 0.08898895203480084, 0.09784969303873492, 0.13810321086187938, 0.15495691969737946, 0.1322122780066871, 0.151375674116759, 0.14803753358297034, 0.13151597730850573, 0.2124682882637362, 0.25459201150288546, 0.19777827128293746, 0.2684855226842575, 0.25859318933951747, 0.24501138386925903, 0.236578237985689, 0.2469045582291295, 0.24763858329192723, 0.29884086503919016, 0.29413307215066864, 0.2773280524321343, 0.19166295774183084, 0.17669474391783457, 0.20503958852482018, 0.18908894763570783, 0.20477046623753714, 0.18917433776388703, 0.21773042615288596, 0.22101171564363709, 0.21724507760604184, 0.1725443226202913, 0.1767016402384265, 0.16646574837016725, 0.19769003351139192, 0.1693325638037333, 0.17095002189964748, 0.1849842682337658, 0.1666100827138387, 0.18901105289195097, 0.17159811687786808, 0.16301211266059823, 0.17193782124577062, 0.1831696179447888, 0.21323105622989602, 0.17247571442386977, 0.16747080671098924, 0.16999938765510392, 0.17589081508985038, 0.154530820835437, 0.5945626123442306, 0.16107055431025552, 0.6668839740132906, 0.18232501303453952, 0.17121139665872265, 0.15319642977860204, 0.5936306345168656, 0.15657792420550054, 0.42003345400289727, 0.18761372670725418, 0.44279755089998585, 0.1684018987682968, 0.17973348039888037, 0.18996613427997966, 0.6545564703996938, 0.11867292067075974, 0.19261082193431744, 0.17714440840965873, 0.17567055888447158, 0.17733591294316997, 0.18825289712766913, 0.201830672772622, 0.16833530193932622, 0.1797402396301211, 0.18371883585799398, 0.19292281817021095, 0.07606245514274756, 0.07726333573319955, 0.06815186946011054, 0.07537051716906518, 0.06019342380475079, 0.06089927736143086, 0.06851390840262972, 0.06570019329610766, 0.09326897603486273]}, "mutation_prompt": null}
{"id": "b9ab152c-031f-48e2-855e-8306ffe02a7c", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < func(individual):\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "An adaptive memetic algorithm combining differential evolution and local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "573879b8-f911-49f9-9153-4234bbe30840", "metadata": {"aucs": [0.6039350122729534, 0.5952149621674756, 0.6218478021831451, 0.6066630408194239, 0.6410371186691097, 0.6250534507472101, 0.6110678013542424, 0.5462917611669991, 0.629531872114435, 0.3697174040268528, 0.3669369290391955, 0.4524530442300271, 0.36164383666659783, 0.2769612590971303, 0.3336918637821805, 0.3247551550984854, 0.33654628769671024, 0.3379682845930576, 0.09477728701841825, 0.08271421337741736, 0.11231637514104587, 0.09356977415278056, 0.0892542648042145, 0.08989707427332905, 0.10320401729032003, 0.10830789148685749, 0.10324872849930322, 0.08067480376289371, 0.09196378062600674, 0.09327228328148485, 0.09001932268209256, 0.09169295916113829, 0.09232249238013335, 0.09449479886523571, 0.0910318126761076, 0.10024689043006385, 0.9121908029517921, 0.8603554023836044, 0.9223364481206701, 0.9153504724989995, 0.8772081427059671, 0.8634184514173824, 0.8790013730987266, 0.9193135768160452, 0.9155872866498785, 0.2655551842298197, 0.30186043113594696, 0.29191407158930793, 0.2844264073629097, 0.30778365538890295, 0.2586134536025092, 0.28729692623503456, 0.29174159101256114, 0.28455758665450637, 0.4964939138682587, 0.3872629284311222, 0.46016311080729944, 0.6281896929792871, 0.5354453117286729, 0.5726856406894725, 0.598841715263642, 0.5797062703810036, 0.42270483935256065, 0.24737386016839635, 0.1780987028623604, 0.2163965432809548, 0.1651501444569119, 0.17278006986960537, 0.19824346985808272, 0.14897059360603837, 0.21100440870938098, 0.16666454449678458, 0.15477033024359188, 0.11095627414031128, 0.16110400721807383, 0.15414800672223916, 0.2145587529968439, 0.16604708204478902, 0.11418820329195312, 0.19416914092181037, 0.15080173052390766, 0.11194337599634419, 0.08788358645254024, 0.09183664146208337, 0.1266601758544149, 0.16023091900932906, 0.14536676167524643, 0.16852831191652007, 0.11973259343520781, 0.12575461458273163, 0.23198001087166797, 0.29954107148060216, 0.24320778461917292, 0.28367599719913184, 0.25299668969604094, 0.2200423447327291, 0.28743783281545343, 0.3151500805310947, 0.17013253254683913, 0.04080109116538355, 0.06205722043098161, 0.023854766385587256, 0.05759260154840251, 0.04295206088178061, 0.029444889726949475, 0.026717016246022074, 0.04101862094707098, 0.04444323759201818, 0.1637103837055034, 0.13614779551858047, 0.16225079143436838, 0.16917409754168844, 0.16596426125889552, 0.13037896254773929, 0.1600492199724255, 0.1613735909506775, 0.1395289218362703, 0.47198586876842596, 0.4374989566784385, 0.4747771154362329, 0.453741851186619, 0.4319842328715139, 0.47729015577752476, 0.4387169173809595, 0.47478728678075366, 0.49856439817029574, 0.08809721095602197, 0.09583711914775872, 0.10736012794248984, 0.08238234543862144, 0.10151763154105375, 0.08978587150041817, 0.08347606739999935, 0.08898895203480084, 0.09784969303873492, 0.13810321086187938, 0.15495691969737946, 0.1322122780066871, 0.151375674116759, 0.14803753358297034, 0.13151597730850573, 0.2124682882637362, 0.25459201150288546, 0.19777827128293746, 0.2684855226842575, 0.25859318933951747, 0.24501138386925903, 0.236578237985689, 0.2469045582291295, 0.24763858329192723, 0.29884086503919016, 0.29413307215066864, 0.2773280524321343, 0.19166295774183084, 0.17669474391783457, 0.20503958852482018, 0.18908894763570783, 0.20477046623753714, 0.18917433776388703, 0.21773042615288596, 0.22101171564363709, 0.21724507760604184, 0.1725443226202913, 0.1767016402384265, 0.16646574837016725, 0.19769003351139192, 0.1693325638037333, 0.17095002189964748, 0.1849842682337658, 0.1666100827138387, 0.18901105289195097, 0.17159811687786808, 0.16301211266059823, 0.17193782124577062, 0.1831696179447888, 0.21323105622989602, 0.17247571442386977, 0.16747080671098924, 0.16999938765510392, 0.17589081508985038, 0.154530820835437, 0.5945626123442306, 0.16107055431025552, 0.6668839740132906, 0.18232501303453952, 0.17121139665872265, 0.15319642977860204, 0.5936306345168656, 0.15657792420550054, 0.42003345400289727, 0.18761372670725418, 0.44279755089998585, 0.1684018987682968, 0.17973348039888037, 0.18996613427997966, 0.6545564703996938, 0.11867292067075974, 0.19261082193431744, 0.17714440840965873, 0.17567055888447158, 0.17733591294316997, 0.18825289712766913, 0.201830672772622, 0.16833530193932622, 0.1797402396301211, 0.18371883585799398, 0.19292281817021095, 0.07606245514274756, 0.07726333573319955, 0.06815186946011054, 0.07537051716906518, 0.06019342380475079, 0.06089927736143086, 0.06851390840262972, 0.06570019329610766, 0.09326897603486273]}, "mutation_prompt": null}
{"id": "d9c72548-9b53-4bca-b0d9-9f75ecacf4e5", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget)\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < func(individual):\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Enhance the local search by dynamically adjusting the perturbation size based on the current iteration to improve exploitation.", "configspace": "", "generation": 2, "fitness": 0.2575510552687868, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "573879b8-f911-49f9-9153-4234bbe30840", "metadata": {"aucs": [0.640734724699932, 0.5858602702078637, 0.5881312211212633, 0.6166102335665555, 0.6574016550894282, 0.6491767695016493, 0.5978951002145214, 0.588599733342607, 0.6257436364169404, 0.37335086419384544, 0.3637052518976417, 0.37659038208399576, 0.32844684175323435, 0.38558632669264825, 0.40145433336235203, 0.3837268121785886, 0.336437895130417, 0.36530703201347825, 0.08937448248417901, 0.10208746024639426, 0.07821851587920936, 0.11054150343262681, 0.10366375651884119, 0.11572954556308268, 0.1051368151514982, 0.0965393249565557, 0.09674465476040917, 0.07511824526080213, 0.07581686208760552, 0.08920311333527464, 0.08412885583944785, 0.08386975294377608, 0.11594452074006545, 0.09669375812364489, 0.09000731207021162, 0.08926065565862207, 0.9060307756795203, 0.8884985510525248, 0.922368699428857, 0.9154190430358264, 0.8324843171213026, 0.8635577320712132, 0.8848630085622867, 0.9193290337223244, 0.9155773251637911, 0.255079909985766, 0.28351551789369767, 0.29833380397873366, 0.27085103637082164, 0.2979591230509513, 0.26256867761472014, 0.30083143699407966, 0.2901490367549885, 0.24470250009132666, 0.5147270637615533, 0.41715462482191956, 0.47025131450749713, 0.5696170694938986, 0.4673268607614224, 0.49429405410879135, 0.5244414116062873, 0.5371892337857289, 0.5469653542742818, 0.22580571884632783, 0.20359142367118543, 0.21218429190191046, 0.16564083890297787, 0.13857721285428393, 0.17688462862014787, 0.10618655166713742, 0.1986738946329465, 0.1980799434831364, 0.17371614785424372, 0.18162179920564248, 0.12812147133040996, 0.18334244335496463, 0.16612325119781945, 0.19344866382802817, 0.16387967957507754, 0.16401069064936624, 0.148527617565676, 0.11485597817358717, 0.09446547665562521, 0.11280610111601985, 0.1091003664112935, 0.14025359968142326, 0.16379654660420562, 0.11488119234016503, 0.1547375121585126, 0.10881539322480627, 0.2256927301812136, 0.2618350833080778, 0.21916980344079218, 0.28421461713985174, 0.2733962273531073, 0.24385381338041057, 0.25249463747422096, 0.3430018656727257, 0.25268887653290917, 0.038516647429157835, 0.016633906275529076, 0.036046744049279544, 0.01304576383895606, 0.047097910307194124, 0.009023305716892582, 0.019566875263714034, 0.03037398409547254, 0.041416747222329686, 0.1557650061149325, 0.13340059403102755, 0.14539953094706348, 0.14956585377834652, 0.14539417016515432, 0.16635637187474495, 0.1614884336696708, 0.16078277350752213, 0.14281097172188706, 0.518243833201847, 0.4949008472195163, 0.5130611999571124, 0.5005575557012001, 0.465405798755715, 0.4512704531492099, 0.44498496858101866, 0.4909957828197433, 0.4886018713990826, 0.08008210404687577, 0.08175286292537587, 0.0913275739165218, 0.09390963892353643, 0.09624131085797671, 0.09079189027030188, 0.0806577592146499, 0.09580705361757313, 0.0749396089182901, 0.1264411884687492, 0.16006980317114872, 0.13332365850523986, 0.1742895191097914, 0.1425087632826857, 0.12988358042975434, 0.20650860312783914, 0.25186756872087834, 0.24685940178057264, 0.2852147625048541, 0.23678072648750992, 0.283300960609004, 0.24090379531089678, 0.2686478363921073, 0.2596528418834061, 0.27678675412401943, 0.28835187564308606, 0.2610473875217918, 0.2064148531149459, 0.2197705733619163, 0.2028927460322154, 0.15857818439706428, 0.1781676603227692, 0.21520799715352534, 0.21902864564389013, 0.23811450009538748, 0.20999935221447785, 0.17195882218756797, 0.18590719257944244, 0.17396684697688813, 0.175459226376794, 0.17498972152193615, 0.17120021704649613, 0.18388096703127266, 0.20651239831295243, 0.17234590593579036, 0.17862538948000983, 0.17723693856361045, 0.17851734073111913, 0.17733369427591184, 0.17035705915493615, 0.1754275003435034, 0.18462518332747813, 0.17257170831555635, 0.1819130930004087, 0.15441366685699376, 0.5930000609813011, 0.16114946135267127, 0.67993326404798, 0.18240899927733456, 0.1712534415370166, 0.16168838923363016, 0.6251023075375302, 0.15665986522352526, 0.3696132778816288, 0.18604381689533633, 0.4186517278845856, 0.16954610728480768, 0.185106464992549, 0.18851786021644956, 0.6130852358923002, 0.11856349411908884, 0.19561501545655824, 0.1741302407869233, 0.18445615340179666, 0.19638611445895227, 0.16239094520678576, 0.1817931196197473, 0.17836460707015955, 0.17952941504306652, 0.17918277915619873, 0.19092440509303654, 0.06176735023686253, 0.06362447757081813, 0.06700834884828255, 0.07853241043537096, 0.07206416195586285, 0.07397304229091883, 0.06278570552600937, 0.06643203004793008, 0.07226890237875827]}, "mutation_prompt": null}
{"id": "ee70bd1b-5628-40c9-8d4c-9ac1ebd24da3", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget)\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < func(individual):\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Enhance the local search by dynamically adjusting the perturbation size based on the current iteration to improve exploitation.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d9c72548-9b53-4bca-b0d9-9f75ecacf4e5", "metadata": {"aucs": [0.640734724699932, 0.5858602702078637, 0.5881312211212633, 0.6166102335665555, 0.6574016550894282, 0.6491767695016493, 0.5978951002145214, 0.588599733342607, 0.6257436364169404, 0.37335086419384544, 0.3637052518976417, 0.37659038208399576, 0.32844684175323435, 0.38558632669264825, 0.40145433336235203, 0.3837268121785886, 0.336437895130417, 0.36530703201347825, 0.08937448248417901, 0.10208746024639426, 0.07821851587920936, 0.11054150343262681, 0.10366375651884119, 0.11572954556308268, 0.1051368151514982, 0.0965393249565557, 0.09674465476040917, 0.07511824526080213, 0.07581686208760552, 0.08920311333527464, 0.08412885583944785, 0.08386975294377608, 0.11594452074006545, 0.09669375812364489, 0.09000731207021162, 0.08926065565862207, 0.9060307756795203, 0.8884985510525248, 0.922368699428857, 0.9154190430358264, 0.8324843171213026, 0.8635577320712132, 0.8848630085622867, 0.9193290337223244, 0.9155773251637911, 0.255079909985766, 0.28351551789369767, 0.29833380397873366, 0.27085103637082164, 0.2979591230509513, 0.26256867761472014, 0.30083143699407966, 0.2901490367549885, 0.24470250009132666, 0.5147270637615533, 0.41715462482191956, 0.47025131450749713, 0.5696170694938986, 0.4673268607614224, 0.49429405410879135, 0.5244414116062873, 0.5371892337857289, 0.5469653542742818, 0.22580571884632783, 0.20359142367118543, 0.21218429190191046, 0.16564083890297787, 0.13857721285428393, 0.17688462862014787, 0.10618655166713742, 0.1986738946329465, 0.1980799434831364, 0.17371614785424372, 0.18162179920564248, 0.12812147133040996, 0.18334244335496463, 0.16612325119781945, 0.19344866382802817, 0.16387967957507754, 0.16401069064936624, 0.148527617565676, 0.11485597817358717, 0.09446547665562521, 0.11280610111601985, 0.1091003664112935, 0.14025359968142326, 0.16379654660420562, 0.11488119234016503, 0.1547375121585126, 0.10881539322480627, 0.2256927301812136, 0.2618350833080778, 0.21916980344079218, 0.28421461713985174, 0.2733962273531073, 0.24385381338041057, 0.25249463747422096, 0.3430018656727257, 0.25268887653290917, 0.038516647429157835, 0.016633906275529076, 0.036046744049279544, 0.01304576383895606, 0.047097910307194124, 0.009023305716892582, 0.019566875263714034, 0.03037398409547254, 0.041416747222329686, 0.1557650061149325, 0.13340059403102755, 0.14539953094706348, 0.14956585377834652, 0.14539417016515432, 0.16635637187474495, 0.1614884336696708, 0.16078277350752213, 0.14281097172188706, 0.518243833201847, 0.4949008472195163, 0.5130611999571124, 0.5005575557012001, 0.465405798755715, 0.4512704531492099, 0.44498496858101866, 0.4909957828197433, 0.4886018713990826, 0.08008210404687577, 0.08175286292537587, 0.0913275739165218, 0.09390963892353643, 0.09624131085797671, 0.09079189027030188, 0.0806577592146499, 0.09580705361757313, 0.0749396089182901, 0.1264411884687492, 0.16006980317114872, 0.13332365850523986, 0.1742895191097914, 0.1425087632826857, 0.12988358042975434, 0.20650860312783914, 0.25186756872087834, 0.24685940178057264, 0.2852147625048541, 0.23678072648750992, 0.283300960609004, 0.24090379531089678, 0.2686478363921073, 0.2596528418834061, 0.27678675412401943, 0.28835187564308606, 0.2610473875217918, 0.2064148531149459, 0.2197705733619163, 0.2028927460322154, 0.15857818439706428, 0.1781676603227692, 0.21520799715352534, 0.21902864564389013, 0.23811450009538748, 0.20999935221447785, 0.17195882218756797, 0.18590719257944244, 0.17396684697688813, 0.175459226376794, 0.17498972152193615, 0.17120021704649613, 0.18388096703127266, 0.20651239831295243, 0.17234590593579036, 0.17862538948000983, 0.17723693856361045, 0.17851734073111913, 0.17733369427591184, 0.17035705915493615, 0.1754275003435034, 0.18462518332747813, 0.17257170831555635, 0.1819130930004087, 0.15441366685699376, 0.5930000609813011, 0.16114946135267127, 0.67993326404798, 0.18240899927733456, 0.1712534415370166, 0.16168838923363016, 0.6251023075375302, 0.15665986522352526, 0.3696132778816288, 0.18604381689533633, 0.4186517278845856, 0.16954610728480768, 0.185106464992549, 0.18851786021644956, 0.6130852358923002, 0.11856349411908884, 0.19561501545655824, 0.1741302407869233, 0.18445615340179666, 0.19638611445895227, 0.16239094520678576, 0.1817931196197473, 0.17836460707015955, 0.17952941504306652, 0.17918277915619873, 0.19092440509303654, 0.06176735023686253, 0.06362447757081813, 0.06700834884828255, 0.07853241043537096, 0.07206416195586285, 0.07397304229091883, 0.06278570552600937, 0.06643203004793008, 0.07226890237875827]}, "mutation_prompt": null}
{"id": "5fe3e15e-bd56-4318-ab0c-383ba7dbef74", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget)\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < func(individual):\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Enhance the local search by dynamically adjusting the perturbation size based on the current iteration to improve exploitation.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d9c72548-9b53-4bca-b0d9-9f75ecacf4e5", "metadata": {"aucs": [0.640734724699932, 0.5858602702078637, 0.5881312211212633, 0.6166102335665555, 0.6574016550894282, 0.6491767695016493, 0.5978951002145214, 0.588599733342607, 0.6257436364169404, 0.37335086419384544, 0.3637052518976417, 0.37659038208399576, 0.32844684175323435, 0.38558632669264825, 0.40145433336235203, 0.3837268121785886, 0.336437895130417, 0.36530703201347825, 0.08937448248417901, 0.10208746024639426, 0.07821851587920936, 0.11054150343262681, 0.10366375651884119, 0.11572954556308268, 0.1051368151514982, 0.0965393249565557, 0.09674465476040917, 0.07511824526080213, 0.07581686208760552, 0.08920311333527464, 0.08412885583944785, 0.08386975294377608, 0.11594452074006545, 0.09669375812364489, 0.09000731207021162, 0.08926065565862207, 0.9060307756795203, 0.8884985510525248, 0.922368699428857, 0.9154190430358264, 0.8324843171213026, 0.8635577320712132, 0.8848630085622867, 0.9193290337223244, 0.9155773251637911, 0.255079909985766, 0.28351551789369767, 0.29833380397873366, 0.27085103637082164, 0.2979591230509513, 0.26256867761472014, 0.30083143699407966, 0.2901490367549885, 0.24470250009132666, 0.5147270637615533, 0.41715462482191956, 0.47025131450749713, 0.5696170694938986, 0.4673268607614224, 0.49429405410879135, 0.5244414116062873, 0.5371892337857289, 0.5469653542742818, 0.22580571884632783, 0.20359142367118543, 0.21218429190191046, 0.16564083890297787, 0.13857721285428393, 0.17688462862014787, 0.10618655166713742, 0.1986738946329465, 0.1980799434831364, 0.17371614785424372, 0.18162179920564248, 0.12812147133040996, 0.18334244335496463, 0.16612325119781945, 0.19344866382802817, 0.16387967957507754, 0.16401069064936624, 0.148527617565676, 0.11485597817358717, 0.09446547665562521, 0.11280610111601985, 0.1091003664112935, 0.14025359968142326, 0.16379654660420562, 0.11488119234016503, 0.1547375121585126, 0.10881539322480627, 0.2256927301812136, 0.2618350833080778, 0.21916980344079218, 0.28421461713985174, 0.2733962273531073, 0.24385381338041057, 0.25249463747422096, 0.3430018656727257, 0.25268887653290917, 0.038516647429157835, 0.016633906275529076, 0.036046744049279544, 0.01304576383895606, 0.047097910307194124, 0.009023305716892582, 0.019566875263714034, 0.03037398409547254, 0.041416747222329686, 0.1557650061149325, 0.13340059403102755, 0.14539953094706348, 0.14956585377834652, 0.14539417016515432, 0.16635637187474495, 0.1614884336696708, 0.16078277350752213, 0.14281097172188706, 0.518243833201847, 0.4949008472195163, 0.5130611999571124, 0.5005575557012001, 0.465405798755715, 0.4512704531492099, 0.44498496858101866, 0.4909957828197433, 0.4886018713990826, 0.08008210404687577, 0.08175286292537587, 0.0913275739165218, 0.09390963892353643, 0.09624131085797671, 0.09079189027030188, 0.0806577592146499, 0.09580705361757313, 0.0749396089182901, 0.1264411884687492, 0.16006980317114872, 0.13332365850523986, 0.1742895191097914, 0.1425087632826857, 0.12988358042975434, 0.20650860312783914, 0.25186756872087834, 0.24685940178057264, 0.2852147625048541, 0.23678072648750992, 0.283300960609004, 0.24090379531089678, 0.2686478363921073, 0.2596528418834061, 0.27678675412401943, 0.28835187564308606, 0.2610473875217918, 0.2064148531149459, 0.2197705733619163, 0.2028927460322154, 0.15857818439706428, 0.1781676603227692, 0.21520799715352534, 0.21902864564389013, 0.23811450009538748, 0.20999935221447785, 0.17195882218756797, 0.18590719257944244, 0.17396684697688813, 0.175459226376794, 0.17498972152193615, 0.17120021704649613, 0.18388096703127266, 0.20651239831295243, 0.17234590593579036, 0.17862538948000983, 0.17723693856361045, 0.17851734073111913, 0.17733369427591184, 0.17035705915493615, 0.1754275003435034, 0.18462518332747813, 0.17257170831555635, 0.1819130930004087, 0.15441366685699376, 0.5930000609813011, 0.16114946135267127, 0.67993326404798, 0.18240899927733456, 0.1712534415370166, 0.16168838923363016, 0.6251023075375302, 0.15665986522352526, 0.3696132778816288, 0.18604381689533633, 0.4186517278845856, 0.16954610728480768, 0.185106464992549, 0.18851786021644956, 0.6130852358923002, 0.11856349411908884, 0.19561501545655824, 0.1741302407869233, 0.18445615340179666, 0.19638611445895227, 0.16239094520678576, 0.1817931196197473, 0.17836460707015955, 0.17952941504306652, 0.17918277915619873, 0.19092440509303654, 0.06176735023686253, 0.06362447757081813, 0.06700834884828255, 0.07853241043537096, 0.07206416195586285, 0.07397304229091883, 0.06278570552600937, 0.06643203004793008, 0.07226890237875827]}, "mutation_prompt": null}
{"id": "fed51773-dc5e-47f4-94a8-5dbdd886587d", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget)\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < func(individual):\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Enhance the local search by dynamically adjusting the perturbation size based on the current iteration to improve exploitation.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d9c72548-9b53-4bca-b0d9-9f75ecacf4e5", "metadata": {"aucs": [0.640734724699932, 0.5858602702078637, 0.5881312211212633, 0.6166102335665555, 0.6574016550894282, 0.6491767695016493, 0.5978951002145214, 0.588599733342607, 0.6257436364169404, 0.37335086419384544, 0.3637052518976417, 0.37659038208399576, 0.32844684175323435, 0.38558632669264825, 0.40145433336235203, 0.3837268121785886, 0.336437895130417, 0.36530703201347825, 0.08937448248417901, 0.10208746024639426, 0.07821851587920936, 0.11054150343262681, 0.10366375651884119, 0.11572954556308268, 0.1051368151514982, 0.0965393249565557, 0.09674465476040917, 0.07511824526080213, 0.07581686208760552, 0.08920311333527464, 0.08412885583944785, 0.08386975294377608, 0.11594452074006545, 0.09669375812364489, 0.09000731207021162, 0.08926065565862207, 0.9060307756795203, 0.8884985510525248, 0.922368699428857, 0.9154190430358264, 0.8324843171213026, 0.8635577320712132, 0.8848630085622867, 0.9193290337223244, 0.9155773251637911, 0.255079909985766, 0.28351551789369767, 0.29833380397873366, 0.27085103637082164, 0.2979591230509513, 0.26256867761472014, 0.30083143699407966, 0.2901490367549885, 0.24470250009132666, 0.5147270637615533, 0.41715462482191956, 0.47025131450749713, 0.5696170694938986, 0.4673268607614224, 0.49429405410879135, 0.5244414116062873, 0.5371892337857289, 0.5469653542742818, 0.22580571884632783, 0.20359142367118543, 0.21218429190191046, 0.16564083890297787, 0.13857721285428393, 0.17688462862014787, 0.10618655166713742, 0.1986738946329465, 0.1980799434831364, 0.17371614785424372, 0.18162179920564248, 0.12812147133040996, 0.18334244335496463, 0.16612325119781945, 0.19344866382802817, 0.16387967957507754, 0.16401069064936624, 0.148527617565676, 0.11485597817358717, 0.09446547665562521, 0.11280610111601985, 0.1091003664112935, 0.14025359968142326, 0.16379654660420562, 0.11488119234016503, 0.1547375121585126, 0.10881539322480627, 0.2256927301812136, 0.2618350833080778, 0.21916980344079218, 0.28421461713985174, 0.2733962273531073, 0.24385381338041057, 0.25249463747422096, 0.3430018656727257, 0.25268887653290917, 0.038516647429157835, 0.016633906275529076, 0.036046744049279544, 0.01304576383895606, 0.047097910307194124, 0.009023305716892582, 0.019566875263714034, 0.03037398409547254, 0.041416747222329686, 0.1557650061149325, 0.13340059403102755, 0.14539953094706348, 0.14956585377834652, 0.14539417016515432, 0.16635637187474495, 0.1614884336696708, 0.16078277350752213, 0.14281097172188706, 0.518243833201847, 0.4949008472195163, 0.5130611999571124, 0.5005575557012001, 0.465405798755715, 0.4512704531492099, 0.44498496858101866, 0.4909957828197433, 0.4886018713990826, 0.08008210404687577, 0.08175286292537587, 0.0913275739165218, 0.09390963892353643, 0.09624131085797671, 0.09079189027030188, 0.0806577592146499, 0.09580705361757313, 0.0749396089182901, 0.1264411884687492, 0.16006980317114872, 0.13332365850523986, 0.1742895191097914, 0.1425087632826857, 0.12988358042975434, 0.20650860312783914, 0.25186756872087834, 0.24685940178057264, 0.2852147625048541, 0.23678072648750992, 0.283300960609004, 0.24090379531089678, 0.2686478363921073, 0.2596528418834061, 0.27678675412401943, 0.28835187564308606, 0.2610473875217918, 0.2064148531149459, 0.2197705733619163, 0.2028927460322154, 0.15857818439706428, 0.1781676603227692, 0.21520799715352534, 0.21902864564389013, 0.23811450009538748, 0.20999935221447785, 0.17195882218756797, 0.18590719257944244, 0.17396684697688813, 0.175459226376794, 0.17498972152193615, 0.17120021704649613, 0.18388096703127266, 0.20651239831295243, 0.17234590593579036, 0.17862538948000983, 0.17723693856361045, 0.17851734073111913, 0.17733369427591184, 0.17035705915493615, 0.1754275003435034, 0.18462518332747813, 0.17257170831555635, 0.1819130930004087, 0.15441366685699376, 0.5930000609813011, 0.16114946135267127, 0.67993326404798, 0.18240899927733456, 0.1712534415370166, 0.16168838923363016, 0.6251023075375302, 0.15665986522352526, 0.3696132778816288, 0.18604381689533633, 0.4186517278845856, 0.16954610728480768, 0.185106464992549, 0.18851786021644956, 0.6130852358923002, 0.11856349411908884, 0.19561501545655824, 0.1741302407869233, 0.18445615340179666, 0.19638611445895227, 0.16239094520678576, 0.1817931196197473, 0.17836460707015955, 0.17952941504306652, 0.17918277915619873, 0.19092440509303654, 0.06176735023686253, 0.06362447757081813, 0.06700834884828255, 0.07853241043537096, 0.07206416195586285, 0.07397304229091883, 0.06278570552600937, 0.06643203004793008, 0.07226890237875827]}, "mutation_prompt": null}
{"id": "60e7dd02-b28c-4ba4-997b-1b74caabd5f2", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        adaptive_CR = self.CR * (1 - self.current_iteration / self.budget)  # Adaptive crossover\n        crossover_mask = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget)\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < func(individual):\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Incorporate adaptive crossover probability based on iteration progress to balance exploration and exploitation.", "configspace": "", "generation": 6, "fitness": 0.2319160409746644, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "d9c72548-9b53-4bca-b0d9-9f75ecacf4e5", "metadata": {"aucs": [0.6164571292167688, 0.597494041030981, 0.6600136984759825, 0.6247579506323844, 0.6337788714604966, 0.6196237299769131, 0.6489157814022334, 0.6101820116615462, 0.634765415250806, 0.3357374348544624, 0.40018345760299057, 0.3405369685853482, 0.3867368458988678, 0.3414437465995831, 0.33068135436295343, 0.38167638334155995, 0.32545585702898006, 0.27547770384095516, 0.11006754621793113, 0.09509971872813894, 0.09873577669483946, 0.1250821586361982, 0.09657842672553074, 0.10314124465615371, 0.08797930630022488, 0.12018507505823217, 0.09692972356458862, 0.09813744539234537, 0.09612289583676115, 0.10194521027447023, 0.0913014131427562, 0.10300077531351015, 0.09831484211225561, 0.09898746459102037, 0.10374110990629781, 0.09966559170920919, 0.9417992325701852, 0.882800151162893, 0.9232782999239426, 0.9180907870126074, 0.9207656381679998, 0.8627979683567303, 0.8894378583898168, 0.8494466635094816, 0.927069179862039, 0.24757075347647162, 0.26049179715267523, 0.3032666915973803, 0.2676627011596896, 0.27757477042282985, 0.22560622120670526, 0.26220061523349436, 0.2872988110957334, 0.28121743397501464, 0.479454127002249, 0.23457933368652018, 0.2639335797778898, 0.5453000697905297, 0.4778854053402418, 0.5557255826981713, 0.37811338405657946, 0.4201422488660851, 0.36121962944281305, 0.11360895380044878, 0.14245082167701983, 0.15334805169167431, 0.15681250201618369, 0.1697648476190332, 0.15430012528566672, 0.1358398767481762, 0.15078473914284263, 0.14128231663828228, 0.16198671207732862, 0.1492838495188984, 0.119192324317836, 0.14094923356070443, 0.12547438326358062, 0.14483305173042027, 0.11826989385670494, 0.11158432972398291, 0.1255234467947428, 0.030292540263424095, 0.02329874599805648, 0.008185401544298698, 0.05399440395186106, 0.04992356731623071, 0.02540546695610979, 0.027713299714543838, 0.034374303583441734, 0.02100717746689984, 0.0855066002548509, 0.1379626032782999, 0.14654655797981253, 0.16703748507420346, 0.14183509120418347, 0.1221363985279943, 0.17155270327549876, 0.20002403106956657, 0.15894983159563747, 9.999999999998899e-05, 0.0002038633141259183, 9.999999999998899e-05, 9.999999999998899e-05, 0.01876188977280402, 9.999999999998899e-05, 9.999999999998899e-05, 0.00032716492833495536, 0.03219218573143079, 0.10458026371086726, 0.12101405392662057, 0.1052615720335136, 0.12258775651684373, 0.11767432627699259, 0.1582826338321789, 0.09307421439166752, 0.12420917372562013, 0.10206358863294973, 0.4154427091182197, 0.42651356839400323, 0.44697818373862397, 0.42285832408330803, 0.46967753331748074, 0.44106017962928523, 0.41317300369377097, 0.44526170528898623, 0.45008824142705206, 0.07112384947485095, 0.0891681951002401, 0.0788927825680974, 0.09145040476387789, 0.09716992918643896, 0.09561501167206155, 0.07142566302651954, 0.08935082014113083, 0.08766239936585007, 0.13139574972388124, 0.16198259615719834, 0.14611328371427446, 0.1485911144074582, 0.16223582688412896, 0.12461299422245631, 0.1645987425831349, 0.22618125266612266, 0.18256807127221086, 0.25113567241130785, 0.2657412562223217, 0.24562196929688762, 0.230557726828709, 0.20096055187796724, 0.2590001276270476, 0.2830088931385384, 0.27916868490494595, 0.2829299156372579, 0.1652088203246176, 0.1983032632310494, 0.1950967651628217, 0.19194259094625832, 0.17483721638993688, 0.1988324869253798, 0.2022856733913303, 0.19579107963646314, 0.17516651102422243, 0.16907513575797328, 0.17260853891870487, 0.1787342683570856, 0.17962047375407042, 0.18232694440270703, 0.1900497001811261, 0.18385955204167492, 0.18394201634372598, 0.18319286091332598, 0.18809269359484737, 0.1780883161484369, 0.18467916330836398, 0.1903524257900573, 0.16698550032291182, 0.18144305731327137, 0.17072270062766415, 0.17741657624550722, 0.1845140745849847, 0.5432043567832687, 0.1626441356657815, 0.1635228679615791, 0.1752973854612826, 0.5363548241548539, 0.17196745726506557, 0.2521897071537883, 0.17168443156473734, 0.13945320879354417, 0.1600493336196841, 0.15770683236640248, 0.15793979180011897, 0.37830792122588874, 0.16704182508133547, 0.19246382266373063, 0.11984922886757376, 0.48795148116684417, 0.20376233586095238, 0.17557207332836133, 0.17364569801016727, 0.19638611445895227, 0.19989264461418965, 0.19001659136852955, 0.1870210086399764, 0.17251661123731588, 0.18753725211580763, 0.18350110037625522, 0.07566453704264697, 0.06071766906001119, 0.07555580592738165, 0.07104821902313996, 0.06150116147226237, 0.07658889690968607, 0.07992813353897965, 0.06795881548524974, 0.06950483492456438]}, "mutation_prompt": null}
{"id": "ac1facb1-1deb-4da9-bbfe-ba099040046f", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget)\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < func(individual):\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Improve exploration by randomly readjusting the mutation factor (F) during iterations.", "configspace": "", "generation": 7, "fitness": 0.2842643627500391, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.21.", "error": "", "parent_id": "d9c72548-9b53-4bca-b0d9-9f75ecacf4e5", "metadata": {"aucs": [0.6640899726467635, 0.6719200176716749, 0.6493680478610613, 0.7120234001917676, 0.6671412575702422, 0.7169467108113863, 0.6945924826437897, 0.6593981064129727, 0.6565916845179249, 0.3788887444211537, 0.40587730800464794, 0.4465277728632219, 0.4391164541034135, 0.3739441954819135, 0.4153658683281688, 0.40221913599120185, 0.39959186657488677, 0.4304671117737684, 0.1264788916010564, 0.12688989893623404, 0.09764729587517706, 0.08305972565748776, 0.08343559774540155, 0.10019344395912344, 0.09754112720251706, 0.09163190169036972, 0.0945912278235812, 0.0951329981534409, 0.09193687874828393, 0.10095560552095284, 0.09592519157147594, 0.09148404972619739, 0.0827066072459205, 0.08819441537734274, 0.09662547715673186, 0.12061877503667673, 0.8874408573316453, 0.900457896086472, 0.874799849383448, 0.8679799820620756, 0.9379401933251158, 0.893032586328209, 0.9360756280836657, 0.9042614618433713, 0.9178721235534295, 0.31995049126776764, 0.30296417673709153, 0.3457748080231976, 0.3078363279688737, 0.3313939418697527, 0.3267895700663572, 0.31927453924277793, 0.3307344885102188, 0.32777245808031086, 0.5630446983608635, 0.4311139266602021, 0.6823576720668578, 0.5909987673076568, 0.6824524269816884, 0.6682393606681696, 0.5103740552125362, 0.6229966705958205, 0.7020679085588271, 0.15318430450046439, 0.18917091326181223, 0.19498188258718452, 0.17802174278823646, 0.21094098089637414, 0.17421153943268897, 0.2246822677029845, 0.17670331579005472, 0.16880782444258036, 0.15345264678309245, 0.24892723147624185, 0.18354741002202046, 0.18483163368679267, 0.20971174663037317, 0.20583336431847332, 0.14566982863025313, 0.18665118675505799, 0.21012220812325022, 0.2135317333443525, 0.15282745476759796, 0.22682430064067216, 0.2006027754119204, 0.18371300421903058, 0.20173012865331952, 0.19364397718038462, 0.16057434435041018, 0.1228145896252083, 0.26425236201261926, 0.32116344679150133, 0.29097843091593834, 0.3260524024693664, 0.2725560877471267, 0.33128040234124934, 0.3081659953870888, 0.31589148954740354, 0.27763657839705824, 0.03507456041503809, 0.05519151613471096, 0.08608204867437286, 0.05414631917023993, 0.07782767459645823, 0.07444761806458444, 0.06051386392409752, 0.06292920596545049, 0.0996960671601439, 0.18013911459511878, 0.14868796916871907, 0.21604546095742339, 0.18537280601393258, 0.1929516631433319, 0.19915293100180154, 0.2148376230899881, 0.17740402672346933, 0.18791142894718682, 0.5023557995663916, 0.5210123689857424, 0.5054304024874626, 0.5396046955620173, 0.5136971663338883, 0.5116940359768224, 0.5178774447132246, 0.5483223034375682, 0.47955714751107026, 0.08675424365638229, 0.07932256390594172, 0.08878948251428487, 0.07835314147021455, 0.07948861299438559, 0.07962131357562086, 0.07939376509149298, 0.10656532557817577, 0.09862322136775525, 0.2183479702221609, 0.14408272176016856, 0.1286177103550754, 0.14588323039471163, 0.1860597266139684, 0.18228987600276136, 0.12239440481419939, 0.13352633926674462, 0.13970303371987325, 0.28982255921596856, 0.30740995891347944, 0.29910422804208736, 0.2714476106075401, 0.2776003449614174, 0.24378362357661365, 0.3267773660326174, 0.32396611692735466, 0.29172928831586686, 0.20676822492899105, 0.21622186104572627, 0.23453730228775505, 0.2402169177483825, 0.22089263276018467, 0.22122963272216534, 0.23358344505185713, 0.2314529029796919, 0.27234780982296647, 0.18527497477303745, 0.18985528744408975, 0.1776536175309722, 0.17831303038641833, 0.1639178458774737, 0.18321190867733317, 0.19497329736092472, 0.18242770034748634, 0.18062693155747178, 0.17053660995747633, 0.22352757587380756, 0.194826824068433, 0.2612917060119886, 0.17823295119279192, 0.18730906970440353, 0.17489091752712116, 0.18203032136840847, 0.19142837222337417, 0.18527782944595605, 0.1451283069816458, 0.15048440392389506, 0.1728052037466834, 0.1824761047495671, 0.5312209677391905, 0.4984028110369232, 0.5144096370061654, 0.4230865361421021, 0.6402990702545392, 0.18634103202479235, 0.6436369637957756, 0.525601646308069, 0.5738720608224043, 0.19394593507826674, 0.10876777980174723, 0.207115223892125, 0.1481663470061887, 0.18090841399698832, 0.19057834511048521, 0.1864472074503828, 0.1985864759109821, 0.19830951722087298, 0.16885339121985576, 0.17308490432304136, 0.19197299604981177, 0.17476926746526367, 0.07774698657104184, 0.08835805665080221, 0.06142648039329013, 0.06917831167234001, 0.0678599893492432, 0.08568649665094563, 0.06964795540626578, 0.07943646827281903, 0.07340487238561111]}, "mutation_prompt": null}
{"id": "583ab490-ee0a-401d-a3e0-6c14f491e7d3", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = np.random.uniform(0.7, 1.0)  # Dynamic crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget)\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < func(individual):\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Refine the exploration strategy by dynamically adjusting the crossover probability.", "configspace": "", "generation": 8, "fitness": 0.2746887046652844, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "ac1facb1-1deb-4da9-bbfe-ba099040046f", "metadata": {"aucs": [0.685512941460156, 0.6815574568120019, 0.6828781048479038, 0.6766263570095234, 0.6911630854635493, 0.6699031622732239, 0.6769841330309737, 0.6716191960172018, 0.6537256367469892, 0.3999213361897117, 0.4025769635587816, 0.40044413709568316, 0.38498103240536286, 0.4192208421958168, 0.43716351882498394, 0.43701491743406307, 0.3390336982472256, 0.45196865442998424, 0.1150221330528386, 0.10683200616771249, 0.08816803235250337, 0.09072289217878371, 0.10048626905517066, 0.09506613156547061, 0.11549475007953003, 0.10082850443479874, 0.11248267310718041, 0.13092005727883804, 0.11127733031189269, 0.09018125397673105, 0.11830832808679947, 0.10236821050703293, 0.10120549089846231, 0.094642806773371, 0.10640064958663986, 0.09793684958587623, 0.929622233050226, 0.8573867234861867, 0.9192539597107355, 0.9499988582764887, 0.9243729937973802, 0.9103748518236036, 0.9564135468119404, 0.8737161864118781, 0.9144502077056752, 0.30097883226787037, 0.310201312494611, 0.320575675098297, 0.30861817101173594, 0.2877625773666659, 0.2977684217668317, 0.3381588454281559, 0.3146371570028521, 0.25132832505171787, 0.6290619206637591, 0.46770499860833303, 0.5038320001105858, 0.4842755796599124, 0.5507874816007488, 0.5897120918491998, 0.6612348647259649, 0.5435265841658536, 0.6739292519980266, 0.2751283467725797, 0.31257198055619817, 0.1866513066804808, 0.19132159398974402, 0.1693578486600441, 0.19273327106357763, 0.21016002379317145, 0.2181118986749948, 0.15318847649892176, 0.27694992591900913, 0.16756022525195513, 0.1626269424459228, 0.19602860090877783, 0.14801270861493498, 0.16107846242968515, 0.16851552971341166, 0.18242279383463977, 0.2109469090194669, 0.16349311646856457, 0.05087166402349197, 0.13329185968922597, 0.0783956446684615, 0.20024415447539234, 0.12137200697947736, 0.16174167218493107, 0.12010611906031732, 0.16792202430518233, 0.2642894205439962, 0.2436562150222631, 0.2988624782048783, 0.24286530509314574, 0.2344347128567461, 0.26076261566059233, 0.22512652530014887, 0.2781565354304423, 0.23601158018292057, 0.040918430409973894, 0.03122931617850777, 0.03623192996862068, 0.07066183777652646, 0.04454046856805549, 0.045545378779808354, 0.0833095174658447, 0.05577377727994515, 0.07433244091376234, 0.1717301915807602, 0.14125415933255603, 0.17317493890102542, 0.20789733435631297, 0.15524152429123061, 0.15936382410334005, 0.19233262107018112, 0.191988043726386, 0.15820094051089673, 0.4698183883832854, 0.5693714749742604, 0.5695596918482952, 0.5090238636273743, 0.511254409901312, 0.5161457844080151, 0.5070152461667273, 0.5011290372637552, 0.47380381678954975, 0.07880594769502203, 0.08859088026825102, 0.07281662600068428, 0.09226527011157393, 0.08049144704591438, 0.08135942436543753, 0.08837209060035056, 0.09133332019009655, 0.09355476345740932, 0.1256554049075823, 0.11470905487067828, 0.120794213530791, 0.12238359732433657, 0.19321210979389658, 0.16723579149626489, 0.13488073983048998, 0.18011008234584847, 0.13520871050890526, 0.2786339468783373, 0.2824065873177044, 0.31498467177432454, 0.2857003935028508, 0.2514166583301475, 0.26798143631842053, 0.29599756986671444, 0.30989171378092306, 0.3036733961185095, 0.22281247046713137, 0.20386190855129382, 0.22340864258552684, 0.22006486694281968, 0.22002869093498756, 0.1796636012688979, 0.22181685272005025, 0.23537369140387276, 0.2523487024702207, 0.1835797733543888, 0.19491975502960213, 0.1845311521354086, 0.17962143855144763, 0.18366398263590522, 0.19500574708005525, 0.23276447599002925, 0.19242503657033172, 0.18213007431444284, 0.18176120179663635, 0.20981841103771526, 0.22832528813135178, 0.25742964321664086, 0.17254433659358515, 0.21173844071087633, 0.1703336763538318, 0.18085574044243247, 0.17318246577636287, 0.1579110819736005, 0.5765292137020828, 0.16010012814517827, 0.16401741065094189, 0.18152487435835707, 0.17578606895298676, 0.6404754641835431, 0.16270611860551254, 0.5305018462378445, 0.1621416647117141, 0.19252795243351506, 0.1891420801941016, 0.6594117164407066, 0.3662970058183662, 0.5240937880990558, 0.19586192319823625, 0.2090596011179332, 0.19124392486818476, 0.20132252675368711, 0.17533080499923526, 0.17386958418356735, 0.17125730850911625, 0.18167134794251494, 0.18061100333607394, 0.19764261018769236, 0.18766512350163012, 0.17592588123701802, 0.0756844628343224, 0.06581696725981323, 0.06367290779059365, 0.07575903952943186, 0.0715657591848945, 0.07679180560033605, 0.08295346282926752, 0.06726053862541426, 0.08600921586564558]}, "mutation_prompt": null}
{"id": "bd17f3d9-0f42-4a1a-a93e-26d9d63d05ec", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Improve local exploitation by dynamically adjusting perturbation size based on fitness improvement ratio.", "configspace": "", "generation": 9, "fitness": 0.29241565334333297, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.22.", "error": "", "parent_id": "ac1facb1-1deb-4da9-bbfe-ba099040046f", "metadata": {"aucs": [0.6395690930186543, 0.6815869002074451, 0.688839899224178, 0.6919859483834634, 0.6753933957200691, 0.7291233126582346, 0.709520269730876, 0.6811349670743859, 0.667453929159065, 0.44868215640823883, 0.45073228453308045, 0.3848277371060109, 0.49098252728562175, 0.4014824909184983, 0.4343131605972489, 0.39671996582088775, 0.44279173216128, 0.4336922568802799, 0.10111800026944462, 0.09333710890979752, 0.10756321969521254, 0.12273413085660323, 0.128597448554174, 0.10072491010015894, 0.0952571845902348, 0.11736934023604173, 0.09214833640415565, 0.09313592516184688, 0.07838269924731434, 0.08837957613202996, 0.07463173800757683, 0.0981865089401508, 0.09610862953134669, 0.08933060238184842, 0.11541024659904264, 0.09408830499868004, 0.970861648530517, 0.8708506450525079, 0.8679271876238679, 0.8667858819083551, 0.9378858516362558, 0.8987243492317012, 0.938265392888973, 0.9629581958526743, 0.9170493902722912, 0.313103788756677, 0.3296245437401347, 0.3536010606148777, 0.32899534519571627, 0.34429057703708466, 0.307884080876036, 0.3574546153318512, 0.3270483292661899, 0.3602191918043276, 0.5156497278973686, 0.6268235088719128, 0.5796618135321217, 0.63567983215377, 0.6456726160146204, 0.719515124404815, 0.5538150409773853, 0.6679529777931071, 0.5977995579600976, 0.18378436853656288, 0.177310173929229, 0.2811065328959572, 0.1710565480921441, 0.19153742884782554, 0.1749844798427126, 0.16522517743344634, 0.192347063960716, 0.19387237753514475, 0.11272557890976864, 0.1500594018014716, 0.14536706142772526, 0.14661228881089405, 0.22263765451716722, 0.20279595225821534, 0.21065979966050563, 0.1654582578562579, 0.20360337771595283, 0.18521974587402334, 0.16261210324699282, 0.1531101680532243, 0.16564480306952578, 0.1793230703522618, 0.1349580673006927, 0.1675806841530495, 0.20006654112626, 0.27064224896106603, 0.3158617038031193, 0.2760586155192639, 0.32439020571872035, 0.2897437402120421, 0.27107469081426727, 0.23090553823159166, 0.4333826248827487, 0.29057085983527864, 0.31960106826010737, 0.05907001568598258, 0.03589410813784122, 0.026895764800174637, 0.07205885456998218, 0.08892537497367758, 0.054718230006161495, 0.11551924407473002, 0.06778981446503307, 0.10412127810876792, 0.1620246146674995, 0.1582314486759142, 0.2019606118523828, 0.20299096641894243, 0.1903366395000613, 0.19373427516243868, 0.1964179650139284, 0.19293437555291326, 0.19081384500718612, 0.49593304446582465, 0.5129677480142756, 0.5327410452750319, 0.5077895264042127, 0.4926554170715849, 0.5531773042476944, 0.5392064863601254, 0.566014551524707, 0.5325463512640121, 0.09469723235448624, 0.08888644422102754, 0.10447973154961221, 0.09086707837517494, 0.09011878265029738, 0.07808804119221313, 0.07549120306266399, 0.0805161370709977, 0.0760055435998731, 0.16891413635241082, 0.18896897469821028, 0.11641508870928141, 0.12882557837480968, 0.14894385760222673, 0.16643463932074576, 0.21287059355240068, 0.20947991273185929, 0.12210558725495879, 0.3016110990430717, 0.2984812242199302, 0.30561061103083687, 0.29779028928296836, 0.282396733873987, 0.3120290439831591, 0.29632346812581134, 0.31738352676169457, 0.34810738669266617, 0.25283322802233266, 0.24535440203295011, 0.24538596968791448, 0.21485214943173414, 0.23347297027610747, 0.24278746109116656, 0.23447383809051625, 0.25613430282451133, 0.23103449392271214, 0.19430411874241915, 0.22088408271070492, 0.19072252543394275, 0.20407789946449262, 0.18798027413982754, 0.20442008700291825, 0.17382480885453455, 0.20402000789650732, 0.19608909159312515, 0.1809899224791951, 0.19610779416477342, 0.27435498410927395, 0.1888357584416116, 0.22860022256315382, 0.1747839770577404, 0.2376490006943458, 0.1826023824185441, 0.1643945322471343, 0.19151421957455228, 0.5662312272784311, 0.14609138462274296, 0.523414834753692, 0.18983269564637362, 0.17058057128956916, 0.16977043657186952, 0.6135429544981972, 0.46346951144992554, 0.58462767854275, 0.19135893395773385, 0.6313551494512681, 0.48899183443656624, 0.560009171917028, 0.19353206529844225, 0.2012071617723692, 0.15189309388719507, 0.6567506210316532, 0.20164501487305775, 0.2014391033860793, 0.19109021083068645, 0.20344582082097273, 0.18945989035183153, 0.17528567593384736, 0.1684407924426623, 0.19196856883022173, 0.18872337653566662, 0.07906145683351318, 0.06954995768880312, 0.07704561583154523, 0.07432921291612604, 0.07115671375780053, 0.06428258456961644, 0.07128080151172012, 0.06661521826335315, 0.07918021224505423]}, "mutation_prompt": null}
{"id": "f12f69ba-75c9-4f60-b90b-c0a7d95bb725", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        dynamic_factor = np.sqrt(self.budget / self.current_iteration)  # Introduced dynamic scaling\n        perturbation_size = 0.1 * dynamic_factor * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Enhance the exploration by introducing a dynamic scaling factor for the perturbation size during local search.", "configspace": "", "generation": 10, "fitness": 0.2833455180126092, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "bd17f3d9-0f42-4a1a-a93e-26d9d63d05ec", "metadata": {"aucs": [0.6214929359053307, 0.6454366399693094, 0.7267018200214643, 0.695859881614438, 0.6918926313238846, 0.7140179731198175, 0.6979206929147104, 0.7015099183432527, 0.7237234822315393, 0.3553628404420681, 0.43434266926625087, 0.41501381612126176, 0.367475598892406, 0.39912659054875255, 0.3953056210652176, 0.3995085700311809, 0.3931035440896673, 0.42253593617202045, 0.11273948100441145, 0.10921404850440308, 0.1025718892150298, 0.10283984783545441, 0.11242395814211892, 0.09994923528713373, 0.16091508928439457, 0.0949221598252199, 0.1086331386023579, 0.10015125871600061, 0.08963768081199874, 0.10210212541589991, 0.09414807132060521, 0.09077877323684302, 0.0965374548953516, 0.08472624367028658, 0.09196658422657655, 0.08750580828927745, 0.9340265670597209, 0.931857076776263, 0.949266729768862, 0.9282970172855548, 0.9744744999778059, 0.9339435872285096, 0.943351003573012, 0.927507018509699, 0.9384685729845794, 0.3175377347036048, 0.32550260630612415, 0.27993630370447764, 0.29907598966395277, 0.29703686175599286, 0.2790827586561043, 0.3564194878179895, 0.3002636070455681, 0.34022782731590184, 0.5383338715087476, 0.43501051809864666, 0.5849333186660537, 0.462625790976265, 0.5617794920700991, 0.529065791269343, 0.5284555033934786, 0.593432288643543, 0.5593149406322213, 0.16735723059584584, 0.20863975741576646, 0.22995911442249395, 0.1910085599260659, 0.16902984119213926, 0.1792496948820521, 0.2236162521312336, 0.18148236417612051, 0.19418936259969333, 0.11288954630441606, 0.11299491459659561, 0.10193788585433505, 0.20274223641531575, 0.21522506496817673, 0.14153614346970866, 0.2166258520359582, 0.18744054817221656, 0.16834539894190315, 0.13844688226317015, 0.164935129038441, 0.14427590027221504, 0.1671460463161487, 0.13003044391387142, 0.2016831134283813, 0.18892436535233725, 0.12902614615217767, 0.2254047405603049, 0.28022848499219044, 0.2275493210459293, 0.2599844297135572, 0.3199101344586722, 0.1386445267766676, 0.2676612813461856, 0.27377334358018357, 0.3649963984143245, 0.27090107346884995, 0.06233505851987298, 0.07365283502549813, 0.043609435769181415, 0.041216457320405464, 0.03924288787916319, 0.0534817280369263, 0.04805843204967675, 0.10266157586844005, 0.10940427097207461, 0.1857663134789569, 0.19893742498904976, 0.14686584486568355, 0.20679518927465856, 0.21190775007367746, 0.1873974561384414, 0.2142232613741224, 0.18874534688427913, 0.15162849072790485, 0.5107069858939265, 0.5464920056564713, 0.532779270433489, 0.5269855966534389, 0.5469032723123904, 0.5318907020935775, 0.5224000749344555, 0.5914078923718765, 0.5069631412989566, 0.10100709545049724, 0.0945534115260398, 0.08642178203621531, 0.09468573162254657, 0.0978445668239607, 0.085303670870429, 0.08866517437087296, 0.0820248797427433, 0.08123081287251588, 0.2250623124377965, 0.14349960494237568, 0.25521344435269155, 0.3438277472196798, 0.14030750568054495, 0.1243389778230114, 0.17103249668940845, 0.15159873321601114, 0.16515162151200125, 0.287414006808432, 0.29331792290754133, 0.2859235880032044, 0.2916653449610269, 0.28331965099990053, 0.28783162546836927, 0.31887552498472826, 0.31381284545613275, 0.31323116577647536, 0.22061722731410083, 0.23942082247319207, 0.22886302195912311, 0.23357479602226072, 0.23094880284540353, 0.23965680362369435, 0.2457191423408227, 0.24343119624176013, 0.24629517624130948, 0.17468537305922416, 0.20755205868070647, 0.1830187528381907, 0.19600124837334665, 0.171970836644201, 0.18277435691950716, 0.19762421726004153, 0.18528593802763393, 0.18055844932374132, 0.18330764465433258, 0.17427482159726138, 0.1782430121842281, 0.17638717690298544, 0.18847147731448521, 0.23885662738883384, 0.1741741833564754, 0.1723279185750224, 0.22007129201621978, 0.674549133442204, 0.7084535024561838, 0.5285259183552882, 0.175768809334513, 0.7244746594191296, 0.5005473215511055, 0.5469387402501489, 0.5292539019126373, 0.17951307943373396, 0.19228001193496025, 0.15995322793568723, 0.19872823910205017, 0.18798149523245278, 0.20135796846902954, 0.19142583610735608, 0.20403781464925286, 0.15350369024134547, 0.2079253533001505, 0.17813534485105842, 0.1712039539675776, 0.18364869655639882, 0.24280889767341418, 0.1845950285285637, 0.17705329705299355, 0.17630349675034918, 0.19579246259045224, 0.18051062249570082, 0.07174738206808706, 0.07614229152495178, 0.07322847835497448, 0.07325041604860238, 0.07415762796459113, 0.06458931043249283, 0.06632379322589188, 0.07634286982723881, 0.07873459311147968]}, "mutation_prompt": null}
{"id": "f34a23eb-8070-4e11-9c31-72e3cdd16a8e", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        normalized_improvement = (self.fitness.min() - current_fitness) / (abs(self.fitness.min()) + np.finfo(float).eps)\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else normalized_improvement)\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Enhance adaptive local search by adjusting perturbation size based on normalized fitness improvement.", "configspace": "", "generation": 11, "fitness": 0.27221616875776294, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.20.", "error": "", "parent_id": "bd17f3d9-0f42-4a1a-a93e-26d9d63d05ec", "metadata": {"aucs": [0.6284078918305328, 0.6685357496593375, 0.6619311268582526, 0.6414008083696976, 0.6501985763335063, 0.6713796732596136, 0.6520962228312809, 0.6783966315356618, 0.6197754570163001, 0.44853254098303796, 0.44517347668058516, 0.4305558490179715, 0.4270711892775352, 0.4339655431178536, 0.3959984107289829, 0.3878723804939206, 0.522836328275051, 0.4391353443175172, 0.09542179036973031, 0.09545976669883838, 0.1335732552656247, 0.09494117487176068, 0.1234966274559447, 0.10148078847076991, 0.08080722577200394, 0.08877862743089115, 0.08827014482122975, 0.08206059973049817, 0.07738692708833028, 0.0825342270372077, 0.07099181214687011, 0.08825620082480712, 0.07136191976804562, 0.08706569553914811, 0.08464790109425357, 0.0850150139938376, 0.9689755371180078, 0.7465125316907717, 0.9772584341596304, 0.8022179704422077, 0.8911473066265451, 0.9516924861017473, 0.9508878098465532, 0.8371713742396182, 0.8935882397457596, 0.27526549438393366, 0.2979682078127952, 0.32067907261168394, 0.29835665151651436, 0.28725084385031274, 0.31690420248151696, 0.29526921841139797, 0.3260816443840847, 0.3101432894256314, 0.5240509061328915, 0.5038916220464018, 0.5560797631188441, 0.5459863003975951, 0.5245993610911446, 0.6251122614783806, 0.5284099035899222, 0.6222201590482834, 0.5788735820399314, 0.13092646741506564, 0.16551689623622112, 0.20184437007415268, 0.14983028481396576, 0.16056945338202844, 0.2025224717050439, 0.22950718017428473, 0.1449572869528789, 0.18604517703554002, 0.1928493020420875, 0.09727901877057465, 0.12422525866024048, 0.19468103088211297, 0.1165023526370147, 0.1614695949340792, 0.1575425320422872, 0.1500444995939617, 0.29788759076442284, 0.19948967827550612, 0.16936311345586708, 0.20080549903167288, 0.13467126799091544, 0.1795504036568616, 0.1920642132756777, 0.20394777818324317, 0.16221400733499725, 0.17295585660068646, 0.3046375571818464, 0.29292651527279523, 0.3496573691296607, 0.3078813821856269, 0.28025645622687867, 0.3105861313056395, 0.34066756160267886, 0.3453993258241257, 0.30963382415138563, 0.056048882920025966, 0.039847740901279405, 0.0988875128305925, 0.06693557098842828, 0.06290081812054793, 0.10751693101888482, 0.04987005398087607, 0.07897180689390149, 0.06270420178168556, 0.20640607381533116, 0.20814657872966402, 0.19674408551431977, 0.1916940506971151, 0.20424392716448692, 0.20010936029243953, 0.17808906664307178, 0.20741409828692225, 0.16788492714503578, 0.48569327052588984, 0.5055229497080869, 0.5016151977413137, 0.4484432215072697, 0.5006508538716259, 0.4896699440734361, 0.5076078465144604, 0.511527786039499, 0.4946775358201869, 0.07916311069062454, 0.09104459435636514, 0.10067627149729053, 0.08712856404628733, 0.07513258862530037, 0.09510136239487188, 0.07632912652820201, 0.07711230912736844, 0.09125565619169629, 0.17338591072124088, 0.12426806536279278, 0.12235291278489535, 0.12876334068821194, 0.2427373003432367, 0.13748873839632048, 0.2164151318060552, 0.12017821636237225, 0.16424231741249673, 0.27480598038693627, 0.27140211951360615, 0.2874686883823655, 0.29145145870593225, 0.27507829448293974, 0.29537272569954887, 0.2822140012370902, 0.3013159841163974, 0.3035203052278075, 0.22958884505378852, 0.24186779735826136, 0.2088279513386022, 0.23648965871389915, 0.22176160880992335, 0.20776297776054975, 0.22870545060120362, 0.21327512270859716, 0.23715859642363213, 0.19404810971197162, 0.17782956767263036, 0.18755951373213509, 0.1932565053009201, 0.18787811516808084, 0.1788246026316046, 0.16350316273665122, 0.2060492451032313, 0.17794920057776742, 0.19776693224951825, 0.16836851630254768, 0.1860365204745792, 0.18315555013207307, 0.1691335109500991, 0.17036280632964995, 0.1751349685790583, 0.19472912985718804, 0.2271262052485601, 0.1715175627623301, 0.5116892013579697, 0.14652077735336078, 0.5889297662035728, 0.18975145227048662, 0.1828729937390784, 0.15271597220346955, 0.40940661700138403, 0.1580909921471101, 0.42993598002946876, 0.19649426549738258, 0.15484719700076965, 0.15898675102370052, 0.19335107458789258, 0.190778340175757, 0.20420546554176322, 0.15123073919281282, 0.5575728649457141, 0.18925769180788643, 0.1792137823428147, 0.18574909503314074, 0.16933522586271466, 0.18704446133438246, 0.17888676416020877, 0.1953585734822718, 0.17264762594782024, 0.262844078069972, 0.06983436713269386, 0.06747406153727775, 0.06600290298998557, 0.07163991932142488, 0.07536815130217656, 0.05885282510155376, 0.07653509508226397, 0.07508954027777326, 0.07696495615450438]}, "mutation_prompt": null}
{"id": "de68e553-6b9d-450c-82ee-3e197781080d", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Improve local exploitation by dynamically adjusting perturbation size based on fitness improvement ratio.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "bd17f3d9-0f42-4a1a-a93e-26d9d63d05ec", "metadata": {"aucs": [0.6395690930186543, 0.6815869002074451, 0.688839899224178, 0.6919859483834634, 0.6753933957200691, 0.7291233126582346, 0.709520269730876, 0.6811349670743859, 0.667453929159065, 0.44868215640823883, 0.45073228453308045, 0.3848277371060109, 0.49098252728562175, 0.4014824909184983, 0.4343131605972489, 0.39671996582088775, 0.44279173216128, 0.4336922568802799, 0.10111800026944462, 0.09333710890979752, 0.10756321969521254, 0.12273413085660323, 0.128597448554174, 0.10072491010015894, 0.0952571845902348, 0.11736934023604173, 0.09214833640415565, 0.09313592516184688, 0.07838269924731434, 0.08837957613202996, 0.07463173800757683, 0.0981865089401508, 0.09610862953134669, 0.08933060238184842, 0.11541024659904264, 0.09408830499868004, 0.970861648530517, 0.8708506450525079, 0.8679271876238679, 0.8667858819083551, 0.9378858516362558, 0.8987243492317012, 0.938265392888973, 0.9629581958526743, 0.9170493902722912, 0.313103788756677, 0.3296245437401347, 0.3536010606148777, 0.32899534519571627, 0.34429057703708466, 0.307884080876036, 0.3574546153318512, 0.3270483292661899, 0.3602191918043276, 0.5156497278973686, 0.6268235088719128, 0.5796618135321217, 0.63567983215377, 0.6456726160146204, 0.719515124404815, 0.5538150409773853, 0.6679529777931071, 0.5977995579600976, 0.18378436853656288, 0.177310173929229, 0.2811065328959572, 0.1710565480921441, 0.19153742884782554, 0.1749844798427126, 0.16522517743344634, 0.192347063960716, 0.19387237753514475, 0.11272557890976864, 0.1500594018014716, 0.14536706142772526, 0.14661228881089405, 0.22263765451716722, 0.20279595225821534, 0.21065979966050563, 0.1654582578562579, 0.20360337771595283, 0.18521974587402334, 0.16261210324699282, 0.1531101680532243, 0.16564480306952578, 0.1793230703522618, 0.1349580673006927, 0.1675806841530495, 0.20006654112626, 0.27064224896106603, 0.3158617038031193, 0.2760586155192639, 0.32439020571872035, 0.2897437402120421, 0.27107469081426727, 0.23090553823159166, 0.4333826248827487, 0.29057085983527864, 0.31960106826010737, 0.05907001568598258, 0.03589410813784122, 0.026895764800174637, 0.07205885456998218, 0.08892537497367758, 0.054718230006161495, 0.11551924407473002, 0.06778981446503307, 0.10412127810876792, 0.1620246146674995, 0.1582314486759142, 0.2019606118523828, 0.20299096641894243, 0.1903366395000613, 0.19373427516243868, 0.1964179650139284, 0.19293437555291326, 0.19081384500718612, 0.49593304446582465, 0.5129677480142756, 0.5327410452750319, 0.5077895264042127, 0.4926554170715849, 0.5531773042476944, 0.5392064863601254, 0.566014551524707, 0.5325463512640121, 0.09469723235448624, 0.08888644422102754, 0.10447973154961221, 0.09086707837517494, 0.09011878265029738, 0.07808804119221313, 0.07549120306266399, 0.0805161370709977, 0.0760055435998731, 0.16891413635241082, 0.18896897469821028, 0.11641508870928141, 0.12882557837480968, 0.14894385760222673, 0.16643463932074576, 0.21287059355240068, 0.20947991273185929, 0.12210558725495879, 0.3016110990430717, 0.2984812242199302, 0.30561061103083687, 0.29779028928296836, 0.282396733873987, 0.3120290439831591, 0.29632346812581134, 0.31738352676169457, 0.34810738669266617, 0.25283322802233266, 0.24535440203295011, 0.24538596968791448, 0.21485214943173414, 0.23347297027610747, 0.24278746109116656, 0.23447383809051625, 0.25613430282451133, 0.23103449392271214, 0.19430411874241915, 0.22088408271070492, 0.19072252543394275, 0.20407789946449262, 0.18798027413982754, 0.20442008700291825, 0.17382480885453455, 0.20402000789650732, 0.19608909159312515, 0.1809899224791951, 0.19610779416477342, 0.27435498410927395, 0.1888357584416116, 0.22860022256315382, 0.1747839770577404, 0.2376490006943458, 0.1826023824185441, 0.1643945322471343, 0.19151421957455228, 0.5662312272784311, 0.14609138462274296, 0.523414834753692, 0.18983269564637362, 0.17058057128956916, 0.16977043657186952, 0.6135429544981972, 0.46346951144992554, 0.58462767854275, 0.19135893395773385, 0.6313551494512681, 0.48899183443656624, 0.560009171917028, 0.19353206529844225, 0.2012071617723692, 0.15189309388719507, 0.6567506210316532, 0.20164501487305775, 0.2014391033860793, 0.19109021083068645, 0.20344582082097273, 0.18945989035183153, 0.17528567593384736, 0.1684407924426623, 0.19196856883022173, 0.18872337653566662, 0.07906145683351318, 0.06954995768880312, 0.07704561583154523, 0.07432921291612604, 0.07115671375780053, 0.06428258456961644, 0.07128080151172012, 0.06661521826335315, 0.07918021224505423]}, "mutation_prompt": null}
{"id": "8f278fb2-5ca6-41a0-bea1-514f384ba618", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Improve local exploitation by dynamically adjusting perturbation size based on fitness improvement ratio.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "bd17f3d9-0f42-4a1a-a93e-26d9d63d05ec", "metadata": {"aucs": [0.6395690930186543, 0.6815869002074451, 0.688839899224178, 0.6919859483834634, 0.6753933957200691, 0.7291233126582346, 0.709520269730876, 0.6811349670743859, 0.667453929159065, 0.44868215640823883, 0.45073228453308045, 0.3848277371060109, 0.49098252728562175, 0.4014824909184983, 0.4343131605972489, 0.39671996582088775, 0.44279173216128, 0.4336922568802799, 0.10111800026944462, 0.09333710890979752, 0.10756321969521254, 0.12273413085660323, 0.128597448554174, 0.10072491010015894, 0.0952571845902348, 0.11736934023604173, 0.09214833640415565, 0.09313592516184688, 0.07838269924731434, 0.08837957613202996, 0.07463173800757683, 0.0981865089401508, 0.09610862953134669, 0.08933060238184842, 0.11541024659904264, 0.09408830499868004, 0.970861648530517, 0.8708506450525079, 0.8679271876238679, 0.8667858819083551, 0.9378858516362558, 0.8987243492317012, 0.938265392888973, 0.9629581958526743, 0.9170493902722912, 0.313103788756677, 0.3296245437401347, 0.3536010606148777, 0.32899534519571627, 0.34429057703708466, 0.307884080876036, 0.3574546153318512, 0.3270483292661899, 0.3602191918043276, 0.5156497278973686, 0.6268235088719128, 0.5796618135321217, 0.63567983215377, 0.6456726160146204, 0.719515124404815, 0.5538150409773853, 0.6679529777931071, 0.5977995579600976, 0.18378436853656288, 0.177310173929229, 0.2811065328959572, 0.1710565480921441, 0.19153742884782554, 0.1749844798427126, 0.16522517743344634, 0.192347063960716, 0.19387237753514475, 0.11272557890976864, 0.1500594018014716, 0.14536706142772526, 0.14661228881089405, 0.22263765451716722, 0.20279595225821534, 0.21065979966050563, 0.1654582578562579, 0.20360337771595283, 0.18521974587402334, 0.16261210324699282, 0.1531101680532243, 0.16564480306952578, 0.1793230703522618, 0.1349580673006927, 0.1675806841530495, 0.20006654112626, 0.27064224896106603, 0.3158617038031193, 0.2760586155192639, 0.32439020571872035, 0.2897437402120421, 0.27107469081426727, 0.23090553823159166, 0.4333826248827487, 0.29057085983527864, 0.31960106826010737, 0.05907001568598258, 0.03589410813784122, 0.026895764800174637, 0.07205885456998218, 0.08892537497367758, 0.054718230006161495, 0.11551924407473002, 0.06778981446503307, 0.10412127810876792, 0.1620246146674995, 0.1582314486759142, 0.2019606118523828, 0.20299096641894243, 0.1903366395000613, 0.19373427516243868, 0.1964179650139284, 0.19293437555291326, 0.19081384500718612, 0.49593304446582465, 0.5129677480142756, 0.5327410452750319, 0.5077895264042127, 0.4926554170715849, 0.5531773042476944, 0.5392064863601254, 0.566014551524707, 0.5325463512640121, 0.09469723235448624, 0.08888644422102754, 0.10447973154961221, 0.09086707837517494, 0.09011878265029738, 0.07808804119221313, 0.07549120306266399, 0.0805161370709977, 0.0760055435998731, 0.16891413635241082, 0.18896897469821028, 0.11641508870928141, 0.12882557837480968, 0.14894385760222673, 0.16643463932074576, 0.21287059355240068, 0.20947991273185929, 0.12210558725495879, 0.3016110990430717, 0.2984812242199302, 0.30561061103083687, 0.29779028928296836, 0.282396733873987, 0.3120290439831591, 0.29632346812581134, 0.31738352676169457, 0.34810738669266617, 0.25283322802233266, 0.24535440203295011, 0.24538596968791448, 0.21485214943173414, 0.23347297027610747, 0.24278746109116656, 0.23447383809051625, 0.25613430282451133, 0.23103449392271214, 0.19430411874241915, 0.22088408271070492, 0.19072252543394275, 0.20407789946449262, 0.18798027413982754, 0.20442008700291825, 0.17382480885453455, 0.20402000789650732, 0.19608909159312515, 0.1809899224791951, 0.19610779416477342, 0.27435498410927395, 0.1888357584416116, 0.22860022256315382, 0.1747839770577404, 0.2376490006943458, 0.1826023824185441, 0.1643945322471343, 0.19151421957455228, 0.5662312272784311, 0.14609138462274296, 0.523414834753692, 0.18983269564637362, 0.17058057128956916, 0.16977043657186952, 0.6135429544981972, 0.46346951144992554, 0.58462767854275, 0.19135893395773385, 0.6313551494512681, 0.48899183443656624, 0.560009171917028, 0.19353206529844225, 0.2012071617723692, 0.15189309388719507, 0.6567506210316532, 0.20164501487305775, 0.2014391033860793, 0.19109021083068645, 0.20344582082097273, 0.18945989035183153, 0.17528567593384736, 0.1684407924426623, 0.19196856883022173, 0.18872337653566662, 0.07906145683351318, 0.06954995768880312, 0.07704561583154523, 0.07432921291612604, 0.07115671375780053, 0.06428258456961644, 0.07128080151172012, 0.06661521826335315, 0.07918021224505423]}, "mutation_prompt": null}
{"id": "47feb661-2425-45de-aebc-2a3c2f7ef8e8", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        diversity = np.std(self.population)\n        self.F = np.random.uniform(0.5, 1.0) * (1 + diversity / 10)  # Adjusted mutation factor with diversity\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Enhance exploration by dynamically scaling differential evolution mutation factor with population diversity.", "configspace": "", "generation": 14, "fitness": 0.23350433591180011, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "bd17f3d9-0f42-4a1a-a93e-26d9d63d05ec", "metadata": {"aucs": [0.5644318170991673, 0.5154410930781304, 0.49239157715019366, 0.4153395736984209, 0.5180286186270009, 0.48738488886066866, 0.5949545067636272, 0.5662055035413471, 0.6033354990270956, 0.29706001639125557, 0.3529696089950516, 0.32693694677175733, 0.26851551381167604, 0.2644781369547826, 0.27565016555046606, 0.21488137513500427, 0.26035689978160104, 0.2059074293100226, 0.07559220377610532, 0.08955647599380934, 0.08307567859315623, 0.08627054324143468, 0.10596185497127752, 0.09371730238175646, 0.08768566710159409, 0.10107368007082751, 0.09707909714595953, 0.08453398525731459, 0.07412489370425046, 0.08659693096432197, 0.07551769278053666, 0.0934610552467342, 0.10153196011841503, 0.0761349685850169, 0.0830170600149267, 0.10298846209794776, 0.984066182799539, 0.9130176584743476, 0.9157826670758811, 0.9403791427954138, 0.9511335831087117, 0.9600562181867865, 0.967800308609715, 0.9005034091952958, 0.990863402690783, 0.2630844187320772, 0.246553834896576, 0.24183808497573167, 0.22983485476399823, 0.2475186919074951, 0.2276223406968012, 0.2186830833762925, 0.2535360887194743, 0.2297779193366115, 0.3753820294154582, 0.5550767357074269, 0.4639307880820316, 0.3009414631931485, 0.4355092871808752, 0.23941628228656897, 0.48594603166052486, 0.5460885385843806, 0.4166616396819953, 0.1774434458018188, 0.17689280022202514, 0.12952227108568282, 0.1561322009000885, 0.1151660544904598, 0.13123761768132902, 0.1520334239523944, 0.15015988152870663, 0.22641357375488236, 0.16147136698993525, 0.1721518731327396, 0.09515796075399452, 0.2112377330747517, 0.1979543844889885, 0.20533996725021852, 0.20869104314092735, 0.28328172082775926, 0.19363587820250783, 0.07194369719187776, 0.07875836688746529, 0.07216955912639134, 0.10798698425397546, 0.06516945722427336, 0.039021663400788165, 0.07399660808557984, 0.10613034445448699, 0.12055013277886684, 0.22260220699710664, 0.16973940106145224, 0.16816440964786616, 0.16208728798221073, 0.16521648188535787, 0.12230318556220043, 0.18789389657879918, 0.25365472811915535, 0.08817948934992315, 0.004535219118873113, 0.019328354979202378, 0.0019268041912633427, 0.005628072396845152, 0.005187672017713307, 0.010185934127227125, 0.02399356925304874, 0.033731951641453595, 0.007429005420985235, 0.1233438722915029, 0.10574912115462154, 0.12325224755879938, 0.12565964726533563, 0.10320453260012585, 0.12937728725380349, 0.11085146684963243, 0.11355601725768538, 0.13383770414675278, 0.4199021339250718, 0.5034256710243434, 0.45653916884420065, 0.4412922137379188, 0.37871901542884256, 0.4533436026711666, 0.4333276622340214, 0.4287761128778339, 0.47464761712426806, 0.08063050921199033, 0.08397926334020978, 0.07006710028128471, 0.08429246752843611, 0.08182182730683019, 0.09184195979006404, 0.0915876777840684, 0.07760419710541477, 0.08458052139565675, 0.17774157353471542, 0.19741929148725645, 0.15636934593181973, 0.23798395269165262, 0.14856767926689662, 0.17995782618417, 0.15802522018565013, 0.1833856950466788, 0.155006040856712, 0.2627909934709737, 0.23874478254780085, 0.2582009971450637, 0.27795933586465926, 0.24240770087236452, 0.23438830739623906, 0.25385475973437344, 0.24388419529737215, 0.24543418867813593, 0.1937825938772778, 0.1965193125613286, 0.19087777481120005, 0.17270718405071261, 0.17562384637216366, 0.160294250905182, 0.20825108296122408, 0.21397652489555763, 0.18486129735628998, 0.17170158121382406, 0.18073316131173034, 0.18696628170189566, 0.16528834144236493, 0.17903149843069532, 0.19689083518270356, 0.18448950578962808, 0.17805862055640231, 0.17415581953418824, 0.16881046022339907, 0.16382225176836251, 0.19375575046005655, 0.1722318185539642, 0.18041860597991888, 0.18111886027001345, 0.19036759981476636, 0.16512453013942885, 0.1852703746460631, 0.15419393643721813, 0.18901039339396675, 0.15561923215058415, 0.1828810053906259, 0.1725305567596206, 0.5382130014600297, 0.5547612103912146, 0.15218959493934603, 0.15537492008307685, 0.20660992514001397, 0.43810689030073036, 0.38877669596168996, 0.1816925626898621, 0.13835586136461875, 0.5163805046527359, 0.20435804978583072, 0.20292280990342793, 0.14550509272762502, 0.1840856633533675, 0.1857245183404863, 0.20413272456990572, 0.20699573104581825, 0.17959777270301636, 0.1707363380106659, 0.16940831423368508, 0.24804962788870866, 0.18494408131914297, 0.060716643578427654, 0.06869701938094874, 0.06450273293415942, 0.08324631452803499, 0.058505385061255355, 0.06301841674554709, 0.06592107366928135, 0.06476786389895772, 0.06931077342225145]}, "mutation_prompt": null}
{"id": "c0e6b86c-b58f-4a31-b90c-b0ab9ba3b401", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = np.random.uniform(0.7, 1.0)  # Dynamically adjust crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Enhance mutation diversity by dynamically adjusting the crossover probability during the search process.", "configspace": "", "generation": 15, "fitness": 0.27848413417536333, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.21.", "error": "", "parent_id": "bd17f3d9-0f42-4a1a-a93e-26d9d63d05ec", "metadata": {"aucs": [0.641241896510898, 0.6771766036293173, 0.6641040225130445, 0.69929739479904, 0.6732977057423912, 0.7131135215754592, 0.6862225370456119, 0.6875787822417156, 0.6775684161309237, 0.38521880951172327, 0.4412537250540729, 0.4727403859107232, 0.40163042958226325, 0.446427296327381, 0.3588911999019554, 0.38831257671070574, 0.41072685678492393, 0.45454034552398226, 0.103467693519253, 0.10699802541097758, 0.09321960208827618, 0.09622978373434177, 0.12577228355279657, 0.1280311198613594, 0.09565030017997489, 0.0983437367801211, 0.09892110564790724, 0.10185635216799727, 0.10461713105688886, 0.09800609245367564, 0.09355088096720632, 0.10563983031709945, 0.0925193035772901, 0.10065255106125004, 0.09331623007447853, 0.10250366168400016, 0.9066083326820049, 0.8747275684327064, 0.9158857871662466, 0.9461373760904463, 0.9244566509902488, 0.9103150723734542, 0.8682235553866477, 0.906000453944762, 0.9342908145705078, 0.29228512780509897, 0.3149092210108282, 0.3082642826686466, 0.33092162805780445, 0.3263810694570388, 0.33510272217597903, 0.33668759513256086, 0.30953799820122074, 0.3094501080997081, 0.6713469704331905, 0.5650920185168933, 0.6941365006259965, 0.6365185638465355, 0.6574874238535054, 0.650830579044415, 0.5217019939884529, 0.6468612640320484, 0.5347029608883098, 0.18230273361426597, 0.17459384052976024, 0.2725630628768867, 0.207977483226378, 0.2254304935683178, 0.1952434312270197, 0.20853576265158635, 0.2534543964365502, 0.20366269801334058, 0.19617423620781826, 0.2551302261856617, 0.17297731155949392, 0.17364535161515782, 0.29238858540068025, 0.17753621668922914, 0.131323867735463, 0.20408221345844224, 0.30591747702380057, 0.09574858425675936, 0.1269633814351533, 0.15200148778718936, 0.13327307942066258, 0.10665739051933487, 0.1577343781188294, 0.12078334050805373, 0.14912095617151622, 0.15535308443191664, 0.2004955158358943, 0.20579497991998952, 0.21763147990481846, 0.17555165270374562, 0.16289235858997142, 0.24051635987996345, 0.25567627863152753, 0.276714056816562, 0.2712461775346291, 0.05366504760587154, 0.042724619642759754, 0.07692428164693843, 0.06859217226113956, 0.05343591115215918, 0.0645859981605108, 0.09778655841209583, 0.024202087961306296, 0.07933134109167606, 0.151595513029526, 0.15402447505529493, 0.20335172968746706, 0.18878356847626376, 0.14830467204399045, 0.17327060134565564, 0.1515581069338594, 0.1675720043151554, 0.13970742727410745, 0.4755489532299624, 0.5017355327825956, 0.5231820245639032, 0.4897102130691091, 0.5162367746549892, 0.5110733552723203, 0.5000484669532602, 0.4645964998258131, 0.479714004335272, 0.09439010369567602, 0.08106030477189397, 0.07760899931543408, 0.10430601863385092, 0.08753661860349726, 0.08390025383024335, 0.07959273279595869, 0.0873528818899163, 0.10552892467865371, 0.17893280540770795, 0.13589253647948374, 0.1401765669647701, 0.1303184637078597, 0.22430093859546474, 0.1647308840845515, 0.14225493192106664, 0.13461929525457494, 0.14740313514532266, 0.3052189888153515, 0.2817428667110923, 0.308042733840323, 0.3199538067596124, 0.2869990621731304, 0.25802995876901225, 0.30651868531420834, 0.30199322330619593, 0.2579824099039917, 0.19142528558780159, 0.2257758478966314, 0.22307132868615276, 0.2191268696150378, 0.2236687935004653, 0.22275291095366834, 0.240986588778917, 0.25853078195556733, 0.2463704923440876, 0.1935426290100979, 0.18935028435758516, 0.17031465456444816, 0.18713123307640622, 0.18434115874626877, 0.1704505086900293, 0.17449334040786035, 0.19482445220078737, 0.1736926054116047, 0.19424601521465212, 0.18980128008666453, 0.1784976391446036, 0.19673719435411374, 0.16387020912602346, 0.17206280781243843, 0.1826706529846751, 0.1781756669095994, 0.18468205422804662, 0.4932403525411546, 0.576754280543297, 0.14768139222548637, 0.6337179939571097, 0.1788958296497185, 0.1761978786748436, 0.6021296114086336, 0.19299601347345308, 0.44598928878397415, 0.16208805511352298, 0.1930568866246697, 0.1594446068055091, 0.5101892515011093, 0.37810499828258803, 0.4133396949970892, 0.1010541356462854, 0.20682641024964254, 0.19935610190712583, 0.17443586427851387, 0.19482347917071252, 0.17562521075479598, 0.1913767812497834, 0.17605692647019244, 0.18685543412105676, 0.18017598213355046, 0.18445711549484944, 0.18498986343500723, 0.07276200196863014, 0.08599859014145828, 0.08429175511425924, 0.08412365451739812, 0.06884834816588103, 0.07158360102610928, 0.07856982683772551, 0.07321820525639411, 0.0704784419682084]}, "mutation_prompt": null}
{"id": "6f0f87ca-6231-4845-8d3d-2f80ddba541d", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n        stagnation_threshold = 100\n        last_best_fitness = np.inf\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations % stagnation_threshold == 0:\n                    current_best_fitness = np.min(self.fitness)\n                    if current_best_fitness >= last_best_fitness:\n                        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                        self.fitness = np.array([func(ind) for ind in self.population])\n                        evaluations += self.population_size  # Account for the new evaluations\n                    last_best_fitness = current_best_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Enhance diversity by introducing a random restart mechanism when improvement stagnates.", "configspace": "", "generation": 16, "fitness": 0.17946775887719588, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": "bd17f3d9-0f42-4a1a-a93e-26d9d63d05ec", "metadata": {"aucs": [0.3845277308541285, 0.5308857835257237, 0.40326967774320843, 0.4242730994635766, 0.44833657848957786, 0.533951348996029, 0.617722328572605, 0.49853211565034816, 0.5218547708487122, 0.1364821453280214, 0.17076281219556733, 0.07448914927923012, 0.2243540367171769, 0.1047622110194465, 0.33458305917294306, 0.19723380410996683, 0.2581758101189858, 0.17595181835573148, 0.0763729463363928, 0.06976273114450704, 0.06297030565449635, 0.08074800151812056, 0.07400585047794561, 0.06343973691446203, 0.08531583365943207, 0.07286584080890335, 0.06505002295958806, 0.050068715000039066, 0.04469237071091303, 0.06571671632471754, 0.07388256566636431, 0.0752592238658315, 0.06833698684685474, 0.06424771715523026, 0.054448771996123524, 0.062487720235098854, 0.970861648530517, 0.8224450882485144, 0.8679271876238679, 0.8667858819083551, 0.9378858516362558, 0.8987243492317012, 0.938265392888973, 0.9629581958526743, 0.643172251338894, 0.1907673232280207, 0.16582040341239968, 0.1670516971655026, 0.1679734086054827, 0.23977268482616687, 0.11646614562872015, 0.21201451318520126, 0.18253103089723655, 0.17998533994050503, 0.13996176050260833, 0.2079017321947012, 0.267989830717688, 0.245760830589424, 0.2052471440383511, 0.197767353335618, 0.1896655190713581, 0.21227267286523333, 0.33113399579275815, 0.11016157740493071, 0.15913016623802856, 0.14078525923663765, 0.12497451098290346, 0.12774155444172686, 0.16128232458071778, 0.16522517743344634, 0.07761474993680584, 0.13622041940774288, 0.1348244380514605, 0.10109261452746543, 0.11440943898791378, 0.10397361766188151, 0.12479157373471295, 0.10820749941775631, 0.13019561314779127, 0.07348884796240363, 0.05527143419699532, 0.03247719670549809, 9.999999999998899e-05, 0.03517912420251146, 9.999999999998899e-05, 9.999999999998899e-05, 0.004795480990249623, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08019334449487192, 0.06553740645495876, 0.05576057019223013, 0.07255492646958428, 0.04465060746966498, 0.06147366705929924, 0.09014974780920215, 0.05683868387206481, 0.12646655312458555, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004932857754128217, 9.999999999998899e-05, 9.999999999998899e-05, 0.06368661169052736, 0.08795703191679438, 0.1064779805974988, 0.07258721876915131, 0.06557281391606451, 0.09974240757344655, 0.06871341641392359, 0.04238852289671591, 0.11858355813340926, 0.3811289962684147, 0.2951891887620903, 0.40749732047436393, 0.3982323770374637, 0.31568680112896186, 0.38455512589427354, 0.22937079234101132, 0.3675367351680964, 0.4229881820439657, 0.06321637327203844, 0.07084917172706795, 0.06334572194481702, 0.06901601791489431, 0.06768486057783318, 0.058306070856448455, 0.06979602835681475, 0.07878624357968533, 0.06674500886237633, 0.17772685285535805, 0.13045234527654992, 0.12800651599059798, 0.12558596024074997, 0.13268951608180957, 0.13113879881095036, 0.18441424647211724, 0.11855578337981154, 0.11943663598509868, 0.1993434338506258, 0.1724180879905911, 0.20301749327046126, 0.18882108770925354, 0.19473415907615588, 0.1800541350523508, 0.18888569472549266, 0.20898952949259142, 0.18227516680132216, 0.1697425535600916, 0.1514474315347285, 0.1281898796889669, 0.13758715033492896, 0.17097334185492896, 0.1321238582465758, 0.13126160539555642, 0.16513342648647322, 0.1336431338647288, 0.19359863406337674, 0.1761962073363531, 0.1727334292931053, 0.15758630539693808, 0.16109360306102627, 0.217592874447459, 0.1695006901624594, 0.19378470520337043, 0.17962081480433645, 0.18482541449465584, 0.1627154788357711, 0.16738095045389567, 0.16050211855081686, 0.165030194035782, 0.16238182717550698, 0.17348078327920835, 0.17927789553287343, 0.16091342115678176, 0.14949394455740317, 0.19184305857966633, 0.1748095572384607, 0.1760562992459248, 0.14409967028956072, 0.21934252830958656, 0.12165498455453871, 0.1419253847831673, 0.17170882805826881, 0.15607036178715517, 0.1715537915249048, 0.13719812784246221, 0.11637365223306328, 0.1646011389093368, 0.15568085873663273, 0.19854761316794423, 0.15142838888021837, 0.16829871282776587, 0.1863092358100885, 0.2014391033860793, 0.18064580607776515, 0.19586958514500252, 0.16857624526748094, 0.1859361640487417, 0.19061693143940506, 0.19196856883022173, 0.17540987846722, 0.05998154860634386, 0.06320796893826552, 0.05792336111655971, 0.06006229092707149, 0.06474248293944351, 0.06250020686758728, 0.06277666416504779, 0.0676250252178241, 0.057523644344468106]}, "mutation_prompt": null}
{"id": "3b5e87fb-43e5-4814-ac26-b80aaa35edb5", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.9 * (1 - self.current_iteration / self.budget)  # Dynamic adjustment of crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Enhance global exploration by introducing a dynamic crossover probability adjustment based on current iteration.", "configspace": "", "generation": 17, "fitness": 0.2546228381175471, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.21.", "error": "", "parent_id": "bd17f3d9-0f42-4a1a-a93e-26d9d63d05ec", "metadata": {"aucs": [0.6318695533002026, 0.7020483932427776, 0.6862703910876166, 0.7011453921108836, 0.6670985399308382, 0.7092099887397373, 0.6738750570091598, 0.7194756526976289, 0.7029599567530652, 0.4478796189638852, 0.4373443148399788, 0.45888441868541985, 0.38324199901781897, 0.397352945472056, 0.4380676991895387, 0.4403033858346984, 0.4458601067489347, 0.42672567457237787, 0.10262618137578683, 0.10763720135065236, 0.1561206340607676, 0.10947580505411714, 0.12667797344641152, 0.12254575396642753, 0.10423154882588004, 0.10177036796026673, 0.11627505486378831, 0.10931006161400514, 0.10245425385726536, 0.11504177903910773, 0.0962376083786729, 0.08958146376004739, 0.1225992289143032, 0.1077881877241611, 0.09680839505398797, 0.10810110945519391, 0.9696543795093671, 0.9135039641218081, 0.9184586282510504, 0.8735197371665882, 0.9639088188530794, 0.8916984299541009, 0.8942009020755354, 0.9072591609561319, 0.9013879924639548, 0.29655817824073105, 0.27498714961356596, 0.2493296854659114, 0.2891168405851702, 0.30709342732674016, 0.32605153104360296, 0.27363499000390357, 0.3310066227882372, 0.3279419650103791, 0.5332139323892298, 0.4814307924213628, 0.5638344440274441, 0.6082012232162304, 0.44634127372728016, 0.5247125075501318, 0.3912546740082036, 0.556211091779852, 0.5700535240823784, 0.16342247792472153, 0.1964930154489738, 0.16921317513496337, 0.16746068289399407, 0.1529471686950321, 0.18684759162873588, 0.14326884697452336, 0.16422811053769326, 0.15351186020264396, 0.23465388239520701, 0.11594974431326699, 0.13623802891279624, 0.1671387208598346, 0.16267374145640645, 0.17684683662208722, 0.12713157073661518, 0.22761653793435588, 0.165828911686563, 0.05304270770400077, 0.05304339055498708, 0.06970834742929033, 0.057536822558868383, 0.024483109705032757, 0.0314787658298703, 0.05402682831688377, 0.06356446441265651, 0.0941219016913587, 0.1581089060818065, 0.1380717723541287, 0.15669891235029465, 0.11011165813405988, 0.24228937042720466, 0.22246136560575247, 0.2613737112573973, 0.13936306557694678, 0.1450555373513469, 0.0004852298018502843, 0.007758738697452805, 9.999999999998899e-05, 0.0020628659527308635, 0.029760581718078494, 0.027358759033021318, 0.014589784847691023, 0.014441086873284048, 0.03500049851232834, 0.1248603320142383, 0.11136028845790624, 0.13556260559573474, 0.13759421991985565, 0.13697951498685013, 0.15237265930276533, 0.13522708622843405, 0.12652734229503293, 0.13543426268440306, 0.4687254272361615, 0.44451346385804147, 0.4443222810632138, 0.5075695076134272, 0.46183608307400104, 0.4659663311340645, 0.4211449679994015, 0.45679431946867444, 0.45972382218749885, 0.07675103928954663, 0.09066546966848421, 0.08137960307831804, 0.07252436843408394, 0.09355337711209288, 0.08444070087843414, 0.09116703054516506, 0.08511589420530885, 0.0901153547010235, 0.14072949389695844, 0.13573223401103696, 0.11620942484078445, 0.13220308661211877, 0.12189881052051899, 0.15032490810989407, 0.19364542665236395, 0.17229365093453175, 0.1923761968256068, 0.2688156303212782, 0.28465181566465747, 0.2920084074468775, 0.2756600761538516, 0.27507427075891266, 0.26542302911207294, 0.30906549512917136, 0.3160203400975785, 0.2842435751502188, 0.21273124626355167, 0.21261112132162774, 0.18499154585539268, 0.1859486889949996, 0.1949596427698167, 0.2008835949113177, 0.20614357258016835, 0.25343927624207985, 0.211483992215318, 0.20374134505140196, 0.1987831835676609, 0.18698109961815923, 0.17783075642176116, 0.18001419491597626, 0.18049169348253202, 0.17721045217959486, 0.18422355680777902, 0.17990498919986608, 0.1853450869139519, 0.1727665570055702, 0.1874358397743736, 0.1820391221987211, 0.19130802552510762, 0.1790732620558514, 0.1753665051868002, 0.18513093080051912, 0.17659082302690332, 0.147404674358239, 0.1560908475629531, 0.3422105001117276, 0.18007554411553828, 0.17893171566052424, 0.6839142057618635, 0.3645015892468074, 0.3622992578236631, 0.1742908574937192, 0.349722268421811, 0.1964043878614773, 0.39413523912955095, 0.17729271357017773, 0.15730318125954512, 0.18876622272216625, 0.19744232884829493, 0.1511908488589352, 0.20386872779763532, 0.18563752938153977, 0.17006024381500628, 0.17849447562772514, 0.18044543423785508, 0.18468007710828893, 0.18689335854445777, 0.1858717048185995, 0.17756727385428583, 0.20386878751379922, 0.0729461887398597, 0.07162219824463611, 0.07372408464991842, 0.07461908941531381, 0.0760749840530347, 0.07472133642623302, 0.08422412955263403, 0.07892536580569909, 0.0792476801730827]}, "mutation_prompt": null}
{"id": "27a48622-7e3a-4223-90cf-2ca7c0230fd8", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Improve local exploitation by dynamically adjusting perturbation size based on fitness improvement ratio.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "bd17f3d9-0f42-4a1a-a93e-26d9d63d05ec", "metadata": {"aucs": [0.6395690930186543, 0.6815869002074451, 0.688839899224178, 0.6919859483834634, 0.6753933957200691, 0.7291233126582346, 0.709520269730876, 0.6811349670743859, 0.667453929159065, 0.44868215640823883, 0.45073228453308045, 0.3848277371060109, 0.49098252728562175, 0.4014824909184983, 0.4343131605972489, 0.39671996582088775, 0.44279173216128, 0.4336922568802799, 0.10111800026944462, 0.09333710890979752, 0.10756321969521254, 0.12273413085660323, 0.128597448554174, 0.10072491010015894, 0.0952571845902348, 0.11736934023604173, 0.09214833640415565, 0.09313592516184688, 0.07838269924731434, 0.08837957613202996, 0.07463173800757683, 0.0981865089401508, 0.09610862953134669, 0.08933060238184842, 0.11541024659904264, 0.09408830499868004, 0.970861648530517, 0.8708506450525079, 0.8679271876238679, 0.8667858819083551, 0.9378858516362558, 0.8987243492317012, 0.938265392888973, 0.9629581958526743, 0.9170493902722912, 0.313103788756677, 0.3296245437401347, 0.3536010606148777, 0.32899534519571627, 0.34429057703708466, 0.307884080876036, 0.3574546153318512, 0.3270483292661899, 0.3602191918043276, 0.5156497278973686, 0.6268235088719128, 0.5796618135321217, 0.63567983215377, 0.6456726160146204, 0.719515124404815, 0.5538150409773853, 0.6679529777931071, 0.5977995579600976, 0.18378436853656288, 0.177310173929229, 0.2811065328959572, 0.1710565480921441, 0.19153742884782554, 0.1749844798427126, 0.16522517743344634, 0.192347063960716, 0.19387237753514475, 0.11272557890976864, 0.1500594018014716, 0.14536706142772526, 0.14661228881089405, 0.22263765451716722, 0.20279595225821534, 0.21065979966050563, 0.1654582578562579, 0.20360337771595283, 0.18521974587402334, 0.16261210324699282, 0.1531101680532243, 0.16564480306952578, 0.1793230703522618, 0.1349580673006927, 0.1675806841530495, 0.20006654112626, 0.27064224896106603, 0.3158617038031193, 0.2760586155192639, 0.32439020571872035, 0.2897437402120421, 0.27107469081426727, 0.23090553823159166, 0.4333826248827487, 0.29057085983527864, 0.31960106826010737, 0.05907001568598258, 0.03589410813784122, 0.026895764800174637, 0.07205885456998218, 0.08892537497367758, 0.054718230006161495, 0.11551924407473002, 0.06778981446503307, 0.10412127810876792, 0.1620246146674995, 0.1582314486759142, 0.2019606118523828, 0.20299096641894243, 0.1903366395000613, 0.19373427516243868, 0.1964179650139284, 0.19293437555291326, 0.19081384500718612, 0.49593304446582465, 0.5129677480142756, 0.5327410452750319, 0.5077895264042127, 0.4926554170715849, 0.5531773042476944, 0.5392064863601254, 0.566014551524707, 0.5325463512640121, 0.09469723235448624, 0.08888644422102754, 0.10447973154961221, 0.09086707837517494, 0.09011878265029738, 0.07808804119221313, 0.07549120306266399, 0.0805161370709977, 0.0760055435998731, 0.16891413635241082, 0.18896897469821028, 0.11641508870928141, 0.12882557837480968, 0.14894385760222673, 0.16643463932074576, 0.21287059355240068, 0.20947991273185929, 0.12210558725495879, 0.3016110990430717, 0.2984812242199302, 0.30561061103083687, 0.29779028928296836, 0.282396733873987, 0.3120290439831591, 0.29632346812581134, 0.31738352676169457, 0.34810738669266617, 0.25283322802233266, 0.24535440203295011, 0.24538596968791448, 0.21485214943173414, 0.23347297027610747, 0.24278746109116656, 0.23447383809051625, 0.25613430282451133, 0.23103449392271214, 0.19430411874241915, 0.22088408271070492, 0.19072252543394275, 0.20407789946449262, 0.18798027413982754, 0.20442008700291825, 0.17382480885453455, 0.20402000789650732, 0.19608909159312515, 0.1809899224791951, 0.19610779416477342, 0.27435498410927395, 0.1888357584416116, 0.22860022256315382, 0.1747839770577404, 0.2376490006943458, 0.1826023824185441, 0.1643945322471343, 0.19151421957455228, 0.5662312272784311, 0.14609138462274296, 0.523414834753692, 0.18983269564637362, 0.17058057128956916, 0.16977043657186952, 0.6135429544981972, 0.46346951144992554, 0.58462767854275, 0.19135893395773385, 0.6313551494512681, 0.48899183443656624, 0.560009171917028, 0.19353206529844225, 0.2012071617723692, 0.15189309388719507, 0.6567506210316532, 0.20164501487305775, 0.2014391033860793, 0.19109021083068645, 0.20344582082097273, 0.18945989035183153, 0.17528567593384736, 0.1684407924426623, 0.19196856883022173, 0.18872337653566662, 0.07906145683351318, 0.06954995768880312, 0.07704561583154523, 0.07432921291612604, 0.07115671375780053, 0.06428258456961644, 0.07128080151172012, 0.06661521826335315, 0.07918021224505423]}, "mutation_prompt": null}
{"id": "891e9a0d-8125-4c17-92f0-503b01f5a4ed", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Improve local exploitation by dynamically adjusting perturbation size based on fitness improvement ratio.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "bd17f3d9-0f42-4a1a-a93e-26d9d63d05ec", "metadata": {"aucs": [0.6395690930186543, 0.6815869002074451, 0.688839899224178, 0.6919859483834634, 0.6753933957200691, 0.7291233126582346, 0.709520269730876, 0.6811349670743859, 0.667453929159065, 0.44868215640823883, 0.45073228453308045, 0.3848277371060109, 0.49098252728562175, 0.4014824909184983, 0.4343131605972489, 0.39671996582088775, 0.44279173216128, 0.4336922568802799, 0.10111800026944462, 0.09333710890979752, 0.10756321969521254, 0.12273413085660323, 0.128597448554174, 0.10072491010015894, 0.0952571845902348, 0.11736934023604173, 0.09214833640415565, 0.09313592516184688, 0.07838269924731434, 0.08837957613202996, 0.07463173800757683, 0.0981865089401508, 0.09610862953134669, 0.08933060238184842, 0.11541024659904264, 0.09408830499868004, 0.970861648530517, 0.8708506450525079, 0.8679271876238679, 0.8667858819083551, 0.9378858516362558, 0.8987243492317012, 0.938265392888973, 0.9629581958526743, 0.9170493902722912, 0.313103788756677, 0.3296245437401347, 0.3536010606148777, 0.32899534519571627, 0.34429057703708466, 0.307884080876036, 0.3574546153318512, 0.3270483292661899, 0.3602191918043276, 0.5156497278973686, 0.6268235088719128, 0.5796618135321217, 0.63567983215377, 0.6456726160146204, 0.719515124404815, 0.5538150409773853, 0.6679529777931071, 0.5977995579600976, 0.18378436853656288, 0.177310173929229, 0.2811065328959572, 0.1710565480921441, 0.19153742884782554, 0.1749844798427126, 0.16522517743344634, 0.192347063960716, 0.19387237753514475, 0.11272557890976864, 0.1500594018014716, 0.14536706142772526, 0.14661228881089405, 0.22263765451716722, 0.20279595225821534, 0.21065979966050563, 0.1654582578562579, 0.20360337771595283, 0.18521974587402334, 0.16261210324699282, 0.1531101680532243, 0.16564480306952578, 0.1793230703522618, 0.1349580673006927, 0.1675806841530495, 0.20006654112626, 0.27064224896106603, 0.3158617038031193, 0.2760586155192639, 0.32439020571872035, 0.2897437402120421, 0.27107469081426727, 0.23090553823159166, 0.4333826248827487, 0.29057085983527864, 0.31960106826010737, 0.05907001568598258, 0.03589410813784122, 0.026895764800174637, 0.07205885456998218, 0.08892537497367758, 0.054718230006161495, 0.11551924407473002, 0.06778981446503307, 0.10412127810876792, 0.1620246146674995, 0.1582314486759142, 0.2019606118523828, 0.20299096641894243, 0.1903366395000613, 0.19373427516243868, 0.1964179650139284, 0.19293437555291326, 0.19081384500718612, 0.49593304446582465, 0.5129677480142756, 0.5327410452750319, 0.5077895264042127, 0.4926554170715849, 0.5531773042476944, 0.5392064863601254, 0.566014551524707, 0.5325463512640121, 0.09469723235448624, 0.08888644422102754, 0.10447973154961221, 0.09086707837517494, 0.09011878265029738, 0.07808804119221313, 0.07549120306266399, 0.0805161370709977, 0.0760055435998731, 0.16891413635241082, 0.18896897469821028, 0.11641508870928141, 0.12882557837480968, 0.14894385760222673, 0.16643463932074576, 0.21287059355240068, 0.20947991273185929, 0.12210558725495879, 0.3016110990430717, 0.2984812242199302, 0.30561061103083687, 0.29779028928296836, 0.282396733873987, 0.3120290439831591, 0.29632346812581134, 0.31738352676169457, 0.34810738669266617, 0.25283322802233266, 0.24535440203295011, 0.24538596968791448, 0.21485214943173414, 0.23347297027610747, 0.24278746109116656, 0.23447383809051625, 0.25613430282451133, 0.23103449392271214, 0.19430411874241915, 0.22088408271070492, 0.19072252543394275, 0.20407789946449262, 0.18798027413982754, 0.20442008700291825, 0.17382480885453455, 0.20402000789650732, 0.19608909159312515, 0.1809899224791951, 0.19610779416477342, 0.27435498410927395, 0.1888357584416116, 0.22860022256315382, 0.1747839770577404, 0.2376490006943458, 0.1826023824185441, 0.1643945322471343, 0.19151421957455228, 0.5662312272784311, 0.14609138462274296, 0.523414834753692, 0.18983269564637362, 0.17058057128956916, 0.16977043657186952, 0.6135429544981972, 0.46346951144992554, 0.58462767854275, 0.19135893395773385, 0.6313551494512681, 0.48899183443656624, 0.560009171917028, 0.19353206529844225, 0.2012071617723692, 0.15189309388719507, 0.6567506210316532, 0.20164501487305775, 0.2014391033860793, 0.19109021083068645, 0.20344582082097273, 0.18945989035183153, 0.17528567593384736, 0.1684407924426623, 0.19196856883022173, 0.18872337653566662, 0.07906145683351318, 0.06954995768880312, 0.07704561583154523, 0.07432921291612604, 0.07115671375780053, 0.06428258456961644, 0.07128080151172012, 0.06661521826335315, 0.07918021224505423]}, "mutation_prompt": null}
{"id": "b528cdd5-a900-4b58-bad9-91ba2bbb9506", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Enhance global exploration by introducing adaptive population size based on the remaining budget.", "configspace": "", "generation": 20, "fitness": 0.3131206029229992, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.", "error": "", "parent_id": "bd17f3d9-0f42-4a1a-a93e-26d9d63d05ec", "metadata": {"aucs": [0.6880841906159763, 0.7336735505234593, 0.7173741735507848, 0.7347091941833751, 0.7152915670648244, 0.7493757127754836, 0.7131512625064276, 0.7246934781186185, 0.7070995638763942, 0.482225899261268, 0.5040941689044393, 0.5036463217073027, 0.4763455521626979, 0.5085673042671977, 0.4962875748696043, 0.5393873290992249, 0.4974296065525253, 0.5196157277314157, 0.12572102761163373, 0.10154169273186309, 0.09230874706524261, 0.09385960444595198, 0.09899388880055249, 0.10929800132210932, 0.1039668757275849, 0.22263117568988955, 0.12444162941089476, 0.11807813826681157, 0.10987379609254166, 0.10371705361591743, 0.10552427429789091, 0.12490351064104166, 0.11973847081544986, 0.09123576917485732, 0.1006178675762569, 0.0887870771539152, 0.8795959760566845, 0.9531338640433403, 0.9864252448738643, 0.8812453617372751, 0.9017769374975981, 0.883829460464581, 0.9142286121955158, 0.8864831225887614, 0.8637929549936509, 0.37720915572236813, 0.4095251153187862, 0.36166757212652223, 0.32876350667136867, 0.3277487052817071, 0.33698677669865884, 0.3572984737190972, 0.356567144475165, 0.33505371123354044, 0.6345249941381377, 0.6390652213187376, 0.670741336626226, 0.6908971178001544, 0.7211428268401039, 0.6505724388063847, 0.6594897705970455, 0.6722369752038247, 0.5954709995244911, 0.30138717019220274, 0.2506666386970442, 0.17077502319863325, 0.2766159110119387, 0.2583863243928468, 0.2486227570531081, 0.22343897591620754, 0.22481833848083166, 0.24419147928943485, 0.19954924188504664, 0.1794829228279703, 0.24453000206990383, 0.27590093643370917, 0.2114104888818843, 0.1753224702194175, 0.19394656697793655, 0.2329344871204534, 0.2050824469588527, 0.10944525477088696, 0.10273707640445007, 0.17019746149574078, 0.19082541296227662, 0.18545952498592355, 0.1592943746486375, 0.24893696343031857, 0.23243907765304417, 0.2590322934330477, 0.30966426225043786, 0.3824699575947841, 0.3510097633141075, 0.32636211345192145, 0.26584257413138923, 0.30007516493470787, 0.40332387535511494, 0.18094860844280858, 0.3694460084891077, 0.08330134578563453, 0.06312006364629963, 0.06637732579530076, 0.13685155104926472, 0.10652489502064932, 0.06044031936652661, 0.10679098239181095, 0.100665788875687, 0.048061700976488875, 0.16563810836140969, 0.2328140580845558, 0.1986372003699326, 0.22497673171472898, 0.23063658651435903, 0.23293151270662926, 0.2071432624839441, 0.210731080456952, 0.2589702923638404, 0.5958373823497756, 0.5423428879530064, 0.6044729341235706, 0.5438377327466064, 0.521250545188798, 0.5772440681634904, 0.5909859907964627, 0.5598847415358801, 0.5590901454572645, 0.08532650774179451, 0.08754483577047589, 0.08388774072279426, 0.0901325728166188, 0.08320985250885438, 0.08450794988705945, 0.09862077852537898, 0.11118875193121458, 0.09575906263382694, 0.2232983615222337, 0.17987902217438534, 0.31040704635930505, 0.2936029080016016, 0.1335223957827929, 0.17912312978965184, 0.2239670638349872, 0.17411938496001567, 0.19132839216816344, 0.321404846889617, 0.3537403233523556, 0.30867116535011496, 0.27583388574895784, 0.2962086593946974, 0.28534519487646504, 0.3068494107575832, 0.3464668559254078, 0.33916739437083, 0.24100378014643242, 0.2598969710442788, 0.24357616423102801, 0.23010496900177135, 0.19026157786134457, 0.2721878489188849, 0.25923206174567237, 0.2741936473074579, 0.2667378850624109, 0.19732064080284595, 0.1870150535080336, 0.18199151673312985, 0.18143901792219008, 0.1736748764231928, 0.24411030530135513, 0.19988046595708742, 0.19023224807428452, 0.21734608104843478, 0.1771433670347211, 0.19390092697883143, 0.1722351854270171, 0.17543533666176703, 0.19799041904310266, 0.19529647808487494, 0.22778987543728058, 0.184963902266844, 0.18841811100729888, 0.15747500309660367, 0.6625344199736904, 0.14848866850034104, 0.6952705960121468, 0.769268085978053, 0.17446620400389734, 0.19233877634548113, 0.19845165226196848, 0.17765092129432758, 0.6626191792302003, 0.7014305388081421, 0.7128674749242259, 0.18599567895553704, 0.6554241193383683, 0.18470065332108876, 0.21025538203031735, 0.5877002053278664, 0.19529973674659618, 0.19899958225753167, 0.1895279318097134, 0.16880043153032476, 0.17797747162244726, 0.18290275837798387, 0.17182336739685433, 0.17383236844581684, 0.16357255700662277, 0.18693431039592556, 0.06678468531969406, 0.07753276589403135, 0.07119558611785703, 0.06655491543935366, 0.08047568360016122, 0.06057778666792146, 0.07846783895088938, 0.07025794282572573, 0.07320740633135336]}, "mutation_prompt": null}
{"id": "b44aecde-111f-4607-9d67-07fccca458bb", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Enhance global exploration by introducing adaptive population size based on the remaining budget.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b528cdd5-a900-4b58-bad9-91ba2bbb9506", "metadata": {"aucs": [0.6880841906159763, 0.7336735505234593, 0.7173741735507848, 0.7347091941833751, 0.7152915670648244, 0.7493757127754836, 0.7131512625064276, 0.7246934781186185, 0.7070995638763942, 0.482225899261268, 0.5040941689044393, 0.5036463217073027, 0.4763455521626979, 0.5085673042671977, 0.4962875748696043, 0.5393873290992249, 0.4974296065525253, 0.5196157277314157, 0.12572102761163373, 0.10154169273186309, 0.09230874706524261, 0.09385960444595198, 0.09899388880055249, 0.10929800132210932, 0.1039668757275849, 0.22263117568988955, 0.12444162941089476, 0.11807813826681157, 0.10987379609254166, 0.10371705361591743, 0.10552427429789091, 0.12490351064104166, 0.11973847081544986, 0.09123576917485732, 0.1006178675762569, 0.0887870771539152, 0.8795959760566845, 0.9531338640433403, 0.9864252448738643, 0.8812453617372751, 0.9017769374975981, 0.883829460464581, 0.9142286121955158, 0.8864831225887614, 0.8637929549936509, 0.37720915572236813, 0.4095251153187862, 0.36166757212652223, 0.32876350667136867, 0.3277487052817071, 0.33698677669865884, 0.3572984737190972, 0.356567144475165, 0.33505371123354044, 0.6345249941381377, 0.6390652213187376, 0.670741336626226, 0.6908971178001544, 0.7211428268401039, 0.6505724388063847, 0.6594897705970455, 0.6722369752038247, 0.5954709995244911, 0.30138717019220274, 0.2506666386970442, 0.17077502319863325, 0.2766159110119387, 0.2583863243928468, 0.2486227570531081, 0.22343897591620754, 0.22481833848083166, 0.24419147928943485, 0.19954924188504664, 0.1794829228279703, 0.24453000206990383, 0.27590093643370917, 0.2114104888818843, 0.1753224702194175, 0.19394656697793655, 0.2329344871204534, 0.2050824469588527, 0.10944525477088696, 0.10273707640445007, 0.17019746149574078, 0.19082541296227662, 0.18545952498592355, 0.1592943746486375, 0.24893696343031857, 0.23243907765304417, 0.2590322934330477, 0.30966426225043786, 0.3824699575947841, 0.3510097633141075, 0.32636211345192145, 0.26584257413138923, 0.30007516493470787, 0.40332387535511494, 0.18094860844280858, 0.3694460084891077, 0.08330134578563453, 0.06312006364629963, 0.06637732579530076, 0.13685155104926472, 0.10652489502064932, 0.06044031936652661, 0.10679098239181095, 0.100665788875687, 0.048061700976488875, 0.16563810836140969, 0.2328140580845558, 0.1986372003699326, 0.22497673171472898, 0.23063658651435903, 0.23293151270662926, 0.2071432624839441, 0.210731080456952, 0.2589702923638404, 0.5958373823497756, 0.5423428879530064, 0.6044729341235706, 0.5438377327466064, 0.521250545188798, 0.5772440681634904, 0.5909859907964627, 0.5598847415358801, 0.5590901454572645, 0.08532650774179451, 0.08754483577047589, 0.08388774072279426, 0.0901325728166188, 0.08320985250885438, 0.08450794988705945, 0.09862077852537898, 0.11118875193121458, 0.09575906263382694, 0.2232983615222337, 0.17987902217438534, 0.31040704635930505, 0.2936029080016016, 0.1335223957827929, 0.17912312978965184, 0.2239670638349872, 0.17411938496001567, 0.19132839216816344, 0.321404846889617, 0.3537403233523556, 0.30867116535011496, 0.27583388574895784, 0.2962086593946974, 0.28534519487646504, 0.3068494107575832, 0.3464668559254078, 0.33916739437083, 0.24100378014643242, 0.2598969710442788, 0.24357616423102801, 0.23010496900177135, 0.19026157786134457, 0.2721878489188849, 0.25923206174567237, 0.2741936473074579, 0.2667378850624109, 0.19732064080284595, 0.1870150535080336, 0.18199151673312985, 0.18143901792219008, 0.1736748764231928, 0.24411030530135513, 0.19988046595708742, 0.19023224807428452, 0.21734608104843478, 0.1771433670347211, 0.19390092697883143, 0.1722351854270171, 0.17543533666176703, 0.19799041904310266, 0.19529647808487494, 0.22778987543728058, 0.184963902266844, 0.18841811100729888, 0.15747500309660367, 0.6625344199736904, 0.14848866850034104, 0.6952705960121468, 0.769268085978053, 0.17446620400389734, 0.19233877634548113, 0.19845165226196848, 0.17765092129432758, 0.6626191792302003, 0.7014305388081421, 0.7128674749242259, 0.18599567895553704, 0.6554241193383683, 0.18470065332108876, 0.21025538203031735, 0.5877002053278664, 0.19529973674659618, 0.19899958225753167, 0.1895279318097134, 0.16880043153032476, 0.17797747162244726, 0.18290275837798387, 0.17182336739685433, 0.17383236844581684, 0.16357255700662277, 0.18693431039592556, 0.06678468531969406, 0.07753276589403135, 0.07119558611785703, 0.06655491543935366, 0.08047568360016122, 0.06057778666792146, 0.07846783895088938, 0.07025794282572573, 0.07320740633135336]}, "mutation_prompt": null}
{"id": "b24a0085-d87c-4d2a-9105-46acb4264cb8", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        # Dynamic crossover probability based on iteration progress\n        self.CR = 0.9 * (1 - self.current_iteration / self.budget)\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Enhance adaptive exploration by introducing a dynamic crossover probability based on iteration progress.", "configspace": "", "generation": 22, "fitness": 0.2786456307980983, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "b528cdd5-a900-4b58-bad9-91ba2bbb9506", "metadata": {"aucs": [0.6842350186747803, 0.7278488960912373, 0.7057250276337014, 0.7217630123284706, 0.7257796322922221, 0.74978793872014, 0.7089364370110852, 0.7597970502328295, 0.7293475674924113, 0.49928930140012595, 0.5296297477870329, 0.5490600351516123, 0.5171766160384221, 0.45994399678706077, 0.49906168738004464, 0.5493768489806088, 0.498185655697705, 0.49054845016523674, 0.17068827652377894, 0.13521227149310833, 0.11214905435599398, 0.1237810978564785, 0.11604763346781544, 0.11902974646400832, 0.1279764101393237, 0.12862179342947933, 0.18167488682056876, 0.09253828572253098, 0.11556382598907855, 0.09476208264568797, 0.11054961973713329, 0.11343447127801942, 0.12694699947374066, 0.09978628546543533, 0.10590179237912656, 0.10694105053665592, 0.8938454189985443, 0.9079991321550196, 0.9864252448738643, 0.8549977361981597, 0.908243822299689, 0.8941612179971359, 0.8941834196000041, 0.8529311265078601, 0.9054055701680777, 0.3806288530353168, 0.300893755970595, 0.3471640311372447, 0.3271426399342783, 0.30721552683282893, 0.34414952585531655, 0.34639808208352396, 0.39393193143579597, 0.3399994252654579, 0.5357608762154906, 0.4969252779461948, 0.5534721172856834, 0.6302776571045882, 0.6219915201089133, 0.4358290246347808, 0.5254592091199192, 0.4875311307610961, 0.6355146509071121, 0.1827214284172598, 0.20405837748124345, 0.19835302762104934, 0.1373397933883561, 0.16808582681442785, 0.18048626886581554, 0.17377564258346923, 0.19815129090127437, 0.201452144604361, 0.2101789291980376, 0.198160586520301, 0.1740399013341032, 0.17592773823132846, 0.1830560513392091, 0.18119979013660914, 0.16156691202937945, 0.10912495252333743, 0.17410183077046115, 0.10841189841535637, 0.06249061180414317, 0.08900931756979336, 0.06297730075930996, 0.06342201359431454, 0.04668693873054852, 0.06221863269429562, 0.06759782741911935, 0.07437605455577034, 0.17721406203064105, 0.15607644900718332, 0.1623141515862544, 0.21443548210591667, 0.16161063945118315, 0.035373275138468, 0.26271381271916205, 0.14314095805458804, 0.18679578962772514, 0.0053784369443473645, 0.023537297248412914, 0.02402932477436648, 0.033476979317060396, 0.024812727664147327, 0.024001235814889554, 0.048043700570950754, 0.003072768795034375, 0.04984227890556048, 0.15515522204471255, 0.1487089805846863, 0.13560211633664954, 0.16502413150483952, 0.14408864840383717, 0.16452286158959306, 0.1389084143865511, 0.15761371602927643, 0.1402003664948075, 0.4727698404725533, 0.46530348943223143, 0.46787887852649945, 0.4754562673872752, 0.48424825431566, 0.46937283863266666, 0.48415924420964074, 0.47480438165676675, 0.4614953428852384, 0.08254947680913938, 0.09150393870574391, 0.08711292683663108, 0.08298439156067938, 0.09681539167414066, 0.10605800670982912, 0.08337066749015354, 0.08587185467949188, 0.08227623391501548, 0.15071863345922354, 0.1355456302134448, 0.1494553503910938, 0.1750486691734583, 0.16105859753249785, 0.13369884643960994, 0.19451105024001536, 0.14971581978669257, 0.14710826052593096, 0.29629851081508163, 0.31328968193471785, 0.3079330723716769, 0.26721795534051307, 0.30846584880562455, 0.3176284234658152, 0.33569017150405833, 0.34338085311723976, 0.33770042628537733, 0.20558211660202008, 0.2208057851201244, 0.1600493235714684, 0.17031199845474798, 0.244668813792292, 0.2446319697518916, 0.21935973940107223, 0.26333125887012854, 0.22901313039159643, 0.18575755460502363, 0.16688565831077196, 0.16858943306870988, 0.19571861853362138, 0.17842193717581845, 0.17455432821802408, 0.22583970254210484, 0.18248876482364085, 0.1962706209548104, 0.1787294031339972, 0.17614362574432907, 0.19476924121999495, 0.18641432017531756, 0.2118201030150182, 0.4251110821224151, 0.18241521465827515, 0.1823898912407076, 0.19504096465453769, 0.14818983678314346, 0.6209199698477104, 0.14816608267359788, 0.5396910718407708, 0.18462437439942947, 0.6648278569607972, 0.19255332850183238, 0.19349094986308712, 0.4469740170956369, 0.5074268611294546, 0.1600780819231331, 0.5054597589769545, 0.1884899084914784, 0.6057985070406213, 0.5633476037024123, 0.21027010471935104, 0.1976241643961092, 0.5647562022077515, 0.21307891111167487, 0.18931222933149106, 0.18875860396008515, 0.18439775755254517, 0.1749666097142215, 0.18855168064357497, 0.17143820885646788, 0.17621078426226555, 0.18229369945541707, 0.08112202287252179, 0.07036645915289486, 0.08167947982860702, 0.07786633161458922, 0.07828448714286895, 0.08382470383303242, 0.07942155634666814, 0.06805791541949935, 0.08128295977493982]}, "mutation_prompt": null}
{"id": "981ed248-79f6-4ba6-8eb5-a7c0abe94a31", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.1 * ((1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min()))**0.5\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Enhance the local search by dynamically adjusting perturbation size based on function value feedback.", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "An exception occurred: OverflowError('Range exceeds valid bounds').", "error": "OverflowError('Range exceeds valid bounds')", "parent_id": "b528cdd5-a900-4b58-bad9-91ba2bbb9506", "metadata": {}, "mutation_prompt": null}
{"id": "b2cb79aa-db17-4a22-936b-9599d2923176", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (self.current_iteration / self.budget)  # New randomized crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Improve balance between exploration and exploitation by randomizing crossover probability based on current budget usage.", "configspace": "", "generation": 24, "fitness": 0.2408702021572027, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.22.", "error": "", "parent_id": "b528cdd5-a900-4b58-bad9-91ba2bbb9506", "metadata": {"aucs": [0.7194679570561252, 0.7135342440011012, 0.7178013577180191, 0.7256489502660086, 0.715733517034649, 0.7480594253655761, 0.7196192441720686, 0.7168537665718555, 0.7206618162696117, 0.5349313394738815, 0.45128424380936205, 0.5113451071292765, 0.4726816670963341, 0.4771060592643722, 0.4597185825616823, 0.4772721613023039, 0.47695485322495024, 0.444287519631569, 0.2669536734683625, 0.2564524774859074, 0.22861713800980177, 0.2553602060157064, 0.26219327121611735, 0.32435642762128714, 0.15168453411331773, 0.4111550754584866, 0.18757266872222744, 0.16520606118075432, 0.14338367469300972, 0.20708347898214663, 0.21256360329381274, 0.12255560772145146, 0.15941791714480935, 0.1339282840826459, 0.1614809650772837, 0.17982957567171254, 0.9180980342148513, 0.9447231424685287, 0.9259324362207237, 0.9323147620130995, 0.940102966225888, 0.9263423766876367, 0.9480433042495903, 0.9392106280625474, 0.9348438248497216, 0.2627346303264557, 0.26802961985984475, 0.29003796316426766, 0.2768414466660968, 0.2424745773587198, 0.2739675322597144, 0.2699228189117514, 0.27916974005182393, 0.23541456149774964, 0.2681716893060939, 0.21745996172700865, 0.20095972913849314, 0.33807233880977006, 0.2769476573346298, 0.2525622588460794, 0.39477406854946606, 0.3421382368724952, 0.3426465734860672, 0.10086027995960667, 0.1614069557582648, 0.1277632231518543, 0.15015002622894824, 0.16510608746679334, 0.11978682727627454, 0.13320508849648072, 0.17389419758444424, 0.15029668309735167, 0.10738705468678822, 0.12335276400194106, 0.12499948743022449, 0.1408458492793181, 0.14486554269316476, 0.17798066898928977, 0.12503741663430268, 0.14181531566378358, 0.11442384135124573, 0.0015415842942806401, 0.0001527465414438156, 0.0011773217945643122, 0.0016251716781514602, 0.0017431691285421103, 0.0008682274584369543, 0.0008360816236793189, 9.999999999998899e-05, 0.00021958099512398022, 0.1234311301662554, 0.045186336764325485, 0.05624484949862929, 0.033092833382101894, 0.05536400796546459, 0.025580467196074874, 0.05523029571684279, 0.0863123337234154, 0.06023089432587059, 0.0002848064243565762, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0013695105431961174, 9.999999999998899e-05, 0.003978759933660703, 0.013832073522748067, 0.0894917903291853, 0.0822570688903912, 0.12018400272241836, 0.11117472985848531, 0.08445834254043327, 0.08988566174808077, 0.08755809033350548, 0.09699879889971585, 0.09952128387055437, 0.46881887576014736, 0.4417396812501232, 0.4337327102221571, 0.45700629651255287, 0.42859046315354576, 0.4636793201171524, 0.4391978070925603, 0.43713901216467055, 0.4318553191461889, 0.09366201627609994, 0.08642400881509005, 0.10964105568106297, 0.09114891219563193, 0.07794569956562669, 0.09832932271688533, 0.0674003986759728, 0.0776973052128549, 0.11043108113635058, 0.12934035078291695, 0.12998865613154253, 0.15838844932549911, 0.13943096692864343, 0.129119528737891, 0.12013269038407048, 0.12976453855307624, 0.14953454166066826, 0.1423066273119875, 0.2496103749365619, 0.2385072304366621, 0.2562210693627591, 0.2868728639812478, 0.24759504088305473, 0.2639991604542309, 0.2905089424589461, 0.30946161870128985, 0.30946769284536024, 0.19914757218205037, 0.17945868022672418, 0.19984749816743475, 0.18646308779395504, 0.17229206202444058, 0.18053580898401034, 0.225776760419641, 0.1817259039797936, 0.18758208037401314, 0.22109607438263779, 0.1929429453662579, 0.19494219175554361, 0.17745947357308034, 0.19804738578327097, 0.18062525311679967, 0.17666761805881948, 0.18114967627426692, 0.17718174432782707, 0.19345908160440162, 0.18764319143037078, 0.18517069272932685, 0.19393210228989155, 0.17905466965024774, 0.18963430107107293, 0.18457814164366104, 0.24999145712274662, 0.19689301116450253, 0.2118578321908624, 0.13791304950083882, 0.1872264947874953, 0.3926697945010006, 0.17949718897383427, 0.19679252150695725, 0.15067957687813482, 0.1521128841822862, 0.14344888959361246, 0.2592683886428526, 0.22204881071315297, 0.20916010482792002, 0.18204399422573214, 0.17295254104899127, 0.3656300873572772, 0.3963265058292018, 0.2696888291870644, 0.23991513221801342, 0.1843513347041822, 0.169282445950792, 0.18867080077150433, 0.19708902738420175, 0.169921676743912, 0.17354350522657258, 0.19260621877792528, 0.18097728617622955, 0.1950658821752037, 0.06749396131077612, 0.07957847029625587, 0.07353757276093997, 0.06484457220945983, 0.07223655873228052, 0.0705732660386087, 0.07376961743060584, 0.07162488901873909, 0.07727326632778131]}, "mutation_prompt": null}
{"id": "77bfdd1f-105f-48eb-abbf-bde81fd1a4ee", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.9 * (1 - self.current_iteration / self.budget)  # Dynamic crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Introduce a dynamic crossover probability that adapts based on iteration progress to balance exploration and exploitation.", "configspace": "", "generation": 25, "fitness": 0.2786456307980983, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "b528cdd5-a900-4b58-bad9-91ba2bbb9506", "metadata": {"aucs": [0.6842350186747803, 0.7278488960912373, 0.7057250276337014, 0.7217630123284706, 0.7257796322922221, 0.74978793872014, 0.7089364370110852, 0.7597970502328295, 0.7293475674924113, 0.49928930140012595, 0.5296297477870329, 0.5490600351516123, 0.5171766160384221, 0.45994399678706077, 0.49906168738004464, 0.5493768489806088, 0.498185655697705, 0.49054845016523674, 0.17068827652377894, 0.13521227149310833, 0.11214905435599398, 0.1237810978564785, 0.11604763346781544, 0.11902974646400832, 0.1279764101393237, 0.12862179342947933, 0.18167488682056876, 0.09253828572253098, 0.11556382598907855, 0.09476208264568797, 0.11054961973713329, 0.11343447127801942, 0.12694699947374066, 0.09978628546543533, 0.10590179237912656, 0.10694105053665592, 0.8938454189985443, 0.9079991321550196, 0.9864252448738643, 0.8549977361981597, 0.908243822299689, 0.8941612179971359, 0.8941834196000041, 0.8529311265078601, 0.9054055701680777, 0.3806288530353168, 0.300893755970595, 0.3471640311372447, 0.3271426399342783, 0.30721552683282893, 0.34414952585531655, 0.34639808208352396, 0.39393193143579597, 0.3399994252654579, 0.5357608762154906, 0.4969252779461948, 0.5534721172856834, 0.6302776571045882, 0.6219915201089133, 0.4358290246347808, 0.5254592091199192, 0.4875311307610961, 0.6355146509071121, 0.1827214284172598, 0.20405837748124345, 0.19835302762104934, 0.1373397933883561, 0.16808582681442785, 0.18048626886581554, 0.17377564258346923, 0.19815129090127437, 0.201452144604361, 0.2101789291980376, 0.198160586520301, 0.1740399013341032, 0.17592773823132846, 0.1830560513392091, 0.18119979013660914, 0.16156691202937945, 0.10912495252333743, 0.17410183077046115, 0.10841189841535637, 0.06249061180414317, 0.08900931756979336, 0.06297730075930996, 0.06342201359431454, 0.04668693873054852, 0.06221863269429562, 0.06759782741911935, 0.07437605455577034, 0.17721406203064105, 0.15607644900718332, 0.1623141515862544, 0.21443548210591667, 0.16161063945118315, 0.035373275138468, 0.26271381271916205, 0.14314095805458804, 0.18679578962772514, 0.0053784369443473645, 0.023537297248412914, 0.02402932477436648, 0.033476979317060396, 0.024812727664147327, 0.024001235814889554, 0.048043700570950754, 0.003072768795034375, 0.04984227890556048, 0.15515522204471255, 0.1487089805846863, 0.13560211633664954, 0.16502413150483952, 0.14408864840383717, 0.16452286158959306, 0.1389084143865511, 0.15761371602927643, 0.1402003664948075, 0.4727698404725533, 0.46530348943223143, 0.46787887852649945, 0.4754562673872752, 0.48424825431566, 0.46937283863266666, 0.48415924420964074, 0.47480438165676675, 0.4614953428852384, 0.08254947680913938, 0.09150393870574391, 0.08711292683663108, 0.08298439156067938, 0.09681539167414066, 0.10605800670982912, 0.08337066749015354, 0.08587185467949188, 0.08227623391501548, 0.15071863345922354, 0.1355456302134448, 0.1494553503910938, 0.1750486691734583, 0.16105859753249785, 0.13369884643960994, 0.19451105024001536, 0.14971581978669257, 0.14710826052593096, 0.29629851081508163, 0.31328968193471785, 0.3079330723716769, 0.26721795534051307, 0.30846584880562455, 0.3176284234658152, 0.33569017150405833, 0.34338085311723976, 0.33770042628537733, 0.20558211660202008, 0.2208057851201244, 0.1600493235714684, 0.17031199845474798, 0.244668813792292, 0.2446319697518916, 0.21935973940107223, 0.26333125887012854, 0.22901313039159643, 0.18575755460502363, 0.16688565831077196, 0.16858943306870988, 0.19571861853362138, 0.17842193717581845, 0.17455432821802408, 0.22583970254210484, 0.18248876482364085, 0.1962706209548104, 0.1787294031339972, 0.17614362574432907, 0.19476924121999495, 0.18641432017531756, 0.2118201030150182, 0.4251110821224151, 0.18241521465827515, 0.1823898912407076, 0.19504096465453769, 0.14818983678314346, 0.6209199698477104, 0.14816608267359788, 0.5396910718407708, 0.18462437439942947, 0.6648278569607972, 0.19255332850183238, 0.19349094986308712, 0.4469740170956369, 0.5074268611294546, 0.1600780819231331, 0.5054597589769545, 0.1884899084914784, 0.6057985070406213, 0.5633476037024123, 0.21027010471935104, 0.1976241643961092, 0.5647562022077515, 0.21307891111167487, 0.18931222933149106, 0.18875860396008515, 0.18439775755254517, 0.1749666097142215, 0.18855168064357497, 0.17143820885646788, 0.17621078426226555, 0.18229369945541707, 0.08112202287252179, 0.07036645915289486, 0.08167947982860702, 0.07786633161458922, 0.07828448714286895, 0.08382470383303242, 0.07942155634666814, 0.06805791541949935, 0.08128295977493982]}, "mutation_prompt": null}
{"id": "59c42c78-d09a-4fa3-b74f-ecf6818e057c", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Enhance global exploration by introducing adaptive population size based on the remaining budget.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b528cdd5-a900-4b58-bad9-91ba2bbb9506", "metadata": {"aucs": [0.6880841906159763, 0.7336735505234593, 0.7173741735507848, 0.7347091941833751, 0.7152915670648244, 0.7493757127754836, 0.7131512625064276, 0.7246934781186185, 0.7070995638763942, 0.482225899261268, 0.5040941689044393, 0.5036463217073027, 0.4763455521626979, 0.5085673042671977, 0.4962875748696043, 0.5393873290992249, 0.4974296065525253, 0.5196157277314157, 0.12572102761163373, 0.10154169273186309, 0.09230874706524261, 0.09385960444595198, 0.09899388880055249, 0.10929800132210932, 0.1039668757275849, 0.22263117568988955, 0.12444162941089476, 0.11807813826681157, 0.10987379609254166, 0.10371705361591743, 0.10552427429789091, 0.12490351064104166, 0.11973847081544986, 0.09123576917485732, 0.1006178675762569, 0.0887870771539152, 0.8795959760566845, 0.9531338640433403, 0.9864252448738643, 0.8812453617372751, 0.9017769374975981, 0.883829460464581, 0.9142286121955158, 0.8864831225887614, 0.8637929549936509, 0.37720915572236813, 0.4095251153187862, 0.36166757212652223, 0.32876350667136867, 0.3277487052817071, 0.33698677669865884, 0.3572984737190972, 0.356567144475165, 0.33505371123354044, 0.6345249941381377, 0.6390652213187376, 0.670741336626226, 0.6908971178001544, 0.7211428268401039, 0.6505724388063847, 0.6594897705970455, 0.6722369752038247, 0.5954709995244911, 0.30138717019220274, 0.2506666386970442, 0.17077502319863325, 0.2766159110119387, 0.2583863243928468, 0.2486227570531081, 0.22343897591620754, 0.22481833848083166, 0.24419147928943485, 0.19954924188504664, 0.1794829228279703, 0.24453000206990383, 0.27590093643370917, 0.2114104888818843, 0.1753224702194175, 0.19394656697793655, 0.2329344871204534, 0.2050824469588527, 0.10944525477088696, 0.10273707640445007, 0.17019746149574078, 0.19082541296227662, 0.18545952498592355, 0.1592943746486375, 0.24893696343031857, 0.23243907765304417, 0.2590322934330477, 0.30966426225043786, 0.3824699575947841, 0.3510097633141075, 0.32636211345192145, 0.26584257413138923, 0.30007516493470787, 0.40332387535511494, 0.18094860844280858, 0.3694460084891077, 0.08330134578563453, 0.06312006364629963, 0.06637732579530076, 0.13685155104926472, 0.10652489502064932, 0.06044031936652661, 0.10679098239181095, 0.100665788875687, 0.048061700976488875, 0.16563810836140969, 0.2328140580845558, 0.1986372003699326, 0.22497673171472898, 0.23063658651435903, 0.23293151270662926, 0.2071432624839441, 0.210731080456952, 0.2589702923638404, 0.5958373823497756, 0.5423428879530064, 0.6044729341235706, 0.5438377327466064, 0.521250545188798, 0.5772440681634904, 0.5909859907964627, 0.5598847415358801, 0.5590901454572645, 0.08532650774179451, 0.08754483577047589, 0.08388774072279426, 0.0901325728166188, 0.08320985250885438, 0.08450794988705945, 0.09862077852537898, 0.11118875193121458, 0.09575906263382694, 0.2232983615222337, 0.17987902217438534, 0.31040704635930505, 0.2936029080016016, 0.1335223957827929, 0.17912312978965184, 0.2239670638349872, 0.17411938496001567, 0.19132839216816344, 0.321404846889617, 0.3537403233523556, 0.30867116535011496, 0.27583388574895784, 0.2962086593946974, 0.28534519487646504, 0.3068494107575832, 0.3464668559254078, 0.33916739437083, 0.24100378014643242, 0.2598969710442788, 0.24357616423102801, 0.23010496900177135, 0.19026157786134457, 0.2721878489188849, 0.25923206174567237, 0.2741936473074579, 0.2667378850624109, 0.19732064080284595, 0.1870150535080336, 0.18199151673312985, 0.18143901792219008, 0.1736748764231928, 0.24411030530135513, 0.19988046595708742, 0.19023224807428452, 0.21734608104843478, 0.1771433670347211, 0.19390092697883143, 0.1722351854270171, 0.17543533666176703, 0.19799041904310266, 0.19529647808487494, 0.22778987543728058, 0.184963902266844, 0.18841811100729888, 0.15747500309660367, 0.6625344199736904, 0.14848866850034104, 0.6952705960121468, 0.769268085978053, 0.17446620400389734, 0.19233877634548113, 0.19845165226196848, 0.17765092129432758, 0.6626191792302003, 0.7014305388081421, 0.7128674749242259, 0.18599567895553704, 0.6554241193383683, 0.18470065332108876, 0.21025538203031735, 0.5877002053278664, 0.19529973674659618, 0.19899958225753167, 0.1895279318097134, 0.16880043153032476, 0.17797747162244726, 0.18290275837798387, 0.17182336739685433, 0.17383236844581684, 0.16357255700662277, 0.18693431039592556, 0.06678468531969406, 0.07753276589403135, 0.07119558611785703, 0.06655491543935366, 0.08047568360016122, 0.06057778666792146, 0.07846783895088938, 0.07025794282572573, 0.07320740633135336]}, "mutation_prompt": null}
{"id": "692560c3-0cfa-48bc-a572-7a84152f2f88", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.8 + 0.2 * np.random.rand()  # Dynamic crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Improve balance between exploration and exploitation by dynamically adjusting crossover probability.", "configspace": "", "generation": 27, "fitness": 0.3040915538953785, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.22.", "error": "", "parent_id": "b528cdd5-a900-4b58-bad9-91ba2bbb9506", "metadata": {"aucs": [0.6927035525539844, 0.7268105866480192, 0.7086046443871492, 0.7217600231473864, 0.7123793946784405, 0.7388975854904614, 0.6626766011319757, 0.712371836899496, 0.7027112959613657, 0.5347076602074574, 0.4754932987347281, 0.5096971225610675, 0.514036444921584, 0.539569039175839, 0.4794657814847888, 0.47348200047568556, 0.5332663068386843, 0.515270662356357, 0.10104462254154134, 0.1156257468754569, 0.09689929070344772, 0.12545048279224957, 0.11631970643317091, 0.09493588714711876, 0.10372759370609452, 0.10379601619281253, 0.1077178394472601, 0.09186947653914646, 0.10361483404364702, 0.10261485159359929, 0.09224301274872193, 0.0799283032773428, 0.10982300087581465, 0.11102009504717536, 0.10211547611128968, 0.11872358378615755, 0.9388378679689441, 0.9511864204367007, 0.9124864417265387, 0.9265196476583376, 0.9208822499516176, 0.9646768236183778, 0.9894835515479545, 0.8919034860939709, 0.9349249724642921, 0.34688941739310375, 0.3948705369869826, 0.36714595297277, 0.4000711662094968, 0.4103024870795319, 0.3647495685523492, 0.3676862925966513, 0.39724347402408133, 0.4057412570912454, 0.6808399697984994, 0.5623000072177327, 0.6098029897067931, 0.6632470218045882, 0.6231394941502428, 0.6045342103172305, 0.7332987059798775, 0.630141955523124, 0.6290502613995921, 0.26117899905313424, 0.23281457611532053, 0.22835638046124485, 0.18542231182065638, 0.2940790613803075, 0.18125762040508442, 0.19566946896467974, 0.24068565544090392, 0.2588231317831464, 0.2589259902505653, 0.24761861538048102, 0.16228453928267517, 0.21307517263826936, 0.31029753220189593, 0.20276676525408355, 0.2567855141166969, 0.22312904188401805, 0.2928006051631573, 0.23236901228758944, 0.22816007380549974, 0.20530162420472875, 0.26501570902183913, 0.18034445530748422, 0.18439189037018344, 0.2450209896679214, 0.24863553781911585, 0.14868985799494117, 0.20508501455271366, 0.31980400948568954, 0.3274979510244975, 0.3123378525058381, 0.07324712543542333, 0.24134964748425614, 0.4164062558405468, 0.36772854429811697, 0.26357935974951974, 0.1551660114214063, 0.0762974867367362, 0.0895647842535503, 0.11233833987524833, 0.055189228702020365, 0.14657272288386247, 0.10610442031174316, 0.12624229520777153, 0.10485731528026698, 0.22225187136871916, 0.29349052748868354, 0.21924175599432782, 0.22852120960708389, 0.24280063225231907, 0.21151257549445057, 0.2722332326404051, 0.24161254531377496, 0.2148778898648066, 0.5912047603885074, 0.5599484759500937, 0.5976988357400121, 0.5730322143396038, 0.5186510822350774, 0.5690343056529956, 0.6123662699087398, 0.5201156755503176, 0.5756572267212708, 0.0864393454476845, 0.09033525858124192, 0.0832667696074808, 0.08386520729525149, 0.09065149432209296, 0.0963355193462625, 0.09640106196192177, 0.08446232953839317, 0.11170611994587254, 0.16993979607458443, 0.25033347088192526, 0.15426624812988576, 0.29344281475305356, 0.2413273165863239, 0.1177299510285571, 0.1624453466694591, 0.22934770554736472, 0.19093948311007902, 0.3007839972123204, 0.3334697598177935, 0.28507620676816103, 0.2934102363790687, 0.3104867185915263, 0.32842007470495427, 0.38675553766332416, 0.3213061215472899, 0.3224889428129609, 0.261292161953639, 0.2982191121183474, 0.2449267214649098, 0.2445865253278956, 0.2767357795295129, 0.22516966130000038, 0.2414164307472222, 0.2618216952504745, 0.31185500459625637, 0.18702398019220445, 0.19199915039067594, 0.2008287385631865, 0.18050592024473322, 0.19626898080987776, 0.18772731395903397, 0.18087685510137808, 0.19365186397999878, 0.18162701233492273, 0.212473959259197, 0.18298251301652635, 0.23552690225259942, 0.22537104574372435, 0.19143344934858098, 0.2159440119538678, 0.2985005226255819, 0.16382329605794987, 0.17053292779811968, 0.1704240151242542, 0.16845150463866299, 0.15210344834102707, 0.15801603808056153, 0.7035757894331712, 0.16950108086758575, 0.6647674599188858, 0.19765357226130065, 0.1821183567557808, 0.15725850892187077, 0.14633388946358938, 0.19918267139201085, 0.12034228361119548, 0.1216148549982623, 0.5847962828653244, 0.20959009741513424, 0.10912662447541621, 0.19721700589536206, 0.18489418995289664, 0.19879503110111596, 0.1882952497468111, 0.21226136267784523, 0.1840361657407299, 0.2036103006960398, 0.18788820934817863, 0.1846581099322514, 0.18938311841573396, 0.06799938043125364, 0.08206378227470601, 0.06841615053325822, 0.0774557270346451, 0.0668492051814088, 0.07740498183294164, 0.06831544446199767, 0.06975790041619234, 0.08021400549593383]}, "mutation_prompt": null}
{"id": "e7e7388a-7a00-49a6-a81f-543c9f1ae85d", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.05 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Refine adaptive local search perturbation to enhance convergence speed.", "configspace": "", "generation": 28, "fitness": 0.30960128740255516, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.22.", "error": "", "parent_id": "b528cdd5-a900-4b58-bad9-91ba2bbb9506", "metadata": {"aucs": [0.7123371039182472, 0.7236694892245523, 0.6584966878847289, 0.7447154803528454, 0.6973469313329221, 0.7334112632142438, 0.7122764732107887, 0.7111216050589246, 0.6909507669117401, 0.5070288552362854, 0.5412999460972707, 0.4806363509358701, 0.5142661119399154, 0.5232852337081271, 0.5057360299441274, 0.5539534094525203, 0.5293128703400083, 0.5475398369560709, 0.09443627839482682, 0.12440553080411088, 0.11112564935281477, 0.10498412968486392, 0.11555914462532169, 0.10059265728322153, 0.10386352432801671, 0.09866861268869687, 0.10224533192314189, 0.08393743618543392, 0.08699122344735133, 0.10895666057459763, 0.08695467137084611, 0.09192975723301733, 0.09283118581899374, 0.09948050723275015, 0.10643527935522401, 0.10254984968899461, 0.9311210046405505, 0.926417754553279, 0.9505727322492737, 0.85318899404342, 0.9404560388842041, 0.9296432664300167, 0.913938519114915, 0.9039772968747415, 0.914094791682613, 0.37115060333306715, 0.314430669775588, 0.3556939180421188, 0.37978314902769694, 0.3834342377920231, 0.3396234183568997, 0.36209929461872226, 0.3689570895469235, 0.37467564760745, 0.5402795519498766, 0.5339228391291337, 0.6917510227585927, 0.7147541512860003, 0.71271195566991, 0.5870106196495715, 0.22186000951656448, 0.6885919858292385, 0.6337894238364101, 0.34849343087820306, 0.19720239202400458, 0.20395144233723017, 0.2295456914210744, 0.24101184413846122, 0.23364609938955816, 0.28295346691789003, 0.22905299143167046, 0.3769600088784034, 0.21258813906461504, 0.17139844008515315, 0.189872891179927, 0.2372180005701946, 0.31451987155405536, 0.17436655117236388, 0.25942203376163686, 0.20083634558158192, 0.21190133303518965, 0.11285593564092555, 0.27035985206519475, 0.1944701868996025, 0.18053714108410424, 0.24818175573848977, 0.24745257681420252, 0.16332657430152742, 0.2273418560928312, 0.24862144936027875, 0.2810661356846086, 0.35406111155838305, 0.3615755829210421, 0.3229974238028718, 0.3945192406785326, 0.3946744756334396, 0.34429938153461803, 0.47521266003808493, 0.2656436945152736, 0.09934315790515846, 0.06391533332013333, 0.05471515968062157, 0.13398106437957247, 0.08576433403605788, 0.06502957806985055, 0.07789059458282477, 0.08432900566426138, 0.09459936343418007, 0.2067288551226074, 0.22105984641235377, 0.22040867066845438, 0.23714827301314334, 0.23059613233485043, 0.22581829134995746, 0.2230843853918938, 0.17321904931156584, 0.20923561359414744, 0.544271833852148, 0.5608547280372098, 0.574157712860291, 0.5806163004779484, 0.5932330049597616, 0.5461489592551425, 0.5292644084893003, 0.5595905635186971, 0.5508198891059584, 0.09770940876242307, 0.07963127387371294, 0.09651513944879175, 0.10775261021897453, 0.09235471375639048, 0.09517018205660466, 0.09865886801353996, 0.08678159466743451, 0.09770377736271807, 0.17577546745585138, 0.16433833227697126, 0.20573462296420997, 0.2218419015108708, 0.13524744424448198, 0.196021644591847, 0.19416908895560536, 0.1700382084450106, 0.2776304792693106, 0.29184141651388884, 0.3403199338490611, 0.3265829899945747, 0.2929246770404439, 0.31841126858897784, 0.3395267953591369, 0.339874625754479, 0.3475114026854428, 0.40867382666451735, 0.20365283745984641, 0.22142226190825998, 0.2685874961067398, 0.24790626658543913, 0.2530383238430056, 0.26047450290866414, 0.24383693158408382, 0.24032146288902512, 0.2553976860299365, 0.18574645030146697, 0.17773431866714762, 0.1946654487193341, 0.18004173921125877, 0.17338055686148313, 0.18067850548487363, 0.18932407012174668, 0.17320828522212472, 0.1904794161045532, 0.16634889588736224, 0.19979095353247167, 0.18144053039965524, 0.21754892237640333, 0.21545024097740395, 0.21639093938046394, 0.17901518385066917, 0.19040888581987603, 0.21362411121362535, 0.1902146525003855, 0.1757102099138823, 0.17214304373672207, 0.5730271798687607, 0.6021502684519513, 0.17876898149199383, 0.18429741264386434, 0.15732564543126104, 0.16759586896688283, 0.6477052750553128, 0.548669321988281, 0.14540247151330843, 0.19880492753380807, 0.5944067801438297, 0.24882314299976005, 0.7812264064032465, 0.6263161663892117, 0.18906080813515957, 0.19107225769579694, 0.209582713138722, 0.18682995389955714, 0.1793739804724943, 0.18527404444827922, 0.1780668056104534, 0.21352256779562573, 0.19608626199016055, 0.18296519377016118, 0.06841008800619364, 0.08071160358632534, 0.07223097463905581, 0.07714188558425172, 0.07131271905860215, 0.07040125030290456, 0.07471714280718411, 0.06682909940799453, 0.079820077274815]}, "mutation_prompt": null}
{"id": "461e08c3-b1c1-4e9b-bb00-9567fe571103", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Enhance global exploration by introducing adaptive population size based on the remaining budget.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b528cdd5-a900-4b58-bad9-91ba2bbb9506", "metadata": {"aucs": [0.6880841906159763, 0.7336735505234593, 0.7173741735507848, 0.7347091941833751, 0.7152915670648244, 0.7493757127754836, 0.7131512625064276, 0.7246934781186185, 0.7070995638763942, 0.482225899261268, 0.5040941689044393, 0.5036463217073027, 0.4763455521626979, 0.5085673042671977, 0.4962875748696043, 0.5393873290992249, 0.4974296065525253, 0.5196157277314157, 0.12572102761163373, 0.10154169273186309, 0.09230874706524261, 0.09385960444595198, 0.09899388880055249, 0.10929800132210932, 0.1039668757275849, 0.22263117568988955, 0.12444162941089476, 0.11807813826681157, 0.10987379609254166, 0.10371705361591743, 0.10552427429789091, 0.12490351064104166, 0.11973847081544986, 0.09123576917485732, 0.1006178675762569, 0.0887870771539152, 0.8795959760566845, 0.9531338640433403, 0.9864252448738643, 0.8812453617372751, 0.9017769374975981, 0.883829460464581, 0.9142286121955158, 0.8864831225887614, 0.8637929549936509, 0.37720915572236813, 0.4095251153187862, 0.36166757212652223, 0.32876350667136867, 0.3277487052817071, 0.33698677669865884, 0.3572984737190972, 0.356567144475165, 0.33505371123354044, 0.6345249941381377, 0.6390652213187376, 0.670741336626226, 0.6908971178001544, 0.7211428268401039, 0.6505724388063847, 0.6594897705970455, 0.6722369752038247, 0.5954709995244911, 0.30138717019220274, 0.2506666386970442, 0.17077502319863325, 0.2766159110119387, 0.2583863243928468, 0.2486227570531081, 0.22343897591620754, 0.22481833848083166, 0.24419147928943485, 0.19954924188504664, 0.1794829228279703, 0.24453000206990383, 0.27590093643370917, 0.2114104888818843, 0.1753224702194175, 0.19394656697793655, 0.2329344871204534, 0.2050824469588527, 0.10944525477088696, 0.10273707640445007, 0.17019746149574078, 0.19082541296227662, 0.18545952498592355, 0.1592943746486375, 0.24893696343031857, 0.23243907765304417, 0.2590322934330477, 0.30966426225043786, 0.3824699575947841, 0.3510097633141075, 0.32636211345192145, 0.26584257413138923, 0.30007516493470787, 0.40332387535511494, 0.18094860844280858, 0.3694460084891077, 0.08330134578563453, 0.06312006364629963, 0.06637732579530076, 0.13685155104926472, 0.10652489502064932, 0.06044031936652661, 0.10679098239181095, 0.100665788875687, 0.048061700976488875, 0.16563810836140969, 0.2328140580845558, 0.1986372003699326, 0.22497673171472898, 0.23063658651435903, 0.23293151270662926, 0.2071432624839441, 0.210731080456952, 0.2589702923638404, 0.5958373823497756, 0.5423428879530064, 0.6044729341235706, 0.5438377327466064, 0.521250545188798, 0.5772440681634904, 0.5909859907964627, 0.5598847415358801, 0.5590901454572645, 0.08532650774179451, 0.08754483577047589, 0.08388774072279426, 0.0901325728166188, 0.08320985250885438, 0.08450794988705945, 0.09862077852537898, 0.11118875193121458, 0.09575906263382694, 0.2232983615222337, 0.17987902217438534, 0.31040704635930505, 0.2936029080016016, 0.1335223957827929, 0.17912312978965184, 0.2239670638349872, 0.17411938496001567, 0.19132839216816344, 0.321404846889617, 0.3537403233523556, 0.30867116535011496, 0.27583388574895784, 0.2962086593946974, 0.28534519487646504, 0.3068494107575832, 0.3464668559254078, 0.33916739437083, 0.24100378014643242, 0.2598969710442788, 0.24357616423102801, 0.23010496900177135, 0.19026157786134457, 0.2721878489188849, 0.25923206174567237, 0.2741936473074579, 0.2667378850624109, 0.19732064080284595, 0.1870150535080336, 0.18199151673312985, 0.18143901792219008, 0.1736748764231928, 0.24411030530135513, 0.19988046595708742, 0.19023224807428452, 0.21734608104843478, 0.1771433670347211, 0.19390092697883143, 0.1722351854270171, 0.17543533666176703, 0.19799041904310266, 0.19529647808487494, 0.22778987543728058, 0.184963902266844, 0.18841811100729888, 0.15747500309660367, 0.6625344199736904, 0.14848866850034104, 0.6952705960121468, 0.769268085978053, 0.17446620400389734, 0.19233877634548113, 0.19845165226196848, 0.17765092129432758, 0.6626191792302003, 0.7014305388081421, 0.7128674749242259, 0.18599567895553704, 0.6554241193383683, 0.18470065332108876, 0.21025538203031735, 0.5877002053278664, 0.19529973674659618, 0.19899958225753167, 0.1895279318097134, 0.16880043153032476, 0.17797747162244726, 0.18290275837798387, 0.17182336739685433, 0.17383236844581684, 0.16357255700662277, 0.18693431039592556, 0.06678468531969406, 0.07753276589403135, 0.07119558611785703, 0.06655491543935366, 0.08047568360016122, 0.06057778666792146, 0.07846783895088938, 0.07025794282572573, 0.07320740633135336]}, "mutation_prompt": null}
{"id": "d04d17a1-8ac0-4033-a108-da926615a588", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0) * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Introduce adaptive mutation factor and local search adjustment based on evaluations to enhance exploitation.", "configspace": "", "generation": 30, "fitness": 0.3140061756722242, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.", "error": "", "parent_id": "b528cdd5-a900-4b58-bad9-91ba2bbb9506", "metadata": {"aucs": [0.7426341853045109, 0.7225055900794927, 0.7409797415338677, 0.7317052492069891, 0.7676152059055499, 0.7708827012276177, 0.7425910469797085, 0.73199843265735, 0.7468458652666932, 0.6040340159138855, 0.5586656878335314, 0.5550514603375596, 0.5417244179879565, 0.5386268355326211, 0.4891938769224503, 0.5837072045388995, 0.5245776168869536, 0.564122058395884, 0.08537055927038728, 0.12424432430078358, 0.0842941289476401, 0.1168190807844347, 0.10767779074575756, 0.10677372071472213, 0.11971786011102181, 0.10906329947134819, 0.23028563877090114, 0.09115171663580313, 0.09848075027406777, 0.10915340881189628, 0.09629900947509773, 0.0837994680035079, 0.1085958318025918, 0.08566625855456056, 0.08687046314953673, 0.12075290494977675, 0.9055231477660843, 0.9465958318926612, 0.9864304589341601, 0.8755276503395327, 0.9125356579520572, 0.8613837868831612, 0.9228008955888573, 0.8884724481334145, 0.8828926900216503, 0.35335943378675216, 0.3481992099874529, 0.4000767864193665, 0.33891268434687294, 0.40342835734856586, 0.36099108490751497, 0.4368947459038547, 0.37940748561902127, 0.4091589628995592, 0.739437116575155, 0.688921105309741, 0.6486086835854755, 0.6539759891303448, 0.69999855105002, 0.6928294073580152, 0.728078853899905, 0.7371351510513434, 0.767733051506586, 0.1940370204695009, 0.22876633778394184, 0.21778836409988866, 0.2017477871529476, 0.16201941157062716, 0.25816830688642745, 0.22705950278489806, 0.30179023990150455, 0.18268331274153193, 0.18272550869535076, 0.1158449321200884, 0.2269021266068425, 0.2648151606905206, 0.22101312800403428, 0.1765589042292306, 0.21285359224861655, 0.23976116437622352, 0.11513423860087701, 0.14137730501613954, 0.1790344070788482, 0.2038163074381637, 0.2721914543510545, 0.0855035654888201, 0.10679853943875373, 0.23318817317351048, 0.2050690066215486, 0.2517214248872357, 0.25095903847850987, 0.23005050464301924, 0.33528771171405947, 0.3199836274442954, 0.16585715101484422, 0.2384332458322157, 0.3015751554040824, 0.32950872992515146, 0.2365160649755741, 0.1241826344119571, 0.043696556930082675, 0.1198138560726536, 0.10103371801439975, 0.09802396573422834, 0.10158417057809221, 0.15731998647056333, 0.13882782756298806, 0.13863805582947353, 0.242664199646888, 0.25104886022376827, 0.1960452189330918, 0.2266322954192519, 0.22841727527041789, 0.2714858033770976, 0.2608265351881034, 0.240992112366607, 0.20051003807711598, 0.6145874638988499, 0.5746110538633182, 0.5844120288253454, 0.5641099672991217, 0.5347235150893828, 0.5617305063098983, 0.5189481527993778, 0.5979471168892301, 0.5666662760871475, 0.08791948523318349, 0.10372198363213447, 0.091022351062222, 0.10724011751612073, 0.0930297960267551, 0.08998497635983493, 0.09390521247754113, 0.07997582526157021, 0.13131840419684648, 0.17006427226859722, 0.2502086323041349, 0.19971456481960803, 0.15249015971534352, 0.15443289219522227, 0.33423848515544974, 0.13897104277827388, 0.2972235526312508, 0.1734532292253742, 0.3414834769311904, 0.3664082502621091, 0.333704319227327, 0.3605587689452937, 0.32645493303572226, 0.35371671419036865, 0.3690288375913263, 0.39150856213367335, 0.3866825678913869, 0.24207911979295782, 0.26034988970084627, 0.28003422122220023, 0.2590733203055542, 0.23322435880486447, 0.2921691323529806, 0.2603851581875677, 0.3194557554853531, 0.31061760951378614, 0.1913788999360092, 0.17219087442866343, 0.1773906571142646, 0.18063694293995136, 0.1731191390529888, 0.18914569100760337, 0.22067286025397004, 0.1951172038347435, 0.1757727645212983, 0.17685003639747132, 0.18818911180006703, 0.21055227514592523, 0.33385530429592525, 0.27106516831985483, 0.1744232725424154, 0.19408350986915435, 0.3701772191218249, 0.1853857440678336, 0.1585122966470548, 0.1771713293648427, 0.1617207121823805, 0.17244443810117882, 0.7851430132783068, 0.17447667910471953, 0.19373269078736288, 0.5375720883644196, 0.18203638049433268, 0.14475250965083664, 0.10843985030706449, 0.6354895331461532, 0.5333258050411442, 0.5751782174205637, 0.19216998577581457, 0.21012829421565027, 0.436974733982725, 0.19305218351169529, 0.17878880234276462, 0.18111580104060254, 0.17999943784785533, 0.1702650715483356, 0.17702755578539053, 0.1857162647150925, 0.2035947240701691, 0.18367785773931078, 0.2029404949068655, 0.07725707439315865, 0.07093544814087749, 0.06800767681534725, 0.0943699735222906, 0.08161182416821045, 0.08201903980493097, 0.07224924343548322, 0.07835199199794429, 0.08142198992581018]}, "mutation_prompt": null}
{"id": "8006c707-600b-4152-a46a-3570cbcb5d3a", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0) * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.9 * (1 - self.current_iteration / self.budget)  # Dynamic crossover adjustment\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Enhance adaptive mutation by dynamically adjusting crossover rates based on iteration progress to improve exploration.", "configspace": "", "generation": 31, "fitness": 0.2908967192666741, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.23.", "error": "", "parent_id": "d04d17a1-8ac0-4033-a108-da926615a588", "metadata": {"aucs": [0.7206820172505297, 0.7498340913538852, 0.744511537784873, 0.7469973264745049, 0.7660639661802142, 0.7389511674561442, 0.7483400370627192, 0.7560828955798183, 0.696931683339, 0.5518477207630081, 0.5610150949281254, 0.5648699223566664, 0.5403887997375825, 0.5580950697032041, 0.5520584086549969, 0.5863289345887921, 0.5532969288250897, 0.544375963342878, 0.09960757024745648, 0.14199088916040004, 0.11951877484478013, 0.14794760880043867, 0.12368203315794457, 0.14134802862269702, 0.12589627042687845, 0.14869788271745366, 0.2292847184871245, 0.10238418775463742, 0.13140806048692955, 0.10583366887707146, 0.12191739244634758, 0.1705753954322008, 0.11856088337634141, 0.11608382007782603, 0.10983345481309681, 0.12275044091694087, 0.9495572191670508, 0.9378860377725728, 0.9864304589341601, 0.8716505605826272, 0.8922506021955375, 0.8926818491767979, 0.9141207377534103, 0.8804295637119324, 0.8934588130943159, 0.3742158117487887, 0.4119675689541604, 0.4005530849235871, 0.39179153567254044, 0.38046302532929577, 0.36589798089393755, 0.36221299238344984, 0.39305752787894266, 0.3897215865144995, 0.7192405334838731, 0.6039275516012852, 0.2131726205091652, 0.7375553015005314, 0.6060462563648004, 0.6333514863636716, 0.6171899921157222, 0.6442121925618657, 0.7166452150670319, 0.19441564531665056, 0.22708189774272092, 0.18873492463336927, 0.11871328365874012, 0.1036953508074886, 0.1440706738605133, 0.1788515676017487, 0.15399735088645705, 0.1829854810297583, 0.21060272940758462, 0.2872114085988764, 0.21085738398802323, 0.2695781355393031, 0.14861324574611368, 0.17768572106110292, 0.24046347893312892, 0.17933687212816818, 0.1115580179242972, 0.10750851256603966, 0.10283610972386736, 0.09900535989639214, 0.0343883414722741, 0.028092528186212218, 0.19054065485933713, 0.09761159784668982, 0.08408473023740282, 0.12991379506430023, 0.21795794394173928, 0.24538134764801034, 0.2021638297676428, 0.16864573394575477, 0.2103476983642043, 0.1975487733136605, 0.2623862080826026, 0.29533901048267286, 0.25411482883541026, 0.04692671931276948, 0.022136174395724795, 0.04879839297517352, 0.034284298362726395, 0.04766306803321718, 0.06499654596782634, 0.00658234991149842, 0.07329123431659479, 0.027344599718400642, 0.1730342841892054, 0.17508278972988467, 0.1613921426849798, 0.15630224181654484, 0.15938927863134467, 0.17095797028156612, 0.16916661136528222, 0.143746084670633, 0.18328326160438713, 0.5529611452983567, 0.5374744968549621, 0.4919377271092137, 0.5149294193358117, 0.5188352742951365, 0.5033762446831762, 0.4982565174273884, 0.5230939196225829, 0.46714429507515265, 0.0818615745882515, 0.09029377551276663, 0.0895676438316676, 0.08953204457943287, 0.09343634692967207, 0.08401859668830458, 0.0939845408987372, 0.09188416774199848, 0.09193401883209829, 0.17297244057348982, 0.13076418123615352, 0.1413167369109236, 0.14641956308440962, 0.14864881449788458, 0.3189969456439825, 0.1601261931967023, 0.12808697404680336, 0.13774361549457959, 0.32289102218755394, 0.33692249273459707, 0.30709535444175273, 0.3146855816499692, 0.3382284142856151, 0.27457847509242805, 0.3570173414925285, 0.4102597057157351, 0.3598628046694312, 0.19779857217451668, 0.21710748022301396, 0.21368356705776226, 0.2553677941090303, 0.20496695392861974, 0.24108256678472717, 0.25889089155951595, 0.25274991699867544, 0.2268269497203742, 0.1852687910698162, 0.17176214726915062, 0.1733716543275705, 0.20204482174659155, 0.16407888779811364, 0.18922955745808145, 0.18694165838810928, 0.1923472778667512, 0.1731963021908095, 0.2261661286660709, 0.1972029133510821, 0.1899977728242921, 0.17970003028266035, 0.19625377931702948, 0.19519425623966846, 0.18609626801423151, 0.18760111531132528, 0.17904663112420627, 0.14875074452915416, 0.1597593205813972, 0.14951527090350936, 0.1661178789714307, 0.7138569320289493, 0.1832284614859403, 0.18460566085804153, 0.15106305323114944, 0.6055376917579531, 0.7089393649249713, 0.5053595580839019, 0.623529209080507, 0.18908347255360614, 0.5726797240920348, 0.19878720082809276, 0.21014945812119257, 0.13241490667404465, 0.18956519343230982, 0.18441450002154403, 0.18744279519723706, 0.20190763587071825, 0.18158058098184315, 0.17814577469933524, 0.1767710526984092, 0.17815920649776873, 0.18700199776066806, 0.17839146319511567, 0.07691126293721884, 0.0741998344428344, 0.07365579219788343, 0.06784826516389131, 0.07993750270644762, 0.07342159888521294, 0.07829605941987205, 0.07031089057710938, 0.06885998079909672]}, "mutation_prompt": null}
{"id": "68b587ea-217e-451c-adf7-d3b8e2824f62", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0) * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Introduce adaptive mutation factor and local search adjustment based on evaluations to enhance exploitation.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d04d17a1-8ac0-4033-a108-da926615a588", "metadata": {"aucs": [0.7426341853045109, 0.7225055900794927, 0.7409797415338677, 0.7317052492069891, 0.7676152059055499, 0.7708827012276177, 0.7425910469797085, 0.73199843265735, 0.7468458652666932, 0.6040340159138855, 0.5586656878335314, 0.5550514603375596, 0.5417244179879565, 0.5386268355326211, 0.4891938769224503, 0.5837072045388995, 0.5245776168869536, 0.564122058395884, 0.08537055927038728, 0.12424432430078358, 0.0842941289476401, 0.1168190807844347, 0.10767779074575756, 0.10677372071472213, 0.11971786011102181, 0.10906329947134819, 0.23028563877090114, 0.09115171663580313, 0.09848075027406777, 0.10915340881189628, 0.09629900947509773, 0.0837994680035079, 0.1085958318025918, 0.08566625855456056, 0.08687046314953673, 0.12075290494977675, 0.9055231477660843, 0.9465958318926612, 0.9864304589341601, 0.8755276503395327, 0.9125356579520572, 0.8613837868831612, 0.9228008955888573, 0.8884724481334145, 0.8828926900216503, 0.35335943378675216, 0.3481992099874529, 0.4000767864193665, 0.33891268434687294, 0.40342835734856586, 0.36099108490751497, 0.4368947459038547, 0.37940748561902127, 0.4091589628995592, 0.739437116575155, 0.688921105309741, 0.6486086835854755, 0.6539759891303448, 0.69999855105002, 0.6928294073580152, 0.728078853899905, 0.7371351510513434, 0.767733051506586, 0.1940370204695009, 0.22876633778394184, 0.21778836409988866, 0.2017477871529476, 0.16201941157062716, 0.25816830688642745, 0.22705950278489806, 0.30179023990150455, 0.18268331274153193, 0.18272550869535076, 0.1158449321200884, 0.2269021266068425, 0.2648151606905206, 0.22101312800403428, 0.1765589042292306, 0.21285359224861655, 0.23976116437622352, 0.11513423860087701, 0.14137730501613954, 0.1790344070788482, 0.2038163074381637, 0.2721914543510545, 0.0855035654888201, 0.10679853943875373, 0.23318817317351048, 0.2050690066215486, 0.2517214248872357, 0.25095903847850987, 0.23005050464301924, 0.33528771171405947, 0.3199836274442954, 0.16585715101484422, 0.2384332458322157, 0.3015751554040824, 0.32950872992515146, 0.2365160649755741, 0.1241826344119571, 0.043696556930082675, 0.1198138560726536, 0.10103371801439975, 0.09802396573422834, 0.10158417057809221, 0.15731998647056333, 0.13882782756298806, 0.13863805582947353, 0.242664199646888, 0.25104886022376827, 0.1960452189330918, 0.2266322954192519, 0.22841727527041789, 0.2714858033770976, 0.2608265351881034, 0.240992112366607, 0.20051003807711598, 0.6145874638988499, 0.5746110538633182, 0.5844120288253454, 0.5641099672991217, 0.5347235150893828, 0.5617305063098983, 0.5189481527993778, 0.5979471168892301, 0.5666662760871475, 0.08791948523318349, 0.10372198363213447, 0.091022351062222, 0.10724011751612073, 0.0930297960267551, 0.08998497635983493, 0.09390521247754113, 0.07997582526157021, 0.13131840419684648, 0.17006427226859722, 0.2502086323041349, 0.19971456481960803, 0.15249015971534352, 0.15443289219522227, 0.33423848515544974, 0.13897104277827388, 0.2972235526312508, 0.1734532292253742, 0.3414834769311904, 0.3664082502621091, 0.333704319227327, 0.3605587689452937, 0.32645493303572226, 0.35371671419036865, 0.3690288375913263, 0.39150856213367335, 0.3866825678913869, 0.24207911979295782, 0.26034988970084627, 0.28003422122220023, 0.2590733203055542, 0.23322435880486447, 0.2921691323529806, 0.2603851581875677, 0.3194557554853531, 0.31061760951378614, 0.1913788999360092, 0.17219087442866343, 0.1773906571142646, 0.18063694293995136, 0.1731191390529888, 0.18914569100760337, 0.22067286025397004, 0.1951172038347435, 0.1757727645212983, 0.17685003639747132, 0.18818911180006703, 0.21055227514592523, 0.33385530429592525, 0.27106516831985483, 0.1744232725424154, 0.19408350986915435, 0.3701772191218249, 0.1853857440678336, 0.1585122966470548, 0.1771713293648427, 0.1617207121823805, 0.17244443810117882, 0.7851430132783068, 0.17447667910471953, 0.19373269078736288, 0.5375720883644196, 0.18203638049433268, 0.14475250965083664, 0.10843985030706449, 0.6354895331461532, 0.5333258050411442, 0.5751782174205637, 0.19216998577581457, 0.21012829421565027, 0.436974733982725, 0.19305218351169529, 0.17878880234276462, 0.18111580104060254, 0.17999943784785533, 0.1702650715483356, 0.17702755578539053, 0.1857162647150925, 0.2035947240701691, 0.18367785773931078, 0.2029404949068655, 0.07725707439315865, 0.07093544814087749, 0.06800767681534725, 0.0943699735222906, 0.08161182416821045, 0.08201903980493097, 0.07224924343548322, 0.07835199199794429, 0.08142198992581018]}, "mutation_prompt": null}
{"id": "3d234e99-dfda-4fa5-985f-afa1766e23e2", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0) * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Introduce adaptive scaling for crossover probability based on function evaluations to improve exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": 0.3339167359762169, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.24.", "error": "", "parent_id": "d04d17a1-8ac0-4033-a108-da926615a588", "metadata": {"aucs": [0.7038313688403066, 0.743928857802591, 0.7560508206163828, 0.7219173056875023, 0.7421079591792674, 0.7930009329679681, 0.7436785203822623, 0.7198040777536261, 0.7002810856294976, 0.5716574770009174, 0.5976046946297183, 0.5551544665886294, 0.5076641482355237, 0.5169063357640791, 0.5736410575901869, 0.5306148911229513, 0.592124132112893, 0.5661765801498353, 0.13241238294815627, 0.12824622145445608, 0.11783580031424368, 0.10491957026507948, 0.1046342580125793, 0.09230025528669872, 0.1048419077341417, 0.1299915749972812, 0.09644327262565544, 0.09456194348308711, 0.11358687995875827, 0.09142756080072645, 0.1312681347887541, 0.11240367198556855, 0.10033249518500487, 0.09350380506174205, 0.10979080295412291, 0.09984191722225255, 0.9051560894045779, 0.9632976144751287, 0.9748200510248832, 0.7992943671742906, 0.8917915159553417, 0.7969036232810127, 0.7854717651200025, 0.9045572965780869, 0.869078862896797, 0.40981073050894923, 0.39054194085519134, 0.33586528620035805, 0.4516489025314623, 0.39952960342178545, 0.4328168420558757, 0.39180403341474945, 0.3442268351509773, 0.3671331186038451, 0.7708797596734744, 0.7063466521852724, 0.1654311433705592, 0.7770868544110645, 0.7468771429838391, 0.7592243351409629, 0.7353826439928655, 0.8027770542701451, 0.7389399434191213, 0.19132009492168456, 0.15295347740444465, 0.19801944704503094, 0.18368703209004544, 0.22163024199770665, 0.46158734848126115, 0.4725751618198992, 0.1998041376367331, 0.2584884918087428, 0.12682122132169205, 0.12559693818602224, 0.12166217719483863, 0.19853514726888388, 0.19236616341397828, 0.1862537475463657, 0.2026620546622242, 0.18274567894096672, 0.1662998613942568, 0.17797497297901987, 0.09690963510167216, 0.43131045648053956, 0.149866827260129, 0.2868026530490929, 0.2669646766198053, 0.28110491058621734, 0.21142133324468604, 0.3044296200478086, 0.5169409408402444, 0.5357420410345979, 0.31175744367937763, 0.28695256796654545, 0.3104878383466062, 0.348263853844224, 0.11562447182728086, 0.5673393808992695, 0.34041798499657727, 0.17841555867851588, 0.17756116285745105, 0.13975626578019074, 0.14652993192510055, 0.12931233820754406, 0.20472619400575554, 0.13987375825315662, 0.17088937261732173, 0.11511523340992003, 0.2979934774877705, 0.2305033023156351, 0.28817880996134126, 0.2440622245700974, 0.262928320551588, 0.28181553873054777, 0.2239139107940581, 0.2640521464987824, 0.27690567942690036, 0.614035309276102, 0.6849386287100123, 0.5834478146294717, 0.5679522571245758, 0.5057399009824285, 0.6117795079043433, 0.6136713454880558, 0.6469069483609697, 0.5030893323883259, 0.10765812097305172, 0.14557710721624884, 0.1066813198012263, 0.08877985400805266, 0.08375221061667215, 0.09875838588656294, 0.09632607109625402, 0.11529044711661351, 0.09520686335075368, 0.20691240321366455, 0.14002034892234327, 0.18940277867314403, 0.1779527766922231, 0.43679170746698415, 0.2242536575846268, 0.34182506197949647, 0.17312750322649895, 0.15740008902877323, 0.3668125215617306, 0.3765461899629181, 0.3595349598818315, 0.33974220136115485, 0.34182489341160127, 0.3452028095802492, 0.39102524113553316, 0.39820553935598657, 0.2070738281852379, 0.2613978288863885, 0.3358346592819559, 0.28445702188795086, 0.24407623770859066, 0.2726580263374029, 0.3162090950618671, 0.25625722750680247, 0.29111062371208996, 0.2791823614229766, 0.19245891286660977, 0.1698038574206534, 0.18523224451551135, 0.1952051268588384, 0.18354833210778754, 0.21094396633175871, 0.20515853080249202, 0.23761947239850756, 0.19181738857680264, 0.2959090826093115, 0.2032900896832368, 0.18632488561585225, 0.1949472199217248, 0.3932618484986893, 0.24955991271928935, 0.1915372516889956, 0.18828752558760675, 0.20649567527103696, 0.7326344763941118, 0.8288703624240127, 0.15180777243251942, 0.7890276962747119, 0.18783379377651854, 0.17487864936737207, 0.18173828535014303, 0.6901940754593975, 0.15512320812185265, 0.7503324037743441, 0.6239534936499597, 0.6560318105886904, 0.1835106034377837, 0.19662347209131592, 0.15824635346355242, 0.21212418169610936, 0.7511630708963973, 0.1252455997141324, 0.18319298564682263, 0.19570426896787907, 0.17477714932701105, 0.1794575836521457, 0.20205543105008605, 0.18544564910009276, 0.1796305530335247, 0.1636836462628326, 0.18360693310295106, 0.08359960191145999, 0.07723762018759595, 0.07398981323313858, 0.08013813884101673, 0.08462710928568251, 0.07867534901923978, 0.07565135012624014, 0.06518677515553917, 0.07715092936900603]}, "mutation_prompt": null}
{"id": "6046febd-7dca-4fe8-9f56-e845f4c86eab", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        diversity = np.mean(np.std(self.population, axis=0))  # Calculate the diversity\n        self.F = np.random.uniform(0.5, 1.0) * (1 - self.current_iteration / self.budget) * (1 + diversity)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Improve exploration by introducing dynamic scaling of the mutation factor based on current diversity in the population.", "configspace": "", "generation": 34, "fitness": 0.13788019968997747, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.19.", "error": "", "parent_id": "3d234e99-dfda-4fa5-985f-afa1766e23e2", "metadata": {"aucs": [0.21118072508399333, 0.16359773474469985, 0.16417276237586043, 0.5115330982665678, 0.3273702129119843, 0.3651894650128571, 0.3500410513276587, 0.380341830102243, 0.33306070195966353, 0.010992757654086027, 0.015500015711862769, 0.008666376484326999, 0.011564070549748617, 0.05573876735345584, 0.016411777989523202, 0.0017875377520093494, 0.01811827812301181, 0.036055156898769924, 0.047056105758361055, 0.03616920978083127, 0.050397162916705596, 0.04769290782129776, 0.0430848161945403, 0.0423527201376479, 0.05839777047368366, 0.03793913279816552, 0.05490812682930568, 0.01712814526741535, 0.03999907073704434, 0.02152273473313604, 0.0459578522646068, 0.026713347800903287, 0.0348716445909828, 0.02386317647909819, 0.02801331773701554, 0.02556480037007136, 0.996669588457743, 0.8300066284957783, 0.9842612641380335, 0.8816786153316588, 0.9936258676136737, 0.9291596175677576, 0.9865999475940301, 0.9955230310747806, 0.9961706523937223, 0.1565799862210735, 0.10399300350126683, 0.11885169381671679, 0.18130309240490172, 0.13598411914232678, 0.07890809086402772, 0.09315206171409895, 0.12316433687285788, 0.14270263263292615, 0.16859509897247116, 0.1603803448740615, 0.11444825475186682, 0.10844133741248319, 0.15986055403193278, 0.11491826417670059, 0.1851100590385072, 0.16159561850585302, 0.14336417941568147, 0.024850173149640442, 0.008673025047756355, 0.018900930063048715, 0.05367935121469669, 0.08545256006609347, 0.05150656337169912, 0.022438575550608908, 0.07386708073748127, 0.03372973073774432, 0.10366283614613314, 0.13858141440711258, 0.10485167279622687, 0.025092512500807573, 0.025036401816075027, 0.014062358848336953, 0.006724601085408399, 0.036604687189196405, 0.021563669459154, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011131061635250572, 0.008259083065792039, 0.0021480376099931586, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02798262695825593, 0.026184046901771563, 0.059182373872052274, 0.1510906203182072, 0.08011915131453373, 0.03445711745142166, 0.09567052521593611, 0.06956890831646956, 0.05058205579433028, 9.999999999998899e-05, 0.003024523202127094, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.014801665804492381, 0.034199121912663166, 0.05068147230095288, 0.029089474148344507, 0.04153286201209572, 0.04167087376471956, 0.045020499049381435, 0.03943018716473268, 0.07335854039506173, 0.18077959875964478, 0.25180677544315244, 0.2333075221434724, 0.27452415135109454, 0.20882049739746933, 0.22894104812607963, 0.17767960475797495, 0.18712493163705568, 0.2679877518666246, 0.0491504105261249, 0.06939967094991695, 0.06086026308859216, 0.061272849532150064, 0.02986692984790207, 0.04646455930282645, 0.04248960443691718, 0.03667693592895083, 0.05787030739316301, 0.1472175854710287, 0.14176740525789078, 0.15003610182751415, 0.17497603904752523, 0.1505256064110594, 0.17183467960570453, 0.18069873276612014, 0.22095085528997416, 0.15613767271634404, 0.15312408922619325, 0.15879412793051328, 0.1630326572326699, 0.12501287989065735, 0.13855519413513906, 0.16243066340953316, 0.1472203372605101, 0.21979352931593876, 0.18001026799979591, 0.09884287742117781, 0.11109763871523681, 0.09673389990372938, 0.13989443382353606, 0.11818912074426025, 0.1174283863055462, 0.10263180875606992, 0.13061372013036265, 0.13938967518643908, 0.1458718765954573, 0.14107678921224742, 0.14276047816185222, 0.14804974737548016, 0.14581235635707868, 0.17337925790564745, 0.1632044842046786, 0.12513447945513978, 0.1301944939378773, 0.10263087826599293, 0.08605071897766903, 0.1349968611515665, 0.07470625158805155, 0.07417261270134456, 0.07494948155009784, 0.06350864369515052, 0.08391283345971856, 0.06416365561577109, 0.1407178683873812, 0.13082032677911215, 0.1475642539501656, 0.16549843285776678, 0.17566594750773823, 0.17681736629179523, 0.14935888871217906, 0.12813767929339082, 0.10918140263138243, 0.10957590916827253, 0.1443139189945054, 0.14366910700363766, 0.09824743300823624, 0.15424444049191477, 0.10950709854125129, 0.19317327782721783, 0.18339475355763157, 0.11668185837479739, 0.1785636042272466, 0.18350715073516566, 0.1711228800998782, 0.2555322312990117, 0.18752445905677595, 0.19454584050052448, 0.20501138501155547, 0.1985766127124663, 0.19001675169372256, 0.033273947192176134, 0.04756841853815763, 0.037246540929793626, 0.04068562569651368, 0.0428888158602746, 0.03405416214279233, 0.043071136923761744, 0.043403345167525864, 0.03455568698314104]}, "mutation_prompt": null}
{"id": "8dbc22af-4a4b-4bd3-9ff9-1afdca5cdba9", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0) * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget)**2 * (1 if current_fitness == 0 else current_fitness / self.fitness.min())  # Dynamic scaling\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Introduce dynamic perturbation size scaling during local search to enhance fine-grained exploration as evaluations progress.", "configspace": "", "generation": 35, "fitness": 0.3307320189997184, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.23.", "error": "", "parent_id": "3d234e99-dfda-4fa5-985f-afa1766e23e2", "metadata": {"aucs": [0.7454168834779725, 0.7458362386588677, 0.7850615762567859, 0.7585697829751044, 0.7700046830317586, 0.7901062135647396, 0.7361502593088438, 0.7216592063296874, 0.7024595061298466, 0.5692268297330298, 0.6003388779144403, 0.6264162377442823, 0.38005766446414524, 0.5562244979717458, 0.5568182546684177, 0.5712951745342784, 0.5673375336337585, 0.5764099001239489, 0.11271775037816678, 0.10867888969385053, 0.1208142328938262, 0.15145946807376875, 0.11434490322187707, 0.12295589218980107, 0.11755579299030383, 0.16210439484457073, 0.10941779540441587, 0.11168872041573252, 0.08746337993813391, 0.0910603885052409, 0.0737302683916059, 0.11319747852488604, 0.10752606113546204, 0.1029606480592804, 0.10349009520550267, 0.09602256915606977, 0.8771703735933333, 0.963250096182219, 0.9748199958543433, 0.8293331447466328, 0.8928937093256024, 0.8334560372470283, 0.7998300964449312, 0.8017886661867606, 0.8136144177589106, 0.43172844221096074, 0.47863089142490356, 0.35984037205577424, 0.3822501234283936, 0.3770049089087466, 0.47039230958249023, 0.3841781699721517, 0.37377840488607994, 0.3474732359078756, 0.22384500884587655, 0.6889696480211027, 0.21311221816563408, 0.781962650289409, 0.6843363933002383, 0.7844643610346929, 0.6846723818348743, 0.7938250190513468, 0.7864982297667407, 0.39124089687393504, 0.45742290500000937, 0.25607027104656555, 0.20983219419585408, 0.2262418738135571, 0.18642978922593179, 0.19482098656882896, 0.19005345809544483, 0.20258443546099503, 0.14183025880956557, 0.16530888539924293, 0.22826105989041112, 0.28711811345488014, 0.21978025519964062, 0.17093142026648167, 0.36913247414754136, 0.2294059548022701, 0.2055971066955622, 0.20525198499048491, 0.10417060881272666, 0.32160074602515043, 0.23501428081063336, 0.17951163209945276, 0.14178791989779072, 0.30192482065468895, 0.09666312251546116, 0.27433538737474084, 0.39263835262722446, 0.37608504607658344, 0.3712662632992907, 0.49410748813938477, 0.24780895355304533, 0.3071274824330349, 0.41694024328641954, 0.47230526098006653, 0.5741107744141957, 0.06493667249843948, 0.14495091178727182, 0.12856963946766664, 0.11496660217086441, 0.12143319983214829, 0.14660710784852404, 0.09466698562633169, 0.11370109645729609, 0.2221412445316744, 0.2187874976000197, 0.259250037058103, 0.1781126385531454, 0.22036466877817795, 0.2553190586621067, 0.23586313275534865, 0.2836158009318649, 0.25312024310137493, 0.20400447473552807, 0.5630701170592697, 0.6512590816204382, 0.6218853009855851, 0.5814176229736192, 0.6043003431888281, 0.5766398805684337, 0.5608262958037031, 0.46876590128112694, 0.6548080650592786, 0.09006850235594155, 0.10768950574931313, 0.10785384451811775, 0.09767383944284358, 0.10177774732842504, 0.10929206558831506, 0.0996533023171875, 0.0906473917870868, 0.08910573285896028, 0.12178478301668016, 0.14731686871314342, 0.2654404468767002, 0.32855221592452866, 0.3304400265583767, 0.15091530994840818, 0.2527811140458921, 0.2287207040840451, 0.17764459569959212, 0.35900809131591804, 0.35350937063694143, 0.33648546227352594, 0.36455374039043686, 0.35939645549649046, 0.36552079919268166, 0.3689891696816624, 0.39984636317011124, 0.20968308688877668, 0.30218993393436033, 0.3496346728838723, 0.3005172430182461, 0.2596557449294943, 0.31404205780895034, 0.28751966133325935, 0.28257389783002695, 0.26745508145658603, 0.31488727939250116, 0.19376439559721415, 0.16511024756090864, 0.18235820297441752, 0.20610879232047596, 0.2122761089591072, 0.19650081868243174, 0.21735016276976582, 0.17720571286303133, 0.19814034344495335, 0.17905989744941342, 0.17350034788145008, 0.18604877985161006, 0.19120710155308873, 0.2165356849289488, 0.18263711107527025, 0.39376316167527714, 0.18627876476157545, 0.18767094192225053, 0.7368257784464858, 0.8091207439875221, 0.15175415341692444, 0.7870036678263109, 0.1925692474446251, 0.18255038251726952, 0.18171905703412317, 0.7116672814722853, 0.19154130729265106, 0.7142492551704861, 0.5664831490412585, 0.6388543557874826, 0.19025442054742359, 0.19665329684602917, 0.15827207048074377, 0.21210398129152486, 0.7622870800029922, 0.12520828946921791, 0.1845705399463915, 0.1725407686220487, 0.20400725567750133, 0.19892297370745482, 0.18864876335881686, 0.17530958476313085, 0.19272102239844946, 0.18268414381030484, 0.20233587185503243, 0.08427448534934845, 0.07913139178305795, 0.0777464048009493, 0.07597179497775908, 0.07957154757623153, 0.07302337543371307, 0.07925331697424864, 0.0750597784891126, 0.07708919817720816]}, "mutation_prompt": null}
{"id": "43fafd16-fef1-4c4c-bd0e-f548acb6b83c", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0) * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.15 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())  # Increase perturbation size\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Refine local search by enhancing perturbation for improved convergence.", "configspace": "", "generation": 36, "fitness": 0.3221791101876444, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.", "error": "", "parent_id": "3d234e99-dfda-4fa5-985f-afa1766e23e2", "metadata": {"aucs": [0.7442867767054395, 0.7386552488086631, 0.7471224532208471, 0.7488878017141427, 0.7515302481724393, 0.7540427596641, 0.7772334200837182, 0.7428210546810698, 0.7215172874982361, 0.5948675884660228, 0.6121950416728221, 0.5472389495980168, 0.5465291988625045, 0.5697661206391598, 0.5733603502142463, 0.5283415299112466, 0.5408068418429381, 0.5562436378755095, 0.11586081804655857, 0.14834486572686945, 0.09926235099270542, 0.09213898687856037, 0.10947198445376871, 0.11339099386477047, 0.12080330996252686, 0.10807233388370496, 0.12905310227556854, 0.07871758394632689, 0.12307478045118936, 0.0923435094459013, 0.10375430843630418, 0.11015139151186848, 0.09465995912094272, 0.10264554640093049, 0.12070865001050823, 0.09756332093451892, 0.8303919993763215, 0.88284844119756, 0.9754694522241552, 0.8983970441093448, 0.89433950799439, 0.7918748865574723, 0.8603744572917065, 0.9059055167860042, 0.8093991061663615, 0.42256344274607316, 0.4053483552810334, 0.37427245912319773, 0.3058060112201241, 0.2992738029779721, 0.4092203376794218, 0.3901271494910379, 0.406306511583717, 0.381216029498865, 0.7100060607939096, 0.711457281187903, 0.6888154615667407, 0.7692098586437026, 0.7746818542984562, 0.7769060256532525, 0.770425413644469, 0.7435454108605652, 0.7529484376446012, 0.2128079996892246, 0.18106332884025078, 0.2603326664096679, 0.23906383917927265, 0.19499332272441583, 0.20922353782755676, 0.209459691077587, 0.17300887680202737, 0.17654221405550397, 0.11644659337168228, 0.12051500940684623, 0.12051317844028941, 0.33867051111421187, 0.14822275041550947, 0.20682583611899397, 0.2462340046930932, 0.16212454347774097, 0.1904370581011764, 0.08089946942487891, 0.3296106109321547, 0.09662427806499085, 0.028309334666396402, 0.202064053220537, 0.15263241612000034, 0.27941783063145076, 0.22054556526992752, 0.317041556426067, 0.36427233150868943, 0.11030288794749576, 0.5239485614964561, 0.517528258334558, 0.23488300482078683, 0.2486367039385594, 0.5831946725288014, 0.42572653317672826, 0.42977364598266266, 0.07632304508501697, 0.09588487583287242, 0.09955556587812175, 0.09875522511540513, 0.15984770436273432, 0.11451474578162635, 0.06594154327287471, 0.13042194244436378, 0.14728696511879558, 0.2788705478917307, 0.20171826311049879, 0.22236292644755673, 0.29546903230458466, 0.2904144039868026, 0.20549961332404232, 0.20692774194846364, 0.2628918858306821, 0.2838470792692316, 0.6188086846019993, 0.536002534557463, 0.5795388912497089, 0.47018725364910174, 0.5573143224337469, 0.5723699820451646, 0.5879854834013631, 0.5676765705955324, 0.5388336882073835, 0.08903804912846713, 0.10480790034640264, 0.09782355653905783, 0.09645469912669946, 0.12575601130431846, 0.10533279740740942, 0.10249415528283246, 0.08575753168182798, 0.10629025275439274, 0.4188489013101764, 0.1481202639946101, 0.5192167147688164, 0.1324022089860173, 0.24864027420474855, 0.16819412264251454, 0.22678748252909942, 0.19615075702113505, 0.21816211587117262, 0.3212684218756312, 0.3654938769837236, 0.36787204779793303, 0.3912970605748959, 0.35577775474973716, 0.3585237565175605, 0.34796793196778986, 0.42343966939166844, 0.3646324092961538, 0.3024436222345409, 0.3050269089220592, 0.2167247998279077, 0.29299605015020835, 0.3081783315737907, 0.30443580677716997, 0.31917302188561936, 0.30561756891644687, 0.2227033705461039, 0.19680269725896737, 0.1897695660504901, 0.21362647488556108, 0.19198519106305945, 0.16434524451769705, 0.1796713802977008, 0.20422492441045914, 0.19373178110780487, 0.17956493008926988, 0.21446414698960614, 0.19211877057214544, 0.1894556039929659, 0.28571937853498075, 0.2201231944613643, 0.1853022012154384, 0.1933158600435957, 0.24709032463292824, 0.19158701315492532, 0.19697293288769102, 0.8322855539034676, 0.1674399283548339, 0.18177956293797382, 0.18688342179840678, 0.7685082209399112, 0.18001939764695085, 0.7038257657419491, 0.1578388642149846, 0.7693833356466444, 0.19051048098424284, 0.14880324340952777, 0.19280406575836928, 0.15994198017502093, 0.6538199196699757, 0.21201960486278426, 0.1267303797712248, 0.12499232362518087, 0.18761553668869146, 0.1785314888775551, 0.18200047529227203, 0.183026713444718, 0.1919521995344169, 0.1763389953805139, 0.17915757193748816, 0.18449555154491748, 0.17994244596168718, 0.07474494485104155, 0.07133474890837166, 0.08113315936770815, 0.07705739851597737, 0.07408085349870075, 0.07309941124072283, 0.07495165333272558, 0.07605864343182966, 0.08011652266905445]}, "mutation_prompt": null}
{"id": "086b5962-3fd2-4a91-b85f-b8bc4cc14f74", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0) * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Introduce adaptive scaling for crossover probability based on function evaluations to improve exploration and exploitation balance.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3d234e99-dfda-4fa5-985f-afa1766e23e2", "metadata": {"aucs": [0.7038313688403066, 0.743928857802591, 0.7560508206163828, 0.7219173056875023, 0.7421079591792674, 0.7930009329679681, 0.7436785203822623, 0.7198040777536261, 0.7002810856294976, 0.5716574770009174, 0.5976046946297183, 0.5551544665886294, 0.5076641482355237, 0.5169063357640791, 0.5736410575901869, 0.5306148911229513, 0.592124132112893, 0.5661765801498353, 0.13241238294815627, 0.12824622145445608, 0.11783580031424368, 0.10491957026507948, 0.1046342580125793, 0.09230025528669872, 0.1048419077341417, 0.1299915749972812, 0.09644327262565544, 0.09456194348308711, 0.11358687995875827, 0.09142756080072645, 0.1312681347887541, 0.11240367198556855, 0.10033249518500487, 0.09350380506174205, 0.10979080295412291, 0.09984191722225255, 0.9051560894045779, 0.9632976144751287, 0.9748200510248832, 0.7992943671742906, 0.8917915159553417, 0.7969036232810127, 0.7854717651200025, 0.9045572965780869, 0.869078862896797, 0.40981073050894923, 0.39054194085519134, 0.33586528620035805, 0.4516489025314623, 0.39952960342178545, 0.4328168420558757, 0.39180403341474945, 0.3442268351509773, 0.3671331186038451, 0.7708797596734744, 0.7063466521852724, 0.1654311433705592, 0.7770868544110645, 0.7468771429838391, 0.7592243351409629, 0.7353826439928655, 0.8027770542701451, 0.7389399434191213, 0.19132009492168456, 0.15295347740444465, 0.19801944704503094, 0.18368703209004544, 0.22163024199770665, 0.46158734848126115, 0.4725751618198992, 0.1998041376367331, 0.2584884918087428, 0.12682122132169205, 0.12559693818602224, 0.12166217719483863, 0.19853514726888388, 0.19236616341397828, 0.1862537475463657, 0.2026620546622242, 0.18274567894096672, 0.1662998613942568, 0.17797497297901987, 0.09690963510167216, 0.43131045648053956, 0.149866827260129, 0.2868026530490929, 0.2669646766198053, 0.28110491058621734, 0.21142133324468604, 0.3044296200478086, 0.5169409408402444, 0.5357420410345979, 0.31175744367937763, 0.28695256796654545, 0.3104878383466062, 0.348263853844224, 0.11562447182728086, 0.5673393808992695, 0.34041798499657727, 0.17841555867851588, 0.17756116285745105, 0.13975626578019074, 0.14652993192510055, 0.12931233820754406, 0.20472619400575554, 0.13987375825315662, 0.17088937261732173, 0.11511523340992003, 0.2979934774877705, 0.2305033023156351, 0.28817880996134126, 0.2440622245700974, 0.262928320551588, 0.28181553873054777, 0.2239139107940581, 0.2640521464987824, 0.27690567942690036, 0.614035309276102, 0.6849386287100123, 0.5834478146294717, 0.5679522571245758, 0.5057399009824285, 0.6117795079043433, 0.6136713454880558, 0.6469069483609697, 0.5030893323883259, 0.10765812097305172, 0.14557710721624884, 0.1066813198012263, 0.08877985400805266, 0.08375221061667215, 0.09875838588656294, 0.09632607109625402, 0.11529044711661351, 0.09520686335075368, 0.20691240321366455, 0.14002034892234327, 0.18940277867314403, 0.1779527766922231, 0.43679170746698415, 0.2242536575846268, 0.34182506197949647, 0.17312750322649895, 0.15740008902877323, 0.3668125215617306, 0.3765461899629181, 0.3595349598818315, 0.33974220136115485, 0.34182489341160127, 0.3452028095802492, 0.39102524113553316, 0.39820553935598657, 0.2070738281852379, 0.2613978288863885, 0.3358346592819559, 0.28445702188795086, 0.24407623770859066, 0.2726580263374029, 0.3162090950618671, 0.25625722750680247, 0.29111062371208996, 0.2791823614229766, 0.19245891286660977, 0.1698038574206534, 0.18523224451551135, 0.1952051268588384, 0.18354833210778754, 0.21094396633175871, 0.20515853080249202, 0.23761947239850756, 0.19181738857680264, 0.2959090826093115, 0.2032900896832368, 0.18632488561585225, 0.1949472199217248, 0.3932618484986893, 0.24955991271928935, 0.1915372516889956, 0.18828752558760675, 0.20649567527103696, 0.7326344763941118, 0.8288703624240127, 0.15180777243251942, 0.7890276962747119, 0.18783379377651854, 0.17487864936737207, 0.18173828535014303, 0.6901940754593975, 0.15512320812185265, 0.7503324037743441, 0.6239534936499597, 0.6560318105886904, 0.1835106034377837, 0.19662347209131592, 0.15824635346355242, 0.21212418169610936, 0.7511630708963973, 0.1252455997141324, 0.18319298564682263, 0.19570426896787907, 0.17477714932701105, 0.1794575836521457, 0.20205543105008605, 0.18544564910009276, 0.1796305530335247, 0.1636836462628326, 0.18360693310295106, 0.08359960191145999, 0.07723762018759595, 0.07398981323313858, 0.08013813884101673, 0.08462710928568251, 0.07867534901923978, 0.07565135012624014, 0.06518677515553917, 0.07715092936900603]}, "mutation_prompt": null}
{"id": "582dd943-e275-4fb7-a358-3f379ecf0b5e", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        best_fitness = self.fitness.min()\n        self.F = np.random.uniform(0.5, 1.0) * (1 - self.current_iteration / self.budget) * (best_fitness / (best_fitness + 1e-9))  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Introduce adaptive scaling for mutation factor based on the best individual’s fitness to enhance convergence rate and solution quality.", "configspace": "", "generation": 38, "fitness": 0.3336074374485002, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.24.", "error": "", "parent_id": "3d234e99-dfda-4fa5-985f-afa1766e23e2", "metadata": {"aucs": [0.703831342791829, 0.7439288583861974, 0.7560508122001379, 0.7219173008292343, 0.7421079488088366, 0.7930009331461407, 0.7436785190170101, 0.7198040478894887, 0.7002811074761861, 0.5716804125762591, 0.5976155533935097, 0.5601764108448651, 0.5252130462239271, 0.5168958873303586, 0.5736431764233578, 0.5250756885191747, 0.5921261402266887, 0.5651508668616722, 0.13241238290187507, 0.12824622145248155, 0.11783580031278051, 0.10491957030075005, 0.10463425809373317, 0.09230025529226482, 0.10484190772109736, 0.12999157496241154, 0.09644327259154017, 0.09456194354640379, 0.11358687972401271, 0.09142756082164838, 0.13126813473344812, 0.1124036720766719, 0.10033249479728967, 0.09350380527193813, 0.10979080299076449, 0.09984191719931168, 0.9051560894514268, 0.9632976144412286, 0.9748200510241152, 0.7992943671302861, 0.8917915159553146, 0.7969036232847415, 0.7854717651173357, 0.9045572965778744, 0.8690788625579249, 0.40981078486822553, 0.3905420638007314, 0.33584425526966655, 0.45212780173280476, 0.39891064790831077, 0.4328629154692759, 0.3918040344790925, 0.3442268378613642, 0.3671331584816143, 0.7708797596734744, 0.7063466521852724, 0.1654311433705592, 0.7770868544110645, 0.7468771429838391, 0.7592243351409629, 0.7353826439928655, 0.8027770542701451, 0.7389399434191213, 0.19132009493303181, 0.15295347739586962, 0.19801944709470332, 0.18368703206660808, 0.22163022447700398, 0.46158608883550134, 0.4725751944262141, 0.19980413765412008, 0.25848849165587173, 0.12682122146138464, 0.12559693818179607, 0.12166217719367722, 0.19853514582287923, 0.19236616330831757, 0.18625375531087263, 0.20266205469482923, 0.1827456791716474, 0.16629986102613692, 0.1779749623663509, 0.09690963130523356, 0.43216798118470734, 0.1498668273303132, 0.28680269004707293, 0.2669646761385239, 0.28110493515634116, 0.21142132144439751, 0.30442963429397696, 0.5172412505662428, 0.5357415814730007, 0.3117574469542277, 0.28745679117152045, 0.3105781054137545, 0.34371924884716243, 0.11562447081441807, 0.5673398444008131, 0.34041762216478666, 0.17841555825778088, 0.17756115300258812, 0.13975626574685562, 0.14652993188262775, 0.1293123383200886, 0.20472619159738736, 0.13987375824696158, 0.1708893726231212, 0.11511523337274043, 0.29799173573044735, 0.23050329898937338, 0.28817881488507024, 0.2440690510740504, 0.2629297145479784, 0.2818148361202657, 0.22391389115455174, 0.2640521317821134, 0.27690627335294826, 0.614034983100981, 0.6849656498818064, 0.5834478559634301, 0.5679532989285421, 0.5057399397800233, 0.6118611920664282, 0.6136304936802353, 0.6469066481674774, 0.5030893364111687, 0.10765812096948935, 0.14557710721735073, 0.1066813198064841, 0.08877985402109101, 0.08375221062153437, 0.09875838586315056, 0.09632605523584992, 0.11529043099195602, 0.09520702758008426, 0.18967587289129362, 0.14003343732795326, 0.18940516479449576, 0.17795277669666287, 0.4367920235060283, 0.22425366190317264, 0.3471006046333196, 0.1725556943268326, 0.15740006203499501, 0.3668127340387334, 0.3765461656216428, 0.3595350803835492, 0.33974232727787734, 0.34182475983413174, 0.34520296286241947, 0.3910253122533134, 0.3982055285002549, 0.20707382746221903, 0.2647471010009437, 0.29428739586798636, 0.3124846951272162, 0.24407610614053, 0.272658040093827, 0.3162105557558249, 0.2562572329940517, 0.2911106277167339, 0.2791823627863046, 0.17119618855258434, 0.1804075517319519, 0.1776405913405673, 0.17497615595339977, 0.18920367166312013, 0.18361145129203538, 0.20515898718203385, 0.18096437436781054, 0.19181746152632517, 0.29590908069741184, 0.20329008968279882, 0.18632488561518568, 0.19494721992174457, 0.3932618484151714, 0.24955991342549833, 0.19153725168978653, 0.18828752563492768, 0.20649567528210278, 0.7326344765334659, 0.8288703624616645, 0.15180777243295618, 0.7890277686633412, 0.18783379374764453, 0.17487864914298357, 0.18173828535016678, 0.6901940754772833, 0.1551232081218803, 0.7503324037757579, 0.6239534934959183, 0.6560318104854103, 0.18351060343825665, 0.19662347209153508, 0.15824635346347282, 0.2121241816977273, 0.751163067527837, 0.1252455997137164, 0.1804459877927631, 0.19620580034978274, 0.18679001344265966, 0.2532685775913004, 0.17781710149071062, 0.18559424596029317, 0.17963055002938566, 0.16368364612405362, 0.1836069330738993, 0.0835996000235184, 0.07723762032344528, 0.0739898134675463, 0.0801381390215633, 0.08462710894338121, 0.07867534900605366, 0.07565143753696324, 0.0651867745611433, 0.07715098535852394]}, "mutation_prompt": null}
{"id": "24f3fa9b-1e04-4b6a-bd25-a17810376bbb", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0) * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            # Stochastic rank-based selection\n            ranks = np.argsort(self.fitness)\n            self.population = self.population[ranks]\n            self.fitness = self.fitness[ranks]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Introduce stochastic rank-based selection to improve the selection pressure and convergence speed.", "configspace": "", "generation": 39, "fitness": 0.32673572988951644, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.23.", "error": "", "parent_id": "3d234e99-dfda-4fa5-985f-afa1766e23e2", "metadata": {"aucs": [0.7071230733442735, 0.7286033729471706, 0.7522774078725741, 0.7290061984709737, 0.7518591594253594, 0.7686113882072763, 0.7055860149564429, 0.7559011257234318, 0.663401317918419, 0.5993242434755304, 0.5670892491872161, 0.5879356540687366, 0.5572811048464199, 0.42176655850122635, 0.5399124682771821, 0.5095879683014938, 0.5941599708993616, 0.5724950159708447, 0.11164545871302489, 0.1355930517468139, 0.11869545166823614, 0.28055595948411005, 0.12751902067687804, 0.12916448891258603, 0.16180162619706118, 0.13025221012800126, 0.14561282404253928, 0.09865611697168919, 0.09175848714321144, 0.10613658106531365, 0.12418156500746458, 0.10224149232171331, 0.10780176991228219, 0.10290067668875968, 0.10277274099066724, 0.1009333065545206, 0.872244909285226, 0.8597987136457911, 0.9149929476049223, 0.8195914616782634, 0.8630881900949686, 0.93122643528624, 0.8030591618103955, 0.9367326245324699, 0.8234713109011851, 0.4169960780551273, 0.41212559526416803, 0.36547390492177734, 0.4116633793622799, 0.45880816903069965, 0.5112903717184247, 0.3948924442749254, 0.39885702888225394, 0.3950072810900227, 0.7394491661883019, 0.7464288296358381, 0.7421347981173386, 0.7018334374504307, 0.7824869461842874, 0.1951730786188377, 0.7210038940753871, 0.7357332778536039, 0.7027429191425485, 0.22094468831333947, 0.2107831086292834, 0.22090247961476606, 0.26856342651909215, 0.22957742314393126, 0.18806103305513855, 0.19512105919067146, 0.1980818783105036, 0.17706957593447115, 0.15190715602572813, 0.30645803433272434, 0.2364837398459485, 0.18471236572546756, 0.1820981479804089, 0.20268154947408012, 0.19329467139555945, 0.19708205421724223, 0.1885165899479445, 0.1715121491915581, 0.14750327425855536, 0.23434147581141684, 0.33854417630887346, 0.16762735056251987, 0.22705276201798563, 0.19989691617152694, 0.3787580408540413, 0.2537859057009221, 0.30501091000079783, 0.3566700763181784, 0.45250594925841525, 0.2859362603045795, 0.2160405340817514, 0.35707505212679536, 0.5067174365344441, 0.5954603443264568, 0.48653404580015314, 0.05823991043198007, 0.11033361743863845, 0.054802298887350887, 0.22474555124584972, 0.11537111871383365, 0.06956905596358576, 0.11037860972260738, 0.13493053133408828, 0.17141906420930586, 0.23621617436867037, 0.232594500983489, 0.32045770450239686, 0.29011795023035947, 0.28425624988434994, 0.2319610920682199, 0.24802903924997544, 0.23561608956599167, 0.23922198934604144, 0.5845517058802839, 0.6073789790731879, 0.6637292857908232, 0.6213894159160734, 0.5897252873579163, 0.5964804660108387, 0.5898207432901066, 0.555504134356912, 0.5471707967607768, 0.09113406057672768, 0.1045531646165817, 0.08626428302380629, 0.0967560442194636, 0.11709168690770799, 0.11264799518862734, 0.09136177968904213, 0.09326738796952783, 0.08900727172374423, 0.4201496469252226, 0.18191741332882627, 0.19973300241926428, 0.1553824121646672, 0.47804607308439595, 0.19224896972673067, 0.2563960884354849, 0.21598262326887008, 0.3471259284086371, 0.32535846973108806, 0.35448527850492373, 0.3484252333643376, 0.36306923669982083, 0.3418769231107085, 0.36650148081910905, 0.33154449240582606, 0.40354275893695846, 0.3616197890062053, 0.2786409327314352, 0.2653754142852467, 0.30547815242011656, 0.26168096416091635, 0.2855528918305529, 0.2837241179062102, 0.2953867087232679, 0.31405731055568253, 0.26425819869738787, 0.18753901397032102, 0.20407623863130775, 0.2066855376191553, 0.18935202118446126, 0.2016934873798768, 0.17432060571023433, 0.18051623088305424, 0.199359352465466, 0.20900177973116574, 0.21397939688031142, 0.21057489341070024, 0.46471397895065314, 0.20647872889097585, 0.20179410408697873, 0.20969113282872243, 0.193363887410121, 0.18221769533354648, 0.18582506724022352, 0.15709281376806572, 0.6975524359421159, 0.15085233986897761, 0.17222802674877424, 0.19242019089734697, 0.18219607710170171, 0.17903571011457442, 0.18953603895623528, 0.1844214407092033, 0.7188000689593794, 0.1659752723351856, 0.6168777566498038, 0.1813394330413095, 0.15905992989650108, 0.7088098793967588, 0.20670672218904707, 0.699859717168222, 0.1575086106180843, 0.18888356135022655, 0.1780072726677554, 0.1999068077703129, 0.18946403981670223, 0.19640130878591, 0.17666915012617412, 0.1720973909648177, 0.18009653790550384, 0.18353849479380702, 0.06972965503667661, 0.08031875792241738, 0.08868166874683336, 0.07467177808620395, 0.07088629362701848, 0.07381111295475784, 0.07453786971176724, 0.06908719088289494, 0.083255483256655]}, "mutation_prompt": null}
{"id": "f5c03118-cfcd-4dd5-ae37-965986c2b959", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0) * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Introduce adaptive scaling for crossover probability based on function evaluations to improve exploration and exploitation balance.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3d234e99-dfda-4fa5-985f-afa1766e23e2", "metadata": {"aucs": [0.7038313688403066, 0.743928857802591, 0.7560508206163828, 0.7219173056875023, 0.7421079591792674, 0.7930009329679681, 0.7436785203822623, 0.7198040777536261, 0.7002810856294976, 0.5716574770009174, 0.5976046946297183, 0.5551544665886294, 0.5076641482355237, 0.5169063357640791, 0.5736410575901869, 0.5306148911229513, 0.592124132112893, 0.5661765801498353, 0.13241238294815627, 0.12824622145445608, 0.11783580031424368, 0.10491957026507948, 0.1046342580125793, 0.09230025528669872, 0.1048419077341417, 0.1299915749972812, 0.09644327262565544, 0.09456194348308711, 0.11358687995875827, 0.09142756080072645, 0.1312681347887541, 0.11240367198556855, 0.10033249518500487, 0.09350380506174205, 0.10979080295412291, 0.09984191722225255, 0.9051560894045779, 0.9632976144751287, 0.9748200510248832, 0.7992943671742906, 0.8917915159553417, 0.7969036232810127, 0.7854717651200025, 0.9045572965780869, 0.869078862896797, 0.40981073050894923, 0.39054194085519134, 0.33586528620035805, 0.4516489025314623, 0.39952960342178545, 0.4328168420558757, 0.39180403341474945, 0.3442268351509773, 0.3671331186038451, 0.7708797596734744, 0.7063466521852724, 0.1654311433705592, 0.7770868544110645, 0.7468771429838391, 0.7592243351409629, 0.7353826439928655, 0.8027770542701451, 0.7389399434191213, 0.19132009492168456, 0.15295347740444465, 0.19801944704503094, 0.18368703209004544, 0.22163024199770665, 0.46158734848126115, 0.4725751618198992, 0.1998041376367331, 0.2584884918087428, 0.12682122132169205, 0.12559693818602224, 0.12166217719483863, 0.19853514726888388, 0.19236616341397828, 0.1862537475463657, 0.2026620546622242, 0.18274567894096672, 0.1662998613942568, 0.17797497297901987, 0.09690963510167216, 0.43131045648053956, 0.149866827260129, 0.2868026530490929, 0.2669646766198053, 0.28110491058621734, 0.21142133324468604, 0.3044296200478086, 0.5169409408402444, 0.5357420410345979, 0.31175744367937763, 0.28695256796654545, 0.3104878383466062, 0.348263853844224, 0.11562447182728086, 0.5673393808992695, 0.34041798499657727, 0.17841555867851588, 0.17756116285745105, 0.13975626578019074, 0.14652993192510055, 0.12931233820754406, 0.20472619400575554, 0.13987375825315662, 0.17088937261732173, 0.11511523340992003, 0.2979934774877705, 0.2305033023156351, 0.28817880996134126, 0.2440622245700974, 0.262928320551588, 0.28181553873054777, 0.2239139107940581, 0.2640521464987824, 0.27690567942690036, 0.614035309276102, 0.6849386287100123, 0.5834478146294717, 0.5679522571245758, 0.5057399009824285, 0.6117795079043433, 0.6136713454880558, 0.6469069483609697, 0.5030893323883259, 0.10765812097305172, 0.14557710721624884, 0.1066813198012263, 0.08877985400805266, 0.08375221061667215, 0.09875838588656294, 0.09632607109625402, 0.11529044711661351, 0.09520686335075368, 0.20691240321366455, 0.14002034892234327, 0.18940277867314403, 0.1779527766922231, 0.43679170746698415, 0.2242536575846268, 0.34182506197949647, 0.17312750322649895, 0.15740008902877323, 0.3668125215617306, 0.3765461899629181, 0.3595349598818315, 0.33974220136115485, 0.34182489341160127, 0.3452028095802492, 0.39102524113553316, 0.39820553935598657, 0.2070738281852379, 0.2613978288863885, 0.3358346592819559, 0.28445702188795086, 0.24407623770859066, 0.2726580263374029, 0.3162090950618671, 0.25625722750680247, 0.29111062371208996, 0.2791823614229766, 0.19245891286660977, 0.1698038574206534, 0.18523224451551135, 0.1952051268588384, 0.18354833210778754, 0.21094396633175871, 0.20515853080249202, 0.23761947239850756, 0.19181738857680264, 0.2959090826093115, 0.2032900896832368, 0.18632488561585225, 0.1949472199217248, 0.3932618484986893, 0.24955991271928935, 0.1915372516889956, 0.18828752558760675, 0.20649567527103696, 0.7326344763941118, 0.8288703624240127, 0.15180777243251942, 0.7890276962747119, 0.18783379377651854, 0.17487864936737207, 0.18173828535014303, 0.6901940754593975, 0.15512320812185265, 0.7503324037743441, 0.6239534936499597, 0.6560318105886904, 0.1835106034377837, 0.19662347209131592, 0.15824635346355242, 0.21212418169610936, 0.7511630708963973, 0.1252455997141324, 0.18319298564682263, 0.19570426896787907, 0.17477714932701105, 0.1794575836521457, 0.20205543105008605, 0.18544564910009276, 0.1796305530335247, 0.1636836462628326, 0.18360693310295106, 0.08359960191145999, 0.07723762018759595, 0.07398981323313858, 0.08013813884101673, 0.08462710928568251, 0.07867534901923978, 0.07565135012624014, 0.06518677515553917, 0.07715092936900603]}, "mutation_prompt": null}
{"id": "92793930-0b43-4f32-af7a-9e1721f637e3", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0) * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        # Dynamic perturbation strategy for local search\n        perturbation_size = 0.05 * (1 + self.fitness.std() / (self.fitness.mean() + 1e-9))\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Introduce a dynamic perturbation strategy for local search scaling based on function fitness to enhance convergence.", "configspace": "", "generation": 41, "fitness": 0.314702351139422, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.", "error": "", "parent_id": "3d234e99-dfda-4fa5-985f-afa1766e23e2", "metadata": {"aucs": [0.7226366817186649, 0.7082833613389095, 0.7428979603030332, 0.6964968160861926, 0.764680159070672, 0.7533100955413797, 0.7150617358552118, 0.7534458374248348, 0.7076805043813539, 0.4887410341394748, 0.5515812666995912, 0.5568739388735309, 0.5418323284711313, 0.5654120316809457, 0.5551625705805698, 0.5846616094012429, 0.5919319925541444, 0.5729206614475281, 0.10216531079160918, 0.08643557870665153, 0.09108998710292637, 0.10601442000433103, 0.11296251291266912, 0.119497647343487, 0.10356755473854662, 0.10833415368660282, 0.11140681434486654, 0.10966000188312375, 0.1214159600871193, 0.07659260559743619, 0.11006068095147514, 0.08895192988939693, 0.09852800623368729, 0.10994247718588268, 0.08732200885007046, 0.09669488252694503, 0.8234438616732891, 0.9116178176932516, 0.9367523836318075, 0.8374110110430366, 0.9521573689821673, 0.7677824133364727, 0.7708381947453968, 0.8254965682079768, 0.8613265349958339, 0.4171993718234317, 0.4193336629986215, 0.4445028121283988, 0.39288379490821046, 0.38834244533646634, 0.38259543172157884, 0.4013139538954551, 0.4069951330186202, 0.4172900402976426, 0.7657283661588412, 0.6831548501141744, 0.7539619613546988, 0.5869775504566132, 0.8074989066122888, 0.7476540718615852, 0.712425874369846, 0.6718640256713702, 0.6742384271801263, 0.3424016149464517, 0.15462200517107594, 0.17012565180161365, 0.1220479599154971, 0.22325303841784128, 0.16373752056878876, 0.1493879575903294, 0.24181908091216864, 0.20089133456361363, 0.13538964033765188, 0.18963137679761932, 0.21287454439955678, 0.1531474696964571, 0.14579869500399378, 0.1203269076356479, 0.1966514936118786, 0.1174283677158795, 0.13175284369052553, 0.2577446483879976, 0.05462334769763433, 0.2286851337397332, 0.1416986390966165, 0.07175051673224153, 0.15014860575620803, 0.11994412963357104, 0.0868894592674222, 0.1267319179811448, 0.23177769331109366, 0.26783911239820357, 0.4680391156181857, 0.4125208025928422, 0.24321569700504186, 0.3489202472957351, 0.41964735602046954, 0.3679787082472976, 0.2880477470373809, 0.0873455058581214, 0.10134025961741189, 0.038474011629027194, 0.1198058651085705, 0.11470950731032648, 0.10815779125533953, 0.18562663946766034, 0.13737863470368683, 0.09730430668190515, 0.30060300073584445, 0.2966548132353014, 0.20708835041512663, 0.19334379795559975, 0.2427154359586624, 0.20738393616589046, 0.21629958603490718, 0.2737275112032096, 0.3046707757274011, 0.5489696193966678, 0.6605010524871535, 0.5303189519183613, 0.5240307678389018, 0.601108714942262, 0.48840283217072644, 0.5579622187575075, 0.5464832525332426, 0.6013326887520691, 0.08698652040313615, 0.1042373233371211, 0.10425901088208289, 0.10225561133216399, 0.08368715523338399, 0.09809836575506814, 0.08565163700043033, 0.09560862898310496, 0.08124176109585335, 0.19920850099201604, 0.1584055555559667, 0.17915808957774537, 0.16556414321961987, 0.2679531154985193, 0.148920734850034, 0.17750875526160748, 0.1598854236477104, 0.2130746247783153, 0.35625812133629675, 0.3805036392456498, 0.38144139686285583, 0.39380223338132814, 0.3925908549941317, 0.3851412711017803, 0.4128836125411447, 0.37688286059252496, 0.36652941349477464, 0.2943917376843058, 0.2836682579960669, 0.2657761206666296, 0.24226358399001913, 0.3076028193279431, 0.28847961735416106, 0.19979496997354507, 0.3610212292888708, 0.30226247317658117, 0.19607256115453398, 0.18153320036679244, 0.21145152750251894, 0.179276644125546, 0.1791754198875225, 0.1744524138362864, 0.1836009379366601, 0.17740414182125608, 0.19695625165479036, 0.2251100344679814, 0.21510636076661427, 0.18095325947555108, 0.37098891043486804, 0.2000115954915629, 0.18006483035333654, 0.1890891342246832, 0.3750929353831113, 0.19275659200791617, 0.16886325022587467, 0.7736892349139628, 0.15136142652412943, 0.17740629267289298, 0.18168832031615922, 0.75791422372715, 0.17508972517856414, 0.19448750095646383, 0.15336636721815844, 0.6973720461873367, 0.7270093263454374, 0.14832770667829576, 0.7215372248902008, 0.1874158147206626, 0.1581227441037305, 0.21199349237130405, 0.6810627364267106, 0.12392409509546487, 0.17753146498343142, 0.1695253723643425, 0.2090884224507532, 0.17944191050641423, 0.18261502060897306, 0.18625212268908686, 0.20298168834938524, 0.18631884349024075, 0.18183444237162638, 0.06586302589241622, 0.07401537748955811, 0.08277521843930413, 0.07608690382588668, 0.07289513452353202, 0.06872729865429739, 0.07353484816369604, 0.07765101428411869, 0.08157212609283537]}, "mutation_prompt": null}
{"id": "f3138d9c-9df1-481a-b3fd-114ee4378b77", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0) * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_factor = 0.05 + 0.05 * (1 - self.current_iteration / self.budget)  # Dynamic perturbation factor\n        perturbation_size = perturbation_factor * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Introduce a dynamic local search perturbation factor to enhance convergence speed while maintaining exploration capability.", "configspace": "", "generation": 42, "fitness": 0.3293670073098214, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.24.", "error": "", "parent_id": "3d234e99-dfda-4fa5-985f-afa1766e23e2", "metadata": {"aucs": [0.7283379827969573, 0.7615975381091992, 0.7472093916159208, 0.7179576158542904, 0.7303777055643978, 0.7827379982316848, 0.7339336948401215, 0.7331512795361881, 0.7057545156134379, 0.5549385026747943, 0.5779154919429643, 0.5569620320534632, 0.58525905436887, 0.5843837423904419, 0.5363534746294019, 0.5442574441588646, 0.6423555021916049, 0.5760228053554772, 0.10417147959972117, 0.11228321783983375, 0.1209586094413031, 0.10491859161460304, 0.133735523494245, 0.10637914167129525, 0.10532755597362142, 0.09862544193200551, 0.11425405640034425, 0.10487985942045619, 0.09068499618841452, 0.11110309060101808, 0.11798431621929961, 0.10989082220192847, 0.0861109396849199, 0.09007745737618422, 0.13725109563988658, 0.104650598000255, 0.9051449346401491, 0.9633247879576813, 0.974820078715863, 0.8321615826107513, 0.8921803856800222, 0.8207334878779056, 0.7865028876262126, 0.8290582391434311, 0.8679707978884983, 0.46149523533677916, 0.47550803329793456, 0.37782077912866563, 0.3839098618404412, 0.4032021223919211, 0.40815985617241235, 0.32469995170782917, 0.3334475882751148, 0.4554047303897677, 0.7901752658775251, 0.7342808273692409, 0.1654311433705592, 0.6255280952497121, 0.6837585423320502, 0.8081544241936427, 0.7535125662520794, 0.7107114260713642, 0.7885287917677285, 0.18086409549133797, 0.15488688789335991, 0.16140260223888492, 0.20503527075972694, 0.18543108746381642, 0.15997708063970928, 0.22742693340344766, 0.4356081080400216, 0.20592863130537586, 0.14741056104069283, 0.13953006335751794, 0.15315307317981464, 0.24274362683127382, 0.18648555122490462, 0.20395188372894546, 0.16541986896188787, 0.19306886463795536, 0.19105546356643532, 0.09425865786112608, 0.24134552163792589, 0.28244807889707657, 0.03266651384136132, 0.22041033112245323, 0.21537996425092687, 0.27253607990057416, 0.14472307617213487, 0.34308041237548803, 0.42363953765021056, 0.42377550089922256, 0.4379941403720309, 0.2954765061061435, 0.3724772463173731, 0.44479453653922885, 0.41385440469679935, 0.4561909702237886, 0.43066933837619714, 0.1544866046812462, 0.06660317221587486, 0.09280206626908694, 0.1093512620482483, 0.10367402992776786, 0.1095593720406649, 0.10430715420195791, 0.12063238904371698, 0.14732269445609547, 0.24446641186491502, 0.26151760219934206, 0.2255611687796335, 0.2243453564903063, 0.23384482982537302, 0.24792661314382936, 0.16241415331885878, 0.21498022044234844, 0.26624646204878233, 0.7028818368979763, 0.5777751877185049, 0.515834004806718, 0.5270439817075239, 0.5783971077230002, 0.5209944896731199, 0.591854751488165, 0.5922186671747904, 0.5777929559403135, 0.11408666598717154, 0.09625182123469767, 0.12853326432411738, 0.1251157513350747, 0.07972591148149821, 0.10958311786403008, 0.10234680655122907, 0.11183058917054767, 0.09364095058989019, 0.1674743662167013, 0.14273504261876047, 0.19165603775969953, 0.4582565277024423, 0.21665424429605706, 0.13602924715765363, 0.4577906677631729, 0.1831003011588428, 0.1804167512213709, 0.37239661256159806, 0.3846713619270745, 0.36434433882237227, 0.34486957136611074, 0.32671395902736633, 0.3928065128075541, 0.37605874629925506, 0.3764784715857299, 0.20773430037670515, 0.2674297201671816, 0.3084622166048191, 0.2738579158820422, 0.27710086093187936, 0.29446746089445675, 0.310707173059239, 0.2505339457890645, 0.28436685054027644, 0.3007093848205573, 0.18961201595627786, 0.20348796477740316, 0.19572945266184338, 0.17312606600413005, 0.17828391151895118, 0.18664940896623283, 0.23903642369731892, 0.20663221786513253, 0.20287856280441097, 0.26415072902112247, 0.18633750858729736, 0.18428719003555938, 0.23491840502931882, 0.17886417838849755, 0.2877200395226851, 0.287541273088588, 0.19886785253475414, 0.2232542355775713, 0.7396903297412704, 0.8033233232406405, 0.1518473762306587, 0.7851943225445018, 0.18907162728501647, 0.1746208016714208, 0.18173700741548227, 0.7006593854957902, 0.15512037939916423, 0.690053462265418, 0.6289753217639693, 0.6340811258889223, 0.18413636377084763, 0.1966065983150952, 0.15824522884949732, 0.21213614316725415, 0.7806310921861613, 0.12518251022926274, 0.18267975177653573, 0.17201405898531485, 0.19494846280266065, 0.16942257428057506, 0.18411059008921604, 0.18664876029265254, 0.18522853277840012, 0.19057041286833132, 0.21007278636727744, 0.07738465163427588, 0.06995859482619693, 0.06368709524626026, 0.0839979549840737, 0.08540929611523129, 0.0635468727705556, 0.08315979257222894, 0.07921894957542785, 0.07123313203648196]}, "mutation_prompt": null}
{"id": "cf3be063-73de-494f-a06a-45c6477e0451", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0) * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size * (self.budget - self.current_iteration) / self.budget, perturbation_size, self.dim)  # Adjusted perturbation\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Enhance local search with adaptive perturbation based on remaining evaluations to improve convergence.", "configspace": "", "generation": 43, "fitness": 0.33282442182376926, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.24.", "error": "", "parent_id": "3d234e99-dfda-4fa5-985f-afa1766e23e2", "metadata": {"aucs": [0.728685309492388, 0.7825031622842424, 0.7446348612841571, 0.7286402918928883, 0.7624778805853348, 0.7806094552693291, 0.7697038923553211, 0.7272601961854303, 0.7022658963598003, 0.5311377386780971, 0.5173935192639655, 0.6056137554649333, 0.5632902899404548, 0.5754930479830538, 0.5295686247053721, 0.5567222770999776, 0.5691804424472355, 0.545444208889833, 0.12703117439383027, 0.10767438810798413, 0.11216915664486737, 0.08387710367397028, 0.12832913067487384, 0.11348007928558146, 0.10321451317465558, 0.0886469468651192, 0.10432489436249692, 0.09498172236924451, 0.10085978701021758, 0.08865412763292424, 0.10393095494626503, 0.07998683173808918, 0.09642960346393814, 0.1113811125473192, 0.09371273633700472, 0.10212397283421193, 0.905914526631456, 0.9632132148642856, 0.9748202656513673, 0.7995218956124218, 0.8571362147198314, 0.7936774326698167, 0.8108672482232705, 0.7931419204927252, 0.8241457951495536, 0.44874636070029594, 0.37107252594197704, 0.4256782317282991, 0.45063640316527676, 0.4329879792306296, 0.4030639781741395, 0.3835861666176221, 0.40893723932401926, 0.4576963046101611, 0.7338157460661481, 0.7117218390963371, 0.2017071740275832, 0.7795119324436601, 0.709511429775014, 0.8053621888324954, 0.7495928546856958, 0.7253810934045828, 0.7530553788739469, 0.2274983956258363, 0.47365424215371255, 0.21800962210238783, 0.24224066160547264, 0.2036984484865496, 0.19379837323091764, 0.4104877725903253, 0.19134928445223243, 0.22567807096468995, 0.1600393485963898, 0.21177150888215557, 0.23017675076993904, 0.18430785324423338, 0.19589168881565933, 0.1503449179952262, 0.11426779914148277, 0.23259130669995431, 0.17527408367228126, 0.3244774357300908, 0.31279427479845534, 0.23265526704421313, 0.2630810140726533, 0.06338979986683313, 0.22344534865537213, 0.09016081868669334, 0.1966212332284415, 0.34027374309047687, 0.36805758835500646, 0.4501658774911822, 0.5407438152824308, 0.3125932308207432, 0.38294351064711174, 0.27386529221076084, 0.6521585841333395, 0.37110642626800094, 0.20152134570470948, 0.12000905385928295, 0.19353134452482768, 0.061389652395667516, 0.21710648890078832, 0.11421579649843994, 0.09037259382678053, 0.1983222423311316, 0.08524481327455069, 0.15218475674735932, 0.2459789478050427, 0.23363383630415724, 0.2541138834218324, 0.2695899410648551, 0.2875023756207531, 0.26287964390648555, 0.26942158129513905, 0.2613395013895261, 0.24909987448800208, 0.689041139922278, 0.7098804760674304, 0.5322062451149074, 0.5135901032918665, 0.6400028283807464, 0.5636732293184559, 0.6296772898102143, 0.5781081932869114, 0.5984705734608087, 0.09439335053243925, 0.0900397297352371, 0.12736367131887805, 0.08771094643723465, 0.09387301782100366, 0.08764119800093084, 0.08393086919816106, 0.10077598858022829, 0.10014696207812868, 0.17663033284295382, 0.11587401821048882, 0.15235161830920574, 0.2169719275108074, 0.22018076592812608, 0.16719686645188336, 0.2510342083318574, 0.2279895802684997, 0.18000967186960337, 0.368551757159295, 0.4213358971150606, 0.3808809893535343, 0.40644738357853016, 0.33237426346586496, 0.3751117340279758, 0.42026155543183774, 0.34220454863054606, 0.2114474253766353, 0.27750136994902075, 0.288824558716, 0.28356506181689, 0.32941175752288376, 0.28259746778126604, 0.27744374134557404, 0.32712890145863005, 0.3271375340366661, 0.31612199700574184, 0.1937196638779406, 0.1991528784389478, 0.23275500135334437, 0.18432725754129686, 0.18072145256144756, 0.19271948948318762, 0.17712355956891168, 0.19379777373197726, 0.203887058073428, 0.19636456409776115, 0.18943411955150624, 0.289343891500063, 0.21256164943385758, 0.20614290070250718, 0.25991687278887443, 0.3407005842129467, 0.4862676944409573, 0.1953018598713253, 0.7451463256856372, 0.7998012268190348, 0.15180893671467188, 0.8027715038118732, 0.18793696329277232, 0.18193655520254493, 0.1816992539072707, 0.7077121287257413, 0.18976349265358772, 0.7235959455376191, 0.49930773552712415, 0.1482133504672789, 0.1852182360213599, 0.19599381498456137, 0.15822947909839802, 0.2119681422934735, 0.761714368485878, 0.12513107188654016, 0.1887874282422508, 0.17248225654458982, 0.17169443647478688, 0.18852390113116935, 0.19031606044781324, 0.17665158144433502, 0.18628715340732105, 0.16793186757743883, 0.23115381213943742, 0.06884721019798268, 0.06863993077698072, 0.08037044342710908, 0.08025347982306341, 0.09058424992570813, 0.07335176770637841, 0.07266969164234505, 0.07688505988142191, 0.07233774521954894]}, "mutation_prompt": null}
{"id": "50d2b5c7-dae1-42de-bd37-54c615e9fa9e", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        diversity = np.std(self.population)  # Compute population diversity\n        self.F = (0.5 + diversity / 10) * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Enhance adaptive scaling by adjusting both mutation factor and crossover probability based on population diversity.", "configspace": "", "generation": 44, "fitness": 0.31815946678286966, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.23.", "error": "", "parent_id": "3d234e99-dfda-4fa5-985f-afa1766e23e2", "metadata": {"aucs": [0.7618741013826802, 0.7746520124821001, 0.6942400393322423, 0.7384336016961699, 0.6904378902410943, 0.6984381454311797, 0.7732503106519807, 0.7569517742738352, 0.758190920881464, 0.49415402191532687, 0.42223328349915656, 0.5981767384086596, 0.18686319960346476, 0.11591354391014774, 0.5547297374545851, 0.546108012394814, 0.5535103336286042, 0.07557610962802264, 0.08941605614822834, 0.13342885486588307, 0.1035145596469984, 0.12162784288766382, 0.10443002078067587, 0.10221272572802242, 0.10232390657625623, 0.12330779268471637, 0.0959392220163161, 0.11061536865387278, 0.10336007746949194, 0.12496232489692516, 0.1109222361247808, 0.09657273125008337, 0.08681093252524463, 0.0967700087286314, 0.09382598035917056, 0.12099474394986431, 0.9886701305898151, 0.8562467781090519, 0.8231308963481103, 0.7688904664925453, 0.8220163871488098, 0.9701515934563655, 0.8564202636488156, 0.8379651170781502, 0.9833498043781023, 0.4055123391093708, 0.3920821455432212, 0.3661068919098568, 0.4040929879761228, 0.4200234226453682, 0.37705174598258784, 0.4593683879246594, 0.3676430953096578, 0.3685604539009236, 0.6990739779965056, 0.21485575414088876, 0.7501435352829635, 0.7392584419239765, 0.20567289455712368, 0.7077284058464347, 0.6945975277068646, 0.7526077508761128, 0.743528397331073, 0.15926187680122272, 0.33554954334165843, 0.4641181622163195, 0.22644354568517244, 0.1968045271035579, 0.1896110756915772, 0.18837481752696517, 0.16208665218615148, 0.2059786844197502, 0.22877280796062527, 0.18787962284939907, 0.15622542167432496, 0.20321105685848917, 0.2608695603500356, 0.30387881126462357, 0.276445397918895, 0.19111590715351512, 0.2347622425583895, 0.14670501195419006, 0.3485293352314651, 0.4264436625495188, 0.06771172727922692, 0.2595117795804679, 0.14812820326124854, 0.3946766938198609, 0.1777173488749879, 0.3774692857067047, 0.4056135775745261, 0.3333386631309423, 0.2800281455538478, 0.22459759923021616, 0.28768232509321645, 0.17389842836195402, 0.3135756253295421, 0.32672701072069676, 0.4100445379317753, 0.08267967082956007, 0.0954638899759277, 0.08097924401186485, 0.14290878405838814, 0.1675527999547587, 0.11522446520986163, 0.16876569599380564, 0.1167632072927468, 0.08883909821215763, 0.29801049085413567, 0.21529504417670664, 0.2802999291864936, 0.18957553580798914, 0.3281452560720284, 0.2246962791376057, 0.24287925023662238, 0.24248385115780136, 0.2977170698126611, 0.6692596088021374, 0.5222103006160703, 0.5429015702822118, 0.6459897045492891, 0.605762668822344, 0.5443942132103927, 0.6650979558955138, 0.6333028209397888, 0.7560188852756646, 0.08783704046960539, 0.092254003328752, 0.08857202968903188, 0.11198019096249678, 0.094565002778503, 0.10646695688565688, 0.12347724920045788, 0.09514954469568093, 0.292336624729424, 0.31520922233402937, 0.2557444567163255, 0.2421452908013425, 0.4853504950737999, 0.15759821149150388, 0.20140530966018222, 0.21607220830190788, 0.27660146577806466, 0.22145975103972793, 0.31495034772133523, 0.3794465595246562, 0.40853134789798917, 0.41132044951283786, 0.37125836471882134, 0.39710231672207785, 0.35659156500854927, 0.36970672259366943, 0.3896586530594306, 0.3226384496314454, 0.31509137438614, 0.2640684479724117, 0.3154440510872266, 0.27258976096856413, 0.3825735293361572, 0.2919572977441528, 0.29086285142168145, 0.26738821389646816, 0.20133988050650597, 0.21308857596325004, 0.19622285949113216, 0.18154373609130114, 0.18373034902815988, 0.18083996718029272, 0.18246152564255513, 0.18644789894109892, 0.1741352833787161, 0.3793304898445623, 0.19261551600953875, 0.20936107748390753, 0.1779513605341646, 0.4946621026531218, 0.18865501634401705, 0.18979349530692602, 0.17869725181939045, 0.44851808810413485, 0.16743071127389975, 0.1672775458568172, 0.1936711645822181, 0.7103524056336975, 0.1824545969787409, 0.16758647699669527, 0.6592573913357351, 0.6522300529327281, 0.1364831636137369, 0.16341433619730683, 0.16147914077510883, 0.20456900013783164, 0.18181622676843268, 0.18722292003149188, 0.6778982810589296, 0.205700923227645, 0.19910046315129915, 0.20563037630830294, 0.18644109060013436, 0.19776748086144313, 0.1879946809306513, 0.1657330358135941, 0.1723061158182443, 0.17473293092540776, 0.17727200004313037, 0.17596305953959968, 0.21320567928974565, 0.12688896013220852, 0.07888200261221157, 0.09108725387333594, 0.07694737231227722, 0.07461802748266488, 0.07174890924598509, 0.09123157262194947, 0.08404630100595245, 0.08067862322638708]}, "mutation_prompt": null}
{"id": "5346cdf8-ddea-438c-91cf-262f78f77dce", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0) * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Introduce adaptive scaling for crossover probability based on function evaluations to improve exploration and exploitation balance.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3d234e99-dfda-4fa5-985f-afa1766e23e2", "metadata": {"aucs": [0.7038313688403066, 0.743928857802591, 0.7560508206163828, 0.7219173056875023, 0.7421079591792674, 0.7930009329679681, 0.7436785203822623, 0.7198040777536261, 0.7002810856294976, 0.5716574770009174, 0.5976046946297183, 0.5551544665886294, 0.5076641482355237, 0.5169063357640791, 0.5736410575901869, 0.5306148911229513, 0.592124132112893, 0.5661765801498353, 0.13241238294815627, 0.12824622145445608, 0.11783580031424368, 0.10491957026507948, 0.1046342580125793, 0.09230025528669872, 0.1048419077341417, 0.1299915749972812, 0.09644327262565544, 0.09456194348308711, 0.11358687995875827, 0.09142756080072645, 0.1312681347887541, 0.11240367198556855, 0.10033249518500487, 0.09350380506174205, 0.10979080295412291, 0.09984191722225255, 0.9051560894045779, 0.9632976144751287, 0.9748200510248832, 0.7992943671742906, 0.8917915159553417, 0.7969036232810127, 0.7854717651200025, 0.9045572965780869, 0.869078862896797, 0.40981073050894923, 0.39054194085519134, 0.33586528620035805, 0.4516489025314623, 0.39952960342178545, 0.4328168420558757, 0.39180403341474945, 0.3442268351509773, 0.3671331186038451, 0.7708797596734744, 0.7063466521852724, 0.1654311433705592, 0.7770868544110645, 0.7468771429838391, 0.7592243351409629, 0.7353826439928655, 0.8027770542701451, 0.7389399434191213, 0.19132009492168456, 0.15295347740444465, 0.19801944704503094, 0.18368703209004544, 0.22163024199770665, 0.46158734848126115, 0.4725751618198992, 0.1998041376367331, 0.2584884918087428, 0.12682122132169205, 0.12559693818602224, 0.12166217719483863, 0.19853514726888388, 0.19236616341397828, 0.1862537475463657, 0.2026620546622242, 0.18274567894096672, 0.1662998613942568, 0.17797497297901987, 0.09690963510167216, 0.43131045648053956, 0.149866827260129, 0.2868026530490929, 0.2669646766198053, 0.28110491058621734, 0.21142133324468604, 0.3044296200478086, 0.5169409408402444, 0.5357420410345979, 0.31175744367937763, 0.28695256796654545, 0.3104878383466062, 0.348263853844224, 0.11562447182728086, 0.5673393808992695, 0.34041798499657727, 0.17841555867851588, 0.17756116285745105, 0.13975626578019074, 0.14652993192510055, 0.12931233820754406, 0.20472619400575554, 0.13987375825315662, 0.17088937261732173, 0.11511523340992003, 0.2979934774877705, 0.2305033023156351, 0.28817880996134126, 0.2440622245700974, 0.262928320551588, 0.28181553873054777, 0.2239139107940581, 0.2640521464987824, 0.27690567942690036, 0.614035309276102, 0.6849386287100123, 0.5834478146294717, 0.5679522571245758, 0.5057399009824285, 0.6117795079043433, 0.6136713454880558, 0.6469069483609697, 0.5030893323883259, 0.10765812097305172, 0.14557710721624884, 0.1066813198012263, 0.08877985400805266, 0.08375221061667215, 0.09875838588656294, 0.09632607109625402, 0.11529044711661351, 0.09520686335075368, 0.20691240321366455, 0.14002034892234327, 0.18940277867314403, 0.1779527766922231, 0.43679170746698415, 0.2242536575846268, 0.34182506197949647, 0.17312750322649895, 0.15740008902877323, 0.3668125215617306, 0.3765461899629181, 0.3595349598818315, 0.33974220136115485, 0.34182489341160127, 0.3452028095802492, 0.39102524113553316, 0.39820553935598657, 0.2070738281852379, 0.2613978288863885, 0.3358346592819559, 0.28445702188795086, 0.24407623770859066, 0.2726580263374029, 0.3162090950618671, 0.25625722750680247, 0.29111062371208996, 0.2791823614229766, 0.19245891286660977, 0.1698038574206534, 0.18523224451551135, 0.1952051268588384, 0.18354833210778754, 0.21094396633175871, 0.20515853080249202, 0.23761947239850756, 0.19181738857680264, 0.2959090826093115, 0.2032900896832368, 0.18632488561585225, 0.1949472199217248, 0.3932618484986893, 0.24955991271928935, 0.1915372516889956, 0.18828752558760675, 0.20649567527103696, 0.7326344763941118, 0.8288703624240127, 0.15180777243251942, 0.7890276962747119, 0.18783379377651854, 0.17487864936737207, 0.18173828535014303, 0.6901940754593975, 0.15512320812185265, 0.7503324037743441, 0.6239534936499597, 0.6560318105886904, 0.1835106034377837, 0.19662347209131592, 0.15824635346355242, 0.21212418169610936, 0.7511630708963973, 0.1252455997141324, 0.18319298564682263, 0.19570426896787907, 0.17477714932701105, 0.1794575836521457, 0.20205543105008605, 0.18544564910009276, 0.1796305530335247, 0.1636836462628326, 0.18360693310295106, 0.08359960191145999, 0.07723762018759595, 0.07398981323313858, 0.08013813884101673, 0.08462710928568251, 0.07867534901923978, 0.07565135012624014, 0.06518677515553917, 0.07715092936900603]}, "mutation_prompt": null}
{"id": "46f9b86e-1121-48ee-b493-34b5bac09e84", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0) * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        fitness_variance = np.var(self.fitness)\n        perturbation_size = (0.1 + fitness_variance) * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Introduced dynamic perturbation scaling based on fitness variance for enhanced local search adaptability.", "configspace": "", "generation": 46, "fitness": 0.2994704712339904, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "3d234e99-dfda-4fa5-985f-afa1766e23e2", "metadata": {"aucs": [0.7087159595134476, 0.7277453031454273, 0.7086497735727015, 0.7096458773837255, 0.7286726011419808, 0.7454971485693856, 0.6867135360283301, 0.7310895876907733, 0.670670751509955, 0.5184290099459965, 0.5433273487282679, 0.5512256699851559, 0.5453747953014655, 0.06003131956848207, 0.5007531644663603, 0.4751434016316354, 0.5524726666634585, 0.5239339839696575, 0.1105937110937173, 0.11136048651547192, 0.13598508839702994, 0.10185398542715252, 0.08159061458549655, 0.13100740089122465, 0.11192563966546609, 0.099434110813444, 0.11028622422669865, 0.09443045530639138, 0.0902771426038067, 0.10232248348777373, 0.0857505851453001, 0.14333384789241754, 0.0967753065892244, 0.07403288997139967, 0.07278728206868634, 0.09145995721481881, 0.9926738850568936, 0.9971067679500865, 0.9909406029114449, 0.9847767477976714, 0.9852617422979272, 0.9965161969236885, 0.9800562679702715, 0.9688374433564938, 0.9660031392302248, 0.29593306359695803, 0.05751931265955501, 0.1603659069567107, 0.3696582626275099, 0.27241465299539913, 0.34791005444288514, 9.999999999998899e-05, 0.31407008210153686, 0.36018179577370424, 0.3384444822357965, 0.3607835847481431, 0.7552886113140809, 0.7104281741699052, 0.7476684758819072, 0.7530081917700178, 0.6887932816302791, 0.7449819588109138, 0.6859122586902384, 0.18179137609246587, 0.10738877260075297, 0.15423939353110894, 0.12518899690176843, 0.1607553952691183, 0.11831771344697284, 0.15533781016056658, 0.11320408167076712, 0.2114252027274388, 0.05082865770647804, 0.1199100252663513, 0.14839463292608712, 0.2093572363774887, 0.16108937153827774, 0.1712865977297472, 0.1799141207636853, 0.35074716153838237, 0.15631845693201574, 0.1486804203698875, 9.999999999998899e-05, 0.09474936166070325, 0.27042681922198775, 0.1481144170381471, 0.3817305673629081, 0.38693657689792804, 0.13066111144920978, 0.36808318469581636, 0.31735337114173834, 0.2991252591021498, 0.3021973135240955, 0.2519216593311643, 0.40050833156816734, 0.31641766005747063, 0.4218863777707129, 0.17546479159527661, 0.5794138564876612, 0.08778219154649103, 0.1362259274195159, 0.19392082980694236, 0.0772682443250935, 0.0627986999853769, 0.20570749681403544, 0.13362060784077934, 0.14041365702735564, 0.10020544713369273, 0.2155720973027957, 0.26711506220126435, 0.24733389719324406, 0.24771955150959912, 0.2757207396214655, 0.25450624960007495, 0.2540584174713395, 0.2520195286331074, 0.2527344957722535, 0.6610498189486196, 0.538381313499682, 0.6474670977109991, 0.5640293328289935, 0.3435775001692164, 0.4962100170696747, 0.6243867168602886, 0.5550634162394273, 0.489399752041077, 0.07750555234208079, 0.10728717004218702, 0.11399268910070715, 0.07167143349998117, 0.10457245588626451, 0.0822850878796999, 0.08501418884785072, 0.0865957973147139, 0.0773509338256737, 0.12197046177378668, 0.12800905518294936, 0.14836660138318025, 0.13045763565271196, 0.14292985003538272, 0.11618286970789482, 0.13675129447844625, 0.10942210996492108, 0.1572098492875026, 0.3751291598801225, 0.3636904946959484, 0.34027887174582394, 0.358505592806857, 0.34778833633321304, 0.312286183448529, 0.38092786261489386, 0.39444845192661193, 0.3563571929871038, 0.2252912629016398, 0.214477234340118, 0.18579088948022426, 0.27766333062173154, 0.2596253953608477, 0.27554356275703606, 0.18740257775202096, 0.2915816895003617, 0.28599592754852277, 0.1696681257629643, 0.15722390894993732, 0.1771817457718916, 0.19074411568535854, 0.17623328723286635, 0.18249495686331774, 0.2021722325544708, 0.17491331728157455, 0.1774789922795399, 0.21337439984671713, 0.20182981753351403, 0.19785964053656957, 0.20060465957654228, 0.198362012638153, 0.3306599357315726, 0.19227105240162168, 0.24127066849038215, 0.17089706557867035, 0.16812096451965242, 0.403314846320203, 0.1123645331241041, 0.16126669202659172, 0.18339955399959262, 0.8121391757784756, 0.4088569341991961, 0.16362522983791072, 0.6851231170806669, 0.1481775558192403, 0.6746650192763541, 0.4424926757592368, 0.6438909646088217, 0.1859140050293261, 0.12250856676986455, 0.18710953602592184, 0.19718451875504062, 0.18589533539959957, 0.17376615705669296, 0.18085499998181476, 0.1905458303933234, 0.17173742115004276, 0.16908688388002524, 0.18409708489826715, 0.16915215652224347, 0.20281866871833598, 0.1793159007473294, 0.07615968871620316, 0.0714306464389951, 0.07140175854939856, 0.0714119768241599, 0.07063382618391112, 0.07377238589772228, 0.06299132674109276, 0.07379230332878328, 0.06851631492172094]}, "mutation_prompt": null}
{"id": "6e95458a-00c5-4956-aa93-6db8863f228a", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0) * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        fitness_variance = np.var(self.fitness) if self.fitness is not None else 1.0  # New line to introduce fitness variance\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / (self.fitness.min() + fitness_variance))  # Adjusted line\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Introduce dynamic perturbation size scaling based on fitness variance to enhance local search adaptability.", "configspace": "", "generation": 47, "fitness": 0.2964531308949687, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.23.", "error": "", "parent_id": "3d234e99-dfda-4fa5-985f-afa1766e23e2", "metadata": {"aucs": [0.7452013608754842, 0.7205168840853385, 0.7259332406709209, 0.6988672113671995, 0.7572947250814493, 0.7811299502701995, 0.728474187686013, 0.7497707758559868, 0.737259273296232, 0.6047166594795059, 0.5427225831412844, 0.5488888836870427, 0.5461174169582634, 0.06144249961097281, 0.527579600889303, 0.5522856889797326, 0.5306761201151391, 0.5269909493074096, 0.09104024037064395, 0.1214901662619402, 0.12566604868544073, 0.09086783622584826, 0.12221542587922829, 0.10775349067158824, 0.12649313858252498, 0.04279901370963146, 0.1103147863095566, 0.0864154504305159, 0.06823196023606437, 0.08794558499968896, 0.09007258356821601, 0.14019385823665853, 0.09587936970366995, 0.10442878543564971, 0.08939040061732395, 0.10542467360759877, 0.841726830192509, 0.8785688642236731, 0.7352471894336996, 0.8609186419084636, 0.9163281950703782, 0.7780032368763568, 0.8200151863085451, 0.8670783663798429, 0.8859072760294687, 0.3714926019063871, 0.2791313256693603, 0.2987852794854392, 0.2801586779012566, 0.41171201516199907, 0.31192128936416486, 0.2726915329527724, 0.23402061509181793, 0.277206972039022, 0.6077823865458871, 0.7393945291163695, 0.27689461344638544, 0.6916356927893272, 0.575352969254953, 0.7078525001690414, 0.6795028796461566, 0.7543772459989542, 0.7536924793188955, 0.17939477576263452, 0.10736760453072125, 0.15609845182463156, 0.14700039026172929, 0.15104710809997346, 0.13487106895425627, 0.15533777120225112, 0.1376683721178048, 0.15770646066068494, 0.01831598583736682, 0.024575306997281943, 0.14278581057570938, 0.20822559443075328, 0.16436735694586968, 0.17177797775773995, 0.1800080524659432, 0.35088119604781487, 0.1405698459835164, 0.14890034786660522, 9.999999999998899e-05, 0.18030879666201616, 0.17923492474320224, 0.3423278499295649, 9.999999999998899e-05, 0.2920122107341139, 0.07239517437636556, 0.32206022343086993, 0.41185631873034856, 0.17517421194955496, 0.273463562197632, 0.1169005502099113, 0.08932548035561938, 0.22538425025060993, 0.3306643174081725, 0.32026875668540034, 0.5403934545744431, 0.13942620815790363, 0.05911322252336226, 0.07259604578333656, 0.11920076905800814, 0.16044588959130157, 0.07100444089320412, 0.09835219635539527, 0.1404136570068547, 0.10020544714629542, 0.3126455269947874, 0.14223791180616085, 0.160392899334186, 0.18205234247255797, 0.33083491697120526, 0.3008392398420958, 0.0739517004654967, 0.2701172866161776, 0.29091817231295414, 0.6774278913595486, 0.6179077396554502, 0.6531304080109754, 0.6158613984153622, 0.4925382281554471, 0.6102157011913911, 0.5468314272922455, 0.5683409367556184, 0.5409262854171897, 0.10869992708402965, 0.08465434135451211, 0.08848474563033593, 0.08219699531895619, 0.0914593890657156, 0.11939940366453028, 0.08077022064894723, 0.08842956788092837, 0.09452927486092633, 0.14968638494111908, 0.12197888587561645, 0.15272218591612985, 0.3520095916001469, 0.229970371550412, 0.13810225935362486, 0.18762821046810174, 0.17220290206272149, 0.23746957237427901, 0.3378729019455057, 0.40975412066122807, 0.3488320577608537, 0.3758731408028442, 0.34411131876034884, 0.21262910016194347, 0.37380156142558485, 0.35618873919383065, 0.3717232164978982, 0.16664220664835516, 0.26327014181974695, 0.28717391134317827, 0.3318656410059404, 0.29302620738526, 0.27191197234470976, 0.2829513148587006, 0.3325507098663981, 0.3052652882264614, 0.21015419947581981, 0.18100625756738775, 0.2082754347703878, 0.19857150819199554, 0.18683818719898515, 0.20598748080071716, 0.1827347655460716, 0.19173212480353263, 0.19364226203189416, 0.1672477256494893, 0.18985088302635644, 0.19149030164421388, 0.20060439584747014, 0.19836522944522816, 0.3361249568182104, 0.1922715521340882, 0.18434903039207706, 0.17089361198947117, 0.1680125632341456, 0.7385193586781551, 0.15100799917967234, 0.6803210476266847, 0.191238284424317, 0.1798942184878788, 0.7694707471318505, 0.18872079239451545, 0.1604267647654558, 0.7717384977299256, 0.5531883022478524, 0.144564581363003, 0.19025682551692547, 0.15951965767408582, 0.15401004190513357, 0.21218585061983153, 0.12512679766683776, 0.12495829886051857, 0.2199381785313992, 0.17560884905548102, 0.19457280375291353, 0.1750243983472476, 0.1981151986365729, 0.26722566124390823, 0.17334902906470484, 0.1929663965260182, 0.21320429795685591, 0.06134869814042343, 0.06612334247616236, 0.06449283044596321, 0.07228657642109959, 0.07545882376470103, 0.0814396679607815, 0.07095105276387803, 0.06700235801473975, 0.06894212569436842]}, "mutation_prompt": null}
{"id": "f48172de-9edb-425e-a3df-881527d99823", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0) * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        convergence_rate = np.abs((self.fitness.min() - current_fitness) / self.fitness.min())\n        perturbation_size *= (1 - 0.5 * convergence_rate)  # Dynamic adjustment based on convergence rate\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Introduce dynamic adjustment to perturbation size in local search based on convergence rate to fine-tune exploitation.", "configspace": "", "generation": 48, "fitness": 0.3201937912234733, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.23.", "error": "", "parent_id": "3d234e99-dfda-4fa5-985f-afa1766e23e2", "metadata": {"aucs": [0.7569190881540454, 0.7574693352273493, 0.7607296905382231, 0.7374841063744482, 0.7270220543238306, 0.7783457035490398, 0.7741335521394477, 0.7139082288443686, 0.6780379632152047, 0.5400365405347726, 0.5834991358077163, 0.5507815547552828, 0.5755548929078587, 0.5358446461031943, 0.552643685319435, 0.5836537223849754, 0.4662151407256072, 0.5160894823577205, 0.13933804144699313, 0.11333634053316943, 0.1099904251288446, 0.11890844675025747, 0.10884268624227211, 0.11600181900403439, 0.1174840818097338, 0.10863185835035438, 0.10626595151258278, 0.09116066569109804, 0.08457080194919586, 0.11030586347318527, 0.10288625059929468, 0.10675291038475787, 0.08797799534926276, 0.100206041412639, 0.08390178148636074, 0.09543544326848463, 0.843880390108564, 0.8153290396595585, 0.91845015554124, 0.8401698448128605, 0.8969836478992069, 0.8075977442175695, 0.7943261943079398, 0.7826284264105103, 0.8062830607858978, 0.3943564318631517, 0.3463292406721681, 0.343651083004762, 0.3530988606738601, 0.35339970608011173, 0.4067207712746982, 0.41125630001763724, 0.3396949515119858, 0.39452332630734843, 0.7167890960699497, 0.7651329260158848, 0.7678393409923588, 0.7447454712173975, 0.21080658669353658, 0.7257051515499633, 0.6288045648823984, 0.785611295403044, 0.2242417847513538, 0.3484436673154565, 0.16032667931664724, 0.1507656280392472, 0.19747221467333953, 0.16703543767400497, 0.12527313897525383, 0.21427865757521847, 0.18123803144385642, 0.20664918513915198, 0.12276435493403803, 0.2762444055743939, 0.11822036908556222, 0.18962163303762813, 0.18563305169976196, 0.20856598592972775, 0.20321539501755015, 0.32213127004135644, 0.16386893987760143, 0.33515356629386395, 0.11974595612633732, 0.19285670317730963, 0.272736575742471, 0.3095762773213966, 0.3282023287530307, 0.1675020058421538, 0.22427654364943228, 0.21558305884148332, 0.47041561052237957, 0.36725005619595363, 0.38583867704783426, 0.22364185723928676, 0.5414477369419974, 0.44192089272157686, 0.4415220186799742, 0.31534908279985896, 0.5015154697177777, 0.1219249607295465, 0.16430685227020492, 0.07359119161820327, 0.14542045306931117, 0.2132648883029178, 0.149129442626033, 0.22598841994103613, 0.10588903603987132, 0.09704750670463158, 0.2938109144132197, 0.2410649589018775, 0.25210238493510784, 0.20179863138607934, 0.26235228241040864, 0.2635577151713949, 0.25969237909702103, 0.2331695901604599, 0.22693661010436328, 0.6625823931371196, 0.6154006374407555, 0.5314202020985708, 0.4495024181135361, 0.5357035152017818, 0.5753773453517312, 0.6589428106511976, 0.5340767500207624, 0.6382297758953722, 0.10920421274578751, 0.10731675652781325, 0.10259968156733335, 0.09652184664664021, 0.10935625526040582, 0.09877834040185007, 0.08730317007420418, 0.11843675466122916, 0.10213471397957852, 0.14003840091801956, 0.1624167666942944, 0.1797653230735312, 0.1356751322087062, 0.2143889910167246, 0.11929629651010076, 0.3766727280039126, 0.12805797089154125, 0.16573458657305729, 0.3760190119946525, 0.3960358685688924, 0.3386305731210614, 0.39192679318940127, 0.3870047460237155, 0.3774654886331247, 0.37515915242773834, 0.4090752177380106, 0.3580448851889255, 0.2882323473700028, 0.2897096848639851, 0.30106383796875225, 0.3063502553518429, 0.29049644402834907, 0.293642695745441, 0.2589894545966489, 0.28870289598461085, 0.27135850526484084, 0.18797962182959504, 0.19575558470432064, 0.18793653230545737, 0.1974728217723536, 0.18108811559949367, 0.19317499064256838, 0.19988252852050303, 0.1895532435425069, 0.2129391213392744, 0.23245998250104194, 0.19103978004949795, 0.21001037355793695, 0.20602796790746603, 0.2096801663723381, 0.17087476458248807, 0.4017056173006628, 0.3002129643369662, 0.17378078164586785, 0.16887306803327506, 0.7951914643718558, 0.15190347109242774, 0.7400868905135951, 0.18342903514095243, 0.8291503703605635, 0.18172832224546043, 0.6978508101846299, 0.1546749125404101, 0.7265288292377183, 0.5873712452256674, 0.1485559266462647, 0.18356038354003545, 0.18879266101261205, 0.15825896452066013, 0.21256689250404937, 0.12632849243849065, 0.1252118517361428, 0.16706240652107718, 0.18200534112396105, 0.17243246954525548, 0.196903311032969, 0.22475680193481795, 0.1841807738522856, 0.17334362281950721, 0.17784094085876623, 0.18348349063213287, 0.07211317059446976, 0.07274379137719711, 0.08452321282822906, 0.08407479452647149, 0.07839525819210336, 0.07611901523456055, 0.07369415410276725, 0.09062024828471549, 0.07703391600264986]}, "mutation_prompt": null}
{"id": "3834a6b3-d0d2-4ed0-9084-bf2ffd9efcdf", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0) * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        relative_improvement = (current_fitness - self.fitness.min()) / abs(current_fitness)\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else relative_improvement)\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Enhance the local search by dynamically adjusting perturbation size based on both iteration progress and relative fitness improvement, maintaining exploration and exploitation.", "configspace": "", "generation": 49, "fitness": 0.30760145673396927, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.22.", "error": "", "parent_id": "3d234e99-dfda-4fa5-985f-afa1766e23e2", "metadata": {"aucs": [0.7378230234188953, 0.747768824716099, 0.708125143002311, 0.5661058212213885, 0.7398790687562182, 0.698767648915493, 0.7152964691150998, 0.754704438023724, 0.6744023639433163, 0.5388707344856614, 0.5561845031662382, 0.5891284915270507, 0.5883153751212864, 0.6177976118981972, 0.6204682856798631, 0.5737275884359812, 0.5799119360313687, 0.48022861243571013, 0.0995263520009193, 0.10085500740889763, 0.12177654587703257, 0.08055684404442454, 0.08864968507094995, 0.11715788816220918, 0.08831256520832975, 0.09292194414531729, 0.10642225351984946, 0.09325797393488411, 0.10543113667735782, 0.0985225873449388, 0.0858975822214596, 0.08410011472273471, 0.11757559213617164, 0.11608778524844088, 0.09918024817825499, 0.08912182515662948, 0.7755791998703488, 0.8614419490774502, 0.7570793885946018, 0.6189639473407731, 0.6576180783569088, 0.7246103418208591, 0.6759623549881315, 0.7279207848633042, 0.7044860983924244, 0.2541316648279197, 0.24943869237249172, 0.4068420846203592, 0.3774674228132806, 0.33348952344451965, 0.34923776292488296, 0.325097236523917, 0.34206542497270653, 0.35937030581876717, 0.6973960708280977, 0.6888173742997353, 0.6649752951266109, 0.6981373626637597, 0.7576643165708095, 0.7362423638173756, 0.7693969935214992, 0.6867093926345011, 0.6590299375406036, 0.21664868291348438, 0.1477514761134605, 0.1354671938222458, 0.14933825383240185, 0.14911479829791008, 0.1568556198985641, 0.26036998609897744, 0.13482480239202066, 0.11538446420529147, 0.09711200851917734, 0.13407481918053454, 0.0974971091805803, 0.13938233664181354, 0.1198625301165126, 0.16032017302600998, 0.14192390828168244, 0.11344007300367087, 0.16859045558140684, 0.1942396998189414, 0.2932548991171271, 0.39644332338915134, 0.3516374536039786, 0.330845668230489, 0.08209708840675956, 0.1631462809210883, 0.3991442807887645, 0.23986775820986117, 0.4748290425222166, 0.5197032550915096, 0.5601865135216595, 0.4179656664056025, 0.12379583945946393, 0.3207413273386521, 0.5636961760026049, 0.47903716607671687, 0.5206021896234575, 0.2196895942339665, 0.08200001959953374, 0.07072985416122335, 0.11604002445571515, 0.13498563737972402, 0.18189228762654908, 0.17166620982041425, 0.1334173363524629, 0.20538350963846697, 0.2862288742220308, 0.2653389762520557, 0.2617496583282818, 0.29073692412635543, 0.3217759137002213, 0.2711634766767147, 0.1988647412918768, 0.2218582487666514, 0.22408799580458727, 0.6772923657620467, 0.5301665483364788, 0.5407322406049706, 0.6382457438380202, 0.48995445252565983, 0.5276802226583537, 0.5911945304930214, 0.45721020915113464, 0.6454391005445523, 0.1129348126592391, 0.11892354717320319, 0.09415395892803458, 0.08756209647152358, 0.09613611601621419, 0.10638947835550405, 0.10941237137830284, 0.08456455414619035, 0.09605340104220028, 0.16242351563378166, 0.12625020462158276, 0.21234483111311453, 0.1522012876747978, 0.18281643408291048, 0.17294520012205905, 0.2308861701334033, 0.10621629535163446, 0.16046457986272322, 0.3618735126392125, 0.382522212934574, 0.3831770877808448, 0.30918906099005994, 0.35025843465086814, 0.3191726839832908, 0.3644058482061717, 0.3992606262484085, 0.40955436097839015, 0.30019473475775993, 0.2815766617983705, 0.2483613441994974, 0.18231286236285693, 0.2712751680269925, 0.2327445383788106, 0.23283796944959545, 0.28485585321456575, 0.2959873826970342, 0.19807286346493846, 0.18299333862806144, 0.16794877102978767, 0.17337632887407528, 0.1822388662627754, 0.1860346120090146, 0.1818767667798309, 0.19077343553434634, 0.1905943721532909, 0.19450308245125703, 0.20349403704768387, 0.20794172911818432, 0.19114905848139896, 0.22088819581392916, 0.17678120528851904, 0.18989081725090418, 0.18228554399085184, 0.16945321462769314, 0.16828306616050304, 0.7397962463213531, 0.15105651425948197, 0.7625254053250066, 0.17990246754732853, 0.17533194459491153, 0.179611749398065, 0.15655314199514414, 0.6209146499353824, 0.31390694521090634, 0.7037649466752982, 0.3283284857636679, 0.19592565391764905, 0.1551543747001728, 0.23095494501206737, 0.210766513623589, 0.12236046383933663, 0.15221598906453693, 0.2810679985623419, 0.20097255552551385, 0.18717496995761718, 0.19076598166244052, 0.18289699216235045, 0.18059869581962318, 0.18942278047194006, 0.18133184800422264, 0.2409898236444471, 0.07576323723442635, 0.07890461554593164, 0.08276127152730495, 0.07049969784842891, 0.07908513330044586, 0.06219001703959659, 0.08691819363277942, 0.07841668936802837, 0.07551695745105902]}, "mutation_prompt": null}
{"id": "d1136147-cafa-417c-8fda-112166ca04f8", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        fitness_diversity = np.std(self.fitness) / np.mean(self.fitness)  # Fitness diversity\n        self.F = np.random.uniform(0.5, 1.0) * fitness_diversity  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Introduce adaptive scaling for mutation factor based on fitness diversity to enhance exploration in diverse populations.", "configspace": "", "generation": 50, "fitness": 0.14048587439602614, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.15.", "error": "", "parent_id": "3d234e99-dfda-4fa5-985f-afa1766e23e2", "metadata": {"aucs": [0.43114338608114144, 0.4874998744964347, 0.46178559694037635, 0.43808669876041073, 0.37282060349308177, 0.4423450258013327, 0.42475300301783514, 0.4300289216938509, 0.4488038603488622, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.15525886444355796, 0.07883727476796776, 0.0446801169346569, 0.10451455399763998, 0.1347730025951107, 0.05721811325940929, 0.1525430793345819, 0.09994374023615471, 0.0569645915995296, 0.07721957400397328, 0.0404930972297296, 0.0026878666781603444, 0.10189864964037898, 0.1001298949314674, 0.07396578958941269, 0.12357874199570373, 0.08106748857650914, 0.053627737047184154, 0.8514857102136208, 0.8208164701354884, 0.9736420267526316, 0.09229921628538507, 0.0823191398797406, 0.08679958336202487, 0.0884430256696278, 0.11624056897072699, 0.13164093505153684, 0.05553276313826627, 0.09342694513302374, 0.05186672669869674, 0.032181176785463506, 0.0570155932540769, 0.038640610473476, 0.0686167417318726, 0.08561742207809153, 0.06251220352662334, 0.14579153373966325, 0.671727759279318, 0.5137807992539549, 0.14428325651194063, 0.13160984908238882, 0.15218017366153314, 0.11587342096610387, 0.17033871572772974, 0.16367683353086082, 0.023425050321053686, 9.999999999998899e-05, 0.03414857635227708, 9.999999999998899e-05, 0.02666591909459659, 9.999999999998899e-05, 0.0004990714511048377, 9.999999999998899e-05, 0.05266562132106245, 0.09174323722227651, 0.059832589458235996, 0.0770475398913919, 0.019724091759536377, 0.00016954702623717122, 0.018705262998040206, 9.999999999998899e-05, 9.999999999998899e-05, 0.02223905931051018, 0.04319657675583877, 9.999999999998899e-05, 9.999999999998899e-05, 0.008555121449030367, 9.999999999998899e-05, 0.012573170596444472, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08335514137213418, 0.023307076648433345, 0.01885960542862053, 0.051314562612227, 0.046132050894674426, 0.08867381469097713, 0.0911362703428884, 0.03735366347864533, 0.03836836618566852, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.042165783185641015, 0.0946476709784787, 0.09442458923962294, 0.05258576299716533, 0.0570406003896734, 0.03030097161918477, 0.005682044110360551, 0.015236170601331644, 0.012820837186104495, 0.3930515512757866, 0.3715500036741123, 0.4057171285195763, 0.3848844720877095, 0.44985527653792323, 0.25844930311359005, 0.32914330987330787, 0.32592667331416614, 0.37027928997716353, 0.017899181850815182, 0.0990024095374602, 9.999999999998899e-05, 0.07342943132528834, 0.03450534337502398, 0.12398731720151279, 0.0810650995312241, 0.039059660545364916, 0.04893705299844209, 0.20467047041676112, 0.20500215833426738, 0.15880564834136834, 0.1978758717260365, 0.19837248195577883, 0.229756906268767, 0.1948766784052064, 0.18782600076192846, 0.13447732052594297, 0.3708377430840022, 0.12505248291961468, 0.25826254479031163, 0.2562095387947527, 0.37534579714907046, 0.12975793814720304, 0.1368098009169304, 0.23015492108275015, 0.10109548439996541, 0.10975087418776241, 0.1120158350817212, 0.09357102870071632, 0.29208838584812824, 0.18945203144760758, 0.2094500780840327, 0.17691596804364995, 0.20390437879694678, 0.05083882734277523, 0.19297239112982767, 0.19013003137028373, 0.20791037014930358, 0.2251203209538155, 0.1731879440611288, 0.16622723058878874, 0.22810797975504749, 0.10368490415807408, 0.18675624020080872, 0.04772742144135045, 0.1538289530582162, 0.14736316834829666, 0.16057028910446247, 0.1617926369786472, 0.11308920239279174, 0.13985999929898352, 0.14149343769494716, 0.1399349666888251, 0.19109411379117935, 0.12657946016770005, 0.15127841151311572, 0.2938208527399373, 0.17471313302196811, 0.17562928465502248, 0.13435605900754288, 0.1651905616759517, 0.13866821013572173, 0.08057867630597393, 0.32304960615371303, 0.3639492096218029, 0.10041701360684852, 0.15373050724306014, 0.18006789519609445, 0.19526975868134466, 0.19856819562735473, 0.12478545954001696, 0.17800169611746974, 0.17361873597241229, 0.20817254073036695, 0.18879318539304846, 0.20216129074672307, 0.20796266470895552, 0.19729501759874568, 0.19296136209591108, 0.19110710774027118, 0.08528135647779889, 0.05988939778287827, 0.06010340186879004, 0.06474140638298831, 0.0693362823702095, 0.10176817484148082, 0.07410243537099992, 0.06695161497374391, 0.07855383666065185]}, "mutation_prompt": null}
{"id": "d210e014-c311-4cc4-a569-50d17fc8b94c", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0) * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Introduce adaptive scaling for crossover probability based on function evaluations to improve exploration and exploitation balance.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3d234e99-dfda-4fa5-985f-afa1766e23e2", "metadata": {"aucs": [0.7038313688403066, 0.743928857802591, 0.7560508206163828, 0.7219173056875023, 0.7421079591792674, 0.7930009329679681, 0.7436785203822623, 0.7198040777536261, 0.7002810856294976, 0.5716574770009174, 0.5976046946297183, 0.5551544665886294, 0.5076641482355237, 0.5169063357640791, 0.5736410575901869, 0.5306148911229513, 0.592124132112893, 0.5661765801498353, 0.13241238294815627, 0.12824622145445608, 0.11783580031424368, 0.10491957026507948, 0.1046342580125793, 0.09230025528669872, 0.1048419077341417, 0.1299915749972812, 0.09644327262565544, 0.09456194348308711, 0.11358687995875827, 0.09142756080072645, 0.1312681347887541, 0.11240367198556855, 0.10033249518500487, 0.09350380506174205, 0.10979080295412291, 0.09984191722225255, 0.9051560894045779, 0.9632976144751287, 0.9748200510248832, 0.7992943671742906, 0.8917915159553417, 0.7969036232810127, 0.7854717651200025, 0.9045572965780869, 0.869078862896797, 0.40981073050894923, 0.39054194085519134, 0.33586528620035805, 0.4516489025314623, 0.39952960342178545, 0.4328168420558757, 0.39180403341474945, 0.3442268351509773, 0.3671331186038451, 0.7708797596734744, 0.7063466521852724, 0.1654311433705592, 0.7770868544110645, 0.7468771429838391, 0.7592243351409629, 0.7353826439928655, 0.8027770542701451, 0.7389399434191213, 0.19132009492168456, 0.15295347740444465, 0.19801944704503094, 0.18368703209004544, 0.22163024199770665, 0.46158734848126115, 0.4725751618198992, 0.1998041376367331, 0.2584884918087428, 0.12682122132169205, 0.12559693818602224, 0.12166217719483863, 0.19853514726888388, 0.19236616341397828, 0.1862537475463657, 0.2026620546622242, 0.18274567894096672, 0.1662998613942568, 0.17797497297901987, 0.09690963510167216, 0.43131045648053956, 0.149866827260129, 0.2868026530490929, 0.2669646766198053, 0.28110491058621734, 0.21142133324468604, 0.3044296200478086, 0.5169409408402444, 0.5357420410345979, 0.31175744367937763, 0.28695256796654545, 0.3104878383466062, 0.348263853844224, 0.11562447182728086, 0.5673393808992695, 0.34041798499657727, 0.17841555867851588, 0.17756116285745105, 0.13975626578019074, 0.14652993192510055, 0.12931233820754406, 0.20472619400575554, 0.13987375825315662, 0.17088937261732173, 0.11511523340992003, 0.2979934774877705, 0.2305033023156351, 0.28817880996134126, 0.2440622245700974, 0.262928320551588, 0.28181553873054777, 0.2239139107940581, 0.2640521464987824, 0.27690567942690036, 0.614035309276102, 0.6849386287100123, 0.5834478146294717, 0.5679522571245758, 0.5057399009824285, 0.6117795079043433, 0.6136713454880558, 0.6469069483609697, 0.5030893323883259, 0.10765812097305172, 0.14557710721624884, 0.1066813198012263, 0.08877985400805266, 0.08375221061667215, 0.09875838588656294, 0.09632607109625402, 0.11529044711661351, 0.09520686335075368, 0.20691240321366455, 0.14002034892234327, 0.18940277867314403, 0.1779527766922231, 0.43679170746698415, 0.2242536575846268, 0.34182506197949647, 0.17312750322649895, 0.15740008902877323, 0.3668125215617306, 0.3765461899629181, 0.3595349598818315, 0.33974220136115485, 0.34182489341160127, 0.3452028095802492, 0.39102524113553316, 0.39820553935598657, 0.2070738281852379, 0.2613978288863885, 0.3358346592819559, 0.28445702188795086, 0.24407623770859066, 0.2726580263374029, 0.3162090950618671, 0.25625722750680247, 0.29111062371208996, 0.2791823614229766, 0.19245891286660977, 0.1698038574206534, 0.18523224451551135, 0.1952051268588384, 0.18354833210778754, 0.21094396633175871, 0.20515853080249202, 0.23761947239850756, 0.19181738857680264, 0.2959090826093115, 0.2032900896832368, 0.18632488561585225, 0.1949472199217248, 0.3932618484986893, 0.24955991271928935, 0.1915372516889956, 0.18828752558760675, 0.20649567527103696, 0.7326344763941118, 0.8288703624240127, 0.15180777243251942, 0.7890276962747119, 0.18783379377651854, 0.17487864936737207, 0.18173828535014303, 0.6901940754593975, 0.15512320812185265, 0.7503324037743441, 0.6239534936499597, 0.6560318105886904, 0.1835106034377837, 0.19662347209131592, 0.15824635346355242, 0.21212418169610936, 0.7511630708963973, 0.1252455997141324, 0.18319298564682263, 0.19570426896787907, 0.17477714932701105, 0.1794575836521457, 0.20205543105008605, 0.18544564910009276, 0.1796305530335247, 0.1636836462628326, 0.18360693310295106, 0.08359960191145999, 0.07723762018759595, 0.07398981323313858, 0.08013813884101673, 0.08462710928568251, 0.07867534901923978, 0.07565135012624014, 0.06518677515553917, 0.07715092936900603]}, "mutation_prompt": null}
{"id": "5e035bff-3800-45e6-9efc-ee64909d2abf", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0) * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))\n            if evaluations % (self.budget // 10) == 0:  # New minor population update\n                random_idx = np.random.randint(0, self.population_size)\n                self.population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[random_idx] = func(self.population[random_idx])\n                evaluations += 1\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Improve exploration by introducing a small random population initialization update mechanism during each iteration.", "configspace": "", "generation": 52, "fitness": 0.33387476125177795, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.24.", "error": "", "parent_id": "3d234e99-dfda-4fa5-985f-afa1766e23e2", "metadata": {"aucs": [0.7089745260968229, 0.7509886570455657, 0.7455866546676084, 0.7414072530457505, 0.7509895690808245, 0.7901472881748399, 0.7504995156517635, 0.7144065123644836, 0.7163485662534919, 0.5304396276475514, 0.6060018332468233, 0.5007484786552359, 0.5790883088842702, 0.5244687620072748, 0.5727098530762558, 0.5143603168369522, 0.573570846549657, 0.5580335594377674, 0.11895469416777449, 0.1234635028453629, 0.12550728208186757, 0.11065054386908268, 0.1063414004149652, 0.1085560582717302, 0.10642556759971122, 0.11320902753356221, 0.10617431784385079, 0.09451931860412555, 0.0827803776443572, 0.09826023913861992, 0.1478435462956782, 0.1256037970589825, 0.09261777187048714, 0.08849173864653481, 0.09997140285046557, 0.11155630659974047, 0.9051560894045779, 0.9632976144751287, 0.9748200510248832, 0.7992943671742906, 0.8917915159553417, 0.7969036232810127, 0.7854717651200025, 0.9045572965780869, 0.869078862896797, 0.4028212102843357, 0.38930543998007383, 0.39974410939325755, 0.4758404403208738, 0.3906674283116205, 0.36320135025877576, 0.35775264794872075, 0.40718404371109873, 0.3521969996178381, 0.7739873000213996, 0.7723174570466573, 0.1654311433705592, 0.7693113368588889, 0.7541021669784771, 0.7531144236177723, 0.7345541647689904, 0.8027770542701451, 0.7714615899900059, 0.20916580740465474, 0.15553650062064095, 0.19096969571605216, 0.18716568014803825, 0.18107371689672946, 0.5273690818852154, 0.34009590270294954, 0.21963374852925122, 0.3671402762667447, 0.1303059014151391, 0.12677306152235202, 0.1216553685963705, 0.24237700845069676, 0.20527747097120008, 0.1756887131245507, 0.22838326951365873, 0.16482669757873614, 0.19314054637199185, 0.14867310788559318, 0.12515752081337328, 0.3560288290510515, 0.15745620520351045, 0.2756169062435678, 0.239121950584834, 0.36363890669459065, 0.26421848747952814, 0.32054951198072246, 0.32218263280694415, 0.4783995900905844, 0.30650914924487693, 0.32999491953711235, 0.5338224788835599, 0.379075603995489, 0.12138494856569837, 0.4760101256532927, 0.3115914596893351, 0.12605034246836255, 0.11690010983432986, 0.18120739085108228, 0.2675385812140244, 0.15040410374298718, 0.1543510397707767, 0.17261804263305736, 0.2393697127005775, 0.11501842634344162, 0.2325430556767344, 0.2590573356776774, 0.2496902600478912, 0.23548762540940604, 0.2740462003804871, 0.3478443889810192, 0.27156224316379185, 0.2703724710850681, 0.26011207207434595, 0.6103139828754751, 0.6232072483254608, 0.5812135036466575, 0.5471002745314273, 0.6437486014161273, 0.5580280088874621, 0.7074042142699934, 0.6367494135888114, 0.5262243740660046, 0.09682549256658335, 0.10211680769629095, 0.10804641353486366, 0.08228703624835398, 0.08479032058929026, 0.09880443272573425, 0.10857568446247501, 0.1003952595695089, 0.09263794477933718, 0.16758925102096323, 0.12708466566699195, 0.18582115616452366, 0.1540145250777034, 0.2585700826013856, 0.21641040543070067, 0.3557594300172101, 0.1755895466986871, 0.11846491894503275, 0.3687521816713485, 0.36904849393698647, 0.38844530129118016, 0.34508273766123443, 0.35837415826275143, 0.37088474947172057, 0.3719174631092341, 0.4065864065241065, 0.2063030691422929, 0.25335951621639974, 0.33712645808303077, 0.30604372134842783, 0.24219879468208094, 0.29008500418775174, 0.26876181830012846, 0.24542307174581524, 0.3219059465434967, 0.2749335923626408, 0.1933959516931404, 0.1728861794865355, 0.18264748523835572, 0.1952051268588384, 0.18410589299383795, 0.2123267242783622, 0.2139488464156808, 0.184282741058584, 0.20693936893728115, 0.3088031552665277, 0.21307729034090228, 0.1969994384803072, 0.194858328934439, 0.20374434765725824, 0.2585055387798463, 0.21271778525055562, 0.20782737605024337, 0.36263750885438384, 0.7208539539609304, 0.8289095660493433, 0.15180776404158747, 0.7837020379774127, 0.18765404907248295, 0.17487863891620858, 0.1817394541132522, 0.6818944203165751, 0.15512494822981093, 0.7502811194842037, 0.481097717307301, 0.5993806123790528, 0.18517616620734567, 0.1966189711123113, 0.15824819171836513, 0.2121242006134031, 0.7558698176632623, 0.12524522299168517, 0.1834382648818731, 0.20658823791074388, 0.17418664911884407, 0.1777253703395021, 0.20205543105008605, 0.19088268490865723, 0.17816453268468269, 0.16801464611275074, 0.18357412036700127, 0.08364445832047418, 0.07799585803710829, 0.07810104132037032, 0.07134598627191102, 0.07830637427504394, 0.07420220166912206, 0.07709147132186789, 0.08931793683414746, 0.07776904739342061]}, "mutation_prompt": null}
{"id": "c8a4b8ab-7c86-4b4d-9361-6c605696cb46", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n        self.best_individual = None\n        self.best_fitness = float('inf')\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0) * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                # Introduce elitism: keep track of the best individual\n                if trial_fitness < self.best_fitness:\n                    self.best_individual = trial\n                    self.best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        return self.best_individual, self.best_fitness", "name": "AdaptiveMemeticAlgorithm", "description": "Enhance solution quality by introducing elitism to preserve the best individual throughout generations.", "configspace": "", "generation": 53, "fitness": 0.3339167359762169, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.24.", "error": "", "parent_id": "3d234e99-dfda-4fa5-985f-afa1766e23e2", "metadata": {"aucs": [0.7038313688403066, 0.743928857802591, 0.7560508206163828, 0.7219173056875023, 0.7421079591792674, 0.7930009329679681, 0.7436785203822623, 0.7198040777536261, 0.7002810856294976, 0.5716574770009174, 0.5976046946297183, 0.5551544665886294, 0.5076641482355237, 0.5169063357640791, 0.5736410575901869, 0.5306148911229513, 0.592124132112893, 0.5661765801498353, 0.13241238294815627, 0.12824622145445608, 0.11783580031424368, 0.10491957026507948, 0.1046342580125793, 0.09230025528669872, 0.1048419077341417, 0.1299915749972812, 0.09644327262565544, 0.09456194348308711, 0.11358687995875827, 0.09142756080072645, 0.1312681347887541, 0.11240367198556855, 0.10033249518500487, 0.09350380506174205, 0.10979080295412291, 0.09984191722225255, 0.9051560894045779, 0.9632976144751287, 0.9748200510248832, 0.7992943671742906, 0.8917915159553417, 0.7969036232810127, 0.7854717651200025, 0.9045572965780869, 0.869078862896797, 0.40981073050894923, 0.39054194085519134, 0.33586528620035805, 0.4516489025314623, 0.39952960342178545, 0.4328168420558757, 0.39180403341474945, 0.3442268351509773, 0.3671331186038451, 0.7708797596734744, 0.7063466521852724, 0.1654311433705592, 0.7770868544110645, 0.7468771429838391, 0.7592243351409629, 0.7353826439928655, 0.8027770542701451, 0.7389399434191213, 0.19132009492168456, 0.15295347740444465, 0.19801944704503094, 0.18368703209004544, 0.22163024199770665, 0.46158734848126115, 0.4725751618198992, 0.1998041376367331, 0.2584884918087428, 0.12682122132169205, 0.12559693818602224, 0.12166217719483863, 0.19853514726888388, 0.19236616341397828, 0.1862537475463657, 0.2026620546622242, 0.18274567894096672, 0.1662998613942568, 0.17797497297901987, 0.09690963510167216, 0.43131045648053956, 0.149866827260129, 0.2868026530490929, 0.2669646766198053, 0.28110491058621734, 0.21142133324468604, 0.3044296200478086, 0.5169409408402444, 0.5357420410345979, 0.31175744367937763, 0.28695256796654545, 0.3104878383466062, 0.348263853844224, 0.11562447182728086, 0.5673393808992695, 0.34041798499657727, 0.17841555867851588, 0.17756116285745105, 0.13975626578019074, 0.14652993192510055, 0.12931233820754406, 0.20472619400575554, 0.13987375825315662, 0.17088937261732173, 0.11511523340992003, 0.2979934774877705, 0.2305033023156351, 0.28817880996134126, 0.2440622245700974, 0.262928320551588, 0.28181553873054777, 0.2239139107940581, 0.2640521464987824, 0.27690567942690036, 0.614035309276102, 0.6849386287100123, 0.5834478146294717, 0.5679522571245758, 0.5057399009824285, 0.6117795079043433, 0.6136713454880558, 0.6469069483609697, 0.5030893323883259, 0.10765812097305172, 0.14557710721624884, 0.1066813198012263, 0.08877985400805266, 0.08375221061667215, 0.09875838588656294, 0.09632607109625402, 0.11529044711661351, 0.09520686335075368, 0.20691240321366455, 0.14002034892234327, 0.18940277867314403, 0.1779527766922231, 0.43679170746698415, 0.2242536575846268, 0.34182506197949647, 0.17312750322649895, 0.15740008902877323, 0.3668125215617306, 0.3765461899629181, 0.3595349598818315, 0.33974220136115485, 0.34182489341160127, 0.3452028095802492, 0.39102524113553316, 0.39820553935598657, 0.2070738281852379, 0.2613978288863885, 0.3358346592819559, 0.28445702188795086, 0.24407623770859066, 0.2726580263374029, 0.3162090950618671, 0.25625722750680247, 0.29111062371208996, 0.2791823614229766, 0.19245891286660977, 0.1698038574206534, 0.18523224451551135, 0.1952051268588384, 0.18354833210778754, 0.21094396633175871, 0.20515853080249202, 0.23761947239850756, 0.19181738857680264, 0.2959090826093115, 0.2032900896832368, 0.18632488561585225, 0.1949472199217248, 0.3932618484986893, 0.24955991271928935, 0.1915372516889956, 0.18828752558760675, 0.20649567527103696, 0.7326344763941118, 0.8288703624240127, 0.15180777243251942, 0.7890276962747119, 0.18783379377651854, 0.17487864936737207, 0.18173828535014303, 0.6901940754593975, 0.15512320812185265, 0.7503324037743441, 0.6239534936499597, 0.6560318105886904, 0.1835106034377837, 0.19662347209131592, 0.15824635346355242, 0.21212418169610936, 0.7511630708963973, 0.1252455997141324, 0.18319298564682263, 0.19570426896787907, 0.17477714932701105, 0.1794575836521457, 0.20205543105008605, 0.18544564910009276, 0.1796305530335247, 0.1636836462628326, 0.18360693310295106, 0.08359960191145999, 0.07723762018759595, 0.07398981323313858, 0.08013813884101673, 0.08462710928568251, 0.07867534901923978, 0.07565135012624014, 0.06518677515553917, 0.07715092936900603]}, "mutation_prompt": null}
{"id": "4479b5fc-47f7-423b-b45c-4b1c48acbc2b", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0) * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Introduce adaptive scaling for crossover probability based on function evaluations to improve exploration and exploitation balance.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3d234e99-dfda-4fa5-985f-afa1766e23e2", "metadata": {"aucs": [0.7038313688403066, 0.743928857802591, 0.7560508206163828, 0.7219173056875023, 0.7421079591792674, 0.7930009329679681, 0.7436785203822623, 0.7198040777536261, 0.7002810856294976, 0.5716574770009174, 0.5976046946297183, 0.5551544665886294, 0.5076641482355237, 0.5169063357640791, 0.5736410575901869, 0.5306148911229513, 0.592124132112893, 0.5661765801498353, 0.13241238294815627, 0.12824622145445608, 0.11783580031424368, 0.10491957026507948, 0.1046342580125793, 0.09230025528669872, 0.1048419077341417, 0.1299915749972812, 0.09644327262565544, 0.09456194348308711, 0.11358687995875827, 0.09142756080072645, 0.1312681347887541, 0.11240367198556855, 0.10033249518500487, 0.09350380506174205, 0.10979080295412291, 0.09984191722225255, 0.9051560894045779, 0.9632976144751287, 0.9748200510248832, 0.7992943671742906, 0.8917915159553417, 0.7969036232810127, 0.7854717651200025, 0.9045572965780869, 0.869078862896797, 0.40981073050894923, 0.39054194085519134, 0.33586528620035805, 0.4516489025314623, 0.39952960342178545, 0.4328168420558757, 0.39180403341474945, 0.3442268351509773, 0.3671331186038451, 0.7708797596734744, 0.7063466521852724, 0.1654311433705592, 0.7770868544110645, 0.7468771429838391, 0.7592243351409629, 0.7353826439928655, 0.8027770542701451, 0.7389399434191213, 0.19132009492168456, 0.15295347740444465, 0.19801944704503094, 0.18368703209004544, 0.22163024199770665, 0.46158734848126115, 0.4725751618198992, 0.1998041376367331, 0.2584884918087428, 0.12682122132169205, 0.12559693818602224, 0.12166217719483863, 0.19853514726888388, 0.19236616341397828, 0.1862537475463657, 0.2026620546622242, 0.18274567894096672, 0.1662998613942568, 0.17797497297901987, 0.09690963510167216, 0.43131045648053956, 0.149866827260129, 0.2868026530490929, 0.2669646766198053, 0.28110491058621734, 0.21142133324468604, 0.3044296200478086, 0.5169409408402444, 0.5357420410345979, 0.31175744367937763, 0.28695256796654545, 0.3104878383466062, 0.348263853844224, 0.11562447182728086, 0.5673393808992695, 0.34041798499657727, 0.17841555867851588, 0.17756116285745105, 0.13975626578019074, 0.14652993192510055, 0.12931233820754406, 0.20472619400575554, 0.13987375825315662, 0.17088937261732173, 0.11511523340992003, 0.2979934774877705, 0.2305033023156351, 0.28817880996134126, 0.2440622245700974, 0.262928320551588, 0.28181553873054777, 0.2239139107940581, 0.2640521464987824, 0.27690567942690036, 0.614035309276102, 0.6849386287100123, 0.5834478146294717, 0.5679522571245758, 0.5057399009824285, 0.6117795079043433, 0.6136713454880558, 0.6469069483609697, 0.5030893323883259, 0.10765812097305172, 0.14557710721624884, 0.1066813198012263, 0.08877985400805266, 0.08375221061667215, 0.09875838588656294, 0.09632607109625402, 0.11529044711661351, 0.09520686335075368, 0.20691240321366455, 0.14002034892234327, 0.18940277867314403, 0.1779527766922231, 0.43679170746698415, 0.2242536575846268, 0.34182506197949647, 0.17312750322649895, 0.15740008902877323, 0.3668125215617306, 0.3765461899629181, 0.3595349598818315, 0.33974220136115485, 0.34182489341160127, 0.3452028095802492, 0.39102524113553316, 0.39820553935598657, 0.2070738281852379, 0.2613978288863885, 0.3358346592819559, 0.28445702188795086, 0.24407623770859066, 0.2726580263374029, 0.3162090950618671, 0.25625722750680247, 0.29111062371208996, 0.2791823614229766, 0.19245891286660977, 0.1698038574206534, 0.18523224451551135, 0.1952051268588384, 0.18354833210778754, 0.21094396633175871, 0.20515853080249202, 0.23761947239850756, 0.19181738857680264, 0.2959090826093115, 0.2032900896832368, 0.18632488561585225, 0.1949472199217248, 0.3932618484986893, 0.24955991271928935, 0.1915372516889956, 0.18828752558760675, 0.20649567527103696, 0.7326344763941118, 0.8288703624240127, 0.15180777243251942, 0.7890276962747119, 0.18783379377651854, 0.17487864936737207, 0.18173828535014303, 0.6901940754593975, 0.15512320812185265, 0.7503324037743441, 0.6239534936499597, 0.6560318105886904, 0.1835106034377837, 0.19662347209131592, 0.15824635346355242, 0.21212418169610936, 0.7511630708963973, 0.1252455997141324, 0.18319298564682263, 0.19570426896787907, 0.17477714932701105, 0.1794575836521457, 0.20205543105008605, 0.18544564910009276, 0.1796305530335247, 0.1636836462628326, 0.18360693310295106, 0.08359960191145999, 0.07723762018759595, 0.07398981323313858, 0.08013813884101673, 0.08462710928568251, 0.07867534901923978, 0.07565135012624014, 0.06518677515553917, 0.07715092936900603]}, "mutation_prompt": null}
{"id": "da704631-3c95-428d-8281-f812f62ed4ec", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0) * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation_scale = 0.5 + 0.5 * (1 - current_fitness / self.fitness.min())  # Added line\n        perturbation = np.random.uniform(-perturbation_size * perturbation_scale, perturbation_size * perturbation_scale, self.dim)  # Modified line\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Introduce adaptive scaling for perturbation size during local search to enhance local exploitation.", "configspace": "", "generation": 55, "fitness": 0.32587873465040124, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.23.", "error": "", "parent_id": "3d234e99-dfda-4fa5-985f-afa1766e23e2", "metadata": {"aucs": [0.742709118914029, 0.7150609150350593, 0.7493463597029024, 0.6801678349470704, 0.7714999974130508, 0.7591465905312728, 0.7231092364127356, 0.7324496986682971, 0.7318734872907601, 0.4859673618141487, 0.5892357115593874, 0.5488878585458672, 0.4945562494205624, 0.5443576622827283, 0.5305240904902261, 0.5898005189293176, 0.5730796442550679, 0.5871308431179278, 0.08605829115456487, 0.12120871401349942, 0.1396793608904875, 0.07932103404880841, 0.09776070135250137, 0.1968757165505618, 0.103380398910775, 0.1008993631778552, 0.10172588821372996, 0.08893616208979271, 0.10747822132608975, 0.08944522892935436, 0.10861673453266363, 0.12031806234102682, 0.10504343478571576, 0.11585532569017598, 0.15902960806773858, 0.0888027705099177, 0.8616019840220919, 0.9793133955653931, 0.893195288879111, 0.8240117627414354, 0.9521507386256574, 0.7513086189960404, 0.7839975018889662, 0.8187754855275645, 0.8044204551508132, 0.42635032230419956, 0.46814920605792254, 0.39737065391898363, 0.37067396580378986, 0.3988211805260439, 0.35261463489451395, 0.35349236601448064, 0.3563454712162424, 0.33707732082323394, 0.690556855773871, 0.7351466120956889, 0.7864717721136479, 0.7430791880466747, 0.75051391635894, 0.7334130454839736, 0.14637345759154163, 0.8135181845786905, 0.7397236117752193, 0.20400721589504045, 0.18441038508267282, 0.22197242704460074, 0.24624845110036964, 0.21197529773635826, 0.19442202750429127, 0.2849014432136895, 0.18674480548344996, 0.16411969153162242, 0.20371767169233868, 0.24723657653541664, 0.20092277132936676, 0.15541568049948185, 0.12316664323505955, 0.2049596802819973, 0.2468694044487818, 0.2901382848395906, 0.42240684590941624, 0.32349517305296815, 0.26683710014893147, 0.12218920572567638, 0.1391441271845668, 0.3648550606432245, 0.21822811888412164, 0.19979540930149053, 0.20121883737551893, 0.2724780167417894, 0.2554159705314797, 0.39764725361041486, 0.4258799460867996, 0.364180414887155, 0.36402171577225617, 0.34857795442638073, 0.4691919122844601, 0.4774164448950513, 0.5023531992552731, 0.1390768120782908, 0.09146844272149846, 0.17416121744599422, 0.14983630869466402, 0.2808110008039063, 0.1119282721659367, 0.17387564958661628, 0.08588906618879644, 0.14849242568772225, 0.21147361446441226, 0.24290498987131437, 0.20618463537975873, 0.2279868214798234, 0.2544947872029242, 0.20010640889877063, 0.22381554036979656, 0.20890605904207238, 0.2987375476899663, 0.6253227276573259, 0.6704052631989457, 0.611136105844677, 0.5032848646343833, 0.6502551866724038, 0.5351525052771136, 0.6652736843854029, 0.6089407988309103, 0.6134072825190304, 0.12058745081130418, 0.10598147966932392, 0.09162963793833345, 0.08450617313196085, 0.08693888145322815, 0.0812993231343122, 0.0991369965600033, 0.09125651043022376, 0.0797370255785701, 0.4692272056945437, 0.1873097467505459, 0.43921720743003856, 0.1380501775288956, 0.13488493234409593, 0.24146505680456287, 0.24113487009216394, 0.29063614420503425, 0.3295368869284576, 0.3713473351404565, 0.39067315711150163, 0.30085923266822157, 0.34200579065146053, 0.3629382228119131, 0.35436080557216, 0.4063087749223431, 0.4322373516368694, 0.3237739235962571, 0.31036507887750975, 0.28340332380777633, 0.3201780987694779, 0.2835404153867046, 0.2906532928523473, 0.27169130597551916, 0.28306906599499737, 0.3358202910145056, 0.25993135068934814, 0.1917757960207901, 0.19706179665749712, 0.21055118968864228, 0.18109268192560113, 0.17863718471218348, 0.18822080009449094, 0.19635978271830945, 0.20324803284043946, 0.19085422328471224, 0.5054825830563607, 0.17901094725087074, 0.1866396553619174, 0.29471706087524985, 0.21688973691173064, 0.26341300053331407, 0.20410549771696873, 0.1757563606108874, 0.1837624519630977, 0.16872388571075303, 0.1592831632819427, 0.1515569799153782, 0.7209967382517124, 0.17641889156685198, 0.1829833370650622, 0.17541931977575353, 0.1941223917443844, 0.15240388910973013, 0.7635131954305043, 0.7306676231493856, 0.148518812486076, 0.7190434297436041, 0.18758809358992512, 0.15813408984792754, 0.21212755760408386, 0.12681506621118466, 0.12572992730211918, 0.17392799094146139, 0.18073890507438028, 0.17733713509863847, 0.1683057699541356, 0.19341521120476268, 0.22443775231907015, 0.33924192631526007, 0.17745165516121486, 0.18255452882042533, 0.07868919329246815, 0.0805176723333143, 0.07384404461700067, 0.08085862015385048, 0.067302375192128, 0.0859204274788199, 0.0792671875819031, 0.07116037418629728, 0.06982384113316509]}, "mutation_prompt": null}
{"id": "09a817ec-42fc-4ee8-bd40-36a1998932b8", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0) * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def reseed_population(self):\n        random_indices = np.random.choice(self.population_size, size=int(0.1 * self.population_size), replace=False)\n        self.population[random_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(random_indices), self.dim))\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n            \n            if evaluations % (self.budget // 10) == 0:  # Reseed periodically to avoid premature convergence\n                self.reseed_population()\n                self.evaluate_population(func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Introduce random reseeding to prevent premature convergence and enhance exploration in the algorithm.", "configspace": "", "generation": 56, "fitness": 0.3328548539467332, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.24.", "error": "", "parent_id": "3d234e99-dfda-4fa5-985f-afa1766e23e2", "metadata": {"aucs": [0.717559516160507, 0.7564612959954643, 0.7528151849750144, 0.7021290068890653, 0.7520626925287053, 0.7921665677998277, 0.7613865945739913, 0.7040958823668713, 0.6987622756372167, 0.557917424468155, 0.6202804393490007, 0.5614637472967615, 0.5632668312547531, 0.5355349056983172, 0.5586533739678692, 0.5676084933451386, 0.5757363919566885, 0.5602227934280688, 0.1028441512206193, 0.11448596420085488, 0.11232837907849025, 0.11642705213259164, 0.1064476525453989, 0.09733459320275195, 0.09600142203438422, 0.09872551191273637, 0.13778601183295358, 0.08694284362369087, 0.10451687893126704, 0.08053503158926634, 0.10803679990578763, 0.12435727466608237, 0.09065384365890228, 0.09469213483077399, 0.0964814006346032, 0.10851832288695407, 0.9051560894045779, 0.9632976144751287, 0.9748200510248832, 0.7992943671742906, 0.8917915159553417, 0.7969036232810127, 0.7854717651200025, 0.9045572965780869, 0.869078862896797, 0.3758165169725074, 0.43221345546669354, 0.4012632485093963, 0.47129362083278104, 0.4003582282368491, 0.3600087629501305, 0.46488091587819436, 0.4722922826085866, 0.3620172332315831, 0.7121296572466637, 0.7503990012917537, 0.1654311433705592, 0.7774475175390633, 0.7542208273857466, 0.7716553242345255, 0.7360416414430455, 0.8027770542701451, 0.7674859504026734, 0.20338970364527176, 0.15313431812315736, 0.2147973839817242, 0.19449774975576328, 0.2007854882286364, 0.3600192164430528, 0.3366713272876314, 0.22359311961859019, 0.2773862838148785, 0.12651666701539377, 0.13140539967547482, 0.12164423638379829, 0.23265767307901108, 0.20960583611113814, 0.18371865270778565, 0.2338000712385916, 0.17441842120124562, 0.1719177311139778, 0.23431616107989717, 0.1050516309642553, 0.48516987168706294, 0.1350330637039333, 0.30059621146464965, 0.39340817247058235, 0.18117194210662424, 0.26046916275133347, 0.3420055955263691, 0.4355128558581962, 0.4068190539103229, 0.5324853160389551, 0.27036946507359205, 0.4110649428729811, 0.4090453900194424, 0.14279916520963398, 0.3452241151874589, 0.45761649860623854, 0.14357078317267602, 0.09366673711095352, 0.1349224666544303, 0.21595039166645058, 0.19585324217076128, 0.14730821656844417, 0.15405954049127246, 0.18032946885423684, 0.1090719696379212, 0.226607737373843, 0.2604795657740058, 0.25350167810401303, 0.21760424555997482, 0.24457724658874136, 0.27457027557998814, 0.25674891472906725, 0.2700615928612736, 0.2762530595027354, 0.6457615162930898, 0.6041523233752398, 0.5664232688667539, 0.46141802083227923, 0.5686801431875694, 0.5200389779593899, 0.596918197295099, 0.6187150165584399, 0.5310004531304999, 0.11135950343580514, 0.09618226018078879, 0.09736986119230784, 0.09243857647160547, 0.09032340251734117, 0.08761268628989705, 0.11288963124705265, 0.1111911202700212, 0.10647329549842521, 0.1326163427697622, 0.13393350613453348, 0.18030088123101318, 0.15286118858548758, 0.3751093180456915, 0.2363474137167214, 0.33033600916091466, 0.17899653501197121, 0.19370151942860425, 0.3635463607860654, 0.4210392669189832, 0.3286882586089427, 0.3611451225005382, 0.32188809754783143, 0.3248316600565623, 0.3382217352115904, 0.4023903706590638, 0.20682372365394663, 0.2668336863759644, 0.3173799124576324, 0.3248732526849818, 0.24486712373094466, 0.2910446595977334, 0.3170040457912442, 0.258947115842066, 0.32276570170664587, 0.30955539634892815, 0.20356416205420969, 0.17346756400025187, 0.1794981757281534, 0.19545549959684538, 0.18651175116789387, 0.21094396633175871, 0.20418071244025193, 0.23764682847610497, 0.20078541678858186, 0.2115534310398577, 0.20208481375806553, 0.19871713604616248, 0.18658985368350145, 0.1991037789281499, 0.24989308755086836, 0.19151084106653526, 0.18027030281982992, 0.20582876835925856, 0.7335128294754644, 0.8289515845207063, 0.15180777453830419, 0.7787004602317757, 0.18785570824834452, 0.17487853370596618, 0.18173811284486818, 0.6991660185097117, 0.15512464397752013, 0.7367224763260257, 0.625716040236878, 0.6538885485141572, 0.18417529734046778, 0.19660364336833058, 0.15824793435281337, 0.21212418931280352, 0.7481423113707935, 0.12524534055430758, 0.18800006854625984, 0.19570426896787907, 0.17988446315039242, 0.1815012092606788, 0.20205543105008605, 0.18334098778219488, 0.17481658592492844, 0.17085799162544646, 0.1835950091157068, 0.08360742529342768, 0.07340452234424955, 0.0852344222671505, 0.07401963980676851, 0.08420775030777983, 0.07375153924094446, 0.0743067126495065, 0.07334467056976413, 0.07321447744173926]}, "mutation_prompt": null}
{"id": "3e002f9d-6921-4169-b39c-d14cfe54341f", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0) * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        diversity = np.std(self.population, axis=0).mean()  # Calculate population diversity\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min()) * diversity\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Introduce adaptive local search perturbation scale based on population diversity to enhance local search efficiency.", "configspace": "", "generation": 57, "fitness": 0.3321824725880775, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.23.", "error": "", "parent_id": "3d234e99-dfda-4fa5-985f-afa1766e23e2", "metadata": {"aucs": [0.7609684488070749, 0.7867667861045654, 0.7614807514189663, 0.7293207891001792, 0.7611212564588203, 0.748736062948327, 0.7420459223408734, 0.7363755744545508, 0.6697180504466194, 0.570627524509199, 0.5802555579914324, 0.5790143715448384, 0.5370732754273266, 0.5577201842657035, 0.5551760382550746, 0.5648346370585065, 0.5931863172848093, 0.5323740045014509, 0.10056175259165323, 0.11446568939998303, 0.09872368726287584, 0.1041147162940792, 0.11336028609052462, 0.11533732351130399, 0.11680487146007779, 0.09628587298376445, 0.14260744207761233, 0.08555747019088245, 0.07836209255967408, 0.09829784183841184, 0.09861380982858647, 0.08764268382740192, 0.1168797587566569, 0.11914905258411013, 0.09974508953988914, 0.09278387673931687, 0.8968809532890194, 0.9286738551685246, 0.9680776815207845, 0.7962650540098656, 0.9106504574499209, 0.8999217109978842, 0.8626677822917637, 0.8544646154510673, 0.8037109853287612, 0.3854848921180539, 0.4530219191242204, 0.40362380893640204, 0.4760254572640349, 0.3642757643096124, 0.34521620864792213, 0.43992083413799987, 0.39808601268166055, 0.3745681105000247, 0.743467406063127, 0.7553589803251126, 0.725317796512555, 0.7374486647365807, 0.7348401279912862, 0.7330683982138653, 0.7942091446963551, 0.7288040577750068, 0.7728405922453289, 0.17824183454861464, 0.33984182192393586, 0.17258806059852827, 0.25567778146615194, 0.19959054128439935, 0.2062846070266814, 0.19447851108031722, 0.18939928023040642, 0.2305658492023661, 0.12777449302873412, 0.16360915625926575, 0.12277378817295448, 0.28898063992440715, 0.2139589836447825, 0.1962845202622967, 0.12105685198803107, 0.2101179675891396, 0.1236765812736712, 0.2667866250712575, 0.3320890887468084, 0.40914133758293647, 0.25324683390346703, 0.35752255724547144, 0.19216677829632256, 0.26000885578365196, 0.40445376497945307, 0.2025584098019494, 0.3733531335859144, 0.27730342887292225, 0.33156786507152713, 0.40307885298571267, 0.2828453828655032, 0.23775385381454162, 0.21137037925931312, 0.4232246688193252, 0.36331524410476534, 0.07832611664986566, 0.09712393506984318, 0.17931311769229563, 0.15798859329084258, 0.22949521242715798, 0.11020890572105413, 0.10769772172096892, 0.17105500514652971, 0.22488726675040194, 0.25192848080721, 0.21274234447395357, 0.2492850809592324, 0.23325032505987797, 0.24782251293516644, 0.30966534523168787, 0.28490668501664584, 0.3099287454617321, 0.2725557741587856, 0.6650698684971623, 0.5605694597304292, 0.6806814898285178, 0.6462580795529829, 0.5559297486127532, 0.6028186953751258, 0.549490257700856, 0.5766685194064921, 0.5289375673615084, 0.08811979174134266, 0.12060816406229768, 0.09773944905333942, 0.09822736013775757, 0.10464987895911038, 0.1104110733983904, 0.0995058461165419, 0.12459948541704746, 0.08905418759723305, 0.19688748734258765, 0.3586254467941523, 0.32486287582527706, 0.21548852364225501, 0.46160426901944274, 0.16264818739063847, 0.39610663254255185, 0.23198462150810928, 0.22139991912074497, 0.32185056893332487, 0.3121853262358756, 0.3495802936744622, 0.34064030597461914, 0.3306156520788127, 0.35413846878745303, 0.2915470770613482, 0.4556258809523699, 0.40851177125365934, 0.27336246216897087, 0.2970249069366979, 0.24075143516089004, 0.24893057781752959, 0.265538375968256, 0.22655699606045943, 0.30907079933583137, 0.34623440089858026, 0.24253688891780856, 0.20508994173909267, 0.18844456817610133, 0.18994341592375585, 0.19344654105718573, 0.20727413957574004, 0.18677517438191138, 0.20366166818947407, 0.18536427819508328, 0.19237335688365376, 0.20458306660882708, 0.18658107899193221, 0.19909724807626583, 0.18879249341262927, 0.38960456096143525, 0.1905659185527503, 0.21880474658493654, 0.1956912900666531, 0.1828637167878533, 0.16434460015694385, 0.7124339461795934, 0.15222954047700754, 0.18176768941628274, 0.17760398434370295, 0.18455932788538376, 0.18211707797402066, 0.7850850800418491, 0.7580049930061751, 0.7685809596913541, 0.5583323422477342, 0.15147298872733495, 0.19495969547753056, 0.20014262457450338, 0.7424367354336203, 0.212253032152958, 0.126912746520638, 0.12695596499136774, 0.18829074387976474, 0.18684133538119574, 0.1752013022543446, 0.17395214453342633, 0.19307858196102978, 0.17788700118322176, 0.18768550906897186, 0.18166261602004463, 0.2265272768064327, 0.06805108090198775, 0.07678985584573561, 0.07358606260447453, 0.07569506199830378, 0.08412417137190298, 0.07273687603146062, 0.07937956815126057, 0.09233374952130013, 0.08694189298436816]}, "mutation_prompt": null}
{"id": "9719434b-9d11-4d62-864b-e63958b9c454", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0) * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Introduce adaptive scaling for crossover probability based on function evaluations to improve exploration and exploitation balance.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3d234e99-dfda-4fa5-985f-afa1766e23e2", "metadata": {"aucs": [0.7038313688403066, 0.743928857802591, 0.7560508206163828, 0.7219173056875023, 0.7421079591792674, 0.7930009329679681, 0.7436785203822623, 0.7198040777536261, 0.7002810856294976, 0.5716574770009174, 0.5976046946297183, 0.5551544665886294, 0.5076641482355237, 0.5169063357640791, 0.5736410575901869, 0.5306148911229513, 0.592124132112893, 0.5661765801498353, 0.13241238294815627, 0.12824622145445608, 0.11783580031424368, 0.10491957026507948, 0.1046342580125793, 0.09230025528669872, 0.1048419077341417, 0.1299915749972812, 0.09644327262565544, 0.09456194348308711, 0.11358687995875827, 0.09142756080072645, 0.1312681347887541, 0.11240367198556855, 0.10033249518500487, 0.09350380506174205, 0.10979080295412291, 0.09984191722225255, 0.9051560894045779, 0.9632976144751287, 0.9748200510248832, 0.7992943671742906, 0.8917915159553417, 0.7969036232810127, 0.7854717651200025, 0.9045572965780869, 0.869078862896797, 0.40981073050894923, 0.39054194085519134, 0.33586528620035805, 0.4516489025314623, 0.39952960342178545, 0.4328168420558757, 0.39180403341474945, 0.3442268351509773, 0.3671331186038451, 0.7708797596734744, 0.7063466521852724, 0.1654311433705592, 0.7770868544110645, 0.7468771429838391, 0.7592243351409629, 0.7353826439928655, 0.8027770542701451, 0.7389399434191213, 0.19132009492168456, 0.15295347740444465, 0.19801944704503094, 0.18368703209004544, 0.22163024199770665, 0.46158734848126115, 0.4725751618198992, 0.1998041376367331, 0.2584884918087428, 0.12682122132169205, 0.12559693818602224, 0.12166217719483863, 0.19853514726888388, 0.19236616341397828, 0.1862537475463657, 0.2026620546622242, 0.18274567894096672, 0.1662998613942568, 0.17797497297901987, 0.09690963510167216, 0.43131045648053956, 0.149866827260129, 0.2868026530490929, 0.2669646766198053, 0.28110491058621734, 0.21142133324468604, 0.3044296200478086, 0.5169409408402444, 0.5357420410345979, 0.31175744367937763, 0.28695256796654545, 0.3104878383466062, 0.348263853844224, 0.11562447182728086, 0.5673393808992695, 0.34041798499657727, 0.17841555867851588, 0.17756116285745105, 0.13975626578019074, 0.14652993192510055, 0.12931233820754406, 0.20472619400575554, 0.13987375825315662, 0.17088937261732173, 0.11511523340992003, 0.2979934774877705, 0.2305033023156351, 0.28817880996134126, 0.2440622245700974, 0.262928320551588, 0.28181553873054777, 0.2239139107940581, 0.2640521464987824, 0.27690567942690036, 0.614035309276102, 0.6849386287100123, 0.5834478146294717, 0.5679522571245758, 0.5057399009824285, 0.6117795079043433, 0.6136713454880558, 0.6469069483609697, 0.5030893323883259, 0.10765812097305172, 0.14557710721624884, 0.1066813198012263, 0.08877985400805266, 0.08375221061667215, 0.09875838588656294, 0.09632607109625402, 0.11529044711661351, 0.09520686335075368, 0.20691240321366455, 0.14002034892234327, 0.18940277867314403, 0.1779527766922231, 0.43679170746698415, 0.2242536575846268, 0.34182506197949647, 0.17312750322649895, 0.15740008902877323, 0.3668125215617306, 0.3765461899629181, 0.3595349598818315, 0.33974220136115485, 0.34182489341160127, 0.3452028095802492, 0.39102524113553316, 0.39820553935598657, 0.2070738281852379, 0.2613978288863885, 0.3358346592819559, 0.28445702188795086, 0.24407623770859066, 0.2726580263374029, 0.3162090950618671, 0.25625722750680247, 0.29111062371208996, 0.2791823614229766, 0.19245891286660977, 0.1698038574206534, 0.18523224451551135, 0.1952051268588384, 0.18354833210778754, 0.21094396633175871, 0.20515853080249202, 0.23761947239850756, 0.19181738857680264, 0.2959090826093115, 0.2032900896832368, 0.18632488561585225, 0.1949472199217248, 0.3932618484986893, 0.24955991271928935, 0.1915372516889956, 0.18828752558760675, 0.20649567527103696, 0.7326344763941118, 0.8288703624240127, 0.15180777243251942, 0.7890276962747119, 0.18783379377651854, 0.17487864936737207, 0.18173828535014303, 0.6901940754593975, 0.15512320812185265, 0.7503324037743441, 0.6239534936499597, 0.6560318105886904, 0.1835106034377837, 0.19662347209131592, 0.15824635346355242, 0.21212418169610936, 0.7511630708963973, 0.1252455997141324, 0.18319298564682263, 0.19570426896787907, 0.17477714932701105, 0.1794575836521457, 0.20205543105008605, 0.18544564910009276, 0.1796305530335247, 0.1636836462628326, 0.18360693310295106, 0.08359960191145999, 0.07723762018759595, 0.07398981323313858, 0.08013813884101673, 0.08462710928568251, 0.07867534901923978, 0.07565135012624014, 0.06518677515553917, 0.07715092936900603]}, "mutation_prompt": null}
{"id": "c5a19c71-1cfa-4f20-b03e-71388f9ea6e6", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        diversity = np.std(self.population, axis=0).mean()  # Compute diversity across dimensions\n        self.F = np.random.uniform(0.5, 1.0) * (1 - self.current_iteration / self.budget) * diversity  # Adjust mutation factor with diversity\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Enhance adaptive mutation scaling by incorporating diversity metrics to improve exploration and balance.", "configspace": "", "generation": 59, "fitness": 0.22126488990582996, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.21.", "error": "", "parent_id": "3d234e99-dfda-4fa5-985f-afa1766e23e2", "metadata": {"aucs": [0.5472064450349621, 0.5209452748865486, 0.6370378386410596, 0.5497756500665252, 0.7295994925636251, 0.7331924716696182, 0.5647511347987317, 0.49381002484768, 0.4918315118927993, 0.18967293184348877, 0.2953764480684129, 0.27364065023329254, 0.13237939162669632, 0.26895860875637756, 0.34851877204972737, 0.24570906562270012, 0.1783092505551338, 0.1620880811403751, 0.055018621909638354, 0.2096893033322651, 0.10957156632819276, 0.15681846713123937, 0.07013630612949295, 0.08913372754302895, 0.1090593087185665, 0.0839832634201626, 0.07931040242096876, 0.0503078734373017, 0.0932947993144051, 0.08156213864086637, 0.09134733901619252, 0.07221724496532278, 0.0353353191631397, 0.05489075250696873, 0.05983265092790768, 0.08813591172325885, 0.9527723823482527, 0.9794000519520227, 0.9809806566848546, 0.9546392421147818, 0.9705470610627893, 0.9206357949910838, 0.9538195985953952, 0.9642697470328117, 0.9960914314004572, 0.3986935086302066, 0.3275186168494515, 0.27022549120367556, 0.29250915058173677, 0.39506722158880525, 0.25709666260378294, 0.36102524448993056, 0.21264977410646901, 0.3150810991058923, 0.628187467424999, 0.17838819174111797, 0.2580839791470739, 0.14973109875574897, 0.3991900950365591, 0.5285356310836944, 0.18055778640849185, 0.1717207478820728, 0.7077064935371284, 0.2126548183705873, 0.10949692737271999, 0.16447747347391828, 0.09889059539959655, 0.1334438349664928, 0.11016811246550207, 0.2323493900282354, 0.16001778453376414, 0.1181719118672574, 0.1861867285290164, 0.33138705977867444, 0.11752099456728227, 0.21995997517447308, 0.1496536134335381, 0.12197553383303639, 0.14096010650791235, 0.0865924849646843, 0.1997303928205474, 0.048528362884499465, 0.06446131323827664, 0.09694686999223345, 9.999999999998899e-05, 0.03166239335551546, 0.013266626268146453, 0.00025444387148343406, 9.999999999998899e-05, 0.049227298086681026, 0.04599483217624856, 0.06395456371111463, 0.0713022725065704, 0.15869240324766665, 0.06636080324480786, 0.018834840881853943, 0.21484384242533872, 0.07032947968903502, 0.2544421753405036, 0.027816748666241953, 0.0589224657756271, 0.06995018634584416, 0.07058186267781441, 0.10301218398510359, 0.04985517950715257, 0.00702633917498352, 0.06046507219690689, 0.09111247124080224, 0.1366948144707123, 0.21826905959771636, 0.21384695156618871, 0.14685165202267814, 0.1441619020933691, 0.2297526575783566, 0.22326357213225556, 0.2074514348354103, 0.11565129365617155, 0.36713611524987944, 0.4797877626566647, 0.4319956764727202, 0.43839972154324036, 0.4831869617011505, 0.49205326822323736, 0.5106936520527822, 0.42783332130606355, 0.45316097305551295, 0.07658459704611509, 0.06968768008134285, 0.08246213223808951, 0.065905744331485, 0.05081692279898964, 0.0763752356702262, 0.08884425583365141, 0.05586505969793565, 0.06234452176445793, 0.15172403001280144, 0.14319187039377756, 0.1563956305197608, 0.27073783360856096, 0.16287211062128937, 0.13692329019977445, 0.1743456348962371, 0.24270673949729393, 0.3486154374380781, 0.1854535399264844, 0.17229308242947738, 0.2068112037997164, 0.14799413061394373, 0.2724541170206658, 0.15936943677502857, 0.18178168291910868, 0.2733631484934306, 0.3079464030249547, 0.08815343031017964, 0.10332186508229957, 0.12251255656970295, 0.177916481374365, 0.2089342793597262, 0.05975321036686765, 0.10360688228343917, 0.15080784421619553, 0.1553112179303051, 0.19075585260533767, 0.1895703951181663, 0.14841546004302142, 0.14181739331537102, 0.14721521569088314, 0.14378908397901302, 0.15469796740941633, 0.15452216821561537, 0.14411915543538856, 0.12139711993884539, 0.12725362461706413, 0.15040848333704615, 0.16491710967579187, 0.13243266858850788, 0.14007620284560385, 0.0935544672961176, 0.18913237006706185, 0.15107237385363093, 0.4806142566577295, 0.14022711346862193, 0.16628880574770788, 0.16706648195307772, 0.4372957983077195, 0.17535390045192345, 0.16094198622909228, 0.1749928254178158, 0.11257180126953203, 0.13741428728709526, 0.15644960000676877, 0.13810134869061708, 0.09194962533475481, 0.08108710725069035, 0.11948195370446757, 0.2066382224789477, 0.11548010392295349, 0.19730537208563104, 0.17838980596546283, 0.192032690577575, 0.19031193510271371, 0.20517770412818281, 0.1764574989105131, 0.1995340589410507, 0.18409905974560092, 0.2014303702287359, 0.21900857101718152, 0.04921746516464498, 0.05906261983472194, 0.06633091836468485, 0.05141398118738505, 0.05987273109122071, 0.05232594309927718, 0.06398436381435113, 0.061737588052974246, 0.06479214691245139]}, "mutation_prompt": null}
{"id": "5c1cb389-7baa-4831-ba1c-d60d3c79ad54", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0) * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Introduce adaptive scaling for crossover probability based on function evaluations to improve exploration and exploitation balance.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3d234e99-dfda-4fa5-985f-afa1766e23e2", "metadata": {"aucs": [0.7038313688403066, 0.743928857802591, 0.7560508206163828, 0.7219173056875023, 0.7421079591792674, 0.7930009329679681, 0.7436785203822623, 0.7198040777536261, 0.7002810856294976, 0.5716574770009174, 0.5976046946297183, 0.5551544665886294, 0.5076641482355237, 0.5169063357640791, 0.5736410575901869, 0.5306148911229513, 0.592124132112893, 0.5661765801498353, 0.13241238294815627, 0.12824622145445608, 0.11783580031424368, 0.10491957026507948, 0.1046342580125793, 0.09230025528669872, 0.1048419077341417, 0.1299915749972812, 0.09644327262565544, 0.09456194348308711, 0.11358687995875827, 0.09142756080072645, 0.1312681347887541, 0.11240367198556855, 0.10033249518500487, 0.09350380506174205, 0.10979080295412291, 0.09984191722225255, 0.9051560894045779, 0.9632976144751287, 0.9748200510248832, 0.7992943671742906, 0.8917915159553417, 0.7969036232810127, 0.7854717651200025, 0.9045572965780869, 0.869078862896797, 0.40981073050894923, 0.39054194085519134, 0.33586528620035805, 0.4516489025314623, 0.39952960342178545, 0.4328168420558757, 0.39180403341474945, 0.3442268351509773, 0.3671331186038451, 0.7708797596734744, 0.7063466521852724, 0.1654311433705592, 0.7770868544110645, 0.7468771429838391, 0.7592243351409629, 0.7353826439928655, 0.8027770542701451, 0.7389399434191213, 0.19132009492168456, 0.15295347740444465, 0.19801944704503094, 0.18368703209004544, 0.22163024199770665, 0.46158734848126115, 0.4725751618198992, 0.1998041376367331, 0.2584884918087428, 0.12682122132169205, 0.12559693818602224, 0.12166217719483863, 0.19853514726888388, 0.19236616341397828, 0.1862537475463657, 0.2026620546622242, 0.18274567894096672, 0.1662998613942568, 0.17797497297901987, 0.09690963510167216, 0.43131045648053956, 0.149866827260129, 0.2868026530490929, 0.2669646766198053, 0.28110491058621734, 0.21142133324468604, 0.3044296200478086, 0.5169409408402444, 0.5357420410345979, 0.31175744367937763, 0.28695256796654545, 0.3104878383466062, 0.348263853844224, 0.11562447182728086, 0.5673393808992695, 0.34041798499657727, 0.17841555867851588, 0.17756116285745105, 0.13975626578019074, 0.14652993192510055, 0.12931233820754406, 0.20472619400575554, 0.13987375825315662, 0.17088937261732173, 0.11511523340992003, 0.2979934774877705, 0.2305033023156351, 0.28817880996134126, 0.2440622245700974, 0.262928320551588, 0.28181553873054777, 0.2239139107940581, 0.2640521464987824, 0.27690567942690036, 0.614035309276102, 0.6849386287100123, 0.5834478146294717, 0.5679522571245758, 0.5057399009824285, 0.6117795079043433, 0.6136713454880558, 0.6469069483609697, 0.5030893323883259, 0.10765812097305172, 0.14557710721624884, 0.1066813198012263, 0.08877985400805266, 0.08375221061667215, 0.09875838588656294, 0.09632607109625402, 0.11529044711661351, 0.09520686335075368, 0.20691240321366455, 0.14002034892234327, 0.18940277867314403, 0.1779527766922231, 0.43679170746698415, 0.2242536575846268, 0.34182506197949647, 0.17312750322649895, 0.15740008902877323, 0.3668125215617306, 0.3765461899629181, 0.3595349598818315, 0.33974220136115485, 0.34182489341160127, 0.3452028095802492, 0.39102524113553316, 0.39820553935598657, 0.2070738281852379, 0.2613978288863885, 0.3358346592819559, 0.28445702188795086, 0.24407623770859066, 0.2726580263374029, 0.3162090950618671, 0.25625722750680247, 0.29111062371208996, 0.2791823614229766, 0.19245891286660977, 0.1698038574206534, 0.18523224451551135, 0.1952051268588384, 0.18354833210778754, 0.21094396633175871, 0.20515853080249202, 0.23761947239850756, 0.19181738857680264, 0.2959090826093115, 0.2032900896832368, 0.18632488561585225, 0.1949472199217248, 0.3932618484986893, 0.24955991271928935, 0.1915372516889956, 0.18828752558760675, 0.20649567527103696, 0.7326344763941118, 0.8288703624240127, 0.15180777243251942, 0.7890276962747119, 0.18783379377651854, 0.17487864936737207, 0.18173828535014303, 0.6901940754593975, 0.15512320812185265, 0.7503324037743441, 0.6239534936499597, 0.6560318105886904, 0.1835106034377837, 0.19662347209131592, 0.15824635346355242, 0.21212418169610936, 0.7511630708963973, 0.1252455997141324, 0.18319298564682263, 0.19570426896787907, 0.17477714932701105, 0.1794575836521457, 0.20205543105008605, 0.18544564910009276, 0.1796305530335247, 0.1636836462628326, 0.18360693310295106, 0.08359960191145999, 0.07723762018759595, 0.07398981323313858, 0.08013813884101673, 0.08462710928568251, 0.07867534901923978, 0.07565135012624014, 0.06518677515553917, 0.07715092936900603]}, "mutation_prompt": null}
{"id": "13a0bd94-c137-41b7-8a9b-ee23bff92f99", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0) * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Introduce adaptive scaling for crossover probability based on function evaluations to improve exploration and exploitation balance.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3d234e99-dfda-4fa5-985f-afa1766e23e2", "metadata": {"aucs": [0.7038313688403066, 0.743928857802591, 0.7560508206163828, 0.7219173056875023, 0.7421079591792674, 0.7930009329679681, 0.7436785203822623, 0.7198040777536261, 0.7002810856294976, 0.5716574770009174, 0.5976046946297183, 0.5551544665886294, 0.5076641482355237, 0.5169063357640791, 0.5736410575901869, 0.5306148911229513, 0.592124132112893, 0.5661765801498353, 0.13241238294815627, 0.12824622145445608, 0.11783580031424368, 0.10491957026507948, 0.1046342580125793, 0.09230025528669872, 0.1048419077341417, 0.1299915749972812, 0.09644327262565544, 0.09456194348308711, 0.11358687995875827, 0.09142756080072645, 0.1312681347887541, 0.11240367198556855, 0.10033249518500487, 0.09350380506174205, 0.10979080295412291, 0.09984191722225255, 0.9051560894045779, 0.9632976144751287, 0.9748200510248832, 0.7992943671742906, 0.8917915159553417, 0.7969036232810127, 0.7854717651200025, 0.9045572965780869, 0.869078862896797, 0.40981073050894923, 0.39054194085519134, 0.33586528620035805, 0.4516489025314623, 0.39952960342178545, 0.4328168420558757, 0.39180403341474945, 0.3442268351509773, 0.3671331186038451, 0.7708797596734744, 0.7063466521852724, 0.1654311433705592, 0.7770868544110645, 0.7468771429838391, 0.7592243351409629, 0.7353826439928655, 0.8027770542701451, 0.7389399434191213, 0.19132009492168456, 0.15295347740444465, 0.19801944704503094, 0.18368703209004544, 0.22163024199770665, 0.46158734848126115, 0.4725751618198992, 0.1998041376367331, 0.2584884918087428, 0.12682122132169205, 0.12559693818602224, 0.12166217719483863, 0.19853514726888388, 0.19236616341397828, 0.1862537475463657, 0.2026620546622242, 0.18274567894096672, 0.1662998613942568, 0.17797497297901987, 0.09690963510167216, 0.43131045648053956, 0.149866827260129, 0.2868026530490929, 0.2669646766198053, 0.28110491058621734, 0.21142133324468604, 0.3044296200478086, 0.5169409408402444, 0.5357420410345979, 0.31175744367937763, 0.28695256796654545, 0.3104878383466062, 0.348263853844224, 0.11562447182728086, 0.5673393808992695, 0.34041798499657727, 0.17841555867851588, 0.17756116285745105, 0.13975626578019074, 0.14652993192510055, 0.12931233820754406, 0.20472619400575554, 0.13987375825315662, 0.17088937261732173, 0.11511523340992003, 0.2979934774877705, 0.2305033023156351, 0.28817880996134126, 0.2440622245700974, 0.262928320551588, 0.28181553873054777, 0.2239139107940581, 0.2640521464987824, 0.27690567942690036, 0.614035309276102, 0.6849386287100123, 0.5834478146294717, 0.5679522571245758, 0.5057399009824285, 0.6117795079043433, 0.6136713454880558, 0.6469069483609697, 0.5030893323883259, 0.10765812097305172, 0.14557710721624884, 0.1066813198012263, 0.08877985400805266, 0.08375221061667215, 0.09875838588656294, 0.09632607109625402, 0.11529044711661351, 0.09520686335075368, 0.20691240321366455, 0.14002034892234327, 0.18940277867314403, 0.1779527766922231, 0.43679170746698415, 0.2242536575846268, 0.34182506197949647, 0.17312750322649895, 0.15740008902877323, 0.3668125215617306, 0.3765461899629181, 0.3595349598818315, 0.33974220136115485, 0.34182489341160127, 0.3452028095802492, 0.39102524113553316, 0.39820553935598657, 0.2070738281852379, 0.2613978288863885, 0.3358346592819559, 0.28445702188795086, 0.24407623770859066, 0.2726580263374029, 0.3162090950618671, 0.25625722750680247, 0.29111062371208996, 0.2791823614229766, 0.19245891286660977, 0.1698038574206534, 0.18523224451551135, 0.1952051268588384, 0.18354833210778754, 0.21094396633175871, 0.20515853080249202, 0.23761947239850756, 0.19181738857680264, 0.2959090826093115, 0.2032900896832368, 0.18632488561585225, 0.1949472199217248, 0.3932618484986893, 0.24955991271928935, 0.1915372516889956, 0.18828752558760675, 0.20649567527103696, 0.7326344763941118, 0.8288703624240127, 0.15180777243251942, 0.7890276962747119, 0.18783379377651854, 0.17487864936737207, 0.18173828535014303, 0.6901940754593975, 0.15512320812185265, 0.7503324037743441, 0.6239534936499597, 0.6560318105886904, 0.1835106034377837, 0.19662347209131592, 0.15824635346355242, 0.21212418169610936, 0.7511630708963973, 0.1252455997141324, 0.18319298564682263, 0.19570426896787907, 0.17477714932701105, 0.1794575836521457, 0.20205543105008605, 0.18544564910009276, 0.1796305530335247, 0.1636836462628326, 0.18360693310295106, 0.08359960191145999, 0.07723762018759595, 0.07398981323313858, 0.08013813884101673, 0.08462710928568251, 0.07867534901923978, 0.07565135012624014, 0.06518677515553917, 0.07715092936900603]}, "mutation_prompt": null}
{"id": "20827eb3-2650-4312-9a0d-59dfb2900357", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0) * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / max(self.fitness.min(), self.fitness.std()))\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Introduce a dynamic perturbation size scaling based on fitness variability to enhance local search during optimization.", "configspace": "", "generation": 62, "fitness": 0.3142146048915155, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.", "error": "", "parent_id": "3d234e99-dfda-4fa5-985f-afa1766e23e2", "metadata": {"aucs": [0.7038313688403066, 0.743928857802591, 0.7560508206163828, 0.7219173056875023, 0.7421079591792674, 0.7930009329679681, 0.7059961724685229, 0.7285098935020151, 0.7107828979379904, 0.5847823451738772, 0.5922051025732369, 0.5209755487554244, 0.6013143482691347, 0.5475720105954274, 0.5806092646229128, 0.556954911768297, 0.5518035070719518, 0.4173855082107757, 0.10382829516171677, 0.11443834536876618, 0.11053638257081932, 0.09904640937331965, 0.10512478149096638, 0.09720798118323581, 0.11439483489713398, 0.12226491993068811, 0.10927887380170376, 0.10405290231674058, 0.08687821101739845, 0.10410506701121958, 0.0980356939348982, 0.1164116844288332, 0.08506254334751029, 0.0995615639438574, 0.104523499288383, 0.12875248233143177, 0.7807074076908134, 0.9626167547563104, 0.8811592525854655, 0.7992943671742906, 0.8917915159553417, 0.7969036232810127, 0.7854717651200025, 0.9045572965780869, 0.869078862896797, 0.42605570353699884, 0.35350541119391643, 0.28347300822062715, 0.33419107928188696, 0.39249672557270954, 0.29995508427897677, 0.34085515849953707, 0.13282234235081558, 0.24301063652998267, 0.753960542105695, 0.7845473882619156, 0.21963701377095546, 0.7563331616390745, 0.7892347978439933, 0.335457555648099, 0.6062593873073301, 0.6949296088720958, 0.6041316444440471, 0.12043285818296356, 0.1143813341003348, 0.1938199596524841, 0.34417756081672357, 0.27256915708893226, 0.42007313764613574, 0.1769757633114858, 0.17781201014617232, 0.15095393885844766, 0.10482420174699492, 0.13285129094659875, 0.23020304530831082, 0.124354675007181, 0.2764183647591938, 0.26308237121510525, 0.2121392950700539, 0.12684248803673503, 0.181022215368148, 0.3770220416647385, 9.999999999998899e-05, 0.4099737129150218, 0.48512450800472817, 0.3059875591217883, 0.1058248684147417, 0.09657759778199304, 0.1118897307738036, 0.08157342772782372, 0.41595636066858055, 0.2888517750702363, 0.3585904500717343, 0.33346882924057475, 0.3944377950436778, 0.25094162464283154, 0.42363944335681725, 0.2439162196523097, 0.38648252302782515, 0.08709647839524148, 0.04788767029771446, 0.12162681488832328, 0.1371559122182724, 0.09641399268101836, 0.1501071674039809, 0.10900280117950623, 0.09784063472347848, 0.08511601641820743, 0.29344597597721755, 0.21950891941820505, 0.2373609741280085, 0.28798552406955524, 0.29488745337141586, 0.25657062437562206, 0.17499678926163054, 0.2764052050296232, 0.2316998528089027, 0.5496098382791806, 0.5281629459561719, 0.5728600077327533, 0.4832467269018459, 0.4984035990182618, 0.602477245875477, 0.5439593109908726, 0.6469069483609697, 0.5030893323883259, 0.10765812097305172, 0.11162808959965864, 0.1066813198012263, 0.09675139733271809, 0.09407904298897607, 0.09750876800523733, 0.08012026830088925, 0.13337511175199945, 0.08988791024630605, 0.20691240321366455, 0.14002034892234327, 0.18940277867314403, 0.12464180281147585, 0.17470679716456528, 0.15305985493762964, 0.34182506197949647, 0.17312750322649895, 0.15740008902877323, 0.3666322891272925, 0.37273386965448807, 0.3600449443859818, 0.33974220136115485, 0.3265025904309615, 0.3452028095802492, 0.39102524113553316, 0.39820553935598657, 0.2070738281852379, 0.21618743149017505, 0.27737345012695513, 0.2587528242721897, 0.3326382452059953, 0.31034283658509, 0.2900146852027988, 0.25625722750680247, 0.29111062371208996, 0.2791823614229766, 0.19497794383291522, 0.19585775580650155, 0.1767797584191667, 0.1952051268588384, 0.18354833210778754, 0.21094396633175871, 0.20515853080249202, 0.23761947239850756, 0.19181738857680264, 0.19803953822327225, 0.17995475134912997, 0.19311193860999742, 0.28880887242148967, 0.21009098845407648, 0.17256323361267756, 0.19372358264814615, 0.2108660744997991, 0.1592832750775095, 0.7326344763941118, 0.8288703624240127, 0.15180777243251942, 0.7326831589770169, 0.1831489935438776, 0.17561719205278004, 0.35104612683932335, 0.18905809514761462, 0.6901236261300896, 0.20172680966429501, 0.7056752260424458, 0.15091561238684104, 0.1835106034377837, 0.19662347209131592, 0.15824635346355242, 0.20645289882166296, 0.8262616061787738, 0.710881324289786, 0.18319298564682263, 0.19570426896787907, 0.17477714932701105, 0.1797824629499153, 0.18137916319336544, 0.17018547761488245, 0.17558323386588814, 0.2055033095635056, 0.22375879083087735, 0.08359960191145999, 0.07723762018759595, 0.07398981323313858, 0.08013813884101673, 0.08462710928568251, 0.07867534901923978, 0.07565135012624014, 0.06518677515553917, 0.07715092936900603]}, "mutation_prompt": null}
{"id": "236850eb-0fa2-4517-8fd8-9236fd6252c9", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0) * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                # Increase local search frequency near best solution\n                if np.random.rand() < (1 - self.fitness[i] / self.fitness.min()):\n                    trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Introduce an adaptive increase in local search frequency based on proximity to the global best solution to improve convergence.", "configspace": "", "generation": 63, "fitness": 0.37435655191031825, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.28.", "error": "", "parent_id": "3d234e99-dfda-4fa5-985f-afa1766e23e2", "metadata": {"aucs": [0.8987260391577574, 0.9071434572359618, 0.9097306352549602, 0.9100527847133607, 0.9172994439470689, 0.9165643472766625, 0.9177557005843653, 0.9073450893243553, 0.8980181542478711, 0.817323327393582, 0.8042022840603013, 0.7848269543332402, 0.8153923524658081, 0.8265557584761498, 0.7818089535604563, 0.8156798115323559, 0.8167669353710741, 0.22222209192942888, 0.160429725063447, 0.15846710295237676, 0.1739977528487039, 0.48439104990335324, 0.34064817934125435, 0.1575387691604001, 0.14344342707591928, 0.15489633340077713, 0.1744780882855652, 0.14448999035308585, 0.13668038331482113, 0.12704279898386872, 0.14623534392507642, 0.13938105173688087, 0.1195536358271937, 0.1400838792164315, 0.14545714298442236, 0.11024739567242847, 0.9378601031158192, 0.9364595541714623, 0.9579318785611366, 0.9782921051042497, 0.9468892806188421, 0.07492172564540744, 0.9208436333017085, 0.07512627567987673, 0.881901461581631, 0.6447625422880852, 0.5334278113503312, 0.31096485335748714, 0.6076199487360414, 0.29087810447294016, 0.5609899723146315, 0.40378449091356206, 0.5929103931490507, 0.4494390535200703, 0.9152442018973418, 0.9208348336874397, 0.895502383764492, 0.21390038413120638, 0.9010448101869517, 0.20503541419820492, 0.9070857422977309, 0.9181483150010002, 0.2374094837649835, 0.28483628463372046, 0.1942763825663092, 0.15530238752379677, 0.32551162569322123, 0.27501904352028783, 0.13873832261058128, 0.1861553778892976, 0.1809384891981286, 0.1628835173066847, 0.25075897322039276, 0.1578934659353356, 0.24378942501441636, 0.18127156394061084, 0.22532863964267213, 0.18984939727471195, 0.8157280634614233, 0.20896652278105665, 0.18944669359491506, 0.011766339876430498, 0.3659407987078389, 0.5867219674868478, 0.2744838306242635, 0.4820085499106398, 0.07535582717863765, 0.15080625288920835, 0.371359531869042, 0.10173012142519833, 0.25950430080675524, 0.42103315686090614, 0.3349137037350409, 0.5327712262796938, 0.7125365173423626, 0.13314012605971548, 0.41093280675530097, 0.2595338959026301, 0.25178519168515434, 0.04036586719034019, 0.12806597244421625, 0.06583426739947718, 0.08013148763923494, 0.164882725573527, 0.08485753062235268, 0.16252233036508168, 0.11653268832788743, 0.09473960176713447, 0.33879846632813415, 0.2702089786686782, 0.2280312740244801, 0.3958107223912297, 0.37898775212867086, 0.42159127189284573, 0.17773154637777555, 0.2646632120518865, 0.24009166473331556, 0.8820385579564717, 0.7139813718991883, 0.6458441656494933, 0.5579537883663971, 0.6039457246162985, 0.5403404175066562, 0.8184356411543396, 0.7426436501066471, 0.6333969950609415, 0.12878773724767345, 0.11656059355948978, 0.14440142972072734, 0.11757898547172208, 0.10202896443779952, 0.13287333832581794, 0.09873711478450986, 0.1302643374317467, 0.11216314540426098, 0.19027086333609133, 0.2190801622980605, 0.16261711641951393, 0.17348135112874552, 0.17035576865630264, 0.20121615125896453, 0.14816948739288838, 0.18809531358634168, 0.17342079134052424, 0.4997379198203016, 0.5111791568681378, 0.5496728341045284, 0.5617339084069395, 0.5383550115446576, 0.5409238133581272, 0.6878432131744188, 0.6674102057550495, 0.5661027181153184, 0.33762320106786814, 0.4166180997655994, 0.367164522420384, 0.4571746593985718, 0.4239493922521608, 0.41944842799700033, 0.5271842328387503, 0.5118829307742059, 0.4820154004753242, 0.2204504901247364, 0.1874273007799503, 0.2005700935184842, 0.23730989897418697, 0.21117094989364427, 0.2020416432123805, 0.2159814240481498, 0.19452226833572517, 0.19127096222539208, 0.2152324037775759, 0.21461389095300076, 0.23302437049836322, 0.1902282817890687, 0.20397017574616438, 0.22374436862678626, 0.2091225077275901, 0.6185170506923594, 0.2426380040673034, 0.16958195029797463, 0.9223243676700238, 0.15457581173753276, 0.17667225089872662, 0.18637472379299957, 0.5800069413259559, 0.20690424214780212, 0.8686084052312162, 0.2061784010693426, 0.9152430753816772, 0.21048633363290892, 0.905946383803339, 0.8716644165363503, 0.21050035920927723, 0.21121063714695087, 0.12716119629052824, 0.21059172183278507, 0.1517596698347876, 0.18471577559724983, 0.19136287073598346, 0.18306402836493219, 0.15956246110953143, 0.187023104583672, 0.1905453331242567, 0.2188620669006911, 0.17642852759220728, 0.182164333652575, 0.08396910836574334, 0.08602848048440759, 0.08597368912114522, 0.0806022184964772, 0.08760682263890718, 0.07584179705227345, 0.1009441086902052, 0.08336202773317802, 0.08967826444736515]}, "mutation_prompt": null}
{"id": "e6200264-3db5-4b3d-823c-95d14fa19783", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0) * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                # Increase local search frequency near best solution\n                if np.random.rand() < (1 - self.fitness[i] / self.fitness.min()):\n                    trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Introduce an adaptive increase in local search frequency based on proximity to the global best solution to improve convergence.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "236850eb-0fa2-4517-8fd8-9236fd6252c9", "metadata": {"aucs": [0.8987260391577574, 0.9071434572359618, 0.9097306352549602, 0.9100527847133607, 0.9172994439470689, 0.9165643472766625, 0.9177557005843653, 0.9073450893243553, 0.8980181542478711, 0.817323327393582, 0.8042022840603013, 0.7848269543332402, 0.8153923524658081, 0.8265557584761498, 0.7818089535604563, 0.8156798115323559, 0.8167669353710741, 0.22222209192942888, 0.160429725063447, 0.15846710295237676, 0.1739977528487039, 0.48439104990335324, 0.34064817934125435, 0.1575387691604001, 0.14344342707591928, 0.15489633340077713, 0.1744780882855652, 0.14448999035308585, 0.13668038331482113, 0.12704279898386872, 0.14623534392507642, 0.13938105173688087, 0.1195536358271937, 0.1400838792164315, 0.14545714298442236, 0.11024739567242847, 0.9378601031158192, 0.9364595541714623, 0.9579318785611366, 0.9782921051042497, 0.9468892806188421, 0.07492172564540744, 0.9208436333017085, 0.07512627567987673, 0.881901461581631, 0.6447625422880852, 0.5334278113503312, 0.31096485335748714, 0.6076199487360414, 0.29087810447294016, 0.5609899723146315, 0.40378449091356206, 0.5929103931490507, 0.4494390535200703, 0.9152442018973418, 0.9208348336874397, 0.895502383764492, 0.21390038413120638, 0.9010448101869517, 0.20503541419820492, 0.9070857422977309, 0.9181483150010002, 0.2374094837649835, 0.28483628463372046, 0.1942763825663092, 0.15530238752379677, 0.32551162569322123, 0.27501904352028783, 0.13873832261058128, 0.1861553778892976, 0.1809384891981286, 0.1628835173066847, 0.25075897322039276, 0.1578934659353356, 0.24378942501441636, 0.18127156394061084, 0.22532863964267213, 0.18984939727471195, 0.8157280634614233, 0.20896652278105665, 0.18944669359491506, 0.011766339876430498, 0.3659407987078389, 0.5867219674868478, 0.2744838306242635, 0.4820085499106398, 0.07535582717863765, 0.15080625288920835, 0.371359531869042, 0.10173012142519833, 0.25950430080675524, 0.42103315686090614, 0.3349137037350409, 0.5327712262796938, 0.7125365173423626, 0.13314012605971548, 0.41093280675530097, 0.2595338959026301, 0.25178519168515434, 0.04036586719034019, 0.12806597244421625, 0.06583426739947718, 0.08013148763923494, 0.164882725573527, 0.08485753062235268, 0.16252233036508168, 0.11653268832788743, 0.09473960176713447, 0.33879846632813415, 0.2702089786686782, 0.2280312740244801, 0.3958107223912297, 0.37898775212867086, 0.42159127189284573, 0.17773154637777555, 0.2646632120518865, 0.24009166473331556, 0.8820385579564717, 0.7139813718991883, 0.6458441656494933, 0.5579537883663971, 0.6039457246162985, 0.5403404175066562, 0.8184356411543396, 0.7426436501066471, 0.6333969950609415, 0.12878773724767345, 0.11656059355948978, 0.14440142972072734, 0.11757898547172208, 0.10202896443779952, 0.13287333832581794, 0.09873711478450986, 0.1302643374317467, 0.11216314540426098, 0.19027086333609133, 0.2190801622980605, 0.16261711641951393, 0.17348135112874552, 0.17035576865630264, 0.20121615125896453, 0.14816948739288838, 0.18809531358634168, 0.17342079134052424, 0.4997379198203016, 0.5111791568681378, 0.5496728341045284, 0.5617339084069395, 0.5383550115446576, 0.5409238133581272, 0.6878432131744188, 0.6674102057550495, 0.5661027181153184, 0.33762320106786814, 0.4166180997655994, 0.367164522420384, 0.4571746593985718, 0.4239493922521608, 0.41944842799700033, 0.5271842328387503, 0.5118829307742059, 0.4820154004753242, 0.2204504901247364, 0.1874273007799503, 0.2005700935184842, 0.23730989897418697, 0.21117094989364427, 0.2020416432123805, 0.2159814240481498, 0.19452226833572517, 0.19127096222539208, 0.2152324037775759, 0.21461389095300076, 0.23302437049836322, 0.1902282817890687, 0.20397017574616438, 0.22374436862678626, 0.2091225077275901, 0.6185170506923594, 0.2426380040673034, 0.16958195029797463, 0.9223243676700238, 0.15457581173753276, 0.17667225089872662, 0.18637472379299957, 0.5800069413259559, 0.20690424214780212, 0.8686084052312162, 0.2061784010693426, 0.9152430753816772, 0.21048633363290892, 0.905946383803339, 0.8716644165363503, 0.21050035920927723, 0.21121063714695087, 0.12716119629052824, 0.21059172183278507, 0.1517596698347876, 0.18471577559724983, 0.19136287073598346, 0.18306402836493219, 0.15956246110953143, 0.187023104583672, 0.1905453331242567, 0.2188620669006911, 0.17642852759220728, 0.182164333652575, 0.08396910836574334, 0.08602848048440759, 0.08597368912114522, 0.0806022184964772, 0.08760682263890718, 0.07584179705227345, 0.1009441086902052, 0.08336202773317802, 0.08967826444736515]}, "mutation_prompt": null}
{"id": "e76371ff-832f-4fa0-a8c5-a5b579f91004", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0) * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        improvement_rate = (self.fitness.min() - current_fitness) / self.fitness.min() if self.fitness.min() != 0 else 0\n        perturbation_size = 0.1 * improvement_rate * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                # Increase local search frequency near best solution\n                if np.random.rand() < (1 - self.fitness[i] / self.fitness.min()):\n                    trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Introduce dynamic perturbation size based on fitness improvement rate to enhance exploration.", "configspace": "", "generation": 65, "fitness": 0.37171981611407695, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.28.", "error": "", "parent_id": "236850eb-0fa2-4517-8fd8-9236fd6252c9", "metadata": {"aucs": [0.8987260391577574, 0.9071434572359618, 0.9097306352549602, 0.9100527847133607, 0.9172994439470689, 0.9165643472766625, 0.9000105758963605, 0.9104616534930755, 0.9044547815947502, 0.843754451625458, 0.8085026740715601, 0.7886819336062894, 0.8028129605012859, 0.5861062734049376, 0.7369449998515978, 0.8171718175469199, 0.8129022649503892, 0.8107579424365501, 0.135650349430668, 0.1376460511247003, 0.7063247332684132, 0.48439104990335324, 0.34064817934125435, 0.1575387691604001, 0.14344342707591928, 0.15489633340077713, 0.1744780882855652, 0.13663279644243853, 0.11648856365919347, 0.10551042840002123, 0.14623534392507642, 0.13938105173688087, 0.1195536358271937, 0.1400838792164315, 0.14545714298442236, 0.11024739567242847, 0.9202080120851188, 0.9724241674091664, 0.985889423760451, 0.9782921051042497, 0.9468892806188421, 0.07492172564540744, 0.9208436333017085, 0.07512627567987673, 0.881901461581631, 0.6447625422880852, 0.5334278113503312, 0.31096485335748714, 0.6076199487360414, 0.29087810447294016, 0.5609899723146315, 0.1988530511336548, 0.5062925926291152, 0.21935116405548094, 0.9152442018973418, 0.9208348336874397, 0.895502383764492, 0.21390038413120638, 0.9010448101869517, 0.20503541419820492, 0.9070857422977309, 0.9181483150010002, 0.2374094837649835, 0.28483628463372046, 0.1942763825663092, 0.15530238752379677, 0.16495935442052323, 0.1722182246540257, 0.142032652472741, 0.1861553778892976, 0.1809384891981286, 0.1628835173066847, 0.25075897322039276, 0.1578934659353356, 0.24378942501441636, 0.18127156394061084, 0.22532863964267213, 0.18984939727471195, 0.8157280634614233, 0.20896652278105665, 0.18944669359491506, 0.011766339876430498, 0.29022216051255234, 0.37614054610440395, 0.2744838306242635, 0.4820085499106398, 0.07535582717863765, 0.4311637612211031, 0.19525109228866344, 0.1430549579042386, 0.25950430080675524, 0.42103315686090614, 0.3349137037350409, 0.5576351029082405, 0.28565862074108417, 0.1903366571835351, 0.41093280675530097, 0.2595338959026301, 0.25178519168515434, 0.042557764158428824, 0.11864075214090519, 0.07215923645064337, 0.08483284122514212, 0.18275171997156503, 0.08465926992131989, 0.16252233036508168, 0.11653268832788743, 0.09473960176713447, 0.33879846632813415, 0.2702089786686782, 0.2280312740244801, 0.3276482608075205, 0.518106506004133, 0.3780864455896683, 0.2898389172526251, 0.15904417598213372, 0.28949765577468856, 0.7233342497802784, 0.6536060685306964, 0.6184993136739669, 0.6735334325247617, 0.5500162047244379, 0.5861562875644764, 0.8184356411543396, 0.7426436501066471, 0.6333969950609415, 0.12878773724767345, 0.11656059355948978, 0.14440142972072734, 0.11757898547172208, 0.10202896443779952, 0.13287333832581794, 0.14339442208292152, 0.10199868028065995, 0.11127580250749092, 0.19027086333609133, 0.2190801622980605, 0.16261711641951393, 0.16925879063994076, 0.2564897786479897, 0.16992576387604275, 0.14816948739288838, 0.18809531358634168, 0.17342079134052424, 0.5600048873347261, 0.5678990710893089, 0.49169667068189427, 0.5617339084069395, 0.5383550115446576, 0.5409238133581272, 0.6878432131744188, 0.6674102057550495, 0.5661027181153184, 0.35690964585033, 0.31766001654070253, 0.31235499775347453, 0.4571746593985718, 0.4239493922521608, 0.41944842799700033, 0.5271842328387503, 0.5118829307742059, 0.4820154004753242, 0.2221945486755802, 0.23707047528915803, 0.19916315669237106, 0.23730989897418697, 0.21117094989364427, 0.2020416432123805, 0.2159814240481498, 0.19452226833572517, 0.19127096222539208, 0.23977205113310407, 0.23980546818850168, 0.19158221061644432, 0.1902282817890687, 0.20397017574616438, 0.22374436862678626, 0.2091225077275901, 0.6185170506923594, 0.2426380040673034, 0.16958195029797463, 0.9223243676700238, 0.15457581173753276, 0.17667370697957718, 0.1862971656449618, 0.4924268524519605, 0.8797359079141058, 0.1661590285493516, 0.20800573256763644, 0.9208962375022823, 0.21048633363290892, 0.905839214252297, 0.8716644165363503, 0.21050035920927723, 0.21121063714695087, 0.12735442808631903, 0.21107741317756645, 0.15326431438641142, 0.18471577559724983, 0.19136287073598346, 0.18306402836493219, 0.15956246110953143, 0.187023104583672, 0.1905453331242567, 0.19148444233163053, 0.18167710233617473, 0.19685950175272293, 0.08396910836574334, 0.08602848048440759, 0.08597368912114522, 0.0806022184964772, 0.08760682263890718, 0.07584179705227345, 0.1009441086902052, 0.08336202773317802, 0.08967826444736515]}, "mutation_prompt": null}
{"id": "e3509279-8675-4362-b419-2f123b6f570a", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = np.random.uniform(0.5, 1.0) * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                # Increase local search frequency near best solution\n                if np.random.rand() < (1 - self.fitness[i] / self.fitness.min()):\n                    trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Introduce an adaptive increase in local search frequency based on proximity to the global best solution to improve convergence.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "236850eb-0fa2-4517-8fd8-9236fd6252c9", "metadata": {"aucs": [0.8987260391577574, 0.9071434572359618, 0.9097306352549602, 0.9100527847133607, 0.9172994439470689, 0.9165643472766625, 0.9177557005843653, 0.9073450893243553, 0.8980181542478711, 0.817323327393582, 0.8042022840603013, 0.7848269543332402, 0.8153923524658081, 0.8265557584761498, 0.7818089535604563, 0.8156798115323559, 0.8167669353710741, 0.22222209192942888, 0.160429725063447, 0.15846710295237676, 0.1739977528487039, 0.48439104990335324, 0.34064817934125435, 0.1575387691604001, 0.14344342707591928, 0.15489633340077713, 0.1744780882855652, 0.14448999035308585, 0.13668038331482113, 0.12704279898386872, 0.14623534392507642, 0.13938105173688087, 0.1195536358271937, 0.1400838792164315, 0.14545714298442236, 0.11024739567242847, 0.9378601031158192, 0.9364595541714623, 0.9579318785611366, 0.9782921051042497, 0.9468892806188421, 0.07492172564540744, 0.9208436333017085, 0.07512627567987673, 0.881901461581631, 0.6447625422880852, 0.5334278113503312, 0.31096485335748714, 0.6076199487360414, 0.29087810447294016, 0.5609899723146315, 0.40378449091356206, 0.5929103931490507, 0.4494390535200703, 0.9152442018973418, 0.9208348336874397, 0.895502383764492, 0.21390038413120638, 0.9010448101869517, 0.20503541419820492, 0.9070857422977309, 0.9181483150010002, 0.2374094837649835, 0.28483628463372046, 0.1942763825663092, 0.15530238752379677, 0.32551162569322123, 0.27501904352028783, 0.13873832261058128, 0.1861553778892976, 0.1809384891981286, 0.1628835173066847, 0.25075897322039276, 0.1578934659353356, 0.24378942501441636, 0.18127156394061084, 0.22532863964267213, 0.18984939727471195, 0.8157280634614233, 0.20896652278105665, 0.18944669359491506, 0.011766339876430498, 0.3659407987078389, 0.5867219674868478, 0.2744838306242635, 0.4820085499106398, 0.07535582717863765, 0.15080625288920835, 0.371359531869042, 0.10173012142519833, 0.25950430080675524, 0.42103315686090614, 0.3349137037350409, 0.5327712262796938, 0.7125365173423626, 0.13314012605971548, 0.41093280675530097, 0.2595338959026301, 0.25178519168515434, 0.04036586719034019, 0.12806597244421625, 0.06583426739947718, 0.08013148763923494, 0.164882725573527, 0.08485753062235268, 0.16252233036508168, 0.11653268832788743, 0.09473960176713447, 0.33879846632813415, 0.2702089786686782, 0.2280312740244801, 0.3958107223912297, 0.37898775212867086, 0.42159127189284573, 0.17773154637777555, 0.2646632120518865, 0.24009166473331556, 0.8820385579564717, 0.7139813718991883, 0.6458441656494933, 0.5579537883663971, 0.6039457246162985, 0.5403404175066562, 0.8184356411543396, 0.7426436501066471, 0.6333969950609415, 0.12878773724767345, 0.11656059355948978, 0.14440142972072734, 0.11757898547172208, 0.10202896443779952, 0.13287333832581794, 0.09873711478450986, 0.1302643374317467, 0.11216314540426098, 0.19027086333609133, 0.2190801622980605, 0.16261711641951393, 0.17348135112874552, 0.17035576865630264, 0.20121615125896453, 0.14816948739288838, 0.18809531358634168, 0.17342079134052424, 0.4997379198203016, 0.5111791568681378, 0.5496728341045284, 0.5617339084069395, 0.5383550115446576, 0.5409238133581272, 0.6878432131744188, 0.6674102057550495, 0.5661027181153184, 0.33762320106786814, 0.4166180997655994, 0.367164522420384, 0.4571746593985718, 0.4239493922521608, 0.41944842799700033, 0.5271842328387503, 0.5118829307742059, 0.4820154004753242, 0.2204504901247364, 0.1874273007799503, 0.2005700935184842, 0.23730989897418697, 0.21117094989364427, 0.2020416432123805, 0.2159814240481498, 0.19452226833572517, 0.19127096222539208, 0.2152324037775759, 0.21461389095300076, 0.23302437049836322, 0.1902282817890687, 0.20397017574616438, 0.22374436862678626, 0.2091225077275901, 0.6185170506923594, 0.2426380040673034, 0.16958195029797463, 0.9223243676700238, 0.15457581173753276, 0.17667225089872662, 0.18637472379299957, 0.5800069413259559, 0.20690424214780212, 0.8686084052312162, 0.2061784010693426, 0.9152430753816772, 0.21048633363290892, 0.905946383803339, 0.8716644165363503, 0.21050035920927723, 0.21121063714695087, 0.12716119629052824, 0.21059172183278507, 0.1517596698347876, 0.18471577559724983, 0.19136287073598346, 0.18306402836493219, 0.15956246110953143, 0.187023104583672, 0.1905453331242567, 0.2188620669006911, 0.17642852759220728, 0.182164333652575, 0.08396910836574334, 0.08602848048440759, 0.08597368912114522, 0.0806022184964772, 0.08760682263890718, 0.07584179705227345, 0.1009441086902052, 0.08336202773317802, 0.08967826444736515]}, "mutation_prompt": null}
{"id": "a85ab43e-3e4e-40d0-8d72-95aa28fad598", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = 0.7 + 0.3 * np.random.rand() * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                # Increase local search frequency near best solution\n                if np.random.rand() < (1 - self.fitness[i] / self.fitness.min()):\n                    trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Introduce an adaptive control mechanism for the mutation factor to enhance exploration while maintaining convergence stability in the optimization process.", "configspace": "", "generation": 67, "fitness": 0.4644775293129944, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.28.", "error": "", "parent_id": "236850eb-0fa2-4517-8fd8-9236fd6252c9", "metadata": {"aucs": [0.8635679096504482, 0.8651904840699595, 0.8706656124464578, 0.8810134389315147, 0.8685718654200112, 0.8856447563191137, 0.8670100666879484, 0.8749560852358703, 0.8775438954388255, 0.7404208325202579, 0.7384994052373408, 0.7261127410990609, 0.7272742525314373, 0.7471737697063785, 0.7631206891894722, 0.7516069185437104, 0.7439412279336488, 0.7389483781818461, 0.14187198723623984, 0.14430037860058242, 0.5068317157702751, 0.6141208230766544, 0.5926557280439354, 0.17717242840235026, 0.48246124113651934, 0.15915506627740783, 0.48402756353441956, 0.1390418208853602, 0.13117637109521962, 0.148000140067155, 0.1539150518159822, 0.15948608292752742, 0.1561365275238189, 0.12195309062208304, 0.14776975668919712, 0.14660357755904152, 0.9286016989000958, 0.901301764793804, 0.9587363612150387, 0.9529502408428152, 0.9546236887962392, 0.9627372031533812, 0.8641095226866682, 0.8993408801477827, 0.9386599586607532, 0.7173611945447436, 0.6968346240610815, 0.6981789833798285, 0.7097262539295792, 0.7280636814887845, 0.7203972964247863, 0.7101582894679983, 0.6937310355627413, 0.7122138352874839, 0.8578762062038061, 0.8836313302564254, 0.8699748825079259, 0.8809898710796447, 0.8727004376322524, 0.8989927174263601, 0.8787271372953744, 0.7951697730295809, 0.8621600934569479, 0.12861512018828958, 0.6611720265992113, 0.5800596250663388, 0.31856510080017264, 0.5761412784699418, 0.4289200835983523, 0.7000093107114131, 0.710976705107656, 0.6620400567496458, 0.6823035883090878, 0.6696361829113344, 0.6261798768441218, 0.5844216609310808, 0.6381144679130523, 0.42161185600649365, 0.6758313923014843, 0.1262323780913417, 0.5098010512578499, 0.5559531768340462, 0.3997514818161074, 0.24857031001642804, 0.6029110103067217, 0.28694574622930735, 0.4152592389400309, 0.4616082544116279, 0.3344140780297181, 0.4133354702868083, 0.661122795775277, 0.5483002350605397, 0.6293056775802961, 0.46247010624975693, 0.45144429776319206, 0.38598580789580883, 0.7646005010276716, 0.7029255531350846, 0.7179893530147177, 0.17462777689593334, 0.12453942600507584, 0.12348118148056908, 0.26056197145905624, 0.1759389546519804, 0.2278391177782041, 0.19790128381342587, 0.24887179477912602, 0.29525490925803566, 0.359025352572241, 0.3936311269217716, 0.3654223749196335, 0.3743718285658255, 0.35611243435164974, 0.34543803899807113, 0.40547228307625105, 0.34199174817140954, 0.3499321991835511, 0.7736705813162172, 0.72864482630593, 0.7940239494941197, 0.7122081090083364, 0.7596926111517235, 0.6608693214103916, 0.6925019769340037, 0.7388022611470371, 0.6868041915551863, 0.13247506286945132, 0.1244319687874138, 0.10302623549869239, 0.10223168645004022, 0.09842825088064278, 0.09972399049977776, 0.10175425982978481, 0.10846204959263539, 0.1264660882701759, 0.17043121414511575, 0.14067064232233606, 0.1727208310728483, 0.48777162134548846, 0.5838534099188235, 0.16099873614551963, 0.3344869463872888, 0.16047322868341285, 0.2652780291712937, 0.4636590074545376, 0.6417322471408001, 0.5127237337979609, 0.5127110128720004, 0.6098202428335417, 0.6575378119560286, 0.6331396625786849, 0.5453262382759511, 0.634106206486766, 0.3567992909885823, 0.3274626715357434, 0.3890832683767902, 0.4273860392087654, 0.41386243728154837, 0.4582653409979063, 0.26308425642842903, 0.40123365999851623, 0.44758314524427656, 0.18857976268689391, 0.25939554897586203, 0.1885566469133565, 0.2253993535990807, 0.2119916895974352, 0.1985762199015786, 0.18323681702479733, 0.18581247082260932, 0.18300515909694837, 0.2247140223530173, 0.21302124540092227, 0.22278086806946762, 0.6126493486657143, 0.6045243538687136, 0.6964947698121675, 0.210426364113661, 0.6301172500758386, 0.6993563085908812, 0.17179353502163397, 0.1477603756649416, 0.18668235938951727, 0.1850387005762163, 0.17664466913025278, 0.8983830547091507, 0.8444535889884224, 0.1645357621718102, 0.8672375608870939, 0.8759684773718894, 0.1680924457491304, 0.8609968278250881, 0.16423240593239863, 0.16282230354353555, 0.20688933676184718, 0.126848024158292, 0.8580242070227013, 0.7685276786996931, 0.19288556739724072, 0.1738455562573865, 0.20011565717648094, 0.15668931603210567, 0.16934378164028507, 0.16583971353965465, 0.1541713266825524, 0.1636793664730014, 0.18608663767603206, 0.0870581787387158, 0.07420570431373563, 0.07841584358511355, 0.08658021317402886, 0.0764258368848807, 0.07873052909461553, 0.08067708880578117, 0.07801874472758552, 0.08456010083370835]}, "mutation_prompt": null}
{"id": "9777af56-07eb-41e8-a6b5-b73094fa5e8b", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = 0.7 + 0.3 * np.random.rand() * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        # Modified perturbation size for adaptive scaling\n        perturbation_size = 0.05 + 0.05 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                # Increase local search frequency near best solution\n                if np.random.rand() < (1 - self.fitness[i] / self.fitness.min()):\n                    trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Introduce adaptive scaling for local search step size to enhance exploitation near convergence.", "configspace": "", "generation": 68, "fitness": 0.4686887643758104, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.28.", "error": "", "parent_id": "a85ab43e-3e4e-40d0-8d72-95aa28fad598", "metadata": {"aucs": [0.8635679096504482, 0.8651904840699595, 0.8706656124464578, 0.8810134389315147, 0.8685718654200112, 0.8856447563191137, 0.8684146222163904, 0.8756551246832438, 0.8679631748178588, 0.7532667375927997, 0.7443007533536237, 0.7569169131023736, 0.7347243411524695, 0.7679153024656786, 0.7545183773600026, 0.7368902332759621, 0.7166759231323901, 0.7738634979294521, 0.15221440172801903, 0.5504231285938777, 0.54815205534065, 0.6141208230766544, 0.5926557280439354, 0.17717242840235026, 0.48246124113651934, 0.15915506627740783, 0.48402756353441956, 0.13292692014921215, 0.1619629465969551, 0.11272842499955038, 0.1539150518159822, 0.15948608292752742, 0.1561365275238189, 0.12195309062208304, 0.14776975668919712, 0.14660357755904152, 0.8884242633665269, 0.8998429290768728, 0.9442128792419914, 0.9529502408428152, 0.9546236887962392, 0.9627372031533812, 0.8641095226866682, 0.8993408801477827, 0.9386599586607532, 0.7173611945447436, 0.6968346240610815, 0.6981789833798285, 0.7097262539295792, 0.7280636814887845, 0.7203972964247863, 0.6888976754292169, 0.6992924393249529, 0.6938502093579653, 0.8578762062038061, 0.8836313302564254, 0.8699748825079259, 0.8809898710796447, 0.8727004376322524, 0.8989927174263601, 0.8787271372953744, 0.7951697730295809, 0.8621600934569479, 0.12861512018828958, 0.6611720265992113, 0.5800596250663388, 0.2685811802835609, 0.5777109707231156, 0.5186167277814931, 0.7000093107114131, 0.710976705107656, 0.6620400567496458, 0.6823035883090878, 0.6696361829113344, 0.6261798768441218, 0.5844216609310808, 0.6381144679130523, 0.42161185600649365, 0.6758313923014843, 0.1262323780913417, 0.5098010512578499, 0.4286920310498181, 0.48805118670775693, 0.425576654322369, 0.6029110103067217, 0.28694574622930735, 0.4152592389400309, 0.4069474665076702, 0.4120514530218341, 0.44419535760603435, 0.661122795775277, 0.5483002350605397, 0.6293056775802961, 0.42887125693541184, 0.6395293719486403, 0.45687673986909205, 0.7646005010276716, 0.7029255531350846, 0.7179893530147177, 0.18029074111849164, 0.2957308371326355, 0.17083567439940073, 0.19435699059037959, 0.29459502055381603, 0.15378019700896617, 0.19790128381342587, 0.24887179477912602, 0.29525490925803566, 0.359025352572241, 0.3936311269217716, 0.3654223749196335, 0.35023462902662394, 0.3754514497426875, 0.4129025874544041, 0.35869869452121217, 0.31308989279862176, 0.4526392597533164, 0.7105134948269605, 0.7164644305089387, 0.8116356047267818, 0.7248755944144798, 0.5745644185179984, 0.8276347867001287, 0.6925019769340037, 0.7388022611470371, 0.6868041915551863, 0.13247506286945132, 0.1244319687874138, 0.10302623549869239, 0.10223168645004022, 0.09842825088064278, 0.09972399049977776, 0.11428249942573221, 0.08599751120685373, 0.08017712742104066, 0.17043121414511575, 0.14067064232233606, 0.1727208310728483, 0.1868523317286226, 0.7610379728109469, 0.1723421938595613, 0.3344869463872888, 0.16047322868341285, 0.2652780291712937, 0.47709191428407316, 0.551139202495502, 0.5776666666407821, 0.5127110128720004, 0.6098202428335417, 0.6575378119560286, 0.6331396625786849, 0.5453262382759511, 0.634106206486766, 0.3973397305655164, 0.33327653221655396, 0.32931149704114837, 0.4273860392087654, 0.41386243728154837, 0.4582653409979063, 0.26308425642842903, 0.40123365999851623, 0.44758314524427656, 0.19034086330786226, 0.2310733816666416, 0.18203372336269275, 0.2253993535990807, 0.2119916895974352, 0.1985762199015786, 0.18323681702479733, 0.18581247082260932, 0.18300515909694837, 0.5488774185432892, 0.18031549284431037, 0.5349302586087175, 0.6126493486657143, 0.6045243538687136, 0.6964947698121675, 0.210426364113661, 0.6301172500758386, 0.6993563085908812, 0.17179353502163397, 0.1477603756649416, 0.18668235938951727, 0.18507530007033468, 0.17664466913025278, 0.8525011351688441, 0.8446174742006775, 0.16443284941386305, 0.8850378671919152, 0.8759684773718894, 0.16809239305294776, 0.8787423422616358, 0.16423240593239863, 0.16282230354353555, 0.20688933676184718, 0.20911423561462528, 0.8352912094291937, 0.12433852578530424, 0.19288556739724072, 0.1738455562573865, 0.20011565717648094, 0.15668931603210567, 0.16934378164028507, 0.16583971353965465, 0.1541713266825524, 0.2275184983065729, 0.15161845059884194, 0.0870581787387158, 0.07420570431373563, 0.07841584358511355, 0.08658021317402886, 0.0764258368848807, 0.07873052909461553, 0.08067708880578117, 0.07801874472758552, 0.08456010083370835]}, "mutation_prompt": null}
{"id": "dc61b7ae-bae2-49cd-bc46-0ed136686231", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = 0.7 + 0.3 * np.random.rand() * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        # Modified perturbation size for adaptive scaling\n        perturbation_size = 0.05 + 0.05 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                # Increase local search frequency near best solution\n                if np.random.rand() < (1 - self.fitness[i] / self.fitness.min()):\n                    trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Introduce adaptive scaling for local search step size to enhance exploitation near convergence.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9777af56-07eb-41e8-a6b5-b73094fa5e8b", "metadata": {"aucs": [0.8635679096504482, 0.8651904840699595, 0.8706656124464578, 0.8810134389315147, 0.8685718654200112, 0.8856447563191137, 0.8684146222163904, 0.8756551246832438, 0.8679631748178588, 0.7532667375927997, 0.7443007533536237, 0.7569169131023736, 0.7347243411524695, 0.7679153024656786, 0.7545183773600026, 0.7368902332759621, 0.7166759231323901, 0.7738634979294521, 0.15221440172801903, 0.5504231285938777, 0.54815205534065, 0.6141208230766544, 0.5926557280439354, 0.17717242840235026, 0.48246124113651934, 0.15915506627740783, 0.48402756353441956, 0.13292692014921215, 0.1619629465969551, 0.11272842499955038, 0.1539150518159822, 0.15948608292752742, 0.1561365275238189, 0.12195309062208304, 0.14776975668919712, 0.14660357755904152, 0.8884242633665269, 0.8998429290768728, 0.9442128792419914, 0.9529502408428152, 0.9546236887962392, 0.9627372031533812, 0.8641095226866682, 0.8993408801477827, 0.9386599586607532, 0.7173611945447436, 0.6968346240610815, 0.6981789833798285, 0.7097262539295792, 0.7280636814887845, 0.7203972964247863, 0.6888976754292169, 0.6992924393249529, 0.6938502093579653, 0.8578762062038061, 0.8836313302564254, 0.8699748825079259, 0.8809898710796447, 0.8727004376322524, 0.8989927174263601, 0.8787271372953744, 0.7951697730295809, 0.8621600934569479, 0.12861512018828958, 0.6611720265992113, 0.5800596250663388, 0.2685811802835609, 0.5777109707231156, 0.5186167277814931, 0.7000093107114131, 0.710976705107656, 0.6620400567496458, 0.6823035883090878, 0.6696361829113344, 0.6261798768441218, 0.5844216609310808, 0.6381144679130523, 0.42161185600649365, 0.6758313923014843, 0.1262323780913417, 0.5098010512578499, 0.4286920310498181, 0.48805118670775693, 0.425576654322369, 0.6029110103067217, 0.28694574622930735, 0.4152592389400309, 0.4069474665076702, 0.4120514530218341, 0.44419535760603435, 0.661122795775277, 0.5483002350605397, 0.6293056775802961, 0.42887125693541184, 0.6395293719486403, 0.45687673986909205, 0.7646005010276716, 0.7029255531350846, 0.7179893530147177, 0.18029074111849164, 0.2957308371326355, 0.17083567439940073, 0.19435699059037959, 0.29459502055381603, 0.15378019700896617, 0.19790128381342587, 0.24887179477912602, 0.29525490925803566, 0.359025352572241, 0.3936311269217716, 0.3654223749196335, 0.35023462902662394, 0.3754514497426875, 0.4129025874544041, 0.35869869452121217, 0.31308989279862176, 0.4526392597533164, 0.7105134948269605, 0.7164644305089387, 0.8116356047267818, 0.7248755944144798, 0.5745644185179984, 0.8276347867001287, 0.6925019769340037, 0.7388022611470371, 0.6868041915551863, 0.13247506286945132, 0.1244319687874138, 0.10302623549869239, 0.10223168645004022, 0.09842825088064278, 0.09972399049977776, 0.11428249942573221, 0.08599751120685373, 0.08017712742104066, 0.17043121414511575, 0.14067064232233606, 0.1727208310728483, 0.1868523317286226, 0.7610379728109469, 0.1723421938595613, 0.3344869463872888, 0.16047322868341285, 0.2652780291712937, 0.47709191428407316, 0.551139202495502, 0.5776666666407821, 0.5127110128720004, 0.6098202428335417, 0.6575378119560286, 0.6331396625786849, 0.5453262382759511, 0.634106206486766, 0.3973397305655164, 0.33327653221655396, 0.32931149704114837, 0.4273860392087654, 0.41386243728154837, 0.4582653409979063, 0.26308425642842903, 0.40123365999851623, 0.44758314524427656, 0.19034086330786226, 0.2310733816666416, 0.18203372336269275, 0.2253993535990807, 0.2119916895974352, 0.1985762199015786, 0.18323681702479733, 0.18581247082260932, 0.18300515909694837, 0.5488774185432892, 0.18031549284431037, 0.5349302586087175, 0.6126493486657143, 0.6045243538687136, 0.6964947698121675, 0.210426364113661, 0.6301172500758386, 0.6993563085908812, 0.17179353502163397, 0.1477603756649416, 0.18668235938951727, 0.18507530007033468, 0.17664466913025278, 0.8525011351688441, 0.8446174742006775, 0.16443284941386305, 0.8850378671919152, 0.8759684773718894, 0.16809239305294776, 0.8787423422616358, 0.16423240593239863, 0.16282230354353555, 0.20688933676184718, 0.20911423561462528, 0.8352912094291937, 0.12433852578530424, 0.19288556739724072, 0.1738455562573865, 0.20011565717648094, 0.15668931603210567, 0.16934378164028507, 0.16583971353965465, 0.1541713266825524, 0.2275184983065729, 0.15161845059884194, 0.0870581787387158, 0.07420570431373563, 0.07841584358511355, 0.08658021317402886, 0.0764258368848807, 0.07873052909461553, 0.08067708880578117, 0.07801874472758552, 0.08456010083370835]}, "mutation_prompt": null}
{"id": "b736b320-d9e7-4880-8ded-aeddf66cbbb4", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = 0.7 + 0.3 * np.random.rand() * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        # Modified perturbation size for adaptive scaling\n        perturbation_size = 0.05 + 0.05 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                # Increase local search frequency near best solution\n                if np.random.rand() < (1 - self.fitness[i] / self.fitness.min()):\n                    trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Introduce adaptive scaling for local search step size to enhance exploitation near convergence.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9777af56-07eb-41e8-a6b5-b73094fa5e8b", "metadata": {"aucs": [0.8635679096504482, 0.8651904840699595, 0.8706656124464578, 0.8810134389315147, 0.8685718654200112, 0.8856447563191137, 0.8684146222163904, 0.8756551246832438, 0.8679631748178588, 0.7532667375927997, 0.7443007533536237, 0.7569169131023736, 0.7347243411524695, 0.7679153024656786, 0.7545183773600026, 0.7368902332759621, 0.7166759231323901, 0.7738634979294521, 0.15221440172801903, 0.5504231285938777, 0.54815205534065, 0.6141208230766544, 0.5926557280439354, 0.17717242840235026, 0.48246124113651934, 0.15915506627740783, 0.48402756353441956, 0.13292692014921215, 0.1619629465969551, 0.11272842499955038, 0.1539150518159822, 0.15948608292752742, 0.1561365275238189, 0.12195309062208304, 0.14776975668919712, 0.14660357755904152, 0.8884242633665269, 0.8998429290768728, 0.9442128792419914, 0.9529502408428152, 0.9546236887962392, 0.9627372031533812, 0.8641095226866682, 0.8993408801477827, 0.9386599586607532, 0.7173611945447436, 0.6968346240610815, 0.6981789833798285, 0.7097262539295792, 0.7280636814887845, 0.7203972964247863, 0.6888976754292169, 0.6992924393249529, 0.6938502093579653, 0.8578762062038061, 0.8836313302564254, 0.8699748825079259, 0.8809898710796447, 0.8727004376322524, 0.8989927174263601, 0.8787271372953744, 0.7951697730295809, 0.8621600934569479, 0.12861512018828958, 0.6611720265992113, 0.5800596250663388, 0.2685811802835609, 0.5777109707231156, 0.5186167277814931, 0.7000093107114131, 0.710976705107656, 0.6620400567496458, 0.6823035883090878, 0.6696361829113344, 0.6261798768441218, 0.5844216609310808, 0.6381144679130523, 0.42161185600649365, 0.6758313923014843, 0.1262323780913417, 0.5098010512578499, 0.4286920310498181, 0.48805118670775693, 0.425576654322369, 0.6029110103067217, 0.28694574622930735, 0.4152592389400309, 0.4069474665076702, 0.4120514530218341, 0.44419535760603435, 0.661122795775277, 0.5483002350605397, 0.6293056775802961, 0.42887125693541184, 0.6395293719486403, 0.45687673986909205, 0.7646005010276716, 0.7029255531350846, 0.7179893530147177, 0.18029074111849164, 0.2957308371326355, 0.17083567439940073, 0.19435699059037959, 0.29459502055381603, 0.15378019700896617, 0.19790128381342587, 0.24887179477912602, 0.29525490925803566, 0.359025352572241, 0.3936311269217716, 0.3654223749196335, 0.35023462902662394, 0.3754514497426875, 0.4129025874544041, 0.35869869452121217, 0.31308989279862176, 0.4526392597533164, 0.7105134948269605, 0.7164644305089387, 0.8116356047267818, 0.7248755944144798, 0.5745644185179984, 0.8276347867001287, 0.6925019769340037, 0.7388022611470371, 0.6868041915551863, 0.13247506286945132, 0.1244319687874138, 0.10302623549869239, 0.10223168645004022, 0.09842825088064278, 0.09972399049977776, 0.11428249942573221, 0.08599751120685373, 0.08017712742104066, 0.17043121414511575, 0.14067064232233606, 0.1727208310728483, 0.1868523317286226, 0.7610379728109469, 0.1723421938595613, 0.3344869463872888, 0.16047322868341285, 0.2652780291712937, 0.47709191428407316, 0.551139202495502, 0.5776666666407821, 0.5127110128720004, 0.6098202428335417, 0.6575378119560286, 0.6331396625786849, 0.5453262382759511, 0.634106206486766, 0.3973397305655164, 0.33327653221655396, 0.32931149704114837, 0.4273860392087654, 0.41386243728154837, 0.4582653409979063, 0.26308425642842903, 0.40123365999851623, 0.44758314524427656, 0.19034086330786226, 0.2310733816666416, 0.18203372336269275, 0.2253993535990807, 0.2119916895974352, 0.1985762199015786, 0.18323681702479733, 0.18581247082260932, 0.18300515909694837, 0.5488774185432892, 0.18031549284431037, 0.5349302586087175, 0.6126493486657143, 0.6045243538687136, 0.6964947698121675, 0.210426364113661, 0.6301172500758386, 0.6993563085908812, 0.17179353502163397, 0.1477603756649416, 0.18668235938951727, 0.18507530007033468, 0.17664466913025278, 0.8525011351688441, 0.8446174742006775, 0.16443284941386305, 0.8850378671919152, 0.8759684773718894, 0.16809239305294776, 0.8787423422616358, 0.16423240593239863, 0.16282230354353555, 0.20688933676184718, 0.20911423561462528, 0.8352912094291937, 0.12433852578530424, 0.19288556739724072, 0.1738455562573865, 0.20011565717648094, 0.15668931603210567, 0.16934378164028507, 0.16583971353965465, 0.1541713266825524, 0.2275184983065729, 0.15161845059884194, 0.0870581787387158, 0.07420570431373563, 0.07841584358511355, 0.08658021317402886, 0.0764258368848807, 0.07873052909461553, 0.08067708880578117, 0.07801874472758552, 0.08456010083370835]}, "mutation_prompt": null}
{"id": "ae923438-b2bc-4d97-b5a0-ee056518f886", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = 0.7 + 0.3 * np.random.rand() * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        # Modified perturbation size for adaptive scaling\n        perturbation_size = 0.1 + 0.1 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                # Increase local search frequency near best solution\n                if np.random.rand() < (1 - self.fitness[i] / self.fitness.min()):\n                    trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Improve the perturbation size scaling in the local search method to increase exploration in early iterations.", "configspace": "", "generation": 71, "fitness": 0.46033190139187896, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.28.", "error": "", "parent_id": "9777af56-07eb-41e8-a6b5-b73094fa5e8b", "metadata": {"aucs": [0.8635679096504482, 0.8651904840699595, 0.8706656124464578, 0.8810134389315147, 0.8685718654200112, 0.8856447563191137, 0.8587298323991346, 0.8518188615833593, 0.8576567633085901, 0.7482672074664012, 0.751316817160073, 0.712177497764812, 0.7456390118001991, 0.7253361142481534, 0.7350394383740259, 0.7502364961340735, 0.7221112075476053, 0.7363983753792072, 0.1430120230518025, 0.6613392345684491, 0.1582823274323849, 0.6141208230766544, 0.5926557280439354, 0.17717242840235026, 0.48246124113651934, 0.15915506627740783, 0.48402756353441956, 0.14454849323460717, 0.1340332738528417, 0.1329371141472675, 0.1539150518159822, 0.15948608292752742, 0.1561365275238189, 0.12195309062208304, 0.14776975668919712, 0.14660357755904152, 0.9304377122938904, 0.9240798149614475, 0.9543668862222232, 0.9529502408428152, 0.9546236887962392, 0.9627372031533812, 0.8641095226866682, 0.8993408801477827, 0.9386599586607532, 0.7173611945447436, 0.6968346240610815, 0.6981789833798285, 0.7097262539295792, 0.7280636814887845, 0.7203972964247863, 0.6384591806997149, 0.7133579088252171, 0.6826521573035798, 0.8578762062038061, 0.8836313302564254, 0.8699748825079259, 0.8809898710796447, 0.8727004376322524, 0.8989927174263601, 0.8787271372953744, 0.7951697730295809, 0.8621600934569479, 0.12861512018828958, 0.6611720265992113, 0.5800596250663388, 0.4919478622626058, 0.6277490412140514, 0.5006478493367472, 0.7000093107114131, 0.710976705107656, 0.6620400567496458, 0.6823035883090878, 0.6696361829113344, 0.6261798768441218, 0.5844216609310808, 0.6381144679130523, 0.42161185600649365, 0.6758313923014843, 0.1262323780913417, 0.5098010512578499, 0.31059253148915045, 0.37443880516330585, 0.35169065600372695, 0.6029110103067217, 0.28694574622930735, 0.4152592389400309, 0.28602893210175717, 0.4152126079095002, 0.5084556707529108, 0.661122795775277, 0.5483002350605397, 0.6293056775802961, 0.5298835962219257, 0.5588979801113343, 0.4751364957237252, 0.7646005010276716, 0.7029255531350846, 0.7179893530147177, 0.21211853859171426, 0.12537446559080423, 0.14479048404408645, 0.38974973374135347, 0.14371070616819792, 0.1968579810617963, 0.19790128381342587, 0.24887179477912602, 0.29525490925803566, 0.359025352572241, 0.3936311269217716, 0.3654223749196335, 0.4099133858950632, 0.3751276984090458, 0.4155218404937614, 0.32501522222226775, 0.37709162902698623, 0.2944227470134335, 0.7756988186160051, 0.7423385619277039, 0.7355524057548747, 0.7268098572798989, 0.7419681435843878, 0.6830880070200351, 0.6925019769340037, 0.7388022611470371, 0.6868041915551863, 0.13247506286945132, 0.1244319687874138, 0.10302623549869239, 0.10223168645004022, 0.09842825088064278, 0.09972399049977776, 0.09976203218523283, 0.09899668798559247, 0.10968539906218355, 0.17043121414511575, 0.14067064232233606, 0.1727208310728483, 0.17637865383532314, 0.2491377416273316, 0.17023122038003713, 0.3344869463872888, 0.16047322868341285, 0.2652780291712937, 0.5019243034984313, 0.5158027735416614, 0.513026043616762, 0.5127110128720004, 0.6098202428335417, 0.6575378119560286, 0.6331396625786849, 0.5453262382759511, 0.634106206486766, 0.35237126184219436, 0.32319256192531676, 0.29567184808621894, 0.4273860392087654, 0.41386243728154837, 0.4582653409979063, 0.26308425642842903, 0.40123365999851623, 0.44758314524427656, 0.19768873361992523, 0.19154145337000716, 0.20726598734903412, 0.2253993535990807, 0.2119916895974352, 0.1985762199015786, 0.18323681702479733, 0.18581247082260932, 0.18300515909694837, 0.5020704646079213, 0.7076018164905058, 0.2388124002983305, 0.6126493486657143, 0.6045243538687136, 0.6964947698121675, 0.210426364113661, 0.6301172500758386, 0.6993563085908812, 0.17179353502163397, 0.1477603756649416, 0.18668235938951727, 0.18513541650932774, 0.17664466913025278, 0.8716766587578291, 0.8538304049262033, 0.844220038411083, 0.19333781903464575, 0.8759684773718894, 0.20841004077166259, 0.8807102207643551, 0.16423240593239863, 0.16282230354353555, 0.20688933676184718, 0.125962530830679, 0.1263381259591062, 0.1260559634323547, 0.19288556739724072, 0.1738455562573865, 0.20011565717648094, 0.15668931603210567, 0.16934378164028507, 0.16583971353965465, 0.176540363906601, 0.16972483047622244, 0.17641369452536915, 0.0870581787387158, 0.07420570431373563, 0.07841584358511355, 0.08658021317402886, 0.0764258368848807, 0.07873052909461553, 0.08067708880578117, 0.07801874472758552, 0.08456010083370835]}, "mutation_prompt": null}
{"id": "a9785f79-7558-48d8-9d80-84434496839a", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = 0.7 + 0.3 * np.random.rand() * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        # Modified perturbation size with population diversity scaling\n        diversity_scale = np.std(self.population, axis=0).mean()\n        perturbation_size = 0.05 + 0.05 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min()) * diversity_scale\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                # Increase local search frequency near best solution\n                if np.random.rand() < (1 - self.fitness[i] / self.fitness.min()):\n                    trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Enhance local search convergence by dynamically adjusting perturbation size based on population diversity.", "configspace": "", "generation": 72, "fitness": 0.4568772421371554, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.28.", "error": "", "parent_id": "9777af56-07eb-41e8-a6b5-b73094fa5e8b", "metadata": {"aucs": [0.8635679096504482, 0.8651904840699595, 0.8706656124464578, 0.8810134389315147, 0.8685718654200112, 0.8856447563191137, 0.8675256780367955, 0.8815331272396004, 0.8588435890907125, 0.7518130711184849, 0.7465445805088147, 0.7197979217266977, 0.7482216223936864, 0.7432068827684385, 0.7655592728894698, 0.740870932750362, 0.7488238628874531, 0.7551252379723595, 0.14380707877467014, 0.16247165768521177, 0.4691706452454164, 0.6141208230766544, 0.5926557280439354, 0.17717242840235026, 0.48246124113651934, 0.15915506627740783, 0.48402756353441956, 0.14225262712700004, 0.12464367712672886, 0.14887764101793965, 0.1539150518159822, 0.15948608292752742, 0.1561365275238189, 0.12195309062208304, 0.14776975668919712, 0.14660357755904152, 0.8799678568105951, 0.8922078852840114, 0.9821381183047844, 0.9529502408428152, 0.9546236887962392, 0.9627372031533812, 0.8641095226866682, 0.8993408801477827, 0.9386599586607532, 0.7173611945447436, 0.6968346240610815, 0.6981789833798285, 0.7097262539295792, 0.7280636814887845, 0.7203972964247863, 0.6830273441033852, 0.7268879602909644, 0.6802568556640467, 0.8578762062038061, 0.8836313302564254, 0.8699748825079259, 0.8809898710796447, 0.8727004376322524, 0.8989927174263601, 0.8787271372953744, 0.7951697730295809, 0.8621600934569479, 0.12861512018828958, 0.6611720265992113, 0.5800596250663388, 0.12236391711481065, 0.6421313236872956, 0.22261883056728582, 0.7000093107114131, 0.710976705107656, 0.6620400567496458, 0.6823035883090878, 0.6696361829113344, 0.6261798768441218, 0.5844216609310808, 0.6381144679130523, 0.42161185600649365, 0.6758313923014843, 0.1262323780913417, 0.5098010512578499, 0.4381347971539963, 0.25756985135171107, 0.2741414761915235, 0.6029110103067217, 0.28694574622930735, 0.4152592389400309, 0.16791175382007495, 0.4823759783299887, 0.48188881922048, 0.661122795775277, 0.5483002350605397, 0.6293056775802961, 0.5464291067489557, 0.4471543181220293, 0.4571026559625023, 0.7646005010276716, 0.7029255531350846, 0.7179893530147177, 0.14955466810707585, 0.2037612475312759, 0.15956793192074548, 0.52895328732564, 0.3457124126103843, 0.2574689917042209, 0.19790128381342587, 0.24887179477912602, 0.29525490925803566, 0.359025352572241, 0.3936311269217716, 0.3654223749196335, 0.4166580122157758, 0.3154104134624789, 0.3309831314095385, 0.28768666942051324, 0.3570445838120466, 0.36956150725257386, 0.8183525203523722, 0.7594141468067045, 0.7636870704241834, 0.7499083556881976, 0.7931801426056608, 0.6426617405195432, 0.6925019769340037, 0.7388022611470371, 0.6868041915551863, 0.13247506286945132, 0.1244319687874138, 0.10302623549869239, 0.10223168645004022, 0.09842825088064278, 0.09972399049977776, 0.08387213175948471, 0.08389021449959944, 0.0891812068976946, 0.17043121414511575, 0.14067064232233606, 0.1727208310728483, 0.196335186132102, 0.2872615791895625, 0.2826564728329408, 0.3344869463872888, 0.16047322868341285, 0.2652780291712937, 0.5040895195633279, 0.55039870746818, 0.4484217802321848, 0.5127110128720004, 0.6098202428335417, 0.6575378119560286, 0.6331396625786849, 0.5453262382759511, 0.634106206486766, 0.31266421510752873, 0.31340684614932035, 0.334224627926791, 0.4273860392087654, 0.41386243728154837, 0.4582653409979063, 0.26308425642842903, 0.40123365999851623, 0.44758314524427656, 0.18218206093418, 0.2310733816666416, 0.2113701564775664, 0.2253993535990807, 0.2119916895974352, 0.1985762199015786, 0.18323681702479733, 0.18581247082260932, 0.18300515909694837, 0.6183440212667495, 0.21153578592010613, 0.22920382684085283, 0.6126493486657143, 0.6045243538687136, 0.6964947698121675, 0.210426364113661, 0.6301172500758386, 0.6993563085908812, 0.17179353502163397, 0.1477603756649416, 0.18668235938951727, 0.18501660061500702, 0.17664466913025278, 0.8682176873051408, 0.830633465471672, 0.8346613295465227, 0.1923576976203043, 0.8759684773718894, 0.2089166191517975, 0.8778118234655686, 0.16423240593239863, 0.16282230354353555, 0.20688933676184718, 0.12674282887748045, 0.12621949594279502, 0.20448533133215874, 0.19288556739724072, 0.1738455562573865, 0.20011565717648094, 0.15668931603210567, 0.16934378164028507, 0.16583971353965465, 0.18307388603313768, 0.15832247246772935, 0.18184135014702463, 0.0870581787387158, 0.07420570431373563, 0.07841584358511355, 0.08658021317402886, 0.0764258368848807, 0.07873052909461553, 0.08067708880578117, 0.07801874472758552, 0.08456010083370835]}, "mutation_prompt": null}
{"id": "80655dbc-8bd1-4351-9f4c-feb67fbfffda", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = 0.7 + 0.3 * np.random.rand() * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        # Modified perturbation size for adaptive scaling\n        perturbation_size = 0.05 + 0.05 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                # Increase local search frequency near best solution\n                if np.random.rand() < (1 - self.fitness[i] / self.fitness.min()):\n                    trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Introduce adaptive scaling for local search step size to enhance exploitation near convergence.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9777af56-07eb-41e8-a6b5-b73094fa5e8b", "metadata": {"aucs": [0.8635679096504482, 0.8651904840699595, 0.8706656124464578, 0.8810134389315147, 0.8685718654200112, 0.8856447563191137, 0.8684146222163904, 0.8756551246832438, 0.8679631748178588, 0.7532667375927997, 0.7443007533536237, 0.7569169131023736, 0.7347243411524695, 0.7679153024656786, 0.7545183773600026, 0.7368902332759621, 0.7166759231323901, 0.7738634979294521, 0.15221440172801903, 0.5504231285938777, 0.54815205534065, 0.6141208230766544, 0.5926557280439354, 0.17717242840235026, 0.48246124113651934, 0.15915506627740783, 0.48402756353441956, 0.13292692014921215, 0.1619629465969551, 0.11272842499955038, 0.1539150518159822, 0.15948608292752742, 0.1561365275238189, 0.12195309062208304, 0.14776975668919712, 0.14660357755904152, 0.8884242633665269, 0.8998429290768728, 0.9442128792419914, 0.9529502408428152, 0.9546236887962392, 0.9627372031533812, 0.8641095226866682, 0.8993408801477827, 0.9386599586607532, 0.7173611945447436, 0.6968346240610815, 0.6981789833798285, 0.7097262539295792, 0.7280636814887845, 0.7203972964247863, 0.6888976754292169, 0.6992924393249529, 0.6938502093579653, 0.8578762062038061, 0.8836313302564254, 0.8699748825079259, 0.8809898710796447, 0.8727004376322524, 0.8989927174263601, 0.8787271372953744, 0.7951697730295809, 0.8621600934569479, 0.12861512018828958, 0.6611720265992113, 0.5800596250663388, 0.2685811802835609, 0.5777109707231156, 0.5186167277814931, 0.7000093107114131, 0.710976705107656, 0.6620400567496458, 0.6823035883090878, 0.6696361829113344, 0.6261798768441218, 0.5844216609310808, 0.6381144679130523, 0.42161185600649365, 0.6758313923014843, 0.1262323780913417, 0.5098010512578499, 0.4286920310498181, 0.48805118670775693, 0.425576654322369, 0.6029110103067217, 0.28694574622930735, 0.4152592389400309, 0.4069474665076702, 0.4120514530218341, 0.44419535760603435, 0.661122795775277, 0.5483002350605397, 0.6293056775802961, 0.42887125693541184, 0.6395293719486403, 0.45687673986909205, 0.7646005010276716, 0.7029255531350846, 0.7179893530147177, 0.18029074111849164, 0.2957308371326355, 0.17083567439940073, 0.19435699059037959, 0.29459502055381603, 0.15378019700896617, 0.19790128381342587, 0.24887179477912602, 0.29525490925803566, 0.359025352572241, 0.3936311269217716, 0.3654223749196335, 0.35023462902662394, 0.3754514497426875, 0.4129025874544041, 0.35869869452121217, 0.31308989279862176, 0.4526392597533164, 0.7105134948269605, 0.7164644305089387, 0.8116356047267818, 0.7248755944144798, 0.5745644185179984, 0.8276347867001287, 0.6925019769340037, 0.7388022611470371, 0.6868041915551863, 0.13247506286945132, 0.1244319687874138, 0.10302623549869239, 0.10223168645004022, 0.09842825088064278, 0.09972399049977776, 0.11428249942573221, 0.08599751120685373, 0.08017712742104066, 0.17043121414511575, 0.14067064232233606, 0.1727208310728483, 0.1868523317286226, 0.7610379728109469, 0.1723421938595613, 0.3344869463872888, 0.16047322868341285, 0.2652780291712937, 0.47709191428407316, 0.551139202495502, 0.5776666666407821, 0.5127110128720004, 0.6098202428335417, 0.6575378119560286, 0.6331396625786849, 0.5453262382759511, 0.634106206486766, 0.3973397305655164, 0.33327653221655396, 0.32931149704114837, 0.4273860392087654, 0.41386243728154837, 0.4582653409979063, 0.26308425642842903, 0.40123365999851623, 0.44758314524427656, 0.19034086330786226, 0.2310733816666416, 0.18203372336269275, 0.2253993535990807, 0.2119916895974352, 0.1985762199015786, 0.18323681702479733, 0.18581247082260932, 0.18300515909694837, 0.5488774185432892, 0.18031549284431037, 0.5349302586087175, 0.6126493486657143, 0.6045243538687136, 0.6964947698121675, 0.210426364113661, 0.6301172500758386, 0.6993563085908812, 0.17179353502163397, 0.1477603756649416, 0.18668235938951727, 0.18507530007033468, 0.17664466913025278, 0.8525011351688441, 0.8446174742006775, 0.16443284941386305, 0.8850378671919152, 0.8759684773718894, 0.16809239305294776, 0.8787423422616358, 0.16423240593239863, 0.16282230354353555, 0.20688933676184718, 0.20911423561462528, 0.8352912094291937, 0.12433852578530424, 0.19288556739724072, 0.1738455562573865, 0.20011565717648094, 0.15668931603210567, 0.16934378164028507, 0.16583971353965465, 0.1541713266825524, 0.2275184983065729, 0.15161845059884194, 0.0870581787387158, 0.07420570431373563, 0.07841584358511355, 0.08658021317402886, 0.0764258368848807, 0.07873052909461553, 0.08067708880578117, 0.07801874472758552, 0.08456010083370835]}, "mutation_prompt": null}
{"id": "34243f3d-3ee4-40f3-9624-16afd1c0c49a", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n        self.best_position = None  # Track the best position\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n            self.best_position = self.population[np.argmin(self.fitness)]  # Initialize the best position\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = 0.7 + 0.3 * np.random.rand() * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c]) + 0.1 * (self.best_position - self.population[idx])  # Added directionality\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        # Modified perturbation size for adaptive scaling\n        perturbation_size = 0.05 + 0.05 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                # Increase local search frequency near best solution\n                if np.random.rand() < (1 - self.fitness[i] / self.fitness.min()):\n                    trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.fitness[np.argmin(self.fitness)]:\n                        self.best_position = trial  # Update the best position\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Enhance mutation strategy by introducing directionality based on historical best positions to improve exploration.", "configspace": "", "generation": 74, "fitness": 0.3829460517001343, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.27.", "error": "", "parent_id": "9777af56-07eb-41e8-a6b5-b73094fa5e8b", "metadata": {"aucs": [0.85049566683354, 0.8480564283780936, 0.5401722990636326, 0.7341000917721773, 0.8836893203665546, 0.8779350480210334, 0.8563059743902997, 0.8639758497076211, 0.8526691593131794, 0.7805455183880541, 0.742496892220449, 0.7486199003313188, 0.759957197499545, 0.7405104440533545, 0.45173481128160453, 0.76085880237363, 0.7402904978317595, 0.6933242282667589, 0.28588608942987026, 0.4262858452751759, 0.44487317691935113, 0.12746829954966454, 0.41769826146057965, 0.3093230461506413, 0.16357377480171365, 0.4758249701291162, 0.1359072223031813, 0.11932614674787456, 0.12305400200390615, 0.20562748679847287, 0.13217900891688694, 0.14967730586575712, 0.14998755460970314, 0.11742308550739877, 0.12204515660996351, 0.13278532731417403, 0.9213625412183807, 0.9600768063485869, 0.8878548169264568, 0.194984206179306, 0.9370566299441151, 0.07493418048550304, 0.22203666095620245, 0.9024486919538067, 0.895493888031482, 0.7009055589127923, 0.6943126382647397, 0.2378750945804312, 0.6954159247312479, 0.7098673164069795, 0.7390407109702295, 0.7100582239116966, 0.7113497312046059, 0.6676213288678711, 0.799860244697099, 0.859802959054295, 0.8279685373009759, 0.8231743981723715, 0.8903808232760902, 0.8463586575965963, 0.8765957428572867, 0.3436291763648729, 0.8777028247267722, 0.27691488373927065, 0.5595348052248588, 0.43039478291992916, 0.30287431599634373, 0.25213488676469975, 0.2832621888259258, 0.3814759862499102, 0.3273377430721397, 0.25940538082669673, 0.26393922680755555, 0.23870946234719703, 0.22339699036875849, 0.129172562134094, 0.15898919787942434, 0.6384512832152622, 0.7060878201945151, 0.30268934607701203, 0.3096548821705455, 0.0027846143931805623, 0.3788387046521552, 0.36559157216400584, 9.999999999998899e-05, 0.119141904646617, 0.3801046934819856, 0.5803113320342145, 0.48223760861708886, 0.38370416186230527, 0.4184029520919347, 0.6569297716526854, 0.6452255735402306, 0.48156406772821647, 0.6312136357016171, 0.17301043988742426, 0.7736770589476267, 0.5220859076769163, 0.32618046268713463, 0.1018340909614519, 0.09460190411792624, 0.1244617929068852, 0.13118203860551114, 9.999999999998899e-05, 0.23004344010760303, 0.2133605253288514, 0.3294526331219114, 0.1714831521460357, 0.43305663093768454, 0.3784649468505423, 0.2998007606280847, 0.21085292045169435, 0.34581864015118235, 0.24951530855375925, 0.30685188029065014, 0.34548340510824704, 0.10741785290191586, 0.8187638967713592, 0.7631326808565512, 0.7155889066019969, 0.804241558648317, 0.7011672780903135, 0.6225321176311311, 0.7226518387498087, 0.7787089776972622, 0.6761798571972504, 0.09455779929443231, 0.11111646696165567, 0.10229889480387233, 0.1052234363650979, 0.12548434537724262, 0.09059202422082724, 0.08973836912254718, 0.08486335397326694, 0.10642954478494193, 0.2655127166616479, 0.14536055479719268, 0.1792468894837188, 0.15047238252664463, 0.13349028075963632, 0.19997812484145294, 0.14968402593693897, 0.19905445358830642, 0.17371782699314187, 0.5051155020459566, 0.42660462958169076, 0.4753887388389718, 0.4824942118208826, 0.26879119529143636, 0.3336677786886757, 0.5572783122481432, 0.3273341292814562, 0.47677734174663156, 0.3466523343434279, 0.20430353177247385, 0.2666912434338601, 0.36962623668926387, 0.3010003042557601, 0.3258684334247508, 0.48250550644213785, 0.3398192227619118, 0.35349242486113674, 0.18448064997268532, 0.20775244026896322, 0.19230873029848217, 0.21504119844252012, 0.21399759857571854, 0.20489720525884714, 0.19795217327907744, 0.19121286426742667, 0.1994591622893609, 0.2154319668459862, 0.19967437223185158, 0.20301219610666565, 0.2603954370261343, 0.26407978213585526, 0.30858262303882456, 0.21171821119337364, 0.5203442794109608, 0.5918740907262366, 0.8726990725451156, 0.16515736840242767, 0.18664382594726914, 0.4086488312651726, 0.18560332270739777, 0.18808749794590696, 0.32465458738993613, 0.16644523040310688, 0.18838687033688817, 0.8756183865128178, 0.16685990175419685, 0.8681381297163762, 0.20521723035974115, 0.16363897551375917, 0.20265266921112812, 0.12736065414934128, 0.1261803068508145, 0.12544672002905521, 0.18695180682509183, 0.18745499995234494, 0.20914470028340215, 0.19054849573421073, 0.17540754402142789, 0.2133647083718926, 0.18348526791595587, 0.1831984571221178, 0.18359952751345876, 0.079009900471401, 0.08450249368304252, 0.07762925598793713, 0.09215742251081305, 0.07439264425068448, 0.07520796520245898, 0.07163460172773572, 0.07576322367595845, 0.07787557512828225]}, "mutation_prompt": null}
{"id": "476b0bdf-555d-4f4d-ac49-9129594a9947", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = 0.7 + 0.3 * np.random.rand() * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        # Modified perturbation size for adaptive scaling\n        perturbation_size = 0.05 + 0.05 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                # Increase local search frequency near best solution\n                if np.random.rand() < (1 - self.fitness[i] / self.fitness.min()):\n                    trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Introduce adaptive scaling for local search step size to enhance exploitation near convergence.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9777af56-07eb-41e8-a6b5-b73094fa5e8b", "metadata": {"aucs": [0.8635679096504482, 0.8651904840699595, 0.8706656124464578, 0.8810134389315147, 0.8685718654200112, 0.8856447563191137, 0.8684146222163904, 0.8756551246832438, 0.8679631748178588, 0.7532667375927997, 0.7443007533536237, 0.7569169131023736, 0.7347243411524695, 0.7679153024656786, 0.7545183773600026, 0.7368902332759621, 0.7166759231323901, 0.7738634979294521, 0.15221440172801903, 0.5504231285938777, 0.54815205534065, 0.6141208230766544, 0.5926557280439354, 0.17717242840235026, 0.48246124113651934, 0.15915506627740783, 0.48402756353441956, 0.13292692014921215, 0.1619629465969551, 0.11272842499955038, 0.1539150518159822, 0.15948608292752742, 0.1561365275238189, 0.12195309062208304, 0.14776975668919712, 0.14660357755904152, 0.8884242633665269, 0.8998429290768728, 0.9442128792419914, 0.9529502408428152, 0.9546236887962392, 0.9627372031533812, 0.8641095226866682, 0.8993408801477827, 0.9386599586607532, 0.7173611945447436, 0.6968346240610815, 0.6981789833798285, 0.7097262539295792, 0.7280636814887845, 0.7203972964247863, 0.6888976754292169, 0.6992924393249529, 0.6938502093579653, 0.8578762062038061, 0.8836313302564254, 0.8699748825079259, 0.8809898710796447, 0.8727004376322524, 0.8989927174263601, 0.8787271372953744, 0.7951697730295809, 0.8621600934569479, 0.12861512018828958, 0.6611720265992113, 0.5800596250663388, 0.2685811802835609, 0.5777109707231156, 0.5186167277814931, 0.7000093107114131, 0.710976705107656, 0.6620400567496458, 0.6823035883090878, 0.6696361829113344, 0.6261798768441218, 0.5844216609310808, 0.6381144679130523, 0.42161185600649365, 0.6758313923014843, 0.1262323780913417, 0.5098010512578499, 0.4286920310498181, 0.48805118670775693, 0.425576654322369, 0.6029110103067217, 0.28694574622930735, 0.4152592389400309, 0.4069474665076702, 0.4120514530218341, 0.44419535760603435, 0.661122795775277, 0.5483002350605397, 0.6293056775802961, 0.42887125693541184, 0.6395293719486403, 0.45687673986909205, 0.7646005010276716, 0.7029255531350846, 0.7179893530147177, 0.18029074111849164, 0.2957308371326355, 0.17083567439940073, 0.19435699059037959, 0.29459502055381603, 0.15378019700896617, 0.19790128381342587, 0.24887179477912602, 0.29525490925803566, 0.359025352572241, 0.3936311269217716, 0.3654223749196335, 0.35023462902662394, 0.3754514497426875, 0.4129025874544041, 0.35869869452121217, 0.31308989279862176, 0.4526392597533164, 0.7105134948269605, 0.7164644305089387, 0.8116356047267818, 0.7248755944144798, 0.5745644185179984, 0.8276347867001287, 0.6925019769340037, 0.7388022611470371, 0.6868041915551863, 0.13247506286945132, 0.1244319687874138, 0.10302623549869239, 0.10223168645004022, 0.09842825088064278, 0.09972399049977776, 0.11428249942573221, 0.08599751120685373, 0.08017712742104066, 0.17043121414511575, 0.14067064232233606, 0.1727208310728483, 0.1868523317286226, 0.7610379728109469, 0.1723421938595613, 0.3344869463872888, 0.16047322868341285, 0.2652780291712937, 0.47709191428407316, 0.551139202495502, 0.5776666666407821, 0.5127110128720004, 0.6098202428335417, 0.6575378119560286, 0.6331396625786849, 0.5453262382759511, 0.634106206486766, 0.3973397305655164, 0.33327653221655396, 0.32931149704114837, 0.4273860392087654, 0.41386243728154837, 0.4582653409979063, 0.26308425642842903, 0.40123365999851623, 0.44758314524427656, 0.19034086330786226, 0.2310733816666416, 0.18203372336269275, 0.2253993535990807, 0.2119916895974352, 0.1985762199015786, 0.18323681702479733, 0.18581247082260932, 0.18300515909694837, 0.5488774185432892, 0.18031549284431037, 0.5349302586087175, 0.6126493486657143, 0.6045243538687136, 0.6964947698121675, 0.210426364113661, 0.6301172500758386, 0.6993563085908812, 0.17179353502163397, 0.1477603756649416, 0.18668235938951727, 0.18507530007033468, 0.17664466913025278, 0.8525011351688441, 0.8446174742006775, 0.16443284941386305, 0.8850378671919152, 0.8759684773718894, 0.16809239305294776, 0.8787423422616358, 0.16423240593239863, 0.16282230354353555, 0.20688933676184718, 0.20911423561462528, 0.8352912094291937, 0.12433852578530424, 0.19288556739724072, 0.1738455562573865, 0.20011565717648094, 0.15668931603210567, 0.16934378164028507, 0.16583971353965465, 0.1541713266825524, 0.2275184983065729, 0.15161845059884194, 0.0870581787387158, 0.07420570431373563, 0.07841584358511355, 0.08658021317402886, 0.0764258368848807, 0.07873052909461553, 0.08067708880578117, 0.07801874472758552, 0.08456010083370835]}, "mutation_prompt": null}
{"id": "720402a2-596c-4387-92e2-3bca671cefe1", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = 0.7 + 0.3 * np.random.rand() * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        # Modified perturbation size for adaptive scaling\n        perturbation_size = 0.05 + 0.05 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                # Increase local search frequency near best solution\n                dynamic_intensity = 0.8 + 0.2 * (1 - self.fitness[i] / self.fitness.min())  # Dynamic local search intensity\n                if np.random.rand() < dynamic_intensity:\n                    trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Integrate dynamic local search intensity adjustment to balance exploration and exploitation based on solution quality.", "configspace": "", "generation": 76, "fitness": 0.3261821642071437, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.22.", "error": "", "parent_id": "9777af56-07eb-41e8-a6b5-b73094fa5e8b", "metadata": {"aucs": [0.6616925567821342, 0.6846605716391085, 0.7195116134845397, 0.697017977996243, 0.71867110719054, 0.6710789784115001, 0.697693893304677, 0.6748264457441477, 0.6852932090176728, 0.5440474361116725, 0.5291083602937885, 0.5380542236813194, 0.49372900313246004, 0.5030571592478182, 0.4873091403109049, 0.5135038331984192, 0.6048033162714495, 0.545625564201482, 0.11400937899831554, 0.13819195804149675, 0.11426976576648251, 0.10613495612799417, 0.11887328296491051, 0.0945263951296823, 0.18230257645725523, 0.14195340067768702, 0.09814187639979388, 0.09257287614150378, 0.09422517081317328, 0.07696690680815121, 0.10279617165019794, 0.1229933941610658, 0.07524571953662285, 0.09941714319155581, 0.11395816246176149, 0.08421260434570754, 0.9572238928047333, 0.9325357660424873, 0.8121109292813771, 0.8564129130045471, 0.87092309202861, 0.852430522466524, 0.8510206562494398, 0.9335889396793247, 0.7712454060631848, 0.3857348930728456, 0.3941796856752988, 0.4001122646993843, 0.39327430858212875, 0.42763987911526735, 0.4035375825270118, 0.35684110479429165, 0.34547775504228306, 0.3082705204050431, 0.7138870232995419, 0.6559213203685765, 0.6673091930810038, 0.5851006270376693, 0.7155587148466247, 0.6381677374949182, 0.22095211338805365, 0.6565675004648848, 0.614795272270191, 0.15867270444060433, 0.22597486295821867, 0.2704868395948692, 0.22437441560654825, 0.1975492078368346, 0.294161314142216, 0.31828670807046266, 0.17376920074459756, 0.30500407230723026, 0.2415063313159168, 0.1387651293902067, 0.16453311311697905, 0.2853534060823555, 0.34020402479740963, 0.2696029185751352, 0.31920451317572884, 0.29551726749799223, 0.32614437854908307, 0.2706508959063053, 0.23117232661707265, 0.27241413826809147, 0.3258298203755212, 0.2566984108976218, 0.2882078382277202, 0.2300435964973132, 0.2586110483454259, 0.27699646963251223, 0.40481222647742265, 0.3411234715106529, 0.4225223744694562, 0.36220956838499874, 0.42939485076665695, 0.32600294308611977, 0.5536964007288336, 0.49022239579888816, 0.43323187860315215, 0.058069429143644435, 0.08940644725920377, 0.09361352225889674, 0.22159091650382556, 0.05800120506959172, 0.14140190925732843, 0.11290631621264768, 0.10291712106701312, 0.25977332066101433, 0.2549623418605884, 0.24768382833919855, 0.2065921753765152, 0.22139133342344997, 0.23824472813345432, 0.26024619850994546, 0.208314507646564, 0.236653468940753, 0.2415582078439098, 0.560625811884913, 0.5276795533879692, 0.6040388265040866, 0.5456839074087192, 0.5379567572319175, 0.544689362179904, 0.5274417601540278, 0.5778996722124232, 0.5469650955672133, 0.0896034221412878, 0.08768651721518417, 0.0808545359070284, 0.12305342525059437, 0.08986345717127164, 0.11896696283174957, 0.09990144400872158, 0.07084359123471273, 0.08981218944770886, 0.3622554575414392, 0.14579105789405689, 0.1139161923659785, 0.24978065658787219, 0.15119077290972616, 0.26075746013048773, 0.208944681422646, 0.1859395525150338, 0.23360497996416585, 0.30812623707647135, 0.2982895061991838, 0.30267878884106447, 0.3311927563617192, 0.3235134845420674, 0.28613182316680574, 0.31473052648391786, 0.32928204542147954, 0.28383809293150253, 0.24956256311089553, 0.23640837319541297, 0.23601467248466035, 0.24533623135386662, 0.2589920020468941, 0.21285572473304903, 0.2490815459625032, 0.2736025661691618, 0.23998748614623988, 0.18932527328375004, 0.17628399330490863, 0.17571021946529963, 0.17792380691464382, 0.21699491756220735, 0.17404962142932923, 0.19791484886020283, 0.1692483955446782, 0.1823595106717424, 0.24262645017629925, 0.18504511202249574, 0.20577875662038192, 0.20968169075523235, 0.25186706316643637, 0.21339323274646094, 0.36570914726860415, 0.23482680616756013, 0.21583119850155563, 0.7608274016565815, 0.649484856532311, 0.14933320441995057, 0.205723733072124, 0.19692273944864647, 0.16922068068114715, 0.18469844900212307, 0.5246282260556975, 0.6655104163246122, 0.7118852685174963, 0.19406040678646552, 0.6577073071254682, 0.6842692376990838, 0.6270918793428983, 0.5447315347373287, 0.20833008981816614, 0.1264491749210207, 0.6719449154063102, 0.18299548131564736, 0.1951484501698576, 0.18153919366655924, 0.2727858797194759, 0.17921847549050252, 0.19560017313612266, 0.19422990042474753, 0.1769261562478186, 0.185632746126267, 0.06335917299283522, 0.07372733620407035, 0.06524828758244117, 0.0726652481502027, 0.07456450372253354, 0.06861881665316216, 0.07089921347717354, 0.07094376860063023, 0.06090978597386587]}, "mutation_prompt": null}
{"id": "050404a1-f60c-44a0-ae56-011567dfaf47", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = 0.7 + 0.3 * np.random.rand() * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        # Modified perturbation size for adaptive scaling\n        perturbation_size = 0.05 + 0.05 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        \n        # Leverage historical data for smarter perturbation\n        if np.random.rand() < 0.1:\n            perturbation += 0.01 * np.std(self.population, axis=0)\n        \n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                # Increase local search frequency near best solution\n                if np.random.rand() < (1 - self.fitness[i] / self.fitness.min()):\n                    trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Enhance local search by leveraging historical population data for better perturbation guidance.", "configspace": "", "generation": 77, "fitness": 0.46566566242801116, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.28.", "error": "", "parent_id": "9777af56-07eb-41e8-a6b5-b73094fa5e8b", "metadata": {"aucs": [0.8635679096504482, 0.8651904840699595, 0.8706656124464578, 0.8810134389315147, 0.8685718654200112, 0.8856447563191137, 0.8931364442475312, 0.859977325535783, 0.8627531783422482, 0.7218637602870712, 0.7579096263152558, 0.7274282195285311, 0.7297417042910761, 0.7332757955599838, 0.7405754597062884, 0.7685514332716002, 0.7399508917753836, 0.7558080323890785, 0.5374616051264913, 0.1554091708095724, 0.15850473870664705, 0.6141208230766544, 0.5926557280439354, 0.17717242840235026, 0.48246124113651934, 0.15915506627740783, 0.48402756353441956, 0.1368089031752865, 0.5303162459957197, 0.12350621358054037, 0.1539150518159822, 0.15948608292752742, 0.1561365275238189, 0.12195309062208304, 0.14776975668919712, 0.14660357755904152, 0.8596885106401189, 0.9547181848482531, 0.9458475536924533, 0.9529502408428152, 0.9546236887962392, 0.9627372031533812, 0.8641095226866682, 0.8993408801477827, 0.9386599586607532, 0.7173611945447436, 0.6968346240610815, 0.6981789833798285, 0.7097262539295792, 0.7280636814887845, 0.7203972964247863, 0.7170445057645534, 0.7010265371242057, 0.7073225858876401, 0.8578762062038061, 0.8836313302564254, 0.8699748825079259, 0.8809898710796447, 0.8727004376322524, 0.8989927174263601, 0.8787271372953744, 0.7951697730295809, 0.8621600934569479, 0.12861512018828958, 0.6611720265992113, 0.5800596250663388, 0.5433439066733833, 0.6029560360518328, 0.5507960600426627, 0.7000093107114131, 0.710976705107656, 0.6620400567496458, 0.6823035883090878, 0.6696361829113344, 0.6261798768441218, 0.5844216609310808, 0.6381144679130523, 0.42161185600649365, 0.6758313923014843, 0.1262323780913417, 0.5098010512578499, 0.3742015137093261, 0.2107997715034684, 0.4287418183647794, 0.6029110103067217, 0.28694574622930735, 0.4152592389400309, 0.4351139526849672, 0.589064979964863, 0.44060404649580764, 0.661122795775277, 0.5483002350605397, 0.6293056775802961, 0.509150349439955, 0.5133469921122245, 0.5264893490053564, 0.7646005010276716, 0.7029255531350846, 0.7179893530147177, 0.08280420067035899, 0.2975076939805109, 0.15247650614971697, 0.30922245231008005, 0.23959960349298026, 0.1619197008900104, 0.19790128381342587, 0.24887179477912602, 0.29525490925803566, 0.359025352572241, 0.3936311269217716, 0.3654223749196335, 0.3787223512072625, 0.41503355163308253, 0.4429501305192618, 0.44725777231721486, 0.3543365327819489, 0.33677060803171655, 0.6865802553365423, 0.7931875541639423, 0.7652716026425535, 0.8241070379191384, 0.735971458599672, 0.7673107208567862, 0.6925019769340037, 0.7388022611470371, 0.6868041915551863, 0.13247506286945132, 0.1244319687874138, 0.10302623549869239, 0.10223168645004022, 0.09842825088064278, 0.09972399049977776, 0.1294322945718288, 0.0881566702712786, 0.07848626354522947, 0.17043121414511575, 0.14067064232233606, 0.1727208310728483, 0.31810204245651186, 0.17786099594948246, 0.16508418388528046, 0.3344869463872888, 0.16047322868341285, 0.2652780291712937, 0.45548281651739975, 0.45597721809355585, 0.4884516746725529, 0.5127110128720004, 0.6098202428335417, 0.6575378119560286, 0.6331396625786849, 0.5453262382759511, 0.634106206486766, 0.4192086316175937, 0.36065604214092006, 0.3202614732968535, 0.4273860392087654, 0.41386243728154837, 0.4582653409979063, 0.26308425642842903, 0.40123365999851623, 0.44758314524427656, 0.18114702682800443, 0.23490886028181746, 0.19571527563842317, 0.2253993535990807, 0.2119916895974352, 0.1985762199015786, 0.18323681702479733, 0.18581247082260932, 0.18300515909694837, 0.6569715170879493, 0.4928785240557464, 0.22350951579707523, 0.6126493486657143, 0.6045243538687136, 0.6964947698121675, 0.210426364113661, 0.6301172500758386, 0.6993563085908812, 0.17179353502163397, 0.1477603756649416, 0.18668235938951727, 0.1851397921253689, 0.17664466913025278, 0.8554582874999592, 0.8817287666425329, 0.16855749224258687, 0.16845774918476364, 0.8529943171084622, 0.15999619509645313, 0.8670300666541183, 0.16423240593239863, 0.16282230354353555, 0.20688933676184718, 0.20778534801681403, 0.7750006669175131, 0.20106501932140186, 0.19288556739724072, 0.1738455562573865, 0.20011565717648094, 0.15668931603210567, 0.16934378164028507, 0.16583971353965465, 0.18695014063394433, 0.18384249899280924, 0.20508185399815637, 0.0870581787387158, 0.07420570431373563, 0.07841584358511355, 0.08658021317402886, 0.0764258368848807, 0.07873052909461553, 0.08067708880578117, 0.07801874472758552, 0.08456010083370835]}, "mutation_prompt": null}
{"id": "55df23dd-aefd-413a-873f-9461c9e08d73", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = 0.7 + 0.3 * np.random.rand() * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        # Modified perturbation size for adaptive scaling\n        perturbation_size = 0.05 + 0.05 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                # Increase local search frequency near best solution\n                if np.random.rand() < (1 - self.fitness[i] / self.fitness.min()):\n                    trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Introduce adaptive scaling for local search step size to enhance exploitation near convergence.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9777af56-07eb-41e8-a6b5-b73094fa5e8b", "metadata": {"aucs": [0.8635679096504482, 0.8651904840699595, 0.8706656124464578, 0.8810134389315147, 0.8685718654200112, 0.8856447563191137, 0.8684146222163904, 0.8756551246832438, 0.8679631748178588, 0.7532667375927997, 0.7443007533536237, 0.7569169131023736, 0.7347243411524695, 0.7679153024656786, 0.7545183773600026, 0.7368902332759621, 0.7166759231323901, 0.7738634979294521, 0.15221440172801903, 0.5504231285938777, 0.54815205534065, 0.6141208230766544, 0.5926557280439354, 0.17717242840235026, 0.48246124113651934, 0.15915506627740783, 0.48402756353441956, 0.13292692014921215, 0.1619629465969551, 0.11272842499955038, 0.1539150518159822, 0.15948608292752742, 0.1561365275238189, 0.12195309062208304, 0.14776975668919712, 0.14660357755904152, 0.8884242633665269, 0.8998429290768728, 0.9442128792419914, 0.9529502408428152, 0.9546236887962392, 0.9627372031533812, 0.8641095226866682, 0.8993408801477827, 0.9386599586607532, 0.7173611945447436, 0.6968346240610815, 0.6981789833798285, 0.7097262539295792, 0.7280636814887845, 0.7203972964247863, 0.6888976754292169, 0.6992924393249529, 0.6938502093579653, 0.8578762062038061, 0.8836313302564254, 0.8699748825079259, 0.8809898710796447, 0.8727004376322524, 0.8989927174263601, 0.8787271372953744, 0.7951697730295809, 0.8621600934569479, 0.12861512018828958, 0.6611720265992113, 0.5800596250663388, 0.2685811802835609, 0.5777109707231156, 0.5186167277814931, 0.7000093107114131, 0.710976705107656, 0.6620400567496458, 0.6823035883090878, 0.6696361829113344, 0.6261798768441218, 0.5844216609310808, 0.6381144679130523, 0.42161185600649365, 0.6758313923014843, 0.1262323780913417, 0.5098010512578499, 0.4286920310498181, 0.48805118670775693, 0.425576654322369, 0.6029110103067217, 0.28694574622930735, 0.4152592389400309, 0.4069474665076702, 0.4120514530218341, 0.44419535760603435, 0.661122795775277, 0.5483002350605397, 0.6293056775802961, 0.42887125693541184, 0.6395293719486403, 0.45687673986909205, 0.7646005010276716, 0.7029255531350846, 0.7179893530147177, 0.18029074111849164, 0.2957308371326355, 0.17083567439940073, 0.19435699059037959, 0.29459502055381603, 0.15378019700896617, 0.19790128381342587, 0.24887179477912602, 0.29525490925803566, 0.359025352572241, 0.3936311269217716, 0.3654223749196335, 0.35023462902662394, 0.3754514497426875, 0.4129025874544041, 0.35869869452121217, 0.31308989279862176, 0.4526392597533164, 0.7105134948269605, 0.7164644305089387, 0.8116356047267818, 0.7248755944144798, 0.5745644185179984, 0.8276347867001287, 0.6925019769340037, 0.7388022611470371, 0.6868041915551863, 0.13247506286945132, 0.1244319687874138, 0.10302623549869239, 0.10223168645004022, 0.09842825088064278, 0.09972399049977776, 0.11428249942573221, 0.08599751120685373, 0.08017712742104066, 0.17043121414511575, 0.14067064232233606, 0.1727208310728483, 0.1868523317286226, 0.7610379728109469, 0.1723421938595613, 0.3344869463872888, 0.16047322868341285, 0.2652780291712937, 0.47709191428407316, 0.551139202495502, 0.5776666666407821, 0.5127110128720004, 0.6098202428335417, 0.6575378119560286, 0.6331396625786849, 0.5453262382759511, 0.634106206486766, 0.3973397305655164, 0.33327653221655396, 0.32931149704114837, 0.4273860392087654, 0.41386243728154837, 0.4582653409979063, 0.26308425642842903, 0.40123365999851623, 0.44758314524427656, 0.19034086330786226, 0.2310733816666416, 0.18203372336269275, 0.2253993535990807, 0.2119916895974352, 0.1985762199015786, 0.18323681702479733, 0.18581247082260932, 0.18300515909694837, 0.5488774185432892, 0.18031549284431037, 0.5349302586087175, 0.6126493486657143, 0.6045243538687136, 0.6964947698121675, 0.210426364113661, 0.6301172500758386, 0.6993563085908812, 0.17179353502163397, 0.1477603756649416, 0.18668235938951727, 0.18507530007033468, 0.17664466913025278, 0.8525011351688441, 0.8446174742006775, 0.16443284941386305, 0.8850378671919152, 0.8759684773718894, 0.16809239305294776, 0.8787423422616358, 0.16423240593239863, 0.16282230354353555, 0.20688933676184718, 0.20911423561462528, 0.8352912094291937, 0.12433852578530424, 0.19288556739724072, 0.1738455562573865, 0.20011565717648094, 0.15668931603210567, 0.16934378164028507, 0.16583971353965465, 0.1541713266825524, 0.2275184983065729, 0.15161845059884194, 0.0870581787387158, 0.07420570431373563, 0.07841584358511355, 0.08658021317402886, 0.0764258368848807, 0.07873052909461553, 0.08067708880578117, 0.07801874472758552, 0.08456010083370835]}, "mutation_prompt": null}
{"id": "644c09e9-bd29-46dd-ad19-51e6ee975b80", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = 0.7 + 0.3 * np.random.rand() * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        # Modified perturbation size for adaptive scaling\n        perturbation_size = 0.05 + 0.05 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                # Increase local search frequency near best solution\n                if np.random.rand() < (1 - self.fitness[i] / self.fitness.min()):\n                    trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Introduce adaptive scaling for local search step size to enhance exploitation near convergence.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9777af56-07eb-41e8-a6b5-b73094fa5e8b", "metadata": {"aucs": [0.8635679096504482, 0.8651904840699595, 0.8706656124464578, 0.8810134389315147, 0.8685718654200112, 0.8856447563191137, 0.8684146222163904, 0.8756551246832438, 0.8679631748178588, 0.7532667375927997, 0.7443007533536237, 0.7569169131023736, 0.7347243411524695, 0.7679153024656786, 0.7545183773600026, 0.7368902332759621, 0.7166759231323901, 0.7738634979294521, 0.15221440172801903, 0.5504231285938777, 0.54815205534065, 0.6141208230766544, 0.5926557280439354, 0.17717242840235026, 0.48246124113651934, 0.15915506627740783, 0.48402756353441956, 0.13292692014921215, 0.1619629465969551, 0.11272842499955038, 0.1539150518159822, 0.15948608292752742, 0.1561365275238189, 0.12195309062208304, 0.14776975668919712, 0.14660357755904152, 0.8884242633665269, 0.8998429290768728, 0.9442128792419914, 0.9529502408428152, 0.9546236887962392, 0.9627372031533812, 0.8641095226866682, 0.8993408801477827, 0.9386599586607532, 0.7173611945447436, 0.6968346240610815, 0.6981789833798285, 0.7097262539295792, 0.7280636814887845, 0.7203972964247863, 0.6888976754292169, 0.6992924393249529, 0.6938502093579653, 0.8578762062038061, 0.8836313302564254, 0.8699748825079259, 0.8809898710796447, 0.8727004376322524, 0.8989927174263601, 0.8787271372953744, 0.7951697730295809, 0.8621600934569479, 0.12861512018828958, 0.6611720265992113, 0.5800596250663388, 0.2685811802835609, 0.5777109707231156, 0.5186167277814931, 0.7000093107114131, 0.710976705107656, 0.6620400567496458, 0.6823035883090878, 0.6696361829113344, 0.6261798768441218, 0.5844216609310808, 0.6381144679130523, 0.42161185600649365, 0.6758313923014843, 0.1262323780913417, 0.5098010512578499, 0.4286920310498181, 0.48805118670775693, 0.425576654322369, 0.6029110103067217, 0.28694574622930735, 0.4152592389400309, 0.4069474665076702, 0.4120514530218341, 0.44419535760603435, 0.661122795775277, 0.5483002350605397, 0.6293056775802961, 0.42887125693541184, 0.6395293719486403, 0.45687673986909205, 0.7646005010276716, 0.7029255531350846, 0.7179893530147177, 0.18029074111849164, 0.2957308371326355, 0.17083567439940073, 0.19435699059037959, 0.29459502055381603, 0.15378019700896617, 0.19790128381342587, 0.24887179477912602, 0.29525490925803566, 0.359025352572241, 0.3936311269217716, 0.3654223749196335, 0.35023462902662394, 0.3754514497426875, 0.4129025874544041, 0.35869869452121217, 0.31308989279862176, 0.4526392597533164, 0.7105134948269605, 0.7164644305089387, 0.8116356047267818, 0.7248755944144798, 0.5745644185179984, 0.8276347867001287, 0.6925019769340037, 0.7388022611470371, 0.6868041915551863, 0.13247506286945132, 0.1244319687874138, 0.10302623549869239, 0.10223168645004022, 0.09842825088064278, 0.09972399049977776, 0.11428249942573221, 0.08599751120685373, 0.08017712742104066, 0.17043121414511575, 0.14067064232233606, 0.1727208310728483, 0.1868523317286226, 0.7610379728109469, 0.1723421938595613, 0.3344869463872888, 0.16047322868341285, 0.2652780291712937, 0.47709191428407316, 0.551139202495502, 0.5776666666407821, 0.5127110128720004, 0.6098202428335417, 0.6575378119560286, 0.6331396625786849, 0.5453262382759511, 0.634106206486766, 0.3973397305655164, 0.33327653221655396, 0.32931149704114837, 0.4273860392087654, 0.41386243728154837, 0.4582653409979063, 0.26308425642842903, 0.40123365999851623, 0.44758314524427656, 0.19034086330786226, 0.2310733816666416, 0.18203372336269275, 0.2253993535990807, 0.2119916895974352, 0.1985762199015786, 0.18323681702479733, 0.18581247082260932, 0.18300515909694837, 0.5488774185432892, 0.18031549284431037, 0.5349302586087175, 0.6126493486657143, 0.6045243538687136, 0.6964947698121675, 0.210426364113661, 0.6301172500758386, 0.6993563085908812, 0.17179353502163397, 0.1477603756649416, 0.18668235938951727, 0.18507530007033468, 0.17664466913025278, 0.8525011351688441, 0.8446174742006775, 0.16443284941386305, 0.8850378671919152, 0.8759684773718894, 0.16809239305294776, 0.8787423422616358, 0.16423240593239863, 0.16282230354353555, 0.20688933676184718, 0.20911423561462528, 0.8352912094291937, 0.12433852578530424, 0.19288556739724072, 0.1738455562573865, 0.20011565717648094, 0.15668931603210567, 0.16934378164028507, 0.16583971353965465, 0.1541713266825524, 0.2275184983065729, 0.15161845059884194, 0.0870581787387158, 0.07420570431373563, 0.07841584358511355, 0.08658021317402886, 0.0764258368848807, 0.07873052909461553, 0.08067708880578117, 0.07801874472758552, 0.08456010083370835]}, "mutation_prompt": null}
{"id": "6ccd9709-78f1-4371-93ec-0493ab2fbe6d", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = 0.7 + 0.3 * np.random.rand() * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        # Modified perturbation size for adaptive scaling\n        perturbation_size = 0.05 + 0.05 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                # Increase local search frequency near best solution\n                if np.random.rand() < (1 - self.fitness[i] / self.fitness.min()):\n                    trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Introduce adaptive scaling for local search step size to enhance exploitation near convergence.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9777af56-07eb-41e8-a6b5-b73094fa5e8b", "metadata": {"aucs": [0.8635679096504482, 0.8651904840699595, 0.8706656124464578, 0.8810134389315147, 0.8685718654200112, 0.8856447563191137, 0.8684146222163904, 0.8756551246832438, 0.8679631748178588, 0.7532667375927997, 0.7443007533536237, 0.7569169131023736, 0.7347243411524695, 0.7679153024656786, 0.7545183773600026, 0.7368902332759621, 0.7166759231323901, 0.7738634979294521, 0.15221440172801903, 0.5504231285938777, 0.54815205534065, 0.6141208230766544, 0.5926557280439354, 0.17717242840235026, 0.48246124113651934, 0.15915506627740783, 0.48402756353441956, 0.13292692014921215, 0.1619629465969551, 0.11272842499955038, 0.1539150518159822, 0.15948608292752742, 0.1561365275238189, 0.12195309062208304, 0.14776975668919712, 0.14660357755904152, 0.8884242633665269, 0.8998429290768728, 0.9442128792419914, 0.9529502408428152, 0.9546236887962392, 0.9627372031533812, 0.8641095226866682, 0.8993408801477827, 0.9386599586607532, 0.7173611945447436, 0.6968346240610815, 0.6981789833798285, 0.7097262539295792, 0.7280636814887845, 0.7203972964247863, 0.6888976754292169, 0.6992924393249529, 0.6938502093579653, 0.8578762062038061, 0.8836313302564254, 0.8699748825079259, 0.8809898710796447, 0.8727004376322524, 0.8989927174263601, 0.8787271372953744, 0.7951697730295809, 0.8621600934569479, 0.12861512018828958, 0.6611720265992113, 0.5800596250663388, 0.2685811802835609, 0.5777109707231156, 0.5186167277814931, 0.7000093107114131, 0.710976705107656, 0.6620400567496458, 0.6823035883090878, 0.6696361829113344, 0.6261798768441218, 0.5844216609310808, 0.6381144679130523, 0.42161185600649365, 0.6758313923014843, 0.1262323780913417, 0.5098010512578499, 0.4286920310498181, 0.48805118670775693, 0.425576654322369, 0.6029110103067217, 0.28694574622930735, 0.4152592389400309, 0.4069474665076702, 0.4120514530218341, 0.44419535760603435, 0.661122795775277, 0.5483002350605397, 0.6293056775802961, 0.42887125693541184, 0.6395293719486403, 0.45687673986909205, 0.7646005010276716, 0.7029255531350846, 0.7179893530147177, 0.18029074111849164, 0.2957308371326355, 0.17083567439940073, 0.19435699059037959, 0.29459502055381603, 0.15378019700896617, 0.19790128381342587, 0.24887179477912602, 0.29525490925803566, 0.359025352572241, 0.3936311269217716, 0.3654223749196335, 0.35023462902662394, 0.3754514497426875, 0.4129025874544041, 0.35869869452121217, 0.31308989279862176, 0.4526392597533164, 0.7105134948269605, 0.7164644305089387, 0.8116356047267818, 0.7248755944144798, 0.5745644185179984, 0.8276347867001287, 0.6925019769340037, 0.7388022611470371, 0.6868041915551863, 0.13247506286945132, 0.1244319687874138, 0.10302623549869239, 0.10223168645004022, 0.09842825088064278, 0.09972399049977776, 0.11428249942573221, 0.08599751120685373, 0.08017712742104066, 0.17043121414511575, 0.14067064232233606, 0.1727208310728483, 0.1868523317286226, 0.7610379728109469, 0.1723421938595613, 0.3344869463872888, 0.16047322868341285, 0.2652780291712937, 0.47709191428407316, 0.551139202495502, 0.5776666666407821, 0.5127110128720004, 0.6098202428335417, 0.6575378119560286, 0.6331396625786849, 0.5453262382759511, 0.634106206486766, 0.3973397305655164, 0.33327653221655396, 0.32931149704114837, 0.4273860392087654, 0.41386243728154837, 0.4582653409979063, 0.26308425642842903, 0.40123365999851623, 0.44758314524427656, 0.19034086330786226, 0.2310733816666416, 0.18203372336269275, 0.2253993535990807, 0.2119916895974352, 0.1985762199015786, 0.18323681702479733, 0.18581247082260932, 0.18300515909694837, 0.5488774185432892, 0.18031549284431037, 0.5349302586087175, 0.6126493486657143, 0.6045243538687136, 0.6964947698121675, 0.210426364113661, 0.6301172500758386, 0.6993563085908812, 0.17179353502163397, 0.1477603756649416, 0.18668235938951727, 0.18507530007033468, 0.17664466913025278, 0.8525011351688441, 0.8446174742006775, 0.16443284941386305, 0.8850378671919152, 0.8759684773718894, 0.16809239305294776, 0.8787423422616358, 0.16423240593239863, 0.16282230354353555, 0.20688933676184718, 0.20911423561462528, 0.8352912094291937, 0.12433852578530424, 0.19288556739724072, 0.1738455562573865, 0.20011565717648094, 0.15668931603210567, 0.16934378164028507, 0.16583971353965465, 0.1541713266825524, 0.2275184983065729, 0.15161845059884194, 0.0870581787387158, 0.07420570431373563, 0.07841584358511355, 0.08658021317402886, 0.0764258368848807, 0.07873052909461553, 0.08067708880578117, 0.07801874472758552, 0.08456010083370835]}, "mutation_prompt": null}
{"id": "fe8703b1-7906-4f88-8c1f-4f2d4a50e8d4", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = 0.7 + 0.3 * np.random.rand() * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        # Modified perturbation size for adaptive scaling\n        perturbation_size = 0.05 + 0.05 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                # Increase local search frequency near best solution\n                if np.random.rand() < (1 - self.fitness[i] / self.fitness.min()):\n                    trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                # Elitist selection: preserve the best solution\n                best_idx = np.argmin(self.fitness)\n                if self.fitness[best_idx] < self.fitness[i]:\n                    self.population[i] = self.population[best_idx]\n                    self.fitness[i] = self.fitness[best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Introduce elitist selection to preserve the best solution across generations, enhancing convergence stability.", "configspace": "", "generation": 81, "fitness": 0.04427438631082591, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.05.", "error": "", "parent_id": "9777af56-07eb-41e8-a6b5-b73094fa5e8b", "metadata": {"aucs": [0.12263954382435693, 0.06432772651221763, 0.09169502728636048, 0.08952233024927114, 0.1476858977453196, 0.07709668639236078, 0.13092314105401492, 0.09087949637227499, 0.06711154613058024, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003550988566195845, 0.023608064518803595, 9.999999999998899e-05, 0.010643411704069683, 0.004133752515757427, 0.006669962766643223, 0.018248263482334326, 9.999999999998899e-05, 0.010674738340807233, 0.003819410485508934, 9.999999999998899e-05, 9.999999999998899e-05, 0.01959972157639278, 9.999999999998899e-05, 0.012506371266232219, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12498367236966623, 0.05903329818294112, 0.04287777107098589, 0.0683922498012387, 0.06043037295904219, 0.048624716978051374, 0.11032945188359977, 0.0789709866142535, 0.0392018832149682, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06743133685320624, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.016358594031092077, 9.999999999998899e-05, 0.10027683525177622, 0.08960114357143756, 0.006487473152022916, 0.004562218041036625, 0.02725496812965944, 9.999999999998899e-05, 0.08449959459393008, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12233872808760193, 0.11702059596298908, 0.17529382567203355, 0.1871797098082928, 0.09708865527373767, 0.13774238823442753, 0.1240568991094797, 0.1844940635554091, 0.1210557193025883, 9.999999999998899e-05, 0.010522725644175224, 0.0042440333995921176, 0.01036155840095887, 9.999999999998899e-05, 0.04258205284848937, 0.040582642614603315, 9.999999999998899e-05, 0.0267656688986897, 0.1064244301251498, 0.06735693451091307, 0.059328965068867756, 0.11569413108630322, 0.10852972522114013, 0.05643121168494414, 0.08808199726801991, 0.08637634199929267, 0.07726393575557644, 0.10658721551350103, 0.12608148725624013, 0.10359778603806002, 0.10847166301008526, 0.12639464375411757, 0.10881057447981024, 0.11420206329748472, 0.17377774300845283, 0.07784834048331069, 0.08124334319913273, 0.034008147686441226, 0.05045964993255769, 0.106545548556922, 0.06406947898089654, 0.046310246556478196, 0.07926004880093329, 0.09386031173166853, 0.060041416348675214, 0.12206399176972005, 0.09083876112181277, 0.13345086981233123, 0.11715449225728147, 0.07855245954393053, 0.08853961034790592, 0.12245976138762271, 0.1098168785510647, 0.1261963614278906, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07656591667811685, 0.07466602457976645, 0.11062019132220524, 0.07074464116685397, 0.1207914665021157, 0.06661401029160186, 0.07245568600050101, 0.09643604708838482, 0.0808532764887675, 0.1134710362084157, 0.06533509616680999, 0.03567734830263869, 0.0506857903344724, 0.03738259240699027, 0.045511073114331335, 0.05363964130522514, 0.02860841408687753, 0.06642687810436232, 0.13480174570059533, 0.13830320000453666, 0.14763022729669195, 0.15996975606160502, 0.12026004438589555, 0.13487708680066812, 0.12850576028924698, 0.12080981827198867, 0.14689007985489466, 0.011655389720939602, 0.01347814618054688, 0.031393493129599714, 0.027015293023570086, 0.023578593041280738, 0.00826091239954263, 0.011149453589241465, 9.999999999998899e-05, 0.01745630416284416]}, "mutation_prompt": null}
{"id": "47adf090-ab38-431a-b071-ab724b16ce51", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = 0.7 + 0.3 * np.random.rand() * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        # Modified perturbation size for adaptive scaling\n        perturbation_size = 0.05 + 0.05 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                # Increase local search frequency near best solution\n                if np.random.rand() < (1 - self.fitness[i] / self.fitness.min()):\n                    trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Introduce adaptive scaling for local search step size to enhance exploitation near convergence.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9777af56-07eb-41e8-a6b5-b73094fa5e8b", "metadata": {"aucs": [0.8635679096504482, 0.8651904840699595, 0.8706656124464578, 0.8810134389315147, 0.8685718654200112, 0.8856447563191137, 0.8684146222163904, 0.8756551246832438, 0.8679631748178588, 0.7532667375927997, 0.7443007533536237, 0.7569169131023736, 0.7347243411524695, 0.7679153024656786, 0.7545183773600026, 0.7368902332759621, 0.7166759231323901, 0.7738634979294521, 0.15221440172801903, 0.5504231285938777, 0.54815205534065, 0.6141208230766544, 0.5926557280439354, 0.17717242840235026, 0.48246124113651934, 0.15915506627740783, 0.48402756353441956, 0.13292692014921215, 0.1619629465969551, 0.11272842499955038, 0.1539150518159822, 0.15948608292752742, 0.1561365275238189, 0.12195309062208304, 0.14776975668919712, 0.14660357755904152, 0.8884242633665269, 0.8998429290768728, 0.9442128792419914, 0.9529502408428152, 0.9546236887962392, 0.9627372031533812, 0.8641095226866682, 0.8993408801477827, 0.9386599586607532, 0.7173611945447436, 0.6968346240610815, 0.6981789833798285, 0.7097262539295792, 0.7280636814887845, 0.7203972964247863, 0.6888976754292169, 0.6992924393249529, 0.6938502093579653, 0.8578762062038061, 0.8836313302564254, 0.8699748825079259, 0.8809898710796447, 0.8727004376322524, 0.8989927174263601, 0.8787271372953744, 0.7951697730295809, 0.8621600934569479, 0.12861512018828958, 0.6611720265992113, 0.5800596250663388, 0.2685811802835609, 0.5777109707231156, 0.5186167277814931, 0.7000093107114131, 0.710976705107656, 0.6620400567496458, 0.6823035883090878, 0.6696361829113344, 0.6261798768441218, 0.5844216609310808, 0.6381144679130523, 0.42161185600649365, 0.6758313923014843, 0.1262323780913417, 0.5098010512578499, 0.4286920310498181, 0.48805118670775693, 0.425576654322369, 0.6029110103067217, 0.28694574622930735, 0.4152592389400309, 0.4069474665076702, 0.4120514530218341, 0.44419535760603435, 0.661122795775277, 0.5483002350605397, 0.6293056775802961, 0.42887125693541184, 0.6395293719486403, 0.45687673986909205, 0.7646005010276716, 0.7029255531350846, 0.7179893530147177, 0.18029074111849164, 0.2957308371326355, 0.17083567439940073, 0.19435699059037959, 0.29459502055381603, 0.15378019700896617, 0.19790128381342587, 0.24887179477912602, 0.29525490925803566, 0.359025352572241, 0.3936311269217716, 0.3654223749196335, 0.35023462902662394, 0.3754514497426875, 0.4129025874544041, 0.35869869452121217, 0.31308989279862176, 0.4526392597533164, 0.7105134948269605, 0.7164644305089387, 0.8116356047267818, 0.7248755944144798, 0.5745644185179984, 0.8276347867001287, 0.6925019769340037, 0.7388022611470371, 0.6868041915551863, 0.13247506286945132, 0.1244319687874138, 0.10302623549869239, 0.10223168645004022, 0.09842825088064278, 0.09972399049977776, 0.11428249942573221, 0.08599751120685373, 0.08017712742104066, 0.17043121414511575, 0.14067064232233606, 0.1727208310728483, 0.1868523317286226, 0.7610379728109469, 0.1723421938595613, 0.3344869463872888, 0.16047322868341285, 0.2652780291712937, 0.47709191428407316, 0.551139202495502, 0.5776666666407821, 0.5127110128720004, 0.6098202428335417, 0.6575378119560286, 0.6331396625786849, 0.5453262382759511, 0.634106206486766, 0.3973397305655164, 0.33327653221655396, 0.32931149704114837, 0.4273860392087654, 0.41386243728154837, 0.4582653409979063, 0.26308425642842903, 0.40123365999851623, 0.44758314524427656, 0.19034086330786226, 0.2310733816666416, 0.18203372336269275, 0.2253993535990807, 0.2119916895974352, 0.1985762199015786, 0.18323681702479733, 0.18581247082260932, 0.18300515909694837, 0.5488774185432892, 0.18031549284431037, 0.5349302586087175, 0.6126493486657143, 0.6045243538687136, 0.6964947698121675, 0.210426364113661, 0.6301172500758386, 0.6993563085908812, 0.17179353502163397, 0.1477603756649416, 0.18668235938951727, 0.18507530007033468, 0.17664466913025278, 0.8525011351688441, 0.8446174742006775, 0.16443284941386305, 0.8850378671919152, 0.8759684773718894, 0.16809239305294776, 0.8787423422616358, 0.16423240593239863, 0.16282230354353555, 0.20688933676184718, 0.20911423561462528, 0.8352912094291937, 0.12433852578530424, 0.19288556739724072, 0.1738455562573865, 0.20011565717648094, 0.15668931603210567, 0.16934378164028507, 0.16583971353965465, 0.1541713266825524, 0.2275184983065729, 0.15161845059884194, 0.0870581787387158, 0.07420570431373563, 0.07841584358511355, 0.08658021317402886, 0.0764258368848807, 0.07873052909461553, 0.08067708880578117, 0.07801874472758552, 0.08456010083370835]}, "mutation_prompt": null}
{"id": "f15b071f-7ba2-4b11-b888-b9e9f7e7acbe", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = 0.7 + 0.3 * np.random.rand() * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        # Modified perturbation size for adaptive scaling\n        perturbation_size = 0.05 + 0.05 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                # Increase local search frequency near best solution\n                if np.random.rand() < (1 - self.fitness[i] / self.fitness.min()):\n                    trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Introduce adaptive scaling for local search step size to enhance exploitation near convergence.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9777af56-07eb-41e8-a6b5-b73094fa5e8b", "metadata": {"aucs": [0.8635679096504482, 0.8651904840699595, 0.8706656124464578, 0.8810134389315147, 0.8685718654200112, 0.8856447563191137, 0.8684146222163904, 0.8756551246832438, 0.8679631748178588, 0.7532667375927997, 0.7443007533536237, 0.7569169131023736, 0.7347243411524695, 0.7679153024656786, 0.7545183773600026, 0.7368902332759621, 0.7166759231323901, 0.7738634979294521, 0.15221440172801903, 0.5504231285938777, 0.54815205534065, 0.6141208230766544, 0.5926557280439354, 0.17717242840235026, 0.48246124113651934, 0.15915506627740783, 0.48402756353441956, 0.13292692014921215, 0.1619629465969551, 0.11272842499955038, 0.1539150518159822, 0.15948608292752742, 0.1561365275238189, 0.12195309062208304, 0.14776975668919712, 0.14660357755904152, 0.8884242633665269, 0.8998429290768728, 0.9442128792419914, 0.9529502408428152, 0.9546236887962392, 0.9627372031533812, 0.8641095226866682, 0.8993408801477827, 0.9386599586607532, 0.7173611945447436, 0.6968346240610815, 0.6981789833798285, 0.7097262539295792, 0.7280636814887845, 0.7203972964247863, 0.6888976754292169, 0.6992924393249529, 0.6938502093579653, 0.8578762062038061, 0.8836313302564254, 0.8699748825079259, 0.8809898710796447, 0.8727004376322524, 0.8989927174263601, 0.8787271372953744, 0.7951697730295809, 0.8621600934569479, 0.12861512018828958, 0.6611720265992113, 0.5800596250663388, 0.2685811802835609, 0.5777109707231156, 0.5186167277814931, 0.7000093107114131, 0.710976705107656, 0.6620400567496458, 0.6823035883090878, 0.6696361829113344, 0.6261798768441218, 0.5844216609310808, 0.6381144679130523, 0.42161185600649365, 0.6758313923014843, 0.1262323780913417, 0.5098010512578499, 0.4286920310498181, 0.48805118670775693, 0.425576654322369, 0.6029110103067217, 0.28694574622930735, 0.4152592389400309, 0.4069474665076702, 0.4120514530218341, 0.44419535760603435, 0.661122795775277, 0.5483002350605397, 0.6293056775802961, 0.42887125693541184, 0.6395293719486403, 0.45687673986909205, 0.7646005010276716, 0.7029255531350846, 0.7179893530147177, 0.18029074111849164, 0.2957308371326355, 0.17083567439940073, 0.19435699059037959, 0.29459502055381603, 0.15378019700896617, 0.19790128381342587, 0.24887179477912602, 0.29525490925803566, 0.359025352572241, 0.3936311269217716, 0.3654223749196335, 0.35023462902662394, 0.3754514497426875, 0.4129025874544041, 0.35869869452121217, 0.31308989279862176, 0.4526392597533164, 0.7105134948269605, 0.7164644305089387, 0.8116356047267818, 0.7248755944144798, 0.5745644185179984, 0.8276347867001287, 0.6925019769340037, 0.7388022611470371, 0.6868041915551863, 0.13247506286945132, 0.1244319687874138, 0.10302623549869239, 0.10223168645004022, 0.09842825088064278, 0.09972399049977776, 0.11428249942573221, 0.08599751120685373, 0.08017712742104066, 0.17043121414511575, 0.14067064232233606, 0.1727208310728483, 0.1868523317286226, 0.7610379728109469, 0.1723421938595613, 0.3344869463872888, 0.16047322868341285, 0.2652780291712937, 0.47709191428407316, 0.551139202495502, 0.5776666666407821, 0.5127110128720004, 0.6098202428335417, 0.6575378119560286, 0.6331396625786849, 0.5453262382759511, 0.634106206486766, 0.3973397305655164, 0.33327653221655396, 0.32931149704114837, 0.4273860392087654, 0.41386243728154837, 0.4582653409979063, 0.26308425642842903, 0.40123365999851623, 0.44758314524427656, 0.19034086330786226, 0.2310733816666416, 0.18203372336269275, 0.2253993535990807, 0.2119916895974352, 0.1985762199015786, 0.18323681702479733, 0.18581247082260932, 0.18300515909694837, 0.5488774185432892, 0.18031549284431037, 0.5349302586087175, 0.6126493486657143, 0.6045243538687136, 0.6964947698121675, 0.210426364113661, 0.6301172500758386, 0.6993563085908812, 0.17179353502163397, 0.1477603756649416, 0.18668235938951727, 0.18507530007033468, 0.17664466913025278, 0.8525011351688441, 0.8446174742006775, 0.16443284941386305, 0.8850378671919152, 0.8759684773718894, 0.16809239305294776, 0.8787423422616358, 0.16423240593239863, 0.16282230354353555, 0.20688933676184718, 0.20911423561462528, 0.8352912094291937, 0.12433852578530424, 0.19288556739724072, 0.1738455562573865, 0.20011565717648094, 0.15668931603210567, 0.16934378164028507, 0.16583971353965465, 0.1541713266825524, 0.2275184983065729, 0.15161845059884194, 0.0870581787387158, 0.07420570431373563, 0.07841584358511355, 0.08658021317402886, 0.0764258368848807, 0.07873052909461553, 0.08067708880578117, 0.07801874472758552, 0.08456010083370835]}, "mutation_prompt": null}
{"id": "1b468fe5-e2e8-4884-96c3-55927746783f", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = 0.7 + 0.3 * np.random.rand() * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        # Modified perturbation size for adaptive scaling\n        best_fitness = self.fitness.min()\n        avg_fitness = self.fitness.mean()\n        fitness_diff = np.abs(best_fitness - avg_fitness)\n        perturbation_size = 0.05 + 0.05 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / best_fitness) * (1 + 0.5 * fitness_diff)\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                # Increase local search frequency near best solution\n                if np.random.rand() < (1 - self.fitness[i] / self.fitness.min()):\n                    trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Enhance adaptive scaling using a condition based on the difference between the best and average fitness values.", "configspace": "", "generation": 84, "fitness": 0.4605015291297946, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.28.", "error": "", "parent_id": "9777af56-07eb-41e8-a6b5-b73094fa5e8b", "metadata": {"aucs": [0.8635679096504482, 0.8651904840699595, 0.8706656124464578, 0.8810134389315147, 0.8685718654200112, 0.8856447563191137, 0.8756764953628573, 0.8671008771062692, 0.8654280206262274, 0.7590704670837982, 0.7226061473007228, 0.7395653359687218, 0.7311375098220914, 0.7339632434973844, 0.7616015707226816, 0.7370632005714095, 0.7250568552468285, 0.7632169398950512, 0.15752540664537773, 0.12408162774795783, 0.5538601739259839, 0.6141208230766544, 0.5926557280439354, 0.17717242840235026, 0.48246124113651934, 0.15915506627740783, 0.48402756353441956, 0.1279883954766574, 0.11431951262708318, 0.4911691530817558, 0.1539150518159822, 0.15948608292752742, 0.1561365275238189, 0.12195309062208304, 0.14776975668919712, 0.14660357755904152, 0.9405151146389323, 0.9460898880908867, 0.898350748308118, 0.9529502408428152, 0.9546236887962392, 0.9627372031533812, 0.8641095226866682, 0.8993408801477827, 0.9386599586607532, 0.7173611945447436, 0.6968346240610815, 0.6981789833798285, 0.7097262539295792, 0.7280636814887845, 0.7203972964247863, 0.7109209331764821, 0.6889304082689534, 0.7237392282232635, 0.8578762062038061, 0.8836313302564254, 0.8699748825079259, 0.8809898710796447, 0.8727004376322524, 0.8989927174263601, 0.8787271372953744, 0.7951697730295809, 0.8621600934569479, 0.12861512018828958, 0.6611720265992113, 0.5800596250663388, 0.5983898809969885, 0.6020576325078472, 0.24979841005003933, 0.7000093107114131, 0.710976705107656, 0.6620400567496458, 0.6823035883090878, 0.6696361829113344, 0.6261798768441218, 0.5844216609310808, 0.6381144679130523, 0.42161185600649365, 0.6758313923014843, 0.1262323780913417, 0.5098010512578499, 0.3833158568116958, 0.17162959429775293, 0.3161425912329251, 0.6029110103067217, 0.28694574622930735, 0.4152592389400309, 0.4316258808433596, 0.3287345950943277, 0.4893789271377157, 0.661122795775277, 0.5483002350605397, 0.6293056775802961, 0.5678621364385529, 0.5836340891041121, 0.3248377814887763, 0.7646005010276716, 0.7029255531350846, 0.7179893530147177, 0.12436008742857774, 0.20486267534721914, 0.1038697540512945, 0.330085755123836, 0.2272338878377821, 0.26747051685635104, 0.19790128381342587, 0.24887179477912602, 0.29525490925803566, 0.359025352572241, 0.3936311269217716, 0.3654223749196335, 0.36852756899561523, 0.39945245697586873, 0.31237931161486654, 0.05382152031837795, 0.3353138481906981, 0.3393850752241353, 0.7208611828138818, 0.701000434598549, 0.6478291942330343, 0.7238288360709407, 0.6964872240536251, 0.7183967983322587, 0.6925019769340037, 0.7388022611470371, 0.6868041915551863, 0.13247506286945132, 0.1244319687874138, 0.10302623549869239, 0.10223168645004022, 0.09842825088064278, 0.09972399049977776, 0.1135313204006606, 0.3982875543402222, 0.1537891357313398, 0.17043121414511575, 0.14067064232233606, 0.1727208310728483, 0.14623651302766594, 0.17519771259805694, 0.2924758397701943, 0.3344869463872888, 0.16047322868341285, 0.2652780291712937, 0.4647826668296169, 0.4991290804473548, 0.48350594598766705, 0.5127110128720004, 0.6098202428335417, 0.6575378119560286, 0.6331396625786849, 0.5453262382759511, 0.634106206486766, 0.25281760995778535, 0.4019791189231817, 0.36356000683954803, 0.4273860392087654, 0.41386243728154837, 0.4582653409979063, 0.26308425642842903, 0.40123365999851623, 0.44758314524427656, 0.19981159030723472, 0.18774405532663074, 0.18412930626039492, 0.2253993535990807, 0.2119916895974352, 0.1985762199015786, 0.18323681702479733, 0.18581247082260932, 0.18300515909694837, 0.6278862480785854, 0.5841571496758267, 0.609866048035597, 0.6126493486657143, 0.6045243538687136, 0.6964947698121675, 0.210426364113661, 0.6301172500758386, 0.6993563085908812, 0.17179353502163397, 0.1477603756649416, 0.18668235938951727, 0.18512706270674073, 0.17664466913025278, 0.8379028052364766, 0.8426157577426406, 0.7898006426905653, 0.17990492609728403, 0.8963775157677438, 0.20823478557538633, 0.827330995971739, 0.16423240593239863, 0.16282230354353555, 0.20688933676184718, 0.1277852862601403, 0.20540888252616218, 0.14829194108952193, 0.19288556739724072, 0.1738455562573865, 0.20011565717648094, 0.15668931603210567, 0.16934378164028507, 0.16583971353965465, 0.1728686757491119, 0.17121454758784438, 0.14689007985489466, 0.0870581787387158, 0.07420570431373563, 0.07841584358511355, 0.08658021317402886, 0.0764258368848807, 0.07873052909461553, 0.08067708880578117, 0.07801874472758552, 0.08456010083370835]}, "mutation_prompt": null}
{"id": "abfc3811-04ee-4d79-831f-857d7ecde2f6", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = 0.7 + 0.3 * np.random.rand() * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        # Modified perturbation size for adaptive scaling\n        perturbation_size = 0.05 + 0.05 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            # Adjust population size adaptively\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                # Increase local search frequency near best solution\n                if np.random.rand() < (1 - self.fitness[i] / self.fitness.min()):\n                    trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Introduce adaptive scaling for local search step size to enhance exploitation near convergence.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9777af56-07eb-41e8-a6b5-b73094fa5e8b", "metadata": {"aucs": [0.8635679096504482, 0.8651904840699595, 0.8706656124464578, 0.8810134389315147, 0.8685718654200112, 0.8856447563191137, 0.8684146222163904, 0.8756551246832438, 0.8679631748178588, 0.7532667375927997, 0.7443007533536237, 0.7569169131023736, 0.7347243411524695, 0.7679153024656786, 0.7545183773600026, 0.7368902332759621, 0.7166759231323901, 0.7738634979294521, 0.15221440172801903, 0.5504231285938777, 0.54815205534065, 0.6141208230766544, 0.5926557280439354, 0.17717242840235026, 0.48246124113651934, 0.15915506627740783, 0.48402756353441956, 0.13292692014921215, 0.1619629465969551, 0.11272842499955038, 0.1539150518159822, 0.15948608292752742, 0.1561365275238189, 0.12195309062208304, 0.14776975668919712, 0.14660357755904152, 0.8884242633665269, 0.8998429290768728, 0.9442128792419914, 0.9529502408428152, 0.9546236887962392, 0.9627372031533812, 0.8641095226866682, 0.8993408801477827, 0.9386599586607532, 0.7173611945447436, 0.6968346240610815, 0.6981789833798285, 0.7097262539295792, 0.7280636814887845, 0.7203972964247863, 0.6888976754292169, 0.6992924393249529, 0.6938502093579653, 0.8578762062038061, 0.8836313302564254, 0.8699748825079259, 0.8809898710796447, 0.8727004376322524, 0.8989927174263601, 0.8787271372953744, 0.7951697730295809, 0.8621600934569479, 0.12861512018828958, 0.6611720265992113, 0.5800596250663388, 0.2685811802835609, 0.5777109707231156, 0.5186167277814931, 0.7000093107114131, 0.710976705107656, 0.6620400567496458, 0.6823035883090878, 0.6696361829113344, 0.6261798768441218, 0.5844216609310808, 0.6381144679130523, 0.42161185600649365, 0.6758313923014843, 0.1262323780913417, 0.5098010512578499, 0.4286920310498181, 0.48805118670775693, 0.425576654322369, 0.6029110103067217, 0.28694574622930735, 0.4152592389400309, 0.4069474665076702, 0.4120514530218341, 0.44419535760603435, 0.661122795775277, 0.5483002350605397, 0.6293056775802961, 0.42887125693541184, 0.6395293719486403, 0.45687673986909205, 0.7646005010276716, 0.7029255531350846, 0.7179893530147177, 0.18029074111849164, 0.2957308371326355, 0.17083567439940073, 0.19435699059037959, 0.29459502055381603, 0.15378019700896617, 0.19790128381342587, 0.24887179477912602, 0.29525490925803566, 0.359025352572241, 0.3936311269217716, 0.3654223749196335, 0.35023462902662394, 0.3754514497426875, 0.4129025874544041, 0.35869869452121217, 0.31308989279862176, 0.4526392597533164, 0.7105134948269605, 0.7164644305089387, 0.8116356047267818, 0.7248755944144798, 0.5745644185179984, 0.8276347867001287, 0.6925019769340037, 0.7388022611470371, 0.6868041915551863, 0.13247506286945132, 0.1244319687874138, 0.10302623549869239, 0.10223168645004022, 0.09842825088064278, 0.09972399049977776, 0.11428249942573221, 0.08599751120685373, 0.08017712742104066, 0.17043121414511575, 0.14067064232233606, 0.1727208310728483, 0.1868523317286226, 0.7610379728109469, 0.1723421938595613, 0.3344869463872888, 0.16047322868341285, 0.2652780291712937, 0.47709191428407316, 0.551139202495502, 0.5776666666407821, 0.5127110128720004, 0.6098202428335417, 0.6575378119560286, 0.6331396625786849, 0.5453262382759511, 0.634106206486766, 0.3973397305655164, 0.33327653221655396, 0.32931149704114837, 0.4273860392087654, 0.41386243728154837, 0.4582653409979063, 0.26308425642842903, 0.40123365999851623, 0.44758314524427656, 0.19034086330786226, 0.2310733816666416, 0.18203372336269275, 0.2253993535990807, 0.2119916895974352, 0.1985762199015786, 0.18323681702479733, 0.18581247082260932, 0.18300515909694837, 0.5488774185432892, 0.18031549284431037, 0.5349302586087175, 0.6126493486657143, 0.6045243538687136, 0.6964947698121675, 0.210426364113661, 0.6301172500758386, 0.6993563085908812, 0.17179353502163397, 0.1477603756649416, 0.18668235938951727, 0.18507530007033468, 0.17664466913025278, 0.8525011351688441, 0.8446174742006775, 0.16443284941386305, 0.8850378671919152, 0.8759684773718894, 0.16809239305294776, 0.8787423422616358, 0.16423240593239863, 0.16282230354353555, 0.20688933676184718, 0.20911423561462528, 0.8352912094291937, 0.12433852578530424, 0.19288556739724072, 0.1738455562573865, 0.20011565717648094, 0.15668931603210567, 0.16934378164028507, 0.16583971353965465, 0.1541713266825524, 0.2275184983065729, 0.15161845059884194, 0.0870581787387158, 0.07420570431373563, 0.07841584358511355, 0.08658021317402886, 0.0764258368848807, 0.07873052909461553, 0.08067708880578117, 0.07801874472758552, 0.08456010083370835]}, "mutation_prompt": null}
{"id": "b1b65c21-1ec5-4fec-a6e7-ee77991066e0", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n        self.stagnation_counter = 0  # Stagnation counter for early stopping\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = 0.7 + 0.3 * np.random.rand() * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.05 + 0.05 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min())\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n        prev_best = np.min(self.fitness)\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                if np.random.rand() < (1 - self.fitness[i] / self.fitness.min()):\n                    trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                # Early stopping condition\n                if trial_fitness < prev_best:\n                    prev_best = trial_fitness\n                    self.stagnation_counter = 0\n                else:\n                    self.stagnation_counter += 1\n                if self.stagnation_counter > 100:  # Threshold for stagnation\n                    return self.population[np.argmin(self.fitness)], np.min(self.fitness)\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Incorporate an early stopping mechanism based on fitness stagnation to enhance convergence efficiency.", "configspace": "", "generation": 86, "fitness": 0.09822464764348306, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.14.", "error": "", "parent_id": "9777af56-07eb-41e8-a6b5-b73094fa5e8b", "metadata": {"aucs": [0.1678434334729746, 0.09995791637427776, 0.0916041897440597, 0.1701038495328201, 0.22540581521638858, 0.2041807563564948, 0.21999335862209535, 0.14922882071662757, 0.13319227259664312, 0.28034918852023527, 0.0, 0.0, 0.0, 0.0, 0.03670942306604286, 0.0, 0.0, 0.0, 0.020954458044081692, 0.014572254733962287, 0.03376409510126832, 0.03131428903316624, 0.06961483738897856, 0.06679407408765059, 0.018150078853237717, 0.06144831463335099, 0.03465846798378769, 0.021374349942787974, 0.013532559947371015, 0.028874961143621092, 0.019501673109847073, 0.030486116162391608, 0.00948836935583508, 0.013141820482790001, 0.02041341642163952, 0.023131051839889394, 0.06795720136804684, 0.8998429290768728, 0.9442128792419914, 0.9529502408428152, 0.09527491665720333, 0.9627372031533812, 0.06379241875032005, 0.8993408801477827, 0.08894875046407491, 0.0703487113291893, 0.055658721564253555, 0.05261048708456273, 0.05715762885522202, 0.03773921686396042, 0.0, 0.044651597595182446, 0.05004140956296865, 0.03427148605354391, 0.10018685869141841, 0.21824402106129093, 0.16861155515086612, 0.14388174484854754, 0.17113229131348728, 0.14560273387078526, 0.06353498871950125, 0.17377084386282882, 0.1509069942455189, 0.022976427701321356, 0.0, 0.02731642659394473, 0.0, 0.0, 0.032424479267246675, 0.07737588985197397, 0.016063310526967856, 0.09889805090614068, 0.0, 0.0, 0.011621537910114776, 0.0, 0.0, 0.05499915260742816, 0.08235922573748178, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.06475353557419261, 0.0, 0.10278721287248993, 0.0, 0.0071282561002872225, 0.014981465375014213, 0.05340046807468812, 0.05985731735625799, 0.020046263302536116, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.05104855067514924, 0.0, 0.07078589495407195, 0.05945220850373367, 0.0, 0.0, 0.0, 0.08002000397464604, 0.21559440634240445, 0.17128683581217807, 0.14829537673711235, 0.17973348547258228, 0.15460998398838033, 0.18509634362070393, 0.21185862842527337, 0.24670888016783854, 0.18094716939951816, 0.0399008387019707, 0.04255648280157076, 0.05642808966566937, 0.006002370323321182, 0.03502088769385592, 0.01926646562407386, 0.019794410303402565, 0.03108027595643159, 0.06727355471286389, 0.10633507464079572, 0.07324826922082961, 0.08055455521373112, 0.10805517753030125, 0.10844057434014054, 0.08420123655825373, 0.12112925549180986, 0.07462676447133709, 0.07717165476235766, 0.16352404712797775, 0.1883177166746679, 0.17249430994288417, 0.1726743692227799, 0.12290748603807078, 0.14065237691947974, 0.14826340712130714, 0.18062294082428965, 0.18201572962710988, 0.0744672559486389, 0.07997419482085766, 0.10635057451422869, 0.10645620834926106, 0.10994860108047433, 0.04621487005142011, 0.10964982702822168, 0.09376969834432347, 0.07254034131573572, 0.10797560176630938, 0.2309966670246637, 0.13336421106438578, 0.14166565567272815, 0.09643208174245976, 0.16218135912508647, 0.12237199858757519, 0.11790175622513999, 0.12610897469223914, 0.0, 0.07743217801959013, 0.15215623884859852, 0.15085805918501394, 0.14682023807890565, 0.11505992006623544, 0.1461386497056777, 0.16288203247861222, 0.15824538198282878, 0.1261171985550733, 0.10328328259971653, 0.16655730067918562, 0.1079206982478107, 0.1207035396655618, 0.185465497980963, 0.08176490239448542, 0.0963456876397184, 0.10706686442355262, 0.1071339416051571, 0.07663773324521517, 0.1754985652725387, 0.05508963806694611, 0.10390398370312559, 0.07808223421957428, 0.2072036159388959, 0.09075197873554275, 0.09146083263530669, 0.13624511990233656, 0.1693999043085953, 0.1528655670443433, 0.14618635000082925, 0.15655144902522466, 0.16575631679614, 0.14887557577745758, 0.14522265981805027, 0.14680476350940774, 0.03818261725573502, 0.013379484918498052, 0.03129662407793532, 0.02691798931623457, 0.03202066604184617, 0.027612418068577838, 0.018976932298680693, 0.03178820692562745, 0.05131314237634854]}, "mutation_prompt": null}
{"id": "d8423a67-cbfa-4f4e-9963-656f1880acba", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = 0.7 + 0.3 * np.random.rand() * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        diversity = np.std(self.population, axis=0).mean()  # Calculate population diversity\n        perturbation_size = 0.05 + 0.05 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / self.fitness.min()) * (1 + diversity)\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                if np.random.rand() < (1 - self.fitness[i] / self.fitness.min()):\n                    trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Refine adaptive scaling by introducing a dynamic adjustment to the local search perturbation size based on diversity in the population.", "configspace": "", "generation": 87, "fitness": 0.4676152604991681, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.28.", "error": "", "parent_id": "9777af56-07eb-41e8-a6b5-b73094fa5e8b", "metadata": {"aucs": [0.8635679096504482, 0.8651904840699595, 0.8706656124464578, 0.8810134389315147, 0.8685718654200112, 0.8856447563191137, 0.8620628108219205, 0.8767807940968021, 0.8722197374896216, 0.7285186410598384, 0.7321888986336944, 0.724912507157405, 0.7387184035300882, 0.7540037202827888, 0.7630913290133698, 0.7480338936819506, 0.7364418725198806, 0.7619264336057149, 0.5470927520528086, 0.472099760019115, 0.48326341317841526, 0.6141208230766544, 0.5926557280439354, 0.17717242840235026, 0.48246124113651934, 0.15915506627740783, 0.48402756353441956, 0.14749300416923106, 0.13804487306589075, 0.15489075773452643, 0.1539150518159822, 0.15948608292752742, 0.1561365275238189, 0.12195309062208304, 0.14776975668919712, 0.14660357755904152, 0.9228009756981281, 0.9337051271841457, 0.9187385469024316, 0.9529502408428152, 0.9546236887962392, 0.9627372031533812, 0.8641095226866682, 0.8993408801477827, 0.9386599586607532, 0.7173611945447436, 0.6968346240610815, 0.6981789833798285, 0.7097262539295792, 0.7280636814887845, 0.7203972964247863, 0.7056196496644147, 0.6961752707486082, 0.7206113328847558, 0.8578762062038061, 0.8836313302564254, 0.8699748825079259, 0.8809898710796447, 0.8727004376322524, 0.8989927174263601, 0.8787271372953744, 0.7951697730295809, 0.8621600934569479, 0.12861512018828958, 0.6611720265992113, 0.5800596250663388, 0.5970218001785451, 0.6030778417251658, 0.47535188078043944, 0.7000093107114131, 0.710976705107656, 0.6620400567496458, 0.6823035883090878, 0.6696361829113344, 0.6261798768441218, 0.5844216609310808, 0.6381144679130523, 0.42161185600649365, 0.6758313923014843, 0.1262323780913417, 0.5098010512578499, 0.3428491002001739, 0.45214694165235847, 0.3748370617738923, 0.6029110103067217, 0.28694574622930735, 0.4152592389400309, 0.5754034199085128, 0.46939111230357744, 0.5455011692662555, 0.661122795775277, 0.5483002350605397, 0.6293056775802961, 0.40981186648114376, 0.3344307991093176, 0.5028752699847732, 0.7646005010276716, 0.7029255531350846, 0.7179893530147177, 0.17562887527408944, 0.23084496868906246, 0.13793435153812938, 0.3586523250817608, 0.3104816683209608, 0.15681030525001738, 0.19790128381342587, 0.24887179477912602, 0.29525490925803566, 0.359025352572241, 0.3936311269217716, 0.3654223749196335, 0.38670409844216425, 0.3919576493603988, 0.38166008792389694, 0.3036849301825759, 0.28630696445793746, 0.36093332737259576, 0.8102362745777993, 0.8083572851799786, 0.65895458289684, 0.826046346655268, 0.5972094704988109, 0.7329099846078126, 0.6925019769340037, 0.7388022611470371, 0.6868041915551863, 0.13247506286945132, 0.1244319687874138, 0.10302623549869239, 0.10223168645004022, 0.09842825088064278, 0.09972399049977776, 0.09625478987405711, 0.1244664599795573, 0.10606338573424001, 0.17043121414511575, 0.14067064232233606, 0.1727208310728483, 0.18639631778699606, 0.1919013941061457, 0.1569927415906901, 0.3344869463872888, 0.16047322868341285, 0.2652780291712937, 0.47650908929358804, 0.517087340236691, 0.5347250523132447, 0.5127110128720004, 0.6098202428335417, 0.6575378119560286, 0.6331396625786849, 0.5453262382759511, 0.634106206486766, 0.4211108308048507, 0.4137232833480222, 0.3694585727339955, 0.4273860392087654, 0.41386243728154837, 0.4582653409979063, 0.26308425642842903, 0.40123365999851623, 0.44758314524427656, 0.22162127360195738, 0.2319635378712872, 0.22328276103181788, 0.2253993535990807, 0.2119916895974352, 0.1985762199015786, 0.18323681702479733, 0.18581247082260932, 0.18300515909694837, 0.22142392056863536, 0.664211717275192, 0.2311198791538317, 0.6126493486657143, 0.6045243538687136, 0.6964947698121675, 0.210426364113661, 0.6301172500758386, 0.6993563085908812, 0.17179353502163397, 0.1477603756649416, 0.18668235938951727, 0.1850466678966185, 0.17664466913025278, 0.8390639525900268, 0.8532123994747896, 0.844804468694268, 0.8116001502555492, 0.8491946184527276, 0.20865062464874662, 0.886140994760327, 0.16423240593239863, 0.16282230354353555, 0.20688933676184718, 0.12643810754178508, 0.12604510796264767, 0.12573550377943687, 0.19288556739724072, 0.1738455562573865, 0.20011565717648094, 0.15668931603210567, 0.16934378164028507, 0.16583971353965465, 0.1612857486257444, 0.19929998741703991, 0.15448059639068068, 0.0870581787387158, 0.07420570431373563, 0.07841584358511355, 0.08658021317402886, 0.0764258368848807, 0.07873052909461553, 0.08067708880578117, 0.07801874472758552, 0.08456010083370835]}, "mutation_prompt": null}
{"id": "6b3ed482-f83e-4d45-b944-1833b6a62736", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = 0.7 + 0.3 * np.random.rand() * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        # Enhanced adaptive scaling for local search\n        perturbation_size = 0.05 + 0.05 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / (self.fitness.min() + 1e-8))\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                if np.random.rand() < (1 - self.fitness[i] / self.fitness.min()):\n                    trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Enhance local search by dynamically adjusting perturbation size based on both iteration progress and fitness improvement.", "configspace": "", "generation": 88, "fitness": 0.46880475464339155, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.28.", "error": "", "parent_id": "9777af56-07eb-41e8-a6b5-b73094fa5e8b", "metadata": {"aucs": [0.8635679096504482, 0.8651904840699595, 0.8706656124464578, 0.8810134389315147, 0.8685718654200112, 0.8856447563191137, 0.8684144790314466, 0.8756551607463962, 0.8679631559885149, 0.7549504316548021, 0.7445712873910519, 0.7569208214039143, 0.7343731311502447, 0.7679160440598259, 0.755245659266178, 0.736544124521587, 0.715659176144491, 0.7701104596801012, 0.152214401727366, 0.5504235612074206, 0.5481520543409505, 0.6141208230766544, 0.5926557280439354, 0.17717242840235026, 0.48246124113651934, 0.15915506627740783, 0.48402756353441956, 0.13292692014867513, 0.16196294661575372, 0.11272842500012525, 0.1539150518159822, 0.15948608292752742, 0.1561365275238189, 0.12195309062208304, 0.14776975668919712, 0.14660357755904152, 0.8884242621639741, 0.8998429290899013, 0.9442128792375855, 0.9529502408428152, 0.9546236887962392, 0.9627372031533812, 0.8641095226866682, 0.8993408801477827, 0.9386599586607532, 0.7173611945447436, 0.6968346240610815, 0.6981789833798285, 0.7097262539295792, 0.7280636814887845, 0.7203972964247863, 0.6913636255572715, 0.6996151489028244, 0.6911285284092249, 0.8578762062038061, 0.8836313302564254, 0.8699748825079259, 0.8809898710796447, 0.8727004376322524, 0.8989927174263601, 0.8787271372953744, 0.7951697730295809, 0.8621600934569479, 0.12861512018828958, 0.6611720265992113, 0.5800596250663388, 0.3532204032505184, 0.5757896549694836, 0.5033171986973737, 0.7000093107114131, 0.710976705107656, 0.6620400567496458, 0.6823035883090878, 0.6696361829113344, 0.6261798768441218, 0.5844216609310808, 0.6381144679130523, 0.42161185600649365, 0.6758313923014843, 0.1262323780913417, 0.5098010512578499, 0.42869181427148906, 0.4880511860054273, 0.4255766570048566, 0.6029110103067217, 0.28694574622930735, 0.4152592389400309, 0.4069474671717388, 0.41205145386985975, 0.4441953575939108, 0.661122795775277, 0.5483002350605397, 0.6293056775802961, 0.4288710821030911, 0.639529370173085, 0.45687675069099287, 0.7646005010276716, 0.7029255531350846, 0.7179893530147177, 0.18029074112644305, 0.29573083711649695, 0.17083567326780247, 0.19435698699755843, 0.2945950194234406, 0.1537801970121787, 0.19790128381342587, 0.24887179477912602, 0.29525490925803566, 0.359025352572241, 0.3936311269217716, 0.3654223749196335, 0.3495781444326378, 0.3754487791926393, 0.4123603090885748, 0.3582757083698611, 0.3130898552376722, 0.4559066594684952, 0.7170140606437363, 0.7163568548345361, 0.8113287350129155, 0.7248752993003355, 0.5745662436122012, 0.8268683334509778, 0.6925019769340037, 0.7388022611470371, 0.6868041915551863, 0.13247506286945132, 0.1244319687874138, 0.10302623549869239, 0.10223168645004022, 0.09842825088064278, 0.09972399049977776, 0.1142825003803648, 0.0859975110677833, 0.08017720199076817, 0.17043121414511575, 0.14067064232233606, 0.1727208310728483, 0.18685233173586768, 0.7610379586725853, 0.17234219369321235, 0.3344869463872888, 0.16047322868341285, 0.2652780291712937, 0.47665657631884695, 0.5749743921977077, 0.5788223642093239, 0.5127110128720004, 0.6098202428335417, 0.6575378119560286, 0.6331396625786849, 0.5453262382759511, 0.634106206486766, 0.3528121254517069, 0.306632878602761, 0.32931343166456395, 0.4273860392087654, 0.41386243728154837, 0.4582653409979063, 0.26308425642842903, 0.40123365999851623, 0.44758314524427656, 0.1903408630892487, 0.2310733816666416, 0.18203372394552797, 0.2253993535990807, 0.2119916895974352, 0.1985762199015786, 0.18323681702479733, 0.18581247082260932, 0.18300515909694837, 0.5488774324416037, 0.18031549283944226, 0.5349302590259252, 0.6126493486657143, 0.6045243538687136, 0.6964947698121675, 0.210426364113661, 0.6301172500758386, 0.6993563085908812, 0.17179353502163397, 0.1477603756649416, 0.18668235938951727, 0.185075300069811, 0.17664466913025278, 0.8525002596668572, 0.8446174744214268, 0.16443284941386194, 0.8850378671907997, 0.8759684773718894, 0.16809239305294776, 0.8787423422647999, 0.16423240593239863, 0.16282230354353555, 0.20688933676184718, 0.20911423561625775, 0.8352912095976266, 0.12433852575744753, 0.19288556739724072, 0.1738455562573865, 0.20011565717648094, 0.15668931603210567, 0.16934378164028507, 0.16583971353965465, 0.1541713266825524, 0.22751849828833004, 0.15161845059881252, 0.0870581787387158, 0.07420570431373563, 0.07841584358511355, 0.08658021317402886, 0.0764258368848807, 0.07873052909461553, 0.08067708880578117, 0.07801874472758552, 0.08456010083370835]}, "mutation_prompt": null}
{"id": "4e2bfbf0-beee-402b-94d7-3d52f50306c6", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = 0.7 + 0.3 * np.random.rand() * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        stochastic_component = np.random.rand() * 0.05  # Stochastic component for perturbation scaling\n        perturbation_size = 0.05 + stochastic_component + 0.05 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / (self.fitness.min() + 1e-8))\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                if np.random.rand() < (1 - self.fitness[i] / self.fitness.min()):\n                    trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Enhance local search by incorporating a stochastic component in perturbation scaling for more diverse exploration.", "configspace": "", "generation": 89, "fitness": 0.46297314579866966, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.28.", "error": "", "parent_id": "6b3ed482-f83e-4d45-b944-1833b6a62736", "metadata": {"aucs": [0.8635679096504482, 0.8651904840699595, 0.8706656124464578, 0.8810134389315147, 0.8685718654200112, 0.8856447563191137, 0.8671092425140332, 0.8727239211227843, 0.8649523035408854, 0.7485856492854235, 0.7428432645310358, 0.74484077764352, 0.7437985244294969, 0.7340710482183921, 0.7852698860324684, 0.7547675038941287, 0.7470544680640725, 0.7303589973275331, 0.15555128657225237, 0.4816126666164703, 0.5254024674094172, 0.6141208230766544, 0.5926557280439354, 0.17717242840235026, 0.48246124113651934, 0.15915506627740783, 0.48402756353441956, 0.43190847902198826, 0.13936040700738017, 0.12551612960128, 0.1539150518159822, 0.15948608292752742, 0.1561365275238189, 0.12195309062208304, 0.14776975668919712, 0.14660357755904152, 0.8954747738240827, 0.9425125332610867, 0.9189067231790132, 0.9529502408428152, 0.9546236887962392, 0.9627372031533812, 0.8641095226866682, 0.8993408801477827, 0.9386599586607532, 0.7173611945447436, 0.6968346240610815, 0.6981789833798285, 0.7097262539295792, 0.7280636814887845, 0.7203972964247863, 0.695224294443427, 0.7313550301177649, 0.6913551448718362, 0.8578762062038061, 0.8836313302564254, 0.8699748825079259, 0.8809898710796447, 0.8727004376322524, 0.8989927174263601, 0.8787271372953744, 0.7951697730295809, 0.8621600934569479, 0.12861512018828958, 0.6611720265992113, 0.5800596250663388, 0.5740188322287048, 0.6826740263412774, 0.48672954391555223, 0.7000093107114131, 0.710976705107656, 0.6620400567496458, 0.6823035883090878, 0.6696361829113344, 0.6261798768441218, 0.5844216609310808, 0.6381144679130523, 0.42161185600649365, 0.6758313923014843, 0.1262323780913417, 0.5098010512578499, 0.5187609283035937, 0.3828785590550319, 0.3104085523272977, 0.6029110103067217, 0.28694574622930735, 0.4152592389400309, 0.227372922440223, 0.565306085995069, 0.37516894669790846, 0.661122795775277, 0.5483002350605397, 0.6293056775802961, 0.592960282703269, 0.5683110721497664, 0.5543557552078917, 0.7646005010276716, 0.7029255531350846, 0.7179893530147177, 0.16734665566072238, 0.3286677991871173, 0.14815915870138285, 0.3729032520972033, 0.19637544708883226, 0.21681257570044932, 0.19790128381342587, 0.24887179477912602, 0.29525490925803566, 0.359025352572241, 0.3936311269217716, 0.3654223749196335, 0.3509672851677337, 0.3788077350705322, 0.3631503217245666, 0.3437809197923488, 0.3859863690028207, 0.3251082746937569, 0.8123148461098559, 0.7333064581671251, 0.7172145655838772, 0.7551455515507787, 0.6868635525865572, 0.8200849267738144, 0.6925019769340037, 0.7388022611470371, 0.6868041915551863, 0.13247506286945132, 0.1244319687874138, 0.10302623549869239, 0.10223168645004022, 0.09842825088064278, 0.09972399049977776, 0.10363772548168615, 0.08346768091497148, 0.11674081512194734, 0.17043121414511575, 0.14067064232233606, 0.1727208310728483, 0.29873684886829543, 0.21392109869233966, 0.13831044356179667, 0.3344869463872888, 0.16047322868341285, 0.2652780291712937, 0.43339549583224457, 0.5235891886019381, 0.6300045490361503, 0.5127110128720004, 0.6098202428335417, 0.6575378119560286, 0.6331396625786849, 0.5453262382759511, 0.634106206486766, 0.3742329255300473, 0.3045953451524446, 0.34506022024295935, 0.4273860392087654, 0.41386243728154837, 0.4582653409979063, 0.26308425642842903, 0.40123365999851623, 0.44758314524427656, 0.20485479663965578, 0.18627304691663238, 0.20881592390492298, 0.2253993535990807, 0.2119916895974352, 0.1985762199015786, 0.18323681702479733, 0.18581247082260932, 0.18300515909694837, 0.2173408292261202, 0.1918077168473239, 0.6801379408871706, 0.6126493486657143, 0.6045243538687136, 0.6964947698121675, 0.210426364113661, 0.6301172500758386, 0.6993563085908812, 0.17179353502163397, 0.1477603756649416, 0.18668235938951727, 0.18498586147447582, 0.17664466913025278, 0.8631668533711138, 0.8536107366644778, 0.16854934115116216, 0.16761637997231538, 0.8529635409929149, 0.20649016362430728, 0.8529063361509864, 0.16423240593239863, 0.16282230354353555, 0.20688933676184718, 0.20412006851964037, 0.1598164080385921, 0.19912405121137944, 0.19288556739724072, 0.1738455562573865, 0.20011565717648094, 0.15668931603210567, 0.16934378164028507, 0.16583971353965465, 0.16833491429770198, 0.1650600784568902, 0.1798967154178961, 0.0870581787387158, 0.07420570431373563, 0.07841584358511355, 0.08658021317402886, 0.0764258368848807, 0.07873052909461553, 0.08067708880578117, 0.07801874472758552, 0.08456010083370835]}, "mutation_prompt": null}
{"id": "62497532-c7c4-4fd5-8cbe-cf8c1413c53c", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = 0.7 + 0.3 * np.random.rand() * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        # Enhanced adaptive scaling for local search\n        perturbation_size = 0.05 + 0.05 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / (self.fitness.min() + 1e-8))\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                if np.random.rand() < (1 - self.fitness[i] / self.fitness.min()):\n                    trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Enhance local search by dynamically adjusting perturbation size based on both iteration progress and fitness improvement.", "configspace": "", "generation": 89, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6b3ed482-f83e-4d45-b944-1833b6a62736", "metadata": {"aucs": [0.8635679096504482, 0.8651904840699595, 0.8706656124464578, 0.8810134389315147, 0.8685718654200112, 0.8856447563191137, 0.8684144790314466, 0.8756551607463962, 0.8679631559885149, 0.7549504316548021, 0.7445712873910519, 0.7569208214039143, 0.7343731311502447, 0.7679160440598259, 0.755245659266178, 0.736544124521587, 0.715659176144491, 0.7701104596801012, 0.152214401727366, 0.5504235612074206, 0.5481520543409505, 0.6141208230766544, 0.5926557280439354, 0.17717242840235026, 0.48246124113651934, 0.15915506627740783, 0.48402756353441956, 0.13292692014867513, 0.16196294661575372, 0.11272842500012525, 0.1539150518159822, 0.15948608292752742, 0.1561365275238189, 0.12195309062208304, 0.14776975668919712, 0.14660357755904152, 0.8884242621639741, 0.8998429290899013, 0.9442128792375855, 0.9529502408428152, 0.9546236887962392, 0.9627372031533812, 0.8641095226866682, 0.8993408801477827, 0.9386599586607532, 0.7173611945447436, 0.6968346240610815, 0.6981789833798285, 0.7097262539295792, 0.7280636814887845, 0.7203972964247863, 0.6913636255572715, 0.6996151489028244, 0.6911285284092249, 0.8578762062038061, 0.8836313302564254, 0.8699748825079259, 0.8809898710796447, 0.8727004376322524, 0.8989927174263601, 0.8787271372953744, 0.7951697730295809, 0.8621600934569479, 0.12861512018828958, 0.6611720265992113, 0.5800596250663388, 0.3532204032505184, 0.5757896549694836, 0.5033171986973737, 0.7000093107114131, 0.710976705107656, 0.6620400567496458, 0.6823035883090878, 0.6696361829113344, 0.6261798768441218, 0.5844216609310808, 0.6381144679130523, 0.42161185600649365, 0.6758313923014843, 0.1262323780913417, 0.5098010512578499, 0.42869181427148906, 0.4880511860054273, 0.4255766570048566, 0.6029110103067217, 0.28694574622930735, 0.4152592389400309, 0.4069474671717388, 0.41205145386985975, 0.4441953575939108, 0.661122795775277, 0.5483002350605397, 0.6293056775802961, 0.4288710821030911, 0.639529370173085, 0.45687675069099287, 0.7646005010276716, 0.7029255531350846, 0.7179893530147177, 0.18029074112644305, 0.29573083711649695, 0.17083567326780247, 0.19435698699755843, 0.2945950194234406, 0.1537801970121787, 0.19790128381342587, 0.24887179477912602, 0.29525490925803566, 0.359025352572241, 0.3936311269217716, 0.3654223749196335, 0.3495781444326378, 0.3754487791926393, 0.4123603090885748, 0.3582757083698611, 0.3130898552376722, 0.4559066594684952, 0.7170140606437363, 0.7163568548345361, 0.8113287350129155, 0.7248752993003355, 0.5745662436122012, 0.8268683334509778, 0.6925019769340037, 0.7388022611470371, 0.6868041915551863, 0.13247506286945132, 0.1244319687874138, 0.10302623549869239, 0.10223168645004022, 0.09842825088064278, 0.09972399049977776, 0.1142825003803648, 0.0859975110677833, 0.08017720199076817, 0.17043121414511575, 0.14067064232233606, 0.1727208310728483, 0.18685233173586768, 0.7610379586725853, 0.17234219369321235, 0.3344869463872888, 0.16047322868341285, 0.2652780291712937, 0.47665657631884695, 0.5749743921977077, 0.5788223642093239, 0.5127110128720004, 0.6098202428335417, 0.6575378119560286, 0.6331396625786849, 0.5453262382759511, 0.634106206486766, 0.3528121254517069, 0.306632878602761, 0.32931343166456395, 0.4273860392087654, 0.41386243728154837, 0.4582653409979063, 0.26308425642842903, 0.40123365999851623, 0.44758314524427656, 0.1903408630892487, 0.2310733816666416, 0.18203372394552797, 0.2253993535990807, 0.2119916895974352, 0.1985762199015786, 0.18323681702479733, 0.18581247082260932, 0.18300515909694837, 0.5488774324416037, 0.18031549283944226, 0.5349302590259252, 0.6126493486657143, 0.6045243538687136, 0.6964947698121675, 0.210426364113661, 0.6301172500758386, 0.6993563085908812, 0.17179353502163397, 0.1477603756649416, 0.18668235938951727, 0.185075300069811, 0.17664466913025278, 0.8525002596668572, 0.8446174744214268, 0.16443284941386194, 0.8850378671907997, 0.8759684773718894, 0.16809239305294776, 0.8787423422647999, 0.16423240593239863, 0.16282230354353555, 0.20688933676184718, 0.20911423561625775, 0.8352912095976266, 0.12433852575744753, 0.19288556739724072, 0.1738455562573865, 0.20011565717648094, 0.15668931603210567, 0.16934378164028507, 0.16583971353965465, 0.1541713266825524, 0.22751849828833004, 0.15161845059881252, 0.0870581787387158, 0.07420570431373563, 0.07841584358511355, 0.08658021317402886, 0.0764258368848807, 0.07873052909461553, 0.08067708880578117, 0.07801874472758552, 0.08456010083370835]}, "mutation_prompt": null}
{"id": "af52d5ef-e768-421f-845d-dae6a876a29c", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = 0.7 + 0.3 * np.random.rand() * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        # Enhanced adaptive scaling for local search\n        perturbation_size = 0.05 + 0.05 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / (self.fitness.min() + 1e-8))\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget) ** 0.5))  # Adjusted exploration balance\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                if np.random.rand() < (1 - self.fitness[i] / self.fitness.min()):\n                    trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Introduce adaptive population size reduction enhancing exploitation over iterations and adjusting exploration balance.", "configspace": "", "generation": 91, "fitness": 0.45651646421916564, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.27.", "error": "", "parent_id": "6b3ed482-f83e-4d45-b944-1833b6a62736", "metadata": {"aucs": [0.8486265832401614, 0.8676867164230597, 0.8733949767921014, 0.8675141728843734, 0.8677217035557021, 0.8801095986309588, 0.8672978640615943, 0.8501586861286219, 0.8491557500505349, 0.7253875973375064, 0.7472502805298986, 0.7600077638922125, 0.7271328296906097, 0.7344759255316111, 0.7325746158197489, 0.723674941685962, 0.7262085855536702, 0.6844045310681554, 0.40428584912717147, 0.14478508542028756, 0.14900107208157354, 0.12844951930292714, 0.571041369855686, 0.1463222995873481, 0.1251524914453256, 0.5688497287962209, 0.3961286438855489, 0.1494691628328152, 0.15140612920611096, 0.12896248585797987, 0.14395777963740952, 0.147383834571851, 0.14409610229897973, 0.4705321857084097, 0.1597372308346423, 0.40813897472234006, 0.874932339885134, 0.88362603350217, 0.9442128792375855, 0.9534269096170025, 0.9546236887962392, 0.9627372031533812, 0.8893581190888408, 0.8795761729632968, 0.9333938829458264, 0.7056349761117637, 0.6755931369895065, 0.6733343095237556, 0.6977820982912109, 0.6861944883045675, 0.6687007287069616, 0.6651554844702436, 0.6900393332888337, 0.6577473177957127, 0.8405497084369584, 0.8519625762837161, 0.8464879635393204, 0.8308719613786189, 0.8674460576233222, 0.8354973932148295, 0.8725930018236868, 0.8336522938989186, 0.8280129563588751, 0.6232135836501773, 0.6879434805878947, 0.544251448699826, 0.4548202063238336, 0.6380258341101884, 0.4887632391149377, 0.47151894556431995, 0.5757364531232169, 0.5997986281630598, 0.7167140600310831, 0.3791976133985179, 0.1271312425458977, 0.6327028914815425, 0.6661637799202231, 0.6093763019272795, 0.590444583300727, 0.6377278536407387, 0.12645877184524001, 0.6095383714764779, 0.4797419459105481, 0.5173521334777057, 0.5412359850739165, 0.5313640553285228, 0.4651421898078034, 0.5131059603952111, 0.4379055716634882, 0.4715605481294062, 0.7047761325160045, 0.616899971580547, 0.5368187519697716, 0.6057204405596004, 0.6195502488727838, 0.43271781658775665, 0.7068644313930821, 0.6089369772491645, 0.7332663299665565, 0.266327516832201, 0.07500891566814893, 0.14893101685627175, 0.31148787114226184, 0.27038000088656955, 0.28603577842312355, 0.2507369166813692, 0.1467630220475603, 0.16294955246419685, 0.3628712213288776, 0.3904877052409004, 0.30077310595482154, 0.3743075810789519, 0.3872549812068723, 0.3318239933129524, 0.31101759096197934, 0.3243422793296765, 0.36880971008637686, 0.7562056287139104, 0.7858103438926825, 0.8081289029510859, 0.7043375896918158, 0.6852022069902768, 0.7337027145565229, 0.7969142788532488, 0.7795374177045231, 0.6897667551138744, 0.12095870663105235, 0.10723871631485893, 0.09613662217624097, 0.10870224588658417, 0.1198764431770396, 0.12277562734881853, 0.0887186794709034, 0.0810869263099574, 0.11160322313169713, 0.25923331967893515, 0.14831660695918036, 0.17202496946214563, 0.15094254558554732, 0.16115039001635267, 0.21690840890265506, 0.17711679555296345, 0.20395097021504294, 0.15301196596198718, 0.5073857662988459, 0.47015281018088384, 0.5176022662985156, 0.4560067747985028, 0.5103384680740726, 0.48705812162138906, 0.5899642545276371, 0.5983554251484423, 0.5947313913139767, 0.3124856079968986, 0.32705297327865723, 0.3340696611102738, 0.4011412533457638, 0.4028228272058967, 0.3343545734301929, 0.40289974668518913, 0.40366403228652104, 0.38119058802350014, 0.18196229294238564, 0.23107496437540886, 0.19197838360593644, 0.2089128124068289, 0.18554697574490042, 0.18353918632532817, 0.19188617617347492, 0.18134037609303, 0.2171662648932795, 0.5696899031346465, 0.4887207307774485, 0.6678662178008208, 0.5900688942427028, 0.5286168713831694, 0.21003600102999354, 0.5830877909559361, 0.220551109387928, 0.5397956648859185, 0.1717992042566837, 0.14783567301495404, 0.18656255399080324, 0.18514077140904617, 0.1764902919767537, 0.8572140077292995, 0.8466509370797882, 0.1428725270175757, 0.16215622769800253, 0.8588565438537417, 0.1680731818724296, 0.8598263190963427, 0.16344589497235995, 0.7815596814666448, 0.20601975151149587, 0.20910610578594135, 0.8545999711443556, 0.12393187126025784, 0.2090911326009377, 0.18767323197874908, 0.183548758381193, 0.16755811971535517, 0.16895451765285818, 0.17697659527759568, 0.1541713266825524, 0.18926332042859495, 0.15161845059881252, 0.08045636870760209, 0.08025552958016358, 0.07073944385384057, 0.08704928260483391, 0.08393943171286922, 0.08270253384603676, 0.07964240093328734, 0.07612820465815007, 0.08674832578610969]}, "mutation_prompt": null}
{"id": "9b7d93b6-7353-4684-b15b-40e24e50f95f", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = 0.7 + 0.3 * np.random.rand() * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        # Enhanced adaptive scaling for local search\n        perturbation_size = 0.05 + 0.05 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / (self.fitness.min() + 1e-8))\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                if np.random.rand() < (1 - self.fitness[i] / self.fitness.min()):\n                    trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Enhance local search by dynamically adjusting perturbation size based on both iteration progress and fitness improvement.", "configspace": "", "generation": 89, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6b3ed482-f83e-4d45-b944-1833b6a62736", "metadata": {"aucs": [0.8635679096504482, 0.8651904840699595, 0.8706656124464578, 0.8810134389315147, 0.8685718654200112, 0.8856447563191137, 0.8684144790314466, 0.8756551607463962, 0.8679631559885149, 0.7549504316548021, 0.7445712873910519, 0.7569208214039143, 0.7343731311502447, 0.7679160440598259, 0.755245659266178, 0.736544124521587, 0.715659176144491, 0.7701104596801012, 0.152214401727366, 0.5504235612074206, 0.5481520543409505, 0.6141208230766544, 0.5926557280439354, 0.17717242840235026, 0.48246124113651934, 0.15915506627740783, 0.48402756353441956, 0.13292692014867513, 0.16196294661575372, 0.11272842500012525, 0.1539150518159822, 0.15948608292752742, 0.1561365275238189, 0.12195309062208304, 0.14776975668919712, 0.14660357755904152, 0.8884242621639741, 0.8998429290899013, 0.9442128792375855, 0.9529502408428152, 0.9546236887962392, 0.9627372031533812, 0.8641095226866682, 0.8993408801477827, 0.9386599586607532, 0.7173611945447436, 0.6968346240610815, 0.6981789833798285, 0.7097262539295792, 0.7280636814887845, 0.7203972964247863, 0.6913636255572715, 0.6996151489028244, 0.6911285284092249, 0.8578762062038061, 0.8836313302564254, 0.8699748825079259, 0.8809898710796447, 0.8727004376322524, 0.8989927174263601, 0.8787271372953744, 0.7951697730295809, 0.8621600934569479, 0.12861512018828958, 0.6611720265992113, 0.5800596250663388, 0.3532204032505184, 0.5757896549694836, 0.5033171986973737, 0.7000093107114131, 0.710976705107656, 0.6620400567496458, 0.6823035883090878, 0.6696361829113344, 0.6261798768441218, 0.5844216609310808, 0.6381144679130523, 0.42161185600649365, 0.6758313923014843, 0.1262323780913417, 0.5098010512578499, 0.42869181427148906, 0.4880511860054273, 0.4255766570048566, 0.6029110103067217, 0.28694574622930735, 0.4152592389400309, 0.4069474671717388, 0.41205145386985975, 0.4441953575939108, 0.661122795775277, 0.5483002350605397, 0.6293056775802961, 0.4288710821030911, 0.639529370173085, 0.45687675069099287, 0.7646005010276716, 0.7029255531350846, 0.7179893530147177, 0.18029074112644305, 0.29573083711649695, 0.17083567326780247, 0.19435698699755843, 0.2945950194234406, 0.1537801970121787, 0.19790128381342587, 0.24887179477912602, 0.29525490925803566, 0.359025352572241, 0.3936311269217716, 0.3654223749196335, 0.3495781444326378, 0.3754487791926393, 0.4123603090885748, 0.3582757083698611, 0.3130898552376722, 0.4559066594684952, 0.7170140606437363, 0.7163568548345361, 0.8113287350129155, 0.7248752993003355, 0.5745662436122012, 0.8268683334509778, 0.6925019769340037, 0.7388022611470371, 0.6868041915551863, 0.13247506286945132, 0.1244319687874138, 0.10302623549869239, 0.10223168645004022, 0.09842825088064278, 0.09972399049977776, 0.1142825003803648, 0.0859975110677833, 0.08017720199076817, 0.17043121414511575, 0.14067064232233606, 0.1727208310728483, 0.18685233173586768, 0.7610379586725853, 0.17234219369321235, 0.3344869463872888, 0.16047322868341285, 0.2652780291712937, 0.47665657631884695, 0.5749743921977077, 0.5788223642093239, 0.5127110128720004, 0.6098202428335417, 0.6575378119560286, 0.6331396625786849, 0.5453262382759511, 0.634106206486766, 0.3528121254517069, 0.306632878602761, 0.32931343166456395, 0.4273860392087654, 0.41386243728154837, 0.4582653409979063, 0.26308425642842903, 0.40123365999851623, 0.44758314524427656, 0.1903408630892487, 0.2310733816666416, 0.18203372394552797, 0.2253993535990807, 0.2119916895974352, 0.1985762199015786, 0.18323681702479733, 0.18581247082260932, 0.18300515909694837, 0.5488774324416037, 0.18031549283944226, 0.5349302590259252, 0.6126493486657143, 0.6045243538687136, 0.6964947698121675, 0.210426364113661, 0.6301172500758386, 0.6993563085908812, 0.17179353502163397, 0.1477603756649416, 0.18668235938951727, 0.185075300069811, 0.17664466913025278, 0.8525002596668572, 0.8446174744214268, 0.16443284941386194, 0.8850378671907997, 0.8759684773718894, 0.16809239305294776, 0.8787423422647999, 0.16423240593239863, 0.16282230354353555, 0.20688933676184718, 0.20911423561625775, 0.8352912095976266, 0.12433852575744753, 0.19288556739724072, 0.1738455562573865, 0.20011565717648094, 0.15668931603210567, 0.16934378164028507, 0.16583971353965465, 0.1541713266825524, 0.22751849828833004, 0.15161845059881252, 0.0870581787387158, 0.07420570431373563, 0.07841584358511355, 0.08658021317402886, 0.0764258368848807, 0.07873052909461553, 0.08067708880578117, 0.07801874472758552, 0.08456010083370835]}, "mutation_prompt": null}
{"id": "601cd186-c5c9-464b-959e-d5fc91644a1a", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = 0.7 + 0.3 * np.random.rand() * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.05 + 0.05 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / (self.fitness.min() + 1e-8))\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                if np.random.rand() < (1 - self.fitness[i] / self.fitness.min()):\n                    trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n                if evaluations % (self.budget // 5) == 0:  # Adaptive restart every 20% of budget\n                    reset_indices = np.random.choice(self.population_size, size=self.population_size // 5, replace=False)\n                    for idx in reset_indices:\n                        self.population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                        self.fitness[idx] = func(self.population[idx])\n                        evaluations += 1\n                        if evaluations >= self.budget:\n                            break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Introduce adaptive restart mechanism to the algorithm by periodically resetting a fraction of the population to diversify and escape local optima.", "configspace": "", "generation": 93, "fitness": 0.46229113769037555, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.28.", "error": "", "parent_id": "6b3ed482-f83e-4d45-b944-1833b6a62736", "metadata": {"aucs": [0.8657005288523186, 0.8591571066030912, 0.8689890450008849, 0.881651709042793, 0.8618676182981472, 0.8833304184558557, 0.8690383959053911, 0.8725215535122447, 0.8684867022284841, 0.7538803911264651, 0.7519579189507919, 0.7486818099276005, 0.7340006629839162, 0.7654680060823194, 0.7431930206436395, 0.7347208815513409, 0.7142431742607953, 0.763814237025948, 0.13917980989321788, 0.5027458792083641, 0.5388414475779498, 0.6175533661353103, 0.16556398465655997, 0.1763969965472414, 0.513366498836614, 0.547723911627247, 0.5241499648729947, 0.12994176923493128, 0.16011771845385048, 0.11656289806065356, 0.514456706728557, 0.4980021864208688, 0.15610759264742824, 0.14351755596765103, 0.1576977377310088, 0.15554475858158057, 0.8884242621639741, 0.8998429290899013, 0.9442128792375855, 0.9529502408428152, 0.9546236887962392, 0.9627372031533812, 0.8641095226866682, 0.8993408801477827, 0.9386599586607532, 0.7339169464666706, 0.694291325263768, 0.6912778981258515, 0.7103590921044352, 0.7032384245984347, 0.7087528012340859, 0.6937729906735857, 0.7077397360315955, 0.6723639981234337, 0.8578762062038061, 0.8836313302564254, 0.8699748825079259, 0.8809898710796447, 0.8727004376322524, 0.8989927174263601, 0.8787271372953744, 0.8028241043416557, 0.8621600934569479, 0.12821892867914264, 0.6886668649908585, 0.6389271968968203, 0.2513558505260307, 0.6162930412821861, 0.5601364724425222, 0.7125017052847984, 0.7108873157379079, 0.69342131893177, 0.4822074504651368, 0.6913288310899111, 0.41471230080707433, 0.2669673680597511, 0.6583914626095447, 0.6046156833744158, 0.5343726735900588, 0.12622216444577083, 0.5570394353514041, 0.4085661601097431, 0.4621113590623279, 0.5291047057478017, 0.4015472886665734, 0.24834253424768338, 0.43972359342074785, 0.5760781696543718, 0.49408971957702463, 0.41527944864919986, 0.6399368860510006, 0.4092327321993352, 0.5616108821443813, 0.3588040305116045, 0.39290958402433307, 0.4312933848174658, 0.7198361621251206, 0.7383714697967745, 0.45720444937155524, 0.1683604733848757, 0.21721362458380433, 0.16447217167941308, 0.3262122090169324, 0.2130328638697805, 0.2530634286405494, 0.18179054714437737, 0.34174465260143116, 0.2145173023818826, 0.35397203491411955, 0.4598471422679913, 0.42323437165602495, 0.39739402645423183, 0.3553744741391438, 0.48981291155161866, 0.3376590588809709, 0.39608388098742253, 0.30983852473426254, 0.7850561897741448, 0.7572330341093442, 0.7977838187187836, 0.7257533529266835, 0.6913243935844284, 0.7113780478234584, 0.7105051997176549, 0.6705294508555543, 0.7404450801180946, 0.12344829539843416, 0.07702979275020938, 0.1060996731616275, 0.1140910152700697, 0.10746791231222119, 0.11371035738419721, 0.11823715662338907, 0.10044939076793291, 0.11550978777049226, 0.1705827905553713, 0.14067064232233606, 0.17384865692345808, 0.18685340530963535, 0.7317460019038724, 0.2043909797803216, 0.3211477397541914, 0.16044835571772587, 0.2611203392424962, 0.4276446716426233, 0.544000307040579, 0.45771482523460005, 0.5876572124621227, 0.531907257995669, 0.5213516202777227, 0.6304211660372749, 0.5591836261311496, 0.6251226051906507, 0.3333179113263335, 0.34127931413264667, 0.3592191785134713, 0.47664997253903585, 0.42579857147760247, 0.32965837777127815, 0.26424108453588246, 0.33028968245883095, 0.5153468690426148, 0.19632863089077468, 0.2310733816666416, 0.17868896776285492, 0.22296248272133756, 0.21160741789555526, 0.18333522626659582, 0.19882976833253763, 0.19292409277773703, 0.18185801504345045, 0.19052450312103497, 0.17925151217137913, 0.6261765647365114, 0.21186795334987096, 0.6069583850794673, 0.234984311227189, 0.6475290402651878, 0.5866807788417197, 0.685759312373635, 0.1717935328460629, 0.14776037440988365, 0.18668235617112305, 0.18507530052261756, 0.1766446693571414, 0.8525002596668572, 0.8442243526178574, 0.16443282837175432, 0.8850378671907997, 0.8763302999754345, 0.1680923928591488, 0.8791268448102382, 0.1642324132382209, 0.16282180660851975, 0.20688940947716705, 0.20911423493526793, 0.8321474372541106, 0.12433852070517715, 0.19288556739724072, 0.1738455562573865, 0.20011565717648094, 0.15668931603210567, 0.16934378164028507, 0.1659072622770169, 0.1541713266825524, 0.22400673126448778, 0.15161845059881252, 0.08296540274476616, 0.07344386201796738, 0.08517521694598584, 0.09575692958656434, 0.07945963225570452, 0.07757523676686107, 0.08024742531372686, 0.08021651713852895, 0.0786136642311791]}, "mutation_prompt": null}
{"id": "ea0b322e-7343-405a-ae54-222bb5934687", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n        self.memory_F = np.full(self.population_size, self.F)  # Initialize memory for F\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.memory_F[idx] = 0.7 + 0.3 * np.random.rand() * (1 - self.current_iteration / self.budget)  # Use memory for F\n        mutant = self.population[a] + self.memory_F[idx] * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        # Enhanced adaptive scaling for local search\n        perturbation_size = 0.05 + 0.05 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / (self.fitness.min() + 1e-8))\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                if np.random.rand() < (1 - self.fitness[i] / self.fitness.min()):\n                    trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Enhance differential evolution by incorporating a memory-based strategy for adaptive parameter tuning.", "configspace": "", "generation": 94, "fitness": 0.46880475464339155, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.28.", "error": "", "parent_id": "6b3ed482-f83e-4d45-b944-1833b6a62736", "metadata": {"aucs": [0.8635679096504482, 0.8651904840699595, 0.8706656124464578, 0.8810134389315147, 0.8685718654200112, 0.8856447563191137, 0.8684144790314466, 0.8756551607463962, 0.8679631559885149, 0.7549504316548021, 0.7445712873910519, 0.7569208214039143, 0.7343731311502447, 0.7679160440598259, 0.755245659266178, 0.736544124521587, 0.715659176144491, 0.7701104596801012, 0.152214401727366, 0.5504235612074206, 0.5481520543409505, 0.6141208230766544, 0.5926557280439354, 0.17717242840235026, 0.48246124113651934, 0.15915506627740783, 0.48402756353441956, 0.13292692014867513, 0.16196294661575372, 0.11272842500012525, 0.1539150518159822, 0.15948608292752742, 0.1561365275238189, 0.12195309062208304, 0.14776975668919712, 0.14660357755904152, 0.8884242621639741, 0.8998429290899013, 0.9442128792375855, 0.9529502408428152, 0.9546236887962392, 0.9627372031533812, 0.8641095226866682, 0.8993408801477827, 0.9386599586607532, 0.7173611945447436, 0.6968346240610815, 0.6981789833798285, 0.7097262539295792, 0.7280636814887845, 0.7203972964247863, 0.6913636255572715, 0.6996151489028244, 0.6911285284092249, 0.8578762062038061, 0.8836313302564254, 0.8699748825079259, 0.8809898710796447, 0.8727004376322524, 0.8989927174263601, 0.8787271372953744, 0.7951697730295809, 0.8621600934569479, 0.12861512018828958, 0.6611720265992113, 0.5800596250663388, 0.3532204032505184, 0.5757896549694836, 0.5033171986973737, 0.7000093107114131, 0.710976705107656, 0.6620400567496458, 0.6823035883090878, 0.6696361829113344, 0.6261798768441218, 0.5844216609310808, 0.6381144679130523, 0.42161185600649365, 0.6758313923014843, 0.1262323780913417, 0.5098010512578499, 0.42869181427148906, 0.4880511860054273, 0.4255766570048566, 0.6029110103067217, 0.28694574622930735, 0.4152592389400309, 0.4069474671717388, 0.41205145386985975, 0.4441953575939108, 0.661122795775277, 0.5483002350605397, 0.6293056775802961, 0.4288710821030911, 0.639529370173085, 0.45687675069099287, 0.7646005010276716, 0.7029255531350846, 0.7179893530147177, 0.18029074112644305, 0.29573083711649695, 0.17083567326780247, 0.19435698699755843, 0.2945950194234406, 0.1537801970121787, 0.19790128381342587, 0.24887179477912602, 0.29525490925803566, 0.359025352572241, 0.3936311269217716, 0.3654223749196335, 0.3495781444326378, 0.3754487791926393, 0.4123603090885748, 0.3582757083698611, 0.3130898552376722, 0.4559066594684952, 0.7170140606437363, 0.7163568548345361, 0.8113287350129155, 0.7248752993003355, 0.5745662436122012, 0.8268683334509778, 0.6925019769340037, 0.7388022611470371, 0.6868041915551863, 0.13247506286945132, 0.1244319687874138, 0.10302623549869239, 0.10223168645004022, 0.09842825088064278, 0.09972399049977776, 0.1142825003803648, 0.0859975110677833, 0.08017720199076817, 0.17043121414511575, 0.14067064232233606, 0.1727208310728483, 0.18685233173586768, 0.7610379586725853, 0.17234219369321235, 0.3344869463872888, 0.16047322868341285, 0.2652780291712937, 0.47665657631884695, 0.5749743921977077, 0.5788223642093239, 0.5127110128720004, 0.6098202428335417, 0.6575378119560286, 0.6331396625786849, 0.5453262382759511, 0.634106206486766, 0.3528121254517069, 0.306632878602761, 0.32931343166456395, 0.4273860392087654, 0.41386243728154837, 0.4582653409979063, 0.26308425642842903, 0.40123365999851623, 0.44758314524427656, 0.1903408630892487, 0.2310733816666416, 0.18203372394552797, 0.2253993535990807, 0.2119916895974352, 0.1985762199015786, 0.18323681702479733, 0.18581247082260932, 0.18300515909694837, 0.5488774324416037, 0.18031549283944226, 0.5349302590259252, 0.6126493486657143, 0.6045243538687136, 0.6964947698121675, 0.210426364113661, 0.6301172500758386, 0.6993563085908812, 0.17179353502163397, 0.1477603756649416, 0.18668235938951727, 0.185075300069811, 0.17664466913025278, 0.8525002596668572, 0.8446174744214268, 0.16443284941386194, 0.8850378671907997, 0.8759684773718894, 0.16809239305294776, 0.8787423422647999, 0.16423240593239863, 0.16282230354353555, 0.20688933676184718, 0.20911423561625775, 0.8352912095976266, 0.12433852575744753, 0.19288556739724072, 0.1738455562573865, 0.20011565717648094, 0.15668931603210567, 0.16934378164028507, 0.16583971353965465, 0.1541713266825524, 0.22751849828833004, 0.15161845059881252, 0.0870581787387158, 0.07420570431373563, 0.07841584358511355, 0.08658021317402886, 0.0764258368848807, 0.07873052909461553, 0.08067708880578117, 0.07801874472758552, 0.08456010083370835]}, "mutation_prompt": null}
{"id": "b744fe92-7826-41b3-ad1d-5a8ae06a8aed", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = 0.7 + 0.3 * np.random.rand() * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.05 + 0.05 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / (self.fitness.min() + 1e-8))\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n        best_idx = np.argmin(self.fitness)\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                if np.random.rand() < (1 - self.fitness[i] / self.fitness.min()):\n                    trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            # Preserving the best individual across generations\n            current_best_idx = np.argmin(self.fitness)\n            if self.fitness[current_best_idx] < self.fitness[best_idx]:\n                best_idx = current_best_idx\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Introduce elitism by preserving the best individual across generations to improve convergence stability.", "configspace": "", "generation": 95, "fitness": 0.46880475464339155, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.28.", "error": "", "parent_id": "6b3ed482-f83e-4d45-b944-1833b6a62736", "metadata": {"aucs": [0.8635679096504482, 0.8651904840699595, 0.8706656124464578, 0.8810134389315147, 0.8685718654200112, 0.8856447563191137, 0.8684144790314466, 0.8756551607463962, 0.8679631559885149, 0.7549504316548021, 0.7445712873910519, 0.7569208214039143, 0.7343731311502447, 0.7679160440598259, 0.755245659266178, 0.736544124521587, 0.715659176144491, 0.7701104596801012, 0.152214401727366, 0.5504235612074206, 0.5481520543409505, 0.6141208230766544, 0.5926557280439354, 0.17717242840235026, 0.48246124113651934, 0.15915506627740783, 0.48402756353441956, 0.13292692014867513, 0.16196294661575372, 0.11272842500012525, 0.1539150518159822, 0.15948608292752742, 0.1561365275238189, 0.12195309062208304, 0.14776975668919712, 0.14660357755904152, 0.8884242621639741, 0.8998429290899013, 0.9442128792375855, 0.9529502408428152, 0.9546236887962392, 0.9627372031533812, 0.8641095226866682, 0.8993408801477827, 0.9386599586607532, 0.7173611945447436, 0.6968346240610815, 0.6981789833798285, 0.7097262539295792, 0.7280636814887845, 0.7203972964247863, 0.6913636255572715, 0.6996151489028244, 0.6911285284092249, 0.8578762062038061, 0.8836313302564254, 0.8699748825079259, 0.8809898710796447, 0.8727004376322524, 0.8989927174263601, 0.8787271372953744, 0.7951697730295809, 0.8621600934569479, 0.12861512018828958, 0.6611720265992113, 0.5800596250663388, 0.3532204032505184, 0.5757896549694836, 0.5033171986973737, 0.7000093107114131, 0.710976705107656, 0.6620400567496458, 0.6823035883090878, 0.6696361829113344, 0.6261798768441218, 0.5844216609310808, 0.6381144679130523, 0.42161185600649365, 0.6758313923014843, 0.1262323780913417, 0.5098010512578499, 0.42869181427148906, 0.4880511860054273, 0.4255766570048566, 0.6029110103067217, 0.28694574622930735, 0.4152592389400309, 0.4069474671717388, 0.41205145386985975, 0.4441953575939108, 0.661122795775277, 0.5483002350605397, 0.6293056775802961, 0.4288710821030911, 0.639529370173085, 0.45687675069099287, 0.7646005010276716, 0.7029255531350846, 0.7179893530147177, 0.18029074112644305, 0.29573083711649695, 0.17083567326780247, 0.19435698699755843, 0.2945950194234406, 0.1537801970121787, 0.19790128381342587, 0.24887179477912602, 0.29525490925803566, 0.359025352572241, 0.3936311269217716, 0.3654223749196335, 0.3495781444326378, 0.3754487791926393, 0.4123603090885748, 0.3582757083698611, 0.3130898552376722, 0.4559066594684952, 0.7170140606437363, 0.7163568548345361, 0.8113287350129155, 0.7248752993003355, 0.5745662436122012, 0.8268683334509778, 0.6925019769340037, 0.7388022611470371, 0.6868041915551863, 0.13247506286945132, 0.1244319687874138, 0.10302623549869239, 0.10223168645004022, 0.09842825088064278, 0.09972399049977776, 0.1142825003803648, 0.0859975110677833, 0.08017720199076817, 0.17043121414511575, 0.14067064232233606, 0.1727208310728483, 0.18685233173586768, 0.7610379586725853, 0.17234219369321235, 0.3344869463872888, 0.16047322868341285, 0.2652780291712937, 0.47665657631884695, 0.5749743921977077, 0.5788223642093239, 0.5127110128720004, 0.6098202428335417, 0.6575378119560286, 0.6331396625786849, 0.5453262382759511, 0.634106206486766, 0.3528121254517069, 0.306632878602761, 0.32931343166456395, 0.4273860392087654, 0.41386243728154837, 0.4582653409979063, 0.26308425642842903, 0.40123365999851623, 0.44758314524427656, 0.1903408630892487, 0.2310733816666416, 0.18203372394552797, 0.2253993535990807, 0.2119916895974352, 0.1985762199015786, 0.18323681702479733, 0.18581247082260932, 0.18300515909694837, 0.5488774324416037, 0.18031549283944226, 0.5349302590259252, 0.6126493486657143, 0.6045243538687136, 0.6964947698121675, 0.210426364113661, 0.6301172500758386, 0.6993563085908812, 0.17179353502163397, 0.1477603756649416, 0.18668235938951727, 0.185075300069811, 0.17664466913025278, 0.8525002596668572, 0.8446174744214268, 0.16443284941386194, 0.8850378671907997, 0.8759684773718894, 0.16809239305294776, 0.8787423422647999, 0.16423240593239863, 0.16282230354353555, 0.20688933676184718, 0.20911423561625775, 0.8352912095976266, 0.12433852575744753, 0.19288556739724072, 0.1738455562573865, 0.20011565717648094, 0.15668931603210567, 0.16934378164028507, 0.16583971353965465, 0.1541713266825524, 0.22751849828833004, 0.15161845059881252, 0.0870581787387158, 0.07420570431373563, 0.07841584358511355, 0.08658021317402886, 0.0764258368848807, 0.07873052909461553, 0.08067708880578117, 0.07801874472758552, 0.08456010083370835]}, "mutation_prompt": null}
{"id": "6761193f-25ed-490c-891f-6e5a5eb10e03", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = 0.7 + 0.3 * np.random.rand() * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        # Enhanced adaptive scaling for local search\n        perturbation_size = 0.05 + 0.05 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / (self.fitness.min() + 1e-8))\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                if np.random.rand() < (1 - self.fitness[i] / self.fitness.min()):\n                    trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Enhance local search by dynamically adjusting perturbation size based on both iteration progress and fitness improvement.", "configspace": "", "generation": 89, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6b3ed482-f83e-4d45-b944-1833b6a62736", "metadata": {"aucs": [0.8635679096504482, 0.8651904840699595, 0.8706656124464578, 0.8810134389315147, 0.8685718654200112, 0.8856447563191137, 0.8684144790314466, 0.8756551607463962, 0.8679631559885149, 0.7549504316548021, 0.7445712873910519, 0.7569208214039143, 0.7343731311502447, 0.7679160440598259, 0.755245659266178, 0.736544124521587, 0.715659176144491, 0.7701104596801012, 0.152214401727366, 0.5504235612074206, 0.5481520543409505, 0.6141208230766544, 0.5926557280439354, 0.17717242840235026, 0.48246124113651934, 0.15915506627740783, 0.48402756353441956, 0.13292692014867513, 0.16196294661575372, 0.11272842500012525, 0.1539150518159822, 0.15948608292752742, 0.1561365275238189, 0.12195309062208304, 0.14776975668919712, 0.14660357755904152, 0.8884242621639741, 0.8998429290899013, 0.9442128792375855, 0.9529502408428152, 0.9546236887962392, 0.9627372031533812, 0.8641095226866682, 0.8993408801477827, 0.9386599586607532, 0.7173611945447436, 0.6968346240610815, 0.6981789833798285, 0.7097262539295792, 0.7280636814887845, 0.7203972964247863, 0.6913636255572715, 0.6996151489028244, 0.6911285284092249, 0.8578762062038061, 0.8836313302564254, 0.8699748825079259, 0.8809898710796447, 0.8727004376322524, 0.8989927174263601, 0.8787271372953744, 0.7951697730295809, 0.8621600934569479, 0.12861512018828958, 0.6611720265992113, 0.5800596250663388, 0.3532204032505184, 0.5757896549694836, 0.5033171986973737, 0.7000093107114131, 0.710976705107656, 0.6620400567496458, 0.6823035883090878, 0.6696361829113344, 0.6261798768441218, 0.5844216609310808, 0.6381144679130523, 0.42161185600649365, 0.6758313923014843, 0.1262323780913417, 0.5098010512578499, 0.42869181427148906, 0.4880511860054273, 0.4255766570048566, 0.6029110103067217, 0.28694574622930735, 0.4152592389400309, 0.4069474671717388, 0.41205145386985975, 0.4441953575939108, 0.661122795775277, 0.5483002350605397, 0.6293056775802961, 0.4288710821030911, 0.639529370173085, 0.45687675069099287, 0.7646005010276716, 0.7029255531350846, 0.7179893530147177, 0.18029074112644305, 0.29573083711649695, 0.17083567326780247, 0.19435698699755843, 0.2945950194234406, 0.1537801970121787, 0.19790128381342587, 0.24887179477912602, 0.29525490925803566, 0.359025352572241, 0.3936311269217716, 0.3654223749196335, 0.3495781444326378, 0.3754487791926393, 0.4123603090885748, 0.3582757083698611, 0.3130898552376722, 0.4559066594684952, 0.7170140606437363, 0.7163568548345361, 0.8113287350129155, 0.7248752993003355, 0.5745662436122012, 0.8268683334509778, 0.6925019769340037, 0.7388022611470371, 0.6868041915551863, 0.13247506286945132, 0.1244319687874138, 0.10302623549869239, 0.10223168645004022, 0.09842825088064278, 0.09972399049977776, 0.1142825003803648, 0.0859975110677833, 0.08017720199076817, 0.17043121414511575, 0.14067064232233606, 0.1727208310728483, 0.18685233173586768, 0.7610379586725853, 0.17234219369321235, 0.3344869463872888, 0.16047322868341285, 0.2652780291712937, 0.47665657631884695, 0.5749743921977077, 0.5788223642093239, 0.5127110128720004, 0.6098202428335417, 0.6575378119560286, 0.6331396625786849, 0.5453262382759511, 0.634106206486766, 0.3528121254517069, 0.306632878602761, 0.32931343166456395, 0.4273860392087654, 0.41386243728154837, 0.4582653409979063, 0.26308425642842903, 0.40123365999851623, 0.44758314524427656, 0.1903408630892487, 0.2310733816666416, 0.18203372394552797, 0.2253993535990807, 0.2119916895974352, 0.1985762199015786, 0.18323681702479733, 0.18581247082260932, 0.18300515909694837, 0.5488774324416037, 0.18031549283944226, 0.5349302590259252, 0.6126493486657143, 0.6045243538687136, 0.6964947698121675, 0.210426364113661, 0.6301172500758386, 0.6993563085908812, 0.17179353502163397, 0.1477603756649416, 0.18668235938951727, 0.185075300069811, 0.17664466913025278, 0.8525002596668572, 0.8446174744214268, 0.16443284941386194, 0.8850378671907997, 0.8759684773718894, 0.16809239305294776, 0.8787423422647999, 0.16423240593239863, 0.16282230354353555, 0.20688933676184718, 0.20911423561625775, 0.8352912095976266, 0.12433852575744753, 0.19288556739724072, 0.1738455562573865, 0.20011565717648094, 0.15668931603210567, 0.16934378164028507, 0.16583971353965465, 0.1541713266825524, 0.22751849828833004, 0.15161845059881252, 0.0870581787387158, 0.07420570431373563, 0.07841584358511355, 0.08658021317402886, 0.0764258368848807, 0.07873052909461553, 0.08067708880578117, 0.07801874472758552, 0.08456010083370835]}, "mutation_prompt": null}
{"id": "6f60ec30-68e9-4083-abf7-377821133eec", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = 0.7 + 0.3 * np.random.rand() * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        perturbation_size = 0.05 + 0.05 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / (self.fitness.min() + 1e-8))\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                if np.random.rand() < (1 - self.fitness[i] / self.fitness.min()):\n                    trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i] or np.random.rand() < 0.1:  # Stochastic elitism\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Introduce stochastic elitism to retain the best solutions probabilistically to ensure diversity and robustness.", "configspace": "", "generation": 97, "fitness": 0.25354380720137687, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.23.", "error": "", "parent_id": "6b3ed482-f83e-4d45-b944-1833b6a62736", "metadata": {"aucs": [0.7657523386529068, 0.7991506121421781, 0.8054271316402944, 0.806741481828872, 0.80384765996823, 0.813017824350262, 0.810785913917192, 0.7955559036409645, 0.7948944744924367, 0.5755169167833425, 0.6326927599467106, 0.5806134497085946, 0.6778908097147855, 0.6973247429295335, 0.6597676514556554, 0.6032641892944655, 0.6464758142690468, 0.5946683991015383, 0.10163056470769971, 0.09166149127695422, 0.091764807502272, 0.09214049652445977, 0.12936023231961646, 0.11329793116935338, 0.10696396871930369, 0.12455864738856925, 0.10811203487212928, 0.11004362776295307, 0.08120178284934687, 0.07946209576331931, 0.0862984349301903, 0.11245233021343337, 0.09673744101488335, 0.0960651044231654, 0.10731617770516166, 0.10139496456163233, 0.9568238958678085, 0.9358121906752908, 0.8778200238329522, 0.9646369217216427, 0.9676148252629188, 0.07477184670394232, 0.9466938544028707, 0.9387704832840285, 0.9740334572077113, 0.38733638320164154, 0.4946734237129873, 0.34578459790332194, 0.31226284282558914, 0.14458911384676065, 0.4656662095163884, 0.29879658416993127, 0.32206746702611166, 0.3899394116401983, 0.2640265117243201, 0.2414309338047208, 0.3131506006300314, 0.22703169624829267, 0.520198934072154, 0.23513025249411756, 0.22546082584480798, 0.2525229124622248, 0.24266887060511266, 0.1587068199568703, 0.18885492981569607, 0.16911946652040022, 0.15033032156524861, 0.2098691678770661, 0.15701043824148475, 0.20567180908610905, 0.16323718529327158, 0.1857498956124044, 0.010065245559945146, 0.19517299851299041, 0.010059353200380095, 0.19003007378750536, 0.14489736543245324, 0.20041652488863482, 0.276440087312416, 0.1912704615250166, 0.1902244042218587, 0.004089928244407792, 0.019700244583005566, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0003118703532052347, 9.999999999998899e-05, 0.018647632590213514, 9.999999999998899e-05, 0.08552397410058843, 0.07412585544651884, 0.07425565336224371, 0.05546671637698397, 0.06823237841000684, 0.16789713067755274, 0.07330518714217038, 0.11126581755487586, 0.056130451395611125, 0.04125701710141749, 0.0689826253953999, 0.036564926113332286, 9.999999999998899e-05, 0.035922617204919294, 0.052885613958653654, 9.999999999998899e-05, 0.10039974517489503, 0.059715971716202465, 0.17259305869715225, 0.12429954496132889, 0.19421670514898726, 0.09719001041820341, 0.09681111750288074, 0.11488275318193086, 0.12316941868231934, 0.10099194126825772, 0.10480268460234277, 0.44442896097908813, 0.5058557720785293, 0.5007514017887855, 0.5171328064813906, 0.45660310757733236, 0.4865777464665402, 0.5133226983110069, 0.4710375117432225, 0.4747344870315583, 0.08137716940160444, 0.0955318005486846, 0.08553830099376614, 0.0968466496950785, 0.08404858665344017, 0.09499110934474952, 0.07928473406583603, 0.08382763141726168, 0.10348063782680261, 0.1317561752820755, 0.15030060206163975, 0.23472207313045168, 0.14350364510435798, 0.18867896716245625, 0.22973428411726993, 0.1473828318645879, 0.12519199198938658, 0.17679623682313161, 0.30982975419118397, 0.316740789104778, 0.30981164905695724, 0.30380591319459094, 0.3484445147197316, 0.33951394887694364, 0.38357133822886924, 0.4222549584153137, 0.44176232332721055, 0.14776496067737044, 0.17802183798812987, 0.18355467124197922, 0.23470942381735393, 0.19357252295408212, 0.2155997750770049, 0.2022882780838391, 0.28512502938535667, 0.28752378245485577, 0.1640270365624007, 0.17573564118297402, 0.17481950564423665, 0.21917037344476153, 0.17354477460435702, 0.18310949554711287, 0.18861974975199125, 0.18226932925635797, 0.1854933647579342, 0.1803874632924175, 0.18219950427275555, 0.16627715728421122, 0.1825984904061464, 0.18617857372168334, 0.20716842622080067, 0.17392197870546056, 0.19046496547439606, 0.1823192362104855, 0.16212645368830914, 0.24388379045655828, 0.11476754641503939, 0.18357992222320385, 0.17849824589503516, 0.16502556536771662, 0.7425814055285425, 0.19711073280298763, 0.12760393951470272, 0.2779509642660559, 0.16757494970886033, 0.12673229698934807, 0.16281494377953187, 0.2995861723333223, 0.20282594188479408, 0.21003083185697202, 0.2017660815749085, 0.20669337115473596, 0.17858183207075418, 0.19509440552401103, 0.21306895477958498, 0.1674570336893637, 0.19484984915256998, 0.1746979126055308, 0.18249435511555923, 0.18556699729317738, 0.19469476575996492, 0.06780563220647506, 0.0741259673535617, 0.07685175186445758, 0.07364450634979403, 0.06482094048978437, 0.07338351089093087, 0.0708295212648905, 0.07778295735001084, 0.07788943121561276]}, "mutation_prompt": null}
{"id": "22b23dcb-83d4-41e4-bd54-c8ff21408614", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        decay_factor = 0.5  # Introduced decay factor\n        self.F = (0.7 + 0.3 * np.random.rand()) * (1 - (self.current_iteration / self.budget) ** decay_factor)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        # Enhanced adaptive scaling for local search\n        perturbation_size = 0.05 + 0.05 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / (self.fitness.min() + 1e-8))\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                if np.random.rand() < (1 - self.fitness[i] / self.fitness.min()):\n                    trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Introduce a decay factor to the mutation factor update for smoother convergence control.", "configspace": "", "generation": 98, "fitness": 0.33911515941026, "feedback": "The algorithm AdaptiveMemeticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.27.", "error": "", "parent_id": "6b3ed482-f83e-4d45-b944-1833b6a62736", "metadata": {"aucs": [0.9193560323439309, 0.6258565060233268, 0.9178798138243655, 0.9189540247195187, 0.9218500043171951, 0.9192108838863737, 0.8358158270226743, 0.9061829072090571, 0.9027987964609095, 0.23413128749755274, 0.8335210431993669, 0.047953815868755356, 0.4459595506015199, 0.7848612334957803, 0.8531556777806042, 0.09351255885577592, 0.8384550860962823, 0.8416149668126147, 0.22689625155342752, 0.20648872135321517, 0.12945131451425618, 0.15207519833952154, 0.1319961950433972, 0.14898538150026563, 0.1485140866261463, 0.14079043597600882, 0.1499861054523599, 0.1334507997505503, 0.1414506289280294, 0.1230279919259969, 0.11306289632980393, 0.15105439582882996, 0.10843608899517587, 0.27100676607225915, 0.13516567820130188, 0.1358697579285939, 0.9537672644311783, 0.9133282864637456, 0.939534359470539, 0.9235666613923457, 0.8872277571646738, 0.8958172170192135, 0.8762172828199408, 0.9416855540272772, 0.8431140861358377, 0.20837820324084788, 0.39705392465877687, 0.28055131604057004, 0.2869538841769469, 0.2416605868824928, 0.19404874179884268, 0.1779881080772755, 0.21661824460335055, 0.29771113194911747, 0.8983270007252543, 0.22828604851453094, 0.9061924067042078, 0.9151393200835827, 0.909356434407657, 0.9009477346377115, 0.36688447942833213, 0.933999084755511, 0.4058140000932893, 0.1755237222760503, 0.16558852011295222, 0.14353404758366672, 0.16353714514828788, 0.15058565369104493, 0.21877756522539127, 0.18335417673628474, 0.20417489783910558, 0.1541055135660816, 0.1846904805469326, 0.18145901494756367, 0.12965330486638071, 0.2789507378129348, 0.15467575213311158, 0.1433375957179851, 0.17711621909151687, 0.3808862221651981, 0.16091493778061394, 0.09474879152775506, 0.46731600916086635, 0.2614049374969927, 0.3384154777577615, 0.19741005338545847, 0.18261563284610693, 0.18927737819524304, 0.09333633446218359, 0.2263178327066927, 0.22332545181391694, 0.0811658629719808, 0.17916243617341876, 0.13757985106668513, 0.15563141895830868, 0.43689145919291117, 0.3873160126063049, 0.41811497036891865, 0.3411358167123413, 0.12955563688090843, 0.26061870266351395, 0.1443121343633551, 0.12029722115697494, 0.12277909153782218, 0.10820998527809422, 0.11572332959911513, 0.12328984263808074, 0.23455153648297822, 0.19983155655849494, 0.30245891219701926, 0.21603379650426946, 0.24570031480902144, 0.3231725816525516, 0.19346100974138436, 0.46320731928745396, 0.39449470919461005, 0.2717978598546742, 0.5955881060373489, 0.3804737166629668, 0.7139649087462897, 0.6746770954145854, 0.44004730932894376, 0.5995415411415709, 0.6007031272564917, 0.5584514714451763, 0.6958450895705754, 0.13415659592092366, 0.1276140193299209, 0.15047346743696366, 0.11729276250660226, 0.14073230506034562, 0.10453489199968025, 0.10665024096971665, 0.13662157086042193, 0.11789673781416243, 0.22906392409725418, 0.1952760332408876, 0.15134394274591145, 0.14251244517291128, 0.22376567954374682, 0.22167572382269674, 0.20938618771294804, 0.1679779915798737, 0.1576465207945037, 0.49192667390686373, 0.5339068160673642, 0.3962110521057418, 0.44721829556987824, 0.7150955391796596, 0.48137136231224986, 0.5355051435259806, 0.5042344208842107, 0.5659209193658383, 0.49810283321089743, 0.3545193338988938, 0.23758368590768064, 0.3779623940133793, 0.21464491624213944, 0.22827672137447919, 0.22878912015707764, 0.4937642794236644, 0.31785032934127044, 0.22547742923001812, 0.23246523683300935, 0.1882570027100493, 0.22650999316735265, 0.21805089372835307, 0.235359651810212, 0.21879931746688386, 0.25303750966866423, 0.22759980064228424, 0.3217551936902062, 0.2034341198553974, 0.21515526131494944, 0.20741113190192328, 0.20898538958010382, 0.2190656367815036, 0.2331494312863459, 0.19970534722891664, 0.21677838209745015, 0.9275863218103267, 0.16395284618654682, 0.16404929381540856, 0.1788289689815722, 0.19646054852770445, 0.11987200293911116, 0.8578177725925756, 0.8666535417627336, 0.15348949340340534, 0.8997318196687558, 0.16810562342656088, 0.4278978726052005, 0.16615856440462662, 0.16526758995907898, 0.20929918417040216, 0.20860776781788437, 0.6846352545994092, 0.12506556387270773, 0.18931230481868788, 0.18197025584473747, 0.19157573714048126, 0.20156646870706973, 0.1985277806507787, 0.18296268489377177, 0.20468318998901047, 0.18454577725794796, 0.18851508394409666, 0.0882659384908413, 0.09050906238947554, 0.09058303489536634, 0.08235527583865099, 0.08356761858663175, 0.1008923682141416, 0.09075346309992127, 0.09796374170044542, 0.08857603883271659]}, "mutation_prompt": null}
{"id": "b2922a02-bd43-4cce-942a-e5999f0b65a3", "solution": "import numpy as np\n\nclass AdaptiveMemeticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.F = 0.8  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = None\n\n    def evaluate_population(self, func):\n        if self.fitness is None:\n            self.fitness = np.array([func(ind) for ind in self.population])\n\n    def differential_evolution(self, idx):\n        candidates = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        self.F = 0.7 + 0.3 * np.random.rand() * (1 - self.current_iteration / self.budget)  # Adjusted mutation factor\n        mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.CR = 0.5 + 0.5 * (1 - self.current_iteration / self.budget)  # Adaptive crossover probability\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        if not np.any(crossover_mask):\n            crossover_mask[np.random.randint(0, self.dim)] = True\n        return np.where(crossover_mask, mutant, target)\n\n    def local_search(self, individual, func):\n        current_fitness = func(individual)\n        # Enhanced adaptive scaling for local search\n        perturbation_size = 0.05 + 0.05 * (1 - self.current_iteration / self.budget) * (1 if current_fitness == 0 else current_fitness / (self.fitness.min() + 1e-8))\n        perturbation = np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n        if func(candidate) < current_fitness:\n            return candidate\n        return individual\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.current_iteration = evaluations\n            self.population_size = max(5, int(20 * (1 - evaluations / self.budget)))  \n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.differential_evolution(i)\n                trial = self.crossover(target, mutant)\n                if np.random.rand() < (1 - self.fitness[i] / self.fitness.min()):\n                    trial = self.local_search(trial, func)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemeticAlgorithm", "description": "Enhance local search by dynamically adjusting perturbation size based on both iteration progress and fitness improvement.", "configspace": "", "generation": 89, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6b3ed482-f83e-4d45-b944-1833b6a62736", "metadata": {"aucs": [0.8635679096504482, 0.8651904840699595, 0.8706656124464578, 0.8810134389315147, 0.8685718654200112, 0.8856447563191137, 0.8684144790314466, 0.8756551607463962, 0.8679631559885149, 0.7549504316548021, 0.7445712873910519, 0.7569208214039143, 0.7343731311502447, 0.7679160440598259, 0.755245659266178, 0.736544124521587, 0.715659176144491, 0.7701104596801012, 0.152214401727366, 0.5504235612074206, 0.5481520543409505, 0.6141208230766544, 0.5926557280439354, 0.17717242840235026, 0.48246124113651934, 0.15915506627740783, 0.48402756353441956, 0.13292692014867513, 0.16196294661575372, 0.11272842500012525, 0.1539150518159822, 0.15948608292752742, 0.1561365275238189, 0.12195309062208304, 0.14776975668919712, 0.14660357755904152, 0.8884242621639741, 0.8998429290899013, 0.9442128792375855, 0.9529502408428152, 0.9546236887962392, 0.9627372031533812, 0.8641095226866682, 0.8993408801477827, 0.9386599586607532, 0.7173611945447436, 0.6968346240610815, 0.6981789833798285, 0.7097262539295792, 0.7280636814887845, 0.7203972964247863, 0.6913636255572715, 0.6996151489028244, 0.6911285284092249, 0.8578762062038061, 0.8836313302564254, 0.8699748825079259, 0.8809898710796447, 0.8727004376322524, 0.8989927174263601, 0.8787271372953744, 0.7951697730295809, 0.8621600934569479, 0.12861512018828958, 0.6611720265992113, 0.5800596250663388, 0.3532204032505184, 0.5757896549694836, 0.5033171986973737, 0.7000093107114131, 0.710976705107656, 0.6620400567496458, 0.6823035883090878, 0.6696361829113344, 0.6261798768441218, 0.5844216609310808, 0.6381144679130523, 0.42161185600649365, 0.6758313923014843, 0.1262323780913417, 0.5098010512578499, 0.42869181427148906, 0.4880511860054273, 0.4255766570048566, 0.6029110103067217, 0.28694574622930735, 0.4152592389400309, 0.4069474671717388, 0.41205145386985975, 0.4441953575939108, 0.661122795775277, 0.5483002350605397, 0.6293056775802961, 0.4288710821030911, 0.639529370173085, 0.45687675069099287, 0.7646005010276716, 0.7029255531350846, 0.7179893530147177, 0.18029074112644305, 0.29573083711649695, 0.17083567326780247, 0.19435698699755843, 0.2945950194234406, 0.1537801970121787, 0.19790128381342587, 0.24887179477912602, 0.29525490925803566, 0.359025352572241, 0.3936311269217716, 0.3654223749196335, 0.3495781444326378, 0.3754487791926393, 0.4123603090885748, 0.3582757083698611, 0.3130898552376722, 0.4559066594684952, 0.7170140606437363, 0.7163568548345361, 0.8113287350129155, 0.7248752993003355, 0.5745662436122012, 0.8268683334509778, 0.6925019769340037, 0.7388022611470371, 0.6868041915551863, 0.13247506286945132, 0.1244319687874138, 0.10302623549869239, 0.10223168645004022, 0.09842825088064278, 0.09972399049977776, 0.1142825003803648, 0.0859975110677833, 0.08017720199076817, 0.17043121414511575, 0.14067064232233606, 0.1727208310728483, 0.18685233173586768, 0.7610379586725853, 0.17234219369321235, 0.3344869463872888, 0.16047322868341285, 0.2652780291712937, 0.47665657631884695, 0.5749743921977077, 0.5788223642093239, 0.5127110128720004, 0.6098202428335417, 0.6575378119560286, 0.6331396625786849, 0.5453262382759511, 0.634106206486766, 0.3528121254517069, 0.306632878602761, 0.32931343166456395, 0.4273860392087654, 0.41386243728154837, 0.4582653409979063, 0.26308425642842903, 0.40123365999851623, 0.44758314524427656, 0.1903408630892487, 0.2310733816666416, 0.18203372394552797, 0.2253993535990807, 0.2119916895974352, 0.1985762199015786, 0.18323681702479733, 0.18581247082260932, 0.18300515909694837, 0.5488774324416037, 0.18031549283944226, 0.5349302590259252, 0.6126493486657143, 0.6045243538687136, 0.6964947698121675, 0.210426364113661, 0.6301172500758386, 0.6993563085908812, 0.17179353502163397, 0.1477603756649416, 0.18668235938951727, 0.185075300069811, 0.17664466913025278, 0.8525002596668572, 0.8446174744214268, 0.16443284941386194, 0.8850378671907997, 0.8759684773718894, 0.16809239305294776, 0.8787423422647999, 0.16423240593239863, 0.16282230354353555, 0.20688933676184718, 0.20911423561625775, 0.8352912095976266, 0.12433852575744753, 0.19288556739724072, 0.1738455562573865, 0.20011565717648094, 0.15668931603210567, 0.16934378164028507, 0.16583971353965465, 0.1541713266825524, 0.22751849828833004, 0.15161845059881252, 0.0870581787387158, 0.07420570431373563, 0.07841584358511355, 0.08658021317402886, 0.0764258368848807, 0.07873052909461553, 0.08067708880578117, 0.07801874472758552, 0.08456010083370835]}, "mutation_prompt": null}
