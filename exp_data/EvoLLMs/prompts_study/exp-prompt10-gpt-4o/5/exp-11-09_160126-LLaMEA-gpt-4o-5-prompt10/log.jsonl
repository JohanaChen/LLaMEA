{"id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 56, in __call__\n  File \"<string>\", line 26, in _select_parents\nIndexError: index 8 is out of bounds for axis 0 with size 4\n.", "error": "IndexError('index 8 is out of bounds for axis 0 with size 4')Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 56, in __call__\n  File \"<string>\", line 26, in _select_parents\nIndexError: index 8 is out of bounds for axis 0 with size 4\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "42dbe3cf-21f2-4f1d-8392-b1b5731eaabe", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "88d3cb86-1bfd-4c76-8e06-630fa833d2c8", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "770aeeb5-2bbe-4f5b-99eb-39a4cfa6bf1d", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "dbdfae90-a489-4a25-8a7d-1b938430f3c2", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < 0.7:  # Dynamic crossover decision\n            crossover_point = np.random.randint(1, self.dim-1)\n            child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        else:\n            child = np.copy(parent1)  # Occasionally retain parent1 as child\n        return child\n    \n    def _mutate(self, individual):\n        adaptive_mutation_rate = self.mutation_rate * (1.0 - self.evaluations / self.budget)  # Adaptive mutation\n        for i in range(self.dim):\n            if np.random.rand() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "Enhanced hybrid genetic algorithm with adaptive mutation rate and dynamic crossover.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 12 is out of bounds for axis 0 with size 4').", "error": "IndexError('index 12 is out of bounds for axis 0 with size 4')", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "f5d44d65-6069-4a83-9074-ef9c93d6c64c", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "e84305d0-65b5-4535-a310-c03bd0ea938e", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "badf93b3-4196-430e-bfef-a7f0263be90a", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "6d0b93c0-1c95-44ad-9fee-2d0ec2bc4f2a", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "40aed7ec-a3e1-4df5-ad33-6b59c836255b", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "9abeec02-cfda-4540-b4d8-20e23388727b", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "1e1e2892-69a8-4b37-af48-6eceb08c38af", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "0df67a64-4578-450f-99b5-a5d3352d33fa", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "8e54d56a-0ab2-41cf-8107-2fe6f555a51c", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "39ab259d-28df-4ae6-8d16-8a114db53c18", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "9d618093-44dd-416d-aac6-ba31e9c72af8", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "098b0312-ea20-4ed0-a6d5-06e75e1c149f", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.base_population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.base_population_size):\n            tournament = np.random.choice(self.base_population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        adaptive_mutation_rate = self.mutation_rate * (1 - self.evaluations / self.budget)\n        for i in range(self.dim):\n            if np.random.rand() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.base_population_size\n\n        while self.evaluations < self.budget:\n            dynamic_population_size = self.base_population_size + int(10 * (1 - self.evaluations / self.budget))\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            for i in range(0, dynamic_population_size, 2):\n                parent1 = population[parents_idx[i % self.base_population_size]]\n                parent2 = population[parents_idx[(i+1) % self.base_population_size]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += dynamic_population_size\n\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.base_population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "Enhanced exploration by introducing dynamic mutation rates and adaptive population size for improved convergence speed.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 16 is out of bounds for axis 0 with size 4').", "error": "IndexError('index 16 is out of bounds for axis 0 with size 4')", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "fb926b20-a759-443d-80b8-147b014f02df", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "60b2953c-575c-4e95-bda9-0ab4a90939c2", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.15  # Increased mutation rate for diversity\n        self.elite_fraction = 0.25  # Increased elite fraction for stronger selection pressure\n        self.tournament_size = 3  # Reduced tournament size for diverse selection\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        alpha = np.random.rand(self.dim)  # Blend crossover for smoother offspring\n        child = alpha * parent1 + (1 - alpha) * parent2\n        return child\n    \n    def _mutate(self, individual):\n        if np.random.rand() < self.mutation_rate:\n            mutation_strength = np.random.randn(self.dim) * 0.1  # Gaussian mutation for fine-tuning\n            individual += mutation_strength\n        return np.clip(individual, self.lb, self.ub)\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(3)]  # Fewer neighbors for efficiency\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "An improved hybrid adaptive genetic algorithm with diversified mutation strategy and enhanced selection pressure for faster convergence.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 14 is out of bounds for axis 0 with size 5').", "error": "IndexError('index 14 is out of bounds for axis 0 with size 5')", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "5e5f79fd-c332-44bc-8a70-c697d64ccb8a", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, min(self.tournament_size, self.population_size), replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _adaptive_crossover(self, parent1, parent2, iteration, max_iterations):\n        crossover_point = np.random.randint(1, self.dim-1)\n        if iteration < max_iterations // 2:\n            child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        else:\n            alpha = np.random.uniform(0, 1, self.dim)\n            child = alpha * parent1 + (1 - alpha) * parent2\n        return child\n    \n    def _adaptive_mutate(self, individual, iteration, max_iterations):\n        mutation_strength = np.interp(iteration, [0, max_iterations], [0.1, 0.01])\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] += np.random.normal(0, mutation_strength)\n                individual[i] = np.clip(individual[i], self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n        iteration = 0\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through adaptive crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._adaptive_crossover(parent1, parent2, iteration, self.budget // self.population_size)\n                child2 = self._adaptive_crossover(parent2, parent1, iteration, self.budget // self.population_size)\n\n                child1 = self._adaptive_mutate(child1, iteration, self.budget // self.population_size)\n                child2 = self._adaptive_mutate(child2, iteration, self.budget // self.population_size)\n\n                new_population.append(child1)\n                new_population.append(child2)\n\n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n            iteration += 1\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "Enhanced exploration with adaptive crossover and mutation strategies for improved convergence speed.", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 9 is out of bounds for axis 0 with size 4').", "error": "IndexError('index 9 is out of bounds for axis 0 with size 4')", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "4bcc57e2-b3ba-4b5f-974d-b50b5ed99d3e", "solution": "import numpy as np\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 3\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self, pop_size):\n        return np.random.uniform(self.lb, self.ub, (pop_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness, pop_size):\n        selected = []\n        for _ in range(pop_size):\n            tournament = np.random.choice(pop_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual, adaptive_rate):\n        for i in range(self.dim):\n            if np.random.rand() < adaptive_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.05, 0.05, self.dim) for _ in range(3)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population_size = self.initial_population_size\n        population = self._initialize_population(population_size)\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness, population_size)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            adaptive_mutation_rate = max(0.02, self.mutation_rate * (1 - self.evaluations / self.budget))\n            for i in range(0, population_size, 2):\n                parent1 = population[parents_idx[i % population_size]]\n                parent2 = population[parents_idx[(i+1) % population_size]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1, adaptive_mutation_rate)\n                child2 = self._mutate(child2, adaptive_mutation_rate)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n            # Dynamically adjust population size for diversity\n            population_size = min(self.initial_population_size + (self.evaluations // 100), 40)\n\n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A refined hybrid genetic algorithm enhancing convergence via adaptive mutation rates and dynamic population sizes.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 11 is out of bounds for axis 0 with size 4').", "error": "IndexError('index 11 is out of bounds for axis 0 with size 4')", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "302bd145-a730-4e45-8161-f6f575754998", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "3e3ed1be-998d-4421-85d5-734579d6416b", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "50ce05f8-baef-4cce-89d8-b0cd4e2bb6e5", "solution": "import numpy as np\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.08  # Reduced mutation for more stability\n        self.elite_fraction = 0.25  # Increased elite fraction\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n\n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.05, 0.05, self.dim) for _ in range(3)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n        dynamic_population_size = int(self.population_size / 2)\n\n        while self.evaluations < self.budget:\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            for i in range(0, dynamic_population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[min(i+1, dynamic_population_size-1)]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n\n            new_population = np.array(new_population)\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += dynamic_population_size\n\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n            dynamic_population_size = min(self.population_size, dynamic_population_size + 1)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A refined adaptive genetic algorithm incorporating dynamic population sizing and enhanced local search to accelerate convergence.", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 13 is out of bounds for axis 0 with size 5').", "error": "IndexError('index 13 is out of bounds for axis 0 with size 5')", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "a19cc341-cefd-48d6-9859-577b4dd6ec8e", "solution": "import numpy as np\n\nclass EnhancedHybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, min(self.population_size, 4), replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n\n    def _adaptive_mutate(self, individual):\n        rate = self.mutation_rate * (1 - self.evaluations / self.budget)\n        for i in range(self.dim):\n            if np.random.rand() < rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Dynamic population reduction\n            if self.evaluations / self.budget > 0.5:\n                self.population_size = max(10, int(self.population_size * 0.9))\n            \n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i % len(parents_idx)]]\n                parent2 = population[parents_idx[(i+1) % len(parents_idx)]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._adaptive_mutate(child1)\n                child2 = self._adaptive_mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population[:self.population_size])\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "EnhancedHybridGeneticAlgorithm", "description": "Enhanced Hybrid Genetic Algorithm with Adaptive Mutation and Dynamic Population Strategy for Accelerated Convergence.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 8 is out of bounds for axis 0 with size 4').", "error": "IndexError('index 8 is out of bounds for axis 0 with size 4')", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "7d047f92-e011-4fb9-b7be-673070dcf82d", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "3638a3a4-091d-405e-8b15-3bc470098572", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "a0c45969-8841-42b7-ae5a-21a154e31172", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "fba3869e-0ee2-4418-b54a-42a7bbe25008", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "ad063b8f-d177-4a64-8246-1552f22d5dd4", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "aab05f37-b522-44c3-a480-8318fcf3ed54", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "abcd421d-ea89-4125-a4f0-a4509ef74b02", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n        self.mutation_decay = 0.99  # Added adaptive mutation rate\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, min(self.tournament_size, len(fitness)), replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        self.mutation_rate *= self.mutation_decay  # Decay mutation rate over time\n        return individual\n\n    def _local_search(self, individual, func):\n        search_radius = 0.1 * (self.budget - self.evaluations) / self.budget  # Dynamic local search radius\n        neighbors = [individual + np.random.uniform(-search_radius, search_radius, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "Enhanced a hybrid genetic algorithm with adaptive mutation rate and dynamic local search radius for faster convergence.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 14 is out of bounds for axis 0 with size 4').", "error": "IndexError('index 14 is out of bounds for axis 0 with size 4')", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "f822683e-2acf-4a6d-a64d-07bc0cff64e9", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "528a1c07-871a-4354-912a-de9c75455462", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "f72f0b94-295b-4541-9c12-4667ff2cb251", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "3ee01436-c794-49fd-91c5-cfe96848512f", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "2d186481-9ed7-4b50-a5b0-413511ff302e", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "fdf3092b-7469-474b-a46a-c14853c48bc5", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "db5aa375-f7bc-4078-bb39-37bece7bdbf6", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "4e361c37-70c1-4bb0-8085-67062f39f03e", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.15  # Increased mutation rate for wider exploration\n        self.elite_fraction = 0.3  # Increased elite fraction\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                # Gradually decrease mutation range for convergence improvement\n                individual[i] += np.random.normal(0, 0.05)\n                individual[i] = np.clip(individual[i], self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        mutation_strength = 0.1\n        neighbors = [individual + np.random.uniform(-mutation_strength, mutation_strength, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm enhanced with adaptive mutation and elitism strategies for improved convergence speed.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 12 is out of bounds for axis 0 with size 6').", "error": "IndexError('index 12 is out of bounds for axis 0 with size 6')", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "0bd12559-d350-4c12-a114-90cc1d1ad52b", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "48dca3eb-c7de-4e27-bc6b-f7c03fa11690", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "00653753-cbb1-4742-903f-ae1e80d99e69", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "b103e423-7926-4968-b037-f2ddeb3b3092", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "e38f6f50-42a0-4a15-94fa-d4bc9298d2bc", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "bee248a9-ffd5-4773-b24f-1418b87686d5", "solution": "import numpy as np\nimport random\n\nclass EnhancedGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 3  # Reduced for quicker selection\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        alpha = np.random.uniform(0.3, 0.7, self.dim)  # Blend crossover\n        child = alpha * parent1 + (1 - alpha) * parent2\n        return child\n    \n    def _mutate(self, individual):\n        adaptive_rate = self.mutation_rate * (1 - (self.evaluations / self.budget))\n        for i in range(self.dim):\n            if np.random.rand() < adaptive_rate:\n                individual[i] += np.random.normal(0, 0.1)\n                individual[i] = np.clip(individual[i], self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        step_size = 0.05 * (1 - (self.evaluations / self.budget))  # Dynamic step size\n        neighbors = [individual + np.random.uniform(-step_size, step_size, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "EnhancedGeneticAlgorithm", "description": "Enhanced hybrid genetic algorithm with improved selection, adaptive mutation, and dynamic local search for faster convergence.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 18 is out of bounds for axis 0 with size 4').", "error": "IndexError('index 18 is out of bounds for axis 0 with size 4')", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "69c2ce3d-3a7c-4418-9739-9fbc80e1b6fe", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "ea3e7c36-2bd7-4a9c-a11d-bc2267e516f9", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "cbdcaeb0-60b3-43e0-bf50-f8ebdf4b8b1f", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "6d9fc322-8f30-4dd4-8509-1be523cb0486", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "7a410920-df36-4859-b25f-74521871097e", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "3a31597f-6202-4804-bd95-63dc7883ae7a", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "7b747a4b-6370-4a04-ab5f-034cad7b9f4e", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "eda77c72-543b-40f1-94cd-87caf111c682", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.08  # Adjusted mutation rate for finer control\n        self.elite_fraction = 0.2\n        self.tournament_size = 3  # Reduced tournament size for faster selection pressure\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < 0.8:  # Probability of crossover for diversity\n            crossover_point = np.random.randint(1, self.dim-1)\n            child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        else:\n            child = parent1.copy()  # No crossover, just copy to maintain diversity\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                mutation_strength = np.random.uniform(-0.05, 0.05)  # Decreased mutation strength\n                individual[i] = np.clip(individual[i] + mutation_strength, self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(3)]  # Fewer neighbors for efficiency\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "Enhance genetic algorithm convergence by optimizing mutation dynamics and strategic parent selection.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 8 is out of bounds for axis 0 with size 4').", "error": "IndexError('index 8 is out of bounds for axis 0 with size 4')", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "f2e8b625-35c8-43a1-83f1-9e386e062d22", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "14ed1c01-dd5a-4022-bc19-8cdea5a05f41", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "9bcfafce-a1bb-4f42-af50-1ae69fbb90c6", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "2cf3a05a-b8de-4090-9792-6b3f9f4bbeb5", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "710c0a93-12d4-46fc-8cc6-3ea535c92538", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "134c20c7-e268-4e21-a83b-6aff00857a38", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "d74cfdd5-e2c3-4206-bf06-2d56e6ef56f9", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "5e2683d3-da7e-4856-a92d-f5d07fa69f89", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.3  # Increased elite fraction for better convergence\n        self.tournament_size = 3   # Decreased tournament size for faster selection\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual, iteration, max_iterations):\n        dynamic_mutation_rate = self.mutation_rate * (1 - iteration / max_iterations)  # Dynamic mutation rate\n        for i in range(self.dim):\n            if np.random.rand() < dynamic_mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(4)]  # Reduced neighbors for efficiency\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        iteration = 0\n        max_iterations = self.budget // self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1, iteration, max_iterations)\n                child2 = self._mutate(child2, iteration, max_iterations)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n            \n            iteration += 1\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with dynamic mutation rate and elitism strategy to enhance convergence speed and solution quality.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 13 is out of bounds for axis 0 with size 6').", "error": "IndexError('index 13 is out of bounds for axis 0 with size 6')", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "4124d3bb-81e6-4c3b-bdd8-a978b74a370c", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "2b79c941-3f71-46aa-95c9-f045b044f55d", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "1d54f62a-9399-4f63-b3cb-90e048e4897f", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 3  # Reduced tournament size to promote diversity\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        alpha = np.random.uniform(0.4, 0.6)  # Blend crossover for better exploration\n        child = alpha * parent1 + (1 - alpha) * parent2\n        return child\n    \n    def _mutate(self, individual):\n        adaptive_mutation_rate = self.mutation_rate * (1 - self.evaluations / self.budget)\n        for i in range(self.dim):\n            if np.random.rand() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(3)]  # Fewer neighbors to save budget\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n            # Migrate best elite to the rest of the population\n            if self.evaluations < self.budget:\n                best_elite = population[np.argmin(fitness[:elite_count])]\n                for i in range(elite_count, self.population_size):\n                    population[i] = best_elite + np.random.normal(0, 0.1, self.dim)\n                    population[i] = np.clip(population[i], self.lb, self.ub)\n                    fitness[i] = func(population[i])\n                    self.evaluations += 1\n                    if self.evaluations >= self.budget:\n                        break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "Enhanced hybrid genetic algorithm with adaptive mutation and elite migration for improved convergence speed.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 4 is out of bounds for axis 0 with size 4').", "error": "IndexError('index 4 is out of bounds for axis 0 with size 4')", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "2e56124a-98ed-485a-8604-767046fdf772", "solution": "import numpy as np\nimport random\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        crossover_point = np.random.randint(1, self.dim-1)\n        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        return child\n    \n    def _mutate(self, individual):\n        for i in range(self.dim):\n            if np.random.rand() < self.mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        # Initialize population\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        while self.evaluations < self.budget:\n            # Select parents\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            # Generate new population through crossover and mutation\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1)\n                child2 = self._mutate(child2)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            # Evaluate new population\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            # Combine old and new population and select elites\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:elite_count]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            # Apply local search on elites\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n        \n        # Return best found solution\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "A hybrid adaptive genetic algorithm with local search refinements for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {}, "mutation_prompt": null}
{"id": "ba0ad45e-79a5-497a-a152-a00347f6aeec", "solution": "import numpy as np\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        if np.random.rand() > 0.5:\n            crossover_point = np.random.randint(1, self.dim-1)\n            child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        else:\n            alpha = np.random.rand(self.dim)\n            child = alpha * parent1 + (1 - alpha) * parent2\n        return child\n    \n    def _mutate(self, individual, generation):\n        adaptive_mutation_rate = self.mutation_rate * (1 - generation / self.budget)\n        for i in range(self.dim):\n            if np.random.rand() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n        generation = 0\n\n        while self.evaluations < self.budget:\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1, generation)\n                child2 = self._mutate(child2, generation)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n            generation += 1\n        \n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "An enhanced hybrid genetic algorithm utilizing adaptive mutation rates and elite replacement for faster convergence.", "configspace": "", "generation": 66, "fitness": 0.23060251109720634, "feedback": "The algorithm HybridGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "cf33d5d8-7fde-4849-be58-03b035d98a19", "metadata": {"aucs": [0.5188767331596345, 0.5064088709886925, 0.529496447239648, 0.5144420539623902, 0.5370488447429549, 0.5112964000634398, 0.5443189240093997, 0.5151759905658304, 0.5295974625296624, 0.11628763434397549, 0.073237962137081, 0.1171960218681154, 0.1328054441372537, 0.06734962385719301, 0.18702089088395346, 0.11794777197766848, 0.16142451141806613, 0.09479736946696471, 0.13340173656759524, 0.11187463710972767, 0.13141237757711532, 0.13803893579674764, 0.14700684185232926, 0.23298106805301155, 0.15599881259017334, 0.13753294373569147, 0.14748159785705617, 0.10876875324652024, 0.1199588748125876, 0.11442623443949529, 0.1376682920812753, 0.10753935447249918, 0.11529412838556907, 0.14411587550759053, 0.12631171847284206, 0.09899476319301614, 0.8657788659263602, 0.8708037771669245, 0.8456890545782719, 0.852582574405035, 0.8831960734694649, 0.8854751829924894, 0.8679232429229845, 0.9140837729660892, 0.9015444725811272, 0.3568268521148178, 0.34169183216634236, 0.3275012350470019, 0.3020994963658874, 0.3330206291499205, 0.3610407508786032, 0.33862374062362166, 0.3033525987268578, 0.29969884168468375, 0.1565724305817624, 0.24612530080806716, 0.1426010858307345, 0.2145150807661389, 0.26942187158728426, 0.35259656298456443, 0.15752276978004842, 0.23846888290241963, 0.1995849784012269, 0.17774147063968737, 0.1654716515977942, 0.17840744983435375, 0.15724909282867372, 0.20144777914869705, 0.17030827069467014, 0.16330246182093688, 0.24655007798684248, 0.3514770322958348, 0.14225247094640325, 0.13435904494185447, 0.17037749954018255, 0.16814900747676498, 0.2131401520323899, 0.15134788406363442, 0.14338955739022818, 0.29561775046554084, 0.15586750501445734, 9.999999999998899e-05, 9.999999999998899e-05, 0.0035166480994790472, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06961805886886052, 0.025233134646751365, 0.06903749483907706, 0.05645912279153509, 0.023355064750135157, 0.007827625196492938, 0.11200956379572746, 0.06318894312464596, 0.07997994142271458, 0.006665368751889056, 0.01157989821538663, 0.0017879740169762792, 0.00037159721867408013, 0.014947521855188661, 0.00412625368969477, 9.999999999998899e-05, 0.017349969084643257, 0.0288434555395799, 0.11476562071290586, 0.09215900389490728, 0.1390202896632774, 0.10268411211077477, 0.15948143646883395, 0.05918458680430527, 0.1635227025727929, 0.1255441073180733, 0.08405591483482644, 0.4897452909625738, 0.468474821918648, 0.4482336644336633, 0.46810298655440497, 0.4340659450409212, 0.46357283616222056, 0.4808855253363665, 0.4599415934511112, 0.4624649242993303, 0.09612734276923707, 0.09116039412042976, 0.04977867560294946, 0.1898093805089569, 0.10496876212120221, 0.06321529017138294, 0.07345975748157285, 0.07668599384362873, 0.10252236141264515, 0.24700017564221022, 0.2446872303976746, 0.22846517531484667, 0.31439445608657246, 0.2839388691347797, 0.1889649936153983, 0.25740041441158334, 0.18576644935792974, 0.21280984219620136, 0.21531507504464076, 0.20831586277199543, 0.15805015565264835, 0.2224181463999947, 0.22630207944566505, 0.24714886348589782, 0.3333252362352441, 0.344323674464301, 0.3200394607320015, 0.18958770263436542, 0.2653879417765064, 0.2140139407956907, 0.22514312964500183, 0.19190956803712, 0.21345436527623785, 0.18053751764889692, 0.27381120341821585, 0.24499272608489986, 0.2655839730192584, 0.2551418397180554, 0.20957167420847034, 0.19588568342895574, 0.17548267970119247, 0.23386637959141454, 0.20526428858870627, 0.2081861724669316, 0.20663037237230641, 0.21114615850956675, 0.20210698859591936, 0.1992334651046238, 0.19377810514516836, 0.1824560207628787, 0.21544272153051447, 0.19972876917705684, 0.18556784259466508, 0.17953088823492835, 0.11672352782602902, 0.12712245852129767, 0.15365179749505953, 0.7952637986062888, 0.7358143023317176, 0.7555169639492753, 0.15403889412227878, 0.16968212653933712, 0.15023210862774394, 0.14938982545497348, 0.5345065084217684, 0.3925973379115292, 0.501162113080057, 0.21411065416242636, 0.2127683016083336, 0.105237221246827, 0.5403138581297193, 0.36233078815169917, 0.18154529264887365, 0.19034695359780784, 0.18705007118961925, 0.18731944499283237, 0.18862450994714908, 0.181368886160578, 0.17684088976439394, 0.18598429030599295, 0.18143220521539383, 0.10188353392374716, 0.07538361466450083, 0.07502758819782429, 0.08189984021125563, 0.07672220611827174, 0.07808450200416772, 0.1002375240971789, 0.09321245465027461, 0.07584274895336707]}, "mutation_prompt": null}
{"id": "87d98a4a-280d-4156-8a16-dcfe9dbb584a", "solution": "import numpy as np\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        if np.random.rand() > 0.5:\n            crossover_point = np.random.randint(1, self.dim-1)\n            child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        else:\n            alpha = np.random.rand(self.dim)\n            child = alpha * parent1 + (1 - alpha) * parent2\n        return child\n    \n    def _mutate(self, individual, generation):\n        adaptive_mutation_rate = self.mutation_rate * (1 - generation / self.budget)\n        for i in range(self.dim):\n            if np.random.rand() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n        generation = 0\n\n        while self.evaluations < self.budget:\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1, generation)\n                child2 = self._mutate(child2, generation)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n            generation += 1\n        \n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "An enhanced hybrid genetic algorithm utilizing adaptive mutation rates and elite replacement for faster convergence.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ba0ad45e-79a5-497a-a152-a00347f6aeec", "metadata": {"aucs": [0.5188767331596345, 0.5064088709886925, 0.529496447239648, 0.5144420539623902, 0.5370488447429549, 0.5112964000634398, 0.5443189240093997, 0.5151759905658304, 0.5295974625296624, 0.11628763434397549, 0.073237962137081, 0.1171960218681154, 0.1328054441372537, 0.06734962385719301, 0.18702089088395346, 0.11794777197766848, 0.16142451141806613, 0.09479736946696471, 0.13340173656759524, 0.11187463710972767, 0.13141237757711532, 0.13803893579674764, 0.14700684185232926, 0.23298106805301155, 0.15599881259017334, 0.13753294373569147, 0.14748159785705617, 0.10876875324652024, 0.1199588748125876, 0.11442623443949529, 0.1376682920812753, 0.10753935447249918, 0.11529412838556907, 0.14411587550759053, 0.12631171847284206, 0.09899476319301614, 0.8657788659263602, 0.8708037771669245, 0.8456890545782719, 0.852582574405035, 0.8831960734694649, 0.8854751829924894, 0.8679232429229845, 0.9140837729660892, 0.9015444725811272, 0.3568268521148178, 0.34169183216634236, 0.3275012350470019, 0.3020994963658874, 0.3330206291499205, 0.3610407508786032, 0.33862374062362166, 0.3033525987268578, 0.29969884168468375, 0.1565724305817624, 0.24612530080806716, 0.1426010858307345, 0.2145150807661389, 0.26942187158728426, 0.35259656298456443, 0.15752276978004842, 0.23846888290241963, 0.1995849784012269, 0.17774147063968737, 0.1654716515977942, 0.17840744983435375, 0.15724909282867372, 0.20144777914869705, 0.17030827069467014, 0.16330246182093688, 0.24655007798684248, 0.3514770322958348, 0.14225247094640325, 0.13435904494185447, 0.17037749954018255, 0.16814900747676498, 0.2131401520323899, 0.15134788406363442, 0.14338955739022818, 0.29561775046554084, 0.15586750501445734, 9.999999999998899e-05, 9.999999999998899e-05, 0.0035166480994790472, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06961805886886052, 0.025233134646751365, 0.06903749483907706, 0.05645912279153509, 0.023355064750135157, 0.007827625196492938, 0.11200956379572746, 0.06318894312464596, 0.07997994142271458, 0.006665368751889056, 0.01157989821538663, 0.0017879740169762792, 0.00037159721867408013, 0.014947521855188661, 0.00412625368969477, 9.999999999998899e-05, 0.017349969084643257, 0.0288434555395799, 0.11476562071290586, 0.09215900389490728, 0.1390202896632774, 0.10268411211077477, 0.15948143646883395, 0.05918458680430527, 0.1635227025727929, 0.1255441073180733, 0.08405591483482644, 0.4897452909625738, 0.468474821918648, 0.4482336644336633, 0.46810298655440497, 0.4340659450409212, 0.46357283616222056, 0.4808855253363665, 0.4599415934511112, 0.4624649242993303, 0.09612734276923707, 0.09116039412042976, 0.04977867560294946, 0.1898093805089569, 0.10496876212120221, 0.06321529017138294, 0.07345975748157285, 0.07668599384362873, 0.10252236141264515, 0.24700017564221022, 0.2446872303976746, 0.22846517531484667, 0.31439445608657246, 0.2839388691347797, 0.1889649936153983, 0.25740041441158334, 0.18576644935792974, 0.21280984219620136, 0.21531507504464076, 0.20831586277199543, 0.15805015565264835, 0.2224181463999947, 0.22630207944566505, 0.24714886348589782, 0.3333252362352441, 0.344323674464301, 0.3200394607320015, 0.18958770263436542, 0.2653879417765064, 0.2140139407956907, 0.22514312964500183, 0.19190956803712, 0.21345436527623785, 0.18053751764889692, 0.27381120341821585, 0.24499272608489986, 0.2655839730192584, 0.2551418397180554, 0.20957167420847034, 0.19588568342895574, 0.17548267970119247, 0.23386637959141454, 0.20526428858870627, 0.2081861724669316, 0.20663037237230641, 0.21114615850956675, 0.20210698859591936, 0.1992334651046238, 0.19377810514516836, 0.1824560207628787, 0.21544272153051447, 0.19972876917705684, 0.18556784259466508, 0.17953088823492835, 0.11672352782602902, 0.12712245852129767, 0.15365179749505953, 0.7952637986062888, 0.7358143023317176, 0.7555169639492753, 0.15403889412227878, 0.16968212653933712, 0.15023210862774394, 0.14938982545497348, 0.5345065084217684, 0.3925973379115292, 0.501162113080057, 0.21411065416242636, 0.2127683016083336, 0.105237221246827, 0.5403138581297193, 0.36233078815169917, 0.18154529264887365, 0.19034695359780784, 0.18705007118961925, 0.18731944499283237, 0.18862450994714908, 0.181368886160578, 0.17684088976439394, 0.18598429030599295, 0.18143220521539383, 0.10188353392374716, 0.07538361466450083, 0.07502758819782429, 0.08189984021125563, 0.07672220611827174, 0.07808450200416772, 0.1002375240971789, 0.09321245465027461, 0.07584274895336707]}, "mutation_prompt": null}
{"id": "ea695c7b-8345-4b8a-b4a7-d75fb6e5ecaa", "solution": "import numpy as np\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        if np.random.rand() > 0.5:\n            crossover_point = np.random.randint(1, self.dim-1)\n            child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        else:\n            alpha = np.random.rand(self.dim)\n            child = alpha * parent1 + (1 - alpha) * parent2\n        return child\n    \n    def _mutate(self, individual, generation):\n        adaptive_mutation_rate = self.mutation_rate * (1 - generation / self.budget)\n        for i in range(self.dim):\n            if np.random.rand() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n        generation = 0\n\n        while self.evaluations < self.budget:\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1, generation)\n                child2 = self._mutate(child2, generation)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n            generation += 1\n        \n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "An enhanced hybrid genetic algorithm utilizing adaptive mutation rates and elite replacement for faster convergence.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ba0ad45e-79a5-497a-a152-a00347f6aeec", "metadata": {"aucs": [0.5188767331596345, 0.5064088709886925, 0.529496447239648, 0.5144420539623902, 0.5370488447429549, 0.5112964000634398, 0.5443189240093997, 0.5151759905658304, 0.5295974625296624, 0.11628763434397549, 0.073237962137081, 0.1171960218681154, 0.1328054441372537, 0.06734962385719301, 0.18702089088395346, 0.11794777197766848, 0.16142451141806613, 0.09479736946696471, 0.13340173656759524, 0.11187463710972767, 0.13141237757711532, 0.13803893579674764, 0.14700684185232926, 0.23298106805301155, 0.15599881259017334, 0.13753294373569147, 0.14748159785705617, 0.10876875324652024, 0.1199588748125876, 0.11442623443949529, 0.1376682920812753, 0.10753935447249918, 0.11529412838556907, 0.14411587550759053, 0.12631171847284206, 0.09899476319301614, 0.8657788659263602, 0.8708037771669245, 0.8456890545782719, 0.852582574405035, 0.8831960734694649, 0.8854751829924894, 0.8679232429229845, 0.9140837729660892, 0.9015444725811272, 0.3568268521148178, 0.34169183216634236, 0.3275012350470019, 0.3020994963658874, 0.3330206291499205, 0.3610407508786032, 0.33862374062362166, 0.3033525987268578, 0.29969884168468375, 0.1565724305817624, 0.24612530080806716, 0.1426010858307345, 0.2145150807661389, 0.26942187158728426, 0.35259656298456443, 0.15752276978004842, 0.23846888290241963, 0.1995849784012269, 0.17774147063968737, 0.1654716515977942, 0.17840744983435375, 0.15724909282867372, 0.20144777914869705, 0.17030827069467014, 0.16330246182093688, 0.24655007798684248, 0.3514770322958348, 0.14225247094640325, 0.13435904494185447, 0.17037749954018255, 0.16814900747676498, 0.2131401520323899, 0.15134788406363442, 0.14338955739022818, 0.29561775046554084, 0.15586750501445734, 9.999999999998899e-05, 9.999999999998899e-05, 0.0035166480994790472, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06961805886886052, 0.025233134646751365, 0.06903749483907706, 0.05645912279153509, 0.023355064750135157, 0.007827625196492938, 0.11200956379572746, 0.06318894312464596, 0.07997994142271458, 0.006665368751889056, 0.01157989821538663, 0.0017879740169762792, 0.00037159721867408013, 0.014947521855188661, 0.00412625368969477, 9.999999999998899e-05, 0.017349969084643257, 0.0288434555395799, 0.11476562071290586, 0.09215900389490728, 0.1390202896632774, 0.10268411211077477, 0.15948143646883395, 0.05918458680430527, 0.1635227025727929, 0.1255441073180733, 0.08405591483482644, 0.4897452909625738, 0.468474821918648, 0.4482336644336633, 0.46810298655440497, 0.4340659450409212, 0.46357283616222056, 0.4808855253363665, 0.4599415934511112, 0.4624649242993303, 0.09612734276923707, 0.09116039412042976, 0.04977867560294946, 0.1898093805089569, 0.10496876212120221, 0.06321529017138294, 0.07345975748157285, 0.07668599384362873, 0.10252236141264515, 0.24700017564221022, 0.2446872303976746, 0.22846517531484667, 0.31439445608657246, 0.2839388691347797, 0.1889649936153983, 0.25740041441158334, 0.18576644935792974, 0.21280984219620136, 0.21531507504464076, 0.20831586277199543, 0.15805015565264835, 0.2224181463999947, 0.22630207944566505, 0.24714886348589782, 0.3333252362352441, 0.344323674464301, 0.3200394607320015, 0.18958770263436542, 0.2653879417765064, 0.2140139407956907, 0.22514312964500183, 0.19190956803712, 0.21345436527623785, 0.18053751764889692, 0.27381120341821585, 0.24499272608489986, 0.2655839730192584, 0.2551418397180554, 0.20957167420847034, 0.19588568342895574, 0.17548267970119247, 0.23386637959141454, 0.20526428858870627, 0.2081861724669316, 0.20663037237230641, 0.21114615850956675, 0.20210698859591936, 0.1992334651046238, 0.19377810514516836, 0.1824560207628787, 0.21544272153051447, 0.19972876917705684, 0.18556784259466508, 0.17953088823492835, 0.11672352782602902, 0.12712245852129767, 0.15365179749505953, 0.7952637986062888, 0.7358143023317176, 0.7555169639492753, 0.15403889412227878, 0.16968212653933712, 0.15023210862774394, 0.14938982545497348, 0.5345065084217684, 0.3925973379115292, 0.501162113080057, 0.21411065416242636, 0.2127683016083336, 0.105237221246827, 0.5403138581297193, 0.36233078815169917, 0.18154529264887365, 0.19034695359780784, 0.18705007118961925, 0.18731944499283237, 0.18862450994714908, 0.181368886160578, 0.17684088976439394, 0.18598429030599295, 0.18143220521539383, 0.10188353392374716, 0.07538361466450083, 0.07502758819782429, 0.08189984021125563, 0.07672220611827174, 0.07808450200416772, 0.1002375240971789, 0.09321245465027461, 0.07584274895336707]}, "mutation_prompt": null}
{"id": "aec3eeca-fca7-4530-8f87-95e0286ef48d", "solution": "import numpy as np\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        if np.random.rand() > 0.5:\n            crossover_point = np.random.randint(1, self.dim-1)\n            child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        else:\n            alpha = np.random.rand(self.dim)\n            child = alpha * parent1 + (1 - alpha) * parent2\n        return child\n    \n    def _mutate(self, individual, generation):\n        adaptive_mutation_rate = self.mutation_rate * (1 - generation / self.budget)\n        for i in range(self.dim):\n            if np.random.rand() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n        generation = 0\n\n        while self.evaluations < self.budget:\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1, generation)\n                child2 = self._mutate(child2, generation)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n            generation += 1\n        \n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "An enhanced hybrid genetic algorithm utilizing adaptive mutation rates and elite replacement for faster convergence.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ba0ad45e-79a5-497a-a152-a00347f6aeec", "metadata": {"aucs": [0.5188767331596345, 0.5064088709886925, 0.529496447239648, 0.5144420539623902, 0.5370488447429549, 0.5112964000634398, 0.5443189240093997, 0.5151759905658304, 0.5295974625296624, 0.11628763434397549, 0.073237962137081, 0.1171960218681154, 0.1328054441372537, 0.06734962385719301, 0.18702089088395346, 0.11794777197766848, 0.16142451141806613, 0.09479736946696471, 0.13340173656759524, 0.11187463710972767, 0.13141237757711532, 0.13803893579674764, 0.14700684185232926, 0.23298106805301155, 0.15599881259017334, 0.13753294373569147, 0.14748159785705617, 0.10876875324652024, 0.1199588748125876, 0.11442623443949529, 0.1376682920812753, 0.10753935447249918, 0.11529412838556907, 0.14411587550759053, 0.12631171847284206, 0.09899476319301614, 0.8657788659263602, 0.8708037771669245, 0.8456890545782719, 0.852582574405035, 0.8831960734694649, 0.8854751829924894, 0.8679232429229845, 0.9140837729660892, 0.9015444725811272, 0.3568268521148178, 0.34169183216634236, 0.3275012350470019, 0.3020994963658874, 0.3330206291499205, 0.3610407508786032, 0.33862374062362166, 0.3033525987268578, 0.29969884168468375, 0.1565724305817624, 0.24612530080806716, 0.1426010858307345, 0.2145150807661389, 0.26942187158728426, 0.35259656298456443, 0.15752276978004842, 0.23846888290241963, 0.1995849784012269, 0.17774147063968737, 0.1654716515977942, 0.17840744983435375, 0.15724909282867372, 0.20144777914869705, 0.17030827069467014, 0.16330246182093688, 0.24655007798684248, 0.3514770322958348, 0.14225247094640325, 0.13435904494185447, 0.17037749954018255, 0.16814900747676498, 0.2131401520323899, 0.15134788406363442, 0.14338955739022818, 0.29561775046554084, 0.15586750501445734, 9.999999999998899e-05, 9.999999999998899e-05, 0.0035166480994790472, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06961805886886052, 0.025233134646751365, 0.06903749483907706, 0.05645912279153509, 0.023355064750135157, 0.007827625196492938, 0.11200956379572746, 0.06318894312464596, 0.07997994142271458, 0.006665368751889056, 0.01157989821538663, 0.0017879740169762792, 0.00037159721867408013, 0.014947521855188661, 0.00412625368969477, 9.999999999998899e-05, 0.017349969084643257, 0.0288434555395799, 0.11476562071290586, 0.09215900389490728, 0.1390202896632774, 0.10268411211077477, 0.15948143646883395, 0.05918458680430527, 0.1635227025727929, 0.1255441073180733, 0.08405591483482644, 0.4897452909625738, 0.468474821918648, 0.4482336644336633, 0.46810298655440497, 0.4340659450409212, 0.46357283616222056, 0.4808855253363665, 0.4599415934511112, 0.4624649242993303, 0.09612734276923707, 0.09116039412042976, 0.04977867560294946, 0.1898093805089569, 0.10496876212120221, 0.06321529017138294, 0.07345975748157285, 0.07668599384362873, 0.10252236141264515, 0.24700017564221022, 0.2446872303976746, 0.22846517531484667, 0.31439445608657246, 0.2839388691347797, 0.1889649936153983, 0.25740041441158334, 0.18576644935792974, 0.21280984219620136, 0.21531507504464076, 0.20831586277199543, 0.15805015565264835, 0.2224181463999947, 0.22630207944566505, 0.24714886348589782, 0.3333252362352441, 0.344323674464301, 0.3200394607320015, 0.18958770263436542, 0.2653879417765064, 0.2140139407956907, 0.22514312964500183, 0.19190956803712, 0.21345436527623785, 0.18053751764889692, 0.27381120341821585, 0.24499272608489986, 0.2655839730192584, 0.2551418397180554, 0.20957167420847034, 0.19588568342895574, 0.17548267970119247, 0.23386637959141454, 0.20526428858870627, 0.2081861724669316, 0.20663037237230641, 0.21114615850956675, 0.20210698859591936, 0.1992334651046238, 0.19377810514516836, 0.1824560207628787, 0.21544272153051447, 0.19972876917705684, 0.18556784259466508, 0.17953088823492835, 0.11672352782602902, 0.12712245852129767, 0.15365179749505953, 0.7952637986062888, 0.7358143023317176, 0.7555169639492753, 0.15403889412227878, 0.16968212653933712, 0.15023210862774394, 0.14938982545497348, 0.5345065084217684, 0.3925973379115292, 0.501162113080057, 0.21411065416242636, 0.2127683016083336, 0.105237221246827, 0.5403138581297193, 0.36233078815169917, 0.18154529264887365, 0.19034695359780784, 0.18705007118961925, 0.18731944499283237, 0.18862450994714908, 0.181368886160578, 0.17684088976439394, 0.18598429030599295, 0.18143220521539383, 0.10188353392374716, 0.07538361466450083, 0.07502758819782429, 0.08189984021125563, 0.07672220611827174, 0.07808450200416772, 0.1002375240971789, 0.09321245465027461, 0.07584274895336707]}, "mutation_prompt": null}
{"id": "749c5b87-50e2-4f5a-a504-7698f5fc9931", "solution": "import numpy as np\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        if np.random.rand() > 0.5:\n            crossover_point = np.random.randint(1, self.dim-1)\n            child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        else:\n            alpha = np.random.rand(self.dim)\n            child = alpha * parent1 + (1 - alpha) * parent2\n        return child\n    \n    def _mutate(self, individual, generation):\n        adaptive_mutation_rate = self.mutation_rate * (1 - generation / self.budget)\n        for i in range(self.dim):\n            if np.random.rand() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n        generation = 0\n\n        while self.evaluations < self.budget:\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1, generation)\n                child2 = self._mutate(child2, generation)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n            generation += 1\n        \n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "An enhanced hybrid genetic algorithm utilizing adaptive mutation rates and elite replacement for faster convergence.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ba0ad45e-79a5-497a-a152-a00347f6aeec", "metadata": {"aucs": [0.5188767331596345, 0.5064088709886925, 0.529496447239648, 0.5144420539623902, 0.5370488447429549, 0.5112964000634398, 0.5443189240093997, 0.5151759905658304, 0.5295974625296624, 0.11628763434397549, 0.073237962137081, 0.1171960218681154, 0.1328054441372537, 0.06734962385719301, 0.18702089088395346, 0.11794777197766848, 0.16142451141806613, 0.09479736946696471, 0.13340173656759524, 0.11187463710972767, 0.13141237757711532, 0.13803893579674764, 0.14700684185232926, 0.23298106805301155, 0.15599881259017334, 0.13753294373569147, 0.14748159785705617, 0.10876875324652024, 0.1199588748125876, 0.11442623443949529, 0.1376682920812753, 0.10753935447249918, 0.11529412838556907, 0.14411587550759053, 0.12631171847284206, 0.09899476319301614, 0.8657788659263602, 0.8708037771669245, 0.8456890545782719, 0.852582574405035, 0.8831960734694649, 0.8854751829924894, 0.8679232429229845, 0.9140837729660892, 0.9015444725811272, 0.3568268521148178, 0.34169183216634236, 0.3275012350470019, 0.3020994963658874, 0.3330206291499205, 0.3610407508786032, 0.33862374062362166, 0.3033525987268578, 0.29969884168468375, 0.1565724305817624, 0.24612530080806716, 0.1426010858307345, 0.2145150807661389, 0.26942187158728426, 0.35259656298456443, 0.15752276978004842, 0.23846888290241963, 0.1995849784012269, 0.17774147063968737, 0.1654716515977942, 0.17840744983435375, 0.15724909282867372, 0.20144777914869705, 0.17030827069467014, 0.16330246182093688, 0.24655007798684248, 0.3514770322958348, 0.14225247094640325, 0.13435904494185447, 0.17037749954018255, 0.16814900747676498, 0.2131401520323899, 0.15134788406363442, 0.14338955739022818, 0.29561775046554084, 0.15586750501445734, 9.999999999998899e-05, 9.999999999998899e-05, 0.0035166480994790472, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06961805886886052, 0.025233134646751365, 0.06903749483907706, 0.05645912279153509, 0.023355064750135157, 0.007827625196492938, 0.11200956379572746, 0.06318894312464596, 0.07997994142271458, 0.006665368751889056, 0.01157989821538663, 0.0017879740169762792, 0.00037159721867408013, 0.014947521855188661, 0.00412625368969477, 9.999999999998899e-05, 0.017349969084643257, 0.0288434555395799, 0.11476562071290586, 0.09215900389490728, 0.1390202896632774, 0.10268411211077477, 0.15948143646883395, 0.05918458680430527, 0.1635227025727929, 0.1255441073180733, 0.08405591483482644, 0.4897452909625738, 0.468474821918648, 0.4482336644336633, 0.46810298655440497, 0.4340659450409212, 0.46357283616222056, 0.4808855253363665, 0.4599415934511112, 0.4624649242993303, 0.09612734276923707, 0.09116039412042976, 0.04977867560294946, 0.1898093805089569, 0.10496876212120221, 0.06321529017138294, 0.07345975748157285, 0.07668599384362873, 0.10252236141264515, 0.24700017564221022, 0.2446872303976746, 0.22846517531484667, 0.31439445608657246, 0.2839388691347797, 0.1889649936153983, 0.25740041441158334, 0.18576644935792974, 0.21280984219620136, 0.21531507504464076, 0.20831586277199543, 0.15805015565264835, 0.2224181463999947, 0.22630207944566505, 0.24714886348589782, 0.3333252362352441, 0.344323674464301, 0.3200394607320015, 0.18958770263436542, 0.2653879417765064, 0.2140139407956907, 0.22514312964500183, 0.19190956803712, 0.21345436527623785, 0.18053751764889692, 0.27381120341821585, 0.24499272608489986, 0.2655839730192584, 0.2551418397180554, 0.20957167420847034, 0.19588568342895574, 0.17548267970119247, 0.23386637959141454, 0.20526428858870627, 0.2081861724669316, 0.20663037237230641, 0.21114615850956675, 0.20210698859591936, 0.1992334651046238, 0.19377810514516836, 0.1824560207628787, 0.21544272153051447, 0.19972876917705684, 0.18556784259466508, 0.17953088823492835, 0.11672352782602902, 0.12712245852129767, 0.15365179749505953, 0.7952637986062888, 0.7358143023317176, 0.7555169639492753, 0.15403889412227878, 0.16968212653933712, 0.15023210862774394, 0.14938982545497348, 0.5345065084217684, 0.3925973379115292, 0.501162113080057, 0.21411065416242636, 0.2127683016083336, 0.105237221246827, 0.5403138581297193, 0.36233078815169917, 0.18154529264887365, 0.19034695359780784, 0.18705007118961925, 0.18731944499283237, 0.18862450994714908, 0.181368886160578, 0.17684088976439394, 0.18598429030599295, 0.18143220521539383, 0.10188353392374716, 0.07538361466450083, 0.07502758819782429, 0.08189984021125563, 0.07672220611827174, 0.07808450200416772, 0.1002375240971789, 0.09321245465027461, 0.07584274895336707]}, "mutation_prompt": null}
{"id": "c7e9efdd-7517-475b-a186-2cc775fa1399", "solution": "import numpy as np\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        if np.random.rand() > 0.5:\n            crossover_point = np.random.randint(1, self.dim-1)\n            child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        else:\n            alpha = np.random.rand(self.dim)\n            child = alpha * parent1 + (1 - alpha) * parent2\n        return child\n    \n    def _mutate(self, individual, generation):\n        adaptive_mutation_rate = self.mutation_rate * (1 - generation / self.budget)\n        for i in range(self.dim):\n            if np.random.rand() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n        generation = 0\n\n        while self.evaluations < self.budget:\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1, generation)\n                child2 = self._mutate(child2, generation)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n            generation += 1\n        \n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "An enhanced hybrid genetic algorithm utilizing adaptive mutation rates and elite replacement for faster convergence.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ba0ad45e-79a5-497a-a152-a00347f6aeec", "metadata": {"aucs": [0.5188767331596345, 0.5064088709886925, 0.529496447239648, 0.5144420539623902, 0.5370488447429549, 0.5112964000634398, 0.5443189240093997, 0.5151759905658304, 0.5295974625296624, 0.11628763434397549, 0.073237962137081, 0.1171960218681154, 0.1328054441372537, 0.06734962385719301, 0.18702089088395346, 0.11794777197766848, 0.16142451141806613, 0.09479736946696471, 0.13340173656759524, 0.11187463710972767, 0.13141237757711532, 0.13803893579674764, 0.14700684185232926, 0.23298106805301155, 0.15599881259017334, 0.13753294373569147, 0.14748159785705617, 0.10876875324652024, 0.1199588748125876, 0.11442623443949529, 0.1376682920812753, 0.10753935447249918, 0.11529412838556907, 0.14411587550759053, 0.12631171847284206, 0.09899476319301614, 0.8657788659263602, 0.8708037771669245, 0.8456890545782719, 0.852582574405035, 0.8831960734694649, 0.8854751829924894, 0.8679232429229845, 0.9140837729660892, 0.9015444725811272, 0.3568268521148178, 0.34169183216634236, 0.3275012350470019, 0.3020994963658874, 0.3330206291499205, 0.3610407508786032, 0.33862374062362166, 0.3033525987268578, 0.29969884168468375, 0.1565724305817624, 0.24612530080806716, 0.1426010858307345, 0.2145150807661389, 0.26942187158728426, 0.35259656298456443, 0.15752276978004842, 0.23846888290241963, 0.1995849784012269, 0.17774147063968737, 0.1654716515977942, 0.17840744983435375, 0.15724909282867372, 0.20144777914869705, 0.17030827069467014, 0.16330246182093688, 0.24655007798684248, 0.3514770322958348, 0.14225247094640325, 0.13435904494185447, 0.17037749954018255, 0.16814900747676498, 0.2131401520323899, 0.15134788406363442, 0.14338955739022818, 0.29561775046554084, 0.15586750501445734, 9.999999999998899e-05, 9.999999999998899e-05, 0.0035166480994790472, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06961805886886052, 0.025233134646751365, 0.06903749483907706, 0.05645912279153509, 0.023355064750135157, 0.007827625196492938, 0.11200956379572746, 0.06318894312464596, 0.07997994142271458, 0.006665368751889056, 0.01157989821538663, 0.0017879740169762792, 0.00037159721867408013, 0.014947521855188661, 0.00412625368969477, 9.999999999998899e-05, 0.017349969084643257, 0.0288434555395799, 0.11476562071290586, 0.09215900389490728, 0.1390202896632774, 0.10268411211077477, 0.15948143646883395, 0.05918458680430527, 0.1635227025727929, 0.1255441073180733, 0.08405591483482644, 0.4897452909625738, 0.468474821918648, 0.4482336644336633, 0.46810298655440497, 0.4340659450409212, 0.46357283616222056, 0.4808855253363665, 0.4599415934511112, 0.4624649242993303, 0.09612734276923707, 0.09116039412042976, 0.04977867560294946, 0.1898093805089569, 0.10496876212120221, 0.06321529017138294, 0.07345975748157285, 0.07668599384362873, 0.10252236141264515, 0.24700017564221022, 0.2446872303976746, 0.22846517531484667, 0.31439445608657246, 0.2839388691347797, 0.1889649936153983, 0.25740041441158334, 0.18576644935792974, 0.21280984219620136, 0.21531507504464076, 0.20831586277199543, 0.15805015565264835, 0.2224181463999947, 0.22630207944566505, 0.24714886348589782, 0.3333252362352441, 0.344323674464301, 0.3200394607320015, 0.18958770263436542, 0.2653879417765064, 0.2140139407956907, 0.22514312964500183, 0.19190956803712, 0.21345436527623785, 0.18053751764889692, 0.27381120341821585, 0.24499272608489986, 0.2655839730192584, 0.2551418397180554, 0.20957167420847034, 0.19588568342895574, 0.17548267970119247, 0.23386637959141454, 0.20526428858870627, 0.2081861724669316, 0.20663037237230641, 0.21114615850956675, 0.20210698859591936, 0.1992334651046238, 0.19377810514516836, 0.1824560207628787, 0.21544272153051447, 0.19972876917705684, 0.18556784259466508, 0.17953088823492835, 0.11672352782602902, 0.12712245852129767, 0.15365179749505953, 0.7952637986062888, 0.7358143023317176, 0.7555169639492753, 0.15403889412227878, 0.16968212653933712, 0.15023210862774394, 0.14938982545497348, 0.5345065084217684, 0.3925973379115292, 0.501162113080057, 0.21411065416242636, 0.2127683016083336, 0.105237221246827, 0.5403138581297193, 0.36233078815169917, 0.18154529264887365, 0.19034695359780784, 0.18705007118961925, 0.18731944499283237, 0.18862450994714908, 0.181368886160578, 0.17684088976439394, 0.18598429030599295, 0.18143220521539383, 0.10188353392374716, 0.07538361466450083, 0.07502758819782429, 0.08189984021125563, 0.07672220611827174, 0.07808450200416772, 0.1002375240971789, 0.09321245465027461, 0.07584274895336707]}, "mutation_prompt": null}
{"id": "e204ffa3-a8c7-4a0b-a542-179a468b2d58", "solution": "import numpy as np\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        if np.random.rand() > 0.5:\n            crossover_point = np.random.randint(1, self.dim-1)\n            child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        else:\n            alpha = np.random.rand(self.dim)\n            child = alpha * parent1 + (1 - alpha) * parent2\n        return child\n    \n    def _mutate(self, individual, generation):\n        adaptive_mutation_rate = self.mutation_rate * (1 - generation / self.budget)\n        for i in range(self.dim):\n            if np.random.rand() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n        generation = 0\n\n        while self.evaluations < self.budget:\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1, generation)\n                child2 = self._mutate(child2, generation)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n            generation += 1\n        \n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "An enhanced hybrid genetic algorithm utilizing adaptive mutation rates and elite replacement for faster convergence.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ba0ad45e-79a5-497a-a152-a00347f6aeec", "metadata": {"aucs": [0.5188767331596345, 0.5064088709886925, 0.529496447239648, 0.5144420539623902, 0.5370488447429549, 0.5112964000634398, 0.5443189240093997, 0.5151759905658304, 0.5295974625296624, 0.11628763434397549, 0.073237962137081, 0.1171960218681154, 0.1328054441372537, 0.06734962385719301, 0.18702089088395346, 0.11794777197766848, 0.16142451141806613, 0.09479736946696471, 0.13340173656759524, 0.11187463710972767, 0.13141237757711532, 0.13803893579674764, 0.14700684185232926, 0.23298106805301155, 0.15599881259017334, 0.13753294373569147, 0.14748159785705617, 0.10876875324652024, 0.1199588748125876, 0.11442623443949529, 0.1376682920812753, 0.10753935447249918, 0.11529412838556907, 0.14411587550759053, 0.12631171847284206, 0.09899476319301614, 0.8657788659263602, 0.8708037771669245, 0.8456890545782719, 0.852582574405035, 0.8831960734694649, 0.8854751829924894, 0.8679232429229845, 0.9140837729660892, 0.9015444725811272, 0.3568268521148178, 0.34169183216634236, 0.3275012350470019, 0.3020994963658874, 0.3330206291499205, 0.3610407508786032, 0.33862374062362166, 0.3033525987268578, 0.29969884168468375, 0.1565724305817624, 0.24612530080806716, 0.1426010858307345, 0.2145150807661389, 0.26942187158728426, 0.35259656298456443, 0.15752276978004842, 0.23846888290241963, 0.1995849784012269, 0.17774147063968737, 0.1654716515977942, 0.17840744983435375, 0.15724909282867372, 0.20144777914869705, 0.17030827069467014, 0.16330246182093688, 0.24655007798684248, 0.3514770322958348, 0.14225247094640325, 0.13435904494185447, 0.17037749954018255, 0.16814900747676498, 0.2131401520323899, 0.15134788406363442, 0.14338955739022818, 0.29561775046554084, 0.15586750501445734, 9.999999999998899e-05, 9.999999999998899e-05, 0.0035166480994790472, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06961805886886052, 0.025233134646751365, 0.06903749483907706, 0.05645912279153509, 0.023355064750135157, 0.007827625196492938, 0.11200956379572746, 0.06318894312464596, 0.07997994142271458, 0.006665368751889056, 0.01157989821538663, 0.0017879740169762792, 0.00037159721867408013, 0.014947521855188661, 0.00412625368969477, 9.999999999998899e-05, 0.017349969084643257, 0.0288434555395799, 0.11476562071290586, 0.09215900389490728, 0.1390202896632774, 0.10268411211077477, 0.15948143646883395, 0.05918458680430527, 0.1635227025727929, 0.1255441073180733, 0.08405591483482644, 0.4897452909625738, 0.468474821918648, 0.4482336644336633, 0.46810298655440497, 0.4340659450409212, 0.46357283616222056, 0.4808855253363665, 0.4599415934511112, 0.4624649242993303, 0.09612734276923707, 0.09116039412042976, 0.04977867560294946, 0.1898093805089569, 0.10496876212120221, 0.06321529017138294, 0.07345975748157285, 0.07668599384362873, 0.10252236141264515, 0.24700017564221022, 0.2446872303976746, 0.22846517531484667, 0.31439445608657246, 0.2839388691347797, 0.1889649936153983, 0.25740041441158334, 0.18576644935792974, 0.21280984219620136, 0.21531507504464076, 0.20831586277199543, 0.15805015565264835, 0.2224181463999947, 0.22630207944566505, 0.24714886348589782, 0.3333252362352441, 0.344323674464301, 0.3200394607320015, 0.18958770263436542, 0.2653879417765064, 0.2140139407956907, 0.22514312964500183, 0.19190956803712, 0.21345436527623785, 0.18053751764889692, 0.27381120341821585, 0.24499272608489986, 0.2655839730192584, 0.2551418397180554, 0.20957167420847034, 0.19588568342895574, 0.17548267970119247, 0.23386637959141454, 0.20526428858870627, 0.2081861724669316, 0.20663037237230641, 0.21114615850956675, 0.20210698859591936, 0.1992334651046238, 0.19377810514516836, 0.1824560207628787, 0.21544272153051447, 0.19972876917705684, 0.18556784259466508, 0.17953088823492835, 0.11672352782602902, 0.12712245852129767, 0.15365179749505953, 0.7952637986062888, 0.7358143023317176, 0.7555169639492753, 0.15403889412227878, 0.16968212653933712, 0.15023210862774394, 0.14938982545497348, 0.5345065084217684, 0.3925973379115292, 0.501162113080057, 0.21411065416242636, 0.2127683016083336, 0.105237221246827, 0.5403138581297193, 0.36233078815169917, 0.18154529264887365, 0.19034695359780784, 0.18705007118961925, 0.18731944499283237, 0.18862450994714908, 0.181368886160578, 0.17684088976439394, 0.18598429030599295, 0.18143220521539383, 0.10188353392374716, 0.07538361466450083, 0.07502758819782429, 0.08189984021125563, 0.07672220611827174, 0.07808450200416772, 0.1002375240971789, 0.09321245465027461, 0.07584274895336707]}, "mutation_prompt": null}
{"id": "ed75fd30-8016-4ef8-9c86-f773988e4eef", "solution": "import numpy as np\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        if np.random.rand() > 0.5:\n            crossover_point = np.random.randint(1, self.dim-1)\n            child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        else:\n            alpha = np.random.rand(self.dim)\n            child = alpha * parent1 + (1 - alpha) * parent2\n        return child\n    \n    def _mutate(self, individual, generation):\n        adaptive_mutation_rate = self.mutation_rate * (1 - generation / self.budget)\n        for i in range(self.dim):\n            if np.random.rand() < adaptive_mutation_rate:\n                individual[i] += np.random.normal(0, 0.1 * (1 - generation / self.budget))\n                individual[i] = np.clip(individual[i], self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        for _ in range(3):\n            step = np.random.uniform(-0.05, 0.05, self.dim)\n            candidate = individual + step\n            candidate = np.clip(candidate, self.lb, self.ub)\n            if func(candidate) < func(individual):\n                individual = candidate\n        return individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n        generation = 0\n\n        while self.evaluations < self.budget:\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1, generation)\n                child2 = self._mutate(child2, generation)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n            generation += 1\n            if generation % 10 == 0:\n                self.population_size = min(50, self.population_size + 2)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "Enhanced hybrid genetic algorithm with improved local search and dynamic population size adjustment for faster convergence.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 21 is out of bounds for axis 0 with size 20').", "error": "IndexError('index 21 is out of bounds for axis 0 with size 20')", "parent_id": "ba0ad45e-79a5-497a-a152-a00347f6aeec", "metadata": {}, "mutation_prompt": null}
{"id": "49d9601f-ed37-4dda-94c7-ee153efb2978", "solution": "import numpy as np\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        if np.random.rand() > 0.5:\n            crossover_point = np.random.randint(1, self.dim-1)\n            child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        else:\n            alpha = np.random.rand(self.dim)\n            child = alpha * parent1 + (1 - alpha) * parent2\n        return child\n    \n    def _mutate(self, individual, generation):\n        adaptive_mutation_rate = self.mutation_rate * (1 - generation / self.budget)\n        for i in range(self.dim):\n            if np.random.rand() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n        generation = 0\n\n        while self.evaluations < self.budget:\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1, generation)\n                child2 = self._mutate(child2, generation)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n            generation += 1\n        \n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "An enhanced hybrid genetic algorithm utilizing adaptive mutation rates and elite replacement for faster convergence.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ba0ad45e-79a5-497a-a152-a00347f6aeec", "metadata": {"aucs": [0.5188767331596345, 0.5064088709886925, 0.529496447239648, 0.5144420539623902, 0.5370488447429549, 0.5112964000634398, 0.5443189240093997, 0.5151759905658304, 0.5295974625296624, 0.11628763434397549, 0.073237962137081, 0.1171960218681154, 0.1328054441372537, 0.06734962385719301, 0.18702089088395346, 0.11794777197766848, 0.16142451141806613, 0.09479736946696471, 0.13340173656759524, 0.11187463710972767, 0.13141237757711532, 0.13803893579674764, 0.14700684185232926, 0.23298106805301155, 0.15599881259017334, 0.13753294373569147, 0.14748159785705617, 0.10876875324652024, 0.1199588748125876, 0.11442623443949529, 0.1376682920812753, 0.10753935447249918, 0.11529412838556907, 0.14411587550759053, 0.12631171847284206, 0.09899476319301614, 0.8657788659263602, 0.8708037771669245, 0.8456890545782719, 0.852582574405035, 0.8831960734694649, 0.8854751829924894, 0.8679232429229845, 0.9140837729660892, 0.9015444725811272, 0.3568268521148178, 0.34169183216634236, 0.3275012350470019, 0.3020994963658874, 0.3330206291499205, 0.3610407508786032, 0.33862374062362166, 0.3033525987268578, 0.29969884168468375, 0.1565724305817624, 0.24612530080806716, 0.1426010858307345, 0.2145150807661389, 0.26942187158728426, 0.35259656298456443, 0.15752276978004842, 0.23846888290241963, 0.1995849784012269, 0.17774147063968737, 0.1654716515977942, 0.17840744983435375, 0.15724909282867372, 0.20144777914869705, 0.17030827069467014, 0.16330246182093688, 0.24655007798684248, 0.3514770322958348, 0.14225247094640325, 0.13435904494185447, 0.17037749954018255, 0.16814900747676498, 0.2131401520323899, 0.15134788406363442, 0.14338955739022818, 0.29561775046554084, 0.15586750501445734, 9.999999999998899e-05, 9.999999999998899e-05, 0.0035166480994790472, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06961805886886052, 0.025233134646751365, 0.06903749483907706, 0.05645912279153509, 0.023355064750135157, 0.007827625196492938, 0.11200956379572746, 0.06318894312464596, 0.07997994142271458, 0.006665368751889056, 0.01157989821538663, 0.0017879740169762792, 0.00037159721867408013, 0.014947521855188661, 0.00412625368969477, 9.999999999998899e-05, 0.017349969084643257, 0.0288434555395799, 0.11476562071290586, 0.09215900389490728, 0.1390202896632774, 0.10268411211077477, 0.15948143646883395, 0.05918458680430527, 0.1635227025727929, 0.1255441073180733, 0.08405591483482644, 0.4897452909625738, 0.468474821918648, 0.4482336644336633, 0.46810298655440497, 0.4340659450409212, 0.46357283616222056, 0.4808855253363665, 0.4599415934511112, 0.4624649242993303, 0.09612734276923707, 0.09116039412042976, 0.04977867560294946, 0.1898093805089569, 0.10496876212120221, 0.06321529017138294, 0.07345975748157285, 0.07668599384362873, 0.10252236141264515, 0.24700017564221022, 0.2446872303976746, 0.22846517531484667, 0.31439445608657246, 0.2839388691347797, 0.1889649936153983, 0.25740041441158334, 0.18576644935792974, 0.21280984219620136, 0.21531507504464076, 0.20831586277199543, 0.15805015565264835, 0.2224181463999947, 0.22630207944566505, 0.24714886348589782, 0.3333252362352441, 0.344323674464301, 0.3200394607320015, 0.18958770263436542, 0.2653879417765064, 0.2140139407956907, 0.22514312964500183, 0.19190956803712, 0.21345436527623785, 0.18053751764889692, 0.27381120341821585, 0.24499272608489986, 0.2655839730192584, 0.2551418397180554, 0.20957167420847034, 0.19588568342895574, 0.17548267970119247, 0.23386637959141454, 0.20526428858870627, 0.2081861724669316, 0.20663037237230641, 0.21114615850956675, 0.20210698859591936, 0.1992334651046238, 0.19377810514516836, 0.1824560207628787, 0.21544272153051447, 0.19972876917705684, 0.18556784259466508, 0.17953088823492835, 0.11672352782602902, 0.12712245852129767, 0.15365179749505953, 0.7952637986062888, 0.7358143023317176, 0.7555169639492753, 0.15403889412227878, 0.16968212653933712, 0.15023210862774394, 0.14938982545497348, 0.5345065084217684, 0.3925973379115292, 0.501162113080057, 0.21411065416242636, 0.2127683016083336, 0.105237221246827, 0.5403138581297193, 0.36233078815169917, 0.18154529264887365, 0.19034695359780784, 0.18705007118961925, 0.18731944499283237, 0.18862450994714908, 0.181368886160578, 0.17684088976439394, 0.18598429030599295, 0.18143220521539383, 0.10188353392374716, 0.07538361466450083, 0.07502758819782429, 0.08189984021125563, 0.07672220611827174, 0.07808450200416772, 0.1002375240971789, 0.09321245465027461, 0.07584274895336707]}, "mutation_prompt": null}
{"id": "be90880a-830e-488a-84aa-f4ab2ec6fd3e", "solution": "import numpy as np\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        if np.random.rand() > 0.5:\n            crossover_point = np.random.randint(1, self.dim-1)\n            child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        else:\n            alpha = np.random.rand(self.dim)\n            child = alpha * parent1 + (1 - alpha) * parent2\n        return child\n    \n    def _mutate(self, individual, generation):\n        adaptive_mutation_rate = self.mutation_rate * (1 - generation / self.budget)\n        for i in range(self.dim):\n            if np.random.rand() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n        generation = 0\n\n        while self.evaluations < self.budget:\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1, generation)\n                child2 = self._mutate(child2, generation)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n            generation += 1\n        \n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "An enhanced hybrid genetic algorithm utilizing adaptive mutation rates and elite replacement for faster convergence.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ba0ad45e-79a5-497a-a152-a00347f6aeec", "metadata": {"aucs": [0.5188767331596345, 0.5064088709886925, 0.529496447239648, 0.5144420539623902, 0.5370488447429549, 0.5112964000634398, 0.5443189240093997, 0.5151759905658304, 0.5295974625296624, 0.11628763434397549, 0.073237962137081, 0.1171960218681154, 0.1328054441372537, 0.06734962385719301, 0.18702089088395346, 0.11794777197766848, 0.16142451141806613, 0.09479736946696471, 0.13340173656759524, 0.11187463710972767, 0.13141237757711532, 0.13803893579674764, 0.14700684185232926, 0.23298106805301155, 0.15599881259017334, 0.13753294373569147, 0.14748159785705617, 0.10876875324652024, 0.1199588748125876, 0.11442623443949529, 0.1376682920812753, 0.10753935447249918, 0.11529412838556907, 0.14411587550759053, 0.12631171847284206, 0.09899476319301614, 0.8657788659263602, 0.8708037771669245, 0.8456890545782719, 0.852582574405035, 0.8831960734694649, 0.8854751829924894, 0.8679232429229845, 0.9140837729660892, 0.9015444725811272, 0.3568268521148178, 0.34169183216634236, 0.3275012350470019, 0.3020994963658874, 0.3330206291499205, 0.3610407508786032, 0.33862374062362166, 0.3033525987268578, 0.29969884168468375, 0.1565724305817624, 0.24612530080806716, 0.1426010858307345, 0.2145150807661389, 0.26942187158728426, 0.35259656298456443, 0.15752276978004842, 0.23846888290241963, 0.1995849784012269, 0.17774147063968737, 0.1654716515977942, 0.17840744983435375, 0.15724909282867372, 0.20144777914869705, 0.17030827069467014, 0.16330246182093688, 0.24655007798684248, 0.3514770322958348, 0.14225247094640325, 0.13435904494185447, 0.17037749954018255, 0.16814900747676498, 0.2131401520323899, 0.15134788406363442, 0.14338955739022818, 0.29561775046554084, 0.15586750501445734, 9.999999999998899e-05, 9.999999999998899e-05, 0.0035166480994790472, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06961805886886052, 0.025233134646751365, 0.06903749483907706, 0.05645912279153509, 0.023355064750135157, 0.007827625196492938, 0.11200956379572746, 0.06318894312464596, 0.07997994142271458, 0.006665368751889056, 0.01157989821538663, 0.0017879740169762792, 0.00037159721867408013, 0.014947521855188661, 0.00412625368969477, 9.999999999998899e-05, 0.017349969084643257, 0.0288434555395799, 0.11476562071290586, 0.09215900389490728, 0.1390202896632774, 0.10268411211077477, 0.15948143646883395, 0.05918458680430527, 0.1635227025727929, 0.1255441073180733, 0.08405591483482644, 0.4897452909625738, 0.468474821918648, 0.4482336644336633, 0.46810298655440497, 0.4340659450409212, 0.46357283616222056, 0.4808855253363665, 0.4599415934511112, 0.4624649242993303, 0.09612734276923707, 0.09116039412042976, 0.04977867560294946, 0.1898093805089569, 0.10496876212120221, 0.06321529017138294, 0.07345975748157285, 0.07668599384362873, 0.10252236141264515, 0.24700017564221022, 0.2446872303976746, 0.22846517531484667, 0.31439445608657246, 0.2839388691347797, 0.1889649936153983, 0.25740041441158334, 0.18576644935792974, 0.21280984219620136, 0.21531507504464076, 0.20831586277199543, 0.15805015565264835, 0.2224181463999947, 0.22630207944566505, 0.24714886348589782, 0.3333252362352441, 0.344323674464301, 0.3200394607320015, 0.18958770263436542, 0.2653879417765064, 0.2140139407956907, 0.22514312964500183, 0.19190956803712, 0.21345436527623785, 0.18053751764889692, 0.27381120341821585, 0.24499272608489986, 0.2655839730192584, 0.2551418397180554, 0.20957167420847034, 0.19588568342895574, 0.17548267970119247, 0.23386637959141454, 0.20526428858870627, 0.2081861724669316, 0.20663037237230641, 0.21114615850956675, 0.20210698859591936, 0.1992334651046238, 0.19377810514516836, 0.1824560207628787, 0.21544272153051447, 0.19972876917705684, 0.18556784259466508, 0.17953088823492835, 0.11672352782602902, 0.12712245852129767, 0.15365179749505953, 0.7952637986062888, 0.7358143023317176, 0.7555169639492753, 0.15403889412227878, 0.16968212653933712, 0.15023210862774394, 0.14938982545497348, 0.5345065084217684, 0.3925973379115292, 0.501162113080057, 0.21411065416242636, 0.2127683016083336, 0.105237221246827, 0.5403138581297193, 0.36233078815169917, 0.18154529264887365, 0.19034695359780784, 0.18705007118961925, 0.18731944499283237, 0.18862450994714908, 0.181368886160578, 0.17684088976439394, 0.18598429030599295, 0.18143220521539383, 0.10188353392374716, 0.07538361466450083, 0.07502758819782429, 0.08189984021125563, 0.07672220611827174, 0.07808450200416772, 0.1002375240971789, 0.09321245465027461, 0.07584274895336707]}, "mutation_prompt": null}
{"id": "61289da8-1426-491a-8921-ca8be08a9dcd", "solution": "import numpy as np\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        if np.random.rand() > 0.5:\n            crossover_point = np.random.randint(1, self.dim-1)\n            child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        else:\n            alpha = np.random.rand(self.dim)\n            child = alpha * parent1 + (1 - alpha) * parent2\n        return child\n    \n    def _mutate(self, individual, generation):\n        adaptive_mutation_rate = self.mutation_rate * (1 - generation / self.budget)\n        for i in range(self.dim):\n            if np.random.rand() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n        generation = 0\n\n        while self.evaluations < self.budget:\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1, generation)\n                child2 = self._mutate(child2, generation)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n            generation += 1\n        \n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "An enhanced hybrid genetic algorithm utilizing adaptive mutation rates and elite replacement for faster convergence.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ba0ad45e-79a5-497a-a152-a00347f6aeec", "metadata": {"aucs": [0.5188767331596345, 0.5064088709886925, 0.529496447239648, 0.5144420539623902, 0.5370488447429549, 0.5112964000634398, 0.5443189240093997, 0.5151759905658304, 0.5295974625296624, 0.11628763434397549, 0.073237962137081, 0.1171960218681154, 0.1328054441372537, 0.06734962385719301, 0.18702089088395346, 0.11794777197766848, 0.16142451141806613, 0.09479736946696471, 0.13340173656759524, 0.11187463710972767, 0.13141237757711532, 0.13803893579674764, 0.14700684185232926, 0.23298106805301155, 0.15599881259017334, 0.13753294373569147, 0.14748159785705617, 0.10876875324652024, 0.1199588748125876, 0.11442623443949529, 0.1376682920812753, 0.10753935447249918, 0.11529412838556907, 0.14411587550759053, 0.12631171847284206, 0.09899476319301614, 0.8657788659263602, 0.8708037771669245, 0.8456890545782719, 0.852582574405035, 0.8831960734694649, 0.8854751829924894, 0.8679232429229845, 0.9140837729660892, 0.9015444725811272, 0.3568268521148178, 0.34169183216634236, 0.3275012350470019, 0.3020994963658874, 0.3330206291499205, 0.3610407508786032, 0.33862374062362166, 0.3033525987268578, 0.29969884168468375, 0.1565724305817624, 0.24612530080806716, 0.1426010858307345, 0.2145150807661389, 0.26942187158728426, 0.35259656298456443, 0.15752276978004842, 0.23846888290241963, 0.1995849784012269, 0.17774147063968737, 0.1654716515977942, 0.17840744983435375, 0.15724909282867372, 0.20144777914869705, 0.17030827069467014, 0.16330246182093688, 0.24655007798684248, 0.3514770322958348, 0.14225247094640325, 0.13435904494185447, 0.17037749954018255, 0.16814900747676498, 0.2131401520323899, 0.15134788406363442, 0.14338955739022818, 0.29561775046554084, 0.15586750501445734, 9.999999999998899e-05, 9.999999999998899e-05, 0.0035166480994790472, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06961805886886052, 0.025233134646751365, 0.06903749483907706, 0.05645912279153509, 0.023355064750135157, 0.007827625196492938, 0.11200956379572746, 0.06318894312464596, 0.07997994142271458, 0.006665368751889056, 0.01157989821538663, 0.0017879740169762792, 0.00037159721867408013, 0.014947521855188661, 0.00412625368969477, 9.999999999998899e-05, 0.017349969084643257, 0.0288434555395799, 0.11476562071290586, 0.09215900389490728, 0.1390202896632774, 0.10268411211077477, 0.15948143646883395, 0.05918458680430527, 0.1635227025727929, 0.1255441073180733, 0.08405591483482644, 0.4897452909625738, 0.468474821918648, 0.4482336644336633, 0.46810298655440497, 0.4340659450409212, 0.46357283616222056, 0.4808855253363665, 0.4599415934511112, 0.4624649242993303, 0.09612734276923707, 0.09116039412042976, 0.04977867560294946, 0.1898093805089569, 0.10496876212120221, 0.06321529017138294, 0.07345975748157285, 0.07668599384362873, 0.10252236141264515, 0.24700017564221022, 0.2446872303976746, 0.22846517531484667, 0.31439445608657246, 0.2839388691347797, 0.1889649936153983, 0.25740041441158334, 0.18576644935792974, 0.21280984219620136, 0.21531507504464076, 0.20831586277199543, 0.15805015565264835, 0.2224181463999947, 0.22630207944566505, 0.24714886348589782, 0.3333252362352441, 0.344323674464301, 0.3200394607320015, 0.18958770263436542, 0.2653879417765064, 0.2140139407956907, 0.22514312964500183, 0.19190956803712, 0.21345436527623785, 0.18053751764889692, 0.27381120341821585, 0.24499272608489986, 0.2655839730192584, 0.2551418397180554, 0.20957167420847034, 0.19588568342895574, 0.17548267970119247, 0.23386637959141454, 0.20526428858870627, 0.2081861724669316, 0.20663037237230641, 0.21114615850956675, 0.20210698859591936, 0.1992334651046238, 0.19377810514516836, 0.1824560207628787, 0.21544272153051447, 0.19972876917705684, 0.18556784259466508, 0.17953088823492835, 0.11672352782602902, 0.12712245852129767, 0.15365179749505953, 0.7952637986062888, 0.7358143023317176, 0.7555169639492753, 0.15403889412227878, 0.16968212653933712, 0.15023210862774394, 0.14938982545497348, 0.5345065084217684, 0.3925973379115292, 0.501162113080057, 0.21411065416242636, 0.2127683016083336, 0.105237221246827, 0.5403138581297193, 0.36233078815169917, 0.18154529264887365, 0.19034695359780784, 0.18705007118961925, 0.18731944499283237, 0.18862450994714908, 0.181368886160578, 0.17684088976439394, 0.18598429030599295, 0.18143220521539383, 0.10188353392374716, 0.07538361466450083, 0.07502758819782429, 0.08189984021125563, 0.07672220611827174, 0.07808450200416772, 0.1002375240971789, 0.09321245465027461, 0.07584274895336707]}, "mutation_prompt": null}
{"id": "2f2cd710-f26a-4c35-828e-9f1ec7dd2648", "solution": "import numpy as np\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        if np.random.rand() > 0.5:\n            crossover_point = np.random.randint(1, self.dim-1)\n            child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        else:\n            alpha = np.random.rand(self.dim)\n            child = alpha * parent1 + (1 - alpha) * parent2\n        return child\n    \n    def _mutate(self, individual, generation):\n        adaptive_mutation_rate = self.mutation_rate * (1 - generation / self.budget)\n        for i in range(self.dim):\n            if np.random.rand() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n        generation = 0\n\n        while self.evaluations < self.budget:\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1, generation)\n                child2 = self._mutate(child2, generation)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n            generation += 1\n        \n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "An enhanced hybrid genetic algorithm utilizing adaptive mutation rates and elite replacement for faster convergence.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ba0ad45e-79a5-497a-a152-a00347f6aeec", "metadata": {"aucs": [0.5188767331596345, 0.5064088709886925, 0.529496447239648, 0.5144420539623902, 0.5370488447429549, 0.5112964000634398, 0.5443189240093997, 0.5151759905658304, 0.5295974625296624, 0.11628763434397549, 0.073237962137081, 0.1171960218681154, 0.1328054441372537, 0.06734962385719301, 0.18702089088395346, 0.11794777197766848, 0.16142451141806613, 0.09479736946696471, 0.13340173656759524, 0.11187463710972767, 0.13141237757711532, 0.13803893579674764, 0.14700684185232926, 0.23298106805301155, 0.15599881259017334, 0.13753294373569147, 0.14748159785705617, 0.10876875324652024, 0.1199588748125876, 0.11442623443949529, 0.1376682920812753, 0.10753935447249918, 0.11529412838556907, 0.14411587550759053, 0.12631171847284206, 0.09899476319301614, 0.8657788659263602, 0.8708037771669245, 0.8456890545782719, 0.852582574405035, 0.8831960734694649, 0.8854751829924894, 0.8679232429229845, 0.9140837729660892, 0.9015444725811272, 0.3568268521148178, 0.34169183216634236, 0.3275012350470019, 0.3020994963658874, 0.3330206291499205, 0.3610407508786032, 0.33862374062362166, 0.3033525987268578, 0.29969884168468375, 0.1565724305817624, 0.24612530080806716, 0.1426010858307345, 0.2145150807661389, 0.26942187158728426, 0.35259656298456443, 0.15752276978004842, 0.23846888290241963, 0.1995849784012269, 0.17774147063968737, 0.1654716515977942, 0.17840744983435375, 0.15724909282867372, 0.20144777914869705, 0.17030827069467014, 0.16330246182093688, 0.24655007798684248, 0.3514770322958348, 0.14225247094640325, 0.13435904494185447, 0.17037749954018255, 0.16814900747676498, 0.2131401520323899, 0.15134788406363442, 0.14338955739022818, 0.29561775046554084, 0.15586750501445734, 9.999999999998899e-05, 9.999999999998899e-05, 0.0035166480994790472, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06961805886886052, 0.025233134646751365, 0.06903749483907706, 0.05645912279153509, 0.023355064750135157, 0.007827625196492938, 0.11200956379572746, 0.06318894312464596, 0.07997994142271458, 0.006665368751889056, 0.01157989821538663, 0.0017879740169762792, 0.00037159721867408013, 0.014947521855188661, 0.00412625368969477, 9.999999999998899e-05, 0.017349969084643257, 0.0288434555395799, 0.11476562071290586, 0.09215900389490728, 0.1390202896632774, 0.10268411211077477, 0.15948143646883395, 0.05918458680430527, 0.1635227025727929, 0.1255441073180733, 0.08405591483482644, 0.4897452909625738, 0.468474821918648, 0.4482336644336633, 0.46810298655440497, 0.4340659450409212, 0.46357283616222056, 0.4808855253363665, 0.4599415934511112, 0.4624649242993303, 0.09612734276923707, 0.09116039412042976, 0.04977867560294946, 0.1898093805089569, 0.10496876212120221, 0.06321529017138294, 0.07345975748157285, 0.07668599384362873, 0.10252236141264515, 0.24700017564221022, 0.2446872303976746, 0.22846517531484667, 0.31439445608657246, 0.2839388691347797, 0.1889649936153983, 0.25740041441158334, 0.18576644935792974, 0.21280984219620136, 0.21531507504464076, 0.20831586277199543, 0.15805015565264835, 0.2224181463999947, 0.22630207944566505, 0.24714886348589782, 0.3333252362352441, 0.344323674464301, 0.3200394607320015, 0.18958770263436542, 0.2653879417765064, 0.2140139407956907, 0.22514312964500183, 0.19190956803712, 0.21345436527623785, 0.18053751764889692, 0.27381120341821585, 0.24499272608489986, 0.2655839730192584, 0.2551418397180554, 0.20957167420847034, 0.19588568342895574, 0.17548267970119247, 0.23386637959141454, 0.20526428858870627, 0.2081861724669316, 0.20663037237230641, 0.21114615850956675, 0.20210698859591936, 0.1992334651046238, 0.19377810514516836, 0.1824560207628787, 0.21544272153051447, 0.19972876917705684, 0.18556784259466508, 0.17953088823492835, 0.11672352782602902, 0.12712245852129767, 0.15365179749505953, 0.7952637986062888, 0.7358143023317176, 0.7555169639492753, 0.15403889412227878, 0.16968212653933712, 0.15023210862774394, 0.14938982545497348, 0.5345065084217684, 0.3925973379115292, 0.501162113080057, 0.21411065416242636, 0.2127683016083336, 0.105237221246827, 0.5403138581297193, 0.36233078815169917, 0.18154529264887365, 0.19034695359780784, 0.18705007118961925, 0.18731944499283237, 0.18862450994714908, 0.181368886160578, 0.17684088976439394, 0.18598429030599295, 0.18143220521539383, 0.10188353392374716, 0.07538361466450083, 0.07502758819782429, 0.08189984021125563, 0.07672220611827174, 0.07808450200416772, 0.1002375240971789, 0.09321245465027461, 0.07584274895336707]}, "mutation_prompt": null}
{"id": "5856b440-1ee9-467a-b242-3bfa06ec5650", "solution": "import numpy as np\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        if np.random.rand() > 0.5:\n            crossover_point = np.random.randint(1, self.dim-1)\n            child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        else:\n            alpha = np.random.rand(self.dim)\n            child = alpha * parent1 + (1 - alpha) * parent2\n        return child\n    \n    def _mutate(self, individual, generation):\n        adaptive_mutation_rate = self.mutation_rate * (1 - generation / self.budget)\n        for i in range(self.dim):\n            if np.random.rand() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n        generation = 0\n\n        while self.evaluations < self.budget:\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1, generation)\n                child2 = self._mutate(child2, generation)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n            generation += 1\n        \n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "An enhanced hybrid genetic algorithm utilizing adaptive mutation rates and elite replacement for faster convergence.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ba0ad45e-79a5-497a-a152-a00347f6aeec", "metadata": {"aucs": [0.5188767331596345, 0.5064088709886925, 0.529496447239648, 0.5144420539623902, 0.5370488447429549, 0.5112964000634398, 0.5443189240093997, 0.5151759905658304, 0.5295974625296624, 0.11628763434397549, 0.073237962137081, 0.1171960218681154, 0.1328054441372537, 0.06734962385719301, 0.18702089088395346, 0.11794777197766848, 0.16142451141806613, 0.09479736946696471, 0.13340173656759524, 0.11187463710972767, 0.13141237757711532, 0.13803893579674764, 0.14700684185232926, 0.23298106805301155, 0.15599881259017334, 0.13753294373569147, 0.14748159785705617, 0.10876875324652024, 0.1199588748125876, 0.11442623443949529, 0.1376682920812753, 0.10753935447249918, 0.11529412838556907, 0.14411587550759053, 0.12631171847284206, 0.09899476319301614, 0.8657788659263602, 0.8708037771669245, 0.8456890545782719, 0.852582574405035, 0.8831960734694649, 0.8854751829924894, 0.8679232429229845, 0.9140837729660892, 0.9015444725811272, 0.3568268521148178, 0.34169183216634236, 0.3275012350470019, 0.3020994963658874, 0.3330206291499205, 0.3610407508786032, 0.33862374062362166, 0.3033525987268578, 0.29969884168468375, 0.1565724305817624, 0.24612530080806716, 0.1426010858307345, 0.2145150807661389, 0.26942187158728426, 0.35259656298456443, 0.15752276978004842, 0.23846888290241963, 0.1995849784012269, 0.17774147063968737, 0.1654716515977942, 0.17840744983435375, 0.15724909282867372, 0.20144777914869705, 0.17030827069467014, 0.16330246182093688, 0.24655007798684248, 0.3514770322958348, 0.14225247094640325, 0.13435904494185447, 0.17037749954018255, 0.16814900747676498, 0.2131401520323899, 0.15134788406363442, 0.14338955739022818, 0.29561775046554084, 0.15586750501445734, 9.999999999998899e-05, 9.999999999998899e-05, 0.0035166480994790472, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06961805886886052, 0.025233134646751365, 0.06903749483907706, 0.05645912279153509, 0.023355064750135157, 0.007827625196492938, 0.11200956379572746, 0.06318894312464596, 0.07997994142271458, 0.006665368751889056, 0.01157989821538663, 0.0017879740169762792, 0.00037159721867408013, 0.014947521855188661, 0.00412625368969477, 9.999999999998899e-05, 0.017349969084643257, 0.0288434555395799, 0.11476562071290586, 0.09215900389490728, 0.1390202896632774, 0.10268411211077477, 0.15948143646883395, 0.05918458680430527, 0.1635227025727929, 0.1255441073180733, 0.08405591483482644, 0.4897452909625738, 0.468474821918648, 0.4482336644336633, 0.46810298655440497, 0.4340659450409212, 0.46357283616222056, 0.4808855253363665, 0.4599415934511112, 0.4624649242993303, 0.09612734276923707, 0.09116039412042976, 0.04977867560294946, 0.1898093805089569, 0.10496876212120221, 0.06321529017138294, 0.07345975748157285, 0.07668599384362873, 0.10252236141264515, 0.24700017564221022, 0.2446872303976746, 0.22846517531484667, 0.31439445608657246, 0.2839388691347797, 0.1889649936153983, 0.25740041441158334, 0.18576644935792974, 0.21280984219620136, 0.21531507504464076, 0.20831586277199543, 0.15805015565264835, 0.2224181463999947, 0.22630207944566505, 0.24714886348589782, 0.3333252362352441, 0.344323674464301, 0.3200394607320015, 0.18958770263436542, 0.2653879417765064, 0.2140139407956907, 0.22514312964500183, 0.19190956803712, 0.21345436527623785, 0.18053751764889692, 0.27381120341821585, 0.24499272608489986, 0.2655839730192584, 0.2551418397180554, 0.20957167420847034, 0.19588568342895574, 0.17548267970119247, 0.23386637959141454, 0.20526428858870627, 0.2081861724669316, 0.20663037237230641, 0.21114615850956675, 0.20210698859591936, 0.1992334651046238, 0.19377810514516836, 0.1824560207628787, 0.21544272153051447, 0.19972876917705684, 0.18556784259466508, 0.17953088823492835, 0.11672352782602902, 0.12712245852129767, 0.15365179749505953, 0.7952637986062888, 0.7358143023317176, 0.7555169639492753, 0.15403889412227878, 0.16968212653933712, 0.15023210862774394, 0.14938982545497348, 0.5345065084217684, 0.3925973379115292, 0.501162113080057, 0.21411065416242636, 0.2127683016083336, 0.105237221246827, 0.5403138581297193, 0.36233078815169917, 0.18154529264887365, 0.19034695359780784, 0.18705007118961925, 0.18731944499283237, 0.18862450994714908, 0.181368886160578, 0.17684088976439394, 0.18598429030599295, 0.18143220521539383, 0.10188353392374716, 0.07538361466450083, 0.07502758819782429, 0.08189984021125563, 0.07672220611827174, 0.07808450200416772, 0.1002375240971789, 0.09321245465027461, 0.07584274895336707]}, "mutation_prompt": null}
{"id": "a5231f66-e384-4fb4-9c5a-230b974c8b91", "solution": "import numpy as np\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        if np.random.rand() > 0.5:\n            crossover_point = np.random.randint(1, self.dim-1)\n            child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        else:\n            alpha = np.random.rand(self.dim)\n            child = alpha * parent1 + (1 - alpha) * parent2\n        return child\n    \n    def _mutate(self, individual, generation):\n        adaptive_mutation_rate = self.mutation_rate * (1 - generation / self.budget)\n        for i in range(self.dim):\n            if np.random.rand() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n        generation = 0\n\n        while self.evaluations < self.budget:\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1, generation)\n                child2 = self._mutate(child2, generation)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n            generation += 1\n        \n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "An enhanced hybrid genetic algorithm utilizing adaptive mutation rates and elite replacement for faster convergence.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ba0ad45e-79a5-497a-a152-a00347f6aeec", "metadata": {"aucs": [0.5188767331596345, 0.5064088709886925, 0.529496447239648, 0.5144420539623902, 0.5370488447429549, 0.5112964000634398, 0.5443189240093997, 0.5151759905658304, 0.5295974625296624, 0.11628763434397549, 0.073237962137081, 0.1171960218681154, 0.1328054441372537, 0.06734962385719301, 0.18702089088395346, 0.11794777197766848, 0.16142451141806613, 0.09479736946696471, 0.13340173656759524, 0.11187463710972767, 0.13141237757711532, 0.13803893579674764, 0.14700684185232926, 0.23298106805301155, 0.15599881259017334, 0.13753294373569147, 0.14748159785705617, 0.10876875324652024, 0.1199588748125876, 0.11442623443949529, 0.1376682920812753, 0.10753935447249918, 0.11529412838556907, 0.14411587550759053, 0.12631171847284206, 0.09899476319301614, 0.8657788659263602, 0.8708037771669245, 0.8456890545782719, 0.852582574405035, 0.8831960734694649, 0.8854751829924894, 0.8679232429229845, 0.9140837729660892, 0.9015444725811272, 0.3568268521148178, 0.34169183216634236, 0.3275012350470019, 0.3020994963658874, 0.3330206291499205, 0.3610407508786032, 0.33862374062362166, 0.3033525987268578, 0.29969884168468375, 0.1565724305817624, 0.24612530080806716, 0.1426010858307345, 0.2145150807661389, 0.26942187158728426, 0.35259656298456443, 0.15752276978004842, 0.23846888290241963, 0.1995849784012269, 0.17774147063968737, 0.1654716515977942, 0.17840744983435375, 0.15724909282867372, 0.20144777914869705, 0.17030827069467014, 0.16330246182093688, 0.24655007798684248, 0.3514770322958348, 0.14225247094640325, 0.13435904494185447, 0.17037749954018255, 0.16814900747676498, 0.2131401520323899, 0.15134788406363442, 0.14338955739022818, 0.29561775046554084, 0.15586750501445734, 9.999999999998899e-05, 9.999999999998899e-05, 0.0035166480994790472, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06961805886886052, 0.025233134646751365, 0.06903749483907706, 0.05645912279153509, 0.023355064750135157, 0.007827625196492938, 0.11200956379572746, 0.06318894312464596, 0.07997994142271458, 0.006665368751889056, 0.01157989821538663, 0.0017879740169762792, 0.00037159721867408013, 0.014947521855188661, 0.00412625368969477, 9.999999999998899e-05, 0.017349969084643257, 0.0288434555395799, 0.11476562071290586, 0.09215900389490728, 0.1390202896632774, 0.10268411211077477, 0.15948143646883395, 0.05918458680430527, 0.1635227025727929, 0.1255441073180733, 0.08405591483482644, 0.4897452909625738, 0.468474821918648, 0.4482336644336633, 0.46810298655440497, 0.4340659450409212, 0.46357283616222056, 0.4808855253363665, 0.4599415934511112, 0.4624649242993303, 0.09612734276923707, 0.09116039412042976, 0.04977867560294946, 0.1898093805089569, 0.10496876212120221, 0.06321529017138294, 0.07345975748157285, 0.07668599384362873, 0.10252236141264515, 0.24700017564221022, 0.2446872303976746, 0.22846517531484667, 0.31439445608657246, 0.2839388691347797, 0.1889649936153983, 0.25740041441158334, 0.18576644935792974, 0.21280984219620136, 0.21531507504464076, 0.20831586277199543, 0.15805015565264835, 0.2224181463999947, 0.22630207944566505, 0.24714886348589782, 0.3333252362352441, 0.344323674464301, 0.3200394607320015, 0.18958770263436542, 0.2653879417765064, 0.2140139407956907, 0.22514312964500183, 0.19190956803712, 0.21345436527623785, 0.18053751764889692, 0.27381120341821585, 0.24499272608489986, 0.2655839730192584, 0.2551418397180554, 0.20957167420847034, 0.19588568342895574, 0.17548267970119247, 0.23386637959141454, 0.20526428858870627, 0.2081861724669316, 0.20663037237230641, 0.21114615850956675, 0.20210698859591936, 0.1992334651046238, 0.19377810514516836, 0.1824560207628787, 0.21544272153051447, 0.19972876917705684, 0.18556784259466508, 0.17953088823492835, 0.11672352782602902, 0.12712245852129767, 0.15365179749505953, 0.7952637986062888, 0.7358143023317176, 0.7555169639492753, 0.15403889412227878, 0.16968212653933712, 0.15023210862774394, 0.14938982545497348, 0.5345065084217684, 0.3925973379115292, 0.501162113080057, 0.21411065416242636, 0.2127683016083336, 0.105237221246827, 0.5403138581297193, 0.36233078815169917, 0.18154529264887365, 0.19034695359780784, 0.18705007118961925, 0.18731944499283237, 0.18862450994714908, 0.181368886160578, 0.17684088976439394, 0.18598429030599295, 0.18143220521539383, 0.10188353392374716, 0.07538361466450083, 0.07502758819782429, 0.08189984021125563, 0.07672220611827174, 0.07808450200416772, 0.1002375240971789, 0.09321245465027461, 0.07584274895336707]}, "mutation_prompt": null}
{"id": "7b826ea9-a5fa-4911-b527-e9ecf380c793", "solution": "import numpy as np\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        if np.random.rand() > 0.5:\n            crossover_point = np.random.randint(1, self.dim-1)\n            child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        else:\n            alpha = np.random.rand(self.dim)\n            child = alpha * parent1 + (1 - alpha) * parent2\n        return child\n    \n    def _mutate(self, individual, generation):\n        adaptive_mutation_rate = self.mutation_rate * (1 - generation / self.budget)\n        for i in range(self.dim):\n            if np.random.rand() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n        generation = 0\n\n        while self.evaluations < self.budget:\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1, generation)\n                child2 = self._mutate(child2, generation)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n            generation += 1\n        \n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "An enhanced hybrid genetic algorithm utilizing adaptive mutation rates and elite replacement for faster convergence.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ba0ad45e-79a5-497a-a152-a00347f6aeec", "metadata": {"aucs": [0.5188767331596345, 0.5064088709886925, 0.529496447239648, 0.5144420539623902, 0.5370488447429549, 0.5112964000634398, 0.5443189240093997, 0.5151759905658304, 0.5295974625296624, 0.11628763434397549, 0.073237962137081, 0.1171960218681154, 0.1328054441372537, 0.06734962385719301, 0.18702089088395346, 0.11794777197766848, 0.16142451141806613, 0.09479736946696471, 0.13340173656759524, 0.11187463710972767, 0.13141237757711532, 0.13803893579674764, 0.14700684185232926, 0.23298106805301155, 0.15599881259017334, 0.13753294373569147, 0.14748159785705617, 0.10876875324652024, 0.1199588748125876, 0.11442623443949529, 0.1376682920812753, 0.10753935447249918, 0.11529412838556907, 0.14411587550759053, 0.12631171847284206, 0.09899476319301614, 0.8657788659263602, 0.8708037771669245, 0.8456890545782719, 0.852582574405035, 0.8831960734694649, 0.8854751829924894, 0.8679232429229845, 0.9140837729660892, 0.9015444725811272, 0.3568268521148178, 0.34169183216634236, 0.3275012350470019, 0.3020994963658874, 0.3330206291499205, 0.3610407508786032, 0.33862374062362166, 0.3033525987268578, 0.29969884168468375, 0.1565724305817624, 0.24612530080806716, 0.1426010858307345, 0.2145150807661389, 0.26942187158728426, 0.35259656298456443, 0.15752276978004842, 0.23846888290241963, 0.1995849784012269, 0.17774147063968737, 0.1654716515977942, 0.17840744983435375, 0.15724909282867372, 0.20144777914869705, 0.17030827069467014, 0.16330246182093688, 0.24655007798684248, 0.3514770322958348, 0.14225247094640325, 0.13435904494185447, 0.17037749954018255, 0.16814900747676498, 0.2131401520323899, 0.15134788406363442, 0.14338955739022818, 0.29561775046554084, 0.15586750501445734, 9.999999999998899e-05, 9.999999999998899e-05, 0.0035166480994790472, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06961805886886052, 0.025233134646751365, 0.06903749483907706, 0.05645912279153509, 0.023355064750135157, 0.007827625196492938, 0.11200956379572746, 0.06318894312464596, 0.07997994142271458, 0.006665368751889056, 0.01157989821538663, 0.0017879740169762792, 0.00037159721867408013, 0.014947521855188661, 0.00412625368969477, 9.999999999998899e-05, 0.017349969084643257, 0.0288434555395799, 0.11476562071290586, 0.09215900389490728, 0.1390202896632774, 0.10268411211077477, 0.15948143646883395, 0.05918458680430527, 0.1635227025727929, 0.1255441073180733, 0.08405591483482644, 0.4897452909625738, 0.468474821918648, 0.4482336644336633, 0.46810298655440497, 0.4340659450409212, 0.46357283616222056, 0.4808855253363665, 0.4599415934511112, 0.4624649242993303, 0.09612734276923707, 0.09116039412042976, 0.04977867560294946, 0.1898093805089569, 0.10496876212120221, 0.06321529017138294, 0.07345975748157285, 0.07668599384362873, 0.10252236141264515, 0.24700017564221022, 0.2446872303976746, 0.22846517531484667, 0.31439445608657246, 0.2839388691347797, 0.1889649936153983, 0.25740041441158334, 0.18576644935792974, 0.21280984219620136, 0.21531507504464076, 0.20831586277199543, 0.15805015565264835, 0.2224181463999947, 0.22630207944566505, 0.24714886348589782, 0.3333252362352441, 0.344323674464301, 0.3200394607320015, 0.18958770263436542, 0.2653879417765064, 0.2140139407956907, 0.22514312964500183, 0.19190956803712, 0.21345436527623785, 0.18053751764889692, 0.27381120341821585, 0.24499272608489986, 0.2655839730192584, 0.2551418397180554, 0.20957167420847034, 0.19588568342895574, 0.17548267970119247, 0.23386637959141454, 0.20526428858870627, 0.2081861724669316, 0.20663037237230641, 0.21114615850956675, 0.20210698859591936, 0.1992334651046238, 0.19377810514516836, 0.1824560207628787, 0.21544272153051447, 0.19972876917705684, 0.18556784259466508, 0.17953088823492835, 0.11672352782602902, 0.12712245852129767, 0.15365179749505953, 0.7952637986062888, 0.7358143023317176, 0.7555169639492753, 0.15403889412227878, 0.16968212653933712, 0.15023210862774394, 0.14938982545497348, 0.5345065084217684, 0.3925973379115292, 0.501162113080057, 0.21411065416242636, 0.2127683016083336, 0.105237221246827, 0.5403138581297193, 0.36233078815169917, 0.18154529264887365, 0.19034695359780784, 0.18705007118961925, 0.18731944499283237, 0.18862450994714908, 0.181368886160578, 0.17684088976439394, 0.18598429030599295, 0.18143220521539383, 0.10188353392374716, 0.07538361466450083, 0.07502758819782429, 0.08189984021125563, 0.07672220611827174, 0.07808450200416772, 0.1002375240971789, 0.09321245465027461, 0.07584274895336707]}, "mutation_prompt": null}
{"id": "8c5414bb-1dfd-4e88-bab5-f41d81211a9c", "solution": "import numpy as np\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n        self.dynamic_scaling = True  # Enable dynamic population scaling\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _adaptive_crossover(self, parent1, parent2, generation):\n        alpha = np.random.rand(self.dim) * (1 - generation / self.budget)  # Adapt crossover rate\n        return alpha * parent1 + (1 - alpha) * parent2\n    \n    def _mutate(self, individual, generation):\n        adaptive_mutation_rate = self.mutation_rate * (1 - generation / self.budget)\n        for i in range(self.dim):\n            if np.random.rand() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n        generation = 0\n\n        while self.evaluations < self.budget:\n            # Dynamic scaling: Adjust population size based on remaining evaluations\n            if self.dynamic_scaling and self.budget - self.evaluations < self.population_size:\n                self.population_size = self.budget - self.evaluations\n            \n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._adaptive_crossover(parent1, parent2, generation)\n                child2 = self._adaptive_crossover(parent2, parent1, generation)\n\n                child1 = self._mutate(child1, generation)\n                child2 = self._mutate(child2, generation)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n            generation += 1\n        \n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "An enhanced hybrid genetic algorithm with adaptive crossover strategy and dynamic population scaling to improve convergence speed.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'HybridGeneticAlgorithm' object has no attribute '_local_search'\").", "error": "AttributeError(\"'HybridGeneticAlgorithm' object has no attribute '_local_search'\")", "parent_id": "ba0ad45e-79a5-497a-a152-a00347f6aeec", "metadata": {}, "mutation_prompt": null}
{"id": "fe4185df-1ca6-4409-840c-e92b8e5cc201", "solution": "import numpy as np\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        if np.random.rand() > 0.5:\n            crossover_point = np.random.randint(1, self.dim-1)\n            child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        else:\n            alpha = np.random.rand(self.dim)\n            child = alpha * parent1 + (1 - alpha) * parent2\n        return child\n    \n    def _mutate(self, individual, generation):\n        adaptive_mutation_rate = self.mutation_rate * (1 - generation / self.budget)\n        for i in range(self.dim):\n            if np.random.rand() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n        generation = 0\n\n        while self.evaluations < self.budget:\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1, generation)\n                child2 = self._mutate(child2, generation)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n            generation += 1\n        \n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "An enhanced hybrid genetic algorithm utilizing adaptive mutation rates and elite replacement for faster convergence.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ba0ad45e-79a5-497a-a152-a00347f6aeec", "metadata": {"aucs": [0.5188767331596345, 0.5064088709886925, 0.529496447239648, 0.5144420539623902, 0.5370488447429549, 0.5112964000634398, 0.5443189240093997, 0.5151759905658304, 0.5295974625296624, 0.11628763434397549, 0.073237962137081, 0.1171960218681154, 0.1328054441372537, 0.06734962385719301, 0.18702089088395346, 0.11794777197766848, 0.16142451141806613, 0.09479736946696471, 0.13340173656759524, 0.11187463710972767, 0.13141237757711532, 0.13803893579674764, 0.14700684185232926, 0.23298106805301155, 0.15599881259017334, 0.13753294373569147, 0.14748159785705617, 0.10876875324652024, 0.1199588748125876, 0.11442623443949529, 0.1376682920812753, 0.10753935447249918, 0.11529412838556907, 0.14411587550759053, 0.12631171847284206, 0.09899476319301614, 0.8657788659263602, 0.8708037771669245, 0.8456890545782719, 0.852582574405035, 0.8831960734694649, 0.8854751829924894, 0.8679232429229845, 0.9140837729660892, 0.9015444725811272, 0.3568268521148178, 0.34169183216634236, 0.3275012350470019, 0.3020994963658874, 0.3330206291499205, 0.3610407508786032, 0.33862374062362166, 0.3033525987268578, 0.29969884168468375, 0.1565724305817624, 0.24612530080806716, 0.1426010858307345, 0.2145150807661389, 0.26942187158728426, 0.35259656298456443, 0.15752276978004842, 0.23846888290241963, 0.1995849784012269, 0.17774147063968737, 0.1654716515977942, 0.17840744983435375, 0.15724909282867372, 0.20144777914869705, 0.17030827069467014, 0.16330246182093688, 0.24655007798684248, 0.3514770322958348, 0.14225247094640325, 0.13435904494185447, 0.17037749954018255, 0.16814900747676498, 0.2131401520323899, 0.15134788406363442, 0.14338955739022818, 0.29561775046554084, 0.15586750501445734, 9.999999999998899e-05, 9.999999999998899e-05, 0.0035166480994790472, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06961805886886052, 0.025233134646751365, 0.06903749483907706, 0.05645912279153509, 0.023355064750135157, 0.007827625196492938, 0.11200956379572746, 0.06318894312464596, 0.07997994142271458, 0.006665368751889056, 0.01157989821538663, 0.0017879740169762792, 0.00037159721867408013, 0.014947521855188661, 0.00412625368969477, 9.999999999998899e-05, 0.017349969084643257, 0.0288434555395799, 0.11476562071290586, 0.09215900389490728, 0.1390202896632774, 0.10268411211077477, 0.15948143646883395, 0.05918458680430527, 0.1635227025727929, 0.1255441073180733, 0.08405591483482644, 0.4897452909625738, 0.468474821918648, 0.4482336644336633, 0.46810298655440497, 0.4340659450409212, 0.46357283616222056, 0.4808855253363665, 0.4599415934511112, 0.4624649242993303, 0.09612734276923707, 0.09116039412042976, 0.04977867560294946, 0.1898093805089569, 0.10496876212120221, 0.06321529017138294, 0.07345975748157285, 0.07668599384362873, 0.10252236141264515, 0.24700017564221022, 0.2446872303976746, 0.22846517531484667, 0.31439445608657246, 0.2839388691347797, 0.1889649936153983, 0.25740041441158334, 0.18576644935792974, 0.21280984219620136, 0.21531507504464076, 0.20831586277199543, 0.15805015565264835, 0.2224181463999947, 0.22630207944566505, 0.24714886348589782, 0.3333252362352441, 0.344323674464301, 0.3200394607320015, 0.18958770263436542, 0.2653879417765064, 0.2140139407956907, 0.22514312964500183, 0.19190956803712, 0.21345436527623785, 0.18053751764889692, 0.27381120341821585, 0.24499272608489986, 0.2655839730192584, 0.2551418397180554, 0.20957167420847034, 0.19588568342895574, 0.17548267970119247, 0.23386637959141454, 0.20526428858870627, 0.2081861724669316, 0.20663037237230641, 0.21114615850956675, 0.20210698859591936, 0.1992334651046238, 0.19377810514516836, 0.1824560207628787, 0.21544272153051447, 0.19972876917705684, 0.18556784259466508, 0.17953088823492835, 0.11672352782602902, 0.12712245852129767, 0.15365179749505953, 0.7952637986062888, 0.7358143023317176, 0.7555169639492753, 0.15403889412227878, 0.16968212653933712, 0.15023210862774394, 0.14938982545497348, 0.5345065084217684, 0.3925973379115292, 0.501162113080057, 0.21411065416242636, 0.2127683016083336, 0.105237221246827, 0.5403138581297193, 0.36233078815169917, 0.18154529264887365, 0.19034695359780784, 0.18705007118961925, 0.18731944499283237, 0.18862450994714908, 0.181368886160578, 0.17684088976439394, 0.18598429030599295, 0.18143220521539383, 0.10188353392374716, 0.07538361466450083, 0.07502758819782429, 0.08189984021125563, 0.07672220611827174, 0.07808450200416772, 0.1002375240971789, 0.09321245465027461, 0.07584274895336707]}, "mutation_prompt": null}
{"id": "52b0e4d5-bd11-4ee5-9b86-7b6a7d1910d0", "solution": "import numpy as np\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        if np.random.rand() > 0.5:\n            crossover_point = np.random.randint(1, self.dim-1)\n            child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        else:\n            alpha = np.random.rand(self.dim)\n            child = alpha * parent1 + (1 - alpha) * parent2\n        return child\n    \n    def _mutate(self, individual, generation):\n        adaptive_mutation_rate = self.mutation_rate * (1 - generation / self.budget)\n        for i in range(self.dim):\n            if np.random.rand() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n        generation = 0\n\n        while self.evaluations < self.budget:\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1, generation)\n                child2 = self._mutate(child2, generation)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n            generation += 1\n        \n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "An enhanced hybrid genetic algorithm utilizing adaptive mutation rates and elite replacement for faster convergence.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ba0ad45e-79a5-497a-a152-a00347f6aeec", "metadata": {"aucs": [0.5188767331596345, 0.5064088709886925, 0.529496447239648, 0.5144420539623902, 0.5370488447429549, 0.5112964000634398, 0.5443189240093997, 0.5151759905658304, 0.5295974625296624, 0.11628763434397549, 0.073237962137081, 0.1171960218681154, 0.1328054441372537, 0.06734962385719301, 0.18702089088395346, 0.11794777197766848, 0.16142451141806613, 0.09479736946696471, 0.13340173656759524, 0.11187463710972767, 0.13141237757711532, 0.13803893579674764, 0.14700684185232926, 0.23298106805301155, 0.15599881259017334, 0.13753294373569147, 0.14748159785705617, 0.10876875324652024, 0.1199588748125876, 0.11442623443949529, 0.1376682920812753, 0.10753935447249918, 0.11529412838556907, 0.14411587550759053, 0.12631171847284206, 0.09899476319301614, 0.8657788659263602, 0.8708037771669245, 0.8456890545782719, 0.852582574405035, 0.8831960734694649, 0.8854751829924894, 0.8679232429229845, 0.9140837729660892, 0.9015444725811272, 0.3568268521148178, 0.34169183216634236, 0.3275012350470019, 0.3020994963658874, 0.3330206291499205, 0.3610407508786032, 0.33862374062362166, 0.3033525987268578, 0.29969884168468375, 0.1565724305817624, 0.24612530080806716, 0.1426010858307345, 0.2145150807661389, 0.26942187158728426, 0.35259656298456443, 0.15752276978004842, 0.23846888290241963, 0.1995849784012269, 0.17774147063968737, 0.1654716515977942, 0.17840744983435375, 0.15724909282867372, 0.20144777914869705, 0.17030827069467014, 0.16330246182093688, 0.24655007798684248, 0.3514770322958348, 0.14225247094640325, 0.13435904494185447, 0.17037749954018255, 0.16814900747676498, 0.2131401520323899, 0.15134788406363442, 0.14338955739022818, 0.29561775046554084, 0.15586750501445734, 9.999999999998899e-05, 9.999999999998899e-05, 0.0035166480994790472, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06961805886886052, 0.025233134646751365, 0.06903749483907706, 0.05645912279153509, 0.023355064750135157, 0.007827625196492938, 0.11200956379572746, 0.06318894312464596, 0.07997994142271458, 0.006665368751889056, 0.01157989821538663, 0.0017879740169762792, 0.00037159721867408013, 0.014947521855188661, 0.00412625368969477, 9.999999999998899e-05, 0.017349969084643257, 0.0288434555395799, 0.11476562071290586, 0.09215900389490728, 0.1390202896632774, 0.10268411211077477, 0.15948143646883395, 0.05918458680430527, 0.1635227025727929, 0.1255441073180733, 0.08405591483482644, 0.4897452909625738, 0.468474821918648, 0.4482336644336633, 0.46810298655440497, 0.4340659450409212, 0.46357283616222056, 0.4808855253363665, 0.4599415934511112, 0.4624649242993303, 0.09612734276923707, 0.09116039412042976, 0.04977867560294946, 0.1898093805089569, 0.10496876212120221, 0.06321529017138294, 0.07345975748157285, 0.07668599384362873, 0.10252236141264515, 0.24700017564221022, 0.2446872303976746, 0.22846517531484667, 0.31439445608657246, 0.2839388691347797, 0.1889649936153983, 0.25740041441158334, 0.18576644935792974, 0.21280984219620136, 0.21531507504464076, 0.20831586277199543, 0.15805015565264835, 0.2224181463999947, 0.22630207944566505, 0.24714886348589782, 0.3333252362352441, 0.344323674464301, 0.3200394607320015, 0.18958770263436542, 0.2653879417765064, 0.2140139407956907, 0.22514312964500183, 0.19190956803712, 0.21345436527623785, 0.18053751764889692, 0.27381120341821585, 0.24499272608489986, 0.2655839730192584, 0.2551418397180554, 0.20957167420847034, 0.19588568342895574, 0.17548267970119247, 0.23386637959141454, 0.20526428858870627, 0.2081861724669316, 0.20663037237230641, 0.21114615850956675, 0.20210698859591936, 0.1992334651046238, 0.19377810514516836, 0.1824560207628787, 0.21544272153051447, 0.19972876917705684, 0.18556784259466508, 0.17953088823492835, 0.11672352782602902, 0.12712245852129767, 0.15365179749505953, 0.7952637986062888, 0.7358143023317176, 0.7555169639492753, 0.15403889412227878, 0.16968212653933712, 0.15023210862774394, 0.14938982545497348, 0.5345065084217684, 0.3925973379115292, 0.501162113080057, 0.21411065416242636, 0.2127683016083336, 0.105237221246827, 0.5403138581297193, 0.36233078815169917, 0.18154529264887365, 0.19034695359780784, 0.18705007118961925, 0.18731944499283237, 0.18862450994714908, 0.181368886160578, 0.17684088976439394, 0.18598429030599295, 0.18143220521539383, 0.10188353392374716, 0.07538361466450083, 0.07502758819782429, 0.08189984021125563, 0.07672220611827174, 0.07808450200416772, 0.1002375240971789, 0.09321245465027461, 0.07584274895336707]}, "mutation_prompt": null}
{"id": "32cf5e4d-f507-4343-8cb1-db89ba0152ec", "solution": "import numpy as np\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        if np.random.rand() > 0.5:\n            crossover_point = np.random.randint(1, self.dim-1)\n            child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        else:\n            alpha = np.random.rand(self.dim)\n            child = alpha * parent1 + (1 - alpha) * parent2\n        return child\n    \n    def _mutate(self, individual, generation):\n        adaptive_mutation_rate = self.mutation_rate * (1 - generation / self.budget)\n        for i in range(self.dim):\n            if np.random.rand() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n        generation = 0\n\n        while self.evaluations < self.budget:\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1, generation)\n                child2 = self._mutate(child2, generation)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n            generation += 1\n        \n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "An enhanced hybrid genetic algorithm utilizing adaptive mutation rates and elite replacement for faster convergence.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ba0ad45e-79a5-497a-a152-a00347f6aeec", "metadata": {"aucs": [0.5188767331596345, 0.5064088709886925, 0.529496447239648, 0.5144420539623902, 0.5370488447429549, 0.5112964000634398, 0.5443189240093997, 0.5151759905658304, 0.5295974625296624, 0.11628763434397549, 0.073237962137081, 0.1171960218681154, 0.1328054441372537, 0.06734962385719301, 0.18702089088395346, 0.11794777197766848, 0.16142451141806613, 0.09479736946696471, 0.13340173656759524, 0.11187463710972767, 0.13141237757711532, 0.13803893579674764, 0.14700684185232926, 0.23298106805301155, 0.15599881259017334, 0.13753294373569147, 0.14748159785705617, 0.10876875324652024, 0.1199588748125876, 0.11442623443949529, 0.1376682920812753, 0.10753935447249918, 0.11529412838556907, 0.14411587550759053, 0.12631171847284206, 0.09899476319301614, 0.8657788659263602, 0.8708037771669245, 0.8456890545782719, 0.852582574405035, 0.8831960734694649, 0.8854751829924894, 0.8679232429229845, 0.9140837729660892, 0.9015444725811272, 0.3568268521148178, 0.34169183216634236, 0.3275012350470019, 0.3020994963658874, 0.3330206291499205, 0.3610407508786032, 0.33862374062362166, 0.3033525987268578, 0.29969884168468375, 0.1565724305817624, 0.24612530080806716, 0.1426010858307345, 0.2145150807661389, 0.26942187158728426, 0.35259656298456443, 0.15752276978004842, 0.23846888290241963, 0.1995849784012269, 0.17774147063968737, 0.1654716515977942, 0.17840744983435375, 0.15724909282867372, 0.20144777914869705, 0.17030827069467014, 0.16330246182093688, 0.24655007798684248, 0.3514770322958348, 0.14225247094640325, 0.13435904494185447, 0.17037749954018255, 0.16814900747676498, 0.2131401520323899, 0.15134788406363442, 0.14338955739022818, 0.29561775046554084, 0.15586750501445734, 9.999999999998899e-05, 9.999999999998899e-05, 0.0035166480994790472, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06961805886886052, 0.025233134646751365, 0.06903749483907706, 0.05645912279153509, 0.023355064750135157, 0.007827625196492938, 0.11200956379572746, 0.06318894312464596, 0.07997994142271458, 0.006665368751889056, 0.01157989821538663, 0.0017879740169762792, 0.00037159721867408013, 0.014947521855188661, 0.00412625368969477, 9.999999999998899e-05, 0.017349969084643257, 0.0288434555395799, 0.11476562071290586, 0.09215900389490728, 0.1390202896632774, 0.10268411211077477, 0.15948143646883395, 0.05918458680430527, 0.1635227025727929, 0.1255441073180733, 0.08405591483482644, 0.4897452909625738, 0.468474821918648, 0.4482336644336633, 0.46810298655440497, 0.4340659450409212, 0.46357283616222056, 0.4808855253363665, 0.4599415934511112, 0.4624649242993303, 0.09612734276923707, 0.09116039412042976, 0.04977867560294946, 0.1898093805089569, 0.10496876212120221, 0.06321529017138294, 0.07345975748157285, 0.07668599384362873, 0.10252236141264515, 0.24700017564221022, 0.2446872303976746, 0.22846517531484667, 0.31439445608657246, 0.2839388691347797, 0.1889649936153983, 0.25740041441158334, 0.18576644935792974, 0.21280984219620136, 0.21531507504464076, 0.20831586277199543, 0.15805015565264835, 0.2224181463999947, 0.22630207944566505, 0.24714886348589782, 0.3333252362352441, 0.344323674464301, 0.3200394607320015, 0.18958770263436542, 0.2653879417765064, 0.2140139407956907, 0.22514312964500183, 0.19190956803712, 0.21345436527623785, 0.18053751764889692, 0.27381120341821585, 0.24499272608489986, 0.2655839730192584, 0.2551418397180554, 0.20957167420847034, 0.19588568342895574, 0.17548267970119247, 0.23386637959141454, 0.20526428858870627, 0.2081861724669316, 0.20663037237230641, 0.21114615850956675, 0.20210698859591936, 0.1992334651046238, 0.19377810514516836, 0.1824560207628787, 0.21544272153051447, 0.19972876917705684, 0.18556784259466508, 0.17953088823492835, 0.11672352782602902, 0.12712245852129767, 0.15365179749505953, 0.7952637986062888, 0.7358143023317176, 0.7555169639492753, 0.15403889412227878, 0.16968212653933712, 0.15023210862774394, 0.14938982545497348, 0.5345065084217684, 0.3925973379115292, 0.501162113080057, 0.21411065416242636, 0.2127683016083336, 0.105237221246827, 0.5403138581297193, 0.36233078815169917, 0.18154529264887365, 0.19034695359780784, 0.18705007118961925, 0.18731944499283237, 0.18862450994714908, 0.181368886160578, 0.17684088976439394, 0.18598429030599295, 0.18143220521539383, 0.10188353392374716, 0.07538361466450083, 0.07502758819782429, 0.08189984021125563, 0.07672220611827174, 0.07808450200416772, 0.1002375240971789, 0.09321245465027461, 0.07584274895336707]}, "mutation_prompt": null}
{"id": "fb4f24c6-019d-4ce9-a799-6b83b947315a", "solution": "import numpy as np\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        if np.random.rand() > 0.5:\n            crossover_point = np.random.randint(1, self.dim-1)\n            child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        else:\n            alpha = np.random.rand(self.dim)\n            child = alpha * parent1 + (1 - alpha) * parent2\n        return child\n    \n    def _mutate(self, individual, generation):\n        adaptive_mutation_rate = self.mutation_rate * (1 - generation / self.budget)\n        for i in range(self.dim):\n            if np.random.rand() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n        generation = 0\n\n        while self.evaluations < self.budget:\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1, generation)\n                child2 = self._mutate(child2, generation)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n            generation += 1\n        \n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "An enhanced hybrid genetic algorithm utilizing adaptive mutation rates and elite replacement for faster convergence.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ba0ad45e-79a5-497a-a152-a00347f6aeec", "metadata": {"aucs": [0.5188767331596345, 0.5064088709886925, 0.529496447239648, 0.5144420539623902, 0.5370488447429549, 0.5112964000634398, 0.5443189240093997, 0.5151759905658304, 0.5295974625296624, 0.11628763434397549, 0.073237962137081, 0.1171960218681154, 0.1328054441372537, 0.06734962385719301, 0.18702089088395346, 0.11794777197766848, 0.16142451141806613, 0.09479736946696471, 0.13340173656759524, 0.11187463710972767, 0.13141237757711532, 0.13803893579674764, 0.14700684185232926, 0.23298106805301155, 0.15599881259017334, 0.13753294373569147, 0.14748159785705617, 0.10876875324652024, 0.1199588748125876, 0.11442623443949529, 0.1376682920812753, 0.10753935447249918, 0.11529412838556907, 0.14411587550759053, 0.12631171847284206, 0.09899476319301614, 0.8657788659263602, 0.8708037771669245, 0.8456890545782719, 0.852582574405035, 0.8831960734694649, 0.8854751829924894, 0.8679232429229845, 0.9140837729660892, 0.9015444725811272, 0.3568268521148178, 0.34169183216634236, 0.3275012350470019, 0.3020994963658874, 0.3330206291499205, 0.3610407508786032, 0.33862374062362166, 0.3033525987268578, 0.29969884168468375, 0.1565724305817624, 0.24612530080806716, 0.1426010858307345, 0.2145150807661389, 0.26942187158728426, 0.35259656298456443, 0.15752276978004842, 0.23846888290241963, 0.1995849784012269, 0.17774147063968737, 0.1654716515977942, 0.17840744983435375, 0.15724909282867372, 0.20144777914869705, 0.17030827069467014, 0.16330246182093688, 0.24655007798684248, 0.3514770322958348, 0.14225247094640325, 0.13435904494185447, 0.17037749954018255, 0.16814900747676498, 0.2131401520323899, 0.15134788406363442, 0.14338955739022818, 0.29561775046554084, 0.15586750501445734, 9.999999999998899e-05, 9.999999999998899e-05, 0.0035166480994790472, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06961805886886052, 0.025233134646751365, 0.06903749483907706, 0.05645912279153509, 0.023355064750135157, 0.007827625196492938, 0.11200956379572746, 0.06318894312464596, 0.07997994142271458, 0.006665368751889056, 0.01157989821538663, 0.0017879740169762792, 0.00037159721867408013, 0.014947521855188661, 0.00412625368969477, 9.999999999998899e-05, 0.017349969084643257, 0.0288434555395799, 0.11476562071290586, 0.09215900389490728, 0.1390202896632774, 0.10268411211077477, 0.15948143646883395, 0.05918458680430527, 0.1635227025727929, 0.1255441073180733, 0.08405591483482644, 0.4897452909625738, 0.468474821918648, 0.4482336644336633, 0.46810298655440497, 0.4340659450409212, 0.46357283616222056, 0.4808855253363665, 0.4599415934511112, 0.4624649242993303, 0.09612734276923707, 0.09116039412042976, 0.04977867560294946, 0.1898093805089569, 0.10496876212120221, 0.06321529017138294, 0.07345975748157285, 0.07668599384362873, 0.10252236141264515, 0.24700017564221022, 0.2446872303976746, 0.22846517531484667, 0.31439445608657246, 0.2839388691347797, 0.1889649936153983, 0.25740041441158334, 0.18576644935792974, 0.21280984219620136, 0.21531507504464076, 0.20831586277199543, 0.15805015565264835, 0.2224181463999947, 0.22630207944566505, 0.24714886348589782, 0.3333252362352441, 0.344323674464301, 0.3200394607320015, 0.18958770263436542, 0.2653879417765064, 0.2140139407956907, 0.22514312964500183, 0.19190956803712, 0.21345436527623785, 0.18053751764889692, 0.27381120341821585, 0.24499272608489986, 0.2655839730192584, 0.2551418397180554, 0.20957167420847034, 0.19588568342895574, 0.17548267970119247, 0.23386637959141454, 0.20526428858870627, 0.2081861724669316, 0.20663037237230641, 0.21114615850956675, 0.20210698859591936, 0.1992334651046238, 0.19377810514516836, 0.1824560207628787, 0.21544272153051447, 0.19972876917705684, 0.18556784259466508, 0.17953088823492835, 0.11672352782602902, 0.12712245852129767, 0.15365179749505953, 0.7952637986062888, 0.7358143023317176, 0.7555169639492753, 0.15403889412227878, 0.16968212653933712, 0.15023210862774394, 0.14938982545497348, 0.5345065084217684, 0.3925973379115292, 0.501162113080057, 0.21411065416242636, 0.2127683016083336, 0.105237221246827, 0.5403138581297193, 0.36233078815169917, 0.18154529264887365, 0.19034695359780784, 0.18705007118961925, 0.18731944499283237, 0.18862450994714908, 0.181368886160578, 0.17684088976439394, 0.18598429030599295, 0.18143220521539383, 0.10188353392374716, 0.07538361466450083, 0.07502758819782429, 0.08189984021125563, 0.07672220611827174, 0.07808450200416772, 0.1002375240971789, 0.09321245465027461, 0.07584274895336707]}, "mutation_prompt": null}
{"id": "03e6b401-0ab9-4d30-aae3-96dadc61205f", "solution": "import numpy as np\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        if np.random.rand() > 0.5:\n            crossover_point = np.random.randint(1, self.dim-1)\n            child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        else:\n            alpha = np.random.rand(self.dim)\n            child = alpha * parent1 + (1 - alpha) * parent2\n        return child\n    \n    def _mutate(self, individual, generation):\n        adaptive_mutation_rate = self.mutation_rate * (1 - generation / self.budget)\n        for i in range(self.dim):\n            if np.random.rand() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n        generation = 0\n\n        while self.evaluations < self.budget:\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1, generation)\n                child2 = self._mutate(child2, generation)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n            generation += 1\n        \n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "An enhanced hybrid genetic algorithm utilizing adaptive mutation rates and elite replacement for faster convergence.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ba0ad45e-79a5-497a-a152-a00347f6aeec", "metadata": {"aucs": [0.5188767331596345, 0.5064088709886925, 0.529496447239648, 0.5144420539623902, 0.5370488447429549, 0.5112964000634398, 0.5443189240093997, 0.5151759905658304, 0.5295974625296624, 0.11628763434397549, 0.073237962137081, 0.1171960218681154, 0.1328054441372537, 0.06734962385719301, 0.18702089088395346, 0.11794777197766848, 0.16142451141806613, 0.09479736946696471, 0.13340173656759524, 0.11187463710972767, 0.13141237757711532, 0.13803893579674764, 0.14700684185232926, 0.23298106805301155, 0.15599881259017334, 0.13753294373569147, 0.14748159785705617, 0.10876875324652024, 0.1199588748125876, 0.11442623443949529, 0.1376682920812753, 0.10753935447249918, 0.11529412838556907, 0.14411587550759053, 0.12631171847284206, 0.09899476319301614, 0.8657788659263602, 0.8708037771669245, 0.8456890545782719, 0.852582574405035, 0.8831960734694649, 0.8854751829924894, 0.8679232429229845, 0.9140837729660892, 0.9015444725811272, 0.3568268521148178, 0.34169183216634236, 0.3275012350470019, 0.3020994963658874, 0.3330206291499205, 0.3610407508786032, 0.33862374062362166, 0.3033525987268578, 0.29969884168468375, 0.1565724305817624, 0.24612530080806716, 0.1426010858307345, 0.2145150807661389, 0.26942187158728426, 0.35259656298456443, 0.15752276978004842, 0.23846888290241963, 0.1995849784012269, 0.17774147063968737, 0.1654716515977942, 0.17840744983435375, 0.15724909282867372, 0.20144777914869705, 0.17030827069467014, 0.16330246182093688, 0.24655007798684248, 0.3514770322958348, 0.14225247094640325, 0.13435904494185447, 0.17037749954018255, 0.16814900747676498, 0.2131401520323899, 0.15134788406363442, 0.14338955739022818, 0.29561775046554084, 0.15586750501445734, 9.999999999998899e-05, 9.999999999998899e-05, 0.0035166480994790472, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06961805886886052, 0.025233134646751365, 0.06903749483907706, 0.05645912279153509, 0.023355064750135157, 0.007827625196492938, 0.11200956379572746, 0.06318894312464596, 0.07997994142271458, 0.006665368751889056, 0.01157989821538663, 0.0017879740169762792, 0.00037159721867408013, 0.014947521855188661, 0.00412625368969477, 9.999999999998899e-05, 0.017349969084643257, 0.0288434555395799, 0.11476562071290586, 0.09215900389490728, 0.1390202896632774, 0.10268411211077477, 0.15948143646883395, 0.05918458680430527, 0.1635227025727929, 0.1255441073180733, 0.08405591483482644, 0.4897452909625738, 0.468474821918648, 0.4482336644336633, 0.46810298655440497, 0.4340659450409212, 0.46357283616222056, 0.4808855253363665, 0.4599415934511112, 0.4624649242993303, 0.09612734276923707, 0.09116039412042976, 0.04977867560294946, 0.1898093805089569, 0.10496876212120221, 0.06321529017138294, 0.07345975748157285, 0.07668599384362873, 0.10252236141264515, 0.24700017564221022, 0.2446872303976746, 0.22846517531484667, 0.31439445608657246, 0.2839388691347797, 0.1889649936153983, 0.25740041441158334, 0.18576644935792974, 0.21280984219620136, 0.21531507504464076, 0.20831586277199543, 0.15805015565264835, 0.2224181463999947, 0.22630207944566505, 0.24714886348589782, 0.3333252362352441, 0.344323674464301, 0.3200394607320015, 0.18958770263436542, 0.2653879417765064, 0.2140139407956907, 0.22514312964500183, 0.19190956803712, 0.21345436527623785, 0.18053751764889692, 0.27381120341821585, 0.24499272608489986, 0.2655839730192584, 0.2551418397180554, 0.20957167420847034, 0.19588568342895574, 0.17548267970119247, 0.23386637959141454, 0.20526428858870627, 0.2081861724669316, 0.20663037237230641, 0.21114615850956675, 0.20210698859591936, 0.1992334651046238, 0.19377810514516836, 0.1824560207628787, 0.21544272153051447, 0.19972876917705684, 0.18556784259466508, 0.17953088823492835, 0.11672352782602902, 0.12712245852129767, 0.15365179749505953, 0.7952637986062888, 0.7358143023317176, 0.7555169639492753, 0.15403889412227878, 0.16968212653933712, 0.15023210862774394, 0.14938982545497348, 0.5345065084217684, 0.3925973379115292, 0.501162113080057, 0.21411065416242636, 0.2127683016083336, 0.105237221246827, 0.5403138581297193, 0.36233078815169917, 0.18154529264887365, 0.19034695359780784, 0.18705007118961925, 0.18731944499283237, 0.18862450994714908, 0.181368886160578, 0.17684088976439394, 0.18598429030599295, 0.18143220521539383, 0.10188353392374716, 0.07538361466450083, 0.07502758819782429, 0.08189984021125563, 0.07672220611827174, 0.07808450200416772, 0.1002375240971789, 0.09321245465027461, 0.07584274895336707]}, "mutation_prompt": null}
{"id": "c076011d-2d26-4637-a7b7-11a05ab21e8c", "solution": "import numpy as np\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        if np.random.rand() > 0.5:\n            crossover_point = np.random.randint(1, self.dim-1)\n            child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        else:\n            alpha = np.random.rand(self.dim)\n            child = alpha * parent1 + (1 - alpha) * parent2\n        return child\n    \n    def _mutate(self, individual, generation):\n        adaptive_mutation_rate = self.mutation_rate * (1 - generation / self.budget)\n        for i in range(self.dim):\n            if np.random.rand() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n        generation = 0\n\n        while self.evaluations < self.budget:\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1, generation)\n                child2 = self._mutate(child2, generation)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n            generation += 1\n        \n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "An enhanced hybrid genetic algorithm utilizing adaptive mutation rates and elite replacement for faster convergence.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ba0ad45e-79a5-497a-a152-a00347f6aeec", "metadata": {"aucs": [0.5188767331596345, 0.5064088709886925, 0.529496447239648, 0.5144420539623902, 0.5370488447429549, 0.5112964000634398, 0.5443189240093997, 0.5151759905658304, 0.5295974625296624, 0.11628763434397549, 0.073237962137081, 0.1171960218681154, 0.1328054441372537, 0.06734962385719301, 0.18702089088395346, 0.11794777197766848, 0.16142451141806613, 0.09479736946696471, 0.13340173656759524, 0.11187463710972767, 0.13141237757711532, 0.13803893579674764, 0.14700684185232926, 0.23298106805301155, 0.15599881259017334, 0.13753294373569147, 0.14748159785705617, 0.10876875324652024, 0.1199588748125876, 0.11442623443949529, 0.1376682920812753, 0.10753935447249918, 0.11529412838556907, 0.14411587550759053, 0.12631171847284206, 0.09899476319301614, 0.8657788659263602, 0.8708037771669245, 0.8456890545782719, 0.852582574405035, 0.8831960734694649, 0.8854751829924894, 0.8679232429229845, 0.9140837729660892, 0.9015444725811272, 0.3568268521148178, 0.34169183216634236, 0.3275012350470019, 0.3020994963658874, 0.3330206291499205, 0.3610407508786032, 0.33862374062362166, 0.3033525987268578, 0.29969884168468375, 0.1565724305817624, 0.24612530080806716, 0.1426010858307345, 0.2145150807661389, 0.26942187158728426, 0.35259656298456443, 0.15752276978004842, 0.23846888290241963, 0.1995849784012269, 0.17774147063968737, 0.1654716515977942, 0.17840744983435375, 0.15724909282867372, 0.20144777914869705, 0.17030827069467014, 0.16330246182093688, 0.24655007798684248, 0.3514770322958348, 0.14225247094640325, 0.13435904494185447, 0.17037749954018255, 0.16814900747676498, 0.2131401520323899, 0.15134788406363442, 0.14338955739022818, 0.29561775046554084, 0.15586750501445734, 9.999999999998899e-05, 9.999999999998899e-05, 0.0035166480994790472, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06961805886886052, 0.025233134646751365, 0.06903749483907706, 0.05645912279153509, 0.023355064750135157, 0.007827625196492938, 0.11200956379572746, 0.06318894312464596, 0.07997994142271458, 0.006665368751889056, 0.01157989821538663, 0.0017879740169762792, 0.00037159721867408013, 0.014947521855188661, 0.00412625368969477, 9.999999999998899e-05, 0.017349969084643257, 0.0288434555395799, 0.11476562071290586, 0.09215900389490728, 0.1390202896632774, 0.10268411211077477, 0.15948143646883395, 0.05918458680430527, 0.1635227025727929, 0.1255441073180733, 0.08405591483482644, 0.4897452909625738, 0.468474821918648, 0.4482336644336633, 0.46810298655440497, 0.4340659450409212, 0.46357283616222056, 0.4808855253363665, 0.4599415934511112, 0.4624649242993303, 0.09612734276923707, 0.09116039412042976, 0.04977867560294946, 0.1898093805089569, 0.10496876212120221, 0.06321529017138294, 0.07345975748157285, 0.07668599384362873, 0.10252236141264515, 0.24700017564221022, 0.2446872303976746, 0.22846517531484667, 0.31439445608657246, 0.2839388691347797, 0.1889649936153983, 0.25740041441158334, 0.18576644935792974, 0.21280984219620136, 0.21531507504464076, 0.20831586277199543, 0.15805015565264835, 0.2224181463999947, 0.22630207944566505, 0.24714886348589782, 0.3333252362352441, 0.344323674464301, 0.3200394607320015, 0.18958770263436542, 0.2653879417765064, 0.2140139407956907, 0.22514312964500183, 0.19190956803712, 0.21345436527623785, 0.18053751764889692, 0.27381120341821585, 0.24499272608489986, 0.2655839730192584, 0.2551418397180554, 0.20957167420847034, 0.19588568342895574, 0.17548267970119247, 0.23386637959141454, 0.20526428858870627, 0.2081861724669316, 0.20663037237230641, 0.21114615850956675, 0.20210698859591936, 0.1992334651046238, 0.19377810514516836, 0.1824560207628787, 0.21544272153051447, 0.19972876917705684, 0.18556784259466508, 0.17953088823492835, 0.11672352782602902, 0.12712245852129767, 0.15365179749505953, 0.7952637986062888, 0.7358143023317176, 0.7555169639492753, 0.15403889412227878, 0.16968212653933712, 0.15023210862774394, 0.14938982545497348, 0.5345065084217684, 0.3925973379115292, 0.501162113080057, 0.21411065416242636, 0.2127683016083336, 0.105237221246827, 0.5403138581297193, 0.36233078815169917, 0.18154529264887365, 0.19034695359780784, 0.18705007118961925, 0.18731944499283237, 0.18862450994714908, 0.181368886160578, 0.17684088976439394, 0.18598429030599295, 0.18143220521539383, 0.10188353392374716, 0.07538361466450083, 0.07502758819782429, 0.08189984021125563, 0.07672220611827174, 0.07808450200416772, 0.1002375240971789, 0.09321245465027461, 0.07584274895336707]}, "mutation_prompt": null}
{"id": "b87aa3a5-408c-4e95-8b9e-01e6ff1d69db", "solution": "import numpy as np\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        if np.random.rand() > 0.5:\n            crossover_point = np.random.randint(1, self.dim-1)\n            child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        else:\n            alpha = np.random.rand(self.dim)\n            child = alpha * parent1 + (1 - alpha) * parent2\n        return child\n    \n    def _mutate(self, individual, generation):\n        adaptive_mutation_rate = self.mutation_rate * (1 - generation / self.budget)\n        for i in range(self.dim):\n            if np.random.rand() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n        generation = 0\n\n        while self.evaluations < self.budget:\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1, generation)\n                child2 = self._mutate(child2, generation)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n            generation += 1\n        \n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "An enhanced hybrid genetic algorithm utilizing adaptive mutation rates and elite replacement for faster convergence.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ba0ad45e-79a5-497a-a152-a00347f6aeec", "metadata": {"aucs": [0.5188767331596345, 0.5064088709886925, 0.529496447239648, 0.5144420539623902, 0.5370488447429549, 0.5112964000634398, 0.5443189240093997, 0.5151759905658304, 0.5295974625296624, 0.11628763434397549, 0.073237962137081, 0.1171960218681154, 0.1328054441372537, 0.06734962385719301, 0.18702089088395346, 0.11794777197766848, 0.16142451141806613, 0.09479736946696471, 0.13340173656759524, 0.11187463710972767, 0.13141237757711532, 0.13803893579674764, 0.14700684185232926, 0.23298106805301155, 0.15599881259017334, 0.13753294373569147, 0.14748159785705617, 0.10876875324652024, 0.1199588748125876, 0.11442623443949529, 0.1376682920812753, 0.10753935447249918, 0.11529412838556907, 0.14411587550759053, 0.12631171847284206, 0.09899476319301614, 0.8657788659263602, 0.8708037771669245, 0.8456890545782719, 0.852582574405035, 0.8831960734694649, 0.8854751829924894, 0.8679232429229845, 0.9140837729660892, 0.9015444725811272, 0.3568268521148178, 0.34169183216634236, 0.3275012350470019, 0.3020994963658874, 0.3330206291499205, 0.3610407508786032, 0.33862374062362166, 0.3033525987268578, 0.29969884168468375, 0.1565724305817624, 0.24612530080806716, 0.1426010858307345, 0.2145150807661389, 0.26942187158728426, 0.35259656298456443, 0.15752276978004842, 0.23846888290241963, 0.1995849784012269, 0.17774147063968737, 0.1654716515977942, 0.17840744983435375, 0.15724909282867372, 0.20144777914869705, 0.17030827069467014, 0.16330246182093688, 0.24655007798684248, 0.3514770322958348, 0.14225247094640325, 0.13435904494185447, 0.17037749954018255, 0.16814900747676498, 0.2131401520323899, 0.15134788406363442, 0.14338955739022818, 0.29561775046554084, 0.15586750501445734, 9.999999999998899e-05, 9.999999999998899e-05, 0.0035166480994790472, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06961805886886052, 0.025233134646751365, 0.06903749483907706, 0.05645912279153509, 0.023355064750135157, 0.007827625196492938, 0.11200956379572746, 0.06318894312464596, 0.07997994142271458, 0.006665368751889056, 0.01157989821538663, 0.0017879740169762792, 0.00037159721867408013, 0.014947521855188661, 0.00412625368969477, 9.999999999998899e-05, 0.017349969084643257, 0.0288434555395799, 0.11476562071290586, 0.09215900389490728, 0.1390202896632774, 0.10268411211077477, 0.15948143646883395, 0.05918458680430527, 0.1635227025727929, 0.1255441073180733, 0.08405591483482644, 0.4897452909625738, 0.468474821918648, 0.4482336644336633, 0.46810298655440497, 0.4340659450409212, 0.46357283616222056, 0.4808855253363665, 0.4599415934511112, 0.4624649242993303, 0.09612734276923707, 0.09116039412042976, 0.04977867560294946, 0.1898093805089569, 0.10496876212120221, 0.06321529017138294, 0.07345975748157285, 0.07668599384362873, 0.10252236141264515, 0.24700017564221022, 0.2446872303976746, 0.22846517531484667, 0.31439445608657246, 0.2839388691347797, 0.1889649936153983, 0.25740041441158334, 0.18576644935792974, 0.21280984219620136, 0.21531507504464076, 0.20831586277199543, 0.15805015565264835, 0.2224181463999947, 0.22630207944566505, 0.24714886348589782, 0.3333252362352441, 0.344323674464301, 0.3200394607320015, 0.18958770263436542, 0.2653879417765064, 0.2140139407956907, 0.22514312964500183, 0.19190956803712, 0.21345436527623785, 0.18053751764889692, 0.27381120341821585, 0.24499272608489986, 0.2655839730192584, 0.2551418397180554, 0.20957167420847034, 0.19588568342895574, 0.17548267970119247, 0.23386637959141454, 0.20526428858870627, 0.2081861724669316, 0.20663037237230641, 0.21114615850956675, 0.20210698859591936, 0.1992334651046238, 0.19377810514516836, 0.1824560207628787, 0.21544272153051447, 0.19972876917705684, 0.18556784259466508, 0.17953088823492835, 0.11672352782602902, 0.12712245852129767, 0.15365179749505953, 0.7952637986062888, 0.7358143023317176, 0.7555169639492753, 0.15403889412227878, 0.16968212653933712, 0.15023210862774394, 0.14938982545497348, 0.5345065084217684, 0.3925973379115292, 0.501162113080057, 0.21411065416242636, 0.2127683016083336, 0.105237221246827, 0.5403138581297193, 0.36233078815169917, 0.18154529264887365, 0.19034695359780784, 0.18705007118961925, 0.18731944499283237, 0.18862450994714908, 0.181368886160578, 0.17684088976439394, 0.18598429030599295, 0.18143220521539383, 0.10188353392374716, 0.07538361466450083, 0.07502758819782429, 0.08189984021125563, 0.07672220611827174, 0.07808450200416772, 0.1002375240971789, 0.09321245465027461, 0.07584274895336707]}, "mutation_prompt": null}
{"id": "d812853a-ff88-455f-9cc4-cab834230be4", "solution": "import numpy as np\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        if np.random.rand() > 0.5:\n            crossover_point = np.random.randint(1, self.dim-1)\n            child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        else:\n            alpha = np.random.rand(self.dim)\n            child = alpha * parent1 + (1 - alpha) * parent2\n        return child\n    \n    def _mutate(self, individual, generation):\n        adaptive_mutation_rate = self.mutation_rate * (1 - generation / self.budget)\n        for i in range(self.dim):\n            if np.random.rand() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n        generation = 0\n\n        while self.evaluations < self.budget:\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1, generation)\n                child2 = self._mutate(child2, generation)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n            generation += 1\n        \n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "An enhanced hybrid genetic algorithm utilizing adaptive mutation rates and elite replacement for faster convergence.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ba0ad45e-79a5-497a-a152-a00347f6aeec", "metadata": {"aucs": [0.5188767331596345, 0.5064088709886925, 0.529496447239648, 0.5144420539623902, 0.5370488447429549, 0.5112964000634398, 0.5443189240093997, 0.5151759905658304, 0.5295974625296624, 0.11628763434397549, 0.073237962137081, 0.1171960218681154, 0.1328054441372537, 0.06734962385719301, 0.18702089088395346, 0.11794777197766848, 0.16142451141806613, 0.09479736946696471, 0.13340173656759524, 0.11187463710972767, 0.13141237757711532, 0.13803893579674764, 0.14700684185232926, 0.23298106805301155, 0.15599881259017334, 0.13753294373569147, 0.14748159785705617, 0.10876875324652024, 0.1199588748125876, 0.11442623443949529, 0.1376682920812753, 0.10753935447249918, 0.11529412838556907, 0.14411587550759053, 0.12631171847284206, 0.09899476319301614, 0.8657788659263602, 0.8708037771669245, 0.8456890545782719, 0.852582574405035, 0.8831960734694649, 0.8854751829924894, 0.8679232429229845, 0.9140837729660892, 0.9015444725811272, 0.3568268521148178, 0.34169183216634236, 0.3275012350470019, 0.3020994963658874, 0.3330206291499205, 0.3610407508786032, 0.33862374062362166, 0.3033525987268578, 0.29969884168468375, 0.1565724305817624, 0.24612530080806716, 0.1426010858307345, 0.2145150807661389, 0.26942187158728426, 0.35259656298456443, 0.15752276978004842, 0.23846888290241963, 0.1995849784012269, 0.17774147063968737, 0.1654716515977942, 0.17840744983435375, 0.15724909282867372, 0.20144777914869705, 0.17030827069467014, 0.16330246182093688, 0.24655007798684248, 0.3514770322958348, 0.14225247094640325, 0.13435904494185447, 0.17037749954018255, 0.16814900747676498, 0.2131401520323899, 0.15134788406363442, 0.14338955739022818, 0.29561775046554084, 0.15586750501445734, 9.999999999998899e-05, 9.999999999998899e-05, 0.0035166480994790472, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06961805886886052, 0.025233134646751365, 0.06903749483907706, 0.05645912279153509, 0.023355064750135157, 0.007827625196492938, 0.11200956379572746, 0.06318894312464596, 0.07997994142271458, 0.006665368751889056, 0.01157989821538663, 0.0017879740169762792, 0.00037159721867408013, 0.014947521855188661, 0.00412625368969477, 9.999999999998899e-05, 0.017349969084643257, 0.0288434555395799, 0.11476562071290586, 0.09215900389490728, 0.1390202896632774, 0.10268411211077477, 0.15948143646883395, 0.05918458680430527, 0.1635227025727929, 0.1255441073180733, 0.08405591483482644, 0.4897452909625738, 0.468474821918648, 0.4482336644336633, 0.46810298655440497, 0.4340659450409212, 0.46357283616222056, 0.4808855253363665, 0.4599415934511112, 0.4624649242993303, 0.09612734276923707, 0.09116039412042976, 0.04977867560294946, 0.1898093805089569, 0.10496876212120221, 0.06321529017138294, 0.07345975748157285, 0.07668599384362873, 0.10252236141264515, 0.24700017564221022, 0.2446872303976746, 0.22846517531484667, 0.31439445608657246, 0.2839388691347797, 0.1889649936153983, 0.25740041441158334, 0.18576644935792974, 0.21280984219620136, 0.21531507504464076, 0.20831586277199543, 0.15805015565264835, 0.2224181463999947, 0.22630207944566505, 0.24714886348589782, 0.3333252362352441, 0.344323674464301, 0.3200394607320015, 0.18958770263436542, 0.2653879417765064, 0.2140139407956907, 0.22514312964500183, 0.19190956803712, 0.21345436527623785, 0.18053751764889692, 0.27381120341821585, 0.24499272608489986, 0.2655839730192584, 0.2551418397180554, 0.20957167420847034, 0.19588568342895574, 0.17548267970119247, 0.23386637959141454, 0.20526428858870627, 0.2081861724669316, 0.20663037237230641, 0.21114615850956675, 0.20210698859591936, 0.1992334651046238, 0.19377810514516836, 0.1824560207628787, 0.21544272153051447, 0.19972876917705684, 0.18556784259466508, 0.17953088823492835, 0.11672352782602902, 0.12712245852129767, 0.15365179749505953, 0.7952637986062888, 0.7358143023317176, 0.7555169639492753, 0.15403889412227878, 0.16968212653933712, 0.15023210862774394, 0.14938982545497348, 0.5345065084217684, 0.3925973379115292, 0.501162113080057, 0.21411065416242636, 0.2127683016083336, 0.105237221246827, 0.5403138581297193, 0.36233078815169917, 0.18154529264887365, 0.19034695359780784, 0.18705007118961925, 0.18731944499283237, 0.18862450994714908, 0.181368886160578, 0.17684088976439394, 0.18598429030599295, 0.18143220521539383, 0.10188353392374716, 0.07538361466450083, 0.07502758819782429, 0.08189984021125563, 0.07672220611827174, 0.07808450200416772, 0.1002375240971789, 0.09321245465027461, 0.07584274895336707]}, "mutation_prompt": null}
{"id": "902d536e-fc0c-4b48-868e-c70bf9910fc3", "solution": "import numpy as np\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        if np.random.rand() > 0.5:\n            crossover_point = np.random.randint(1, self.dim-1)\n            child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        else:\n            alpha = np.random.rand(self.dim)\n            child = alpha * parent1 + (1 - alpha) * parent2\n        return child\n    \n    def _mutate(self, individual, generation):\n        adaptive_mutation_rate = self.mutation_rate * (1 - generation / self.budget)\n        for i in range(self.dim):\n            if np.random.rand() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n        generation = 0\n\n        while self.evaluations < self.budget:\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1, generation)\n                child2 = self._mutate(child2, generation)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n            generation += 1\n        \n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "An enhanced hybrid genetic algorithm utilizing adaptive mutation rates and elite replacement for faster convergence.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ba0ad45e-79a5-497a-a152-a00347f6aeec", "metadata": {"aucs": [0.5188767331596345, 0.5064088709886925, 0.529496447239648, 0.5144420539623902, 0.5370488447429549, 0.5112964000634398, 0.5443189240093997, 0.5151759905658304, 0.5295974625296624, 0.11628763434397549, 0.073237962137081, 0.1171960218681154, 0.1328054441372537, 0.06734962385719301, 0.18702089088395346, 0.11794777197766848, 0.16142451141806613, 0.09479736946696471, 0.13340173656759524, 0.11187463710972767, 0.13141237757711532, 0.13803893579674764, 0.14700684185232926, 0.23298106805301155, 0.15599881259017334, 0.13753294373569147, 0.14748159785705617, 0.10876875324652024, 0.1199588748125876, 0.11442623443949529, 0.1376682920812753, 0.10753935447249918, 0.11529412838556907, 0.14411587550759053, 0.12631171847284206, 0.09899476319301614, 0.8657788659263602, 0.8708037771669245, 0.8456890545782719, 0.852582574405035, 0.8831960734694649, 0.8854751829924894, 0.8679232429229845, 0.9140837729660892, 0.9015444725811272, 0.3568268521148178, 0.34169183216634236, 0.3275012350470019, 0.3020994963658874, 0.3330206291499205, 0.3610407508786032, 0.33862374062362166, 0.3033525987268578, 0.29969884168468375, 0.1565724305817624, 0.24612530080806716, 0.1426010858307345, 0.2145150807661389, 0.26942187158728426, 0.35259656298456443, 0.15752276978004842, 0.23846888290241963, 0.1995849784012269, 0.17774147063968737, 0.1654716515977942, 0.17840744983435375, 0.15724909282867372, 0.20144777914869705, 0.17030827069467014, 0.16330246182093688, 0.24655007798684248, 0.3514770322958348, 0.14225247094640325, 0.13435904494185447, 0.17037749954018255, 0.16814900747676498, 0.2131401520323899, 0.15134788406363442, 0.14338955739022818, 0.29561775046554084, 0.15586750501445734, 9.999999999998899e-05, 9.999999999998899e-05, 0.0035166480994790472, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06961805886886052, 0.025233134646751365, 0.06903749483907706, 0.05645912279153509, 0.023355064750135157, 0.007827625196492938, 0.11200956379572746, 0.06318894312464596, 0.07997994142271458, 0.006665368751889056, 0.01157989821538663, 0.0017879740169762792, 0.00037159721867408013, 0.014947521855188661, 0.00412625368969477, 9.999999999998899e-05, 0.017349969084643257, 0.0288434555395799, 0.11476562071290586, 0.09215900389490728, 0.1390202896632774, 0.10268411211077477, 0.15948143646883395, 0.05918458680430527, 0.1635227025727929, 0.1255441073180733, 0.08405591483482644, 0.4897452909625738, 0.468474821918648, 0.4482336644336633, 0.46810298655440497, 0.4340659450409212, 0.46357283616222056, 0.4808855253363665, 0.4599415934511112, 0.4624649242993303, 0.09612734276923707, 0.09116039412042976, 0.04977867560294946, 0.1898093805089569, 0.10496876212120221, 0.06321529017138294, 0.07345975748157285, 0.07668599384362873, 0.10252236141264515, 0.24700017564221022, 0.2446872303976746, 0.22846517531484667, 0.31439445608657246, 0.2839388691347797, 0.1889649936153983, 0.25740041441158334, 0.18576644935792974, 0.21280984219620136, 0.21531507504464076, 0.20831586277199543, 0.15805015565264835, 0.2224181463999947, 0.22630207944566505, 0.24714886348589782, 0.3333252362352441, 0.344323674464301, 0.3200394607320015, 0.18958770263436542, 0.2653879417765064, 0.2140139407956907, 0.22514312964500183, 0.19190956803712, 0.21345436527623785, 0.18053751764889692, 0.27381120341821585, 0.24499272608489986, 0.2655839730192584, 0.2551418397180554, 0.20957167420847034, 0.19588568342895574, 0.17548267970119247, 0.23386637959141454, 0.20526428858870627, 0.2081861724669316, 0.20663037237230641, 0.21114615850956675, 0.20210698859591936, 0.1992334651046238, 0.19377810514516836, 0.1824560207628787, 0.21544272153051447, 0.19972876917705684, 0.18556784259466508, 0.17953088823492835, 0.11672352782602902, 0.12712245852129767, 0.15365179749505953, 0.7952637986062888, 0.7358143023317176, 0.7555169639492753, 0.15403889412227878, 0.16968212653933712, 0.15023210862774394, 0.14938982545497348, 0.5345065084217684, 0.3925973379115292, 0.501162113080057, 0.21411065416242636, 0.2127683016083336, 0.105237221246827, 0.5403138581297193, 0.36233078815169917, 0.18154529264887365, 0.19034695359780784, 0.18705007118961925, 0.18731944499283237, 0.18862450994714908, 0.181368886160578, 0.17684088976439394, 0.18598429030599295, 0.18143220521539383, 0.10188353392374716, 0.07538361466450083, 0.07502758819782429, 0.08189984021125563, 0.07672220611827174, 0.07808450200416772, 0.1002375240971789, 0.09321245465027461, 0.07584274895336707]}, "mutation_prompt": null}
{"id": "33f40f1b-e543-4ae7-bf48-398a2144609d", "solution": "import numpy as np\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        if np.random.rand() > 0.5:\n            crossover_point = np.random.randint(1, self.dim-1)\n            child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        else:\n            alpha = np.random.rand(self.dim)\n            child = alpha * parent1 + (1 - alpha) * parent2\n        return child\n    \n    def _mutate(self, individual, generation):\n        adaptive_mutation_rate = self.mutation_rate * (1 - generation / self.budget)\n        for i in range(self.dim):\n            if np.random.rand() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n        generation = 0\n\n        while self.evaluations < self.budget:\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1, generation)\n                child2 = self._mutate(child2, generation)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n            generation += 1\n        \n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "An enhanced hybrid genetic algorithm utilizing adaptive mutation rates and elite replacement for faster convergence.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ba0ad45e-79a5-497a-a152-a00347f6aeec", "metadata": {"aucs": [0.5188767331596345, 0.5064088709886925, 0.529496447239648, 0.5144420539623902, 0.5370488447429549, 0.5112964000634398, 0.5443189240093997, 0.5151759905658304, 0.5295974625296624, 0.11628763434397549, 0.073237962137081, 0.1171960218681154, 0.1328054441372537, 0.06734962385719301, 0.18702089088395346, 0.11794777197766848, 0.16142451141806613, 0.09479736946696471, 0.13340173656759524, 0.11187463710972767, 0.13141237757711532, 0.13803893579674764, 0.14700684185232926, 0.23298106805301155, 0.15599881259017334, 0.13753294373569147, 0.14748159785705617, 0.10876875324652024, 0.1199588748125876, 0.11442623443949529, 0.1376682920812753, 0.10753935447249918, 0.11529412838556907, 0.14411587550759053, 0.12631171847284206, 0.09899476319301614, 0.8657788659263602, 0.8708037771669245, 0.8456890545782719, 0.852582574405035, 0.8831960734694649, 0.8854751829924894, 0.8679232429229845, 0.9140837729660892, 0.9015444725811272, 0.3568268521148178, 0.34169183216634236, 0.3275012350470019, 0.3020994963658874, 0.3330206291499205, 0.3610407508786032, 0.33862374062362166, 0.3033525987268578, 0.29969884168468375, 0.1565724305817624, 0.24612530080806716, 0.1426010858307345, 0.2145150807661389, 0.26942187158728426, 0.35259656298456443, 0.15752276978004842, 0.23846888290241963, 0.1995849784012269, 0.17774147063968737, 0.1654716515977942, 0.17840744983435375, 0.15724909282867372, 0.20144777914869705, 0.17030827069467014, 0.16330246182093688, 0.24655007798684248, 0.3514770322958348, 0.14225247094640325, 0.13435904494185447, 0.17037749954018255, 0.16814900747676498, 0.2131401520323899, 0.15134788406363442, 0.14338955739022818, 0.29561775046554084, 0.15586750501445734, 9.999999999998899e-05, 9.999999999998899e-05, 0.0035166480994790472, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06961805886886052, 0.025233134646751365, 0.06903749483907706, 0.05645912279153509, 0.023355064750135157, 0.007827625196492938, 0.11200956379572746, 0.06318894312464596, 0.07997994142271458, 0.006665368751889056, 0.01157989821538663, 0.0017879740169762792, 0.00037159721867408013, 0.014947521855188661, 0.00412625368969477, 9.999999999998899e-05, 0.017349969084643257, 0.0288434555395799, 0.11476562071290586, 0.09215900389490728, 0.1390202896632774, 0.10268411211077477, 0.15948143646883395, 0.05918458680430527, 0.1635227025727929, 0.1255441073180733, 0.08405591483482644, 0.4897452909625738, 0.468474821918648, 0.4482336644336633, 0.46810298655440497, 0.4340659450409212, 0.46357283616222056, 0.4808855253363665, 0.4599415934511112, 0.4624649242993303, 0.09612734276923707, 0.09116039412042976, 0.04977867560294946, 0.1898093805089569, 0.10496876212120221, 0.06321529017138294, 0.07345975748157285, 0.07668599384362873, 0.10252236141264515, 0.24700017564221022, 0.2446872303976746, 0.22846517531484667, 0.31439445608657246, 0.2839388691347797, 0.1889649936153983, 0.25740041441158334, 0.18576644935792974, 0.21280984219620136, 0.21531507504464076, 0.20831586277199543, 0.15805015565264835, 0.2224181463999947, 0.22630207944566505, 0.24714886348589782, 0.3333252362352441, 0.344323674464301, 0.3200394607320015, 0.18958770263436542, 0.2653879417765064, 0.2140139407956907, 0.22514312964500183, 0.19190956803712, 0.21345436527623785, 0.18053751764889692, 0.27381120341821585, 0.24499272608489986, 0.2655839730192584, 0.2551418397180554, 0.20957167420847034, 0.19588568342895574, 0.17548267970119247, 0.23386637959141454, 0.20526428858870627, 0.2081861724669316, 0.20663037237230641, 0.21114615850956675, 0.20210698859591936, 0.1992334651046238, 0.19377810514516836, 0.1824560207628787, 0.21544272153051447, 0.19972876917705684, 0.18556784259466508, 0.17953088823492835, 0.11672352782602902, 0.12712245852129767, 0.15365179749505953, 0.7952637986062888, 0.7358143023317176, 0.7555169639492753, 0.15403889412227878, 0.16968212653933712, 0.15023210862774394, 0.14938982545497348, 0.5345065084217684, 0.3925973379115292, 0.501162113080057, 0.21411065416242636, 0.2127683016083336, 0.105237221246827, 0.5403138581297193, 0.36233078815169917, 0.18154529264887365, 0.19034695359780784, 0.18705007118961925, 0.18731944499283237, 0.18862450994714908, 0.181368886160578, 0.17684088976439394, 0.18598429030599295, 0.18143220521539383, 0.10188353392374716, 0.07538361466450083, 0.07502758819782429, 0.08189984021125563, 0.07672220611827174, 0.07808450200416772, 0.1002375240971789, 0.09321245465027461, 0.07584274895336707]}, "mutation_prompt": null}
{"id": "61ad9429-510e-48e4-b3ca-95b46431312b", "solution": "import numpy as np\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        if np.random.rand() > 0.5:\n            crossover_point = np.random.randint(1, self.dim-1)\n            child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        else:\n            alpha = np.random.rand(self.dim)\n            child = alpha * parent1 + (1 - alpha) * parent2\n        return child\n    \n    def _mutate(self, individual, generation):\n        adaptive_mutation_rate = self.mutation_rate * (1 - generation / self.budget)\n        for i in range(self.dim):\n            if np.random.rand() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n        generation = 0\n\n        while self.evaluations < self.budget:\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1, generation)\n                child2 = self._mutate(child2, generation)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n            generation += 1\n        \n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "An enhanced hybrid genetic algorithm utilizing adaptive mutation rates and elite replacement for faster convergence.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ba0ad45e-79a5-497a-a152-a00347f6aeec", "metadata": {"aucs": [0.5188767331596345, 0.5064088709886925, 0.529496447239648, 0.5144420539623902, 0.5370488447429549, 0.5112964000634398, 0.5443189240093997, 0.5151759905658304, 0.5295974625296624, 0.11628763434397549, 0.073237962137081, 0.1171960218681154, 0.1328054441372537, 0.06734962385719301, 0.18702089088395346, 0.11794777197766848, 0.16142451141806613, 0.09479736946696471, 0.13340173656759524, 0.11187463710972767, 0.13141237757711532, 0.13803893579674764, 0.14700684185232926, 0.23298106805301155, 0.15599881259017334, 0.13753294373569147, 0.14748159785705617, 0.10876875324652024, 0.1199588748125876, 0.11442623443949529, 0.1376682920812753, 0.10753935447249918, 0.11529412838556907, 0.14411587550759053, 0.12631171847284206, 0.09899476319301614, 0.8657788659263602, 0.8708037771669245, 0.8456890545782719, 0.852582574405035, 0.8831960734694649, 0.8854751829924894, 0.8679232429229845, 0.9140837729660892, 0.9015444725811272, 0.3568268521148178, 0.34169183216634236, 0.3275012350470019, 0.3020994963658874, 0.3330206291499205, 0.3610407508786032, 0.33862374062362166, 0.3033525987268578, 0.29969884168468375, 0.1565724305817624, 0.24612530080806716, 0.1426010858307345, 0.2145150807661389, 0.26942187158728426, 0.35259656298456443, 0.15752276978004842, 0.23846888290241963, 0.1995849784012269, 0.17774147063968737, 0.1654716515977942, 0.17840744983435375, 0.15724909282867372, 0.20144777914869705, 0.17030827069467014, 0.16330246182093688, 0.24655007798684248, 0.3514770322958348, 0.14225247094640325, 0.13435904494185447, 0.17037749954018255, 0.16814900747676498, 0.2131401520323899, 0.15134788406363442, 0.14338955739022818, 0.29561775046554084, 0.15586750501445734, 9.999999999998899e-05, 9.999999999998899e-05, 0.0035166480994790472, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06961805886886052, 0.025233134646751365, 0.06903749483907706, 0.05645912279153509, 0.023355064750135157, 0.007827625196492938, 0.11200956379572746, 0.06318894312464596, 0.07997994142271458, 0.006665368751889056, 0.01157989821538663, 0.0017879740169762792, 0.00037159721867408013, 0.014947521855188661, 0.00412625368969477, 9.999999999998899e-05, 0.017349969084643257, 0.0288434555395799, 0.11476562071290586, 0.09215900389490728, 0.1390202896632774, 0.10268411211077477, 0.15948143646883395, 0.05918458680430527, 0.1635227025727929, 0.1255441073180733, 0.08405591483482644, 0.4897452909625738, 0.468474821918648, 0.4482336644336633, 0.46810298655440497, 0.4340659450409212, 0.46357283616222056, 0.4808855253363665, 0.4599415934511112, 0.4624649242993303, 0.09612734276923707, 0.09116039412042976, 0.04977867560294946, 0.1898093805089569, 0.10496876212120221, 0.06321529017138294, 0.07345975748157285, 0.07668599384362873, 0.10252236141264515, 0.24700017564221022, 0.2446872303976746, 0.22846517531484667, 0.31439445608657246, 0.2839388691347797, 0.1889649936153983, 0.25740041441158334, 0.18576644935792974, 0.21280984219620136, 0.21531507504464076, 0.20831586277199543, 0.15805015565264835, 0.2224181463999947, 0.22630207944566505, 0.24714886348589782, 0.3333252362352441, 0.344323674464301, 0.3200394607320015, 0.18958770263436542, 0.2653879417765064, 0.2140139407956907, 0.22514312964500183, 0.19190956803712, 0.21345436527623785, 0.18053751764889692, 0.27381120341821585, 0.24499272608489986, 0.2655839730192584, 0.2551418397180554, 0.20957167420847034, 0.19588568342895574, 0.17548267970119247, 0.23386637959141454, 0.20526428858870627, 0.2081861724669316, 0.20663037237230641, 0.21114615850956675, 0.20210698859591936, 0.1992334651046238, 0.19377810514516836, 0.1824560207628787, 0.21544272153051447, 0.19972876917705684, 0.18556784259466508, 0.17953088823492835, 0.11672352782602902, 0.12712245852129767, 0.15365179749505953, 0.7952637986062888, 0.7358143023317176, 0.7555169639492753, 0.15403889412227878, 0.16968212653933712, 0.15023210862774394, 0.14938982545497348, 0.5345065084217684, 0.3925973379115292, 0.501162113080057, 0.21411065416242636, 0.2127683016083336, 0.105237221246827, 0.5403138581297193, 0.36233078815169917, 0.18154529264887365, 0.19034695359780784, 0.18705007118961925, 0.18731944499283237, 0.18862450994714908, 0.181368886160578, 0.17684088976439394, 0.18598429030599295, 0.18143220521539383, 0.10188353392374716, 0.07538361466450083, 0.07502758819782429, 0.08189984021125563, 0.07672220611827174, 0.07808450200416772, 0.1002375240971789, 0.09321245465027461, 0.07584274895336707]}, "mutation_prompt": null}
{"id": "271c8728-c665-422e-ba8b-293f91ecf2c9", "solution": "import numpy as np\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        if np.random.rand() > 0.5:\n            crossover_point = np.random.randint(1, self.dim-1)\n            child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        else:\n            alpha = np.random.rand(self.dim)\n            child = alpha * parent1 + (1 - alpha) * parent2\n        return child\n    \n    def _mutate(self, individual, generation):\n        adaptive_mutation_rate = self.mutation_rate * (1 - generation / self.budget)\n        for i in range(self.dim):\n            if np.random.rand() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n        generation = 0\n\n        while self.evaluations < self.budget:\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1, generation)\n                child2 = self._mutate(child2, generation)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n            generation += 1\n        \n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "An enhanced hybrid genetic algorithm utilizing adaptive mutation rates and elite replacement for faster convergence.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ba0ad45e-79a5-497a-a152-a00347f6aeec", "metadata": {"aucs": [0.5188767331596345, 0.5064088709886925, 0.529496447239648, 0.5144420539623902, 0.5370488447429549, 0.5112964000634398, 0.5443189240093997, 0.5151759905658304, 0.5295974625296624, 0.11628763434397549, 0.073237962137081, 0.1171960218681154, 0.1328054441372537, 0.06734962385719301, 0.18702089088395346, 0.11794777197766848, 0.16142451141806613, 0.09479736946696471, 0.13340173656759524, 0.11187463710972767, 0.13141237757711532, 0.13803893579674764, 0.14700684185232926, 0.23298106805301155, 0.15599881259017334, 0.13753294373569147, 0.14748159785705617, 0.10876875324652024, 0.1199588748125876, 0.11442623443949529, 0.1376682920812753, 0.10753935447249918, 0.11529412838556907, 0.14411587550759053, 0.12631171847284206, 0.09899476319301614, 0.8657788659263602, 0.8708037771669245, 0.8456890545782719, 0.852582574405035, 0.8831960734694649, 0.8854751829924894, 0.8679232429229845, 0.9140837729660892, 0.9015444725811272, 0.3568268521148178, 0.34169183216634236, 0.3275012350470019, 0.3020994963658874, 0.3330206291499205, 0.3610407508786032, 0.33862374062362166, 0.3033525987268578, 0.29969884168468375, 0.1565724305817624, 0.24612530080806716, 0.1426010858307345, 0.2145150807661389, 0.26942187158728426, 0.35259656298456443, 0.15752276978004842, 0.23846888290241963, 0.1995849784012269, 0.17774147063968737, 0.1654716515977942, 0.17840744983435375, 0.15724909282867372, 0.20144777914869705, 0.17030827069467014, 0.16330246182093688, 0.24655007798684248, 0.3514770322958348, 0.14225247094640325, 0.13435904494185447, 0.17037749954018255, 0.16814900747676498, 0.2131401520323899, 0.15134788406363442, 0.14338955739022818, 0.29561775046554084, 0.15586750501445734, 9.999999999998899e-05, 9.999999999998899e-05, 0.0035166480994790472, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06961805886886052, 0.025233134646751365, 0.06903749483907706, 0.05645912279153509, 0.023355064750135157, 0.007827625196492938, 0.11200956379572746, 0.06318894312464596, 0.07997994142271458, 0.006665368751889056, 0.01157989821538663, 0.0017879740169762792, 0.00037159721867408013, 0.014947521855188661, 0.00412625368969477, 9.999999999998899e-05, 0.017349969084643257, 0.0288434555395799, 0.11476562071290586, 0.09215900389490728, 0.1390202896632774, 0.10268411211077477, 0.15948143646883395, 0.05918458680430527, 0.1635227025727929, 0.1255441073180733, 0.08405591483482644, 0.4897452909625738, 0.468474821918648, 0.4482336644336633, 0.46810298655440497, 0.4340659450409212, 0.46357283616222056, 0.4808855253363665, 0.4599415934511112, 0.4624649242993303, 0.09612734276923707, 0.09116039412042976, 0.04977867560294946, 0.1898093805089569, 0.10496876212120221, 0.06321529017138294, 0.07345975748157285, 0.07668599384362873, 0.10252236141264515, 0.24700017564221022, 0.2446872303976746, 0.22846517531484667, 0.31439445608657246, 0.2839388691347797, 0.1889649936153983, 0.25740041441158334, 0.18576644935792974, 0.21280984219620136, 0.21531507504464076, 0.20831586277199543, 0.15805015565264835, 0.2224181463999947, 0.22630207944566505, 0.24714886348589782, 0.3333252362352441, 0.344323674464301, 0.3200394607320015, 0.18958770263436542, 0.2653879417765064, 0.2140139407956907, 0.22514312964500183, 0.19190956803712, 0.21345436527623785, 0.18053751764889692, 0.27381120341821585, 0.24499272608489986, 0.2655839730192584, 0.2551418397180554, 0.20957167420847034, 0.19588568342895574, 0.17548267970119247, 0.23386637959141454, 0.20526428858870627, 0.2081861724669316, 0.20663037237230641, 0.21114615850956675, 0.20210698859591936, 0.1992334651046238, 0.19377810514516836, 0.1824560207628787, 0.21544272153051447, 0.19972876917705684, 0.18556784259466508, 0.17953088823492835, 0.11672352782602902, 0.12712245852129767, 0.15365179749505953, 0.7952637986062888, 0.7358143023317176, 0.7555169639492753, 0.15403889412227878, 0.16968212653933712, 0.15023210862774394, 0.14938982545497348, 0.5345065084217684, 0.3925973379115292, 0.501162113080057, 0.21411065416242636, 0.2127683016083336, 0.105237221246827, 0.5403138581297193, 0.36233078815169917, 0.18154529264887365, 0.19034695359780784, 0.18705007118961925, 0.18731944499283237, 0.18862450994714908, 0.181368886160578, 0.17684088976439394, 0.18598429030599295, 0.18143220521539383, 0.10188353392374716, 0.07538361466450083, 0.07502758819782429, 0.08189984021125563, 0.07672220611827174, 0.07808450200416772, 0.1002375240971789, 0.09321245465027461, 0.07584274895336707]}, "mutation_prompt": null}
{"id": "1a3d29ca-068b-4ec4-9c7a-91b816a1c8bc", "solution": "import numpy as np\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        if np.random.rand() > 0.5:\n            crossover_point = np.random.randint(1, self.dim-1)\n            child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        else:\n            alpha = np.random.rand(self.dim)\n            child = alpha * parent1 + (1 - alpha) * parent2\n        return child\n    \n    def _mutate(self, individual, generation):\n        adaptive_mutation_rate = self.mutation_rate * (1 - generation / self.budget)\n        for i in range(self.dim):\n            if np.random.rand() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n        generation = 0\n\n        while self.evaluations < self.budget:\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1, generation)\n                child2 = self._mutate(child2, generation)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n            generation += 1\n        \n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "An enhanced hybrid genetic algorithm utilizing adaptive mutation rates and elite replacement for faster convergence.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ba0ad45e-79a5-497a-a152-a00347f6aeec", "metadata": {"aucs": [0.5188767331596345, 0.5064088709886925, 0.529496447239648, 0.5144420539623902, 0.5370488447429549, 0.5112964000634398, 0.5443189240093997, 0.5151759905658304, 0.5295974625296624, 0.11628763434397549, 0.073237962137081, 0.1171960218681154, 0.1328054441372537, 0.06734962385719301, 0.18702089088395346, 0.11794777197766848, 0.16142451141806613, 0.09479736946696471, 0.13340173656759524, 0.11187463710972767, 0.13141237757711532, 0.13803893579674764, 0.14700684185232926, 0.23298106805301155, 0.15599881259017334, 0.13753294373569147, 0.14748159785705617, 0.10876875324652024, 0.1199588748125876, 0.11442623443949529, 0.1376682920812753, 0.10753935447249918, 0.11529412838556907, 0.14411587550759053, 0.12631171847284206, 0.09899476319301614, 0.8657788659263602, 0.8708037771669245, 0.8456890545782719, 0.852582574405035, 0.8831960734694649, 0.8854751829924894, 0.8679232429229845, 0.9140837729660892, 0.9015444725811272, 0.3568268521148178, 0.34169183216634236, 0.3275012350470019, 0.3020994963658874, 0.3330206291499205, 0.3610407508786032, 0.33862374062362166, 0.3033525987268578, 0.29969884168468375, 0.1565724305817624, 0.24612530080806716, 0.1426010858307345, 0.2145150807661389, 0.26942187158728426, 0.35259656298456443, 0.15752276978004842, 0.23846888290241963, 0.1995849784012269, 0.17774147063968737, 0.1654716515977942, 0.17840744983435375, 0.15724909282867372, 0.20144777914869705, 0.17030827069467014, 0.16330246182093688, 0.24655007798684248, 0.3514770322958348, 0.14225247094640325, 0.13435904494185447, 0.17037749954018255, 0.16814900747676498, 0.2131401520323899, 0.15134788406363442, 0.14338955739022818, 0.29561775046554084, 0.15586750501445734, 9.999999999998899e-05, 9.999999999998899e-05, 0.0035166480994790472, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06961805886886052, 0.025233134646751365, 0.06903749483907706, 0.05645912279153509, 0.023355064750135157, 0.007827625196492938, 0.11200956379572746, 0.06318894312464596, 0.07997994142271458, 0.006665368751889056, 0.01157989821538663, 0.0017879740169762792, 0.00037159721867408013, 0.014947521855188661, 0.00412625368969477, 9.999999999998899e-05, 0.017349969084643257, 0.0288434555395799, 0.11476562071290586, 0.09215900389490728, 0.1390202896632774, 0.10268411211077477, 0.15948143646883395, 0.05918458680430527, 0.1635227025727929, 0.1255441073180733, 0.08405591483482644, 0.4897452909625738, 0.468474821918648, 0.4482336644336633, 0.46810298655440497, 0.4340659450409212, 0.46357283616222056, 0.4808855253363665, 0.4599415934511112, 0.4624649242993303, 0.09612734276923707, 0.09116039412042976, 0.04977867560294946, 0.1898093805089569, 0.10496876212120221, 0.06321529017138294, 0.07345975748157285, 0.07668599384362873, 0.10252236141264515, 0.24700017564221022, 0.2446872303976746, 0.22846517531484667, 0.31439445608657246, 0.2839388691347797, 0.1889649936153983, 0.25740041441158334, 0.18576644935792974, 0.21280984219620136, 0.21531507504464076, 0.20831586277199543, 0.15805015565264835, 0.2224181463999947, 0.22630207944566505, 0.24714886348589782, 0.3333252362352441, 0.344323674464301, 0.3200394607320015, 0.18958770263436542, 0.2653879417765064, 0.2140139407956907, 0.22514312964500183, 0.19190956803712, 0.21345436527623785, 0.18053751764889692, 0.27381120341821585, 0.24499272608489986, 0.2655839730192584, 0.2551418397180554, 0.20957167420847034, 0.19588568342895574, 0.17548267970119247, 0.23386637959141454, 0.20526428858870627, 0.2081861724669316, 0.20663037237230641, 0.21114615850956675, 0.20210698859591936, 0.1992334651046238, 0.19377810514516836, 0.1824560207628787, 0.21544272153051447, 0.19972876917705684, 0.18556784259466508, 0.17953088823492835, 0.11672352782602902, 0.12712245852129767, 0.15365179749505953, 0.7952637986062888, 0.7358143023317176, 0.7555169639492753, 0.15403889412227878, 0.16968212653933712, 0.15023210862774394, 0.14938982545497348, 0.5345065084217684, 0.3925973379115292, 0.501162113080057, 0.21411065416242636, 0.2127683016083336, 0.105237221246827, 0.5403138581297193, 0.36233078815169917, 0.18154529264887365, 0.19034695359780784, 0.18705007118961925, 0.18731944499283237, 0.18862450994714908, 0.181368886160578, 0.17684088976439394, 0.18598429030599295, 0.18143220521539383, 0.10188353392374716, 0.07538361466450083, 0.07502758819782429, 0.08189984021125563, 0.07672220611827174, 0.07808450200416772, 0.1002375240971789, 0.09321245465027461, 0.07584274895336707]}, "mutation_prompt": null}
{"id": "5b49141d-6a17-4de3-9808-be195fe9ba0e", "solution": "import numpy as np\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        if np.random.rand() > 0.5:\n            crossover_point = np.random.randint(1, self.dim-1)\n            child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        else:\n            alpha = np.random.rand(self.dim)\n            child = alpha * parent1 + (1 - alpha) * parent2\n        return child\n    \n    def _mutate(self, individual, generation):\n        adaptive_mutation_rate = self.mutation_rate * (1 - generation / self.budget)\n        for i in range(self.dim):\n            if np.random.rand() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n        generation = 0\n\n        while self.evaluations < self.budget:\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1, generation)\n                child2 = self._mutate(child2, generation)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n            generation += 1\n        \n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "An enhanced hybrid genetic algorithm utilizing adaptive mutation rates and elite replacement for faster convergence.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ba0ad45e-79a5-497a-a152-a00347f6aeec", "metadata": {"aucs": [0.5188767331596345, 0.5064088709886925, 0.529496447239648, 0.5144420539623902, 0.5370488447429549, 0.5112964000634398, 0.5443189240093997, 0.5151759905658304, 0.5295974625296624, 0.11628763434397549, 0.073237962137081, 0.1171960218681154, 0.1328054441372537, 0.06734962385719301, 0.18702089088395346, 0.11794777197766848, 0.16142451141806613, 0.09479736946696471, 0.13340173656759524, 0.11187463710972767, 0.13141237757711532, 0.13803893579674764, 0.14700684185232926, 0.23298106805301155, 0.15599881259017334, 0.13753294373569147, 0.14748159785705617, 0.10876875324652024, 0.1199588748125876, 0.11442623443949529, 0.1376682920812753, 0.10753935447249918, 0.11529412838556907, 0.14411587550759053, 0.12631171847284206, 0.09899476319301614, 0.8657788659263602, 0.8708037771669245, 0.8456890545782719, 0.852582574405035, 0.8831960734694649, 0.8854751829924894, 0.8679232429229845, 0.9140837729660892, 0.9015444725811272, 0.3568268521148178, 0.34169183216634236, 0.3275012350470019, 0.3020994963658874, 0.3330206291499205, 0.3610407508786032, 0.33862374062362166, 0.3033525987268578, 0.29969884168468375, 0.1565724305817624, 0.24612530080806716, 0.1426010858307345, 0.2145150807661389, 0.26942187158728426, 0.35259656298456443, 0.15752276978004842, 0.23846888290241963, 0.1995849784012269, 0.17774147063968737, 0.1654716515977942, 0.17840744983435375, 0.15724909282867372, 0.20144777914869705, 0.17030827069467014, 0.16330246182093688, 0.24655007798684248, 0.3514770322958348, 0.14225247094640325, 0.13435904494185447, 0.17037749954018255, 0.16814900747676498, 0.2131401520323899, 0.15134788406363442, 0.14338955739022818, 0.29561775046554084, 0.15586750501445734, 9.999999999998899e-05, 9.999999999998899e-05, 0.0035166480994790472, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06961805886886052, 0.025233134646751365, 0.06903749483907706, 0.05645912279153509, 0.023355064750135157, 0.007827625196492938, 0.11200956379572746, 0.06318894312464596, 0.07997994142271458, 0.006665368751889056, 0.01157989821538663, 0.0017879740169762792, 0.00037159721867408013, 0.014947521855188661, 0.00412625368969477, 9.999999999998899e-05, 0.017349969084643257, 0.0288434555395799, 0.11476562071290586, 0.09215900389490728, 0.1390202896632774, 0.10268411211077477, 0.15948143646883395, 0.05918458680430527, 0.1635227025727929, 0.1255441073180733, 0.08405591483482644, 0.4897452909625738, 0.468474821918648, 0.4482336644336633, 0.46810298655440497, 0.4340659450409212, 0.46357283616222056, 0.4808855253363665, 0.4599415934511112, 0.4624649242993303, 0.09612734276923707, 0.09116039412042976, 0.04977867560294946, 0.1898093805089569, 0.10496876212120221, 0.06321529017138294, 0.07345975748157285, 0.07668599384362873, 0.10252236141264515, 0.24700017564221022, 0.2446872303976746, 0.22846517531484667, 0.31439445608657246, 0.2839388691347797, 0.1889649936153983, 0.25740041441158334, 0.18576644935792974, 0.21280984219620136, 0.21531507504464076, 0.20831586277199543, 0.15805015565264835, 0.2224181463999947, 0.22630207944566505, 0.24714886348589782, 0.3333252362352441, 0.344323674464301, 0.3200394607320015, 0.18958770263436542, 0.2653879417765064, 0.2140139407956907, 0.22514312964500183, 0.19190956803712, 0.21345436527623785, 0.18053751764889692, 0.27381120341821585, 0.24499272608489986, 0.2655839730192584, 0.2551418397180554, 0.20957167420847034, 0.19588568342895574, 0.17548267970119247, 0.23386637959141454, 0.20526428858870627, 0.2081861724669316, 0.20663037237230641, 0.21114615850956675, 0.20210698859591936, 0.1992334651046238, 0.19377810514516836, 0.1824560207628787, 0.21544272153051447, 0.19972876917705684, 0.18556784259466508, 0.17953088823492835, 0.11672352782602902, 0.12712245852129767, 0.15365179749505953, 0.7952637986062888, 0.7358143023317176, 0.7555169639492753, 0.15403889412227878, 0.16968212653933712, 0.15023210862774394, 0.14938982545497348, 0.5345065084217684, 0.3925973379115292, 0.501162113080057, 0.21411065416242636, 0.2127683016083336, 0.105237221246827, 0.5403138581297193, 0.36233078815169917, 0.18154529264887365, 0.19034695359780784, 0.18705007118961925, 0.18731944499283237, 0.18862450994714908, 0.181368886160578, 0.17684088976439394, 0.18598429030599295, 0.18143220521539383, 0.10188353392374716, 0.07538361466450083, 0.07502758819782429, 0.08189984021125563, 0.07672220611827174, 0.07808450200416772, 0.1002375240971789, 0.09321245465027461, 0.07584274895336707]}, "mutation_prompt": null}
{"id": "da461cf1-9ef9-4a08-8e08-b41dd439cdc9", "solution": "import numpy as np\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Increased for better diversity\n        self.mutation_rate = 0.08  # Slightly reduced for stability\n        self.elite_fraction = 0.25  # Increased for better retention of good solutions\n        self.tournament_size = 3  # Reduced for faster selection\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        if np.random.rand() > 0.5:\n            crossover_point = np.random.randint(1, self.dim-1)\n            child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        else:\n            alpha = np.random.rand(self.dim)\n            child = alpha * parent1 + (1 - alpha) * parent2\n        return child\n    \n    def _mutate(self, individual, generation):\n        adaptive_mutation_rate = self.mutation_rate * (1 - generation / self.budget)\n        for i in range(self.dim):\n            if np.random.rand() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        step_size = 0.05  # Reduced step size for more precision\n        neighbors = [individual + np.random.uniform(-step_size, step_size, self.dim) for _ in range(8)]  # Increased number of neighbors\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n        generation = 0\n\n        while self.evaluations < self.budget:\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1 % self.population_size]]  # Ensures valid index\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1, generation)\n                child2 = self._mutate(child2, generation)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n            generation += 1\n        \n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "An enhanced hybrid genetic algorithm with dynamic population adjustments and improved local search for faster convergence.", "configspace": "", "generation": 96, "fitness": 0.22753366557281465, "feedback": "The algorithm HybridGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.17.", "error": "", "parent_id": "ba0ad45e-79a5-497a-a152-a00347f6aeec", "metadata": {"aucs": [0.5618821543769654, 0.5910853938841689, 0.5648494951032383, 0.5207374604572936, 0.5933759998579848, 0.5538217256509101, 0.6091410808429571, 0.5380866601457452, 0.5494048233689097, 0.15105754272361338, 0.14376203877567606, 0.1825135993516589, 0.2201872474035581, 0.14431200262487232, 0.1395605841685328, 0.14457714180137993, 0.07883754465465276, 0.13519888786166234, 0.17476930326032558, 0.29785440297024557, 0.29006344946816753, 0.13716164624345295, 0.16376498898532865, 0.18574693101584128, 0.28446585026811555, 0.1269294235478623, 0.13813761599869234, 0.14727738783225364, 0.12734326985416156, 0.15667960093669242, 0.13540477062912737, 0.14717064288469228, 0.13716078771560714, 0.13637915309794613, 0.11849516951390471, 0.12289817300753514, 0.7658819929804562, 0.6430958994650813, 0.706968188831127, 0.7521062108653414, 0.7450653663764866, 0.7957582596086996, 0.7706121836103724, 0.7711132293228475, 0.6639811900439869, 0.3076839201726447, 0.31555710468817244, 0.23194223808802228, 0.2727181111703507, 0.3335999364752267, 0.23694859534822577, 0.25505867095149126, 0.21221437902393414, 0.3872305499411869, 0.17439805612167147, 0.137474302999136, 0.15517430928805476, 0.21341908463279857, 0.37736250598989873, 0.2718968366112209, 0.15085035468868901, 0.17717630623981218, 0.2332023850071091, 0.35362732224657867, 0.2292805010701574, 0.15747234045194602, 0.1821092506717229, 0.3007049248050797, 0.22869468256224823, 0.1772657477494205, 0.21272324036660195, 0.1643689946160226, 0.20468593425656167, 0.16222814712868383, 0.15759205553736266, 0.16059539745874862, 0.1759362071722801, 0.19679265978221205, 0.16870727826647458, 0.1707972645364082, 0.1976115773671635, 0.00435115418489096, 0.013250617023264355, 0.01270044216419497, 0.027391792395229486, 9.999999999998899e-05, 9.999999999998899e-05, 0.000856751957895141, 0.024724263331437624, 0.056155415640286255, 0.0678426434777204, 0.0720469475672757, 0.07698952724758124, 0.0950842796393454, 0.02766059386954034, 0.1102355487069091, 0.14166346921475093, 0.06697224173371907, 0.05195964260497454, 0.08359642622073205, 0.05487218865012222, 0.04891699647255121, 0.0401963812794236, 0.0401291479496394, 0.02868373051156692, 0.043378792122855, 0.07573821081317733, 0.04049881743949102, 0.11120637434652292, 0.11501385051536639, 0.09921301321935516, 0.16677435319575873, 0.0853830086883891, 0.12182333871358075, 0.12983768798285322, 0.15846943280235248, 0.10328302234820497, 0.46471501577321994, 0.47567444866794895, 0.47540920187053326, 0.4239052889366306, 0.45937292321362055, 0.4730148731108549, 0.4868886527814884, 0.5035192087718614, 0.4515125327743522, 0.09205798536353338, 0.10460259117904647, 0.15733207606252164, 0.09551069236123089, 0.1149872903229463, 0.1011539686427192, 0.14190179404858738, 0.11616254784620628, 0.09725837172951834, 0.17939960649555997, 0.19012970183538302, 0.1899190636727891, 0.388049919899609, 0.21257366606510109, 0.2054693993844614, 0.26674418817012024, 0.20659971973571778, 0.230836050092739, 0.25686830712127673, 0.19120707864126285, 0.19540659750859624, 0.21633961927551504, 0.21512641344144623, 0.2633045899580725, 0.23709905398035258, 0.2336409609701734, 0.20592057193141555, 0.20754187445532657, 0.21927868259989958, 0.14044781026051512, 0.1780154680635696, 0.31869446790518685, 0.27801354388909605, 0.16774285936748656, 0.1823887026298625, 0.1876520424574244, 0.24132822652119656, 0.20170937298384306, 0.21033436082452384, 0.25020933745339, 0.20164454135602505, 0.26322591120975725, 0.22530455274386096, 0.22617043781977297, 0.23700387101408582, 0.20157768711521362, 0.22501780031626928, 0.19175514148988193, 0.21404948366872312, 0.4105734881269032, 0.20266375222250876, 0.1963928585442749, 0.20693261246039596, 0.18884288990610698, 0.18532279067699942, 0.17901792094768276, 0.16486000742902684, 0.17138337613278132, 0.19946427973491965, 0.6248800530772362, 0.15589126881784965, 0.16360202873715246, 0.170832299403322, 0.494514938448561, 0.20411574044447955, 0.3921981398547061, 0.1828449823659355, 0.20608180529017817, 0.21015428897482769, 0.15924520381205653, 0.4787693567684569, 0.3007766553177965, 0.19062329706678927, 0.21134761780757283, 0.19080053310891698, 0.19893596959246151, 0.20828874726087465, 0.20428373585149795, 0.21646689532415808, 0.20260232283819046, 0.20287610557847569, 0.09412074948577265, 0.10923755200153695, 0.09215828706275986, 0.08085469377677801, 0.0843670343470343, 0.114172500951785, 0.11357014231614104, 0.10437508456598066, 0.08323186061335275]}, "mutation_prompt": null}
{"id": "cac93259-78d2-4980-952c-ebb3238ffcc3", "solution": "import numpy as np\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n        self.local_search_intensity = 5\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        if np.random.rand() > 0.5:\n            crossover_point = np.random.randint(1, self.dim-1)\n            child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        else:\n            alpha = np.random.rand(self.dim)\n            child = alpha * parent1 + (1 - alpha) * parent2\n        return child\n    \n    def _mutate(self, individual, generation):\n        adaptive_mutation_rate = self.mutation_rate * (1 - generation / self.budget)\n        for i in range(self.dim):\n            if np.random.rand() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        step_size = 0.05  # Reduced step size for finer search\n        neighbors = [individual + np.random.uniform(-step_size, step_size, self.dim) for _ in range(self.local_search_intensity)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n        generation = 0\n\n        while self.evaluations < self.budget:\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1, generation)\n                child2 = self._mutate(child2, generation)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n            generation += 1\n            # Adjust population size over generations\n            if generation % 10 == 0 and self.evaluations < self.budget:\n                self.population_size = min(self.population_size + 2, int(0.5 * self.budget / self.dim))\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "Improved hybrid genetic algorithm with dynamic population size and enhanced local search for faster convergence.", "configspace": "", "generation": 97, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 21 is out of bounds for axis 0 with size 20').", "error": "IndexError('index 21 is out of bounds for axis 0 with size 20')", "parent_id": "ba0ad45e-79a5-497a-a152-a00347f6aeec", "metadata": {}, "mutation_prompt": null}
{"id": "618cb238-a049-4612-98f2-ff6059baad36", "solution": "import numpy as np\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        if np.random.rand() > 0.5:\n            crossover_point = np.random.randint(1, self.dim-1)\n            child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        else:\n            alpha = np.random.rand(self.dim)\n            child = alpha * parent1 + (1 - alpha) * parent2\n        return child\n    \n    def _mutate(self, individual, generation):\n        adaptive_mutation_rate = self.mutation_rate * (1 - generation / self.budget)\n        for i in range(self.dim):\n            if np.random.rand() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n        generation = 0\n\n        while self.evaluations < self.budget:\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1, generation)\n                child2 = self._mutate(child2, generation)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n            generation += 1\n        \n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "An enhanced hybrid genetic algorithm utilizing adaptive mutation rates and elite replacement for faster convergence.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ba0ad45e-79a5-497a-a152-a00347f6aeec", "metadata": {"aucs": [0.5188767331596345, 0.5064088709886925, 0.529496447239648, 0.5144420539623902, 0.5370488447429549, 0.5112964000634398, 0.5443189240093997, 0.5151759905658304, 0.5295974625296624, 0.11628763434397549, 0.073237962137081, 0.1171960218681154, 0.1328054441372537, 0.06734962385719301, 0.18702089088395346, 0.11794777197766848, 0.16142451141806613, 0.09479736946696471, 0.13340173656759524, 0.11187463710972767, 0.13141237757711532, 0.13803893579674764, 0.14700684185232926, 0.23298106805301155, 0.15599881259017334, 0.13753294373569147, 0.14748159785705617, 0.10876875324652024, 0.1199588748125876, 0.11442623443949529, 0.1376682920812753, 0.10753935447249918, 0.11529412838556907, 0.14411587550759053, 0.12631171847284206, 0.09899476319301614, 0.8657788659263602, 0.8708037771669245, 0.8456890545782719, 0.852582574405035, 0.8831960734694649, 0.8854751829924894, 0.8679232429229845, 0.9140837729660892, 0.9015444725811272, 0.3568268521148178, 0.34169183216634236, 0.3275012350470019, 0.3020994963658874, 0.3330206291499205, 0.3610407508786032, 0.33862374062362166, 0.3033525987268578, 0.29969884168468375, 0.1565724305817624, 0.24612530080806716, 0.1426010858307345, 0.2145150807661389, 0.26942187158728426, 0.35259656298456443, 0.15752276978004842, 0.23846888290241963, 0.1995849784012269, 0.17774147063968737, 0.1654716515977942, 0.17840744983435375, 0.15724909282867372, 0.20144777914869705, 0.17030827069467014, 0.16330246182093688, 0.24655007798684248, 0.3514770322958348, 0.14225247094640325, 0.13435904494185447, 0.17037749954018255, 0.16814900747676498, 0.2131401520323899, 0.15134788406363442, 0.14338955739022818, 0.29561775046554084, 0.15586750501445734, 9.999999999998899e-05, 9.999999999998899e-05, 0.0035166480994790472, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06961805886886052, 0.025233134646751365, 0.06903749483907706, 0.05645912279153509, 0.023355064750135157, 0.007827625196492938, 0.11200956379572746, 0.06318894312464596, 0.07997994142271458, 0.006665368751889056, 0.01157989821538663, 0.0017879740169762792, 0.00037159721867408013, 0.014947521855188661, 0.00412625368969477, 9.999999999998899e-05, 0.017349969084643257, 0.0288434555395799, 0.11476562071290586, 0.09215900389490728, 0.1390202896632774, 0.10268411211077477, 0.15948143646883395, 0.05918458680430527, 0.1635227025727929, 0.1255441073180733, 0.08405591483482644, 0.4897452909625738, 0.468474821918648, 0.4482336644336633, 0.46810298655440497, 0.4340659450409212, 0.46357283616222056, 0.4808855253363665, 0.4599415934511112, 0.4624649242993303, 0.09612734276923707, 0.09116039412042976, 0.04977867560294946, 0.1898093805089569, 0.10496876212120221, 0.06321529017138294, 0.07345975748157285, 0.07668599384362873, 0.10252236141264515, 0.24700017564221022, 0.2446872303976746, 0.22846517531484667, 0.31439445608657246, 0.2839388691347797, 0.1889649936153983, 0.25740041441158334, 0.18576644935792974, 0.21280984219620136, 0.21531507504464076, 0.20831586277199543, 0.15805015565264835, 0.2224181463999947, 0.22630207944566505, 0.24714886348589782, 0.3333252362352441, 0.344323674464301, 0.3200394607320015, 0.18958770263436542, 0.2653879417765064, 0.2140139407956907, 0.22514312964500183, 0.19190956803712, 0.21345436527623785, 0.18053751764889692, 0.27381120341821585, 0.24499272608489986, 0.2655839730192584, 0.2551418397180554, 0.20957167420847034, 0.19588568342895574, 0.17548267970119247, 0.23386637959141454, 0.20526428858870627, 0.2081861724669316, 0.20663037237230641, 0.21114615850956675, 0.20210698859591936, 0.1992334651046238, 0.19377810514516836, 0.1824560207628787, 0.21544272153051447, 0.19972876917705684, 0.18556784259466508, 0.17953088823492835, 0.11672352782602902, 0.12712245852129767, 0.15365179749505953, 0.7952637986062888, 0.7358143023317176, 0.7555169639492753, 0.15403889412227878, 0.16968212653933712, 0.15023210862774394, 0.14938982545497348, 0.5345065084217684, 0.3925973379115292, 0.501162113080057, 0.21411065416242636, 0.2127683016083336, 0.105237221246827, 0.5403138581297193, 0.36233078815169917, 0.18154529264887365, 0.19034695359780784, 0.18705007118961925, 0.18731944499283237, 0.18862450994714908, 0.181368886160578, 0.17684088976439394, 0.18598429030599295, 0.18143220521539383, 0.10188353392374716, 0.07538361466450083, 0.07502758819782429, 0.08189984021125563, 0.07672220611827174, 0.07808450200416772, 0.1002375240971789, 0.09321245465027461, 0.07584274895336707]}, "mutation_prompt": null}
{"id": "a9c6faa6-4374-4845-bff6-44b47811d4cb", "solution": "import numpy as np\n\nclass HybridGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_rate = 0.1\n        self.elite_fraction = 0.2\n        self.tournament_size = 4\n        self.lb = -5.0\n        self.ub = 5.0\n        self.evaluations = 0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        selected = []\n        for _ in range(self.population_size):\n            tournament = np.random.choice(self.population_size, self.tournament_size, replace=False)\n            best = tournament[np.argmin(fitness[tournament])]\n            selected.append(best)\n        return selected\n\n    def _crossover(self, parent1, parent2):\n        if np.random.rand() > 0.5:\n            crossover_point = np.random.randint(1, self.dim-1)\n            child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        else:\n            alpha = np.random.rand(self.dim)\n            child = alpha * parent1 + (1 - alpha) * parent2\n        return child\n    \n    def _mutate(self, individual, generation):\n        adaptive_mutation_rate = self.mutation_rate * (1 - generation / self.budget)\n        for i in range(self.dim):\n            if np.random.rand() < adaptive_mutation_rate:\n                individual[i] = np.random.uniform(self.lb, self.ub)\n        return individual\n\n    def _local_search(self, individual, func):\n        neighbors = [individual + np.random.uniform(-0.1, 0.1, self.dim) for _ in range(5)]\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        neighbor_fitness = [func(neighbor) for neighbor in neighbors]\n        best_neighbor = neighbors[np.argmin(neighbor_fitness)]\n        return best_neighbor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n        self.evaluations += self.population_size\n        generation = 0\n\n        while self.evaluations < self.budget:\n            parents_idx = self._select_parents(fitness)\n            new_population = []\n\n            for i in range(0, self.population_size, 2):\n                parent1 = population[parents_idx[i]]\n                parent2 = population[parents_idx[i+1]]\n\n                child1 = self._crossover(parent1, parent2)\n                child2 = self._crossover(parent2, parent1)\n\n                child1 = self._mutate(child1, generation)\n                child2 = self._mutate(child2, generation)\n\n                new_population.append(child1)\n                new_population.append(child2)\n            \n            new_population = np.array(new_population)\n\n            new_fitness = self._evaluate_population(new_population, func)\n            self.evaluations += self.population_size\n\n            combined_population = np.vstack((population, new_population))\n            combined_fitness = np.hstack((fitness, new_fitness))\n            elite_count = int(self.elite_fraction * self.population_size)\n\n            elite_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[elite_indices]\n            fitness = combined_fitness[elite_indices]\n\n            for i in range(elite_count):\n                population[i] = self._local_search(population[i], func)\n                fitness[i] = func(population[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n            generation += 1\n        \n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "HybridGeneticAlgorithm", "description": "An enhanced hybrid genetic algorithm utilizing adaptive mutation rates and elite replacement for faster convergence.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ba0ad45e-79a5-497a-a152-a00347f6aeec", "metadata": {"aucs": [0.5188767331596345, 0.5064088709886925, 0.529496447239648, 0.5144420539623902, 0.5370488447429549, 0.5112964000634398, 0.5443189240093997, 0.5151759905658304, 0.5295974625296624, 0.11628763434397549, 0.073237962137081, 0.1171960218681154, 0.1328054441372537, 0.06734962385719301, 0.18702089088395346, 0.11794777197766848, 0.16142451141806613, 0.09479736946696471, 0.13340173656759524, 0.11187463710972767, 0.13141237757711532, 0.13803893579674764, 0.14700684185232926, 0.23298106805301155, 0.15599881259017334, 0.13753294373569147, 0.14748159785705617, 0.10876875324652024, 0.1199588748125876, 0.11442623443949529, 0.1376682920812753, 0.10753935447249918, 0.11529412838556907, 0.14411587550759053, 0.12631171847284206, 0.09899476319301614, 0.8657788659263602, 0.8708037771669245, 0.8456890545782719, 0.852582574405035, 0.8831960734694649, 0.8854751829924894, 0.8679232429229845, 0.9140837729660892, 0.9015444725811272, 0.3568268521148178, 0.34169183216634236, 0.3275012350470019, 0.3020994963658874, 0.3330206291499205, 0.3610407508786032, 0.33862374062362166, 0.3033525987268578, 0.29969884168468375, 0.1565724305817624, 0.24612530080806716, 0.1426010858307345, 0.2145150807661389, 0.26942187158728426, 0.35259656298456443, 0.15752276978004842, 0.23846888290241963, 0.1995849784012269, 0.17774147063968737, 0.1654716515977942, 0.17840744983435375, 0.15724909282867372, 0.20144777914869705, 0.17030827069467014, 0.16330246182093688, 0.24655007798684248, 0.3514770322958348, 0.14225247094640325, 0.13435904494185447, 0.17037749954018255, 0.16814900747676498, 0.2131401520323899, 0.15134788406363442, 0.14338955739022818, 0.29561775046554084, 0.15586750501445734, 9.999999999998899e-05, 9.999999999998899e-05, 0.0035166480994790472, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06961805886886052, 0.025233134646751365, 0.06903749483907706, 0.05645912279153509, 0.023355064750135157, 0.007827625196492938, 0.11200956379572746, 0.06318894312464596, 0.07997994142271458, 0.006665368751889056, 0.01157989821538663, 0.0017879740169762792, 0.00037159721867408013, 0.014947521855188661, 0.00412625368969477, 9.999999999998899e-05, 0.017349969084643257, 0.0288434555395799, 0.11476562071290586, 0.09215900389490728, 0.1390202896632774, 0.10268411211077477, 0.15948143646883395, 0.05918458680430527, 0.1635227025727929, 0.1255441073180733, 0.08405591483482644, 0.4897452909625738, 0.468474821918648, 0.4482336644336633, 0.46810298655440497, 0.4340659450409212, 0.46357283616222056, 0.4808855253363665, 0.4599415934511112, 0.4624649242993303, 0.09612734276923707, 0.09116039412042976, 0.04977867560294946, 0.1898093805089569, 0.10496876212120221, 0.06321529017138294, 0.07345975748157285, 0.07668599384362873, 0.10252236141264515, 0.24700017564221022, 0.2446872303976746, 0.22846517531484667, 0.31439445608657246, 0.2839388691347797, 0.1889649936153983, 0.25740041441158334, 0.18576644935792974, 0.21280984219620136, 0.21531507504464076, 0.20831586277199543, 0.15805015565264835, 0.2224181463999947, 0.22630207944566505, 0.24714886348589782, 0.3333252362352441, 0.344323674464301, 0.3200394607320015, 0.18958770263436542, 0.2653879417765064, 0.2140139407956907, 0.22514312964500183, 0.19190956803712, 0.21345436527623785, 0.18053751764889692, 0.27381120341821585, 0.24499272608489986, 0.2655839730192584, 0.2551418397180554, 0.20957167420847034, 0.19588568342895574, 0.17548267970119247, 0.23386637959141454, 0.20526428858870627, 0.2081861724669316, 0.20663037237230641, 0.21114615850956675, 0.20210698859591936, 0.1992334651046238, 0.19377810514516836, 0.1824560207628787, 0.21544272153051447, 0.19972876917705684, 0.18556784259466508, 0.17953088823492835, 0.11672352782602902, 0.12712245852129767, 0.15365179749505953, 0.7952637986062888, 0.7358143023317176, 0.7555169639492753, 0.15403889412227878, 0.16968212653933712, 0.15023210862774394, 0.14938982545497348, 0.5345065084217684, 0.3925973379115292, 0.501162113080057, 0.21411065416242636, 0.2127683016083336, 0.105237221246827, 0.5403138581297193, 0.36233078815169917, 0.18154529264887365, 0.19034695359780784, 0.18705007118961925, 0.18731944499283237, 0.18862450994714908, 0.181368886160578, 0.17684088976439394, 0.18598429030599295, 0.18143220521539383, 0.10188353392374716, 0.07538361466450083, 0.07502758819782429, 0.08189984021125563, 0.07672220611827174, 0.07808450200416772, 0.1002375240971789, 0.09321245465027461, 0.07584274895336707]}, "mutation_prompt": null}
