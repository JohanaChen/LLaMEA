{"id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "solution": "import numpy as np\n\nclass MemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Local search on best individual\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            best_fitness = fitness[best_index]\n            \n            # Perform a simple random neighborhood search around the best individual\n            local_neighbors = best_individual + np.random.uniform(-0.1, 0.1, (10, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n            \n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_index]\n                best_fitness = local_fitness[best_index]\n                \n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "MemeticDifferentialEvolution", "description": "A memetic algorithm combining differential evolution and local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 0, "fitness": 0.2762244307598156, "feedback": "The algorithm MemeticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.21.", "error": "", "parent_id": null, "metadata": {"aucs": [0.5836225311948049, 0.5895675481708798, 0.5931935339412369, 0.6092798817755256, 0.5971191751395089, 0.6202579917834308, 0.5915666641654593, 0.6329231146089245, 0.614496547496218, 0.3269420225697043, 0.32341007556044665, 0.3067393591575437, 0.33025145964783187, 0.3164549216374125, 0.31410736857977894, 0.3034373833378351, 0.32458656142264397, 0.32448189010106865, 0.0932342943891219, 0.14210171319527398, 0.12124651238007733, 0.1117186560595137, 0.10416462667954152, 0.13469583922195927, 0.10778599739147499, 0.10180983716471348, 0.11519071115675017, 0.09089923321281623, 0.07916223832856029, 0.09650580656142027, 0.10828047219810033, 0.09519688902934909, 0.11137299647643428, 0.11246531376395619, 0.12295482105811084, 0.09031900319661212, 0.9570017798820938, 0.9513292557106726, 0.9261189549404044, 0.932623940991951, 0.9277210170918078, 0.9656618317581583, 0.9643447913571865, 0.9721847342834466, 0.953476269027666, 0.29421687546028763, 0.31172891459799634, 0.28049672705086315, 0.28360228842594426, 0.29617362506457234, 0.31417605357685474, 0.3030308170377122, 0.2945013636010071, 0.31683005641423334, 0.5179901746271818, 0.4967938945250143, 0.3992218655444725, 0.6421024689794905, 0.4829996488068862, 0.5444143981709784, 0.818801602910831, 0.4169046635013345, 0.5667733833019734, 0.1729377314210867, 0.19408614048524442, 0.2189357195687498, 0.17003335976335543, 0.1734456129185239, 0.22317341038415006, 0.16815520346172597, 0.23471455937223595, 0.18005566062328848, 0.17128012630579414, 0.22078714561119273, 0.18985238237062607, 0.17887929005036718, 0.14169377179786802, 0.17179544957294768, 0.1912676319700436, 0.19817619522267937, 0.1992738826984083, 0.12609625599841567, 0.0884125386662783, 0.07419627554103048, 0.12689456376567354, 0.09695846887388382, 0.10487159974444749, 0.0874590757433692, 0.10069088517058722, 0.08757007935442673, 0.24629823159854047, 0.23721672551643924, 0.1937924518431159, 0.2360613318904099, 0.2283277969657893, 0.21070951185422226, 0.24376182655715817, 0.2505002143128586, 0.24655490215416498, 0.008900204497490405, 0.029919102645743822, 0.0025024944447568087, 0.0084676904081743, 0.012605954307217115, 0.02776100803567294, 0.025295612550901736, 0.023065392675113428, 0.023991856805336775, 0.14806031195500602, 0.16610838876205658, 0.14065028111594324, 0.15394747464367609, 0.14242247562505017, 0.1641355696142669, 0.13765768978862902, 0.14788652466503827, 0.14584253302347738, 0.47246127760880385, 0.468467834239634, 0.488651401632924, 0.46925752632019735, 0.47998205454430665, 0.4819209969882894, 0.48289905070808636, 0.478057701671476, 0.46432681688452015, 0.11941284027623278, 0.0970678050806677, 0.12705107697367768, 0.10342182382932241, 0.10174470673056091, 0.11317706319574627, 0.14065440601023493, 0.09688588256048702, 0.12232279486506359, 0.20147186942807993, 0.22762076159867817, 0.19167359996581346, 0.20502140494458854, 0.3240914377838958, 0.15302899385411983, 0.222969704226318, 0.1971035981559942, 0.3370545323977565, 0.2915631131514015, 0.2631696010212998, 0.28266814135970175, 0.2545950968525381, 0.23443404208008423, 0.27872565991797915, 0.29236532880326027, 0.2846885922197856, 0.2795686791733427, 0.22804063504413763, 0.19258150404602026, 0.23416578679225863, 0.20352583786546963, 0.20717979619202664, 0.17512893086659753, 0.22160308336762413, 0.22804313370465612, 0.21915684395892931, 0.18908813501361632, 0.17079934041368217, 0.17177489544080238, 0.17704592116144846, 0.18118821348623737, 0.17809420476787874, 0.17775590335163471, 0.206728362256554, 0.19042325886574185, 0.19072141796360798, 0.20708449878617063, 0.21776916142881442, 0.19864304601679117, 0.1784266230160374, 0.18479795624277462, 0.21614367460058825, 0.1847424949658062, 0.2039222438571181, 0.6394295150533678, 0.709437038437505, 0.7272318055454359, 0.5459823777417234, 0.1983296595458679, 0.4496339112997588, 0.25540549812494295, 0.29281538805566965, 0.7376930203897825, 0.5344888407338009, 0.20672273819014408, 0.20382124454786565, 0.48192720836055014, 0.34688484757813565, 0.4575825880974329, 0.20682700934964893, 0.20496293634642548, 0.6488622698891036, 0.18509977707364345, 0.191089084099894, 0.18985410408145043, 0.20991206604435897, 0.18978085941796408, 0.19381728563676692, 0.2088429573450009, 0.18922114346994845, 0.18003992478764397, 0.06385995992359572, 0.06776328975003743, 0.08246546412260414, 0.06396501809912802, 0.07245866633439724, 0.07308179633849543, 0.07386375926689548, 0.07343376732690299, 0.07683714007868037]}, "mutation_prompt": null}
{"id": "d889d412-712c-4e35-9351-574654127870", "solution": "import numpy as np\n\nclass MemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Local search on best individual\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            best_fitness = fitness[best_index]\n            \n            # Perform a simple random neighborhood search around the best individual\n            local_neighbors = best_individual + np.random.uniform(-0.1, 0.1, (10, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n            \n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_index]\n                best_fitness = local_fitness[best_index]\n                \n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "MemeticDifferentialEvolution", "description": "A memetic algorithm combining differential evolution and local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.5836225311948049, 0.5895675481708798, 0.5931935339412369, 0.6092798817755256, 0.5971191751395089, 0.6202579917834308, 0.5915666641654593, 0.6329231146089245, 0.614496547496218, 0.3269420225697043, 0.32341007556044665, 0.3067393591575437, 0.33025145964783187, 0.3164549216374125, 0.31410736857977894, 0.3034373833378351, 0.32458656142264397, 0.32448189010106865, 0.0932342943891219, 0.14210171319527398, 0.12124651238007733, 0.1117186560595137, 0.10416462667954152, 0.13469583922195927, 0.10778599739147499, 0.10180983716471348, 0.11519071115675017, 0.09089923321281623, 0.07916223832856029, 0.09650580656142027, 0.10828047219810033, 0.09519688902934909, 0.11137299647643428, 0.11246531376395619, 0.12295482105811084, 0.09031900319661212, 0.9570017798820938, 0.9513292557106726, 0.9261189549404044, 0.932623940991951, 0.9277210170918078, 0.9656618317581583, 0.9643447913571865, 0.9721847342834466, 0.953476269027666, 0.29421687546028763, 0.31172891459799634, 0.28049672705086315, 0.28360228842594426, 0.29617362506457234, 0.31417605357685474, 0.3030308170377122, 0.2945013636010071, 0.31683005641423334, 0.5179901746271818, 0.4967938945250143, 0.3992218655444725, 0.6421024689794905, 0.4829996488068862, 0.5444143981709784, 0.818801602910831, 0.4169046635013345, 0.5667733833019734, 0.1729377314210867, 0.19408614048524442, 0.2189357195687498, 0.17003335976335543, 0.1734456129185239, 0.22317341038415006, 0.16815520346172597, 0.23471455937223595, 0.18005566062328848, 0.17128012630579414, 0.22078714561119273, 0.18985238237062607, 0.17887929005036718, 0.14169377179786802, 0.17179544957294768, 0.1912676319700436, 0.19817619522267937, 0.1992738826984083, 0.12609625599841567, 0.0884125386662783, 0.07419627554103048, 0.12689456376567354, 0.09695846887388382, 0.10487159974444749, 0.0874590757433692, 0.10069088517058722, 0.08757007935442673, 0.24629823159854047, 0.23721672551643924, 0.1937924518431159, 0.2360613318904099, 0.2283277969657893, 0.21070951185422226, 0.24376182655715817, 0.2505002143128586, 0.24655490215416498, 0.008900204497490405, 0.029919102645743822, 0.0025024944447568087, 0.0084676904081743, 0.012605954307217115, 0.02776100803567294, 0.025295612550901736, 0.023065392675113428, 0.023991856805336775, 0.14806031195500602, 0.16610838876205658, 0.14065028111594324, 0.15394747464367609, 0.14242247562505017, 0.1641355696142669, 0.13765768978862902, 0.14788652466503827, 0.14584253302347738, 0.47246127760880385, 0.468467834239634, 0.488651401632924, 0.46925752632019735, 0.47998205454430665, 0.4819209969882894, 0.48289905070808636, 0.478057701671476, 0.46432681688452015, 0.11941284027623278, 0.0970678050806677, 0.12705107697367768, 0.10342182382932241, 0.10174470673056091, 0.11317706319574627, 0.14065440601023493, 0.09688588256048702, 0.12232279486506359, 0.20147186942807993, 0.22762076159867817, 0.19167359996581346, 0.20502140494458854, 0.3240914377838958, 0.15302899385411983, 0.222969704226318, 0.1971035981559942, 0.3370545323977565, 0.2915631131514015, 0.2631696010212998, 0.28266814135970175, 0.2545950968525381, 0.23443404208008423, 0.27872565991797915, 0.29236532880326027, 0.2846885922197856, 0.2795686791733427, 0.22804063504413763, 0.19258150404602026, 0.23416578679225863, 0.20352583786546963, 0.20717979619202664, 0.17512893086659753, 0.22160308336762413, 0.22804313370465612, 0.21915684395892931, 0.18908813501361632, 0.17079934041368217, 0.17177489544080238, 0.17704592116144846, 0.18118821348623737, 0.17809420476787874, 0.17775590335163471, 0.206728362256554, 0.19042325886574185, 0.19072141796360798, 0.20708449878617063, 0.21776916142881442, 0.19864304601679117, 0.1784266230160374, 0.18479795624277462, 0.21614367460058825, 0.1847424949658062, 0.2039222438571181, 0.6394295150533678, 0.709437038437505, 0.7272318055454359, 0.5459823777417234, 0.1983296595458679, 0.4496339112997588, 0.25540549812494295, 0.29281538805566965, 0.7376930203897825, 0.5344888407338009, 0.20672273819014408, 0.20382124454786565, 0.48192720836055014, 0.34688484757813565, 0.4575825880974329, 0.20682700934964893, 0.20496293634642548, 0.6488622698891036, 0.18509977707364345, 0.191089084099894, 0.18985410408145043, 0.20991206604435897, 0.18978085941796408, 0.19381728563676692, 0.2088429573450009, 0.18922114346994845, 0.18003992478764397, 0.06385995992359572, 0.06776328975003743, 0.08246546412260414, 0.06396501809912802, 0.07245866633439724, 0.07308179633849543, 0.07386375926689548, 0.07343376732690299, 0.07683714007868037]}, "mutation_prompt": null}
{"id": "b66bbc2f-a797-4d4e-a9a2-3b191127341f", "solution": "import numpy as np\n\nclass MemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Local search on best individual\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            best_fitness = fitness[best_index]\n            \n            # Perform a simple random neighborhood search around the best individual\n            local_neighbors = best_individual + np.random.uniform(-0.1, 0.1, (10, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n            \n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_index]\n                best_fitness = local_fitness[best_index]\n                \n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "MemeticDifferentialEvolution", "description": "A memetic algorithm combining differential evolution and local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.5836225311948049, 0.5895675481708798, 0.5931935339412369, 0.6092798817755256, 0.5971191751395089, 0.6202579917834308, 0.5915666641654593, 0.6329231146089245, 0.614496547496218, 0.3269420225697043, 0.32341007556044665, 0.3067393591575437, 0.33025145964783187, 0.3164549216374125, 0.31410736857977894, 0.3034373833378351, 0.32458656142264397, 0.32448189010106865, 0.0932342943891219, 0.14210171319527398, 0.12124651238007733, 0.1117186560595137, 0.10416462667954152, 0.13469583922195927, 0.10778599739147499, 0.10180983716471348, 0.11519071115675017, 0.09089923321281623, 0.07916223832856029, 0.09650580656142027, 0.10828047219810033, 0.09519688902934909, 0.11137299647643428, 0.11246531376395619, 0.12295482105811084, 0.09031900319661212, 0.9570017798820938, 0.9513292557106726, 0.9261189549404044, 0.932623940991951, 0.9277210170918078, 0.9656618317581583, 0.9643447913571865, 0.9721847342834466, 0.953476269027666, 0.29421687546028763, 0.31172891459799634, 0.28049672705086315, 0.28360228842594426, 0.29617362506457234, 0.31417605357685474, 0.3030308170377122, 0.2945013636010071, 0.31683005641423334, 0.5179901746271818, 0.4967938945250143, 0.3992218655444725, 0.6421024689794905, 0.4829996488068862, 0.5444143981709784, 0.818801602910831, 0.4169046635013345, 0.5667733833019734, 0.1729377314210867, 0.19408614048524442, 0.2189357195687498, 0.17003335976335543, 0.1734456129185239, 0.22317341038415006, 0.16815520346172597, 0.23471455937223595, 0.18005566062328848, 0.17128012630579414, 0.22078714561119273, 0.18985238237062607, 0.17887929005036718, 0.14169377179786802, 0.17179544957294768, 0.1912676319700436, 0.19817619522267937, 0.1992738826984083, 0.12609625599841567, 0.0884125386662783, 0.07419627554103048, 0.12689456376567354, 0.09695846887388382, 0.10487159974444749, 0.0874590757433692, 0.10069088517058722, 0.08757007935442673, 0.24629823159854047, 0.23721672551643924, 0.1937924518431159, 0.2360613318904099, 0.2283277969657893, 0.21070951185422226, 0.24376182655715817, 0.2505002143128586, 0.24655490215416498, 0.008900204497490405, 0.029919102645743822, 0.0025024944447568087, 0.0084676904081743, 0.012605954307217115, 0.02776100803567294, 0.025295612550901736, 0.023065392675113428, 0.023991856805336775, 0.14806031195500602, 0.16610838876205658, 0.14065028111594324, 0.15394747464367609, 0.14242247562505017, 0.1641355696142669, 0.13765768978862902, 0.14788652466503827, 0.14584253302347738, 0.47246127760880385, 0.468467834239634, 0.488651401632924, 0.46925752632019735, 0.47998205454430665, 0.4819209969882894, 0.48289905070808636, 0.478057701671476, 0.46432681688452015, 0.11941284027623278, 0.0970678050806677, 0.12705107697367768, 0.10342182382932241, 0.10174470673056091, 0.11317706319574627, 0.14065440601023493, 0.09688588256048702, 0.12232279486506359, 0.20147186942807993, 0.22762076159867817, 0.19167359996581346, 0.20502140494458854, 0.3240914377838958, 0.15302899385411983, 0.222969704226318, 0.1971035981559942, 0.3370545323977565, 0.2915631131514015, 0.2631696010212998, 0.28266814135970175, 0.2545950968525381, 0.23443404208008423, 0.27872565991797915, 0.29236532880326027, 0.2846885922197856, 0.2795686791733427, 0.22804063504413763, 0.19258150404602026, 0.23416578679225863, 0.20352583786546963, 0.20717979619202664, 0.17512893086659753, 0.22160308336762413, 0.22804313370465612, 0.21915684395892931, 0.18908813501361632, 0.17079934041368217, 0.17177489544080238, 0.17704592116144846, 0.18118821348623737, 0.17809420476787874, 0.17775590335163471, 0.206728362256554, 0.19042325886574185, 0.19072141796360798, 0.20708449878617063, 0.21776916142881442, 0.19864304601679117, 0.1784266230160374, 0.18479795624277462, 0.21614367460058825, 0.1847424949658062, 0.2039222438571181, 0.6394295150533678, 0.709437038437505, 0.7272318055454359, 0.5459823777417234, 0.1983296595458679, 0.4496339112997588, 0.25540549812494295, 0.29281538805566965, 0.7376930203897825, 0.5344888407338009, 0.20672273819014408, 0.20382124454786565, 0.48192720836055014, 0.34688484757813565, 0.4575825880974329, 0.20682700934964893, 0.20496293634642548, 0.6488622698891036, 0.18509977707364345, 0.191089084099894, 0.18985410408145043, 0.20991206604435897, 0.18978085941796408, 0.19381728563676692, 0.2088429573450009, 0.18922114346994845, 0.18003992478764397, 0.06385995992359572, 0.06776328975003743, 0.08246546412260414, 0.06396501809912802, 0.07245866633439724, 0.07308179633849543, 0.07386375926689548, 0.07343376732690299, 0.07683714007868037]}, "mutation_prompt": null}
{"id": "7428768e-e5d2-4c0e-8dae-98af989f6b1f", "solution": "import numpy as np\n\nclass MemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Local search on best individual\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            best_fitness = fitness[best_index]\n            \n            # Perform a simple random neighborhood search around the best individual\n            local_neighbors = best_individual + np.random.uniform(-0.1, 0.1, (10, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n            \n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_index]\n                best_fitness = local_fitness[best_index]\n                \n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "MemeticDifferentialEvolution", "description": "A memetic algorithm combining differential evolution and local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.5836225311948049, 0.5895675481708798, 0.5931935339412369, 0.6092798817755256, 0.5971191751395089, 0.6202579917834308, 0.5915666641654593, 0.6329231146089245, 0.614496547496218, 0.3269420225697043, 0.32341007556044665, 0.3067393591575437, 0.33025145964783187, 0.3164549216374125, 0.31410736857977894, 0.3034373833378351, 0.32458656142264397, 0.32448189010106865, 0.0932342943891219, 0.14210171319527398, 0.12124651238007733, 0.1117186560595137, 0.10416462667954152, 0.13469583922195927, 0.10778599739147499, 0.10180983716471348, 0.11519071115675017, 0.09089923321281623, 0.07916223832856029, 0.09650580656142027, 0.10828047219810033, 0.09519688902934909, 0.11137299647643428, 0.11246531376395619, 0.12295482105811084, 0.09031900319661212, 0.9570017798820938, 0.9513292557106726, 0.9261189549404044, 0.932623940991951, 0.9277210170918078, 0.9656618317581583, 0.9643447913571865, 0.9721847342834466, 0.953476269027666, 0.29421687546028763, 0.31172891459799634, 0.28049672705086315, 0.28360228842594426, 0.29617362506457234, 0.31417605357685474, 0.3030308170377122, 0.2945013636010071, 0.31683005641423334, 0.5179901746271818, 0.4967938945250143, 0.3992218655444725, 0.6421024689794905, 0.4829996488068862, 0.5444143981709784, 0.818801602910831, 0.4169046635013345, 0.5667733833019734, 0.1729377314210867, 0.19408614048524442, 0.2189357195687498, 0.17003335976335543, 0.1734456129185239, 0.22317341038415006, 0.16815520346172597, 0.23471455937223595, 0.18005566062328848, 0.17128012630579414, 0.22078714561119273, 0.18985238237062607, 0.17887929005036718, 0.14169377179786802, 0.17179544957294768, 0.1912676319700436, 0.19817619522267937, 0.1992738826984083, 0.12609625599841567, 0.0884125386662783, 0.07419627554103048, 0.12689456376567354, 0.09695846887388382, 0.10487159974444749, 0.0874590757433692, 0.10069088517058722, 0.08757007935442673, 0.24629823159854047, 0.23721672551643924, 0.1937924518431159, 0.2360613318904099, 0.2283277969657893, 0.21070951185422226, 0.24376182655715817, 0.2505002143128586, 0.24655490215416498, 0.008900204497490405, 0.029919102645743822, 0.0025024944447568087, 0.0084676904081743, 0.012605954307217115, 0.02776100803567294, 0.025295612550901736, 0.023065392675113428, 0.023991856805336775, 0.14806031195500602, 0.16610838876205658, 0.14065028111594324, 0.15394747464367609, 0.14242247562505017, 0.1641355696142669, 0.13765768978862902, 0.14788652466503827, 0.14584253302347738, 0.47246127760880385, 0.468467834239634, 0.488651401632924, 0.46925752632019735, 0.47998205454430665, 0.4819209969882894, 0.48289905070808636, 0.478057701671476, 0.46432681688452015, 0.11941284027623278, 0.0970678050806677, 0.12705107697367768, 0.10342182382932241, 0.10174470673056091, 0.11317706319574627, 0.14065440601023493, 0.09688588256048702, 0.12232279486506359, 0.20147186942807993, 0.22762076159867817, 0.19167359996581346, 0.20502140494458854, 0.3240914377838958, 0.15302899385411983, 0.222969704226318, 0.1971035981559942, 0.3370545323977565, 0.2915631131514015, 0.2631696010212998, 0.28266814135970175, 0.2545950968525381, 0.23443404208008423, 0.27872565991797915, 0.29236532880326027, 0.2846885922197856, 0.2795686791733427, 0.22804063504413763, 0.19258150404602026, 0.23416578679225863, 0.20352583786546963, 0.20717979619202664, 0.17512893086659753, 0.22160308336762413, 0.22804313370465612, 0.21915684395892931, 0.18908813501361632, 0.17079934041368217, 0.17177489544080238, 0.17704592116144846, 0.18118821348623737, 0.17809420476787874, 0.17775590335163471, 0.206728362256554, 0.19042325886574185, 0.19072141796360798, 0.20708449878617063, 0.21776916142881442, 0.19864304601679117, 0.1784266230160374, 0.18479795624277462, 0.21614367460058825, 0.1847424949658062, 0.2039222438571181, 0.6394295150533678, 0.709437038437505, 0.7272318055454359, 0.5459823777417234, 0.1983296595458679, 0.4496339112997588, 0.25540549812494295, 0.29281538805566965, 0.7376930203897825, 0.5344888407338009, 0.20672273819014408, 0.20382124454786565, 0.48192720836055014, 0.34688484757813565, 0.4575825880974329, 0.20682700934964893, 0.20496293634642548, 0.6488622698891036, 0.18509977707364345, 0.191089084099894, 0.18985410408145043, 0.20991206604435897, 0.18978085941796408, 0.19381728563676692, 0.2088429573450009, 0.18922114346994845, 0.18003992478764397, 0.06385995992359572, 0.06776328975003743, 0.08246546412260414, 0.06396501809912802, 0.07245866633439724, 0.07308179633849543, 0.07386375926689548, 0.07343376732690299, 0.07683714007868037]}, "mutation_prompt": null}
{"id": "ead68e7d-3b46-40d5-af6b-d98e3cfe4b6b", "solution": "import numpy as np\n\nclass MemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Local search on best individual\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            best_fitness = fitness[best_index]\n            \n            # Perform a simple random neighborhood search around the best individual\n            local_neighbors = best_individual + np.random.uniform(-0.1, 0.1, (10, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n            \n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_index]\n                best_fitness = local_fitness[best_index]\n                \n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "MemeticDifferentialEvolution", "description": "A memetic algorithm combining differential evolution and local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.5836225311948049, 0.5895675481708798, 0.5931935339412369, 0.6092798817755256, 0.5971191751395089, 0.6202579917834308, 0.5915666641654593, 0.6329231146089245, 0.614496547496218, 0.3269420225697043, 0.32341007556044665, 0.3067393591575437, 0.33025145964783187, 0.3164549216374125, 0.31410736857977894, 0.3034373833378351, 0.32458656142264397, 0.32448189010106865, 0.0932342943891219, 0.14210171319527398, 0.12124651238007733, 0.1117186560595137, 0.10416462667954152, 0.13469583922195927, 0.10778599739147499, 0.10180983716471348, 0.11519071115675017, 0.09089923321281623, 0.07916223832856029, 0.09650580656142027, 0.10828047219810033, 0.09519688902934909, 0.11137299647643428, 0.11246531376395619, 0.12295482105811084, 0.09031900319661212, 0.9570017798820938, 0.9513292557106726, 0.9261189549404044, 0.932623940991951, 0.9277210170918078, 0.9656618317581583, 0.9643447913571865, 0.9721847342834466, 0.953476269027666, 0.29421687546028763, 0.31172891459799634, 0.28049672705086315, 0.28360228842594426, 0.29617362506457234, 0.31417605357685474, 0.3030308170377122, 0.2945013636010071, 0.31683005641423334, 0.5179901746271818, 0.4967938945250143, 0.3992218655444725, 0.6421024689794905, 0.4829996488068862, 0.5444143981709784, 0.818801602910831, 0.4169046635013345, 0.5667733833019734, 0.1729377314210867, 0.19408614048524442, 0.2189357195687498, 0.17003335976335543, 0.1734456129185239, 0.22317341038415006, 0.16815520346172597, 0.23471455937223595, 0.18005566062328848, 0.17128012630579414, 0.22078714561119273, 0.18985238237062607, 0.17887929005036718, 0.14169377179786802, 0.17179544957294768, 0.1912676319700436, 0.19817619522267937, 0.1992738826984083, 0.12609625599841567, 0.0884125386662783, 0.07419627554103048, 0.12689456376567354, 0.09695846887388382, 0.10487159974444749, 0.0874590757433692, 0.10069088517058722, 0.08757007935442673, 0.24629823159854047, 0.23721672551643924, 0.1937924518431159, 0.2360613318904099, 0.2283277969657893, 0.21070951185422226, 0.24376182655715817, 0.2505002143128586, 0.24655490215416498, 0.008900204497490405, 0.029919102645743822, 0.0025024944447568087, 0.0084676904081743, 0.012605954307217115, 0.02776100803567294, 0.025295612550901736, 0.023065392675113428, 0.023991856805336775, 0.14806031195500602, 0.16610838876205658, 0.14065028111594324, 0.15394747464367609, 0.14242247562505017, 0.1641355696142669, 0.13765768978862902, 0.14788652466503827, 0.14584253302347738, 0.47246127760880385, 0.468467834239634, 0.488651401632924, 0.46925752632019735, 0.47998205454430665, 0.4819209969882894, 0.48289905070808636, 0.478057701671476, 0.46432681688452015, 0.11941284027623278, 0.0970678050806677, 0.12705107697367768, 0.10342182382932241, 0.10174470673056091, 0.11317706319574627, 0.14065440601023493, 0.09688588256048702, 0.12232279486506359, 0.20147186942807993, 0.22762076159867817, 0.19167359996581346, 0.20502140494458854, 0.3240914377838958, 0.15302899385411983, 0.222969704226318, 0.1971035981559942, 0.3370545323977565, 0.2915631131514015, 0.2631696010212998, 0.28266814135970175, 0.2545950968525381, 0.23443404208008423, 0.27872565991797915, 0.29236532880326027, 0.2846885922197856, 0.2795686791733427, 0.22804063504413763, 0.19258150404602026, 0.23416578679225863, 0.20352583786546963, 0.20717979619202664, 0.17512893086659753, 0.22160308336762413, 0.22804313370465612, 0.21915684395892931, 0.18908813501361632, 0.17079934041368217, 0.17177489544080238, 0.17704592116144846, 0.18118821348623737, 0.17809420476787874, 0.17775590335163471, 0.206728362256554, 0.19042325886574185, 0.19072141796360798, 0.20708449878617063, 0.21776916142881442, 0.19864304601679117, 0.1784266230160374, 0.18479795624277462, 0.21614367460058825, 0.1847424949658062, 0.2039222438571181, 0.6394295150533678, 0.709437038437505, 0.7272318055454359, 0.5459823777417234, 0.1983296595458679, 0.4496339112997588, 0.25540549812494295, 0.29281538805566965, 0.7376930203897825, 0.5344888407338009, 0.20672273819014408, 0.20382124454786565, 0.48192720836055014, 0.34688484757813565, 0.4575825880974329, 0.20682700934964893, 0.20496293634642548, 0.6488622698891036, 0.18509977707364345, 0.191089084099894, 0.18985410408145043, 0.20991206604435897, 0.18978085941796408, 0.19381728563676692, 0.2088429573450009, 0.18922114346994845, 0.18003992478764397, 0.06385995992359572, 0.06776328975003743, 0.08246546412260414, 0.06396501809912802, 0.07245866633439724, 0.07308179633849543, 0.07386375926689548, 0.07343376732690299, 0.07683714007868037]}, "mutation_prompt": null}
{"id": "0b1f04ea-4037-4b3e-8bec-7ad935818150", "solution": "import numpy as np\n\nclass MemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Local search on best individual\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            best_fitness = fitness[best_index]\n            \n            # Perform a simple random neighborhood search around the best individual\n            local_neighbors = best_individual + np.random.uniform(-0.1, 0.1, (10, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n            \n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_index]\n                best_fitness = local_fitness[best_index]\n                \n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "MemeticDifferentialEvolution", "description": "A memetic algorithm combining differential evolution and local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.5836225311948049, 0.5895675481708798, 0.5931935339412369, 0.6092798817755256, 0.5971191751395089, 0.6202579917834308, 0.5915666641654593, 0.6329231146089245, 0.614496547496218, 0.3269420225697043, 0.32341007556044665, 0.3067393591575437, 0.33025145964783187, 0.3164549216374125, 0.31410736857977894, 0.3034373833378351, 0.32458656142264397, 0.32448189010106865, 0.0932342943891219, 0.14210171319527398, 0.12124651238007733, 0.1117186560595137, 0.10416462667954152, 0.13469583922195927, 0.10778599739147499, 0.10180983716471348, 0.11519071115675017, 0.09089923321281623, 0.07916223832856029, 0.09650580656142027, 0.10828047219810033, 0.09519688902934909, 0.11137299647643428, 0.11246531376395619, 0.12295482105811084, 0.09031900319661212, 0.9570017798820938, 0.9513292557106726, 0.9261189549404044, 0.932623940991951, 0.9277210170918078, 0.9656618317581583, 0.9643447913571865, 0.9721847342834466, 0.953476269027666, 0.29421687546028763, 0.31172891459799634, 0.28049672705086315, 0.28360228842594426, 0.29617362506457234, 0.31417605357685474, 0.3030308170377122, 0.2945013636010071, 0.31683005641423334, 0.5179901746271818, 0.4967938945250143, 0.3992218655444725, 0.6421024689794905, 0.4829996488068862, 0.5444143981709784, 0.818801602910831, 0.4169046635013345, 0.5667733833019734, 0.1729377314210867, 0.19408614048524442, 0.2189357195687498, 0.17003335976335543, 0.1734456129185239, 0.22317341038415006, 0.16815520346172597, 0.23471455937223595, 0.18005566062328848, 0.17128012630579414, 0.22078714561119273, 0.18985238237062607, 0.17887929005036718, 0.14169377179786802, 0.17179544957294768, 0.1912676319700436, 0.19817619522267937, 0.1992738826984083, 0.12609625599841567, 0.0884125386662783, 0.07419627554103048, 0.12689456376567354, 0.09695846887388382, 0.10487159974444749, 0.0874590757433692, 0.10069088517058722, 0.08757007935442673, 0.24629823159854047, 0.23721672551643924, 0.1937924518431159, 0.2360613318904099, 0.2283277969657893, 0.21070951185422226, 0.24376182655715817, 0.2505002143128586, 0.24655490215416498, 0.008900204497490405, 0.029919102645743822, 0.0025024944447568087, 0.0084676904081743, 0.012605954307217115, 0.02776100803567294, 0.025295612550901736, 0.023065392675113428, 0.023991856805336775, 0.14806031195500602, 0.16610838876205658, 0.14065028111594324, 0.15394747464367609, 0.14242247562505017, 0.1641355696142669, 0.13765768978862902, 0.14788652466503827, 0.14584253302347738, 0.47246127760880385, 0.468467834239634, 0.488651401632924, 0.46925752632019735, 0.47998205454430665, 0.4819209969882894, 0.48289905070808636, 0.478057701671476, 0.46432681688452015, 0.11941284027623278, 0.0970678050806677, 0.12705107697367768, 0.10342182382932241, 0.10174470673056091, 0.11317706319574627, 0.14065440601023493, 0.09688588256048702, 0.12232279486506359, 0.20147186942807993, 0.22762076159867817, 0.19167359996581346, 0.20502140494458854, 0.3240914377838958, 0.15302899385411983, 0.222969704226318, 0.1971035981559942, 0.3370545323977565, 0.2915631131514015, 0.2631696010212998, 0.28266814135970175, 0.2545950968525381, 0.23443404208008423, 0.27872565991797915, 0.29236532880326027, 0.2846885922197856, 0.2795686791733427, 0.22804063504413763, 0.19258150404602026, 0.23416578679225863, 0.20352583786546963, 0.20717979619202664, 0.17512893086659753, 0.22160308336762413, 0.22804313370465612, 0.21915684395892931, 0.18908813501361632, 0.17079934041368217, 0.17177489544080238, 0.17704592116144846, 0.18118821348623737, 0.17809420476787874, 0.17775590335163471, 0.206728362256554, 0.19042325886574185, 0.19072141796360798, 0.20708449878617063, 0.21776916142881442, 0.19864304601679117, 0.1784266230160374, 0.18479795624277462, 0.21614367460058825, 0.1847424949658062, 0.2039222438571181, 0.6394295150533678, 0.709437038437505, 0.7272318055454359, 0.5459823777417234, 0.1983296595458679, 0.4496339112997588, 0.25540549812494295, 0.29281538805566965, 0.7376930203897825, 0.5344888407338009, 0.20672273819014408, 0.20382124454786565, 0.48192720836055014, 0.34688484757813565, 0.4575825880974329, 0.20682700934964893, 0.20496293634642548, 0.6488622698891036, 0.18509977707364345, 0.191089084099894, 0.18985410408145043, 0.20991206604435897, 0.18978085941796408, 0.19381728563676692, 0.2088429573450009, 0.18922114346994845, 0.18003992478764397, 0.06385995992359572, 0.06776328975003743, 0.08246546412260414, 0.06396501809912802, 0.07245866633439724, 0.07308179633849543, 0.07386375926689548, 0.07343376732690299, 0.07683714007868037]}, "mutation_prompt": null}
{"id": "896794b7-5630-4329-b69d-6fc65e163047", "solution": "import numpy as np\n\nclass MemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Local search on best individual\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            best_fitness = fitness[best_index]\n            \n            # Perform a simple random neighborhood search around the best individual\n            local_neighbors = best_individual + np.random.uniform(-0.1, 0.1, (10, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n            \n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_index]\n                best_fitness = local_fitness[best_index]\n                \n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "MemeticDifferentialEvolution", "description": "A memetic algorithm combining differential evolution and local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.5836225311948049, 0.5895675481708798, 0.5931935339412369, 0.6092798817755256, 0.5971191751395089, 0.6202579917834308, 0.5915666641654593, 0.6329231146089245, 0.614496547496218, 0.3269420225697043, 0.32341007556044665, 0.3067393591575437, 0.33025145964783187, 0.3164549216374125, 0.31410736857977894, 0.3034373833378351, 0.32458656142264397, 0.32448189010106865, 0.0932342943891219, 0.14210171319527398, 0.12124651238007733, 0.1117186560595137, 0.10416462667954152, 0.13469583922195927, 0.10778599739147499, 0.10180983716471348, 0.11519071115675017, 0.09089923321281623, 0.07916223832856029, 0.09650580656142027, 0.10828047219810033, 0.09519688902934909, 0.11137299647643428, 0.11246531376395619, 0.12295482105811084, 0.09031900319661212, 0.9570017798820938, 0.9513292557106726, 0.9261189549404044, 0.932623940991951, 0.9277210170918078, 0.9656618317581583, 0.9643447913571865, 0.9721847342834466, 0.953476269027666, 0.29421687546028763, 0.31172891459799634, 0.28049672705086315, 0.28360228842594426, 0.29617362506457234, 0.31417605357685474, 0.3030308170377122, 0.2945013636010071, 0.31683005641423334, 0.5179901746271818, 0.4967938945250143, 0.3992218655444725, 0.6421024689794905, 0.4829996488068862, 0.5444143981709784, 0.818801602910831, 0.4169046635013345, 0.5667733833019734, 0.1729377314210867, 0.19408614048524442, 0.2189357195687498, 0.17003335976335543, 0.1734456129185239, 0.22317341038415006, 0.16815520346172597, 0.23471455937223595, 0.18005566062328848, 0.17128012630579414, 0.22078714561119273, 0.18985238237062607, 0.17887929005036718, 0.14169377179786802, 0.17179544957294768, 0.1912676319700436, 0.19817619522267937, 0.1992738826984083, 0.12609625599841567, 0.0884125386662783, 0.07419627554103048, 0.12689456376567354, 0.09695846887388382, 0.10487159974444749, 0.0874590757433692, 0.10069088517058722, 0.08757007935442673, 0.24629823159854047, 0.23721672551643924, 0.1937924518431159, 0.2360613318904099, 0.2283277969657893, 0.21070951185422226, 0.24376182655715817, 0.2505002143128586, 0.24655490215416498, 0.008900204497490405, 0.029919102645743822, 0.0025024944447568087, 0.0084676904081743, 0.012605954307217115, 0.02776100803567294, 0.025295612550901736, 0.023065392675113428, 0.023991856805336775, 0.14806031195500602, 0.16610838876205658, 0.14065028111594324, 0.15394747464367609, 0.14242247562505017, 0.1641355696142669, 0.13765768978862902, 0.14788652466503827, 0.14584253302347738, 0.47246127760880385, 0.468467834239634, 0.488651401632924, 0.46925752632019735, 0.47998205454430665, 0.4819209969882894, 0.48289905070808636, 0.478057701671476, 0.46432681688452015, 0.11941284027623278, 0.0970678050806677, 0.12705107697367768, 0.10342182382932241, 0.10174470673056091, 0.11317706319574627, 0.14065440601023493, 0.09688588256048702, 0.12232279486506359, 0.20147186942807993, 0.22762076159867817, 0.19167359996581346, 0.20502140494458854, 0.3240914377838958, 0.15302899385411983, 0.222969704226318, 0.1971035981559942, 0.3370545323977565, 0.2915631131514015, 0.2631696010212998, 0.28266814135970175, 0.2545950968525381, 0.23443404208008423, 0.27872565991797915, 0.29236532880326027, 0.2846885922197856, 0.2795686791733427, 0.22804063504413763, 0.19258150404602026, 0.23416578679225863, 0.20352583786546963, 0.20717979619202664, 0.17512893086659753, 0.22160308336762413, 0.22804313370465612, 0.21915684395892931, 0.18908813501361632, 0.17079934041368217, 0.17177489544080238, 0.17704592116144846, 0.18118821348623737, 0.17809420476787874, 0.17775590335163471, 0.206728362256554, 0.19042325886574185, 0.19072141796360798, 0.20708449878617063, 0.21776916142881442, 0.19864304601679117, 0.1784266230160374, 0.18479795624277462, 0.21614367460058825, 0.1847424949658062, 0.2039222438571181, 0.6394295150533678, 0.709437038437505, 0.7272318055454359, 0.5459823777417234, 0.1983296595458679, 0.4496339112997588, 0.25540549812494295, 0.29281538805566965, 0.7376930203897825, 0.5344888407338009, 0.20672273819014408, 0.20382124454786565, 0.48192720836055014, 0.34688484757813565, 0.4575825880974329, 0.20682700934964893, 0.20496293634642548, 0.6488622698891036, 0.18509977707364345, 0.191089084099894, 0.18985410408145043, 0.20991206604435897, 0.18978085941796408, 0.19381728563676692, 0.2088429573450009, 0.18922114346994845, 0.18003992478764397, 0.06385995992359572, 0.06776328975003743, 0.08246546412260414, 0.06396501809912802, 0.07245866633439724, 0.07308179633849543, 0.07386375926689548, 0.07343376732690299, 0.07683714007868037]}, "mutation_prompt": null}
{"id": "1f61ace2-b819-4f3e-92bb-f205463576f6", "solution": "import numpy as np\n\nclass EnhancedMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(60, self.budget // 8)  # Increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_min = 0.5  # Minimum differential weight\n        self.F_max = 0.9  # Maximum differential weight\n        self.CR = 0.8  # Crossover probability, slightly reduced to promote diversity\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                adaptive_F = self.F_min + np.random.rand() * (self.F_max - self.F_min)\n                mutant = np.clip(a + adaptive_F * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            best_fitness = fitness[best_index]\n            \n            local_search_radius = np.linspace(0.05, 0.1, num=10)  # Dynamic local search radius\n            for radius in local_search_radius:\n                if eval_count >= self.budget:\n                    break\n                local_neighbors = best_individual + np.random.uniform(-radius, radius, (5, self.dim))\n                local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n                local_fitness = np.array([func(ind) for ind in local_neighbors])\n                eval_count += len(local_neighbors)\n                \n                if np.min(local_fitness) < best_fitness:\n                    best_index = np.argmin(local_fitness)\n                    best_individual = local_neighbors[best_index]\n                    best_fitness = local_fitness[best_index]\n            \n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "EnhancedMemeticDifferentialEvolution", "description": "An enhanced memetic algorithm using adaptive differential weights and prioritized local refinement to accelerate convergence in diverse optimization landscapes.", "configspace": "", "generation": 7, "fitness": 0.24510322696414522, "feedback": "The algorithm EnhancedMemeticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.20.", "error": "", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.5693176785557392, 0.5264710563511804, 0.537830144110625, 0.5925169755890961, 0.5507044998283, 0.5695808034025049, 0.5763062844301816, 0.5533092973265414, 0.5727175194289607, 0.19007739587994965, 0.18579707209194374, 0.17866348059987125, 0.1569488878582752, 0.19302771971100807, 0.20791051758265966, 0.2015142113308338, 0.19666589604152152, 0.20371198508441846, 0.1416257686260628, 0.112414672338636, 0.10761836837862115, 0.09119851957689518, 0.09713944532543972, 0.10013997998922519, 0.10764015445599395, 0.11770472818430067, 0.15591832318245247, 0.09711872477048711, 0.11270543875379213, 0.11125367254422758, 0.11050687573849771, 0.10400561352898152, 0.09202967743555146, 0.09397963546758381, 0.09592462710577854, 0.11667484470566392, 0.9420831856794869, 0.9374608715217174, 0.9208828261924623, 0.9004101887076088, 0.9078234458125168, 0.9332846926380808, 0.8932019396446268, 0.9085193583470532, 0.9304601740011784, 0.3866315497593792, 0.33823642836456436, 0.3476770080230571, 0.3522876304805377, 0.37619238855247983, 0.36026913456304466, 0.3749511560599861, 0.3359723127477888, 0.3618885283827158, 0.26282132933931723, 0.3002037244456145, 0.27084798738526794, 0.27212397997208504, 0.31365594412023734, 0.29519909824216584, 0.5063618454850158, 0.41637843087640014, 0.28081076377428604, 0.21937833345684699, 0.15598644436389897, 0.2070937696180627, 0.20749285826956332, 0.18793105154649992, 0.15259172978643132, 0.20999620909688865, 0.18554950106115498, 0.20691259270288898, 0.15943658089857604, 0.20740552880583574, 0.19248714782756393, 0.18976791048858466, 0.13798745649276445, 0.1889531343138412, 0.14154621890521357, 0.17374348252029936, 0.1510704966835834, 0.021151017913086934, 0.03837429529983272, 0.012114685794526125, 0.04280420635554749, 0.02373827871521139, 0.0015877155753488692, 0.01012702554838596, 0.06400535313302957, 0.015585312177123, 0.12420405282674851, 0.1256926063366931, 0.11643461379674647, 0.0944404157822677, 0.09522236990750588, 0.1002954021465523, 0.13301689145874895, 0.11890890726870507, 0.11567391020933337, 9.999999999998899e-05, 9.999999999998899e-05, 0.05434973858728975, 9.999999999998899e-05, 0.02442889878960597, 9.999999999998899e-05, 0.0254684301228304, 0.009696640201937723, 9.999999999998899e-05, 0.16202996752889554, 0.12432033018266664, 0.14342616049142887, 0.14686689936056951, 0.09363319220894517, 0.11487887274194164, 0.13978096884249624, 0.1184457686060939, 0.1162818345004607, 0.4682266523627645, 0.48394980652698505, 0.4715132362073864, 0.47439497003113074, 0.4720930940072289, 0.48284936184478333, 0.4845359337889972, 0.4403863480740001, 0.4865881436544027, 0.11300122194463114, 0.11556888077854888, 0.09816053748335596, 0.10658720457277582, 0.11274570870155098, 0.09675836209588884, 0.1133228755823511, 0.14521026880859167, 0.08521610175189342, 0.20928066234368092, 0.16701151221644994, 0.20952276756311528, 0.2033930877266784, 0.17706416902973998, 0.1847182621822563, 0.2499175836105595, 0.2059645707417067, 0.24279408482270715, 0.2501867123917183, 0.3157579109284847, 0.2532928702917705, 0.23430535569179844, 0.23853886682070646, 0.2494545919309984, 0.2632272029657181, 0.2878953483034168, 0.2677442893565849, 0.19948246866278985, 0.19587799668233796, 0.22725966001506737, 0.21161405103540087, 0.1495742242395912, 0.1926260265786296, 0.18559631284352407, 0.18981313443285597, 0.18969327927669455, 0.2073168040114136, 0.17680931946798573, 0.1751985921280137, 0.21479320327144613, 0.1788056999045582, 0.20411635933813355, 0.18140471853067197, 0.21258205169062216, 0.1761491802722034, 0.2242950915523395, 0.18417332164170253, 0.21326909161261065, 0.2099757497408392, 0.18688897969588325, 0.17892743255492882, 0.17963884449565903, 0.2088088420437182, 0.255048442476843, 0.26477484900551396, 0.4544809406382191, 0.43229877449725096, 0.8314615184090552, 0.20286673823651646, 0.1672906211652766, 0.17436992195326695, 0.4024097695312462, 0.20837355004560176, 0.7118141843492454, 0.21280683362359043, 0.20744815148613238, 0.21112837115499705, 0.4943181585460129, 0.5695295497933344, 0.20066456545581446, 0.7234756624940004, 0.21149562716721493, 0.1909622147044212, 0.20226420106414777, 0.19331062717289182, 0.19736170321421576, 0.21648907857457156, 0.19750352717330288, 0.18690429327995883, 0.18162163613762616, 0.187827945469075, 0.13659170430137457, 0.08024895851712244, 0.0698334415170373, 0.09513490544639058, 0.07381097881923093, 0.08455755910749907, 0.0823445150061276, 0.07393907074102302, 0.08154381344570993]}, "mutation_prompt": null}
{"id": "647904ba-776b-4caa-acfe-8f03eb0d26ca", "solution": "import numpy as np\n\nclass MemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Local search on best individual\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            best_fitness = fitness[best_index]\n            \n            # Perform a simple random neighborhood search around the best individual\n            local_neighbors = best_individual + np.random.uniform(-0.1, 0.1, (10, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n            \n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_index]\n                best_fitness = local_fitness[best_index]\n                \n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "MemeticDifferentialEvolution", "description": "A memetic algorithm combining differential evolution and local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.5836225311948049, 0.5895675481708798, 0.5931935339412369, 0.6092798817755256, 0.5971191751395089, 0.6202579917834308, 0.5915666641654593, 0.6329231146089245, 0.614496547496218, 0.3269420225697043, 0.32341007556044665, 0.3067393591575437, 0.33025145964783187, 0.3164549216374125, 0.31410736857977894, 0.3034373833378351, 0.32458656142264397, 0.32448189010106865, 0.0932342943891219, 0.14210171319527398, 0.12124651238007733, 0.1117186560595137, 0.10416462667954152, 0.13469583922195927, 0.10778599739147499, 0.10180983716471348, 0.11519071115675017, 0.09089923321281623, 0.07916223832856029, 0.09650580656142027, 0.10828047219810033, 0.09519688902934909, 0.11137299647643428, 0.11246531376395619, 0.12295482105811084, 0.09031900319661212, 0.9570017798820938, 0.9513292557106726, 0.9261189549404044, 0.932623940991951, 0.9277210170918078, 0.9656618317581583, 0.9643447913571865, 0.9721847342834466, 0.953476269027666, 0.29421687546028763, 0.31172891459799634, 0.28049672705086315, 0.28360228842594426, 0.29617362506457234, 0.31417605357685474, 0.3030308170377122, 0.2945013636010071, 0.31683005641423334, 0.5179901746271818, 0.4967938945250143, 0.3992218655444725, 0.6421024689794905, 0.4829996488068862, 0.5444143981709784, 0.818801602910831, 0.4169046635013345, 0.5667733833019734, 0.1729377314210867, 0.19408614048524442, 0.2189357195687498, 0.17003335976335543, 0.1734456129185239, 0.22317341038415006, 0.16815520346172597, 0.23471455937223595, 0.18005566062328848, 0.17128012630579414, 0.22078714561119273, 0.18985238237062607, 0.17887929005036718, 0.14169377179786802, 0.17179544957294768, 0.1912676319700436, 0.19817619522267937, 0.1992738826984083, 0.12609625599841567, 0.0884125386662783, 0.07419627554103048, 0.12689456376567354, 0.09695846887388382, 0.10487159974444749, 0.0874590757433692, 0.10069088517058722, 0.08757007935442673, 0.24629823159854047, 0.23721672551643924, 0.1937924518431159, 0.2360613318904099, 0.2283277969657893, 0.21070951185422226, 0.24376182655715817, 0.2505002143128586, 0.24655490215416498, 0.008900204497490405, 0.029919102645743822, 0.0025024944447568087, 0.0084676904081743, 0.012605954307217115, 0.02776100803567294, 0.025295612550901736, 0.023065392675113428, 0.023991856805336775, 0.14806031195500602, 0.16610838876205658, 0.14065028111594324, 0.15394747464367609, 0.14242247562505017, 0.1641355696142669, 0.13765768978862902, 0.14788652466503827, 0.14584253302347738, 0.47246127760880385, 0.468467834239634, 0.488651401632924, 0.46925752632019735, 0.47998205454430665, 0.4819209969882894, 0.48289905070808636, 0.478057701671476, 0.46432681688452015, 0.11941284027623278, 0.0970678050806677, 0.12705107697367768, 0.10342182382932241, 0.10174470673056091, 0.11317706319574627, 0.14065440601023493, 0.09688588256048702, 0.12232279486506359, 0.20147186942807993, 0.22762076159867817, 0.19167359996581346, 0.20502140494458854, 0.3240914377838958, 0.15302899385411983, 0.222969704226318, 0.1971035981559942, 0.3370545323977565, 0.2915631131514015, 0.2631696010212998, 0.28266814135970175, 0.2545950968525381, 0.23443404208008423, 0.27872565991797915, 0.29236532880326027, 0.2846885922197856, 0.2795686791733427, 0.22804063504413763, 0.19258150404602026, 0.23416578679225863, 0.20352583786546963, 0.20717979619202664, 0.17512893086659753, 0.22160308336762413, 0.22804313370465612, 0.21915684395892931, 0.18908813501361632, 0.17079934041368217, 0.17177489544080238, 0.17704592116144846, 0.18118821348623737, 0.17809420476787874, 0.17775590335163471, 0.206728362256554, 0.19042325886574185, 0.19072141796360798, 0.20708449878617063, 0.21776916142881442, 0.19864304601679117, 0.1784266230160374, 0.18479795624277462, 0.21614367460058825, 0.1847424949658062, 0.2039222438571181, 0.6394295150533678, 0.709437038437505, 0.7272318055454359, 0.5459823777417234, 0.1983296595458679, 0.4496339112997588, 0.25540549812494295, 0.29281538805566965, 0.7376930203897825, 0.5344888407338009, 0.20672273819014408, 0.20382124454786565, 0.48192720836055014, 0.34688484757813565, 0.4575825880974329, 0.20682700934964893, 0.20496293634642548, 0.6488622698891036, 0.18509977707364345, 0.191089084099894, 0.18985410408145043, 0.20991206604435897, 0.18978085941796408, 0.19381728563676692, 0.2088429573450009, 0.18922114346994845, 0.18003992478764397, 0.06385995992359572, 0.06776328975003743, 0.08246546412260414, 0.06396501809912802, 0.07245866633439724, 0.07308179633849543, 0.07386375926689548, 0.07343376732690299, 0.07683714007868037]}, "mutation_prompt": null}
{"id": "76de3717-4103-4a57-bf0c-380b90a8b01a", "solution": "import numpy as np\n\nclass MemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Local search on best individual\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            best_fitness = fitness[best_index]\n            \n            # Perform a simple random neighborhood search around the best individual\n            local_neighbors = best_individual + np.random.uniform(-0.1, 0.1, (10, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n            \n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_index]\n                best_fitness = local_fitness[best_index]\n                \n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "MemeticDifferentialEvolution", "description": "A memetic algorithm combining differential evolution and local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.5836225311948049, 0.5895675481708798, 0.5931935339412369, 0.6092798817755256, 0.5971191751395089, 0.6202579917834308, 0.5915666641654593, 0.6329231146089245, 0.614496547496218, 0.3269420225697043, 0.32341007556044665, 0.3067393591575437, 0.33025145964783187, 0.3164549216374125, 0.31410736857977894, 0.3034373833378351, 0.32458656142264397, 0.32448189010106865, 0.0932342943891219, 0.14210171319527398, 0.12124651238007733, 0.1117186560595137, 0.10416462667954152, 0.13469583922195927, 0.10778599739147499, 0.10180983716471348, 0.11519071115675017, 0.09089923321281623, 0.07916223832856029, 0.09650580656142027, 0.10828047219810033, 0.09519688902934909, 0.11137299647643428, 0.11246531376395619, 0.12295482105811084, 0.09031900319661212, 0.9570017798820938, 0.9513292557106726, 0.9261189549404044, 0.932623940991951, 0.9277210170918078, 0.9656618317581583, 0.9643447913571865, 0.9721847342834466, 0.953476269027666, 0.29421687546028763, 0.31172891459799634, 0.28049672705086315, 0.28360228842594426, 0.29617362506457234, 0.31417605357685474, 0.3030308170377122, 0.2945013636010071, 0.31683005641423334, 0.5179901746271818, 0.4967938945250143, 0.3992218655444725, 0.6421024689794905, 0.4829996488068862, 0.5444143981709784, 0.818801602910831, 0.4169046635013345, 0.5667733833019734, 0.1729377314210867, 0.19408614048524442, 0.2189357195687498, 0.17003335976335543, 0.1734456129185239, 0.22317341038415006, 0.16815520346172597, 0.23471455937223595, 0.18005566062328848, 0.17128012630579414, 0.22078714561119273, 0.18985238237062607, 0.17887929005036718, 0.14169377179786802, 0.17179544957294768, 0.1912676319700436, 0.19817619522267937, 0.1992738826984083, 0.12609625599841567, 0.0884125386662783, 0.07419627554103048, 0.12689456376567354, 0.09695846887388382, 0.10487159974444749, 0.0874590757433692, 0.10069088517058722, 0.08757007935442673, 0.24629823159854047, 0.23721672551643924, 0.1937924518431159, 0.2360613318904099, 0.2283277969657893, 0.21070951185422226, 0.24376182655715817, 0.2505002143128586, 0.24655490215416498, 0.008900204497490405, 0.029919102645743822, 0.0025024944447568087, 0.0084676904081743, 0.012605954307217115, 0.02776100803567294, 0.025295612550901736, 0.023065392675113428, 0.023991856805336775, 0.14806031195500602, 0.16610838876205658, 0.14065028111594324, 0.15394747464367609, 0.14242247562505017, 0.1641355696142669, 0.13765768978862902, 0.14788652466503827, 0.14584253302347738, 0.47246127760880385, 0.468467834239634, 0.488651401632924, 0.46925752632019735, 0.47998205454430665, 0.4819209969882894, 0.48289905070808636, 0.478057701671476, 0.46432681688452015, 0.11941284027623278, 0.0970678050806677, 0.12705107697367768, 0.10342182382932241, 0.10174470673056091, 0.11317706319574627, 0.14065440601023493, 0.09688588256048702, 0.12232279486506359, 0.20147186942807993, 0.22762076159867817, 0.19167359996581346, 0.20502140494458854, 0.3240914377838958, 0.15302899385411983, 0.222969704226318, 0.1971035981559942, 0.3370545323977565, 0.2915631131514015, 0.2631696010212998, 0.28266814135970175, 0.2545950968525381, 0.23443404208008423, 0.27872565991797915, 0.29236532880326027, 0.2846885922197856, 0.2795686791733427, 0.22804063504413763, 0.19258150404602026, 0.23416578679225863, 0.20352583786546963, 0.20717979619202664, 0.17512893086659753, 0.22160308336762413, 0.22804313370465612, 0.21915684395892931, 0.18908813501361632, 0.17079934041368217, 0.17177489544080238, 0.17704592116144846, 0.18118821348623737, 0.17809420476787874, 0.17775590335163471, 0.206728362256554, 0.19042325886574185, 0.19072141796360798, 0.20708449878617063, 0.21776916142881442, 0.19864304601679117, 0.1784266230160374, 0.18479795624277462, 0.21614367460058825, 0.1847424949658062, 0.2039222438571181, 0.6394295150533678, 0.709437038437505, 0.7272318055454359, 0.5459823777417234, 0.1983296595458679, 0.4496339112997588, 0.25540549812494295, 0.29281538805566965, 0.7376930203897825, 0.5344888407338009, 0.20672273819014408, 0.20382124454786565, 0.48192720836055014, 0.34688484757813565, 0.4575825880974329, 0.20682700934964893, 0.20496293634642548, 0.6488622698891036, 0.18509977707364345, 0.191089084099894, 0.18985410408145043, 0.20991206604435897, 0.18978085941796408, 0.19381728563676692, 0.2088429573450009, 0.18922114346994845, 0.18003992478764397, 0.06385995992359572, 0.06776328975003743, 0.08246546412260414, 0.06396501809912802, 0.07245866633439724, 0.07308179633849543, 0.07386375926689548, 0.07343376732690299, 0.07683714007868037]}, "mutation_prompt": null}
{"id": "a0420ce5-3c23-4357-9ef6-9ee29807a2c6", "solution": "import numpy as np\n\nclass MemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Local search on best individual\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            best_fitness = fitness[best_index]\n            \n            # Perform a simple random neighborhood search around the best individual\n            local_neighbors = best_individual + np.random.uniform(-0.1, 0.1, (10, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n            \n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_index]\n                best_fitness = local_fitness[best_index]\n                \n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "MemeticDifferentialEvolution", "description": "A memetic algorithm combining differential evolution and local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.5836225311948049, 0.5895675481708798, 0.5931935339412369, 0.6092798817755256, 0.5971191751395089, 0.6202579917834308, 0.5915666641654593, 0.6329231146089245, 0.614496547496218, 0.3269420225697043, 0.32341007556044665, 0.3067393591575437, 0.33025145964783187, 0.3164549216374125, 0.31410736857977894, 0.3034373833378351, 0.32458656142264397, 0.32448189010106865, 0.0932342943891219, 0.14210171319527398, 0.12124651238007733, 0.1117186560595137, 0.10416462667954152, 0.13469583922195927, 0.10778599739147499, 0.10180983716471348, 0.11519071115675017, 0.09089923321281623, 0.07916223832856029, 0.09650580656142027, 0.10828047219810033, 0.09519688902934909, 0.11137299647643428, 0.11246531376395619, 0.12295482105811084, 0.09031900319661212, 0.9570017798820938, 0.9513292557106726, 0.9261189549404044, 0.932623940991951, 0.9277210170918078, 0.9656618317581583, 0.9643447913571865, 0.9721847342834466, 0.953476269027666, 0.29421687546028763, 0.31172891459799634, 0.28049672705086315, 0.28360228842594426, 0.29617362506457234, 0.31417605357685474, 0.3030308170377122, 0.2945013636010071, 0.31683005641423334, 0.5179901746271818, 0.4967938945250143, 0.3992218655444725, 0.6421024689794905, 0.4829996488068862, 0.5444143981709784, 0.818801602910831, 0.4169046635013345, 0.5667733833019734, 0.1729377314210867, 0.19408614048524442, 0.2189357195687498, 0.17003335976335543, 0.1734456129185239, 0.22317341038415006, 0.16815520346172597, 0.23471455937223595, 0.18005566062328848, 0.17128012630579414, 0.22078714561119273, 0.18985238237062607, 0.17887929005036718, 0.14169377179786802, 0.17179544957294768, 0.1912676319700436, 0.19817619522267937, 0.1992738826984083, 0.12609625599841567, 0.0884125386662783, 0.07419627554103048, 0.12689456376567354, 0.09695846887388382, 0.10487159974444749, 0.0874590757433692, 0.10069088517058722, 0.08757007935442673, 0.24629823159854047, 0.23721672551643924, 0.1937924518431159, 0.2360613318904099, 0.2283277969657893, 0.21070951185422226, 0.24376182655715817, 0.2505002143128586, 0.24655490215416498, 0.008900204497490405, 0.029919102645743822, 0.0025024944447568087, 0.0084676904081743, 0.012605954307217115, 0.02776100803567294, 0.025295612550901736, 0.023065392675113428, 0.023991856805336775, 0.14806031195500602, 0.16610838876205658, 0.14065028111594324, 0.15394747464367609, 0.14242247562505017, 0.1641355696142669, 0.13765768978862902, 0.14788652466503827, 0.14584253302347738, 0.47246127760880385, 0.468467834239634, 0.488651401632924, 0.46925752632019735, 0.47998205454430665, 0.4819209969882894, 0.48289905070808636, 0.478057701671476, 0.46432681688452015, 0.11941284027623278, 0.0970678050806677, 0.12705107697367768, 0.10342182382932241, 0.10174470673056091, 0.11317706319574627, 0.14065440601023493, 0.09688588256048702, 0.12232279486506359, 0.20147186942807993, 0.22762076159867817, 0.19167359996581346, 0.20502140494458854, 0.3240914377838958, 0.15302899385411983, 0.222969704226318, 0.1971035981559942, 0.3370545323977565, 0.2915631131514015, 0.2631696010212998, 0.28266814135970175, 0.2545950968525381, 0.23443404208008423, 0.27872565991797915, 0.29236532880326027, 0.2846885922197856, 0.2795686791733427, 0.22804063504413763, 0.19258150404602026, 0.23416578679225863, 0.20352583786546963, 0.20717979619202664, 0.17512893086659753, 0.22160308336762413, 0.22804313370465612, 0.21915684395892931, 0.18908813501361632, 0.17079934041368217, 0.17177489544080238, 0.17704592116144846, 0.18118821348623737, 0.17809420476787874, 0.17775590335163471, 0.206728362256554, 0.19042325886574185, 0.19072141796360798, 0.20708449878617063, 0.21776916142881442, 0.19864304601679117, 0.1784266230160374, 0.18479795624277462, 0.21614367460058825, 0.1847424949658062, 0.2039222438571181, 0.6394295150533678, 0.709437038437505, 0.7272318055454359, 0.5459823777417234, 0.1983296595458679, 0.4496339112997588, 0.25540549812494295, 0.29281538805566965, 0.7376930203897825, 0.5344888407338009, 0.20672273819014408, 0.20382124454786565, 0.48192720836055014, 0.34688484757813565, 0.4575825880974329, 0.20682700934964893, 0.20496293634642548, 0.6488622698891036, 0.18509977707364345, 0.191089084099894, 0.18985410408145043, 0.20991206604435897, 0.18978085941796408, 0.19381728563676692, 0.2088429573450009, 0.18922114346994845, 0.18003992478764397, 0.06385995992359572, 0.06776328975003743, 0.08246546412260414, 0.06396501809912802, 0.07245866633439724, 0.07308179633849543, 0.07386375926689548, 0.07343376732690299, 0.07683714007868037]}, "mutation_prompt": null}
{"id": "fdb55f5d-d9c1-458a-b5d3-6c3686fcde4f", "solution": "import numpy as np\n\nclass MemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Local search on best individual\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            best_fitness = fitness[best_index]\n            \n            # Perform a simple random neighborhood search around the best individual\n            local_neighbors = best_individual + np.random.uniform(-0.1, 0.1, (10, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n            \n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_index]\n                best_fitness = local_fitness[best_index]\n                \n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "MemeticDifferentialEvolution", "description": "A memetic algorithm combining differential evolution and local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.5836225311948049, 0.5895675481708798, 0.5931935339412369, 0.6092798817755256, 0.5971191751395089, 0.6202579917834308, 0.5915666641654593, 0.6329231146089245, 0.614496547496218, 0.3269420225697043, 0.32341007556044665, 0.3067393591575437, 0.33025145964783187, 0.3164549216374125, 0.31410736857977894, 0.3034373833378351, 0.32458656142264397, 0.32448189010106865, 0.0932342943891219, 0.14210171319527398, 0.12124651238007733, 0.1117186560595137, 0.10416462667954152, 0.13469583922195927, 0.10778599739147499, 0.10180983716471348, 0.11519071115675017, 0.09089923321281623, 0.07916223832856029, 0.09650580656142027, 0.10828047219810033, 0.09519688902934909, 0.11137299647643428, 0.11246531376395619, 0.12295482105811084, 0.09031900319661212, 0.9570017798820938, 0.9513292557106726, 0.9261189549404044, 0.932623940991951, 0.9277210170918078, 0.9656618317581583, 0.9643447913571865, 0.9721847342834466, 0.953476269027666, 0.29421687546028763, 0.31172891459799634, 0.28049672705086315, 0.28360228842594426, 0.29617362506457234, 0.31417605357685474, 0.3030308170377122, 0.2945013636010071, 0.31683005641423334, 0.5179901746271818, 0.4967938945250143, 0.3992218655444725, 0.6421024689794905, 0.4829996488068862, 0.5444143981709784, 0.818801602910831, 0.4169046635013345, 0.5667733833019734, 0.1729377314210867, 0.19408614048524442, 0.2189357195687498, 0.17003335976335543, 0.1734456129185239, 0.22317341038415006, 0.16815520346172597, 0.23471455937223595, 0.18005566062328848, 0.17128012630579414, 0.22078714561119273, 0.18985238237062607, 0.17887929005036718, 0.14169377179786802, 0.17179544957294768, 0.1912676319700436, 0.19817619522267937, 0.1992738826984083, 0.12609625599841567, 0.0884125386662783, 0.07419627554103048, 0.12689456376567354, 0.09695846887388382, 0.10487159974444749, 0.0874590757433692, 0.10069088517058722, 0.08757007935442673, 0.24629823159854047, 0.23721672551643924, 0.1937924518431159, 0.2360613318904099, 0.2283277969657893, 0.21070951185422226, 0.24376182655715817, 0.2505002143128586, 0.24655490215416498, 0.008900204497490405, 0.029919102645743822, 0.0025024944447568087, 0.0084676904081743, 0.012605954307217115, 0.02776100803567294, 0.025295612550901736, 0.023065392675113428, 0.023991856805336775, 0.14806031195500602, 0.16610838876205658, 0.14065028111594324, 0.15394747464367609, 0.14242247562505017, 0.1641355696142669, 0.13765768978862902, 0.14788652466503827, 0.14584253302347738, 0.47246127760880385, 0.468467834239634, 0.488651401632924, 0.46925752632019735, 0.47998205454430665, 0.4819209969882894, 0.48289905070808636, 0.478057701671476, 0.46432681688452015, 0.11941284027623278, 0.0970678050806677, 0.12705107697367768, 0.10342182382932241, 0.10174470673056091, 0.11317706319574627, 0.14065440601023493, 0.09688588256048702, 0.12232279486506359, 0.20147186942807993, 0.22762076159867817, 0.19167359996581346, 0.20502140494458854, 0.3240914377838958, 0.15302899385411983, 0.222969704226318, 0.1971035981559942, 0.3370545323977565, 0.2915631131514015, 0.2631696010212998, 0.28266814135970175, 0.2545950968525381, 0.23443404208008423, 0.27872565991797915, 0.29236532880326027, 0.2846885922197856, 0.2795686791733427, 0.22804063504413763, 0.19258150404602026, 0.23416578679225863, 0.20352583786546963, 0.20717979619202664, 0.17512893086659753, 0.22160308336762413, 0.22804313370465612, 0.21915684395892931, 0.18908813501361632, 0.17079934041368217, 0.17177489544080238, 0.17704592116144846, 0.18118821348623737, 0.17809420476787874, 0.17775590335163471, 0.206728362256554, 0.19042325886574185, 0.19072141796360798, 0.20708449878617063, 0.21776916142881442, 0.19864304601679117, 0.1784266230160374, 0.18479795624277462, 0.21614367460058825, 0.1847424949658062, 0.2039222438571181, 0.6394295150533678, 0.709437038437505, 0.7272318055454359, 0.5459823777417234, 0.1983296595458679, 0.4496339112997588, 0.25540549812494295, 0.29281538805566965, 0.7376930203897825, 0.5344888407338009, 0.20672273819014408, 0.20382124454786565, 0.48192720836055014, 0.34688484757813565, 0.4575825880974329, 0.20682700934964893, 0.20496293634642548, 0.6488622698891036, 0.18509977707364345, 0.191089084099894, 0.18985410408145043, 0.20991206604435897, 0.18978085941796408, 0.19381728563676692, 0.2088429573450009, 0.18922114346994845, 0.18003992478764397, 0.06385995992359572, 0.06776328975003743, 0.08246546412260414, 0.06396501809912802, 0.07245866633439724, 0.07308179633849543, 0.07386375926689548, 0.07343376732690299, 0.07683714007868037]}, "mutation_prompt": null}
{"id": "a779eca0-da12-4c6b-bbae-0f7a07e60063", "solution": "import numpy as np\n\nclass MemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Local search on best individual\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            best_fitness = fitness[best_index]\n            \n            # Perform a simple random neighborhood search around the best individual\n            local_neighbors = best_individual + np.random.uniform(-0.1, 0.1, (10, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n            \n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_index]\n                best_fitness = local_fitness[best_index]\n                \n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "MemeticDifferentialEvolution", "description": "A memetic algorithm combining differential evolution and local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.5836225311948049, 0.5895675481708798, 0.5931935339412369, 0.6092798817755256, 0.5971191751395089, 0.6202579917834308, 0.5915666641654593, 0.6329231146089245, 0.614496547496218, 0.3269420225697043, 0.32341007556044665, 0.3067393591575437, 0.33025145964783187, 0.3164549216374125, 0.31410736857977894, 0.3034373833378351, 0.32458656142264397, 0.32448189010106865, 0.0932342943891219, 0.14210171319527398, 0.12124651238007733, 0.1117186560595137, 0.10416462667954152, 0.13469583922195927, 0.10778599739147499, 0.10180983716471348, 0.11519071115675017, 0.09089923321281623, 0.07916223832856029, 0.09650580656142027, 0.10828047219810033, 0.09519688902934909, 0.11137299647643428, 0.11246531376395619, 0.12295482105811084, 0.09031900319661212, 0.9570017798820938, 0.9513292557106726, 0.9261189549404044, 0.932623940991951, 0.9277210170918078, 0.9656618317581583, 0.9643447913571865, 0.9721847342834466, 0.953476269027666, 0.29421687546028763, 0.31172891459799634, 0.28049672705086315, 0.28360228842594426, 0.29617362506457234, 0.31417605357685474, 0.3030308170377122, 0.2945013636010071, 0.31683005641423334, 0.5179901746271818, 0.4967938945250143, 0.3992218655444725, 0.6421024689794905, 0.4829996488068862, 0.5444143981709784, 0.818801602910831, 0.4169046635013345, 0.5667733833019734, 0.1729377314210867, 0.19408614048524442, 0.2189357195687498, 0.17003335976335543, 0.1734456129185239, 0.22317341038415006, 0.16815520346172597, 0.23471455937223595, 0.18005566062328848, 0.17128012630579414, 0.22078714561119273, 0.18985238237062607, 0.17887929005036718, 0.14169377179786802, 0.17179544957294768, 0.1912676319700436, 0.19817619522267937, 0.1992738826984083, 0.12609625599841567, 0.0884125386662783, 0.07419627554103048, 0.12689456376567354, 0.09695846887388382, 0.10487159974444749, 0.0874590757433692, 0.10069088517058722, 0.08757007935442673, 0.24629823159854047, 0.23721672551643924, 0.1937924518431159, 0.2360613318904099, 0.2283277969657893, 0.21070951185422226, 0.24376182655715817, 0.2505002143128586, 0.24655490215416498, 0.008900204497490405, 0.029919102645743822, 0.0025024944447568087, 0.0084676904081743, 0.012605954307217115, 0.02776100803567294, 0.025295612550901736, 0.023065392675113428, 0.023991856805336775, 0.14806031195500602, 0.16610838876205658, 0.14065028111594324, 0.15394747464367609, 0.14242247562505017, 0.1641355696142669, 0.13765768978862902, 0.14788652466503827, 0.14584253302347738, 0.47246127760880385, 0.468467834239634, 0.488651401632924, 0.46925752632019735, 0.47998205454430665, 0.4819209969882894, 0.48289905070808636, 0.478057701671476, 0.46432681688452015, 0.11941284027623278, 0.0970678050806677, 0.12705107697367768, 0.10342182382932241, 0.10174470673056091, 0.11317706319574627, 0.14065440601023493, 0.09688588256048702, 0.12232279486506359, 0.20147186942807993, 0.22762076159867817, 0.19167359996581346, 0.20502140494458854, 0.3240914377838958, 0.15302899385411983, 0.222969704226318, 0.1971035981559942, 0.3370545323977565, 0.2915631131514015, 0.2631696010212998, 0.28266814135970175, 0.2545950968525381, 0.23443404208008423, 0.27872565991797915, 0.29236532880326027, 0.2846885922197856, 0.2795686791733427, 0.22804063504413763, 0.19258150404602026, 0.23416578679225863, 0.20352583786546963, 0.20717979619202664, 0.17512893086659753, 0.22160308336762413, 0.22804313370465612, 0.21915684395892931, 0.18908813501361632, 0.17079934041368217, 0.17177489544080238, 0.17704592116144846, 0.18118821348623737, 0.17809420476787874, 0.17775590335163471, 0.206728362256554, 0.19042325886574185, 0.19072141796360798, 0.20708449878617063, 0.21776916142881442, 0.19864304601679117, 0.1784266230160374, 0.18479795624277462, 0.21614367460058825, 0.1847424949658062, 0.2039222438571181, 0.6394295150533678, 0.709437038437505, 0.7272318055454359, 0.5459823777417234, 0.1983296595458679, 0.4496339112997588, 0.25540549812494295, 0.29281538805566965, 0.7376930203897825, 0.5344888407338009, 0.20672273819014408, 0.20382124454786565, 0.48192720836055014, 0.34688484757813565, 0.4575825880974329, 0.20682700934964893, 0.20496293634642548, 0.6488622698891036, 0.18509977707364345, 0.191089084099894, 0.18985410408145043, 0.20991206604435897, 0.18978085941796408, 0.19381728563676692, 0.2088429573450009, 0.18922114346994845, 0.18003992478764397, 0.06385995992359572, 0.06776328975003743, 0.08246546412260414, 0.06396501809912802, 0.07245866633439724, 0.07308179633849543, 0.07386375926689548, 0.07343376732690299, 0.07683714007868037]}, "mutation_prompt": null}
{"id": "feadac80-68af-4aeb-bdfb-347a787971b5", "solution": "import numpy as np\n\nclass EnhancedMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_F = 0.8  # Initial differential weight\n        self.initial_CR = 0.9  # Initial crossover probability\n        self.epsilon = 1e-8  # Small value to prevent division by zero\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        F = self.initial_F\n        CR = self.initial_CR\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Adaptive mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant_vector = a + F * (b - c)\n                mutant = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                \n                trial_vector = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Adaptive parameters update\n            F = 0.5 + 0.3 * np.tanh(eval_count / self.budget)\n            CR = 0.5 + 0.4 * np.tanh(eval_count / self.budget)\n\n            # Dynamic population adjustment based on diversity\n            diversity = np.std(fitness) / (np.mean(fitness) + self.epsilon)\n            if diversity < 0.05 and self.population_size > 5:\n                self.population_size = max(5, self.population_size - 1)\n            elif diversity > 0.1 and self.population_size < min(50, self.budget // 10):\n                self.population_size += 1\n            \n            # Local search on best individual\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            best_fitness = fitness[best_index]\n            \n            # Perform an enhanced local search\n            local_neighbors = best_individual + np.random.uniform(-0.1, 0.1, (min(10, self.budget - eval_count), self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n            \n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_index]\n                best_fitness = local_fitness[best_index]\n                \n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "EnhancedMemeticDifferentialEvolution", "description": "An enhanced memetic differential evolution algorithm with adaptive strategy parameters and dynamic population size adjustment for improved convergence speed.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('zero-size array to reduction operation minimum which has no identity').", "error": "ValueError('zero-size array to reduction operation minimum which has no identity')", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {}, "mutation_prompt": null}
{"id": "b4812f0c-dc7c-4ad2-872e-2aed944eca44", "solution": "import numpy as np\n\nclass MemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Local search on best individual\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            best_fitness = fitness[best_index]\n            \n            # Perform a simple random neighborhood search around the best individual\n            local_neighbors = best_individual + np.random.uniform(-0.1, 0.1, (10, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n            \n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_index]\n                best_fitness = local_fitness[best_index]\n                \n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "MemeticDifferentialEvolution", "description": "A memetic algorithm combining differential evolution and local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.5836225311948049, 0.5895675481708798, 0.5931935339412369, 0.6092798817755256, 0.5971191751395089, 0.6202579917834308, 0.5915666641654593, 0.6329231146089245, 0.614496547496218, 0.3269420225697043, 0.32341007556044665, 0.3067393591575437, 0.33025145964783187, 0.3164549216374125, 0.31410736857977894, 0.3034373833378351, 0.32458656142264397, 0.32448189010106865, 0.0932342943891219, 0.14210171319527398, 0.12124651238007733, 0.1117186560595137, 0.10416462667954152, 0.13469583922195927, 0.10778599739147499, 0.10180983716471348, 0.11519071115675017, 0.09089923321281623, 0.07916223832856029, 0.09650580656142027, 0.10828047219810033, 0.09519688902934909, 0.11137299647643428, 0.11246531376395619, 0.12295482105811084, 0.09031900319661212, 0.9570017798820938, 0.9513292557106726, 0.9261189549404044, 0.932623940991951, 0.9277210170918078, 0.9656618317581583, 0.9643447913571865, 0.9721847342834466, 0.953476269027666, 0.29421687546028763, 0.31172891459799634, 0.28049672705086315, 0.28360228842594426, 0.29617362506457234, 0.31417605357685474, 0.3030308170377122, 0.2945013636010071, 0.31683005641423334, 0.5179901746271818, 0.4967938945250143, 0.3992218655444725, 0.6421024689794905, 0.4829996488068862, 0.5444143981709784, 0.818801602910831, 0.4169046635013345, 0.5667733833019734, 0.1729377314210867, 0.19408614048524442, 0.2189357195687498, 0.17003335976335543, 0.1734456129185239, 0.22317341038415006, 0.16815520346172597, 0.23471455937223595, 0.18005566062328848, 0.17128012630579414, 0.22078714561119273, 0.18985238237062607, 0.17887929005036718, 0.14169377179786802, 0.17179544957294768, 0.1912676319700436, 0.19817619522267937, 0.1992738826984083, 0.12609625599841567, 0.0884125386662783, 0.07419627554103048, 0.12689456376567354, 0.09695846887388382, 0.10487159974444749, 0.0874590757433692, 0.10069088517058722, 0.08757007935442673, 0.24629823159854047, 0.23721672551643924, 0.1937924518431159, 0.2360613318904099, 0.2283277969657893, 0.21070951185422226, 0.24376182655715817, 0.2505002143128586, 0.24655490215416498, 0.008900204497490405, 0.029919102645743822, 0.0025024944447568087, 0.0084676904081743, 0.012605954307217115, 0.02776100803567294, 0.025295612550901736, 0.023065392675113428, 0.023991856805336775, 0.14806031195500602, 0.16610838876205658, 0.14065028111594324, 0.15394747464367609, 0.14242247562505017, 0.1641355696142669, 0.13765768978862902, 0.14788652466503827, 0.14584253302347738, 0.47246127760880385, 0.468467834239634, 0.488651401632924, 0.46925752632019735, 0.47998205454430665, 0.4819209969882894, 0.48289905070808636, 0.478057701671476, 0.46432681688452015, 0.11941284027623278, 0.0970678050806677, 0.12705107697367768, 0.10342182382932241, 0.10174470673056091, 0.11317706319574627, 0.14065440601023493, 0.09688588256048702, 0.12232279486506359, 0.20147186942807993, 0.22762076159867817, 0.19167359996581346, 0.20502140494458854, 0.3240914377838958, 0.15302899385411983, 0.222969704226318, 0.1971035981559942, 0.3370545323977565, 0.2915631131514015, 0.2631696010212998, 0.28266814135970175, 0.2545950968525381, 0.23443404208008423, 0.27872565991797915, 0.29236532880326027, 0.2846885922197856, 0.2795686791733427, 0.22804063504413763, 0.19258150404602026, 0.23416578679225863, 0.20352583786546963, 0.20717979619202664, 0.17512893086659753, 0.22160308336762413, 0.22804313370465612, 0.21915684395892931, 0.18908813501361632, 0.17079934041368217, 0.17177489544080238, 0.17704592116144846, 0.18118821348623737, 0.17809420476787874, 0.17775590335163471, 0.206728362256554, 0.19042325886574185, 0.19072141796360798, 0.20708449878617063, 0.21776916142881442, 0.19864304601679117, 0.1784266230160374, 0.18479795624277462, 0.21614367460058825, 0.1847424949658062, 0.2039222438571181, 0.6394295150533678, 0.709437038437505, 0.7272318055454359, 0.5459823777417234, 0.1983296595458679, 0.4496339112997588, 0.25540549812494295, 0.29281538805566965, 0.7376930203897825, 0.5344888407338009, 0.20672273819014408, 0.20382124454786565, 0.48192720836055014, 0.34688484757813565, 0.4575825880974329, 0.20682700934964893, 0.20496293634642548, 0.6488622698891036, 0.18509977707364345, 0.191089084099894, 0.18985410408145043, 0.20991206604435897, 0.18978085941796408, 0.19381728563676692, 0.2088429573450009, 0.18922114346994845, 0.18003992478764397, 0.06385995992359572, 0.06776328975003743, 0.08246546412260414, 0.06396501809912802, 0.07245866633439724, 0.07308179633849543, 0.07386375926689548, 0.07343376732690299, 0.07683714007868037]}, "mutation_prompt": null}
{"id": "5a47ff82-719e-4f71-a7dc-065e6de61cd8", "solution": "import numpy as np\n\nclass MemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Local search on best individual\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            best_fitness = fitness[best_index]\n            \n            # Perform a simple random neighborhood search around the best individual\n            local_neighbors = best_individual + np.random.uniform(-0.1, 0.1, (10, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n            \n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_index]\n                best_fitness = local_fitness[best_index]\n                \n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "MemeticDifferentialEvolution", "description": "A memetic algorithm combining differential evolution and local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.5836225311948049, 0.5895675481708798, 0.5931935339412369, 0.6092798817755256, 0.5971191751395089, 0.6202579917834308, 0.5915666641654593, 0.6329231146089245, 0.614496547496218, 0.3269420225697043, 0.32341007556044665, 0.3067393591575437, 0.33025145964783187, 0.3164549216374125, 0.31410736857977894, 0.3034373833378351, 0.32458656142264397, 0.32448189010106865, 0.0932342943891219, 0.14210171319527398, 0.12124651238007733, 0.1117186560595137, 0.10416462667954152, 0.13469583922195927, 0.10778599739147499, 0.10180983716471348, 0.11519071115675017, 0.09089923321281623, 0.07916223832856029, 0.09650580656142027, 0.10828047219810033, 0.09519688902934909, 0.11137299647643428, 0.11246531376395619, 0.12295482105811084, 0.09031900319661212, 0.9570017798820938, 0.9513292557106726, 0.9261189549404044, 0.932623940991951, 0.9277210170918078, 0.9656618317581583, 0.9643447913571865, 0.9721847342834466, 0.953476269027666, 0.29421687546028763, 0.31172891459799634, 0.28049672705086315, 0.28360228842594426, 0.29617362506457234, 0.31417605357685474, 0.3030308170377122, 0.2945013636010071, 0.31683005641423334, 0.5179901746271818, 0.4967938945250143, 0.3992218655444725, 0.6421024689794905, 0.4829996488068862, 0.5444143981709784, 0.818801602910831, 0.4169046635013345, 0.5667733833019734, 0.1729377314210867, 0.19408614048524442, 0.2189357195687498, 0.17003335976335543, 0.1734456129185239, 0.22317341038415006, 0.16815520346172597, 0.23471455937223595, 0.18005566062328848, 0.17128012630579414, 0.22078714561119273, 0.18985238237062607, 0.17887929005036718, 0.14169377179786802, 0.17179544957294768, 0.1912676319700436, 0.19817619522267937, 0.1992738826984083, 0.12609625599841567, 0.0884125386662783, 0.07419627554103048, 0.12689456376567354, 0.09695846887388382, 0.10487159974444749, 0.0874590757433692, 0.10069088517058722, 0.08757007935442673, 0.24629823159854047, 0.23721672551643924, 0.1937924518431159, 0.2360613318904099, 0.2283277969657893, 0.21070951185422226, 0.24376182655715817, 0.2505002143128586, 0.24655490215416498, 0.008900204497490405, 0.029919102645743822, 0.0025024944447568087, 0.0084676904081743, 0.012605954307217115, 0.02776100803567294, 0.025295612550901736, 0.023065392675113428, 0.023991856805336775, 0.14806031195500602, 0.16610838876205658, 0.14065028111594324, 0.15394747464367609, 0.14242247562505017, 0.1641355696142669, 0.13765768978862902, 0.14788652466503827, 0.14584253302347738, 0.47246127760880385, 0.468467834239634, 0.488651401632924, 0.46925752632019735, 0.47998205454430665, 0.4819209969882894, 0.48289905070808636, 0.478057701671476, 0.46432681688452015, 0.11941284027623278, 0.0970678050806677, 0.12705107697367768, 0.10342182382932241, 0.10174470673056091, 0.11317706319574627, 0.14065440601023493, 0.09688588256048702, 0.12232279486506359, 0.20147186942807993, 0.22762076159867817, 0.19167359996581346, 0.20502140494458854, 0.3240914377838958, 0.15302899385411983, 0.222969704226318, 0.1971035981559942, 0.3370545323977565, 0.2915631131514015, 0.2631696010212998, 0.28266814135970175, 0.2545950968525381, 0.23443404208008423, 0.27872565991797915, 0.29236532880326027, 0.2846885922197856, 0.2795686791733427, 0.22804063504413763, 0.19258150404602026, 0.23416578679225863, 0.20352583786546963, 0.20717979619202664, 0.17512893086659753, 0.22160308336762413, 0.22804313370465612, 0.21915684395892931, 0.18908813501361632, 0.17079934041368217, 0.17177489544080238, 0.17704592116144846, 0.18118821348623737, 0.17809420476787874, 0.17775590335163471, 0.206728362256554, 0.19042325886574185, 0.19072141796360798, 0.20708449878617063, 0.21776916142881442, 0.19864304601679117, 0.1784266230160374, 0.18479795624277462, 0.21614367460058825, 0.1847424949658062, 0.2039222438571181, 0.6394295150533678, 0.709437038437505, 0.7272318055454359, 0.5459823777417234, 0.1983296595458679, 0.4496339112997588, 0.25540549812494295, 0.29281538805566965, 0.7376930203897825, 0.5344888407338009, 0.20672273819014408, 0.20382124454786565, 0.48192720836055014, 0.34688484757813565, 0.4575825880974329, 0.20682700934964893, 0.20496293634642548, 0.6488622698891036, 0.18509977707364345, 0.191089084099894, 0.18985410408145043, 0.20991206604435897, 0.18978085941796408, 0.19381728563676692, 0.2088429573450009, 0.18922114346994845, 0.18003992478764397, 0.06385995992359572, 0.06776328975003743, 0.08246546412260414, 0.06396501809912802, 0.07245866633439724, 0.07308179633849543, 0.07386375926689548, 0.07343376732690299, 0.07683714007868037]}, "mutation_prompt": null}
{"id": "8f43f69f-ecb3-4dec-919c-87682006a711", "solution": "import numpy as np\n\nclass EnhancedHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.7  # Adaptive differential weight\n        self.CR = 0.85  # Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Adaptive mutation and crossover\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = population[indices]\n                mutant = np.clip(a + self.F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Efficient local search on top individuals\n            top_indices = np.argsort(fitness)[:3]\n            for idx in top_indices:\n                individual = population[idx]\n                individual_fitness = fitness[idx]\n                \n                # Perform a refined local search with Gaussian perturbation\n                local_neighbors = individual + np.random.normal(0, 0.05, (5, self.dim))\n                local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n                local_fitness = np.array([func(ind) for ind in local_neighbors])\n                eval_count += len(local_neighbors)\n                \n                # Update if any local neighbor is better\n                if np.min(local_fitness) < individual_fitness:\n                    best_index = np.argmin(local_fitness)\n                    population[idx] = local_neighbors[best_index]\n                    fitness[idx] = local_fitness[best_index]\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "EnhancedHybridDE", "description": "A hybrid optimization algorithm combining enhanced differential evolution with adaptive mutation and a more efficient local search strategy.", "configspace": "", "generation": 16, "fitness": 0.22929937616744714, "feedback": "The algorithm EnhancedHybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.19.", "error": "", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.4669918773450933, 0.4607943641738915, 0.49832613465066444, 0.4968623601237878, 0.5105010975681292, 0.49873093111014166, 0.5105456589930515, 0.4875352522514155, 0.5127775834110453, 0.18017545309710936, 0.182831216571274, 0.17004181667395657, 0.16796219110908184, 0.19717574098333712, 0.16031811432365883, 0.1688564748596677, 0.16717781357997885, 0.19507972724574452, 0.10586525537688662, 0.14639171001466844, 0.1249431896915224, 0.11719146640859401, 0.11192105110422668, 0.11943660964732883, 0.13011459430943195, 0.12612824758621632, 0.13352127628414145, 0.09742168632290271, 0.09907080136607671, 0.09763176040729282, 0.0924728570111154, 0.12299655482020078, 0.09534504295584634, 0.11430857896228575, 0.08777030431518162, 0.09194393790045163, 0.9267921746302415, 0.9709016577216796, 0.9314290187102753, 0.9102451503006533, 0.9469809655478677, 0.9403402821508513, 0.9519378252763965, 0.9939295664277569, 0.913784775850423, 0.2864470625895216, 0.22357733871399832, 0.2629867178156632, 0.24624120815220651, 0.2909242918316297, 0.24154512905701309, 0.28974244693553364, 0.2477640840258083, 0.30965831296866186, 0.3379976879105936, 0.48769000696924536, 0.3337164416208006, 0.28790751612558674, 0.2741065168405087, 0.5088092052333086, 0.3339711072977495, 0.5927544105863757, 0.318828843706523, 0.2030426186966624, 0.14248000189629384, 0.15644023081517666, 0.1297030903995059, 0.1552098354763617, 0.13729880955787188, 0.23543987271113365, 0.16788230532149706, 0.21330501648770672, 0.12921101907679222, 0.11874791004900687, 0.12488992114489805, 0.1896989132150445, 0.20567498201213608, 0.12725662875838262, 0.20138876456729837, 0.11833216661942703, 0.12662323820864874, 0.0264550162788304, 0.004712271618833808, 0.008542374226369942, 0.016301501422405495, 0.07355140887123068, 0.019221372095365563, 0.02440634806732067, 0.01753579089695545, 0.04184694651044463, 0.10133006052907456, 0.11773474931322547, 0.12449468144661169, 0.1047012598193382, 0.10037004770331004, 0.09543447052804754, 0.12002861745750593, 0.100026335161154, 0.14241279390237138, 0.009573260488066393, 9.999999999998899e-05, 9.999999999998899e-05, 0.015070946594634038, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0006600735864340512, 0.11159464922012963, 0.09848319721722343, 0.0985634884606914, 0.11544164943735524, 0.11595723620848952, 0.12328363254586239, 0.11208873048511336, 0.12460606557377563, 0.09968029950247148, 0.41360521290429264, 0.39060247480996124, 0.41476326815189724, 0.4077351801948589, 0.3926185977624035, 0.40929850123331135, 0.41176353436745416, 0.407712938300662, 0.3914919253367045, 0.09806193045317846, 0.13006088070798016, 0.14139945247607788, 0.09990401028923557, 0.11851989743342328, 0.14300314945899173, 0.10006006881184315, 0.11839677120094605, 0.1236656690127651, 0.1972846541932155, 0.17033768793116288, 0.1907255340732561, 0.2089596790120184, 0.274574676910056, 0.2362013403615003, 0.22905808152588725, 0.21890503028157027, 0.29611469771597465, 0.22668371031742285, 0.2540737192304384, 0.2197591567121937, 0.24488867067302467, 0.21574377661362776, 0.2102989336023109, 0.2646420929164478, 0.2565804120404156, 0.24417775211672554, 0.16509286053133365, 0.18436293740371934, 0.18579447813409555, 0.17153011479619695, 0.1765115012419214, 0.16598762938540912, 0.17738756884188756, 0.18941987776201052, 0.19606377894157578, 0.1832653280512565, 0.20134537630441207, 0.18706203462414417, 0.20600562015162838, 0.18335381407838414, 0.1811846129827418, 0.17748302260098336, 0.1967503837540201, 0.19434816854762926, 0.18209827412606727, 0.18760805535798886, 0.20520845033799162, 0.189071703148891, 0.2201519416984309, 0.19067796126181447, 0.17893441910312247, 0.18041814658870958, 0.18827931279907095, 0.17003803809323492, 0.19990062835573885, 0.16857166002811264, 0.5885577973102574, 0.19551756663029485, 0.16004792861864048, 0.33661644783090927, 0.1857592253939523, 0.18209720400941376, 0.43361192815995475, 0.20249185727320218, 0.4593167184696031, 0.3452241985514003, 0.4337872406138834, 0.36417555825545855, 0.4302669911928507, 0.5516924712360896, 0.20493650066462354, 0.1958947148544109, 0.17540244799207394, 0.2074814642086561, 0.1885733569953606, 0.1986209110934054, 0.18500060546850805, 0.19198713072633222, 0.19876919029860085, 0.18690488616233591, 0.07698948787731519, 0.079658782802693, 0.0752434352825585, 0.08230046159988602, 0.08714527965081253, 0.07722920602619976, 0.0801466427143831, 0.0791375464799392, 0.07699622182406107]}, "mutation_prompt": null}
{"id": "0903c1aa-4aee-4b14-8ef4-f2448243df38", "solution": "import numpy as np\n\nclass MemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Local search on best individual\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            best_fitness = fitness[best_index]\n            \n            # Perform a simple random neighborhood search around the best individual\n            local_neighbors = best_individual + np.random.uniform(-0.1, 0.1, (10, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n            \n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_index]\n                best_fitness = local_fitness[best_index]\n                \n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "MemeticDifferentialEvolution", "description": "A memetic algorithm combining differential evolution and local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.5836225311948049, 0.5895675481708798, 0.5931935339412369, 0.6092798817755256, 0.5971191751395089, 0.6202579917834308, 0.5915666641654593, 0.6329231146089245, 0.614496547496218, 0.3269420225697043, 0.32341007556044665, 0.3067393591575437, 0.33025145964783187, 0.3164549216374125, 0.31410736857977894, 0.3034373833378351, 0.32458656142264397, 0.32448189010106865, 0.0932342943891219, 0.14210171319527398, 0.12124651238007733, 0.1117186560595137, 0.10416462667954152, 0.13469583922195927, 0.10778599739147499, 0.10180983716471348, 0.11519071115675017, 0.09089923321281623, 0.07916223832856029, 0.09650580656142027, 0.10828047219810033, 0.09519688902934909, 0.11137299647643428, 0.11246531376395619, 0.12295482105811084, 0.09031900319661212, 0.9570017798820938, 0.9513292557106726, 0.9261189549404044, 0.932623940991951, 0.9277210170918078, 0.9656618317581583, 0.9643447913571865, 0.9721847342834466, 0.953476269027666, 0.29421687546028763, 0.31172891459799634, 0.28049672705086315, 0.28360228842594426, 0.29617362506457234, 0.31417605357685474, 0.3030308170377122, 0.2945013636010071, 0.31683005641423334, 0.5179901746271818, 0.4967938945250143, 0.3992218655444725, 0.6421024689794905, 0.4829996488068862, 0.5444143981709784, 0.818801602910831, 0.4169046635013345, 0.5667733833019734, 0.1729377314210867, 0.19408614048524442, 0.2189357195687498, 0.17003335976335543, 0.1734456129185239, 0.22317341038415006, 0.16815520346172597, 0.23471455937223595, 0.18005566062328848, 0.17128012630579414, 0.22078714561119273, 0.18985238237062607, 0.17887929005036718, 0.14169377179786802, 0.17179544957294768, 0.1912676319700436, 0.19817619522267937, 0.1992738826984083, 0.12609625599841567, 0.0884125386662783, 0.07419627554103048, 0.12689456376567354, 0.09695846887388382, 0.10487159974444749, 0.0874590757433692, 0.10069088517058722, 0.08757007935442673, 0.24629823159854047, 0.23721672551643924, 0.1937924518431159, 0.2360613318904099, 0.2283277969657893, 0.21070951185422226, 0.24376182655715817, 0.2505002143128586, 0.24655490215416498, 0.008900204497490405, 0.029919102645743822, 0.0025024944447568087, 0.0084676904081743, 0.012605954307217115, 0.02776100803567294, 0.025295612550901736, 0.023065392675113428, 0.023991856805336775, 0.14806031195500602, 0.16610838876205658, 0.14065028111594324, 0.15394747464367609, 0.14242247562505017, 0.1641355696142669, 0.13765768978862902, 0.14788652466503827, 0.14584253302347738, 0.47246127760880385, 0.468467834239634, 0.488651401632924, 0.46925752632019735, 0.47998205454430665, 0.4819209969882894, 0.48289905070808636, 0.478057701671476, 0.46432681688452015, 0.11941284027623278, 0.0970678050806677, 0.12705107697367768, 0.10342182382932241, 0.10174470673056091, 0.11317706319574627, 0.14065440601023493, 0.09688588256048702, 0.12232279486506359, 0.20147186942807993, 0.22762076159867817, 0.19167359996581346, 0.20502140494458854, 0.3240914377838958, 0.15302899385411983, 0.222969704226318, 0.1971035981559942, 0.3370545323977565, 0.2915631131514015, 0.2631696010212998, 0.28266814135970175, 0.2545950968525381, 0.23443404208008423, 0.27872565991797915, 0.29236532880326027, 0.2846885922197856, 0.2795686791733427, 0.22804063504413763, 0.19258150404602026, 0.23416578679225863, 0.20352583786546963, 0.20717979619202664, 0.17512893086659753, 0.22160308336762413, 0.22804313370465612, 0.21915684395892931, 0.18908813501361632, 0.17079934041368217, 0.17177489544080238, 0.17704592116144846, 0.18118821348623737, 0.17809420476787874, 0.17775590335163471, 0.206728362256554, 0.19042325886574185, 0.19072141796360798, 0.20708449878617063, 0.21776916142881442, 0.19864304601679117, 0.1784266230160374, 0.18479795624277462, 0.21614367460058825, 0.1847424949658062, 0.2039222438571181, 0.6394295150533678, 0.709437038437505, 0.7272318055454359, 0.5459823777417234, 0.1983296595458679, 0.4496339112997588, 0.25540549812494295, 0.29281538805566965, 0.7376930203897825, 0.5344888407338009, 0.20672273819014408, 0.20382124454786565, 0.48192720836055014, 0.34688484757813565, 0.4575825880974329, 0.20682700934964893, 0.20496293634642548, 0.6488622698891036, 0.18509977707364345, 0.191089084099894, 0.18985410408145043, 0.20991206604435897, 0.18978085941796408, 0.19381728563676692, 0.2088429573450009, 0.18922114346994845, 0.18003992478764397, 0.06385995992359572, 0.06776328975003743, 0.08246546412260414, 0.06396501809912802, 0.07245866633439724, 0.07308179633849543, 0.07386375926689548, 0.07343376732690299, 0.07683714007868037]}, "mutation_prompt": null}
{"id": "85d36382-8101-4c86-ba43-a53191269343", "solution": "import numpy as np\n\nclass MemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Local search on best individual\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            best_fitness = fitness[best_index]\n            \n            # Perform a simple random neighborhood search around the best individual\n            local_neighbors = best_individual + np.random.uniform(-0.1, 0.1, (10, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n            \n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_index]\n                best_fitness = local_fitness[best_index]\n                \n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "MemeticDifferentialEvolution", "description": "A memetic algorithm combining differential evolution and local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.5836225311948049, 0.5895675481708798, 0.5931935339412369, 0.6092798817755256, 0.5971191751395089, 0.6202579917834308, 0.5915666641654593, 0.6329231146089245, 0.614496547496218, 0.3269420225697043, 0.32341007556044665, 0.3067393591575437, 0.33025145964783187, 0.3164549216374125, 0.31410736857977894, 0.3034373833378351, 0.32458656142264397, 0.32448189010106865, 0.0932342943891219, 0.14210171319527398, 0.12124651238007733, 0.1117186560595137, 0.10416462667954152, 0.13469583922195927, 0.10778599739147499, 0.10180983716471348, 0.11519071115675017, 0.09089923321281623, 0.07916223832856029, 0.09650580656142027, 0.10828047219810033, 0.09519688902934909, 0.11137299647643428, 0.11246531376395619, 0.12295482105811084, 0.09031900319661212, 0.9570017798820938, 0.9513292557106726, 0.9261189549404044, 0.932623940991951, 0.9277210170918078, 0.9656618317581583, 0.9643447913571865, 0.9721847342834466, 0.953476269027666, 0.29421687546028763, 0.31172891459799634, 0.28049672705086315, 0.28360228842594426, 0.29617362506457234, 0.31417605357685474, 0.3030308170377122, 0.2945013636010071, 0.31683005641423334, 0.5179901746271818, 0.4967938945250143, 0.3992218655444725, 0.6421024689794905, 0.4829996488068862, 0.5444143981709784, 0.818801602910831, 0.4169046635013345, 0.5667733833019734, 0.1729377314210867, 0.19408614048524442, 0.2189357195687498, 0.17003335976335543, 0.1734456129185239, 0.22317341038415006, 0.16815520346172597, 0.23471455937223595, 0.18005566062328848, 0.17128012630579414, 0.22078714561119273, 0.18985238237062607, 0.17887929005036718, 0.14169377179786802, 0.17179544957294768, 0.1912676319700436, 0.19817619522267937, 0.1992738826984083, 0.12609625599841567, 0.0884125386662783, 0.07419627554103048, 0.12689456376567354, 0.09695846887388382, 0.10487159974444749, 0.0874590757433692, 0.10069088517058722, 0.08757007935442673, 0.24629823159854047, 0.23721672551643924, 0.1937924518431159, 0.2360613318904099, 0.2283277969657893, 0.21070951185422226, 0.24376182655715817, 0.2505002143128586, 0.24655490215416498, 0.008900204497490405, 0.029919102645743822, 0.0025024944447568087, 0.0084676904081743, 0.012605954307217115, 0.02776100803567294, 0.025295612550901736, 0.023065392675113428, 0.023991856805336775, 0.14806031195500602, 0.16610838876205658, 0.14065028111594324, 0.15394747464367609, 0.14242247562505017, 0.1641355696142669, 0.13765768978862902, 0.14788652466503827, 0.14584253302347738, 0.47246127760880385, 0.468467834239634, 0.488651401632924, 0.46925752632019735, 0.47998205454430665, 0.4819209969882894, 0.48289905070808636, 0.478057701671476, 0.46432681688452015, 0.11941284027623278, 0.0970678050806677, 0.12705107697367768, 0.10342182382932241, 0.10174470673056091, 0.11317706319574627, 0.14065440601023493, 0.09688588256048702, 0.12232279486506359, 0.20147186942807993, 0.22762076159867817, 0.19167359996581346, 0.20502140494458854, 0.3240914377838958, 0.15302899385411983, 0.222969704226318, 0.1971035981559942, 0.3370545323977565, 0.2915631131514015, 0.2631696010212998, 0.28266814135970175, 0.2545950968525381, 0.23443404208008423, 0.27872565991797915, 0.29236532880326027, 0.2846885922197856, 0.2795686791733427, 0.22804063504413763, 0.19258150404602026, 0.23416578679225863, 0.20352583786546963, 0.20717979619202664, 0.17512893086659753, 0.22160308336762413, 0.22804313370465612, 0.21915684395892931, 0.18908813501361632, 0.17079934041368217, 0.17177489544080238, 0.17704592116144846, 0.18118821348623737, 0.17809420476787874, 0.17775590335163471, 0.206728362256554, 0.19042325886574185, 0.19072141796360798, 0.20708449878617063, 0.21776916142881442, 0.19864304601679117, 0.1784266230160374, 0.18479795624277462, 0.21614367460058825, 0.1847424949658062, 0.2039222438571181, 0.6394295150533678, 0.709437038437505, 0.7272318055454359, 0.5459823777417234, 0.1983296595458679, 0.4496339112997588, 0.25540549812494295, 0.29281538805566965, 0.7376930203897825, 0.5344888407338009, 0.20672273819014408, 0.20382124454786565, 0.48192720836055014, 0.34688484757813565, 0.4575825880974329, 0.20682700934964893, 0.20496293634642548, 0.6488622698891036, 0.18509977707364345, 0.191089084099894, 0.18985410408145043, 0.20991206604435897, 0.18978085941796408, 0.19381728563676692, 0.2088429573450009, 0.18922114346994845, 0.18003992478764397, 0.06385995992359572, 0.06776328975003743, 0.08246546412260414, 0.06396501809912802, 0.07245866633439724, 0.07308179633849543, 0.07386375926689548, 0.07343376732690299, 0.07683714007868037]}, "mutation_prompt": null}
{"id": "b0135d0b-a407-4809-bd75-8617ce230796", "solution": "import numpy as np\n\nclass MemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Local search on best individual\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            best_fitness = fitness[best_index]\n            \n            # Perform a simple random neighborhood search around the best individual\n            local_neighbors = best_individual + np.random.uniform(-0.1, 0.1, (10, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n            \n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_index]\n                best_fitness = local_fitness[best_index]\n                \n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "MemeticDifferentialEvolution", "description": "A memetic algorithm combining differential evolution and local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.5836225311948049, 0.5895675481708798, 0.5931935339412369, 0.6092798817755256, 0.5971191751395089, 0.6202579917834308, 0.5915666641654593, 0.6329231146089245, 0.614496547496218, 0.3269420225697043, 0.32341007556044665, 0.3067393591575437, 0.33025145964783187, 0.3164549216374125, 0.31410736857977894, 0.3034373833378351, 0.32458656142264397, 0.32448189010106865, 0.0932342943891219, 0.14210171319527398, 0.12124651238007733, 0.1117186560595137, 0.10416462667954152, 0.13469583922195927, 0.10778599739147499, 0.10180983716471348, 0.11519071115675017, 0.09089923321281623, 0.07916223832856029, 0.09650580656142027, 0.10828047219810033, 0.09519688902934909, 0.11137299647643428, 0.11246531376395619, 0.12295482105811084, 0.09031900319661212, 0.9570017798820938, 0.9513292557106726, 0.9261189549404044, 0.932623940991951, 0.9277210170918078, 0.9656618317581583, 0.9643447913571865, 0.9721847342834466, 0.953476269027666, 0.29421687546028763, 0.31172891459799634, 0.28049672705086315, 0.28360228842594426, 0.29617362506457234, 0.31417605357685474, 0.3030308170377122, 0.2945013636010071, 0.31683005641423334, 0.5179901746271818, 0.4967938945250143, 0.3992218655444725, 0.6421024689794905, 0.4829996488068862, 0.5444143981709784, 0.818801602910831, 0.4169046635013345, 0.5667733833019734, 0.1729377314210867, 0.19408614048524442, 0.2189357195687498, 0.17003335976335543, 0.1734456129185239, 0.22317341038415006, 0.16815520346172597, 0.23471455937223595, 0.18005566062328848, 0.17128012630579414, 0.22078714561119273, 0.18985238237062607, 0.17887929005036718, 0.14169377179786802, 0.17179544957294768, 0.1912676319700436, 0.19817619522267937, 0.1992738826984083, 0.12609625599841567, 0.0884125386662783, 0.07419627554103048, 0.12689456376567354, 0.09695846887388382, 0.10487159974444749, 0.0874590757433692, 0.10069088517058722, 0.08757007935442673, 0.24629823159854047, 0.23721672551643924, 0.1937924518431159, 0.2360613318904099, 0.2283277969657893, 0.21070951185422226, 0.24376182655715817, 0.2505002143128586, 0.24655490215416498, 0.008900204497490405, 0.029919102645743822, 0.0025024944447568087, 0.0084676904081743, 0.012605954307217115, 0.02776100803567294, 0.025295612550901736, 0.023065392675113428, 0.023991856805336775, 0.14806031195500602, 0.16610838876205658, 0.14065028111594324, 0.15394747464367609, 0.14242247562505017, 0.1641355696142669, 0.13765768978862902, 0.14788652466503827, 0.14584253302347738, 0.47246127760880385, 0.468467834239634, 0.488651401632924, 0.46925752632019735, 0.47998205454430665, 0.4819209969882894, 0.48289905070808636, 0.478057701671476, 0.46432681688452015, 0.11941284027623278, 0.0970678050806677, 0.12705107697367768, 0.10342182382932241, 0.10174470673056091, 0.11317706319574627, 0.14065440601023493, 0.09688588256048702, 0.12232279486506359, 0.20147186942807993, 0.22762076159867817, 0.19167359996581346, 0.20502140494458854, 0.3240914377838958, 0.15302899385411983, 0.222969704226318, 0.1971035981559942, 0.3370545323977565, 0.2915631131514015, 0.2631696010212998, 0.28266814135970175, 0.2545950968525381, 0.23443404208008423, 0.27872565991797915, 0.29236532880326027, 0.2846885922197856, 0.2795686791733427, 0.22804063504413763, 0.19258150404602026, 0.23416578679225863, 0.20352583786546963, 0.20717979619202664, 0.17512893086659753, 0.22160308336762413, 0.22804313370465612, 0.21915684395892931, 0.18908813501361632, 0.17079934041368217, 0.17177489544080238, 0.17704592116144846, 0.18118821348623737, 0.17809420476787874, 0.17775590335163471, 0.206728362256554, 0.19042325886574185, 0.19072141796360798, 0.20708449878617063, 0.21776916142881442, 0.19864304601679117, 0.1784266230160374, 0.18479795624277462, 0.21614367460058825, 0.1847424949658062, 0.2039222438571181, 0.6394295150533678, 0.709437038437505, 0.7272318055454359, 0.5459823777417234, 0.1983296595458679, 0.4496339112997588, 0.25540549812494295, 0.29281538805566965, 0.7376930203897825, 0.5344888407338009, 0.20672273819014408, 0.20382124454786565, 0.48192720836055014, 0.34688484757813565, 0.4575825880974329, 0.20682700934964893, 0.20496293634642548, 0.6488622698891036, 0.18509977707364345, 0.191089084099894, 0.18985410408145043, 0.20991206604435897, 0.18978085941796408, 0.19381728563676692, 0.2088429573450009, 0.18922114346994845, 0.18003992478764397, 0.06385995992359572, 0.06776328975003743, 0.08246546412260414, 0.06396501809912802, 0.07245866633439724, 0.07308179633849543, 0.07386375926689548, 0.07343376732690299, 0.07683714007868037]}, "mutation_prompt": null}
{"id": "226f8d01-13ce-46e3-9ce9-f455c3bd1a9b", "solution": "import numpy as np\n\nclass MemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Local search on best individual\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            best_fitness = fitness[best_index]\n            \n            # Perform a simple random neighborhood search around the best individual\n            local_neighbors = best_individual + np.random.uniform(-0.1, 0.1, (10, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n            \n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_index]\n                best_fitness = local_fitness[best_index]\n                \n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "MemeticDifferentialEvolution", "description": "A memetic algorithm combining differential evolution and local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.5836225311948049, 0.5895675481708798, 0.5931935339412369, 0.6092798817755256, 0.5971191751395089, 0.6202579917834308, 0.5915666641654593, 0.6329231146089245, 0.614496547496218, 0.3269420225697043, 0.32341007556044665, 0.3067393591575437, 0.33025145964783187, 0.3164549216374125, 0.31410736857977894, 0.3034373833378351, 0.32458656142264397, 0.32448189010106865, 0.0932342943891219, 0.14210171319527398, 0.12124651238007733, 0.1117186560595137, 0.10416462667954152, 0.13469583922195927, 0.10778599739147499, 0.10180983716471348, 0.11519071115675017, 0.09089923321281623, 0.07916223832856029, 0.09650580656142027, 0.10828047219810033, 0.09519688902934909, 0.11137299647643428, 0.11246531376395619, 0.12295482105811084, 0.09031900319661212, 0.9570017798820938, 0.9513292557106726, 0.9261189549404044, 0.932623940991951, 0.9277210170918078, 0.9656618317581583, 0.9643447913571865, 0.9721847342834466, 0.953476269027666, 0.29421687546028763, 0.31172891459799634, 0.28049672705086315, 0.28360228842594426, 0.29617362506457234, 0.31417605357685474, 0.3030308170377122, 0.2945013636010071, 0.31683005641423334, 0.5179901746271818, 0.4967938945250143, 0.3992218655444725, 0.6421024689794905, 0.4829996488068862, 0.5444143981709784, 0.818801602910831, 0.4169046635013345, 0.5667733833019734, 0.1729377314210867, 0.19408614048524442, 0.2189357195687498, 0.17003335976335543, 0.1734456129185239, 0.22317341038415006, 0.16815520346172597, 0.23471455937223595, 0.18005566062328848, 0.17128012630579414, 0.22078714561119273, 0.18985238237062607, 0.17887929005036718, 0.14169377179786802, 0.17179544957294768, 0.1912676319700436, 0.19817619522267937, 0.1992738826984083, 0.12609625599841567, 0.0884125386662783, 0.07419627554103048, 0.12689456376567354, 0.09695846887388382, 0.10487159974444749, 0.0874590757433692, 0.10069088517058722, 0.08757007935442673, 0.24629823159854047, 0.23721672551643924, 0.1937924518431159, 0.2360613318904099, 0.2283277969657893, 0.21070951185422226, 0.24376182655715817, 0.2505002143128586, 0.24655490215416498, 0.008900204497490405, 0.029919102645743822, 0.0025024944447568087, 0.0084676904081743, 0.012605954307217115, 0.02776100803567294, 0.025295612550901736, 0.023065392675113428, 0.023991856805336775, 0.14806031195500602, 0.16610838876205658, 0.14065028111594324, 0.15394747464367609, 0.14242247562505017, 0.1641355696142669, 0.13765768978862902, 0.14788652466503827, 0.14584253302347738, 0.47246127760880385, 0.468467834239634, 0.488651401632924, 0.46925752632019735, 0.47998205454430665, 0.4819209969882894, 0.48289905070808636, 0.478057701671476, 0.46432681688452015, 0.11941284027623278, 0.0970678050806677, 0.12705107697367768, 0.10342182382932241, 0.10174470673056091, 0.11317706319574627, 0.14065440601023493, 0.09688588256048702, 0.12232279486506359, 0.20147186942807993, 0.22762076159867817, 0.19167359996581346, 0.20502140494458854, 0.3240914377838958, 0.15302899385411983, 0.222969704226318, 0.1971035981559942, 0.3370545323977565, 0.2915631131514015, 0.2631696010212998, 0.28266814135970175, 0.2545950968525381, 0.23443404208008423, 0.27872565991797915, 0.29236532880326027, 0.2846885922197856, 0.2795686791733427, 0.22804063504413763, 0.19258150404602026, 0.23416578679225863, 0.20352583786546963, 0.20717979619202664, 0.17512893086659753, 0.22160308336762413, 0.22804313370465612, 0.21915684395892931, 0.18908813501361632, 0.17079934041368217, 0.17177489544080238, 0.17704592116144846, 0.18118821348623737, 0.17809420476787874, 0.17775590335163471, 0.206728362256554, 0.19042325886574185, 0.19072141796360798, 0.20708449878617063, 0.21776916142881442, 0.19864304601679117, 0.1784266230160374, 0.18479795624277462, 0.21614367460058825, 0.1847424949658062, 0.2039222438571181, 0.6394295150533678, 0.709437038437505, 0.7272318055454359, 0.5459823777417234, 0.1983296595458679, 0.4496339112997588, 0.25540549812494295, 0.29281538805566965, 0.7376930203897825, 0.5344888407338009, 0.20672273819014408, 0.20382124454786565, 0.48192720836055014, 0.34688484757813565, 0.4575825880974329, 0.20682700934964893, 0.20496293634642548, 0.6488622698891036, 0.18509977707364345, 0.191089084099894, 0.18985410408145043, 0.20991206604435897, 0.18978085941796408, 0.19381728563676692, 0.2088429573450009, 0.18922114346994845, 0.18003992478764397, 0.06385995992359572, 0.06776328975003743, 0.08246546412260414, 0.06396501809912802, 0.07245866633439724, 0.07308179633849543, 0.07386375926689548, 0.07343376732690299, 0.07683714007868037]}, "mutation_prompt": null}
{"id": "61497e25-a0be-4a31-b530-5dd512b0446b", "solution": "import numpy as np\n\nclass MemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Local search on best individual\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            best_fitness = fitness[best_index]\n            \n            # Perform a simple random neighborhood search around the best individual\n            local_neighbors = best_individual + np.random.uniform(-0.1, 0.1, (10, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n            \n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_index]\n                best_fitness = local_fitness[best_index]\n                \n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "MemeticDifferentialEvolution", "description": "A memetic algorithm combining differential evolution and local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.5836225311948049, 0.5895675481708798, 0.5931935339412369, 0.6092798817755256, 0.5971191751395089, 0.6202579917834308, 0.5915666641654593, 0.6329231146089245, 0.614496547496218, 0.3269420225697043, 0.32341007556044665, 0.3067393591575437, 0.33025145964783187, 0.3164549216374125, 0.31410736857977894, 0.3034373833378351, 0.32458656142264397, 0.32448189010106865, 0.0932342943891219, 0.14210171319527398, 0.12124651238007733, 0.1117186560595137, 0.10416462667954152, 0.13469583922195927, 0.10778599739147499, 0.10180983716471348, 0.11519071115675017, 0.09089923321281623, 0.07916223832856029, 0.09650580656142027, 0.10828047219810033, 0.09519688902934909, 0.11137299647643428, 0.11246531376395619, 0.12295482105811084, 0.09031900319661212, 0.9570017798820938, 0.9513292557106726, 0.9261189549404044, 0.932623940991951, 0.9277210170918078, 0.9656618317581583, 0.9643447913571865, 0.9721847342834466, 0.953476269027666, 0.29421687546028763, 0.31172891459799634, 0.28049672705086315, 0.28360228842594426, 0.29617362506457234, 0.31417605357685474, 0.3030308170377122, 0.2945013636010071, 0.31683005641423334, 0.5179901746271818, 0.4967938945250143, 0.3992218655444725, 0.6421024689794905, 0.4829996488068862, 0.5444143981709784, 0.818801602910831, 0.4169046635013345, 0.5667733833019734, 0.1729377314210867, 0.19408614048524442, 0.2189357195687498, 0.17003335976335543, 0.1734456129185239, 0.22317341038415006, 0.16815520346172597, 0.23471455937223595, 0.18005566062328848, 0.17128012630579414, 0.22078714561119273, 0.18985238237062607, 0.17887929005036718, 0.14169377179786802, 0.17179544957294768, 0.1912676319700436, 0.19817619522267937, 0.1992738826984083, 0.12609625599841567, 0.0884125386662783, 0.07419627554103048, 0.12689456376567354, 0.09695846887388382, 0.10487159974444749, 0.0874590757433692, 0.10069088517058722, 0.08757007935442673, 0.24629823159854047, 0.23721672551643924, 0.1937924518431159, 0.2360613318904099, 0.2283277969657893, 0.21070951185422226, 0.24376182655715817, 0.2505002143128586, 0.24655490215416498, 0.008900204497490405, 0.029919102645743822, 0.0025024944447568087, 0.0084676904081743, 0.012605954307217115, 0.02776100803567294, 0.025295612550901736, 0.023065392675113428, 0.023991856805336775, 0.14806031195500602, 0.16610838876205658, 0.14065028111594324, 0.15394747464367609, 0.14242247562505017, 0.1641355696142669, 0.13765768978862902, 0.14788652466503827, 0.14584253302347738, 0.47246127760880385, 0.468467834239634, 0.488651401632924, 0.46925752632019735, 0.47998205454430665, 0.4819209969882894, 0.48289905070808636, 0.478057701671476, 0.46432681688452015, 0.11941284027623278, 0.0970678050806677, 0.12705107697367768, 0.10342182382932241, 0.10174470673056091, 0.11317706319574627, 0.14065440601023493, 0.09688588256048702, 0.12232279486506359, 0.20147186942807993, 0.22762076159867817, 0.19167359996581346, 0.20502140494458854, 0.3240914377838958, 0.15302899385411983, 0.222969704226318, 0.1971035981559942, 0.3370545323977565, 0.2915631131514015, 0.2631696010212998, 0.28266814135970175, 0.2545950968525381, 0.23443404208008423, 0.27872565991797915, 0.29236532880326027, 0.2846885922197856, 0.2795686791733427, 0.22804063504413763, 0.19258150404602026, 0.23416578679225863, 0.20352583786546963, 0.20717979619202664, 0.17512893086659753, 0.22160308336762413, 0.22804313370465612, 0.21915684395892931, 0.18908813501361632, 0.17079934041368217, 0.17177489544080238, 0.17704592116144846, 0.18118821348623737, 0.17809420476787874, 0.17775590335163471, 0.206728362256554, 0.19042325886574185, 0.19072141796360798, 0.20708449878617063, 0.21776916142881442, 0.19864304601679117, 0.1784266230160374, 0.18479795624277462, 0.21614367460058825, 0.1847424949658062, 0.2039222438571181, 0.6394295150533678, 0.709437038437505, 0.7272318055454359, 0.5459823777417234, 0.1983296595458679, 0.4496339112997588, 0.25540549812494295, 0.29281538805566965, 0.7376930203897825, 0.5344888407338009, 0.20672273819014408, 0.20382124454786565, 0.48192720836055014, 0.34688484757813565, 0.4575825880974329, 0.20682700934964893, 0.20496293634642548, 0.6488622698891036, 0.18509977707364345, 0.191089084099894, 0.18985410408145043, 0.20991206604435897, 0.18978085941796408, 0.19381728563676692, 0.2088429573450009, 0.18922114346994845, 0.18003992478764397, 0.06385995992359572, 0.06776328975003743, 0.08246546412260414, 0.06396501809912802, 0.07245866633439724, 0.07308179633849543, 0.07386375926689548, 0.07343376732690299, 0.07683714007868037]}, "mutation_prompt": null}
{"id": "f2f140e5-389a-4966-baa1-8d481ca98853", "solution": "import numpy as np\n\nclass MemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Local search on best individual\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            best_fitness = fitness[best_index]\n            \n            # Perform a simple random neighborhood search around the best individual\n            local_neighbors = best_individual + np.random.uniform(-0.1, 0.1, (10, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n            \n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_index]\n                best_fitness = local_fitness[best_index]\n                \n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "MemeticDifferentialEvolution", "description": "A memetic algorithm combining differential evolution and local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.5836225311948049, 0.5895675481708798, 0.5931935339412369, 0.6092798817755256, 0.5971191751395089, 0.6202579917834308, 0.5915666641654593, 0.6329231146089245, 0.614496547496218, 0.3269420225697043, 0.32341007556044665, 0.3067393591575437, 0.33025145964783187, 0.3164549216374125, 0.31410736857977894, 0.3034373833378351, 0.32458656142264397, 0.32448189010106865, 0.0932342943891219, 0.14210171319527398, 0.12124651238007733, 0.1117186560595137, 0.10416462667954152, 0.13469583922195927, 0.10778599739147499, 0.10180983716471348, 0.11519071115675017, 0.09089923321281623, 0.07916223832856029, 0.09650580656142027, 0.10828047219810033, 0.09519688902934909, 0.11137299647643428, 0.11246531376395619, 0.12295482105811084, 0.09031900319661212, 0.9570017798820938, 0.9513292557106726, 0.9261189549404044, 0.932623940991951, 0.9277210170918078, 0.9656618317581583, 0.9643447913571865, 0.9721847342834466, 0.953476269027666, 0.29421687546028763, 0.31172891459799634, 0.28049672705086315, 0.28360228842594426, 0.29617362506457234, 0.31417605357685474, 0.3030308170377122, 0.2945013636010071, 0.31683005641423334, 0.5179901746271818, 0.4967938945250143, 0.3992218655444725, 0.6421024689794905, 0.4829996488068862, 0.5444143981709784, 0.818801602910831, 0.4169046635013345, 0.5667733833019734, 0.1729377314210867, 0.19408614048524442, 0.2189357195687498, 0.17003335976335543, 0.1734456129185239, 0.22317341038415006, 0.16815520346172597, 0.23471455937223595, 0.18005566062328848, 0.17128012630579414, 0.22078714561119273, 0.18985238237062607, 0.17887929005036718, 0.14169377179786802, 0.17179544957294768, 0.1912676319700436, 0.19817619522267937, 0.1992738826984083, 0.12609625599841567, 0.0884125386662783, 0.07419627554103048, 0.12689456376567354, 0.09695846887388382, 0.10487159974444749, 0.0874590757433692, 0.10069088517058722, 0.08757007935442673, 0.24629823159854047, 0.23721672551643924, 0.1937924518431159, 0.2360613318904099, 0.2283277969657893, 0.21070951185422226, 0.24376182655715817, 0.2505002143128586, 0.24655490215416498, 0.008900204497490405, 0.029919102645743822, 0.0025024944447568087, 0.0084676904081743, 0.012605954307217115, 0.02776100803567294, 0.025295612550901736, 0.023065392675113428, 0.023991856805336775, 0.14806031195500602, 0.16610838876205658, 0.14065028111594324, 0.15394747464367609, 0.14242247562505017, 0.1641355696142669, 0.13765768978862902, 0.14788652466503827, 0.14584253302347738, 0.47246127760880385, 0.468467834239634, 0.488651401632924, 0.46925752632019735, 0.47998205454430665, 0.4819209969882894, 0.48289905070808636, 0.478057701671476, 0.46432681688452015, 0.11941284027623278, 0.0970678050806677, 0.12705107697367768, 0.10342182382932241, 0.10174470673056091, 0.11317706319574627, 0.14065440601023493, 0.09688588256048702, 0.12232279486506359, 0.20147186942807993, 0.22762076159867817, 0.19167359996581346, 0.20502140494458854, 0.3240914377838958, 0.15302899385411983, 0.222969704226318, 0.1971035981559942, 0.3370545323977565, 0.2915631131514015, 0.2631696010212998, 0.28266814135970175, 0.2545950968525381, 0.23443404208008423, 0.27872565991797915, 0.29236532880326027, 0.2846885922197856, 0.2795686791733427, 0.22804063504413763, 0.19258150404602026, 0.23416578679225863, 0.20352583786546963, 0.20717979619202664, 0.17512893086659753, 0.22160308336762413, 0.22804313370465612, 0.21915684395892931, 0.18908813501361632, 0.17079934041368217, 0.17177489544080238, 0.17704592116144846, 0.18118821348623737, 0.17809420476787874, 0.17775590335163471, 0.206728362256554, 0.19042325886574185, 0.19072141796360798, 0.20708449878617063, 0.21776916142881442, 0.19864304601679117, 0.1784266230160374, 0.18479795624277462, 0.21614367460058825, 0.1847424949658062, 0.2039222438571181, 0.6394295150533678, 0.709437038437505, 0.7272318055454359, 0.5459823777417234, 0.1983296595458679, 0.4496339112997588, 0.25540549812494295, 0.29281538805566965, 0.7376930203897825, 0.5344888407338009, 0.20672273819014408, 0.20382124454786565, 0.48192720836055014, 0.34688484757813565, 0.4575825880974329, 0.20682700934964893, 0.20496293634642548, 0.6488622698891036, 0.18509977707364345, 0.191089084099894, 0.18985410408145043, 0.20991206604435897, 0.18978085941796408, 0.19381728563676692, 0.2088429573450009, 0.18922114346994845, 0.18003992478764397, 0.06385995992359572, 0.06776328975003743, 0.08246546412260414, 0.06396501809912802, 0.07245866633439724, 0.07308179633849543, 0.07386375926689548, 0.07343376732690299, 0.07683714007868037]}, "mutation_prompt": null}
{"id": "1e147b4e-66fb-40bc-ad37-a1a7d684adbf", "solution": "import numpy as np\n\nclass MemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Local search on best individual\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            best_fitness = fitness[best_index]\n            \n            # Perform a simple random neighborhood search around the best individual\n            local_neighbors = best_individual + np.random.uniform(-0.1, 0.1, (10, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n            \n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_index]\n                best_fitness = local_fitness[best_index]\n                \n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "MemeticDifferentialEvolution", "description": "A memetic algorithm combining differential evolution and local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.5836225311948049, 0.5895675481708798, 0.5931935339412369, 0.6092798817755256, 0.5971191751395089, 0.6202579917834308, 0.5915666641654593, 0.6329231146089245, 0.614496547496218, 0.3269420225697043, 0.32341007556044665, 0.3067393591575437, 0.33025145964783187, 0.3164549216374125, 0.31410736857977894, 0.3034373833378351, 0.32458656142264397, 0.32448189010106865, 0.0932342943891219, 0.14210171319527398, 0.12124651238007733, 0.1117186560595137, 0.10416462667954152, 0.13469583922195927, 0.10778599739147499, 0.10180983716471348, 0.11519071115675017, 0.09089923321281623, 0.07916223832856029, 0.09650580656142027, 0.10828047219810033, 0.09519688902934909, 0.11137299647643428, 0.11246531376395619, 0.12295482105811084, 0.09031900319661212, 0.9570017798820938, 0.9513292557106726, 0.9261189549404044, 0.932623940991951, 0.9277210170918078, 0.9656618317581583, 0.9643447913571865, 0.9721847342834466, 0.953476269027666, 0.29421687546028763, 0.31172891459799634, 0.28049672705086315, 0.28360228842594426, 0.29617362506457234, 0.31417605357685474, 0.3030308170377122, 0.2945013636010071, 0.31683005641423334, 0.5179901746271818, 0.4967938945250143, 0.3992218655444725, 0.6421024689794905, 0.4829996488068862, 0.5444143981709784, 0.818801602910831, 0.4169046635013345, 0.5667733833019734, 0.1729377314210867, 0.19408614048524442, 0.2189357195687498, 0.17003335976335543, 0.1734456129185239, 0.22317341038415006, 0.16815520346172597, 0.23471455937223595, 0.18005566062328848, 0.17128012630579414, 0.22078714561119273, 0.18985238237062607, 0.17887929005036718, 0.14169377179786802, 0.17179544957294768, 0.1912676319700436, 0.19817619522267937, 0.1992738826984083, 0.12609625599841567, 0.0884125386662783, 0.07419627554103048, 0.12689456376567354, 0.09695846887388382, 0.10487159974444749, 0.0874590757433692, 0.10069088517058722, 0.08757007935442673, 0.24629823159854047, 0.23721672551643924, 0.1937924518431159, 0.2360613318904099, 0.2283277969657893, 0.21070951185422226, 0.24376182655715817, 0.2505002143128586, 0.24655490215416498, 0.008900204497490405, 0.029919102645743822, 0.0025024944447568087, 0.0084676904081743, 0.012605954307217115, 0.02776100803567294, 0.025295612550901736, 0.023065392675113428, 0.023991856805336775, 0.14806031195500602, 0.16610838876205658, 0.14065028111594324, 0.15394747464367609, 0.14242247562505017, 0.1641355696142669, 0.13765768978862902, 0.14788652466503827, 0.14584253302347738, 0.47246127760880385, 0.468467834239634, 0.488651401632924, 0.46925752632019735, 0.47998205454430665, 0.4819209969882894, 0.48289905070808636, 0.478057701671476, 0.46432681688452015, 0.11941284027623278, 0.0970678050806677, 0.12705107697367768, 0.10342182382932241, 0.10174470673056091, 0.11317706319574627, 0.14065440601023493, 0.09688588256048702, 0.12232279486506359, 0.20147186942807993, 0.22762076159867817, 0.19167359996581346, 0.20502140494458854, 0.3240914377838958, 0.15302899385411983, 0.222969704226318, 0.1971035981559942, 0.3370545323977565, 0.2915631131514015, 0.2631696010212998, 0.28266814135970175, 0.2545950968525381, 0.23443404208008423, 0.27872565991797915, 0.29236532880326027, 0.2846885922197856, 0.2795686791733427, 0.22804063504413763, 0.19258150404602026, 0.23416578679225863, 0.20352583786546963, 0.20717979619202664, 0.17512893086659753, 0.22160308336762413, 0.22804313370465612, 0.21915684395892931, 0.18908813501361632, 0.17079934041368217, 0.17177489544080238, 0.17704592116144846, 0.18118821348623737, 0.17809420476787874, 0.17775590335163471, 0.206728362256554, 0.19042325886574185, 0.19072141796360798, 0.20708449878617063, 0.21776916142881442, 0.19864304601679117, 0.1784266230160374, 0.18479795624277462, 0.21614367460058825, 0.1847424949658062, 0.2039222438571181, 0.6394295150533678, 0.709437038437505, 0.7272318055454359, 0.5459823777417234, 0.1983296595458679, 0.4496339112997588, 0.25540549812494295, 0.29281538805566965, 0.7376930203897825, 0.5344888407338009, 0.20672273819014408, 0.20382124454786565, 0.48192720836055014, 0.34688484757813565, 0.4575825880974329, 0.20682700934964893, 0.20496293634642548, 0.6488622698891036, 0.18509977707364345, 0.191089084099894, 0.18985410408145043, 0.20991206604435897, 0.18978085941796408, 0.19381728563676692, 0.2088429573450009, 0.18922114346994845, 0.18003992478764397, 0.06385995992359572, 0.06776328975003743, 0.08246546412260414, 0.06396501809912802, 0.07245866633439724, 0.07308179633849543, 0.07386375926689548, 0.07343376732690299, 0.07683714007868037]}, "mutation_prompt": null}
{"id": "ead62712-5d13-4e91-b509-ff707ae4cd21", "solution": "import numpy as np\n\nclass AdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Initial differential weight\n        self.CR = 0.9  # Crossover probability\n        self.elitism_rate = 0.2  # Rate of elite individuals for local search\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            # Sort population by fitness\n            sorted_indices = np.argsort(fitness)\n            population = population[sorted_indices]\n            fitness = fitness[sorted_indices]\n\n            # Adaptive differential evolution\n            for i in range(self.population_size):\n                if np.random.rand() < 0.5:  # Adapt F dynamically\n                    self.F = 0.5 * np.random.rand() + 0.5\n                \n                # Mutation and crossover with elitism\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Elitist local search on top individuals\n            num_elites = int(self.elitism_rate * self.population_size)\n            for j in range(num_elites):\n                elite_individual = population[j]\n                elite_fitness = fitness[j]\n                \n                # Random local search around elite individual\n                local_neighbors = elite_individual + np.random.uniform(-0.1, 0.1, (5, self.dim))\n                local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n                local_fitness = np.array([func(ind) for ind in local_neighbors])\n                eval_count += len(local_neighbors)\n                \n                # Update elite if any local neighbor is better\n                if np.min(local_fitness) < elite_fitness:\n                    best_index = np.argmin(local_fitness)\n                    population[j] = local_neighbors[best_index]\n                    fitness[j] = local_fitness[best_index]\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveMemeticDifferentialEvolution", "description": "A memetic algorithm that integrates adaptive differential evolution and elitist local search to enhance convergence speed and solution quality.", "configspace": "", "generation": 24, "fitness": 0.2509396304747149, "feedback": "The algorithm AdaptiveMemeticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.19.", "error": "", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.5288792933699159, 0.4970656450548173, 0.5008651008110099, 0.5359278395953344, 0.4809266430477249, 0.527889381218452, 0.5280510541059987, 0.5614659741900836, 0.5075072002756573, 0.19817491528077846, 0.16323253731032494, 0.18312674199218137, 0.18038687366690997, 0.18943585492554493, 0.20323681624208056, 0.1960874501689125, 0.1800440526077176, 0.19081270536628303, 0.1287976634337027, 0.11384313385271128, 0.11143939741000108, 0.11558162453435017, 0.1183223218944478, 0.11418246526914266, 0.11679193407282495, 0.1282097610619456, 0.11920272588488201, 0.1011311797742599, 0.11229389136025925, 0.13058254484423737, 0.09525224655954312, 0.09288003525770006, 0.10329642642974357, 0.09815874561241167, 0.11350581355904943, 0.11089506076155753, 0.9270127465082362, 0.9500411499960428, 0.9153783145430884, 0.8754351160142011, 0.8938728737525217, 0.9322497274920574, 0.9509492150681939, 0.8947654087815708, 0.9318556121907505, 0.24015746794418968, 0.2495777059755756, 0.2569536991097602, 0.2514853332787722, 0.24756623294704427, 0.24281531795198796, 0.25743780295928453, 0.3280388001247847, 0.26125100195622497, 0.4747652613687513, 0.5394801489893729, 0.4379871778775043, 0.4609321895919446, 0.3395421009547661, 0.5162416636165851, 0.5448656321257428, 0.5313407633173317, 0.4893126968320567, 0.1838816442374317, 0.16613939920217868, 0.15352815557509714, 0.18380237392379495, 0.18950954512558127, 0.18066772405331688, 0.20763074941799275, 0.1909604627030268, 0.16710781744821035, 0.15957580138358773, 0.2064435427728104, 0.21127138100177112, 0.17359716868272257, 0.17780271043981988, 0.1575906972666964, 0.1970875814068248, 0.1951905692798045, 0.20724220775264035, 0.057388701503125805, 0.06904735390530437, 0.06928106237437137, 0.09840672510989501, 0.055200475036163654, 0.06377265380204211, 0.06847616193505801, 0.05074796456482178, 0.07438647926064501, 0.1627346557444549, 0.14804179971846065, 0.189637384572092, 0.16959761831222242, 0.1599039517339752, 0.20870641067486173, 0.18995232365561177, 0.15345341194375428, 0.22484929425657596, 0.013897189086883532, 9.999999999998899e-05, 0.004861172594383234, 0.0044192970392061826, 0.008515954900927825, 0.013382753656739577, 0.011974879075484335, 0.023372044135416714, 0.000646662274620069, 0.12172331714061801, 0.11835543135056503, 0.1249323692932508, 0.1220940549651014, 0.1257009539208731, 0.15438783714607507, 0.12904917046509146, 0.1345061643933434, 0.14830144390845656, 0.42887011443400547, 0.4315240463018788, 0.41919704831182336, 0.43620775031073256, 0.41259922083490164, 0.42187935445652713, 0.4340940645228101, 0.40480090490507015, 0.43683849498459626, 0.12525655371298727, 0.11793825270957137, 0.12430615263501299, 0.12141577829124761, 0.14733102425157618, 0.11162077113260671, 0.10710933733584138, 0.10989629634982068, 0.10599873549708172, 0.3350072190752379, 0.21140806632753406, 0.21501389384307568, 0.25232036992833184, 0.226125339814649, 0.21665445298636432, 0.22776276344039936, 0.2679499886249225, 0.27834111281530627, 0.2531938224881366, 0.2510313865270425, 0.2548763291197418, 0.26000052033006116, 0.24032825606488273, 0.23787681772091607, 0.2550348605551821, 0.2757699493250729, 0.2569329525199803, 0.19716564119428093, 0.18247268276007444, 0.20293721445497925, 0.19465543328286228, 0.1841837757283199, 0.1901096969167737, 0.1878544517885724, 0.2069070047923256, 0.21194911053889098, 0.22197690242070056, 0.19422266170457814, 0.24849693196685319, 0.20532922477053195, 0.19747991980080626, 0.19975271868083389, 0.18829988691369604, 0.1967236052623379, 0.19336023598082397, 0.20053378974277303, 0.19954011627800183, 0.18156067724923108, 0.19706006489462247, 0.19922085551425306, 0.19946733606910239, 0.19080775933071625, 0.17136684793745294, 0.18209018488684758, 0.5546806257533572, 0.20315479643592083, 0.44100438214815096, 0.5223420920473824, 0.45121969982393295, 0.5395926086489007, 0.17269936391015694, 0.18882980535467253, 0.44792460191194006, 0.5040465758586031, 0.25874818517998943, 0.489652518001813, 0.3429297964538155, 0.3928132130165526, 0.396550959036138, 0.4435046955860268, 0.20407679225641673, 0.42364444728848616, 0.1808182066336047, 0.17233906566569035, 0.19568918518482936, 0.1949452319474, 0.1914539031628032, 0.18662640857674406, 0.20147349793501135, 0.19342568909428537, 0.18708408224325412, 0.0769094770262202, 0.0713160229242592, 0.07658423579333595, 0.07722515781991879, 0.07471538703443148, 0.07393032308883574, 0.08168171611160047, 0.07671572596296916, 0.07294610708017768]}, "mutation_prompt": null}
{"id": "2f02a570-a927-43d7-8cd4-b9c1de73950b", "solution": "import numpy as np\n\nclass MemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Local search on best individual\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            best_fitness = fitness[best_index]\n            \n            # Perform a simple random neighborhood search around the best individual\n            local_neighbors = best_individual + np.random.uniform(-0.1, 0.1, (10, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n            \n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_index]\n                best_fitness = local_fitness[best_index]\n                \n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "MemeticDifferentialEvolution", "description": "A memetic algorithm combining differential evolution and local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.5836225311948049, 0.5895675481708798, 0.5931935339412369, 0.6092798817755256, 0.5971191751395089, 0.6202579917834308, 0.5915666641654593, 0.6329231146089245, 0.614496547496218, 0.3269420225697043, 0.32341007556044665, 0.3067393591575437, 0.33025145964783187, 0.3164549216374125, 0.31410736857977894, 0.3034373833378351, 0.32458656142264397, 0.32448189010106865, 0.0932342943891219, 0.14210171319527398, 0.12124651238007733, 0.1117186560595137, 0.10416462667954152, 0.13469583922195927, 0.10778599739147499, 0.10180983716471348, 0.11519071115675017, 0.09089923321281623, 0.07916223832856029, 0.09650580656142027, 0.10828047219810033, 0.09519688902934909, 0.11137299647643428, 0.11246531376395619, 0.12295482105811084, 0.09031900319661212, 0.9570017798820938, 0.9513292557106726, 0.9261189549404044, 0.932623940991951, 0.9277210170918078, 0.9656618317581583, 0.9643447913571865, 0.9721847342834466, 0.953476269027666, 0.29421687546028763, 0.31172891459799634, 0.28049672705086315, 0.28360228842594426, 0.29617362506457234, 0.31417605357685474, 0.3030308170377122, 0.2945013636010071, 0.31683005641423334, 0.5179901746271818, 0.4967938945250143, 0.3992218655444725, 0.6421024689794905, 0.4829996488068862, 0.5444143981709784, 0.818801602910831, 0.4169046635013345, 0.5667733833019734, 0.1729377314210867, 0.19408614048524442, 0.2189357195687498, 0.17003335976335543, 0.1734456129185239, 0.22317341038415006, 0.16815520346172597, 0.23471455937223595, 0.18005566062328848, 0.17128012630579414, 0.22078714561119273, 0.18985238237062607, 0.17887929005036718, 0.14169377179786802, 0.17179544957294768, 0.1912676319700436, 0.19817619522267937, 0.1992738826984083, 0.12609625599841567, 0.0884125386662783, 0.07419627554103048, 0.12689456376567354, 0.09695846887388382, 0.10487159974444749, 0.0874590757433692, 0.10069088517058722, 0.08757007935442673, 0.24629823159854047, 0.23721672551643924, 0.1937924518431159, 0.2360613318904099, 0.2283277969657893, 0.21070951185422226, 0.24376182655715817, 0.2505002143128586, 0.24655490215416498, 0.008900204497490405, 0.029919102645743822, 0.0025024944447568087, 0.0084676904081743, 0.012605954307217115, 0.02776100803567294, 0.025295612550901736, 0.023065392675113428, 0.023991856805336775, 0.14806031195500602, 0.16610838876205658, 0.14065028111594324, 0.15394747464367609, 0.14242247562505017, 0.1641355696142669, 0.13765768978862902, 0.14788652466503827, 0.14584253302347738, 0.47246127760880385, 0.468467834239634, 0.488651401632924, 0.46925752632019735, 0.47998205454430665, 0.4819209969882894, 0.48289905070808636, 0.478057701671476, 0.46432681688452015, 0.11941284027623278, 0.0970678050806677, 0.12705107697367768, 0.10342182382932241, 0.10174470673056091, 0.11317706319574627, 0.14065440601023493, 0.09688588256048702, 0.12232279486506359, 0.20147186942807993, 0.22762076159867817, 0.19167359996581346, 0.20502140494458854, 0.3240914377838958, 0.15302899385411983, 0.222969704226318, 0.1971035981559942, 0.3370545323977565, 0.2915631131514015, 0.2631696010212998, 0.28266814135970175, 0.2545950968525381, 0.23443404208008423, 0.27872565991797915, 0.29236532880326027, 0.2846885922197856, 0.2795686791733427, 0.22804063504413763, 0.19258150404602026, 0.23416578679225863, 0.20352583786546963, 0.20717979619202664, 0.17512893086659753, 0.22160308336762413, 0.22804313370465612, 0.21915684395892931, 0.18908813501361632, 0.17079934041368217, 0.17177489544080238, 0.17704592116144846, 0.18118821348623737, 0.17809420476787874, 0.17775590335163471, 0.206728362256554, 0.19042325886574185, 0.19072141796360798, 0.20708449878617063, 0.21776916142881442, 0.19864304601679117, 0.1784266230160374, 0.18479795624277462, 0.21614367460058825, 0.1847424949658062, 0.2039222438571181, 0.6394295150533678, 0.709437038437505, 0.7272318055454359, 0.5459823777417234, 0.1983296595458679, 0.4496339112997588, 0.25540549812494295, 0.29281538805566965, 0.7376930203897825, 0.5344888407338009, 0.20672273819014408, 0.20382124454786565, 0.48192720836055014, 0.34688484757813565, 0.4575825880974329, 0.20682700934964893, 0.20496293634642548, 0.6488622698891036, 0.18509977707364345, 0.191089084099894, 0.18985410408145043, 0.20991206604435897, 0.18978085941796408, 0.19381728563676692, 0.2088429573450009, 0.18922114346994845, 0.18003992478764397, 0.06385995992359572, 0.06776328975003743, 0.08246546412260414, 0.06396501809912802, 0.07245866633439724, 0.07308179633849543, 0.07386375926689548, 0.07343376732690299, 0.07683714007868037]}, "mutation_prompt": null}
{"id": "e3aa2fd7-f2bb-4cca-864c-1ba068f8d59b", "solution": "import numpy as np\n\nclass MemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Local search on best individual\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            best_fitness = fitness[best_index]\n            \n            # Perform a simple random neighborhood search around the best individual\n            local_neighbors = best_individual + np.random.uniform(-0.1, 0.1, (10, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n            \n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_index]\n                best_fitness = local_fitness[best_index]\n                \n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "MemeticDifferentialEvolution", "description": "A memetic algorithm combining differential evolution and local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.5836225311948049, 0.5895675481708798, 0.5931935339412369, 0.6092798817755256, 0.5971191751395089, 0.6202579917834308, 0.5915666641654593, 0.6329231146089245, 0.614496547496218, 0.3269420225697043, 0.32341007556044665, 0.3067393591575437, 0.33025145964783187, 0.3164549216374125, 0.31410736857977894, 0.3034373833378351, 0.32458656142264397, 0.32448189010106865, 0.0932342943891219, 0.14210171319527398, 0.12124651238007733, 0.1117186560595137, 0.10416462667954152, 0.13469583922195927, 0.10778599739147499, 0.10180983716471348, 0.11519071115675017, 0.09089923321281623, 0.07916223832856029, 0.09650580656142027, 0.10828047219810033, 0.09519688902934909, 0.11137299647643428, 0.11246531376395619, 0.12295482105811084, 0.09031900319661212, 0.9570017798820938, 0.9513292557106726, 0.9261189549404044, 0.932623940991951, 0.9277210170918078, 0.9656618317581583, 0.9643447913571865, 0.9721847342834466, 0.953476269027666, 0.29421687546028763, 0.31172891459799634, 0.28049672705086315, 0.28360228842594426, 0.29617362506457234, 0.31417605357685474, 0.3030308170377122, 0.2945013636010071, 0.31683005641423334, 0.5179901746271818, 0.4967938945250143, 0.3992218655444725, 0.6421024689794905, 0.4829996488068862, 0.5444143981709784, 0.818801602910831, 0.4169046635013345, 0.5667733833019734, 0.1729377314210867, 0.19408614048524442, 0.2189357195687498, 0.17003335976335543, 0.1734456129185239, 0.22317341038415006, 0.16815520346172597, 0.23471455937223595, 0.18005566062328848, 0.17128012630579414, 0.22078714561119273, 0.18985238237062607, 0.17887929005036718, 0.14169377179786802, 0.17179544957294768, 0.1912676319700436, 0.19817619522267937, 0.1992738826984083, 0.12609625599841567, 0.0884125386662783, 0.07419627554103048, 0.12689456376567354, 0.09695846887388382, 0.10487159974444749, 0.0874590757433692, 0.10069088517058722, 0.08757007935442673, 0.24629823159854047, 0.23721672551643924, 0.1937924518431159, 0.2360613318904099, 0.2283277969657893, 0.21070951185422226, 0.24376182655715817, 0.2505002143128586, 0.24655490215416498, 0.008900204497490405, 0.029919102645743822, 0.0025024944447568087, 0.0084676904081743, 0.012605954307217115, 0.02776100803567294, 0.025295612550901736, 0.023065392675113428, 0.023991856805336775, 0.14806031195500602, 0.16610838876205658, 0.14065028111594324, 0.15394747464367609, 0.14242247562505017, 0.1641355696142669, 0.13765768978862902, 0.14788652466503827, 0.14584253302347738, 0.47246127760880385, 0.468467834239634, 0.488651401632924, 0.46925752632019735, 0.47998205454430665, 0.4819209969882894, 0.48289905070808636, 0.478057701671476, 0.46432681688452015, 0.11941284027623278, 0.0970678050806677, 0.12705107697367768, 0.10342182382932241, 0.10174470673056091, 0.11317706319574627, 0.14065440601023493, 0.09688588256048702, 0.12232279486506359, 0.20147186942807993, 0.22762076159867817, 0.19167359996581346, 0.20502140494458854, 0.3240914377838958, 0.15302899385411983, 0.222969704226318, 0.1971035981559942, 0.3370545323977565, 0.2915631131514015, 0.2631696010212998, 0.28266814135970175, 0.2545950968525381, 0.23443404208008423, 0.27872565991797915, 0.29236532880326027, 0.2846885922197856, 0.2795686791733427, 0.22804063504413763, 0.19258150404602026, 0.23416578679225863, 0.20352583786546963, 0.20717979619202664, 0.17512893086659753, 0.22160308336762413, 0.22804313370465612, 0.21915684395892931, 0.18908813501361632, 0.17079934041368217, 0.17177489544080238, 0.17704592116144846, 0.18118821348623737, 0.17809420476787874, 0.17775590335163471, 0.206728362256554, 0.19042325886574185, 0.19072141796360798, 0.20708449878617063, 0.21776916142881442, 0.19864304601679117, 0.1784266230160374, 0.18479795624277462, 0.21614367460058825, 0.1847424949658062, 0.2039222438571181, 0.6394295150533678, 0.709437038437505, 0.7272318055454359, 0.5459823777417234, 0.1983296595458679, 0.4496339112997588, 0.25540549812494295, 0.29281538805566965, 0.7376930203897825, 0.5344888407338009, 0.20672273819014408, 0.20382124454786565, 0.48192720836055014, 0.34688484757813565, 0.4575825880974329, 0.20682700934964893, 0.20496293634642548, 0.6488622698891036, 0.18509977707364345, 0.191089084099894, 0.18985410408145043, 0.20991206604435897, 0.18978085941796408, 0.19381728563676692, 0.2088429573450009, 0.18922114346994845, 0.18003992478764397, 0.06385995992359572, 0.06776328975003743, 0.08246546412260414, 0.06396501809912802, 0.07245866633439724, 0.07308179633849543, 0.07386375926689548, 0.07343376732690299, 0.07683714007868037]}, "mutation_prompt": null}
{"id": "c04c9531-0b7a-4f40-a54d-b022f5954a33", "solution": "import numpy as np\n\nclass MemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Local search on best individual\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            best_fitness = fitness[best_index]\n            \n            # Perform a simple random neighborhood search around the best individual\n            local_neighbors = best_individual + np.random.uniform(-0.1, 0.1, (10, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n            \n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_index]\n                best_fitness = local_fitness[best_index]\n                \n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "MemeticDifferentialEvolution", "description": "A memetic algorithm combining differential evolution and local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.5836225311948049, 0.5895675481708798, 0.5931935339412369, 0.6092798817755256, 0.5971191751395089, 0.6202579917834308, 0.5915666641654593, 0.6329231146089245, 0.614496547496218, 0.3269420225697043, 0.32341007556044665, 0.3067393591575437, 0.33025145964783187, 0.3164549216374125, 0.31410736857977894, 0.3034373833378351, 0.32458656142264397, 0.32448189010106865, 0.0932342943891219, 0.14210171319527398, 0.12124651238007733, 0.1117186560595137, 0.10416462667954152, 0.13469583922195927, 0.10778599739147499, 0.10180983716471348, 0.11519071115675017, 0.09089923321281623, 0.07916223832856029, 0.09650580656142027, 0.10828047219810033, 0.09519688902934909, 0.11137299647643428, 0.11246531376395619, 0.12295482105811084, 0.09031900319661212, 0.9570017798820938, 0.9513292557106726, 0.9261189549404044, 0.932623940991951, 0.9277210170918078, 0.9656618317581583, 0.9643447913571865, 0.9721847342834466, 0.953476269027666, 0.29421687546028763, 0.31172891459799634, 0.28049672705086315, 0.28360228842594426, 0.29617362506457234, 0.31417605357685474, 0.3030308170377122, 0.2945013636010071, 0.31683005641423334, 0.5179901746271818, 0.4967938945250143, 0.3992218655444725, 0.6421024689794905, 0.4829996488068862, 0.5444143981709784, 0.818801602910831, 0.4169046635013345, 0.5667733833019734, 0.1729377314210867, 0.19408614048524442, 0.2189357195687498, 0.17003335976335543, 0.1734456129185239, 0.22317341038415006, 0.16815520346172597, 0.23471455937223595, 0.18005566062328848, 0.17128012630579414, 0.22078714561119273, 0.18985238237062607, 0.17887929005036718, 0.14169377179786802, 0.17179544957294768, 0.1912676319700436, 0.19817619522267937, 0.1992738826984083, 0.12609625599841567, 0.0884125386662783, 0.07419627554103048, 0.12689456376567354, 0.09695846887388382, 0.10487159974444749, 0.0874590757433692, 0.10069088517058722, 0.08757007935442673, 0.24629823159854047, 0.23721672551643924, 0.1937924518431159, 0.2360613318904099, 0.2283277969657893, 0.21070951185422226, 0.24376182655715817, 0.2505002143128586, 0.24655490215416498, 0.008900204497490405, 0.029919102645743822, 0.0025024944447568087, 0.0084676904081743, 0.012605954307217115, 0.02776100803567294, 0.025295612550901736, 0.023065392675113428, 0.023991856805336775, 0.14806031195500602, 0.16610838876205658, 0.14065028111594324, 0.15394747464367609, 0.14242247562505017, 0.1641355696142669, 0.13765768978862902, 0.14788652466503827, 0.14584253302347738, 0.47246127760880385, 0.468467834239634, 0.488651401632924, 0.46925752632019735, 0.47998205454430665, 0.4819209969882894, 0.48289905070808636, 0.478057701671476, 0.46432681688452015, 0.11941284027623278, 0.0970678050806677, 0.12705107697367768, 0.10342182382932241, 0.10174470673056091, 0.11317706319574627, 0.14065440601023493, 0.09688588256048702, 0.12232279486506359, 0.20147186942807993, 0.22762076159867817, 0.19167359996581346, 0.20502140494458854, 0.3240914377838958, 0.15302899385411983, 0.222969704226318, 0.1971035981559942, 0.3370545323977565, 0.2915631131514015, 0.2631696010212998, 0.28266814135970175, 0.2545950968525381, 0.23443404208008423, 0.27872565991797915, 0.29236532880326027, 0.2846885922197856, 0.2795686791733427, 0.22804063504413763, 0.19258150404602026, 0.23416578679225863, 0.20352583786546963, 0.20717979619202664, 0.17512893086659753, 0.22160308336762413, 0.22804313370465612, 0.21915684395892931, 0.18908813501361632, 0.17079934041368217, 0.17177489544080238, 0.17704592116144846, 0.18118821348623737, 0.17809420476787874, 0.17775590335163471, 0.206728362256554, 0.19042325886574185, 0.19072141796360798, 0.20708449878617063, 0.21776916142881442, 0.19864304601679117, 0.1784266230160374, 0.18479795624277462, 0.21614367460058825, 0.1847424949658062, 0.2039222438571181, 0.6394295150533678, 0.709437038437505, 0.7272318055454359, 0.5459823777417234, 0.1983296595458679, 0.4496339112997588, 0.25540549812494295, 0.29281538805566965, 0.7376930203897825, 0.5344888407338009, 0.20672273819014408, 0.20382124454786565, 0.48192720836055014, 0.34688484757813565, 0.4575825880974329, 0.20682700934964893, 0.20496293634642548, 0.6488622698891036, 0.18509977707364345, 0.191089084099894, 0.18985410408145043, 0.20991206604435897, 0.18978085941796408, 0.19381728563676692, 0.2088429573450009, 0.18922114346994845, 0.18003992478764397, 0.06385995992359572, 0.06776328975003743, 0.08246546412260414, 0.06396501809912802, 0.07245866633439724, 0.07308179633849543, 0.07386375926689548, 0.07343376732690299, 0.07683714007868037]}, "mutation_prompt": null}
{"id": "91bcb924-5b7c-4ab4-a01e-e624044d7864", "solution": "import numpy as np\n\nclass MemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Local search on best individual\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            best_fitness = fitness[best_index]\n            \n            # Perform a simple random neighborhood search around the best individual\n            local_neighbors = best_individual + np.random.uniform(-0.1, 0.1, (10, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n            \n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_index]\n                best_fitness = local_fitness[best_index]\n                \n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "MemeticDifferentialEvolution", "description": "A memetic algorithm combining differential evolution and local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.5836225311948049, 0.5895675481708798, 0.5931935339412369, 0.6092798817755256, 0.5971191751395089, 0.6202579917834308, 0.5915666641654593, 0.6329231146089245, 0.614496547496218, 0.3269420225697043, 0.32341007556044665, 0.3067393591575437, 0.33025145964783187, 0.3164549216374125, 0.31410736857977894, 0.3034373833378351, 0.32458656142264397, 0.32448189010106865, 0.0932342943891219, 0.14210171319527398, 0.12124651238007733, 0.1117186560595137, 0.10416462667954152, 0.13469583922195927, 0.10778599739147499, 0.10180983716471348, 0.11519071115675017, 0.09089923321281623, 0.07916223832856029, 0.09650580656142027, 0.10828047219810033, 0.09519688902934909, 0.11137299647643428, 0.11246531376395619, 0.12295482105811084, 0.09031900319661212, 0.9570017798820938, 0.9513292557106726, 0.9261189549404044, 0.932623940991951, 0.9277210170918078, 0.9656618317581583, 0.9643447913571865, 0.9721847342834466, 0.953476269027666, 0.29421687546028763, 0.31172891459799634, 0.28049672705086315, 0.28360228842594426, 0.29617362506457234, 0.31417605357685474, 0.3030308170377122, 0.2945013636010071, 0.31683005641423334, 0.5179901746271818, 0.4967938945250143, 0.3992218655444725, 0.6421024689794905, 0.4829996488068862, 0.5444143981709784, 0.818801602910831, 0.4169046635013345, 0.5667733833019734, 0.1729377314210867, 0.19408614048524442, 0.2189357195687498, 0.17003335976335543, 0.1734456129185239, 0.22317341038415006, 0.16815520346172597, 0.23471455937223595, 0.18005566062328848, 0.17128012630579414, 0.22078714561119273, 0.18985238237062607, 0.17887929005036718, 0.14169377179786802, 0.17179544957294768, 0.1912676319700436, 0.19817619522267937, 0.1992738826984083, 0.12609625599841567, 0.0884125386662783, 0.07419627554103048, 0.12689456376567354, 0.09695846887388382, 0.10487159974444749, 0.0874590757433692, 0.10069088517058722, 0.08757007935442673, 0.24629823159854047, 0.23721672551643924, 0.1937924518431159, 0.2360613318904099, 0.2283277969657893, 0.21070951185422226, 0.24376182655715817, 0.2505002143128586, 0.24655490215416498, 0.008900204497490405, 0.029919102645743822, 0.0025024944447568087, 0.0084676904081743, 0.012605954307217115, 0.02776100803567294, 0.025295612550901736, 0.023065392675113428, 0.023991856805336775, 0.14806031195500602, 0.16610838876205658, 0.14065028111594324, 0.15394747464367609, 0.14242247562505017, 0.1641355696142669, 0.13765768978862902, 0.14788652466503827, 0.14584253302347738, 0.47246127760880385, 0.468467834239634, 0.488651401632924, 0.46925752632019735, 0.47998205454430665, 0.4819209969882894, 0.48289905070808636, 0.478057701671476, 0.46432681688452015, 0.11941284027623278, 0.0970678050806677, 0.12705107697367768, 0.10342182382932241, 0.10174470673056091, 0.11317706319574627, 0.14065440601023493, 0.09688588256048702, 0.12232279486506359, 0.20147186942807993, 0.22762076159867817, 0.19167359996581346, 0.20502140494458854, 0.3240914377838958, 0.15302899385411983, 0.222969704226318, 0.1971035981559942, 0.3370545323977565, 0.2915631131514015, 0.2631696010212998, 0.28266814135970175, 0.2545950968525381, 0.23443404208008423, 0.27872565991797915, 0.29236532880326027, 0.2846885922197856, 0.2795686791733427, 0.22804063504413763, 0.19258150404602026, 0.23416578679225863, 0.20352583786546963, 0.20717979619202664, 0.17512893086659753, 0.22160308336762413, 0.22804313370465612, 0.21915684395892931, 0.18908813501361632, 0.17079934041368217, 0.17177489544080238, 0.17704592116144846, 0.18118821348623737, 0.17809420476787874, 0.17775590335163471, 0.206728362256554, 0.19042325886574185, 0.19072141796360798, 0.20708449878617063, 0.21776916142881442, 0.19864304601679117, 0.1784266230160374, 0.18479795624277462, 0.21614367460058825, 0.1847424949658062, 0.2039222438571181, 0.6394295150533678, 0.709437038437505, 0.7272318055454359, 0.5459823777417234, 0.1983296595458679, 0.4496339112997588, 0.25540549812494295, 0.29281538805566965, 0.7376930203897825, 0.5344888407338009, 0.20672273819014408, 0.20382124454786565, 0.48192720836055014, 0.34688484757813565, 0.4575825880974329, 0.20682700934964893, 0.20496293634642548, 0.6488622698891036, 0.18509977707364345, 0.191089084099894, 0.18985410408145043, 0.20991206604435897, 0.18978085941796408, 0.19381728563676692, 0.2088429573450009, 0.18922114346994845, 0.18003992478764397, 0.06385995992359572, 0.06776328975003743, 0.08246546412260414, 0.06396501809912802, 0.07245866633439724, 0.07308179633849543, 0.07386375926689548, 0.07343376732690299, 0.07683714007868037]}, "mutation_prompt": null}
{"id": "b305c47c-9e15-4c51-b119-8eca9390e2f2", "solution": "import numpy as np\n\nclass MemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Local search on best individual\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            best_fitness = fitness[best_index]\n            \n            # Perform a simple random neighborhood search around the best individual\n            local_neighbors = best_individual + np.random.uniform(-0.1, 0.1, (10, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n            \n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_index]\n                best_fitness = local_fitness[best_index]\n                \n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "MemeticDifferentialEvolution", "description": "A memetic algorithm combining differential evolution and local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.5836225311948049, 0.5895675481708798, 0.5931935339412369, 0.6092798817755256, 0.5971191751395089, 0.6202579917834308, 0.5915666641654593, 0.6329231146089245, 0.614496547496218, 0.3269420225697043, 0.32341007556044665, 0.3067393591575437, 0.33025145964783187, 0.3164549216374125, 0.31410736857977894, 0.3034373833378351, 0.32458656142264397, 0.32448189010106865, 0.0932342943891219, 0.14210171319527398, 0.12124651238007733, 0.1117186560595137, 0.10416462667954152, 0.13469583922195927, 0.10778599739147499, 0.10180983716471348, 0.11519071115675017, 0.09089923321281623, 0.07916223832856029, 0.09650580656142027, 0.10828047219810033, 0.09519688902934909, 0.11137299647643428, 0.11246531376395619, 0.12295482105811084, 0.09031900319661212, 0.9570017798820938, 0.9513292557106726, 0.9261189549404044, 0.932623940991951, 0.9277210170918078, 0.9656618317581583, 0.9643447913571865, 0.9721847342834466, 0.953476269027666, 0.29421687546028763, 0.31172891459799634, 0.28049672705086315, 0.28360228842594426, 0.29617362506457234, 0.31417605357685474, 0.3030308170377122, 0.2945013636010071, 0.31683005641423334, 0.5179901746271818, 0.4967938945250143, 0.3992218655444725, 0.6421024689794905, 0.4829996488068862, 0.5444143981709784, 0.818801602910831, 0.4169046635013345, 0.5667733833019734, 0.1729377314210867, 0.19408614048524442, 0.2189357195687498, 0.17003335976335543, 0.1734456129185239, 0.22317341038415006, 0.16815520346172597, 0.23471455937223595, 0.18005566062328848, 0.17128012630579414, 0.22078714561119273, 0.18985238237062607, 0.17887929005036718, 0.14169377179786802, 0.17179544957294768, 0.1912676319700436, 0.19817619522267937, 0.1992738826984083, 0.12609625599841567, 0.0884125386662783, 0.07419627554103048, 0.12689456376567354, 0.09695846887388382, 0.10487159974444749, 0.0874590757433692, 0.10069088517058722, 0.08757007935442673, 0.24629823159854047, 0.23721672551643924, 0.1937924518431159, 0.2360613318904099, 0.2283277969657893, 0.21070951185422226, 0.24376182655715817, 0.2505002143128586, 0.24655490215416498, 0.008900204497490405, 0.029919102645743822, 0.0025024944447568087, 0.0084676904081743, 0.012605954307217115, 0.02776100803567294, 0.025295612550901736, 0.023065392675113428, 0.023991856805336775, 0.14806031195500602, 0.16610838876205658, 0.14065028111594324, 0.15394747464367609, 0.14242247562505017, 0.1641355696142669, 0.13765768978862902, 0.14788652466503827, 0.14584253302347738, 0.47246127760880385, 0.468467834239634, 0.488651401632924, 0.46925752632019735, 0.47998205454430665, 0.4819209969882894, 0.48289905070808636, 0.478057701671476, 0.46432681688452015, 0.11941284027623278, 0.0970678050806677, 0.12705107697367768, 0.10342182382932241, 0.10174470673056091, 0.11317706319574627, 0.14065440601023493, 0.09688588256048702, 0.12232279486506359, 0.20147186942807993, 0.22762076159867817, 0.19167359996581346, 0.20502140494458854, 0.3240914377838958, 0.15302899385411983, 0.222969704226318, 0.1971035981559942, 0.3370545323977565, 0.2915631131514015, 0.2631696010212998, 0.28266814135970175, 0.2545950968525381, 0.23443404208008423, 0.27872565991797915, 0.29236532880326027, 0.2846885922197856, 0.2795686791733427, 0.22804063504413763, 0.19258150404602026, 0.23416578679225863, 0.20352583786546963, 0.20717979619202664, 0.17512893086659753, 0.22160308336762413, 0.22804313370465612, 0.21915684395892931, 0.18908813501361632, 0.17079934041368217, 0.17177489544080238, 0.17704592116144846, 0.18118821348623737, 0.17809420476787874, 0.17775590335163471, 0.206728362256554, 0.19042325886574185, 0.19072141796360798, 0.20708449878617063, 0.21776916142881442, 0.19864304601679117, 0.1784266230160374, 0.18479795624277462, 0.21614367460058825, 0.1847424949658062, 0.2039222438571181, 0.6394295150533678, 0.709437038437505, 0.7272318055454359, 0.5459823777417234, 0.1983296595458679, 0.4496339112997588, 0.25540549812494295, 0.29281538805566965, 0.7376930203897825, 0.5344888407338009, 0.20672273819014408, 0.20382124454786565, 0.48192720836055014, 0.34688484757813565, 0.4575825880974329, 0.20682700934964893, 0.20496293634642548, 0.6488622698891036, 0.18509977707364345, 0.191089084099894, 0.18985410408145043, 0.20991206604435897, 0.18978085941796408, 0.19381728563676692, 0.2088429573450009, 0.18922114346994845, 0.18003992478764397, 0.06385995992359572, 0.06776328975003743, 0.08246546412260414, 0.06396501809912802, 0.07245866633439724, 0.07308179633849543, 0.07386375926689548, 0.07343376732690299, 0.07683714007868037]}, "mutation_prompt": null}
{"id": "33e88af6-06f7-481a-b74e-1e5527b18d81", "solution": "import numpy as np\n\nclass MemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Local search on best individual\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            best_fitness = fitness[best_index]\n            \n            # Perform a simple random neighborhood search around the best individual\n            local_neighbors = best_individual + np.random.uniform(-0.1, 0.1, (10, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n            \n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_index]\n                best_fitness = local_fitness[best_index]\n                \n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "MemeticDifferentialEvolution", "description": "A memetic algorithm combining differential evolution and local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.5836225311948049, 0.5895675481708798, 0.5931935339412369, 0.6092798817755256, 0.5971191751395089, 0.6202579917834308, 0.5915666641654593, 0.6329231146089245, 0.614496547496218, 0.3269420225697043, 0.32341007556044665, 0.3067393591575437, 0.33025145964783187, 0.3164549216374125, 0.31410736857977894, 0.3034373833378351, 0.32458656142264397, 0.32448189010106865, 0.0932342943891219, 0.14210171319527398, 0.12124651238007733, 0.1117186560595137, 0.10416462667954152, 0.13469583922195927, 0.10778599739147499, 0.10180983716471348, 0.11519071115675017, 0.09089923321281623, 0.07916223832856029, 0.09650580656142027, 0.10828047219810033, 0.09519688902934909, 0.11137299647643428, 0.11246531376395619, 0.12295482105811084, 0.09031900319661212, 0.9570017798820938, 0.9513292557106726, 0.9261189549404044, 0.932623940991951, 0.9277210170918078, 0.9656618317581583, 0.9643447913571865, 0.9721847342834466, 0.953476269027666, 0.29421687546028763, 0.31172891459799634, 0.28049672705086315, 0.28360228842594426, 0.29617362506457234, 0.31417605357685474, 0.3030308170377122, 0.2945013636010071, 0.31683005641423334, 0.5179901746271818, 0.4967938945250143, 0.3992218655444725, 0.6421024689794905, 0.4829996488068862, 0.5444143981709784, 0.818801602910831, 0.4169046635013345, 0.5667733833019734, 0.1729377314210867, 0.19408614048524442, 0.2189357195687498, 0.17003335976335543, 0.1734456129185239, 0.22317341038415006, 0.16815520346172597, 0.23471455937223595, 0.18005566062328848, 0.17128012630579414, 0.22078714561119273, 0.18985238237062607, 0.17887929005036718, 0.14169377179786802, 0.17179544957294768, 0.1912676319700436, 0.19817619522267937, 0.1992738826984083, 0.12609625599841567, 0.0884125386662783, 0.07419627554103048, 0.12689456376567354, 0.09695846887388382, 0.10487159974444749, 0.0874590757433692, 0.10069088517058722, 0.08757007935442673, 0.24629823159854047, 0.23721672551643924, 0.1937924518431159, 0.2360613318904099, 0.2283277969657893, 0.21070951185422226, 0.24376182655715817, 0.2505002143128586, 0.24655490215416498, 0.008900204497490405, 0.029919102645743822, 0.0025024944447568087, 0.0084676904081743, 0.012605954307217115, 0.02776100803567294, 0.025295612550901736, 0.023065392675113428, 0.023991856805336775, 0.14806031195500602, 0.16610838876205658, 0.14065028111594324, 0.15394747464367609, 0.14242247562505017, 0.1641355696142669, 0.13765768978862902, 0.14788652466503827, 0.14584253302347738, 0.47246127760880385, 0.468467834239634, 0.488651401632924, 0.46925752632019735, 0.47998205454430665, 0.4819209969882894, 0.48289905070808636, 0.478057701671476, 0.46432681688452015, 0.11941284027623278, 0.0970678050806677, 0.12705107697367768, 0.10342182382932241, 0.10174470673056091, 0.11317706319574627, 0.14065440601023493, 0.09688588256048702, 0.12232279486506359, 0.20147186942807993, 0.22762076159867817, 0.19167359996581346, 0.20502140494458854, 0.3240914377838958, 0.15302899385411983, 0.222969704226318, 0.1971035981559942, 0.3370545323977565, 0.2915631131514015, 0.2631696010212998, 0.28266814135970175, 0.2545950968525381, 0.23443404208008423, 0.27872565991797915, 0.29236532880326027, 0.2846885922197856, 0.2795686791733427, 0.22804063504413763, 0.19258150404602026, 0.23416578679225863, 0.20352583786546963, 0.20717979619202664, 0.17512893086659753, 0.22160308336762413, 0.22804313370465612, 0.21915684395892931, 0.18908813501361632, 0.17079934041368217, 0.17177489544080238, 0.17704592116144846, 0.18118821348623737, 0.17809420476787874, 0.17775590335163471, 0.206728362256554, 0.19042325886574185, 0.19072141796360798, 0.20708449878617063, 0.21776916142881442, 0.19864304601679117, 0.1784266230160374, 0.18479795624277462, 0.21614367460058825, 0.1847424949658062, 0.2039222438571181, 0.6394295150533678, 0.709437038437505, 0.7272318055454359, 0.5459823777417234, 0.1983296595458679, 0.4496339112997588, 0.25540549812494295, 0.29281538805566965, 0.7376930203897825, 0.5344888407338009, 0.20672273819014408, 0.20382124454786565, 0.48192720836055014, 0.34688484757813565, 0.4575825880974329, 0.20682700934964893, 0.20496293634642548, 0.6488622698891036, 0.18509977707364345, 0.191089084099894, 0.18985410408145043, 0.20991206604435897, 0.18978085941796408, 0.19381728563676692, 0.2088429573450009, 0.18922114346994845, 0.18003992478764397, 0.06385995992359572, 0.06776328975003743, 0.08246546412260414, 0.06396501809912802, 0.07245866633439724, 0.07308179633849543, 0.07386375926689548, 0.07343376732690299, 0.07683714007868037]}, "mutation_prompt": null}
{"id": "eb92d996-9bb2-4cfe-9b58-fae8e301f83e", "solution": "import numpy as np\n\nclass MemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Local search on best individual\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            best_fitness = fitness[best_index]\n            \n            # Perform a simple random neighborhood search around the best individual\n            local_neighbors = best_individual + np.random.uniform(-0.1, 0.1, (10, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n            \n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_index]\n                best_fitness = local_fitness[best_index]\n                \n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "MemeticDifferentialEvolution", "description": "A memetic algorithm combining differential evolution and local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.5836225311948049, 0.5895675481708798, 0.5931935339412369, 0.6092798817755256, 0.5971191751395089, 0.6202579917834308, 0.5915666641654593, 0.6329231146089245, 0.614496547496218, 0.3269420225697043, 0.32341007556044665, 0.3067393591575437, 0.33025145964783187, 0.3164549216374125, 0.31410736857977894, 0.3034373833378351, 0.32458656142264397, 0.32448189010106865, 0.0932342943891219, 0.14210171319527398, 0.12124651238007733, 0.1117186560595137, 0.10416462667954152, 0.13469583922195927, 0.10778599739147499, 0.10180983716471348, 0.11519071115675017, 0.09089923321281623, 0.07916223832856029, 0.09650580656142027, 0.10828047219810033, 0.09519688902934909, 0.11137299647643428, 0.11246531376395619, 0.12295482105811084, 0.09031900319661212, 0.9570017798820938, 0.9513292557106726, 0.9261189549404044, 0.932623940991951, 0.9277210170918078, 0.9656618317581583, 0.9643447913571865, 0.9721847342834466, 0.953476269027666, 0.29421687546028763, 0.31172891459799634, 0.28049672705086315, 0.28360228842594426, 0.29617362506457234, 0.31417605357685474, 0.3030308170377122, 0.2945013636010071, 0.31683005641423334, 0.5179901746271818, 0.4967938945250143, 0.3992218655444725, 0.6421024689794905, 0.4829996488068862, 0.5444143981709784, 0.818801602910831, 0.4169046635013345, 0.5667733833019734, 0.1729377314210867, 0.19408614048524442, 0.2189357195687498, 0.17003335976335543, 0.1734456129185239, 0.22317341038415006, 0.16815520346172597, 0.23471455937223595, 0.18005566062328848, 0.17128012630579414, 0.22078714561119273, 0.18985238237062607, 0.17887929005036718, 0.14169377179786802, 0.17179544957294768, 0.1912676319700436, 0.19817619522267937, 0.1992738826984083, 0.12609625599841567, 0.0884125386662783, 0.07419627554103048, 0.12689456376567354, 0.09695846887388382, 0.10487159974444749, 0.0874590757433692, 0.10069088517058722, 0.08757007935442673, 0.24629823159854047, 0.23721672551643924, 0.1937924518431159, 0.2360613318904099, 0.2283277969657893, 0.21070951185422226, 0.24376182655715817, 0.2505002143128586, 0.24655490215416498, 0.008900204497490405, 0.029919102645743822, 0.0025024944447568087, 0.0084676904081743, 0.012605954307217115, 0.02776100803567294, 0.025295612550901736, 0.023065392675113428, 0.023991856805336775, 0.14806031195500602, 0.16610838876205658, 0.14065028111594324, 0.15394747464367609, 0.14242247562505017, 0.1641355696142669, 0.13765768978862902, 0.14788652466503827, 0.14584253302347738, 0.47246127760880385, 0.468467834239634, 0.488651401632924, 0.46925752632019735, 0.47998205454430665, 0.4819209969882894, 0.48289905070808636, 0.478057701671476, 0.46432681688452015, 0.11941284027623278, 0.0970678050806677, 0.12705107697367768, 0.10342182382932241, 0.10174470673056091, 0.11317706319574627, 0.14065440601023493, 0.09688588256048702, 0.12232279486506359, 0.20147186942807993, 0.22762076159867817, 0.19167359996581346, 0.20502140494458854, 0.3240914377838958, 0.15302899385411983, 0.222969704226318, 0.1971035981559942, 0.3370545323977565, 0.2915631131514015, 0.2631696010212998, 0.28266814135970175, 0.2545950968525381, 0.23443404208008423, 0.27872565991797915, 0.29236532880326027, 0.2846885922197856, 0.2795686791733427, 0.22804063504413763, 0.19258150404602026, 0.23416578679225863, 0.20352583786546963, 0.20717979619202664, 0.17512893086659753, 0.22160308336762413, 0.22804313370465612, 0.21915684395892931, 0.18908813501361632, 0.17079934041368217, 0.17177489544080238, 0.17704592116144846, 0.18118821348623737, 0.17809420476787874, 0.17775590335163471, 0.206728362256554, 0.19042325886574185, 0.19072141796360798, 0.20708449878617063, 0.21776916142881442, 0.19864304601679117, 0.1784266230160374, 0.18479795624277462, 0.21614367460058825, 0.1847424949658062, 0.2039222438571181, 0.6394295150533678, 0.709437038437505, 0.7272318055454359, 0.5459823777417234, 0.1983296595458679, 0.4496339112997588, 0.25540549812494295, 0.29281538805566965, 0.7376930203897825, 0.5344888407338009, 0.20672273819014408, 0.20382124454786565, 0.48192720836055014, 0.34688484757813565, 0.4575825880974329, 0.20682700934964893, 0.20496293634642548, 0.6488622698891036, 0.18509977707364345, 0.191089084099894, 0.18985410408145043, 0.20991206604435897, 0.18978085941796408, 0.19381728563676692, 0.2088429573450009, 0.18922114346994845, 0.18003992478764397, 0.06385995992359572, 0.06776328975003743, 0.08246546412260414, 0.06396501809912802, 0.07245866633439724, 0.07308179633849543, 0.07386375926689548, 0.07343376732690299, 0.07683714007868037]}, "mutation_prompt": null}
{"id": "2a9907a5-cb6e-4136-bf04-e6e857c4fab0", "solution": "import numpy as np\n\nclass MemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Local search on best individual\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            best_fitness = fitness[best_index]\n            \n            # Perform a simple random neighborhood search around the best individual\n            local_neighbors = best_individual + np.random.uniform(-0.1, 0.1, (10, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n            \n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_index]\n                best_fitness = local_fitness[best_index]\n                \n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "MemeticDifferentialEvolution", "description": "A memetic algorithm combining differential evolution and local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.5836225311948049, 0.5895675481708798, 0.5931935339412369, 0.6092798817755256, 0.5971191751395089, 0.6202579917834308, 0.5915666641654593, 0.6329231146089245, 0.614496547496218, 0.3269420225697043, 0.32341007556044665, 0.3067393591575437, 0.33025145964783187, 0.3164549216374125, 0.31410736857977894, 0.3034373833378351, 0.32458656142264397, 0.32448189010106865, 0.0932342943891219, 0.14210171319527398, 0.12124651238007733, 0.1117186560595137, 0.10416462667954152, 0.13469583922195927, 0.10778599739147499, 0.10180983716471348, 0.11519071115675017, 0.09089923321281623, 0.07916223832856029, 0.09650580656142027, 0.10828047219810033, 0.09519688902934909, 0.11137299647643428, 0.11246531376395619, 0.12295482105811084, 0.09031900319661212, 0.9570017798820938, 0.9513292557106726, 0.9261189549404044, 0.932623940991951, 0.9277210170918078, 0.9656618317581583, 0.9643447913571865, 0.9721847342834466, 0.953476269027666, 0.29421687546028763, 0.31172891459799634, 0.28049672705086315, 0.28360228842594426, 0.29617362506457234, 0.31417605357685474, 0.3030308170377122, 0.2945013636010071, 0.31683005641423334, 0.5179901746271818, 0.4967938945250143, 0.3992218655444725, 0.6421024689794905, 0.4829996488068862, 0.5444143981709784, 0.818801602910831, 0.4169046635013345, 0.5667733833019734, 0.1729377314210867, 0.19408614048524442, 0.2189357195687498, 0.17003335976335543, 0.1734456129185239, 0.22317341038415006, 0.16815520346172597, 0.23471455937223595, 0.18005566062328848, 0.17128012630579414, 0.22078714561119273, 0.18985238237062607, 0.17887929005036718, 0.14169377179786802, 0.17179544957294768, 0.1912676319700436, 0.19817619522267937, 0.1992738826984083, 0.12609625599841567, 0.0884125386662783, 0.07419627554103048, 0.12689456376567354, 0.09695846887388382, 0.10487159974444749, 0.0874590757433692, 0.10069088517058722, 0.08757007935442673, 0.24629823159854047, 0.23721672551643924, 0.1937924518431159, 0.2360613318904099, 0.2283277969657893, 0.21070951185422226, 0.24376182655715817, 0.2505002143128586, 0.24655490215416498, 0.008900204497490405, 0.029919102645743822, 0.0025024944447568087, 0.0084676904081743, 0.012605954307217115, 0.02776100803567294, 0.025295612550901736, 0.023065392675113428, 0.023991856805336775, 0.14806031195500602, 0.16610838876205658, 0.14065028111594324, 0.15394747464367609, 0.14242247562505017, 0.1641355696142669, 0.13765768978862902, 0.14788652466503827, 0.14584253302347738, 0.47246127760880385, 0.468467834239634, 0.488651401632924, 0.46925752632019735, 0.47998205454430665, 0.4819209969882894, 0.48289905070808636, 0.478057701671476, 0.46432681688452015, 0.11941284027623278, 0.0970678050806677, 0.12705107697367768, 0.10342182382932241, 0.10174470673056091, 0.11317706319574627, 0.14065440601023493, 0.09688588256048702, 0.12232279486506359, 0.20147186942807993, 0.22762076159867817, 0.19167359996581346, 0.20502140494458854, 0.3240914377838958, 0.15302899385411983, 0.222969704226318, 0.1971035981559942, 0.3370545323977565, 0.2915631131514015, 0.2631696010212998, 0.28266814135970175, 0.2545950968525381, 0.23443404208008423, 0.27872565991797915, 0.29236532880326027, 0.2846885922197856, 0.2795686791733427, 0.22804063504413763, 0.19258150404602026, 0.23416578679225863, 0.20352583786546963, 0.20717979619202664, 0.17512893086659753, 0.22160308336762413, 0.22804313370465612, 0.21915684395892931, 0.18908813501361632, 0.17079934041368217, 0.17177489544080238, 0.17704592116144846, 0.18118821348623737, 0.17809420476787874, 0.17775590335163471, 0.206728362256554, 0.19042325886574185, 0.19072141796360798, 0.20708449878617063, 0.21776916142881442, 0.19864304601679117, 0.1784266230160374, 0.18479795624277462, 0.21614367460058825, 0.1847424949658062, 0.2039222438571181, 0.6394295150533678, 0.709437038437505, 0.7272318055454359, 0.5459823777417234, 0.1983296595458679, 0.4496339112997588, 0.25540549812494295, 0.29281538805566965, 0.7376930203897825, 0.5344888407338009, 0.20672273819014408, 0.20382124454786565, 0.48192720836055014, 0.34688484757813565, 0.4575825880974329, 0.20682700934964893, 0.20496293634642548, 0.6488622698891036, 0.18509977707364345, 0.191089084099894, 0.18985410408145043, 0.20991206604435897, 0.18978085941796408, 0.19381728563676692, 0.2088429573450009, 0.18922114346994845, 0.18003992478764397, 0.06385995992359572, 0.06776328975003743, 0.08246546412260414, 0.06396501809912802, 0.07245866633439724, 0.07308179633849543, 0.07386375926689548, 0.07343376732690299, 0.07683714007868037]}, "mutation_prompt": null}
{"id": "6c10f0d8-7e31-4154-bd83-6553971722b5", "solution": "import numpy as np\n\nclass MemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Local search on best individual\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            best_fitness = fitness[best_index]\n            \n            # Perform a simple random neighborhood search around the best individual\n            local_neighbors = best_individual + np.random.uniform(-0.1, 0.1, (10, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n            \n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_index]\n                best_fitness = local_fitness[best_index]\n                \n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "MemeticDifferentialEvolution", "description": "A memetic algorithm combining differential evolution and local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.5836225311948049, 0.5895675481708798, 0.5931935339412369, 0.6092798817755256, 0.5971191751395089, 0.6202579917834308, 0.5915666641654593, 0.6329231146089245, 0.614496547496218, 0.3269420225697043, 0.32341007556044665, 0.3067393591575437, 0.33025145964783187, 0.3164549216374125, 0.31410736857977894, 0.3034373833378351, 0.32458656142264397, 0.32448189010106865, 0.0932342943891219, 0.14210171319527398, 0.12124651238007733, 0.1117186560595137, 0.10416462667954152, 0.13469583922195927, 0.10778599739147499, 0.10180983716471348, 0.11519071115675017, 0.09089923321281623, 0.07916223832856029, 0.09650580656142027, 0.10828047219810033, 0.09519688902934909, 0.11137299647643428, 0.11246531376395619, 0.12295482105811084, 0.09031900319661212, 0.9570017798820938, 0.9513292557106726, 0.9261189549404044, 0.932623940991951, 0.9277210170918078, 0.9656618317581583, 0.9643447913571865, 0.9721847342834466, 0.953476269027666, 0.29421687546028763, 0.31172891459799634, 0.28049672705086315, 0.28360228842594426, 0.29617362506457234, 0.31417605357685474, 0.3030308170377122, 0.2945013636010071, 0.31683005641423334, 0.5179901746271818, 0.4967938945250143, 0.3992218655444725, 0.6421024689794905, 0.4829996488068862, 0.5444143981709784, 0.818801602910831, 0.4169046635013345, 0.5667733833019734, 0.1729377314210867, 0.19408614048524442, 0.2189357195687498, 0.17003335976335543, 0.1734456129185239, 0.22317341038415006, 0.16815520346172597, 0.23471455937223595, 0.18005566062328848, 0.17128012630579414, 0.22078714561119273, 0.18985238237062607, 0.17887929005036718, 0.14169377179786802, 0.17179544957294768, 0.1912676319700436, 0.19817619522267937, 0.1992738826984083, 0.12609625599841567, 0.0884125386662783, 0.07419627554103048, 0.12689456376567354, 0.09695846887388382, 0.10487159974444749, 0.0874590757433692, 0.10069088517058722, 0.08757007935442673, 0.24629823159854047, 0.23721672551643924, 0.1937924518431159, 0.2360613318904099, 0.2283277969657893, 0.21070951185422226, 0.24376182655715817, 0.2505002143128586, 0.24655490215416498, 0.008900204497490405, 0.029919102645743822, 0.0025024944447568087, 0.0084676904081743, 0.012605954307217115, 0.02776100803567294, 0.025295612550901736, 0.023065392675113428, 0.023991856805336775, 0.14806031195500602, 0.16610838876205658, 0.14065028111594324, 0.15394747464367609, 0.14242247562505017, 0.1641355696142669, 0.13765768978862902, 0.14788652466503827, 0.14584253302347738, 0.47246127760880385, 0.468467834239634, 0.488651401632924, 0.46925752632019735, 0.47998205454430665, 0.4819209969882894, 0.48289905070808636, 0.478057701671476, 0.46432681688452015, 0.11941284027623278, 0.0970678050806677, 0.12705107697367768, 0.10342182382932241, 0.10174470673056091, 0.11317706319574627, 0.14065440601023493, 0.09688588256048702, 0.12232279486506359, 0.20147186942807993, 0.22762076159867817, 0.19167359996581346, 0.20502140494458854, 0.3240914377838958, 0.15302899385411983, 0.222969704226318, 0.1971035981559942, 0.3370545323977565, 0.2915631131514015, 0.2631696010212998, 0.28266814135970175, 0.2545950968525381, 0.23443404208008423, 0.27872565991797915, 0.29236532880326027, 0.2846885922197856, 0.2795686791733427, 0.22804063504413763, 0.19258150404602026, 0.23416578679225863, 0.20352583786546963, 0.20717979619202664, 0.17512893086659753, 0.22160308336762413, 0.22804313370465612, 0.21915684395892931, 0.18908813501361632, 0.17079934041368217, 0.17177489544080238, 0.17704592116144846, 0.18118821348623737, 0.17809420476787874, 0.17775590335163471, 0.206728362256554, 0.19042325886574185, 0.19072141796360798, 0.20708449878617063, 0.21776916142881442, 0.19864304601679117, 0.1784266230160374, 0.18479795624277462, 0.21614367460058825, 0.1847424949658062, 0.2039222438571181, 0.6394295150533678, 0.709437038437505, 0.7272318055454359, 0.5459823777417234, 0.1983296595458679, 0.4496339112997588, 0.25540549812494295, 0.29281538805566965, 0.7376930203897825, 0.5344888407338009, 0.20672273819014408, 0.20382124454786565, 0.48192720836055014, 0.34688484757813565, 0.4575825880974329, 0.20682700934964893, 0.20496293634642548, 0.6488622698891036, 0.18509977707364345, 0.191089084099894, 0.18985410408145043, 0.20991206604435897, 0.18978085941796408, 0.19381728563676692, 0.2088429573450009, 0.18922114346994845, 0.18003992478764397, 0.06385995992359572, 0.06776328975003743, 0.08246546412260414, 0.06396501809912802, 0.07245866633439724, 0.07308179633849543, 0.07386375926689548, 0.07343376732690299, 0.07683714007868037]}, "mutation_prompt": null}
{"id": "083b6402-b0fa-4214-8091-0e1fa2d22f11", "solution": "import numpy as np\n\nclass MemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Local search on best individual\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            best_fitness = fitness[best_index]\n            \n            # Perform a simple random neighborhood search around the best individual\n            local_neighbors = best_individual + np.random.uniform(-0.1, 0.1, (10, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n            \n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_index]\n                best_fitness = local_fitness[best_index]\n                \n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "MemeticDifferentialEvolution", "description": "A memetic algorithm combining differential evolution and local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.5836225311948049, 0.5895675481708798, 0.5931935339412369, 0.6092798817755256, 0.5971191751395089, 0.6202579917834308, 0.5915666641654593, 0.6329231146089245, 0.614496547496218, 0.3269420225697043, 0.32341007556044665, 0.3067393591575437, 0.33025145964783187, 0.3164549216374125, 0.31410736857977894, 0.3034373833378351, 0.32458656142264397, 0.32448189010106865, 0.0932342943891219, 0.14210171319527398, 0.12124651238007733, 0.1117186560595137, 0.10416462667954152, 0.13469583922195927, 0.10778599739147499, 0.10180983716471348, 0.11519071115675017, 0.09089923321281623, 0.07916223832856029, 0.09650580656142027, 0.10828047219810033, 0.09519688902934909, 0.11137299647643428, 0.11246531376395619, 0.12295482105811084, 0.09031900319661212, 0.9570017798820938, 0.9513292557106726, 0.9261189549404044, 0.932623940991951, 0.9277210170918078, 0.9656618317581583, 0.9643447913571865, 0.9721847342834466, 0.953476269027666, 0.29421687546028763, 0.31172891459799634, 0.28049672705086315, 0.28360228842594426, 0.29617362506457234, 0.31417605357685474, 0.3030308170377122, 0.2945013636010071, 0.31683005641423334, 0.5179901746271818, 0.4967938945250143, 0.3992218655444725, 0.6421024689794905, 0.4829996488068862, 0.5444143981709784, 0.818801602910831, 0.4169046635013345, 0.5667733833019734, 0.1729377314210867, 0.19408614048524442, 0.2189357195687498, 0.17003335976335543, 0.1734456129185239, 0.22317341038415006, 0.16815520346172597, 0.23471455937223595, 0.18005566062328848, 0.17128012630579414, 0.22078714561119273, 0.18985238237062607, 0.17887929005036718, 0.14169377179786802, 0.17179544957294768, 0.1912676319700436, 0.19817619522267937, 0.1992738826984083, 0.12609625599841567, 0.0884125386662783, 0.07419627554103048, 0.12689456376567354, 0.09695846887388382, 0.10487159974444749, 0.0874590757433692, 0.10069088517058722, 0.08757007935442673, 0.24629823159854047, 0.23721672551643924, 0.1937924518431159, 0.2360613318904099, 0.2283277969657893, 0.21070951185422226, 0.24376182655715817, 0.2505002143128586, 0.24655490215416498, 0.008900204497490405, 0.029919102645743822, 0.0025024944447568087, 0.0084676904081743, 0.012605954307217115, 0.02776100803567294, 0.025295612550901736, 0.023065392675113428, 0.023991856805336775, 0.14806031195500602, 0.16610838876205658, 0.14065028111594324, 0.15394747464367609, 0.14242247562505017, 0.1641355696142669, 0.13765768978862902, 0.14788652466503827, 0.14584253302347738, 0.47246127760880385, 0.468467834239634, 0.488651401632924, 0.46925752632019735, 0.47998205454430665, 0.4819209969882894, 0.48289905070808636, 0.478057701671476, 0.46432681688452015, 0.11941284027623278, 0.0970678050806677, 0.12705107697367768, 0.10342182382932241, 0.10174470673056091, 0.11317706319574627, 0.14065440601023493, 0.09688588256048702, 0.12232279486506359, 0.20147186942807993, 0.22762076159867817, 0.19167359996581346, 0.20502140494458854, 0.3240914377838958, 0.15302899385411983, 0.222969704226318, 0.1971035981559942, 0.3370545323977565, 0.2915631131514015, 0.2631696010212998, 0.28266814135970175, 0.2545950968525381, 0.23443404208008423, 0.27872565991797915, 0.29236532880326027, 0.2846885922197856, 0.2795686791733427, 0.22804063504413763, 0.19258150404602026, 0.23416578679225863, 0.20352583786546963, 0.20717979619202664, 0.17512893086659753, 0.22160308336762413, 0.22804313370465612, 0.21915684395892931, 0.18908813501361632, 0.17079934041368217, 0.17177489544080238, 0.17704592116144846, 0.18118821348623737, 0.17809420476787874, 0.17775590335163471, 0.206728362256554, 0.19042325886574185, 0.19072141796360798, 0.20708449878617063, 0.21776916142881442, 0.19864304601679117, 0.1784266230160374, 0.18479795624277462, 0.21614367460058825, 0.1847424949658062, 0.2039222438571181, 0.6394295150533678, 0.709437038437505, 0.7272318055454359, 0.5459823777417234, 0.1983296595458679, 0.4496339112997588, 0.25540549812494295, 0.29281538805566965, 0.7376930203897825, 0.5344888407338009, 0.20672273819014408, 0.20382124454786565, 0.48192720836055014, 0.34688484757813565, 0.4575825880974329, 0.20682700934964893, 0.20496293634642548, 0.6488622698891036, 0.18509977707364345, 0.191089084099894, 0.18985410408145043, 0.20991206604435897, 0.18978085941796408, 0.19381728563676692, 0.2088429573450009, 0.18922114346994845, 0.18003992478764397, 0.06385995992359572, 0.06776328975003743, 0.08246546412260414, 0.06396501809912802, 0.07245866633439724, 0.07308179633849543, 0.07386375926689548, 0.07343376732690299, 0.07683714007868037]}, "mutation_prompt": null}
{"id": "386ef82e-1ede-45b3-9b36-d2c56d387d89", "solution": "import numpy as np\n\nclass MemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Local search on best individual\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            best_fitness = fitness[best_index]\n            \n            # Perform a simple random neighborhood search around the best individual\n            local_neighbors = best_individual + np.random.uniform(-0.1, 0.1, (10, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n            \n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_index]\n                best_fitness = local_fitness[best_index]\n                \n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "MemeticDifferentialEvolution", "description": "A memetic algorithm combining differential evolution and local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.5836225311948049, 0.5895675481708798, 0.5931935339412369, 0.6092798817755256, 0.5971191751395089, 0.6202579917834308, 0.5915666641654593, 0.6329231146089245, 0.614496547496218, 0.3269420225697043, 0.32341007556044665, 0.3067393591575437, 0.33025145964783187, 0.3164549216374125, 0.31410736857977894, 0.3034373833378351, 0.32458656142264397, 0.32448189010106865, 0.0932342943891219, 0.14210171319527398, 0.12124651238007733, 0.1117186560595137, 0.10416462667954152, 0.13469583922195927, 0.10778599739147499, 0.10180983716471348, 0.11519071115675017, 0.09089923321281623, 0.07916223832856029, 0.09650580656142027, 0.10828047219810033, 0.09519688902934909, 0.11137299647643428, 0.11246531376395619, 0.12295482105811084, 0.09031900319661212, 0.9570017798820938, 0.9513292557106726, 0.9261189549404044, 0.932623940991951, 0.9277210170918078, 0.9656618317581583, 0.9643447913571865, 0.9721847342834466, 0.953476269027666, 0.29421687546028763, 0.31172891459799634, 0.28049672705086315, 0.28360228842594426, 0.29617362506457234, 0.31417605357685474, 0.3030308170377122, 0.2945013636010071, 0.31683005641423334, 0.5179901746271818, 0.4967938945250143, 0.3992218655444725, 0.6421024689794905, 0.4829996488068862, 0.5444143981709784, 0.818801602910831, 0.4169046635013345, 0.5667733833019734, 0.1729377314210867, 0.19408614048524442, 0.2189357195687498, 0.17003335976335543, 0.1734456129185239, 0.22317341038415006, 0.16815520346172597, 0.23471455937223595, 0.18005566062328848, 0.17128012630579414, 0.22078714561119273, 0.18985238237062607, 0.17887929005036718, 0.14169377179786802, 0.17179544957294768, 0.1912676319700436, 0.19817619522267937, 0.1992738826984083, 0.12609625599841567, 0.0884125386662783, 0.07419627554103048, 0.12689456376567354, 0.09695846887388382, 0.10487159974444749, 0.0874590757433692, 0.10069088517058722, 0.08757007935442673, 0.24629823159854047, 0.23721672551643924, 0.1937924518431159, 0.2360613318904099, 0.2283277969657893, 0.21070951185422226, 0.24376182655715817, 0.2505002143128586, 0.24655490215416498, 0.008900204497490405, 0.029919102645743822, 0.0025024944447568087, 0.0084676904081743, 0.012605954307217115, 0.02776100803567294, 0.025295612550901736, 0.023065392675113428, 0.023991856805336775, 0.14806031195500602, 0.16610838876205658, 0.14065028111594324, 0.15394747464367609, 0.14242247562505017, 0.1641355696142669, 0.13765768978862902, 0.14788652466503827, 0.14584253302347738, 0.47246127760880385, 0.468467834239634, 0.488651401632924, 0.46925752632019735, 0.47998205454430665, 0.4819209969882894, 0.48289905070808636, 0.478057701671476, 0.46432681688452015, 0.11941284027623278, 0.0970678050806677, 0.12705107697367768, 0.10342182382932241, 0.10174470673056091, 0.11317706319574627, 0.14065440601023493, 0.09688588256048702, 0.12232279486506359, 0.20147186942807993, 0.22762076159867817, 0.19167359996581346, 0.20502140494458854, 0.3240914377838958, 0.15302899385411983, 0.222969704226318, 0.1971035981559942, 0.3370545323977565, 0.2915631131514015, 0.2631696010212998, 0.28266814135970175, 0.2545950968525381, 0.23443404208008423, 0.27872565991797915, 0.29236532880326027, 0.2846885922197856, 0.2795686791733427, 0.22804063504413763, 0.19258150404602026, 0.23416578679225863, 0.20352583786546963, 0.20717979619202664, 0.17512893086659753, 0.22160308336762413, 0.22804313370465612, 0.21915684395892931, 0.18908813501361632, 0.17079934041368217, 0.17177489544080238, 0.17704592116144846, 0.18118821348623737, 0.17809420476787874, 0.17775590335163471, 0.206728362256554, 0.19042325886574185, 0.19072141796360798, 0.20708449878617063, 0.21776916142881442, 0.19864304601679117, 0.1784266230160374, 0.18479795624277462, 0.21614367460058825, 0.1847424949658062, 0.2039222438571181, 0.6394295150533678, 0.709437038437505, 0.7272318055454359, 0.5459823777417234, 0.1983296595458679, 0.4496339112997588, 0.25540549812494295, 0.29281538805566965, 0.7376930203897825, 0.5344888407338009, 0.20672273819014408, 0.20382124454786565, 0.48192720836055014, 0.34688484757813565, 0.4575825880974329, 0.20682700934964893, 0.20496293634642548, 0.6488622698891036, 0.18509977707364345, 0.191089084099894, 0.18985410408145043, 0.20991206604435897, 0.18978085941796408, 0.19381728563676692, 0.2088429573450009, 0.18922114346994845, 0.18003992478764397, 0.06385995992359572, 0.06776328975003743, 0.08246546412260414, 0.06396501809912802, 0.07245866633439724, 0.07308179633849543, 0.07386375926689548, 0.07343376732690299, 0.07683714007868037]}, "mutation_prompt": null}
{"id": "7951ea90-5aef-4b44-bd73-9cddd3c774d2", "solution": "import numpy as np\n\nclass MemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Local search on best individual\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            best_fitness = fitness[best_index]\n            \n            # Perform a simple random neighborhood search around the best individual\n            local_neighbors = best_individual + np.random.uniform(-0.1, 0.1, (10, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n            \n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_index]\n                best_fitness = local_fitness[best_index]\n                \n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "MemeticDifferentialEvolution", "description": "A memetic algorithm combining differential evolution and local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.5836225311948049, 0.5895675481708798, 0.5931935339412369, 0.6092798817755256, 0.5971191751395089, 0.6202579917834308, 0.5915666641654593, 0.6329231146089245, 0.614496547496218, 0.3269420225697043, 0.32341007556044665, 0.3067393591575437, 0.33025145964783187, 0.3164549216374125, 0.31410736857977894, 0.3034373833378351, 0.32458656142264397, 0.32448189010106865, 0.0932342943891219, 0.14210171319527398, 0.12124651238007733, 0.1117186560595137, 0.10416462667954152, 0.13469583922195927, 0.10778599739147499, 0.10180983716471348, 0.11519071115675017, 0.09089923321281623, 0.07916223832856029, 0.09650580656142027, 0.10828047219810033, 0.09519688902934909, 0.11137299647643428, 0.11246531376395619, 0.12295482105811084, 0.09031900319661212, 0.9570017798820938, 0.9513292557106726, 0.9261189549404044, 0.932623940991951, 0.9277210170918078, 0.9656618317581583, 0.9643447913571865, 0.9721847342834466, 0.953476269027666, 0.29421687546028763, 0.31172891459799634, 0.28049672705086315, 0.28360228842594426, 0.29617362506457234, 0.31417605357685474, 0.3030308170377122, 0.2945013636010071, 0.31683005641423334, 0.5179901746271818, 0.4967938945250143, 0.3992218655444725, 0.6421024689794905, 0.4829996488068862, 0.5444143981709784, 0.818801602910831, 0.4169046635013345, 0.5667733833019734, 0.1729377314210867, 0.19408614048524442, 0.2189357195687498, 0.17003335976335543, 0.1734456129185239, 0.22317341038415006, 0.16815520346172597, 0.23471455937223595, 0.18005566062328848, 0.17128012630579414, 0.22078714561119273, 0.18985238237062607, 0.17887929005036718, 0.14169377179786802, 0.17179544957294768, 0.1912676319700436, 0.19817619522267937, 0.1992738826984083, 0.12609625599841567, 0.0884125386662783, 0.07419627554103048, 0.12689456376567354, 0.09695846887388382, 0.10487159974444749, 0.0874590757433692, 0.10069088517058722, 0.08757007935442673, 0.24629823159854047, 0.23721672551643924, 0.1937924518431159, 0.2360613318904099, 0.2283277969657893, 0.21070951185422226, 0.24376182655715817, 0.2505002143128586, 0.24655490215416498, 0.008900204497490405, 0.029919102645743822, 0.0025024944447568087, 0.0084676904081743, 0.012605954307217115, 0.02776100803567294, 0.025295612550901736, 0.023065392675113428, 0.023991856805336775, 0.14806031195500602, 0.16610838876205658, 0.14065028111594324, 0.15394747464367609, 0.14242247562505017, 0.1641355696142669, 0.13765768978862902, 0.14788652466503827, 0.14584253302347738, 0.47246127760880385, 0.468467834239634, 0.488651401632924, 0.46925752632019735, 0.47998205454430665, 0.4819209969882894, 0.48289905070808636, 0.478057701671476, 0.46432681688452015, 0.11941284027623278, 0.0970678050806677, 0.12705107697367768, 0.10342182382932241, 0.10174470673056091, 0.11317706319574627, 0.14065440601023493, 0.09688588256048702, 0.12232279486506359, 0.20147186942807993, 0.22762076159867817, 0.19167359996581346, 0.20502140494458854, 0.3240914377838958, 0.15302899385411983, 0.222969704226318, 0.1971035981559942, 0.3370545323977565, 0.2915631131514015, 0.2631696010212998, 0.28266814135970175, 0.2545950968525381, 0.23443404208008423, 0.27872565991797915, 0.29236532880326027, 0.2846885922197856, 0.2795686791733427, 0.22804063504413763, 0.19258150404602026, 0.23416578679225863, 0.20352583786546963, 0.20717979619202664, 0.17512893086659753, 0.22160308336762413, 0.22804313370465612, 0.21915684395892931, 0.18908813501361632, 0.17079934041368217, 0.17177489544080238, 0.17704592116144846, 0.18118821348623737, 0.17809420476787874, 0.17775590335163471, 0.206728362256554, 0.19042325886574185, 0.19072141796360798, 0.20708449878617063, 0.21776916142881442, 0.19864304601679117, 0.1784266230160374, 0.18479795624277462, 0.21614367460058825, 0.1847424949658062, 0.2039222438571181, 0.6394295150533678, 0.709437038437505, 0.7272318055454359, 0.5459823777417234, 0.1983296595458679, 0.4496339112997588, 0.25540549812494295, 0.29281538805566965, 0.7376930203897825, 0.5344888407338009, 0.20672273819014408, 0.20382124454786565, 0.48192720836055014, 0.34688484757813565, 0.4575825880974329, 0.20682700934964893, 0.20496293634642548, 0.6488622698891036, 0.18509977707364345, 0.191089084099894, 0.18985410408145043, 0.20991206604435897, 0.18978085941796408, 0.19381728563676692, 0.2088429573450009, 0.18922114346994845, 0.18003992478764397, 0.06385995992359572, 0.06776328975003743, 0.08246546412260414, 0.06396501809912802, 0.07245866633439724, 0.07308179633849543, 0.07386375926689548, 0.07343376732690299, 0.07683714007868037]}, "mutation_prompt": null}
{"id": "f04ce4e1-552a-476f-8418-fe8192e188a9", "solution": "import numpy as np\n\nclass AdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_min, self.F_max = 0.5, 1.0  # Adaptive differential weight range\n        self.CR_min, self.CR_max = 0.1, 0.9  # Adaptive crossover probability range\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        stagnation_counter = 0\n        best_fitness = np.min(fitness)\n        \n        while eval_count < self.budget:\n            if stagnation_counter >= 5:  # adaptive adjustment if no improvement\n                self.F_min, self.F_max = 0.6, 1.2\n                self.CR_min, self.CR_max = 0.2, 0.8\n                stagnation_counter = 0\n            \n            for i in range(self.population_size):\n                # Adaptive mutation factor and crossover probability\n                F = np.random.uniform(self.F_min, self.F_max)\n                CR = np.random.uniform(self.CR_min, self.CR_max)\n\n                # Mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        stagnation_counter = 0\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Enhanced local search on best individual\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            \n            # Perform a more extensive random neighborhood search around the best individual\n            local_neighbors = best_individual + np.random.normal(0, 0.1, (20, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n            \n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_index]\n                best_fitness = local_fitness[best_index]\n                stagnation_counter = 0\n            else:\n                stagnation_counter += 1\n                \n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "AdaptiveMemeticDifferentialEvolution", "description": "A memetic algorithm with adaptive differential evolution and enhanced local search for accelerated convergence.", "configspace": "", "generation": 37, "fitness": 0.2350723270716052, "feedback": "The algorithm AdaptiveMemeticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.20.", "error": "", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.5815978166126996, 0.5287802233878852, 0.5472299585724765, 0.5621364039626849, 0.5622332095262139, 0.5601350155403705, 0.5756596035547521, 0.5386634293255346, 0.5594745115943577, 0.22998845575053106, 0.18932383342161097, 0.19854533579839773, 0.20034847777999354, 0.20981589684265634, 0.18619777979514562, 0.19733135866236473, 0.24086190064008828, 0.22512499983028256, 0.14946608049119514, 0.12757978429464945, 0.12758886569381434, 0.12914348023296718, 0.14449620184483558, 0.14101399725760655, 0.15408895104854547, 0.11868527618954672, 0.14444872964788757, 0.11805431730902749, 0.114190588325351, 0.1294328109982038, 0.11675892888616513, 0.12360857675674775, 0.10573957082465335, 0.11732481888959934, 0.11392240177157786, 0.11951883562902188, 0.9445916453136871, 0.9475474520915094, 0.9153183675677324, 0.9303025311507896, 0.9302953137656084, 0.9461034081749717, 0.9499971280129165, 0.9204856043820221, 0.9599072203301977, 0.31244838216961557, 0.3013589629914464, 0.31520188091016266, 0.27828400638429407, 0.26860612334963707, 0.2603203762798375, 0.3098531785241071, 0.2983819724206992, 0.3157588521963628, 0.20116846622896967, 0.21846973964930194, 0.2655779282493306, 0.2878887710952359, 0.26810277420736817, 0.334788799288822, 0.21362174764138364, 0.3041266561902012, 0.24144702137331475, 0.18973720465689004, 0.13384856185941318, 0.20276070793771717, 0.16048938531444146, 0.21237647294926287, 0.15218694273612932, 0.18315238811421453, 0.15514084906871917, 0.1764378242094603, 0.14806272745450566, 0.11638021112833519, 0.14666208977460304, 0.15260895074139136, 0.14937032378580029, 0.18167227525253604, 0.16874969844156618, 0.14357411726055547, 0.1499080314647263, 0.03555895417041133, 0.0011554143517907844, 9.999999999998899e-05, 0.018086973593612887, 0.00692134958170687, 0.009968498647857094, 9.999999999998899e-05, 0.0018494703229238185, 9.999999999998899e-05, 0.07035506521171242, 0.07614197671379097, 0.06749866145770433, 0.06875841677816097, 0.04821451366425922, 0.08096097561207238, 0.09270744962009536, 0.07605430961334203, 0.06625941723020512, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09736078098482648, 0.09798109542683853, 0.10073163976178512, 0.0954142300279045, 0.06997022128731367, 0.0859136055137315, 0.09454395859983866, 0.1012884559863334, 0.08449034810186973, 0.4139731955196909, 0.4336337913934927, 0.42462413862354664, 0.40836516487838903, 0.43162729778664055, 0.41255640061188614, 0.46707992964387857, 0.3955628543159241, 0.42902572991816124, 0.1084341169630223, 0.11566312990963834, 0.08788719865999428, 0.12677637580369916, 0.08548806786636365, 0.08806846499957044, 0.08447634874446253, 0.0811973722234034, 0.07624661745508088, 0.18201894376901773, 0.21964413256822368, 0.1893599590096956, 0.30100703050210675, 0.3129574530246255, 0.24724831104665113, 0.2855782205076268, 0.160536159609746, 0.23926025755543234, 0.23797604364776648, 0.2979728928940635, 0.29763248303071155, 0.27948667396340465, 0.2388221711894526, 0.24635269705264984, 0.24426548786529523, 0.2617626208702477, 0.2742230719263722, 0.18140606938197967, 0.18843361553958315, 0.22636313498892768, 0.15811632484762417, 0.17120437309959435, 0.16151887858862224, 0.18115953363548032, 0.22625521951638383, 0.18442329206502883, 0.20997592743353133, 0.17779754014133142, 0.18390459547038196, 0.1902331216494616, 0.18518113284919469, 0.18262409431093551, 0.2062812784453112, 0.2295533623096223, 0.18439780811573248, 0.2000249633522233, 0.21322308195372375, 0.1976514189269417, 0.19831690614690822, 0.20145514149968324, 0.1772259381038921, 0.1970972345268449, 0.18932576293239212, 0.18180839404750615, 0.6522461688513017, 0.649814686877539, 0.20681627728392227, 0.17480286136696543, 0.5653570004465269, 0.6715146011497519, 0.6046200780824265, 0.44057387934098835, 0.1658006069356781, 0.4449984028727588, 0.43152552250377263, 0.3432873867987406, 0.20967654464395047, 0.3570861447936058, 0.33399526229019916, 0.20393599351359604, 0.20846854072678922, 0.20931380354156115, 0.19474530071523055, 0.19403043981277157, 0.1904235382953131, 0.19931942341879327, 0.21447663278396278, 0.17575948236865246, 0.1738055595985566, 0.20379451470555654, 0.17284039894595538, 0.0878984597167799, 0.08289661869825082, 0.07287907501136981, 0.08657183245436262, 0.074167838637476, 0.08086412601115478, 0.08036154372042892, 0.06558197187939863, 0.07865389840453085]}, "mutation_prompt": null}
{"id": "ffae42db-53d1-4f73-b05a-10c74b19e985", "solution": "import numpy as np\n\nclass MemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Local search on best individual\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            best_fitness = fitness[best_index]\n            \n            # Perform a simple random neighborhood search around the best individual\n            local_neighbors = best_individual + np.random.uniform(-0.1, 0.1, (10, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n            \n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_index]\n                best_fitness = local_fitness[best_index]\n                \n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "MemeticDifferentialEvolution", "description": "A memetic algorithm combining differential evolution and local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.5836225311948049, 0.5895675481708798, 0.5931935339412369, 0.6092798817755256, 0.5971191751395089, 0.6202579917834308, 0.5915666641654593, 0.6329231146089245, 0.614496547496218, 0.3269420225697043, 0.32341007556044665, 0.3067393591575437, 0.33025145964783187, 0.3164549216374125, 0.31410736857977894, 0.3034373833378351, 0.32458656142264397, 0.32448189010106865, 0.0932342943891219, 0.14210171319527398, 0.12124651238007733, 0.1117186560595137, 0.10416462667954152, 0.13469583922195927, 0.10778599739147499, 0.10180983716471348, 0.11519071115675017, 0.09089923321281623, 0.07916223832856029, 0.09650580656142027, 0.10828047219810033, 0.09519688902934909, 0.11137299647643428, 0.11246531376395619, 0.12295482105811084, 0.09031900319661212, 0.9570017798820938, 0.9513292557106726, 0.9261189549404044, 0.932623940991951, 0.9277210170918078, 0.9656618317581583, 0.9643447913571865, 0.9721847342834466, 0.953476269027666, 0.29421687546028763, 0.31172891459799634, 0.28049672705086315, 0.28360228842594426, 0.29617362506457234, 0.31417605357685474, 0.3030308170377122, 0.2945013636010071, 0.31683005641423334, 0.5179901746271818, 0.4967938945250143, 0.3992218655444725, 0.6421024689794905, 0.4829996488068862, 0.5444143981709784, 0.818801602910831, 0.4169046635013345, 0.5667733833019734, 0.1729377314210867, 0.19408614048524442, 0.2189357195687498, 0.17003335976335543, 0.1734456129185239, 0.22317341038415006, 0.16815520346172597, 0.23471455937223595, 0.18005566062328848, 0.17128012630579414, 0.22078714561119273, 0.18985238237062607, 0.17887929005036718, 0.14169377179786802, 0.17179544957294768, 0.1912676319700436, 0.19817619522267937, 0.1992738826984083, 0.12609625599841567, 0.0884125386662783, 0.07419627554103048, 0.12689456376567354, 0.09695846887388382, 0.10487159974444749, 0.0874590757433692, 0.10069088517058722, 0.08757007935442673, 0.24629823159854047, 0.23721672551643924, 0.1937924518431159, 0.2360613318904099, 0.2283277969657893, 0.21070951185422226, 0.24376182655715817, 0.2505002143128586, 0.24655490215416498, 0.008900204497490405, 0.029919102645743822, 0.0025024944447568087, 0.0084676904081743, 0.012605954307217115, 0.02776100803567294, 0.025295612550901736, 0.023065392675113428, 0.023991856805336775, 0.14806031195500602, 0.16610838876205658, 0.14065028111594324, 0.15394747464367609, 0.14242247562505017, 0.1641355696142669, 0.13765768978862902, 0.14788652466503827, 0.14584253302347738, 0.47246127760880385, 0.468467834239634, 0.488651401632924, 0.46925752632019735, 0.47998205454430665, 0.4819209969882894, 0.48289905070808636, 0.478057701671476, 0.46432681688452015, 0.11941284027623278, 0.0970678050806677, 0.12705107697367768, 0.10342182382932241, 0.10174470673056091, 0.11317706319574627, 0.14065440601023493, 0.09688588256048702, 0.12232279486506359, 0.20147186942807993, 0.22762076159867817, 0.19167359996581346, 0.20502140494458854, 0.3240914377838958, 0.15302899385411983, 0.222969704226318, 0.1971035981559942, 0.3370545323977565, 0.2915631131514015, 0.2631696010212998, 0.28266814135970175, 0.2545950968525381, 0.23443404208008423, 0.27872565991797915, 0.29236532880326027, 0.2846885922197856, 0.2795686791733427, 0.22804063504413763, 0.19258150404602026, 0.23416578679225863, 0.20352583786546963, 0.20717979619202664, 0.17512893086659753, 0.22160308336762413, 0.22804313370465612, 0.21915684395892931, 0.18908813501361632, 0.17079934041368217, 0.17177489544080238, 0.17704592116144846, 0.18118821348623737, 0.17809420476787874, 0.17775590335163471, 0.206728362256554, 0.19042325886574185, 0.19072141796360798, 0.20708449878617063, 0.21776916142881442, 0.19864304601679117, 0.1784266230160374, 0.18479795624277462, 0.21614367460058825, 0.1847424949658062, 0.2039222438571181, 0.6394295150533678, 0.709437038437505, 0.7272318055454359, 0.5459823777417234, 0.1983296595458679, 0.4496339112997588, 0.25540549812494295, 0.29281538805566965, 0.7376930203897825, 0.5344888407338009, 0.20672273819014408, 0.20382124454786565, 0.48192720836055014, 0.34688484757813565, 0.4575825880974329, 0.20682700934964893, 0.20496293634642548, 0.6488622698891036, 0.18509977707364345, 0.191089084099894, 0.18985410408145043, 0.20991206604435897, 0.18978085941796408, 0.19381728563676692, 0.2088429573450009, 0.18922114346994845, 0.18003992478764397, 0.06385995992359572, 0.06776328975003743, 0.08246546412260414, 0.06396501809912802, 0.07245866633439724, 0.07308179633849543, 0.07386375926689548, 0.07343376732690299, 0.07683714007868037]}, "mutation_prompt": null}
{"id": "526cae1f-c1d8-41ee-a95f-912561fd9eb9", "solution": "import numpy as np\n\nclass MemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Local search on best individual\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            best_fitness = fitness[best_index]\n            \n            # Perform a simple random neighborhood search around the best individual\n            local_neighbors = best_individual + np.random.uniform(-0.1, 0.1, (10, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n            \n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_index]\n                best_fitness = local_fitness[best_index]\n                \n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "MemeticDifferentialEvolution", "description": "A memetic algorithm combining differential evolution and local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.5836225311948049, 0.5895675481708798, 0.5931935339412369, 0.6092798817755256, 0.5971191751395089, 0.6202579917834308, 0.5915666641654593, 0.6329231146089245, 0.614496547496218, 0.3269420225697043, 0.32341007556044665, 0.3067393591575437, 0.33025145964783187, 0.3164549216374125, 0.31410736857977894, 0.3034373833378351, 0.32458656142264397, 0.32448189010106865, 0.0932342943891219, 0.14210171319527398, 0.12124651238007733, 0.1117186560595137, 0.10416462667954152, 0.13469583922195927, 0.10778599739147499, 0.10180983716471348, 0.11519071115675017, 0.09089923321281623, 0.07916223832856029, 0.09650580656142027, 0.10828047219810033, 0.09519688902934909, 0.11137299647643428, 0.11246531376395619, 0.12295482105811084, 0.09031900319661212, 0.9570017798820938, 0.9513292557106726, 0.9261189549404044, 0.932623940991951, 0.9277210170918078, 0.9656618317581583, 0.9643447913571865, 0.9721847342834466, 0.953476269027666, 0.29421687546028763, 0.31172891459799634, 0.28049672705086315, 0.28360228842594426, 0.29617362506457234, 0.31417605357685474, 0.3030308170377122, 0.2945013636010071, 0.31683005641423334, 0.5179901746271818, 0.4967938945250143, 0.3992218655444725, 0.6421024689794905, 0.4829996488068862, 0.5444143981709784, 0.818801602910831, 0.4169046635013345, 0.5667733833019734, 0.1729377314210867, 0.19408614048524442, 0.2189357195687498, 0.17003335976335543, 0.1734456129185239, 0.22317341038415006, 0.16815520346172597, 0.23471455937223595, 0.18005566062328848, 0.17128012630579414, 0.22078714561119273, 0.18985238237062607, 0.17887929005036718, 0.14169377179786802, 0.17179544957294768, 0.1912676319700436, 0.19817619522267937, 0.1992738826984083, 0.12609625599841567, 0.0884125386662783, 0.07419627554103048, 0.12689456376567354, 0.09695846887388382, 0.10487159974444749, 0.0874590757433692, 0.10069088517058722, 0.08757007935442673, 0.24629823159854047, 0.23721672551643924, 0.1937924518431159, 0.2360613318904099, 0.2283277969657893, 0.21070951185422226, 0.24376182655715817, 0.2505002143128586, 0.24655490215416498, 0.008900204497490405, 0.029919102645743822, 0.0025024944447568087, 0.0084676904081743, 0.012605954307217115, 0.02776100803567294, 0.025295612550901736, 0.023065392675113428, 0.023991856805336775, 0.14806031195500602, 0.16610838876205658, 0.14065028111594324, 0.15394747464367609, 0.14242247562505017, 0.1641355696142669, 0.13765768978862902, 0.14788652466503827, 0.14584253302347738, 0.47246127760880385, 0.468467834239634, 0.488651401632924, 0.46925752632019735, 0.47998205454430665, 0.4819209969882894, 0.48289905070808636, 0.478057701671476, 0.46432681688452015, 0.11941284027623278, 0.0970678050806677, 0.12705107697367768, 0.10342182382932241, 0.10174470673056091, 0.11317706319574627, 0.14065440601023493, 0.09688588256048702, 0.12232279486506359, 0.20147186942807993, 0.22762076159867817, 0.19167359996581346, 0.20502140494458854, 0.3240914377838958, 0.15302899385411983, 0.222969704226318, 0.1971035981559942, 0.3370545323977565, 0.2915631131514015, 0.2631696010212998, 0.28266814135970175, 0.2545950968525381, 0.23443404208008423, 0.27872565991797915, 0.29236532880326027, 0.2846885922197856, 0.2795686791733427, 0.22804063504413763, 0.19258150404602026, 0.23416578679225863, 0.20352583786546963, 0.20717979619202664, 0.17512893086659753, 0.22160308336762413, 0.22804313370465612, 0.21915684395892931, 0.18908813501361632, 0.17079934041368217, 0.17177489544080238, 0.17704592116144846, 0.18118821348623737, 0.17809420476787874, 0.17775590335163471, 0.206728362256554, 0.19042325886574185, 0.19072141796360798, 0.20708449878617063, 0.21776916142881442, 0.19864304601679117, 0.1784266230160374, 0.18479795624277462, 0.21614367460058825, 0.1847424949658062, 0.2039222438571181, 0.6394295150533678, 0.709437038437505, 0.7272318055454359, 0.5459823777417234, 0.1983296595458679, 0.4496339112997588, 0.25540549812494295, 0.29281538805566965, 0.7376930203897825, 0.5344888407338009, 0.20672273819014408, 0.20382124454786565, 0.48192720836055014, 0.34688484757813565, 0.4575825880974329, 0.20682700934964893, 0.20496293634642548, 0.6488622698891036, 0.18509977707364345, 0.191089084099894, 0.18985410408145043, 0.20991206604435897, 0.18978085941796408, 0.19381728563676692, 0.2088429573450009, 0.18922114346994845, 0.18003992478764397, 0.06385995992359572, 0.06776328975003743, 0.08246546412260414, 0.06396501809912802, 0.07245866633439724, 0.07308179633849543, 0.07386375926689548, 0.07343376732690299, 0.07683714007868037]}, "mutation_prompt": null}
{"id": "f5396d44-75dc-495d-8c37-cf3a185ea5b7", "solution": "import numpy as np\n\nclass MemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Local search on best individual\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            best_fitness = fitness[best_index]\n            \n            # Perform a simple random neighborhood search around the best individual\n            local_neighbors = best_individual + np.random.uniform(-0.1, 0.1, (10, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n            \n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_index]\n                best_fitness = local_fitness[best_index]\n                \n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "MemeticDifferentialEvolution", "description": "A memetic algorithm combining differential evolution and local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.5836225311948049, 0.5895675481708798, 0.5931935339412369, 0.6092798817755256, 0.5971191751395089, 0.6202579917834308, 0.5915666641654593, 0.6329231146089245, 0.614496547496218, 0.3269420225697043, 0.32341007556044665, 0.3067393591575437, 0.33025145964783187, 0.3164549216374125, 0.31410736857977894, 0.3034373833378351, 0.32458656142264397, 0.32448189010106865, 0.0932342943891219, 0.14210171319527398, 0.12124651238007733, 0.1117186560595137, 0.10416462667954152, 0.13469583922195927, 0.10778599739147499, 0.10180983716471348, 0.11519071115675017, 0.09089923321281623, 0.07916223832856029, 0.09650580656142027, 0.10828047219810033, 0.09519688902934909, 0.11137299647643428, 0.11246531376395619, 0.12295482105811084, 0.09031900319661212, 0.9570017798820938, 0.9513292557106726, 0.9261189549404044, 0.932623940991951, 0.9277210170918078, 0.9656618317581583, 0.9643447913571865, 0.9721847342834466, 0.953476269027666, 0.29421687546028763, 0.31172891459799634, 0.28049672705086315, 0.28360228842594426, 0.29617362506457234, 0.31417605357685474, 0.3030308170377122, 0.2945013636010071, 0.31683005641423334, 0.5179901746271818, 0.4967938945250143, 0.3992218655444725, 0.6421024689794905, 0.4829996488068862, 0.5444143981709784, 0.818801602910831, 0.4169046635013345, 0.5667733833019734, 0.1729377314210867, 0.19408614048524442, 0.2189357195687498, 0.17003335976335543, 0.1734456129185239, 0.22317341038415006, 0.16815520346172597, 0.23471455937223595, 0.18005566062328848, 0.17128012630579414, 0.22078714561119273, 0.18985238237062607, 0.17887929005036718, 0.14169377179786802, 0.17179544957294768, 0.1912676319700436, 0.19817619522267937, 0.1992738826984083, 0.12609625599841567, 0.0884125386662783, 0.07419627554103048, 0.12689456376567354, 0.09695846887388382, 0.10487159974444749, 0.0874590757433692, 0.10069088517058722, 0.08757007935442673, 0.24629823159854047, 0.23721672551643924, 0.1937924518431159, 0.2360613318904099, 0.2283277969657893, 0.21070951185422226, 0.24376182655715817, 0.2505002143128586, 0.24655490215416498, 0.008900204497490405, 0.029919102645743822, 0.0025024944447568087, 0.0084676904081743, 0.012605954307217115, 0.02776100803567294, 0.025295612550901736, 0.023065392675113428, 0.023991856805336775, 0.14806031195500602, 0.16610838876205658, 0.14065028111594324, 0.15394747464367609, 0.14242247562505017, 0.1641355696142669, 0.13765768978862902, 0.14788652466503827, 0.14584253302347738, 0.47246127760880385, 0.468467834239634, 0.488651401632924, 0.46925752632019735, 0.47998205454430665, 0.4819209969882894, 0.48289905070808636, 0.478057701671476, 0.46432681688452015, 0.11941284027623278, 0.0970678050806677, 0.12705107697367768, 0.10342182382932241, 0.10174470673056091, 0.11317706319574627, 0.14065440601023493, 0.09688588256048702, 0.12232279486506359, 0.20147186942807993, 0.22762076159867817, 0.19167359996581346, 0.20502140494458854, 0.3240914377838958, 0.15302899385411983, 0.222969704226318, 0.1971035981559942, 0.3370545323977565, 0.2915631131514015, 0.2631696010212998, 0.28266814135970175, 0.2545950968525381, 0.23443404208008423, 0.27872565991797915, 0.29236532880326027, 0.2846885922197856, 0.2795686791733427, 0.22804063504413763, 0.19258150404602026, 0.23416578679225863, 0.20352583786546963, 0.20717979619202664, 0.17512893086659753, 0.22160308336762413, 0.22804313370465612, 0.21915684395892931, 0.18908813501361632, 0.17079934041368217, 0.17177489544080238, 0.17704592116144846, 0.18118821348623737, 0.17809420476787874, 0.17775590335163471, 0.206728362256554, 0.19042325886574185, 0.19072141796360798, 0.20708449878617063, 0.21776916142881442, 0.19864304601679117, 0.1784266230160374, 0.18479795624277462, 0.21614367460058825, 0.1847424949658062, 0.2039222438571181, 0.6394295150533678, 0.709437038437505, 0.7272318055454359, 0.5459823777417234, 0.1983296595458679, 0.4496339112997588, 0.25540549812494295, 0.29281538805566965, 0.7376930203897825, 0.5344888407338009, 0.20672273819014408, 0.20382124454786565, 0.48192720836055014, 0.34688484757813565, 0.4575825880974329, 0.20682700934964893, 0.20496293634642548, 0.6488622698891036, 0.18509977707364345, 0.191089084099894, 0.18985410408145043, 0.20991206604435897, 0.18978085941796408, 0.19381728563676692, 0.2088429573450009, 0.18922114346994845, 0.18003992478764397, 0.06385995992359572, 0.06776328975003743, 0.08246546412260414, 0.06396501809912802, 0.07245866633439724, 0.07308179633849543, 0.07386375926689548, 0.07343376732690299, 0.07683714007868037]}, "mutation_prompt": null}
{"id": "e76b903e-b445-4757-a1cb-b2c4ca7761ab", "solution": "import numpy as np\n\nclass MemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Local search on best individual\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            best_fitness = fitness[best_index]\n            \n            # Perform a simple random neighborhood search around the best individual\n            local_neighbors = best_individual + np.random.uniform(-0.1, 0.1, (10, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n            \n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_index]\n                best_fitness = local_fitness[best_index]\n                \n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "MemeticDifferentialEvolution", "description": "A memetic algorithm combining differential evolution and local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.5836225311948049, 0.5895675481708798, 0.5931935339412369, 0.6092798817755256, 0.5971191751395089, 0.6202579917834308, 0.5915666641654593, 0.6329231146089245, 0.614496547496218, 0.3269420225697043, 0.32341007556044665, 0.3067393591575437, 0.33025145964783187, 0.3164549216374125, 0.31410736857977894, 0.3034373833378351, 0.32458656142264397, 0.32448189010106865, 0.0932342943891219, 0.14210171319527398, 0.12124651238007733, 0.1117186560595137, 0.10416462667954152, 0.13469583922195927, 0.10778599739147499, 0.10180983716471348, 0.11519071115675017, 0.09089923321281623, 0.07916223832856029, 0.09650580656142027, 0.10828047219810033, 0.09519688902934909, 0.11137299647643428, 0.11246531376395619, 0.12295482105811084, 0.09031900319661212, 0.9570017798820938, 0.9513292557106726, 0.9261189549404044, 0.932623940991951, 0.9277210170918078, 0.9656618317581583, 0.9643447913571865, 0.9721847342834466, 0.953476269027666, 0.29421687546028763, 0.31172891459799634, 0.28049672705086315, 0.28360228842594426, 0.29617362506457234, 0.31417605357685474, 0.3030308170377122, 0.2945013636010071, 0.31683005641423334, 0.5179901746271818, 0.4967938945250143, 0.3992218655444725, 0.6421024689794905, 0.4829996488068862, 0.5444143981709784, 0.818801602910831, 0.4169046635013345, 0.5667733833019734, 0.1729377314210867, 0.19408614048524442, 0.2189357195687498, 0.17003335976335543, 0.1734456129185239, 0.22317341038415006, 0.16815520346172597, 0.23471455937223595, 0.18005566062328848, 0.17128012630579414, 0.22078714561119273, 0.18985238237062607, 0.17887929005036718, 0.14169377179786802, 0.17179544957294768, 0.1912676319700436, 0.19817619522267937, 0.1992738826984083, 0.12609625599841567, 0.0884125386662783, 0.07419627554103048, 0.12689456376567354, 0.09695846887388382, 0.10487159974444749, 0.0874590757433692, 0.10069088517058722, 0.08757007935442673, 0.24629823159854047, 0.23721672551643924, 0.1937924518431159, 0.2360613318904099, 0.2283277969657893, 0.21070951185422226, 0.24376182655715817, 0.2505002143128586, 0.24655490215416498, 0.008900204497490405, 0.029919102645743822, 0.0025024944447568087, 0.0084676904081743, 0.012605954307217115, 0.02776100803567294, 0.025295612550901736, 0.023065392675113428, 0.023991856805336775, 0.14806031195500602, 0.16610838876205658, 0.14065028111594324, 0.15394747464367609, 0.14242247562505017, 0.1641355696142669, 0.13765768978862902, 0.14788652466503827, 0.14584253302347738, 0.47246127760880385, 0.468467834239634, 0.488651401632924, 0.46925752632019735, 0.47998205454430665, 0.4819209969882894, 0.48289905070808636, 0.478057701671476, 0.46432681688452015, 0.11941284027623278, 0.0970678050806677, 0.12705107697367768, 0.10342182382932241, 0.10174470673056091, 0.11317706319574627, 0.14065440601023493, 0.09688588256048702, 0.12232279486506359, 0.20147186942807993, 0.22762076159867817, 0.19167359996581346, 0.20502140494458854, 0.3240914377838958, 0.15302899385411983, 0.222969704226318, 0.1971035981559942, 0.3370545323977565, 0.2915631131514015, 0.2631696010212998, 0.28266814135970175, 0.2545950968525381, 0.23443404208008423, 0.27872565991797915, 0.29236532880326027, 0.2846885922197856, 0.2795686791733427, 0.22804063504413763, 0.19258150404602026, 0.23416578679225863, 0.20352583786546963, 0.20717979619202664, 0.17512893086659753, 0.22160308336762413, 0.22804313370465612, 0.21915684395892931, 0.18908813501361632, 0.17079934041368217, 0.17177489544080238, 0.17704592116144846, 0.18118821348623737, 0.17809420476787874, 0.17775590335163471, 0.206728362256554, 0.19042325886574185, 0.19072141796360798, 0.20708449878617063, 0.21776916142881442, 0.19864304601679117, 0.1784266230160374, 0.18479795624277462, 0.21614367460058825, 0.1847424949658062, 0.2039222438571181, 0.6394295150533678, 0.709437038437505, 0.7272318055454359, 0.5459823777417234, 0.1983296595458679, 0.4496339112997588, 0.25540549812494295, 0.29281538805566965, 0.7376930203897825, 0.5344888407338009, 0.20672273819014408, 0.20382124454786565, 0.48192720836055014, 0.34688484757813565, 0.4575825880974329, 0.20682700934964893, 0.20496293634642548, 0.6488622698891036, 0.18509977707364345, 0.191089084099894, 0.18985410408145043, 0.20991206604435897, 0.18978085941796408, 0.19381728563676692, 0.2088429573450009, 0.18922114346994845, 0.18003992478764397, 0.06385995992359572, 0.06776328975003743, 0.08246546412260414, 0.06396501809912802, 0.07245866633439724, 0.07308179633849543, 0.07386375926689548, 0.07343376732690299, 0.07683714007868037]}, "mutation_prompt": null}
{"id": "39bceab3-daeb-492a-af4d-1da3ce837a76", "solution": "import numpy as np\n\nclass MemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Local search on best individual\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            best_fitness = fitness[best_index]\n            \n            # Perform a simple random neighborhood search around the best individual\n            local_neighbors = best_individual + np.random.uniform(-0.1, 0.1, (10, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n            \n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_index]\n                best_fitness = local_fitness[best_index]\n                \n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "MemeticDifferentialEvolution", "description": "A memetic algorithm combining differential evolution and local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.5836225311948049, 0.5895675481708798, 0.5931935339412369, 0.6092798817755256, 0.5971191751395089, 0.6202579917834308, 0.5915666641654593, 0.6329231146089245, 0.614496547496218, 0.3269420225697043, 0.32341007556044665, 0.3067393591575437, 0.33025145964783187, 0.3164549216374125, 0.31410736857977894, 0.3034373833378351, 0.32458656142264397, 0.32448189010106865, 0.0932342943891219, 0.14210171319527398, 0.12124651238007733, 0.1117186560595137, 0.10416462667954152, 0.13469583922195927, 0.10778599739147499, 0.10180983716471348, 0.11519071115675017, 0.09089923321281623, 0.07916223832856029, 0.09650580656142027, 0.10828047219810033, 0.09519688902934909, 0.11137299647643428, 0.11246531376395619, 0.12295482105811084, 0.09031900319661212, 0.9570017798820938, 0.9513292557106726, 0.9261189549404044, 0.932623940991951, 0.9277210170918078, 0.9656618317581583, 0.9643447913571865, 0.9721847342834466, 0.953476269027666, 0.29421687546028763, 0.31172891459799634, 0.28049672705086315, 0.28360228842594426, 0.29617362506457234, 0.31417605357685474, 0.3030308170377122, 0.2945013636010071, 0.31683005641423334, 0.5179901746271818, 0.4967938945250143, 0.3992218655444725, 0.6421024689794905, 0.4829996488068862, 0.5444143981709784, 0.818801602910831, 0.4169046635013345, 0.5667733833019734, 0.1729377314210867, 0.19408614048524442, 0.2189357195687498, 0.17003335976335543, 0.1734456129185239, 0.22317341038415006, 0.16815520346172597, 0.23471455937223595, 0.18005566062328848, 0.17128012630579414, 0.22078714561119273, 0.18985238237062607, 0.17887929005036718, 0.14169377179786802, 0.17179544957294768, 0.1912676319700436, 0.19817619522267937, 0.1992738826984083, 0.12609625599841567, 0.0884125386662783, 0.07419627554103048, 0.12689456376567354, 0.09695846887388382, 0.10487159974444749, 0.0874590757433692, 0.10069088517058722, 0.08757007935442673, 0.24629823159854047, 0.23721672551643924, 0.1937924518431159, 0.2360613318904099, 0.2283277969657893, 0.21070951185422226, 0.24376182655715817, 0.2505002143128586, 0.24655490215416498, 0.008900204497490405, 0.029919102645743822, 0.0025024944447568087, 0.0084676904081743, 0.012605954307217115, 0.02776100803567294, 0.025295612550901736, 0.023065392675113428, 0.023991856805336775, 0.14806031195500602, 0.16610838876205658, 0.14065028111594324, 0.15394747464367609, 0.14242247562505017, 0.1641355696142669, 0.13765768978862902, 0.14788652466503827, 0.14584253302347738, 0.47246127760880385, 0.468467834239634, 0.488651401632924, 0.46925752632019735, 0.47998205454430665, 0.4819209969882894, 0.48289905070808636, 0.478057701671476, 0.46432681688452015, 0.11941284027623278, 0.0970678050806677, 0.12705107697367768, 0.10342182382932241, 0.10174470673056091, 0.11317706319574627, 0.14065440601023493, 0.09688588256048702, 0.12232279486506359, 0.20147186942807993, 0.22762076159867817, 0.19167359996581346, 0.20502140494458854, 0.3240914377838958, 0.15302899385411983, 0.222969704226318, 0.1971035981559942, 0.3370545323977565, 0.2915631131514015, 0.2631696010212998, 0.28266814135970175, 0.2545950968525381, 0.23443404208008423, 0.27872565991797915, 0.29236532880326027, 0.2846885922197856, 0.2795686791733427, 0.22804063504413763, 0.19258150404602026, 0.23416578679225863, 0.20352583786546963, 0.20717979619202664, 0.17512893086659753, 0.22160308336762413, 0.22804313370465612, 0.21915684395892931, 0.18908813501361632, 0.17079934041368217, 0.17177489544080238, 0.17704592116144846, 0.18118821348623737, 0.17809420476787874, 0.17775590335163471, 0.206728362256554, 0.19042325886574185, 0.19072141796360798, 0.20708449878617063, 0.21776916142881442, 0.19864304601679117, 0.1784266230160374, 0.18479795624277462, 0.21614367460058825, 0.1847424949658062, 0.2039222438571181, 0.6394295150533678, 0.709437038437505, 0.7272318055454359, 0.5459823777417234, 0.1983296595458679, 0.4496339112997588, 0.25540549812494295, 0.29281538805566965, 0.7376930203897825, 0.5344888407338009, 0.20672273819014408, 0.20382124454786565, 0.48192720836055014, 0.34688484757813565, 0.4575825880974329, 0.20682700934964893, 0.20496293634642548, 0.6488622698891036, 0.18509977707364345, 0.191089084099894, 0.18985410408145043, 0.20991206604435897, 0.18978085941796408, 0.19381728563676692, 0.2088429573450009, 0.18922114346994845, 0.18003992478764397, 0.06385995992359572, 0.06776328975003743, 0.08246546412260414, 0.06396501809912802, 0.07245866633439724, 0.07308179633849543, 0.07386375926689548, 0.07343376732690299, 0.07683714007868037]}, "mutation_prompt": null}
{"id": "e4982b27-e2ef-4265-b9bb-ff08c71a2430", "solution": "import numpy as np\n\nclass MemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Local search on best individual\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            best_fitness = fitness[best_index]\n            \n            # Perform a simple random neighborhood search around the best individual\n            local_neighbors = best_individual + np.random.uniform(-0.1, 0.1, (10, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n            \n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_index]\n                best_fitness = local_fitness[best_index]\n                \n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "MemeticDifferentialEvolution", "description": "A memetic algorithm combining differential evolution and local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.5836225311948049, 0.5895675481708798, 0.5931935339412369, 0.6092798817755256, 0.5971191751395089, 0.6202579917834308, 0.5915666641654593, 0.6329231146089245, 0.614496547496218, 0.3269420225697043, 0.32341007556044665, 0.3067393591575437, 0.33025145964783187, 0.3164549216374125, 0.31410736857977894, 0.3034373833378351, 0.32458656142264397, 0.32448189010106865, 0.0932342943891219, 0.14210171319527398, 0.12124651238007733, 0.1117186560595137, 0.10416462667954152, 0.13469583922195927, 0.10778599739147499, 0.10180983716471348, 0.11519071115675017, 0.09089923321281623, 0.07916223832856029, 0.09650580656142027, 0.10828047219810033, 0.09519688902934909, 0.11137299647643428, 0.11246531376395619, 0.12295482105811084, 0.09031900319661212, 0.9570017798820938, 0.9513292557106726, 0.9261189549404044, 0.932623940991951, 0.9277210170918078, 0.9656618317581583, 0.9643447913571865, 0.9721847342834466, 0.953476269027666, 0.29421687546028763, 0.31172891459799634, 0.28049672705086315, 0.28360228842594426, 0.29617362506457234, 0.31417605357685474, 0.3030308170377122, 0.2945013636010071, 0.31683005641423334, 0.5179901746271818, 0.4967938945250143, 0.3992218655444725, 0.6421024689794905, 0.4829996488068862, 0.5444143981709784, 0.818801602910831, 0.4169046635013345, 0.5667733833019734, 0.1729377314210867, 0.19408614048524442, 0.2189357195687498, 0.17003335976335543, 0.1734456129185239, 0.22317341038415006, 0.16815520346172597, 0.23471455937223595, 0.18005566062328848, 0.17128012630579414, 0.22078714561119273, 0.18985238237062607, 0.17887929005036718, 0.14169377179786802, 0.17179544957294768, 0.1912676319700436, 0.19817619522267937, 0.1992738826984083, 0.12609625599841567, 0.0884125386662783, 0.07419627554103048, 0.12689456376567354, 0.09695846887388382, 0.10487159974444749, 0.0874590757433692, 0.10069088517058722, 0.08757007935442673, 0.24629823159854047, 0.23721672551643924, 0.1937924518431159, 0.2360613318904099, 0.2283277969657893, 0.21070951185422226, 0.24376182655715817, 0.2505002143128586, 0.24655490215416498, 0.008900204497490405, 0.029919102645743822, 0.0025024944447568087, 0.0084676904081743, 0.012605954307217115, 0.02776100803567294, 0.025295612550901736, 0.023065392675113428, 0.023991856805336775, 0.14806031195500602, 0.16610838876205658, 0.14065028111594324, 0.15394747464367609, 0.14242247562505017, 0.1641355696142669, 0.13765768978862902, 0.14788652466503827, 0.14584253302347738, 0.47246127760880385, 0.468467834239634, 0.488651401632924, 0.46925752632019735, 0.47998205454430665, 0.4819209969882894, 0.48289905070808636, 0.478057701671476, 0.46432681688452015, 0.11941284027623278, 0.0970678050806677, 0.12705107697367768, 0.10342182382932241, 0.10174470673056091, 0.11317706319574627, 0.14065440601023493, 0.09688588256048702, 0.12232279486506359, 0.20147186942807993, 0.22762076159867817, 0.19167359996581346, 0.20502140494458854, 0.3240914377838958, 0.15302899385411983, 0.222969704226318, 0.1971035981559942, 0.3370545323977565, 0.2915631131514015, 0.2631696010212998, 0.28266814135970175, 0.2545950968525381, 0.23443404208008423, 0.27872565991797915, 0.29236532880326027, 0.2846885922197856, 0.2795686791733427, 0.22804063504413763, 0.19258150404602026, 0.23416578679225863, 0.20352583786546963, 0.20717979619202664, 0.17512893086659753, 0.22160308336762413, 0.22804313370465612, 0.21915684395892931, 0.18908813501361632, 0.17079934041368217, 0.17177489544080238, 0.17704592116144846, 0.18118821348623737, 0.17809420476787874, 0.17775590335163471, 0.206728362256554, 0.19042325886574185, 0.19072141796360798, 0.20708449878617063, 0.21776916142881442, 0.19864304601679117, 0.1784266230160374, 0.18479795624277462, 0.21614367460058825, 0.1847424949658062, 0.2039222438571181, 0.6394295150533678, 0.709437038437505, 0.7272318055454359, 0.5459823777417234, 0.1983296595458679, 0.4496339112997588, 0.25540549812494295, 0.29281538805566965, 0.7376930203897825, 0.5344888407338009, 0.20672273819014408, 0.20382124454786565, 0.48192720836055014, 0.34688484757813565, 0.4575825880974329, 0.20682700934964893, 0.20496293634642548, 0.6488622698891036, 0.18509977707364345, 0.191089084099894, 0.18985410408145043, 0.20991206604435897, 0.18978085941796408, 0.19381728563676692, 0.2088429573450009, 0.18922114346994845, 0.18003992478764397, 0.06385995992359572, 0.06776328975003743, 0.08246546412260414, 0.06396501809912802, 0.07245866633439724, 0.07308179633849543, 0.07386375926689548, 0.07343376732690299, 0.07683714007868037]}, "mutation_prompt": null}
{"id": "e5061708-914d-4756-926d-94a0971d1430", "solution": "import numpy as np\n\nclass MemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Local search on best individual\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            best_fitness = fitness[best_index]\n            \n            # Perform a simple random neighborhood search around the best individual\n            local_neighbors = best_individual + np.random.uniform(-0.1, 0.1, (10, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n            \n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_index]\n                best_fitness = local_fitness[best_index]\n                \n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "MemeticDifferentialEvolution", "description": "A memetic algorithm combining differential evolution and local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.5836225311948049, 0.5895675481708798, 0.5931935339412369, 0.6092798817755256, 0.5971191751395089, 0.6202579917834308, 0.5915666641654593, 0.6329231146089245, 0.614496547496218, 0.3269420225697043, 0.32341007556044665, 0.3067393591575437, 0.33025145964783187, 0.3164549216374125, 0.31410736857977894, 0.3034373833378351, 0.32458656142264397, 0.32448189010106865, 0.0932342943891219, 0.14210171319527398, 0.12124651238007733, 0.1117186560595137, 0.10416462667954152, 0.13469583922195927, 0.10778599739147499, 0.10180983716471348, 0.11519071115675017, 0.09089923321281623, 0.07916223832856029, 0.09650580656142027, 0.10828047219810033, 0.09519688902934909, 0.11137299647643428, 0.11246531376395619, 0.12295482105811084, 0.09031900319661212, 0.9570017798820938, 0.9513292557106726, 0.9261189549404044, 0.932623940991951, 0.9277210170918078, 0.9656618317581583, 0.9643447913571865, 0.9721847342834466, 0.953476269027666, 0.29421687546028763, 0.31172891459799634, 0.28049672705086315, 0.28360228842594426, 0.29617362506457234, 0.31417605357685474, 0.3030308170377122, 0.2945013636010071, 0.31683005641423334, 0.5179901746271818, 0.4967938945250143, 0.3992218655444725, 0.6421024689794905, 0.4829996488068862, 0.5444143981709784, 0.818801602910831, 0.4169046635013345, 0.5667733833019734, 0.1729377314210867, 0.19408614048524442, 0.2189357195687498, 0.17003335976335543, 0.1734456129185239, 0.22317341038415006, 0.16815520346172597, 0.23471455937223595, 0.18005566062328848, 0.17128012630579414, 0.22078714561119273, 0.18985238237062607, 0.17887929005036718, 0.14169377179786802, 0.17179544957294768, 0.1912676319700436, 0.19817619522267937, 0.1992738826984083, 0.12609625599841567, 0.0884125386662783, 0.07419627554103048, 0.12689456376567354, 0.09695846887388382, 0.10487159974444749, 0.0874590757433692, 0.10069088517058722, 0.08757007935442673, 0.24629823159854047, 0.23721672551643924, 0.1937924518431159, 0.2360613318904099, 0.2283277969657893, 0.21070951185422226, 0.24376182655715817, 0.2505002143128586, 0.24655490215416498, 0.008900204497490405, 0.029919102645743822, 0.0025024944447568087, 0.0084676904081743, 0.012605954307217115, 0.02776100803567294, 0.025295612550901736, 0.023065392675113428, 0.023991856805336775, 0.14806031195500602, 0.16610838876205658, 0.14065028111594324, 0.15394747464367609, 0.14242247562505017, 0.1641355696142669, 0.13765768978862902, 0.14788652466503827, 0.14584253302347738, 0.47246127760880385, 0.468467834239634, 0.488651401632924, 0.46925752632019735, 0.47998205454430665, 0.4819209969882894, 0.48289905070808636, 0.478057701671476, 0.46432681688452015, 0.11941284027623278, 0.0970678050806677, 0.12705107697367768, 0.10342182382932241, 0.10174470673056091, 0.11317706319574627, 0.14065440601023493, 0.09688588256048702, 0.12232279486506359, 0.20147186942807993, 0.22762076159867817, 0.19167359996581346, 0.20502140494458854, 0.3240914377838958, 0.15302899385411983, 0.222969704226318, 0.1971035981559942, 0.3370545323977565, 0.2915631131514015, 0.2631696010212998, 0.28266814135970175, 0.2545950968525381, 0.23443404208008423, 0.27872565991797915, 0.29236532880326027, 0.2846885922197856, 0.2795686791733427, 0.22804063504413763, 0.19258150404602026, 0.23416578679225863, 0.20352583786546963, 0.20717979619202664, 0.17512893086659753, 0.22160308336762413, 0.22804313370465612, 0.21915684395892931, 0.18908813501361632, 0.17079934041368217, 0.17177489544080238, 0.17704592116144846, 0.18118821348623737, 0.17809420476787874, 0.17775590335163471, 0.206728362256554, 0.19042325886574185, 0.19072141796360798, 0.20708449878617063, 0.21776916142881442, 0.19864304601679117, 0.1784266230160374, 0.18479795624277462, 0.21614367460058825, 0.1847424949658062, 0.2039222438571181, 0.6394295150533678, 0.709437038437505, 0.7272318055454359, 0.5459823777417234, 0.1983296595458679, 0.4496339112997588, 0.25540549812494295, 0.29281538805566965, 0.7376930203897825, 0.5344888407338009, 0.20672273819014408, 0.20382124454786565, 0.48192720836055014, 0.34688484757813565, 0.4575825880974329, 0.20682700934964893, 0.20496293634642548, 0.6488622698891036, 0.18509977707364345, 0.191089084099894, 0.18985410408145043, 0.20991206604435897, 0.18978085941796408, 0.19381728563676692, 0.2088429573450009, 0.18922114346994845, 0.18003992478764397, 0.06385995992359572, 0.06776328975003743, 0.08246546412260414, 0.06396501809912802, 0.07245866633439724, 0.07308179633849543, 0.07386375926689548, 0.07343376732690299, 0.07683714007868037]}, "mutation_prompt": null}
{"id": "948808e9-0205-4406-921c-ac9cb8575ae8", "solution": "import numpy as np\n\nclass MemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Local search on best individual\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            best_fitness = fitness[best_index]\n            \n            # Perform a simple random neighborhood search around the best individual\n            local_neighbors = best_individual + np.random.uniform(-0.1, 0.1, (10, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n            \n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_index]\n                best_fitness = local_fitness[best_index]\n                \n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "MemeticDifferentialEvolution", "description": "A memetic algorithm combining differential evolution and local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.5836225311948049, 0.5895675481708798, 0.5931935339412369, 0.6092798817755256, 0.5971191751395089, 0.6202579917834308, 0.5915666641654593, 0.6329231146089245, 0.614496547496218, 0.3269420225697043, 0.32341007556044665, 0.3067393591575437, 0.33025145964783187, 0.3164549216374125, 0.31410736857977894, 0.3034373833378351, 0.32458656142264397, 0.32448189010106865, 0.0932342943891219, 0.14210171319527398, 0.12124651238007733, 0.1117186560595137, 0.10416462667954152, 0.13469583922195927, 0.10778599739147499, 0.10180983716471348, 0.11519071115675017, 0.09089923321281623, 0.07916223832856029, 0.09650580656142027, 0.10828047219810033, 0.09519688902934909, 0.11137299647643428, 0.11246531376395619, 0.12295482105811084, 0.09031900319661212, 0.9570017798820938, 0.9513292557106726, 0.9261189549404044, 0.932623940991951, 0.9277210170918078, 0.9656618317581583, 0.9643447913571865, 0.9721847342834466, 0.953476269027666, 0.29421687546028763, 0.31172891459799634, 0.28049672705086315, 0.28360228842594426, 0.29617362506457234, 0.31417605357685474, 0.3030308170377122, 0.2945013636010071, 0.31683005641423334, 0.5179901746271818, 0.4967938945250143, 0.3992218655444725, 0.6421024689794905, 0.4829996488068862, 0.5444143981709784, 0.818801602910831, 0.4169046635013345, 0.5667733833019734, 0.1729377314210867, 0.19408614048524442, 0.2189357195687498, 0.17003335976335543, 0.1734456129185239, 0.22317341038415006, 0.16815520346172597, 0.23471455937223595, 0.18005566062328848, 0.17128012630579414, 0.22078714561119273, 0.18985238237062607, 0.17887929005036718, 0.14169377179786802, 0.17179544957294768, 0.1912676319700436, 0.19817619522267937, 0.1992738826984083, 0.12609625599841567, 0.0884125386662783, 0.07419627554103048, 0.12689456376567354, 0.09695846887388382, 0.10487159974444749, 0.0874590757433692, 0.10069088517058722, 0.08757007935442673, 0.24629823159854047, 0.23721672551643924, 0.1937924518431159, 0.2360613318904099, 0.2283277969657893, 0.21070951185422226, 0.24376182655715817, 0.2505002143128586, 0.24655490215416498, 0.008900204497490405, 0.029919102645743822, 0.0025024944447568087, 0.0084676904081743, 0.012605954307217115, 0.02776100803567294, 0.025295612550901736, 0.023065392675113428, 0.023991856805336775, 0.14806031195500602, 0.16610838876205658, 0.14065028111594324, 0.15394747464367609, 0.14242247562505017, 0.1641355696142669, 0.13765768978862902, 0.14788652466503827, 0.14584253302347738, 0.47246127760880385, 0.468467834239634, 0.488651401632924, 0.46925752632019735, 0.47998205454430665, 0.4819209969882894, 0.48289905070808636, 0.478057701671476, 0.46432681688452015, 0.11941284027623278, 0.0970678050806677, 0.12705107697367768, 0.10342182382932241, 0.10174470673056091, 0.11317706319574627, 0.14065440601023493, 0.09688588256048702, 0.12232279486506359, 0.20147186942807993, 0.22762076159867817, 0.19167359996581346, 0.20502140494458854, 0.3240914377838958, 0.15302899385411983, 0.222969704226318, 0.1971035981559942, 0.3370545323977565, 0.2915631131514015, 0.2631696010212998, 0.28266814135970175, 0.2545950968525381, 0.23443404208008423, 0.27872565991797915, 0.29236532880326027, 0.2846885922197856, 0.2795686791733427, 0.22804063504413763, 0.19258150404602026, 0.23416578679225863, 0.20352583786546963, 0.20717979619202664, 0.17512893086659753, 0.22160308336762413, 0.22804313370465612, 0.21915684395892931, 0.18908813501361632, 0.17079934041368217, 0.17177489544080238, 0.17704592116144846, 0.18118821348623737, 0.17809420476787874, 0.17775590335163471, 0.206728362256554, 0.19042325886574185, 0.19072141796360798, 0.20708449878617063, 0.21776916142881442, 0.19864304601679117, 0.1784266230160374, 0.18479795624277462, 0.21614367460058825, 0.1847424949658062, 0.2039222438571181, 0.6394295150533678, 0.709437038437505, 0.7272318055454359, 0.5459823777417234, 0.1983296595458679, 0.4496339112997588, 0.25540549812494295, 0.29281538805566965, 0.7376930203897825, 0.5344888407338009, 0.20672273819014408, 0.20382124454786565, 0.48192720836055014, 0.34688484757813565, 0.4575825880974329, 0.20682700934964893, 0.20496293634642548, 0.6488622698891036, 0.18509977707364345, 0.191089084099894, 0.18985410408145043, 0.20991206604435897, 0.18978085941796408, 0.19381728563676692, 0.2088429573450009, 0.18922114346994845, 0.18003992478764397, 0.06385995992359572, 0.06776328975003743, 0.08246546412260414, 0.06396501809912802, 0.07245866633439724, 0.07308179633849543, 0.07386375926689548, 0.07343376732690299, 0.07683714007868037]}, "mutation_prompt": null}
{"id": "e864e72a-6b2a-44c9-9a57-da121759fcf0", "solution": "import numpy as np\n\nclass MemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Local search on best individual\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            best_fitness = fitness[best_index]\n            \n            # Perform a simple random neighborhood search around the best individual\n            local_neighbors = best_individual + np.random.uniform(-0.1, 0.1, (10, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n            \n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_index]\n                best_fitness = local_fitness[best_index]\n                \n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "MemeticDifferentialEvolution", "description": "A memetic algorithm combining differential evolution and local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.5836225311948049, 0.5895675481708798, 0.5931935339412369, 0.6092798817755256, 0.5971191751395089, 0.6202579917834308, 0.5915666641654593, 0.6329231146089245, 0.614496547496218, 0.3269420225697043, 0.32341007556044665, 0.3067393591575437, 0.33025145964783187, 0.3164549216374125, 0.31410736857977894, 0.3034373833378351, 0.32458656142264397, 0.32448189010106865, 0.0932342943891219, 0.14210171319527398, 0.12124651238007733, 0.1117186560595137, 0.10416462667954152, 0.13469583922195927, 0.10778599739147499, 0.10180983716471348, 0.11519071115675017, 0.09089923321281623, 0.07916223832856029, 0.09650580656142027, 0.10828047219810033, 0.09519688902934909, 0.11137299647643428, 0.11246531376395619, 0.12295482105811084, 0.09031900319661212, 0.9570017798820938, 0.9513292557106726, 0.9261189549404044, 0.932623940991951, 0.9277210170918078, 0.9656618317581583, 0.9643447913571865, 0.9721847342834466, 0.953476269027666, 0.29421687546028763, 0.31172891459799634, 0.28049672705086315, 0.28360228842594426, 0.29617362506457234, 0.31417605357685474, 0.3030308170377122, 0.2945013636010071, 0.31683005641423334, 0.5179901746271818, 0.4967938945250143, 0.3992218655444725, 0.6421024689794905, 0.4829996488068862, 0.5444143981709784, 0.818801602910831, 0.4169046635013345, 0.5667733833019734, 0.1729377314210867, 0.19408614048524442, 0.2189357195687498, 0.17003335976335543, 0.1734456129185239, 0.22317341038415006, 0.16815520346172597, 0.23471455937223595, 0.18005566062328848, 0.17128012630579414, 0.22078714561119273, 0.18985238237062607, 0.17887929005036718, 0.14169377179786802, 0.17179544957294768, 0.1912676319700436, 0.19817619522267937, 0.1992738826984083, 0.12609625599841567, 0.0884125386662783, 0.07419627554103048, 0.12689456376567354, 0.09695846887388382, 0.10487159974444749, 0.0874590757433692, 0.10069088517058722, 0.08757007935442673, 0.24629823159854047, 0.23721672551643924, 0.1937924518431159, 0.2360613318904099, 0.2283277969657893, 0.21070951185422226, 0.24376182655715817, 0.2505002143128586, 0.24655490215416498, 0.008900204497490405, 0.029919102645743822, 0.0025024944447568087, 0.0084676904081743, 0.012605954307217115, 0.02776100803567294, 0.025295612550901736, 0.023065392675113428, 0.023991856805336775, 0.14806031195500602, 0.16610838876205658, 0.14065028111594324, 0.15394747464367609, 0.14242247562505017, 0.1641355696142669, 0.13765768978862902, 0.14788652466503827, 0.14584253302347738, 0.47246127760880385, 0.468467834239634, 0.488651401632924, 0.46925752632019735, 0.47998205454430665, 0.4819209969882894, 0.48289905070808636, 0.478057701671476, 0.46432681688452015, 0.11941284027623278, 0.0970678050806677, 0.12705107697367768, 0.10342182382932241, 0.10174470673056091, 0.11317706319574627, 0.14065440601023493, 0.09688588256048702, 0.12232279486506359, 0.20147186942807993, 0.22762076159867817, 0.19167359996581346, 0.20502140494458854, 0.3240914377838958, 0.15302899385411983, 0.222969704226318, 0.1971035981559942, 0.3370545323977565, 0.2915631131514015, 0.2631696010212998, 0.28266814135970175, 0.2545950968525381, 0.23443404208008423, 0.27872565991797915, 0.29236532880326027, 0.2846885922197856, 0.2795686791733427, 0.22804063504413763, 0.19258150404602026, 0.23416578679225863, 0.20352583786546963, 0.20717979619202664, 0.17512893086659753, 0.22160308336762413, 0.22804313370465612, 0.21915684395892931, 0.18908813501361632, 0.17079934041368217, 0.17177489544080238, 0.17704592116144846, 0.18118821348623737, 0.17809420476787874, 0.17775590335163471, 0.206728362256554, 0.19042325886574185, 0.19072141796360798, 0.20708449878617063, 0.21776916142881442, 0.19864304601679117, 0.1784266230160374, 0.18479795624277462, 0.21614367460058825, 0.1847424949658062, 0.2039222438571181, 0.6394295150533678, 0.709437038437505, 0.7272318055454359, 0.5459823777417234, 0.1983296595458679, 0.4496339112997588, 0.25540549812494295, 0.29281538805566965, 0.7376930203897825, 0.5344888407338009, 0.20672273819014408, 0.20382124454786565, 0.48192720836055014, 0.34688484757813565, 0.4575825880974329, 0.20682700934964893, 0.20496293634642548, 0.6488622698891036, 0.18509977707364345, 0.191089084099894, 0.18985410408145043, 0.20991206604435897, 0.18978085941796408, 0.19381728563676692, 0.2088429573450009, 0.18922114346994845, 0.18003992478764397, 0.06385995992359572, 0.06776328975003743, 0.08246546412260414, 0.06396501809912802, 0.07245866633439724, 0.07308179633849543, 0.07386375926689548, 0.07343376732690299, 0.07683714007868037]}, "mutation_prompt": null}
{"id": "fa4c0e38-bb9f-434e-ae26-1b6b2646e7fa", "solution": "import numpy as np\n\nclass MemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Local search on best individual\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            best_fitness = fitness[best_index]\n            \n            # Perform a simple random neighborhood search around the best individual\n            local_neighbors = best_individual + np.random.uniform(-0.1, 0.1, (10, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n            \n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_index]\n                best_fitness = local_fitness[best_index]\n                \n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "MemeticDifferentialEvolution", "description": "A memetic algorithm combining differential evolution and local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.5836225311948049, 0.5895675481708798, 0.5931935339412369, 0.6092798817755256, 0.5971191751395089, 0.6202579917834308, 0.5915666641654593, 0.6329231146089245, 0.614496547496218, 0.3269420225697043, 0.32341007556044665, 0.3067393591575437, 0.33025145964783187, 0.3164549216374125, 0.31410736857977894, 0.3034373833378351, 0.32458656142264397, 0.32448189010106865, 0.0932342943891219, 0.14210171319527398, 0.12124651238007733, 0.1117186560595137, 0.10416462667954152, 0.13469583922195927, 0.10778599739147499, 0.10180983716471348, 0.11519071115675017, 0.09089923321281623, 0.07916223832856029, 0.09650580656142027, 0.10828047219810033, 0.09519688902934909, 0.11137299647643428, 0.11246531376395619, 0.12295482105811084, 0.09031900319661212, 0.9570017798820938, 0.9513292557106726, 0.9261189549404044, 0.932623940991951, 0.9277210170918078, 0.9656618317581583, 0.9643447913571865, 0.9721847342834466, 0.953476269027666, 0.29421687546028763, 0.31172891459799634, 0.28049672705086315, 0.28360228842594426, 0.29617362506457234, 0.31417605357685474, 0.3030308170377122, 0.2945013636010071, 0.31683005641423334, 0.5179901746271818, 0.4967938945250143, 0.3992218655444725, 0.6421024689794905, 0.4829996488068862, 0.5444143981709784, 0.818801602910831, 0.4169046635013345, 0.5667733833019734, 0.1729377314210867, 0.19408614048524442, 0.2189357195687498, 0.17003335976335543, 0.1734456129185239, 0.22317341038415006, 0.16815520346172597, 0.23471455937223595, 0.18005566062328848, 0.17128012630579414, 0.22078714561119273, 0.18985238237062607, 0.17887929005036718, 0.14169377179786802, 0.17179544957294768, 0.1912676319700436, 0.19817619522267937, 0.1992738826984083, 0.12609625599841567, 0.0884125386662783, 0.07419627554103048, 0.12689456376567354, 0.09695846887388382, 0.10487159974444749, 0.0874590757433692, 0.10069088517058722, 0.08757007935442673, 0.24629823159854047, 0.23721672551643924, 0.1937924518431159, 0.2360613318904099, 0.2283277969657893, 0.21070951185422226, 0.24376182655715817, 0.2505002143128586, 0.24655490215416498, 0.008900204497490405, 0.029919102645743822, 0.0025024944447568087, 0.0084676904081743, 0.012605954307217115, 0.02776100803567294, 0.025295612550901736, 0.023065392675113428, 0.023991856805336775, 0.14806031195500602, 0.16610838876205658, 0.14065028111594324, 0.15394747464367609, 0.14242247562505017, 0.1641355696142669, 0.13765768978862902, 0.14788652466503827, 0.14584253302347738, 0.47246127760880385, 0.468467834239634, 0.488651401632924, 0.46925752632019735, 0.47998205454430665, 0.4819209969882894, 0.48289905070808636, 0.478057701671476, 0.46432681688452015, 0.11941284027623278, 0.0970678050806677, 0.12705107697367768, 0.10342182382932241, 0.10174470673056091, 0.11317706319574627, 0.14065440601023493, 0.09688588256048702, 0.12232279486506359, 0.20147186942807993, 0.22762076159867817, 0.19167359996581346, 0.20502140494458854, 0.3240914377838958, 0.15302899385411983, 0.222969704226318, 0.1971035981559942, 0.3370545323977565, 0.2915631131514015, 0.2631696010212998, 0.28266814135970175, 0.2545950968525381, 0.23443404208008423, 0.27872565991797915, 0.29236532880326027, 0.2846885922197856, 0.2795686791733427, 0.22804063504413763, 0.19258150404602026, 0.23416578679225863, 0.20352583786546963, 0.20717979619202664, 0.17512893086659753, 0.22160308336762413, 0.22804313370465612, 0.21915684395892931, 0.18908813501361632, 0.17079934041368217, 0.17177489544080238, 0.17704592116144846, 0.18118821348623737, 0.17809420476787874, 0.17775590335163471, 0.206728362256554, 0.19042325886574185, 0.19072141796360798, 0.20708449878617063, 0.21776916142881442, 0.19864304601679117, 0.1784266230160374, 0.18479795624277462, 0.21614367460058825, 0.1847424949658062, 0.2039222438571181, 0.6394295150533678, 0.709437038437505, 0.7272318055454359, 0.5459823777417234, 0.1983296595458679, 0.4496339112997588, 0.25540549812494295, 0.29281538805566965, 0.7376930203897825, 0.5344888407338009, 0.20672273819014408, 0.20382124454786565, 0.48192720836055014, 0.34688484757813565, 0.4575825880974329, 0.20682700934964893, 0.20496293634642548, 0.6488622698891036, 0.18509977707364345, 0.191089084099894, 0.18985410408145043, 0.20991206604435897, 0.18978085941796408, 0.19381728563676692, 0.2088429573450009, 0.18922114346994845, 0.18003992478764397, 0.06385995992359572, 0.06776328975003743, 0.08246546412260414, 0.06396501809912802, 0.07245866633439724, 0.07308179633849543, 0.07386375926689548, 0.07343376732690299, 0.07683714007868037]}, "mutation_prompt": null}
{"id": "5f3a7900-0b2b-4e33-a3f5-87951e1c8b95", "solution": "import numpy as np\n\nclass MemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Local search on best individual\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            best_fitness = fitness[best_index]\n            \n            # Perform a simple random neighborhood search around the best individual\n            local_neighbors = best_individual + np.random.uniform(-0.1, 0.1, (10, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n            \n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_index]\n                best_fitness = local_fitness[best_index]\n                \n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "MemeticDifferentialEvolution", "description": "A memetic algorithm combining differential evolution and local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.5836225311948049, 0.5895675481708798, 0.5931935339412369, 0.6092798817755256, 0.5971191751395089, 0.6202579917834308, 0.5915666641654593, 0.6329231146089245, 0.614496547496218, 0.3269420225697043, 0.32341007556044665, 0.3067393591575437, 0.33025145964783187, 0.3164549216374125, 0.31410736857977894, 0.3034373833378351, 0.32458656142264397, 0.32448189010106865, 0.0932342943891219, 0.14210171319527398, 0.12124651238007733, 0.1117186560595137, 0.10416462667954152, 0.13469583922195927, 0.10778599739147499, 0.10180983716471348, 0.11519071115675017, 0.09089923321281623, 0.07916223832856029, 0.09650580656142027, 0.10828047219810033, 0.09519688902934909, 0.11137299647643428, 0.11246531376395619, 0.12295482105811084, 0.09031900319661212, 0.9570017798820938, 0.9513292557106726, 0.9261189549404044, 0.932623940991951, 0.9277210170918078, 0.9656618317581583, 0.9643447913571865, 0.9721847342834466, 0.953476269027666, 0.29421687546028763, 0.31172891459799634, 0.28049672705086315, 0.28360228842594426, 0.29617362506457234, 0.31417605357685474, 0.3030308170377122, 0.2945013636010071, 0.31683005641423334, 0.5179901746271818, 0.4967938945250143, 0.3992218655444725, 0.6421024689794905, 0.4829996488068862, 0.5444143981709784, 0.818801602910831, 0.4169046635013345, 0.5667733833019734, 0.1729377314210867, 0.19408614048524442, 0.2189357195687498, 0.17003335976335543, 0.1734456129185239, 0.22317341038415006, 0.16815520346172597, 0.23471455937223595, 0.18005566062328848, 0.17128012630579414, 0.22078714561119273, 0.18985238237062607, 0.17887929005036718, 0.14169377179786802, 0.17179544957294768, 0.1912676319700436, 0.19817619522267937, 0.1992738826984083, 0.12609625599841567, 0.0884125386662783, 0.07419627554103048, 0.12689456376567354, 0.09695846887388382, 0.10487159974444749, 0.0874590757433692, 0.10069088517058722, 0.08757007935442673, 0.24629823159854047, 0.23721672551643924, 0.1937924518431159, 0.2360613318904099, 0.2283277969657893, 0.21070951185422226, 0.24376182655715817, 0.2505002143128586, 0.24655490215416498, 0.008900204497490405, 0.029919102645743822, 0.0025024944447568087, 0.0084676904081743, 0.012605954307217115, 0.02776100803567294, 0.025295612550901736, 0.023065392675113428, 0.023991856805336775, 0.14806031195500602, 0.16610838876205658, 0.14065028111594324, 0.15394747464367609, 0.14242247562505017, 0.1641355696142669, 0.13765768978862902, 0.14788652466503827, 0.14584253302347738, 0.47246127760880385, 0.468467834239634, 0.488651401632924, 0.46925752632019735, 0.47998205454430665, 0.4819209969882894, 0.48289905070808636, 0.478057701671476, 0.46432681688452015, 0.11941284027623278, 0.0970678050806677, 0.12705107697367768, 0.10342182382932241, 0.10174470673056091, 0.11317706319574627, 0.14065440601023493, 0.09688588256048702, 0.12232279486506359, 0.20147186942807993, 0.22762076159867817, 0.19167359996581346, 0.20502140494458854, 0.3240914377838958, 0.15302899385411983, 0.222969704226318, 0.1971035981559942, 0.3370545323977565, 0.2915631131514015, 0.2631696010212998, 0.28266814135970175, 0.2545950968525381, 0.23443404208008423, 0.27872565991797915, 0.29236532880326027, 0.2846885922197856, 0.2795686791733427, 0.22804063504413763, 0.19258150404602026, 0.23416578679225863, 0.20352583786546963, 0.20717979619202664, 0.17512893086659753, 0.22160308336762413, 0.22804313370465612, 0.21915684395892931, 0.18908813501361632, 0.17079934041368217, 0.17177489544080238, 0.17704592116144846, 0.18118821348623737, 0.17809420476787874, 0.17775590335163471, 0.206728362256554, 0.19042325886574185, 0.19072141796360798, 0.20708449878617063, 0.21776916142881442, 0.19864304601679117, 0.1784266230160374, 0.18479795624277462, 0.21614367460058825, 0.1847424949658062, 0.2039222438571181, 0.6394295150533678, 0.709437038437505, 0.7272318055454359, 0.5459823777417234, 0.1983296595458679, 0.4496339112997588, 0.25540549812494295, 0.29281538805566965, 0.7376930203897825, 0.5344888407338009, 0.20672273819014408, 0.20382124454786565, 0.48192720836055014, 0.34688484757813565, 0.4575825880974329, 0.20682700934964893, 0.20496293634642548, 0.6488622698891036, 0.18509977707364345, 0.191089084099894, 0.18985410408145043, 0.20991206604435897, 0.18978085941796408, 0.19381728563676692, 0.2088429573450009, 0.18922114346994845, 0.18003992478764397, 0.06385995992359572, 0.06776328975003743, 0.08246546412260414, 0.06396501809912802, 0.07245866633439724, 0.07308179633849543, 0.07386375926689548, 0.07343376732690299, 0.07683714007868037]}, "mutation_prompt": null}
{"id": "ec80dd36-bfe1-4619-98f0-68f4cea57ff4", "solution": "import numpy as np\n\nclass MemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Local search on best individual\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            best_fitness = fitness[best_index]\n            \n            # Perform a simple random neighborhood search around the best individual\n            local_neighbors = best_individual + np.random.uniform(-0.1, 0.1, (10, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n            \n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_index]\n                best_fitness = local_fitness[best_index]\n                \n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "MemeticDifferentialEvolution", "description": "A memetic algorithm combining differential evolution and local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.5836225311948049, 0.5895675481708798, 0.5931935339412369, 0.6092798817755256, 0.5971191751395089, 0.6202579917834308, 0.5915666641654593, 0.6329231146089245, 0.614496547496218, 0.3269420225697043, 0.32341007556044665, 0.3067393591575437, 0.33025145964783187, 0.3164549216374125, 0.31410736857977894, 0.3034373833378351, 0.32458656142264397, 0.32448189010106865, 0.0932342943891219, 0.14210171319527398, 0.12124651238007733, 0.1117186560595137, 0.10416462667954152, 0.13469583922195927, 0.10778599739147499, 0.10180983716471348, 0.11519071115675017, 0.09089923321281623, 0.07916223832856029, 0.09650580656142027, 0.10828047219810033, 0.09519688902934909, 0.11137299647643428, 0.11246531376395619, 0.12295482105811084, 0.09031900319661212, 0.9570017798820938, 0.9513292557106726, 0.9261189549404044, 0.932623940991951, 0.9277210170918078, 0.9656618317581583, 0.9643447913571865, 0.9721847342834466, 0.953476269027666, 0.29421687546028763, 0.31172891459799634, 0.28049672705086315, 0.28360228842594426, 0.29617362506457234, 0.31417605357685474, 0.3030308170377122, 0.2945013636010071, 0.31683005641423334, 0.5179901746271818, 0.4967938945250143, 0.3992218655444725, 0.6421024689794905, 0.4829996488068862, 0.5444143981709784, 0.818801602910831, 0.4169046635013345, 0.5667733833019734, 0.1729377314210867, 0.19408614048524442, 0.2189357195687498, 0.17003335976335543, 0.1734456129185239, 0.22317341038415006, 0.16815520346172597, 0.23471455937223595, 0.18005566062328848, 0.17128012630579414, 0.22078714561119273, 0.18985238237062607, 0.17887929005036718, 0.14169377179786802, 0.17179544957294768, 0.1912676319700436, 0.19817619522267937, 0.1992738826984083, 0.12609625599841567, 0.0884125386662783, 0.07419627554103048, 0.12689456376567354, 0.09695846887388382, 0.10487159974444749, 0.0874590757433692, 0.10069088517058722, 0.08757007935442673, 0.24629823159854047, 0.23721672551643924, 0.1937924518431159, 0.2360613318904099, 0.2283277969657893, 0.21070951185422226, 0.24376182655715817, 0.2505002143128586, 0.24655490215416498, 0.008900204497490405, 0.029919102645743822, 0.0025024944447568087, 0.0084676904081743, 0.012605954307217115, 0.02776100803567294, 0.025295612550901736, 0.023065392675113428, 0.023991856805336775, 0.14806031195500602, 0.16610838876205658, 0.14065028111594324, 0.15394747464367609, 0.14242247562505017, 0.1641355696142669, 0.13765768978862902, 0.14788652466503827, 0.14584253302347738, 0.47246127760880385, 0.468467834239634, 0.488651401632924, 0.46925752632019735, 0.47998205454430665, 0.4819209969882894, 0.48289905070808636, 0.478057701671476, 0.46432681688452015, 0.11941284027623278, 0.0970678050806677, 0.12705107697367768, 0.10342182382932241, 0.10174470673056091, 0.11317706319574627, 0.14065440601023493, 0.09688588256048702, 0.12232279486506359, 0.20147186942807993, 0.22762076159867817, 0.19167359996581346, 0.20502140494458854, 0.3240914377838958, 0.15302899385411983, 0.222969704226318, 0.1971035981559942, 0.3370545323977565, 0.2915631131514015, 0.2631696010212998, 0.28266814135970175, 0.2545950968525381, 0.23443404208008423, 0.27872565991797915, 0.29236532880326027, 0.2846885922197856, 0.2795686791733427, 0.22804063504413763, 0.19258150404602026, 0.23416578679225863, 0.20352583786546963, 0.20717979619202664, 0.17512893086659753, 0.22160308336762413, 0.22804313370465612, 0.21915684395892931, 0.18908813501361632, 0.17079934041368217, 0.17177489544080238, 0.17704592116144846, 0.18118821348623737, 0.17809420476787874, 0.17775590335163471, 0.206728362256554, 0.19042325886574185, 0.19072141796360798, 0.20708449878617063, 0.21776916142881442, 0.19864304601679117, 0.1784266230160374, 0.18479795624277462, 0.21614367460058825, 0.1847424949658062, 0.2039222438571181, 0.6394295150533678, 0.709437038437505, 0.7272318055454359, 0.5459823777417234, 0.1983296595458679, 0.4496339112997588, 0.25540549812494295, 0.29281538805566965, 0.7376930203897825, 0.5344888407338009, 0.20672273819014408, 0.20382124454786565, 0.48192720836055014, 0.34688484757813565, 0.4575825880974329, 0.20682700934964893, 0.20496293634642548, 0.6488622698891036, 0.18509977707364345, 0.191089084099894, 0.18985410408145043, 0.20991206604435897, 0.18978085941796408, 0.19381728563676692, 0.2088429573450009, 0.18922114346994845, 0.18003992478764397, 0.06385995992359572, 0.06776328975003743, 0.08246546412260414, 0.06396501809912802, 0.07245866633439724, 0.07308179633849543, 0.07386375926689548, 0.07343376732690299, 0.07683714007868037]}, "mutation_prompt": null}
{"id": "9954a2d0-c4ce-4e57-b01a-909ee64400c2", "solution": "import numpy as np\n\nclass MemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])\n                \n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                if eval_count >= self.budget:\n                    break\n\n            # Local search on best individual\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            best_fitness = fitness[best_index]\n            \n            # Perform a simple random neighborhood search around the best individual\n            local_neighbors = best_individual + np.random.uniform(-0.1, 0.1, (10, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n            \n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_index]\n                best_fitness = local_fitness[best_index]\n                \n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index]", "name": "MemeticDifferentialEvolution", "description": "A memetic algorithm combining differential evolution and local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.5836225311948049, 0.5895675481708798, 0.5931935339412369, 0.6092798817755256, 0.5971191751395089, 0.6202579917834308, 0.5915666641654593, 0.6329231146089245, 0.614496547496218, 0.3269420225697043, 0.32341007556044665, 0.3067393591575437, 0.33025145964783187, 0.3164549216374125, 0.31410736857977894, 0.3034373833378351, 0.32458656142264397, 0.32448189010106865, 0.0932342943891219, 0.14210171319527398, 0.12124651238007733, 0.1117186560595137, 0.10416462667954152, 0.13469583922195927, 0.10778599739147499, 0.10180983716471348, 0.11519071115675017, 0.09089923321281623, 0.07916223832856029, 0.09650580656142027, 0.10828047219810033, 0.09519688902934909, 0.11137299647643428, 0.11246531376395619, 0.12295482105811084, 0.09031900319661212, 0.9570017798820938, 0.9513292557106726, 0.9261189549404044, 0.932623940991951, 0.9277210170918078, 0.9656618317581583, 0.9643447913571865, 0.9721847342834466, 0.953476269027666, 0.29421687546028763, 0.31172891459799634, 0.28049672705086315, 0.28360228842594426, 0.29617362506457234, 0.31417605357685474, 0.3030308170377122, 0.2945013636010071, 0.31683005641423334, 0.5179901746271818, 0.4967938945250143, 0.3992218655444725, 0.6421024689794905, 0.4829996488068862, 0.5444143981709784, 0.818801602910831, 0.4169046635013345, 0.5667733833019734, 0.1729377314210867, 0.19408614048524442, 0.2189357195687498, 0.17003335976335543, 0.1734456129185239, 0.22317341038415006, 0.16815520346172597, 0.23471455937223595, 0.18005566062328848, 0.17128012630579414, 0.22078714561119273, 0.18985238237062607, 0.17887929005036718, 0.14169377179786802, 0.17179544957294768, 0.1912676319700436, 0.19817619522267937, 0.1992738826984083, 0.12609625599841567, 0.0884125386662783, 0.07419627554103048, 0.12689456376567354, 0.09695846887388382, 0.10487159974444749, 0.0874590757433692, 0.10069088517058722, 0.08757007935442673, 0.24629823159854047, 0.23721672551643924, 0.1937924518431159, 0.2360613318904099, 0.2283277969657893, 0.21070951185422226, 0.24376182655715817, 0.2505002143128586, 0.24655490215416498, 0.008900204497490405, 0.029919102645743822, 0.0025024944447568087, 0.0084676904081743, 0.012605954307217115, 0.02776100803567294, 0.025295612550901736, 0.023065392675113428, 0.023991856805336775, 0.14806031195500602, 0.16610838876205658, 0.14065028111594324, 0.15394747464367609, 0.14242247562505017, 0.1641355696142669, 0.13765768978862902, 0.14788652466503827, 0.14584253302347738, 0.47246127760880385, 0.468467834239634, 0.488651401632924, 0.46925752632019735, 0.47998205454430665, 0.4819209969882894, 0.48289905070808636, 0.478057701671476, 0.46432681688452015, 0.11941284027623278, 0.0970678050806677, 0.12705107697367768, 0.10342182382932241, 0.10174470673056091, 0.11317706319574627, 0.14065440601023493, 0.09688588256048702, 0.12232279486506359, 0.20147186942807993, 0.22762076159867817, 0.19167359996581346, 0.20502140494458854, 0.3240914377838958, 0.15302899385411983, 0.222969704226318, 0.1971035981559942, 0.3370545323977565, 0.2915631131514015, 0.2631696010212998, 0.28266814135970175, 0.2545950968525381, 0.23443404208008423, 0.27872565991797915, 0.29236532880326027, 0.2846885922197856, 0.2795686791733427, 0.22804063504413763, 0.19258150404602026, 0.23416578679225863, 0.20352583786546963, 0.20717979619202664, 0.17512893086659753, 0.22160308336762413, 0.22804313370465612, 0.21915684395892931, 0.18908813501361632, 0.17079934041368217, 0.17177489544080238, 0.17704592116144846, 0.18118821348623737, 0.17809420476787874, 0.17775590335163471, 0.206728362256554, 0.19042325886574185, 0.19072141796360798, 0.20708449878617063, 0.21776916142881442, 0.19864304601679117, 0.1784266230160374, 0.18479795624277462, 0.21614367460058825, 0.1847424949658062, 0.2039222438571181, 0.6394295150533678, 0.709437038437505, 0.7272318055454359, 0.5459823777417234, 0.1983296595458679, 0.4496339112997588, 0.25540549812494295, 0.29281538805566965, 0.7376930203897825, 0.5344888407338009, 0.20672273819014408, 0.20382124454786565, 0.48192720836055014, 0.34688484757813565, 0.4575825880974329, 0.20682700934964893, 0.20496293634642548, 0.6488622698891036, 0.18509977707364345, 0.191089084099894, 0.18985410408145043, 0.20991206604435897, 0.18978085941796408, 0.19381728563676692, 0.2088429573450009, 0.18922114346994845, 0.18003992478764397, 0.06385995992359572, 0.06776328975003743, 0.08246546412260414, 0.06396501809912802, 0.07245866633439724, 0.07308179633849543, 0.07386375926689548, 0.07343376732690299, 0.07683714007868037]}, "mutation_prompt": null}
{"id": "0fed00a9-e5f0-4ffc-b75a-7e71b309d60b", "solution": "import numpy as np\n\nclass EnhancedMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.8  # Base differential weight\n        self.CR_base = 0.9  # Base crossover probability\n        self.adaptation_rate = 0.05  # Adaptive change rate for F and CR\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        # Track the best solution found\n        best_index = np.argmin(fitness)\n        best_individual = population[best_index]\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Adaptive F and CR\n                F = self.F_base + self.adaptation_rate * np.random.randn()\n                CR = self.CR_base + self.adaptation_rate * np.random.randn()\n\n                # Mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n\n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection and elitism\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Local search around the best individual\n            neighborhood_size = 5\n            local_neighbors = best_individual + np.random.uniform(-0.05, 0.05, (neighborhood_size, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n\n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_local_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_local_index]\n                best_fitness = local_fitness[best_local_index]\n\n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        return best_individual", "name": "EnhancedMemeticDifferentialEvolution", "description": "An enhanced memetic algorithm using adaptive parameter control and elitism to improve convergence speed and solution accuracy.", "configspace": "", "generation": 51, "fitness": 0.2831863734912425, "feedback": "The algorithm EnhancedMemeticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.21.", "error": "", "parent_id": "cec59589-a2e2-42fb-9c69-646a8607a4c5", "metadata": {"aucs": [0.6228027276927866, 0.6064497542707818, 0.6454596468999256, 0.6434740184456335, 0.6482628879401106, 0.6620137091009336, 0.6149729483762327, 0.634629920920164, 0.6711893689007646, 0.3622672042180022, 0.3876383773454327, 0.3707783721943412, 0.3517220154040952, 0.36332274542813303, 0.3280332305446836, 0.3752309144261835, 0.3675504198530276, 0.36400960837366114, 0.12563373270120626, 0.11822500722679852, 0.1272906656565609, 0.14289805158526447, 0.11390032236666792, 0.12148089199396106, 0.09001135428303209, 0.11017955246234012, 0.13309649940144286, 0.1084873849695932, 0.10697354324674302, 0.08949738571182986, 0.11406894591428896, 0.11035634657805038, 0.09488745165202161, 0.09810454026469417, 0.1082926020627627, 0.11346734941016434, 0.9350054780746844, 0.9334440831149503, 0.9654964935628368, 0.9702688901619474, 0.9815837924269865, 0.9557091736871743, 0.8873357246720085, 0.9423633102335435, 0.9574029578541597, 0.26054041416158236, 0.2854399939728982, 0.29101265697595624, 0.2968175434982885, 0.30915631091210005, 0.30657125552318676, 0.2998133991822015, 0.3155788655286911, 0.3230031885360244, 0.4768862778582007, 0.4707757188223106, 0.7352788767247485, 0.5435073492932296, 0.5430089761477254, 0.5620899552321167, 0.5535577757997809, 0.6299423368913617, 0.7166187013430487, 0.2219572997184981, 0.21959362472769572, 0.18567447656362257, 0.18321198994675159, 0.26362614155847175, 0.22298294507173655, 0.22454455215816438, 0.20342567591914062, 0.21347811057163035, 0.1701829312348031, 0.25263096507503446, 0.20720969812776635, 0.2836092627433412, 0.18302290087089934, 0.22841186743804232, 0.22596081532349366, 0.19585511069333084, 0.21714200098068592, 0.10517565062742074, 0.12293336819706857, 0.1326051655992655, 0.15685163632784038, 0.11833219779137272, 0.10433562068520952, 0.110443264365775, 0.14200519702239833, 0.12712871282509075, 0.24805383832049266, 0.2556419837545506, 0.2486833549839922, 0.2453028029986598, 0.2415614230425388, 0.252281246851209, 0.2613397755656368, 0.27382842538400043, 0.2537879536823704, 0.020035903378929798, 0.02463749848521346, 0.02568697031026912, 0.04434763064812597, 0.019340076553692076, 0.025460137035128394, 0.03034077127141377, 0.04138035703396181, 0.041737277629500746, 0.16069453570661862, 0.15432302733281744, 0.16414645274729012, 0.18067144453477446, 0.1712962910603535, 0.16555018567879487, 0.165915682685009, 0.16104116555597991, 0.15529767276507733, 0.4511988982178634, 0.4802232943517961, 0.49882612692082573, 0.5047860993710486, 0.471831079490737, 0.47410401555161064, 0.49009383142187735, 0.48223710586335955, 0.5025548066429868, 0.1349545254483896, 0.10432036386766708, 0.09569358059908684, 0.10854172150056018, 0.09143383203211253, 0.09919673431093035, 0.12757384499717517, 0.09729089702356264, 0.09696542422349941, 0.17300724193228068, 0.28313511617628084, 0.1657505695789805, 0.17999450725571842, 0.24884669290726225, 0.14575075647947722, 0.2777643124071997, 0.17268919670870853, 0.1561103963511934, 0.29686803685943786, 0.2725110162581612, 0.27722214557716485, 0.2539632495299098, 0.2746816895636913, 0.26018337629943666, 0.2898298612069816, 0.30986432895843585, 0.30080074285826264, 0.24592188292109451, 0.20117902007194277, 0.23192933386201542, 0.20973952247913807, 0.20710276500344793, 0.2187972556777994, 0.21177096590539513, 0.22844340589043266, 0.2189215321407223, 0.18820037915920151, 0.20106277300088926, 0.19013273937230402, 0.19722011597934053, 0.19500397587018425, 0.18437929557775845, 0.21291170788339597, 0.18487811357121464, 0.20328535329372088, 0.19328253256360228, 0.2059163107245604, 0.17619027419849698, 0.2038688654051929, 0.19659564897421478, 0.18641719012392655, 0.18917536290576387, 0.18585130081341572, 0.18324379546823766, 0.17574551467848487, 0.5121402229602059, 0.5323784525043289, 0.3353335311612634, 0.5413636256595493, 0.6156288066803246, 0.5728849754461255, 0.18486647667929845, 0.6396815527299935, 0.5152103249085497, 0.18926060683755963, 0.1600398551541593, 0.20006942150112095, 0.4254740102617679, 0.41354255304952947, 0.2057805657770071, 0.6150748487925656, 0.20405112413915139, 0.1945375840875735, 0.20292245532154296, 0.18790431734689184, 0.18783027872254776, 0.22701565111364996, 0.19822149744633866, 0.19755444745858608, 0.19884703347992072, 0.18971731437637107, 0.07154997405362007, 0.08918193419477194, 0.0692501897977803, 0.08635933236966609, 0.07979764405024092, 0.07825962322440305, 0.07667299739894207, 0.06730542648967452, 0.074997601498768]}, "mutation_prompt": null}
{"id": "b0e09909-ec24-4b02-b4ba-3fc990467dcf", "solution": "import numpy as np\n\nclass EnhancedMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.8  # Base differential weight\n        self.CR_base = 0.9  # Base crossover probability\n        self.adaptation_rate = 0.05  # Adaptive change rate for F and CR\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        # Track the best solution found\n        best_index = np.argmin(fitness)\n        best_individual = population[best_index]\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Adaptive F and CR\n                F = self.F_base + self.adaptation_rate * np.random.randn()\n                CR = self.CR_base + self.adaptation_rate * np.random.randn()\n\n                # Mutation and crossover\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n\n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection and elitism\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Local search around the best individual\n            neighborhood_size = 5\n            local_neighbors = best_individual + np.random.uniform(-0.05, 0.05, (neighborhood_size, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n\n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_local_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_local_index]\n                best_fitness = local_fitness[best_local_index]\n\n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        return best_individual", "name": "EnhancedMemeticDifferentialEvolution", "description": "An enhanced memetic algorithm using adaptive parameter control and elitism to improve convergence speed and solution accuracy.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0fed00a9-e5f0-4ffc-b75a-7e71b309d60b", "metadata": {"aucs": [0.6228027276927866, 0.6064497542707818, 0.6454596468999256, 0.6434740184456335, 0.6482628879401106, 0.6620137091009336, 0.6149729483762327, 0.634629920920164, 0.6711893689007646, 0.3622672042180022, 0.3876383773454327, 0.3707783721943412, 0.3517220154040952, 0.36332274542813303, 0.3280332305446836, 0.3752309144261835, 0.3675504198530276, 0.36400960837366114, 0.12563373270120626, 0.11822500722679852, 0.1272906656565609, 0.14289805158526447, 0.11390032236666792, 0.12148089199396106, 0.09001135428303209, 0.11017955246234012, 0.13309649940144286, 0.1084873849695932, 0.10697354324674302, 0.08949738571182986, 0.11406894591428896, 0.11035634657805038, 0.09488745165202161, 0.09810454026469417, 0.1082926020627627, 0.11346734941016434, 0.9350054780746844, 0.9334440831149503, 0.9654964935628368, 0.9702688901619474, 0.9815837924269865, 0.9557091736871743, 0.8873357246720085, 0.9423633102335435, 0.9574029578541597, 0.26054041416158236, 0.2854399939728982, 0.29101265697595624, 0.2968175434982885, 0.30915631091210005, 0.30657125552318676, 0.2998133991822015, 0.3155788655286911, 0.3230031885360244, 0.4768862778582007, 0.4707757188223106, 0.7352788767247485, 0.5435073492932296, 0.5430089761477254, 0.5620899552321167, 0.5535577757997809, 0.6299423368913617, 0.7166187013430487, 0.2219572997184981, 0.21959362472769572, 0.18567447656362257, 0.18321198994675159, 0.26362614155847175, 0.22298294507173655, 0.22454455215816438, 0.20342567591914062, 0.21347811057163035, 0.1701829312348031, 0.25263096507503446, 0.20720969812776635, 0.2836092627433412, 0.18302290087089934, 0.22841186743804232, 0.22596081532349366, 0.19585511069333084, 0.21714200098068592, 0.10517565062742074, 0.12293336819706857, 0.1326051655992655, 0.15685163632784038, 0.11833219779137272, 0.10433562068520952, 0.110443264365775, 0.14200519702239833, 0.12712871282509075, 0.24805383832049266, 0.2556419837545506, 0.2486833549839922, 0.2453028029986598, 0.2415614230425388, 0.252281246851209, 0.2613397755656368, 0.27382842538400043, 0.2537879536823704, 0.020035903378929798, 0.02463749848521346, 0.02568697031026912, 0.04434763064812597, 0.019340076553692076, 0.025460137035128394, 0.03034077127141377, 0.04138035703396181, 0.041737277629500746, 0.16069453570661862, 0.15432302733281744, 0.16414645274729012, 0.18067144453477446, 0.1712962910603535, 0.16555018567879487, 0.165915682685009, 0.16104116555597991, 0.15529767276507733, 0.4511988982178634, 0.4802232943517961, 0.49882612692082573, 0.5047860993710486, 0.471831079490737, 0.47410401555161064, 0.49009383142187735, 0.48223710586335955, 0.5025548066429868, 0.1349545254483896, 0.10432036386766708, 0.09569358059908684, 0.10854172150056018, 0.09143383203211253, 0.09919673431093035, 0.12757384499717517, 0.09729089702356264, 0.09696542422349941, 0.17300724193228068, 0.28313511617628084, 0.1657505695789805, 0.17999450725571842, 0.24884669290726225, 0.14575075647947722, 0.2777643124071997, 0.17268919670870853, 0.1561103963511934, 0.29686803685943786, 0.2725110162581612, 0.27722214557716485, 0.2539632495299098, 0.2746816895636913, 0.26018337629943666, 0.2898298612069816, 0.30986432895843585, 0.30080074285826264, 0.24592188292109451, 0.20117902007194277, 0.23192933386201542, 0.20973952247913807, 0.20710276500344793, 0.2187972556777994, 0.21177096590539513, 0.22844340589043266, 0.2189215321407223, 0.18820037915920151, 0.20106277300088926, 0.19013273937230402, 0.19722011597934053, 0.19500397587018425, 0.18437929557775845, 0.21291170788339597, 0.18487811357121464, 0.20328535329372088, 0.19328253256360228, 0.2059163107245604, 0.17619027419849698, 0.2038688654051929, 0.19659564897421478, 0.18641719012392655, 0.18917536290576387, 0.18585130081341572, 0.18324379546823766, 0.17574551467848487, 0.5121402229602059, 0.5323784525043289, 0.3353335311612634, 0.5413636256595493, 0.6156288066803246, 0.5728849754461255, 0.18486647667929845, 0.6396815527299935, 0.5152103249085497, 0.18926060683755963, 0.1600398551541593, 0.20006942150112095, 0.4254740102617679, 0.41354255304952947, 0.2057805657770071, 0.6150748487925656, 0.20405112413915139, 0.1945375840875735, 0.20292245532154296, 0.18790431734689184, 0.18783027872254776, 0.22701565111364996, 0.19822149744633866, 0.19755444745858608, 0.19884703347992072, 0.18971731437637107, 0.07154997405362007, 0.08918193419477194, 0.0692501897977803, 0.08635933236966609, 0.07979764405024092, 0.07825962322440305, 0.07667299739894207, 0.06730542648967452, 0.074997601498768]}, "mutation_prompt": null}
{"id": "60b3a51e-22ed-4cc2-9a37-d742ccc0f871", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.6  # Adjusted differential weight for exploration-exploitation balance\n        self.CR_base = 0.8  # Adjusted crossover probability\n        self.adaptation_rate = 0.02  # Lower adaptive change rate for stability\n        self.local_search_intensity = 0.1  # Intensity of local search\n        self.mutation_strategy = 'best'  # Using a mix of 'best' and 'rand' strategies\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        # Track the best solution found\n        best_index = np.argmin(fitness)\n        best_individual = population[best_index]\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Adaptive F and CR\n                F = self.F_base + self.adaptation_rate * np.random.randn()\n                CR = self.CR_base + self.adaptation_rate * np.random.randn()\n\n                # Dynamic mutation strategy selection\n                if np.random.rand() < 0.5:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = population[indices]\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(self.population_size, 2, replace=False)\n                    a, b = population[indices]\n                    mutant = np.clip(best_individual + F * (a - b), self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n\n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection and elitism\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Cooperative local search around the best individual\n            neighborhood_size = int(self.local_search_intensity * self.population_size)\n            local_neighbors = best_individual + np.random.uniform(-0.05, 0.05, (neighborhood_size, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n\n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_local_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_local_index]\n                best_fitness = local_fitness[best_local_index]\n\n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        return best_individual", "name": "HybridAdaptiveDifferentialEvolution", "description": "A hybrid adaptive differential evolution with dynamic parameter control and cooperative local search for enhanced convergence speed.", "configspace": "", "generation": 53, "fitness": 0.4411489152288833, "feedback": "The algorithm HybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.27.", "error": "", "parent_id": "0fed00a9-e5f0-4ffc-b75a-7e71b309d60b", "metadata": {"aucs": [0.8619351864320388, 0.8654340039274515, 0.8722648263184456, 0.877359993739161, 0.8733189681286274, 0.8845013937581183, 0.8814411496896972, 0.8679245928160655, 0.8717445788538832, 0.7570065617871957, 0.7668081713250303, 0.7556551273140312, 0.7710736043041881, 0.7416022515477132, 0.7484516206265178, 0.7672941575852692, 0.7696231100050808, 0.7563618993416057, 0.17738823455709374, 0.15472942685807067, 0.15380601292745322, 0.1834943951808552, 0.16544021647767748, 0.17250368940062022, 0.1757555511194041, 0.13052187966424467, 0.4196786163803936, 0.14514885095087482, 0.15098280004487374, 0.14528326216956944, 0.14404546243923977, 0.1297750996164857, 0.12833452866300143, 0.14891767859870852, 0.14145217697140633, 0.10706547763488217, 0.9829928765439452, 0.9744146522536012, 0.9781895694960724, 0.9876835489218235, 0.9768908416089108, 0.9790470928264963, 0.984331235653565, 0.9732642167912735, 0.9793943145633308, 0.537855919215161, 0.5419122244099366, 0.5083502284822685, 0.5640417354618168, 0.5752420038829522, 0.5889700733809504, 0.5618083904615305, 0.555906671987905, 0.5478935959457947, 0.8309191981523927, 0.16977496150361493, 0.8571731693829249, 0.2131287005263246, 0.8654153883109152, 0.7888249704723402, 0.8306736345124398, 0.8405217978384227, 0.7826229781633584, 0.5504505496695846, 0.4609763614768775, 0.6171796563097479, 0.6058785254441058, 0.4971873287598222, 0.6498811649635037, 0.616750195928925, 0.5535256009320549, 0.1321811005144795, 0.5742850570598579, 0.47385105956639284, 0.5185165604833146, 0.5905734179954563, 0.6407035087908766, 0.574628389547235, 0.5182239953497487, 0.5345769209460479, 0.5865701851765353, 0.306159710951873, 0.34614607503665396, 0.3967193148172743, 0.3214064959632179, 0.37730277381184507, 0.3707099918175786, 0.4347787591606864, 0.3151387998752363, 0.43500507244715114, 0.5424170197962371, 0.49349590679305655, 0.5115493055746727, 0.528269245822695, 0.5219073623934471, 0.4739575936998289, 0.5807876819372022, 0.5388378813330577, 0.5389516934175052, 0.19678951494338393, 0.07213972683525804, 0.09456190279994547, 0.36831203098737564, 0.10876783876958329, 0.15316726074491793, 0.3237009861221404, 0.12857085788917288, 0.16044936755678374, 0.3714014008950942, 0.33408174590040385, 0.35998315054717, 0.3707850588044932, 0.37344063136705385, 0.3734698476679694, 0.3383085436423602, 0.32444093716119105, 0.3425702559793058, 0.7593101556564303, 0.7413629206540788, 0.7731595272863633, 0.7403034355964285, 0.7399413777729932, 0.7720837888966623, 0.767781323965766, 0.7305474746735954, 0.7590149552524972, 0.09715972538866424, 0.11015301992524096, 0.1255813076135277, 0.12853515545776595, 0.14014308217683646, 0.13271535663351475, 0.11625656127235873, 0.1213423579322811, 0.11862017197998265, 0.19239234358247048, 0.2886333131436293, 0.17844346823076562, 0.2574477590214157, 0.25052285424687626, 0.34502289591058133, 0.27413317315318486, 0.33517800618237925, 0.29501759834890195, 0.49749934350136615, 0.5191322718693147, 0.49371313613852386, 0.5230342164932302, 0.4962016871155964, 0.5413075409589618, 0.5862430509465537, 0.5627157774056694, 0.5789861848400021, 0.3855815714433899, 0.3254162728098038, 0.3114779296800624, 0.3969176404983725, 0.20698968977797372, 0.3876840569550074, 0.3836287667245214, 0.37497819984665204, 0.28094297840496496, 0.21732653363798016, 0.2050927356501543, 0.20173196474596689, 0.20019733673346873, 0.22092828513756513, 0.1906030916033601, 0.22299185879791517, 0.18462493333792773, 0.21410637010862643, 0.19125400819608585, 0.24199783574895828, 0.20712576638312552, 0.2404386217575636, 0.22313582489396544, 0.21057160840655853, 0.22260812541979735, 0.2371662352955889, 0.7342450513505532, 0.8743676990641347, 0.857497047168996, 0.15347825338303045, 0.17877119067986058, 0.16929958578168702, 0.1932688296029612, 0.8352597621618392, 0.8277702325981031, 0.8294769425096726, 0.8283533173538173, 0.20967979998975328, 0.20244342936842852, 0.8388272782434493, 0.1674341658527153, 0.7891657747784925, 0.2142494262607898, 0.8415839503724241, 0.8348944358393124, 0.18931305717379532, 0.20138586423796434, 0.20741392745653764, 0.17768116788355015, 0.31482355980940546, 0.1829581798048644, 0.20152335463858095, 0.211382522716836, 0.1878246496911794, 0.11596467989419756, 0.09522776771419716, 0.08549570897967207, 0.09194058225525292, 0.0747751116631713, 0.09699903935468379, 0.08144123476190057, 0.15479035815043574, 0.0962143195903391]}, "mutation_prompt": null}
{"id": "a17d804b-9c9a-432a-b3b3-895e0dce7d3e", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.6  # Adjusted differential weight for exploration-exploitation balance\n        self.CR_base = 0.8  # Adjusted crossover probability\n        self.adaptation_rate = 0.02  # Lower adaptive change rate for stability\n        self.local_search_intensity = 0.1  # Intensity of local search\n        self.mutation_strategy = 'best'  # Using a mix of 'best' and 'rand' strategies\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        # Track the best solution found\n        best_index = np.argmin(fitness)\n        best_individual = population[best_index]\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Adaptive F and CR\n                F = self.F_base + self.adaptation_rate * np.random.randn()\n                CR = self.CR_base + self.adaptation_rate * np.random.randn()\n\n                # Dynamic mutation strategy selection\n                if np.random.rand() < 0.5:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = population[indices]\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(self.population_size, 2, replace=False)\n                    a, b = population[indices]\n                    mutant = np.clip(best_individual + F * (a - b), self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n\n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection and elitism\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Cooperative local search around the best individual\n            neighborhood_size = int(self.local_search_intensity * self.population_size)\n            local_neighbors = best_individual + np.random.uniform(-0.05, 0.05, (neighborhood_size, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n\n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_local_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_local_index]\n                best_fitness = local_fitness[best_local_index]\n\n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        return best_individual", "name": "HybridAdaptiveDifferentialEvolution", "description": "A hybrid adaptive differential evolution with dynamic parameter control and cooperative local search for enhanced convergence speed.", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "60b3a51e-22ed-4cc2-9a37-d742ccc0f871", "metadata": {"aucs": [0.8619351864320388, 0.8654340039274515, 0.8722648263184456, 0.877359993739161, 0.8733189681286274, 0.8845013937581183, 0.8814411496896972, 0.8679245928160655, 0.8717445788538832, 0.7570065617871957, 0.7668081713250303, 0.7556551273140312, 0.7710736043041881, 0.7416022515477132, 0.7484516206265178, 0.7672941575852692, 0.7696231100050808, 0.7563618993416057, 0.17738823455709374, 0.15472942685807067, 0.15380601292745322, 0.1834943951808552, 0.16544021647767748, 0.17250368940062022, 0.1757555511194041, 0.13052187966424467, 0.4196786163803936, 0.14514885095087482, 0.15098280004487374, 0.14528326216956944, 0.14404546243923977, 0.1297750996164857, 0.12833452866300143, 0.14891767859870852, 0.14145217697140633, 0.10706547763488217, 0.9829928765439452, 0.9744146522536012, 0.9781895694960724, 0.9876835489218235, 0.9768908416089108, 0.9790470928264963, 0.984331235653565, 0.9732642167912735, 0.9793943145633308, 0.537855919215161, 0.5419122244099366, 0.5083502284822685, 0.5640417354618168, 0.5752420038829522, 0.5889700733809504, 0.5618083904615305, 0.555906671987905, 0.5478935959457947, 0.8309191981523927, 0.16977496150361493, 0.8571731693829249, 0.2131287005263246, 0.8654153883109152, 0.7888249704723402, 0.8306736345124398, 0.8405217978384227, 0.7826229781633584, 0.5504505496695846, 0.4609763614768775, 0.6171796563097479, 0.6058785254441058, 0.4971873287598222, 0.6498811649635037, 0.616750195928925, 0.5535256009320549, 0.1321811005144795, 0.5742850570598579, 0.47385105956639284, 0.5185165604833146, 0.5905734179954563, 0.6407035087908766, 0.574628389547235, 0.5182239953497487, 0.5345769209460479, 0.5865701851765353, 0.306159710951873, 0.34614607503665396, 0.3967193148172743, 0.3214064959632179, 0.37730277381184507, 0.3707099918175786, 0.4347787591606864, 0.3151387998752363, 0.43500507244715114, 0.5424170197962371, 0.49349590679305655, 0.5115493055746727, 0.528269245822695, 0.5219073623934471, 0.4739575936998289, 0.5807876819372022, 0.5388378813330577, 0.5389516934175052, 0.19678951494338393, 0.07213972683525804, 0.09456190279994547, 0.36831203098737564, 0.10876783876958329, 0.15316726074491793, 0.3237009861221404, 0.12857085788917288, 0.16044936755678374, 0.3714014008950942, 0.33408174590040385, 0.35998315054717, 0.3707850588044932, 0.37344063136705385, 0.3734698476679694, 0.3383085436423602, 0.32444093716119105, 0.3425702559793058, 0.7593101556564303, 0.7413629206540788, 0.7731595272863633, 0.7403034355964285, 0.7399413777729932, 0.7720837888966623, 0.767781323965766, 0.7305474746735954, 0.7590149552524972, 0.09715972538866424, 0.11015301992524096, 0.1255813076135277, 0.12853515545776595, 0.14014308217683646, 0.13271535663351475, 0.11625656127235873, 0.1213423579322811, 0.11862017197998265, 0.19239234358247048, 0.2886333131436293, 0.17844346823076562, 0.2574477590214157, 0.25052285424687626, 0.34502289591058133, 0.27413317315318486, 0.33517800618237925, 0.29501759834890195, 0.49749934350136615, 0.5191322718693147, 0.49371313613852386, 0.5230342164932302, 0.4962016871155964, 0.5413075409589618, 0.5862430509465537, 0.5627157774056694, 0.5789861848400021, 0.3855815714433899, 0.3254162728098038, 0.3114779296800624, 0.3969176404983725, 0.20698968977797372, 0.3876840569550074, 0.3836287667245214, 0.37497819984665204, 0.28094297840496496, 0.21732653363798016, 0.2050927356501543, 0.20173196474596689, 0.20019733673346873, 0.22092828513756513, 0.1906030916033601, 0.22299185879791517, 0.18462493333792773, 0.21410637010862643, 0.19125400819608585, 0.24199783574895828, 0.20712576638312552, 0.2404386217575636, 0.22313582489396544, 0.21057160840655853, 0.22260812541979735, 0.2371662352955889, 0.7342450513505532, 0.8743676990641347, 0.857497047168996, 0.15347825338303045, 0.17877119067986058, 0.16929958578168702, 0.1932688296029612, 0.8352597621618392, 0.8277702325981031, 0.8294769425096726, 0.8283533173538173, 0.20967979998975328, 0.20244342936842852, 0.8388272782434493, 0.1674341658527153, 0.7891657747784925, 0.2142494262607898, 0.8415839503724241, 0.8348944358393124, 0.18931305717379532, 0.20138586423796434, 0.20741392745653764, 0.17768116788355015, 0.31482355980940546, 0.1829581798048644, 0.20152335463858095, 0.211382522716836, 0.1878246496911794, 0.11596467989419756, 0.09522776771419716, 0.08549570897967207, 0.09194058225525292, 0.0747751116631713, 0.09699903935468379, 0.08144123476190057, 0.15479035815043574, 0.0962143195903391]}, "mutation_prompt": null}
{"id": "a7109ced-ce56-4151-9a1e-b61ad228a0b3", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.6  # Adjusted differential weight for exploration-exploitation balance\n        self.CR_base = 0.8  # Adjusted crossover probability\n        self.adaptation_rate = 0.02  # Lower adaptive change rate for stability\n        self.local_search_intensity = 0.1  # Intensity of local search\n        self.mutation_strategy = 'best'  # Using a mix of 'best' and 'rand' strategies\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        # Track the best solution found\n        best_index = np.argmin(fitness)\n        best_individual = population[best_index]\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Adaptive F and CR\n                F = self.F_base + self.adaptation_rate * np.random.randn()\n                CR = self.CR_base + self.adaptation_rate * np.random.randn()\n\n                # Dynamic mutation strategy selection\n                if np.random.rand() < 0.5:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = population[indices]\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(self.population_size, 2, replace=False)\n                    a, b = population[indices]\n                    mutant = np.clip(best_individual + F * (a - b), self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n\n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection and elitism\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Cooperative local search around the best individual\n            neighborhood_size = int(self.local_search_intensity * self.population_size)\n            local_neighbors = best_individual + np.random.uniform(-0.05, 0.05, (neighborhood_size, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n\n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_local_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_local_index]\n                best_fitness = local_fitness[best_local_index]\n\n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        return best_individual", "name": "HybridAdaptiveDifferentialEvolution", "description": "A hybrid adaptive differential evolution with dynamic parameter control and cooperative local search for enhanced convergence speed.", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "60b3a51e-22ed-4cc2-9a37-d742ccc0f871", "metadata": {"aucs": [0.8619351864320388, 0.8654340039274515, 0.8722648263184456, 0.877359993739161, 0.8733189681286274, 0.8845013937581183, 0.8814411496896972, 0.8679245928160655, 0.8717445788538832, 0.7570065617871957, 0.7668081713250303, 0.7556551273140312, 0.7710736043041881, 0.7416022515477132, 0.7484516206265178, 0.7672941575852692, 0.7696231100050808, 0.7563618993416057, 0.17738823455709374, 0.15472942685807067, 0.15380601292745322, 0.1834943951808552, 0.16544021647767748, 0.17250368940062022, 0.1757555511194041, 0.13052187966424467, 0.4196786163803936, 0.14514885095087482, 0.15098280004487374, 0.14528326216956944, 0.14404546243923977, 0.1297750996164857, 0.12833452866300143, 0.14891767859870852, 0.14145217697140633, 0.10706547763488217, 0.9829928765439452, 0.9744146522536012, 0.9781895694960724, 0.9876835489218235, 0.9768908416089108, 0.9790470928264963, 0.984331235653565, 0.9732642167912735, 0.9793943145633308, 0.537855919215161, 0.5419122244099366, 0.5083502284822685, 0.5640417354618168, 0.5752420038829522, 0.5889700733809504, 0.5618083904615305, 0.555906671987905, 0.5478935959457947, 0.8309191981523927, 0.16977496150361493, 0.8571731693829249, 0.2131287005263246, 0.8654153883109152, 0.7888249704723402, 0.8306736345124398, 0.8405217978384227, 0.7826229781633584, 0.5504505496695846, 0.4609763614768775, 0.6171796563097479, 0.6058785254441058, 0.4971873287598222, 0.6498811649635037, 0.616750195928925, 0.5535256009320549, 0.1321811005144795, 0.5742850570598579, 0.47385105956639284, 0.5185165604833146, 0.5905734179954563, 0.6407035087908766, 0.574628389547235, 0.5182239953497487, 0.5345769209460479, 0.5865701851765353, 0.306159710951873, 0.34614607503665396, 0.3967193148172743, 0.3214064959632179, 0.37730277381184507, 0.3707099918175786, 0.4347787591606864, 0.3151387998752363, 0.43500507244715114, 0.5424170197962371, 0.49349590679305655, 0.5115493055746727, 0.528269245822695, 0.5219073623934471, 0.4739575936998289, 0.5807876819372022, 0.5388378813330577, 0.5389516934175052, 0.19678951494338393, 0.07213972683525804, 0.09456190279994547, 0.36831203098737564, 0.10876783876958329, 0.15316726074491793, 0.3237009861221404, 0.12857085788917288, 0.16044936755678374, 0.3714014008950942, 0.33408174590040385, 0.35998315054717, 0.3707850588044932, 0.37344063136705385, 0.3734698476679694, 0.3383085436423602, 0.32444093716119105, 0.3425702559793058, 0.7593101556564303, 0.7413629206540788, 0.7731595272863633, 0.7403034355964285, 0.7399413777729932, 0.7720837888966623, 0.767781323965766, 0.7305474746735954, 0.7590149552524972, 0.09715972538866424, 0.11015301992524096, 0.1255813076135277, 0.12853515545776595, 0.14014308217683646, 0.13271535663351475, 0.11625656127235873, 0.1213423579322811, 0.11862017197998265, 0.19239234358247048, 0.2886333131436293, 0.17844346823076562, 0.2574477590214157, 0.25052285424687626, 0.34502289591058133, 0.27413317315318486, 0.33517800618237925, 0.29501759834890195, 0.49749934350136615, 0.5191322718693147, 0.49371313613852386, 0.5230342164932302, 0.4962016871155964, 0.5413075409589618, 0.5862430509465537, 0.5627157774056694, 0.5789861848400021, 0.3855815714433899, 0.3254162728098038, 0.3114779296800624, 0.3969176404983725, 0.20698968977797372, 0.3876840569550074, 0.3836287667245214, 0.37497819984665204, 0.28094297840496496, 0.21732653363798016, 0.2050927356501543, 0.20173196474596689, 0.20019733673346873, 0.22092828513756513, 0.1906030916033601, 0.22299185879791517, 0.18462493333792773, 0.21410637010862643, 0.19125400819608585, 0.24199783574895828, 0.20712576638312552, 0.2404386217575636, 0.22313582489396544, 0.21057160840655853, 0.22260812541979735, 0.2371662352955889, 0.7342450513505532, 0.8743676990641347, 0.857497047168996, 0.15347825338303045, 0.17877119067986058, 0.16929958578168702, 0.1932688296029612, 0.8352597621618392, 0.8277702325981031, 0.8294769425096726, 0.8283533173538173, 0.20967979998975328, 0.20244342936842852, 0.8388272782434493, 0.1674341658527153, 0.7891657747784925, 0.2142494262607898, 0.8415839503724241, 0.8348944358393124, 0.18931305717379532, 0.20138586423796434, 0.20741392745653764, 0.17768116788355015, 0.31482355980940546, 0.1829581798048644, 0.20152335463858095, 0.211382522716836, 0.1878246496911794, 0.11596467989419756, 0.09522776771419716, 0.08549570897967207, 0.09194058225525292, 0.0747751116631713, 0.09699903935468379, 0.08144123476190057, 0.15479035815043574, 0.0962143195903391]}, "mutation_prompt": null}
{"id": "01818baa-fe74-49b3-877a-a314dd085c0d", "solution": "import numpy as np\n\nclass MultiStrategyHybridADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = min(50, self.budget // 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.7  # Slightly increased differential weight\n        self.CR_base = 0.9  # Increased crossover probability for exploitation\n        self.adaptation_rate = 0.05  # Increased adaptation rate\n        self.local_search_intensity = 0.2  # Increased local search intensity\n        self.mutation_strategies = ['best', 'rand']  # Utilize both strategies\n        self.population_size = self.initial_population_size\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        # Track the best solution found\n        best_index = np.argmin(fitness)\n        best_individual = population[best_index]\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Adaptive F and CR\n                F = np.clip(self.F_base + self.adaptation_rate * np.random.randn(), 0, 1)\n                CR = np.clip(self.CR_base + self.adaptation_rate * np.random.randn(), 0, 1)\n\n                # Dynamic mutation strategy selection\n                strategy = np.random.choice(self.mutation_strategies)\n                if strategy == 'rand':\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = population[indices]\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    # 'best' strategy\n                    indices = np.random.choice(self.population_size, 2, replace=False)\n                    a, b = population[indices]\n                    mutant = np.clip(best_individual + F * (a - b), self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n\n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection and elitism\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Enhanced local search using the top individuals\n            top_size = max(1, self.population_size // 5)  # Top 20% for local search\n            top_indices = np.argsort(fitness)[:top_size]\n            for idx in top_indices:\n                local_neighbors = population[idx] + np.random.uniform(-0.1, 0.1, (5, self.dim))\n                local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n                local_fitness = np.array([func(ind) for ind in local_neighbors])\n                eval_count += len(local_neighbors)\n\n                # Update if a better local neighbor is found\n                best_local_index = np.argmin(local_fitness)\n                if local_fitness[best_local_index] < fitness[idx]:\n                    population[idx] = local_neighbors[best_local_index]\n                    fitness[idx] = local_fitness[best_local_index]\n                    if local_fitness[best_local_index] < best_fitness:\n                        best_individual = local_neighbors[best_local_index]\n                        best_fitness = local_fitness[best_local_index]\n\n            # Adaptive population size adjustment\n            if eval_count < self.budget // 2 and np.random.rand() < 0.1:\n                self.population_size = min(self.population_size + 1, self.budget // 5)\n                new_individual = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                new_fitness = func(new_individual)\n                eval_count += 1\n                if new_fitness < best_fitness:\n                    best_individual = new_individual\n                    best_fitness = new_fitness\n                if new_fitness < np.max(fitness):\n                    worst_index = np.argmax(fitness)\n                    population[worst_index] = new_individual\n                    fitness[worst_index] = new_fitness\n\n        # Return best found solution\n        return best_individual", "name": "MultiStrategyHybridADE", "description": "A multi-strategy hybrid adaptive differential evolution with adaptive population size and enhanced local search for improved convergence speed.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 50 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 50 is out of bounds for axis 0 with size 50')", "parent_id": "60b3a51e-22ed-4cc2-9a37-d742ccc0f871", "metadata": {}, "mutation_prompt": null}
{"id": "3b0f3980-65a9-4e2f-aeba-625d6f71a892", "solution": "import numpy as np\n\nclass ParallelIslandsDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.island_count = 5  # Parallel islands for diversity\n        self.population_size = max(5, self.budget // (self.island_count * 10))\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_range = (0.4, 0.9)  # Range for differential weight\n        self.CR_range = (0.6, 0.9)  # Range for crossover probability\n        self.local_search_probability = 0.1  # Probability of local search\n        self.mutation_strategy = 'rand'  # 'rand' strategy for global exploration\n\n    def __call__(self, func):\n        # Initialize multiple island populations\n        islands = [np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                   for _ in range(self.island_count)]\n        fitness = [np.array([func(ind) for ind in island]) for island in islands]\n        eval_count = self.population_size * self.island_count\n\n        # Track the best solution found across all islands\n        best_fitness = np.inf\n        best_individual = None\n\n        while eval_count < self.budget:\n            for island_index, island in enumerate(islands):\n                island_fitness = fitness[island_index]\n                best_island_index = np.argmin(island_fitness)\n                island_best_individual = island[best_island_index]\n\n                for i in range(self.population_size):\n                    # Adaptive F and CR with random selection\n                    F = np.random.uniform(*self.F_range)\n                    CR = np.random.uniform(*self.CR_range)\n\n                    # 'rand' mutation strategy with elitism\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = island[indices]\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                    trial = np.where(np.random.rand(self.dim) < CR, mutant, island[i])\n\n                    # Evaluate trial individual\n                    trial_fitness = func(trial)\n                    eval_count += 1\n\n                    # Selection and update\n                    if trial_fitness < island_fitness[i]:\n                        island[i] = trial\n                        island_fitness[i] = trial_fitness\n                        if trial_fitness < best_fitness:\n                            best_individual = trial\n                            best_fitness = trial_fitness\n\n                    if eval_count >= self.budget:\n                        break\n\n                # Local search for local refinement\n                if np.random.rand() < self.local_search_probability:\n                    search_point = island_best_individual + np.random.uniform(-0.05, 0.05, self.dim)\n                    search_point = np.clip(search_point, self.lower_bound, self.upper_bound)\n                    search_fitness = func(search_point)\n                    eval_count += 1\n                    if search_fitness < island_fitness[best_island_index]:\n                        island[best_island_index] = search_point\n                        island_fitness[best_island_index] = search_fitness\n                        if search_fitness < best_fitness:\n                            best_individual = search_point\n                            best_fitness = search_fitness\n\n            # Migrate best individuals between islands for information exchange\n            if eval_count + self.island_count < self.budget:\n                best_individuals = [island[np.argmin(f)] for island, f in zip(islands, fitness)]\n                for i in range(self.island_count):\n                    islands[i][0] = best_individuals[i]\n                    fitness[i][0] = func(best_individuals[i])\n                eval_count += self.island_count\n\n        # Return best found solution\n        return best_individual", "name": "ParallelIslandsDifferentialEvolution", "description": "An enhanced differential evolution algorithm with adaptive parameters, island-based parallel search, and elitist local refinement for improved convergence speed.", "configspace": "", "generation": 57, "fitness": 0.11631665929160971, "feedback": "The algorithm ParallelIslandsDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.12.", "error": "", "parent_id": "60b3a51e-22ed-4cc2-9a37-d742ccc0f871", "metadata": {"aucs": [0.1901519547494973, 0.1847395701487602, 0.17976435264060142, 0.17883688350860882, 0.19700341572276148, 0.2115196255391404, 0.1972329923576387, 0.18253084126659846, 0.17865651741248456, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05318642782881544, 0.04958863370531874, 0.04710595360495118, 0.04555716187102421, 0.057472694690817616, 0.05147181391957234, 0.055556316506157, 0.05783603134157134, 0.05042032258550311, 0.03539916917190111, 0.03346213827008471, 0.03322860253706117, 0.036824406672952725, 0.03314809193605994, 0.03476652214101705, 0.04059468433318014, 0.03478304780625263, 0.03822056369216065, 0.6440034669381376, 0.796096712458191, 0.5509318489630289, 0.653458775073996, 0.49977894193250094, 0.6127899325532563, 0.5359519950913085, 0.49528186169498767, 0.5822198467243522, 0.08412868017287933, 0.0871403247068967, 0.10693907592235008, 0.08857639931478989, 0.11311835559528827, 0.07073826650861725, 0.09555159021204418, 0.08271683101573868, 0.1285511935980712, 0.13352377025342121, 0.19308637766117165, 0.14958629485954789, 0.12732630486676422, 0.12721203801888536, 0.15106796835645586, 0.13285024385172362, 0.12133157637462466, 0.1367259873761163, 0.013468024494470598, 0.01000611359311876, 0.006256312430225841, 0.023624362502336238, 0.02181934197420965, 0.01399701082874294, 0.011271375037082865, 0.03469903719061529, 0.009275397265935847, 0.0056067500226588685, 0.012092368628205286, 0.028767909351643306, 0.008861512317918097, 0.03902233424140067, 0.03646757103224296, 0.019609212110172636, 0.019901777679167343, 0.04783044509615997, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05912594141638294, 0.09057301112800364, 0.05356369522022231, 0.045803510374605505, 0.03968461677194557, 0.06777680423511534, 0.036743462242774694, 0.049752454094397214, 0.050005520790000424, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00856146924099599, 0.0004325082041428674, 0.01292275742818949, 9.999999999998899e-05, 0.003479753510124306, 0.0011609989002663301, 0.003604749116831618, 0.005764628861546606, 0.2211473357114564, 0.20001423592998846, 0.21135025581217892, 0.2111668308517416, 0.19740463025810373, 0.21163050605953526, 0.21071900160169388, 0.21814065543661343, 0.22908262211043318, 0.05996360842112458, 0.05169028588334712, 0.04501596012678599, 0.05072587967964959, 0.05059961014546843, 0.04238521344626811, 0.046484177928167836, 0.05546579087847148, 0.05318557737958085, 0.13709410100555053, 0.14525027724917194, 0.15672030933036607, 0.14365108109809566, 0.14541009538473404, 0.13176155761510167, 0.14963138758589234, 0.13820621396549726, 0.14112982305949862, 0.16573713170059257, 0.16342966579678864, 0.17790852974988047, 0.16294666755771137, 0.1679469672345807, 0.1736435379538348, 0.18991563396381528, 0.18350391682666323, 0.16159965770465345, 0.11056387547003743, 0.10754561696298792, 0.113562908641483, 0.1069969746690953, 0.12365964001020313, 0.11677389879199851, 0.13231989384823828, 0.12393963070969838, 0.10241485308691844, 0.15438346184273144, 0.15884912185609246, 0.1708008126220142, 0.1454715219192525, 0.19018463050870993, 0.15721798473301418, 0.16544527354395155, 0.14874405680310954, 0.16948378782953444, 0.1457027977824924, 0.15580991183415005, 0.154561095062425, 0.14425009493178365, 0.15604490362288015, 0.14527480345507993, 0.15428498048361106, 0.14134743724651977, 0.16207881422481074, 0.15352983975287093, 0.22645961317376817, 0.1628302812737371, 0.1589581757521914, 0.15393294280998582, 0.16090316970340135, 0.16203845944322914, 0.16659626696881658, 0.16095856209832982, 0.15354172467193583, 0.14390514720480152, 0.12942492253015148, 0.1586799618110747, 0.1506030495991585, 0.16216621838447354, 0.16619565734525077, 0.18481618044704662, 0.14729955662250482, 0.18558447439377035, 0.1924288666680144, 0.18388516815703704, 0.19229645999121125, 0.2135749380374129, 0.18059318502234833, 0.19134750257451238, 0.19391505769604844, 0.20568880668582523, 0.06480747617113503, 0.05660744366668147, 0.06585155299632517, 0.06173482877025327, 0.06260328617297184, 0.053410697119451456, 0.07532529613519179, 0.054140847664914005, 0.044215141148517434]}, "mutation_prompt": null}
{"id": "e6832940-20c6-4692-8876-d1a3aa93f678", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 8)  # Increased initial population for diverse exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.5  # Adjusted for balance between exploration and exploitation\n        self.CR_base = 0.9  # Increased crossover probability\n        self.adaptation_rate = 0.05  # Increased adaptive change rate\n        self.local_search_intensity = 0.15  # Increased intensity of local search\n        self.mutation_strategy = 'rand'  # Primary strategy with opposition-based learning\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        # Track the best solution found\n        best_index = np.argmin(fitness)\n        best_individual = population[best_index]\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Adaptive F and CR\n                F = np.abs(self.F_base + self.adaptation_rate * np.random.randn())\n                CR = np.clip(self.CR_base + self.adaptation_rate * np.random.randn(), 0.0, 1.0)\n\n                if np.random.rand() < 0.5:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = population[indices]\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(self.population_size, 2, replace=False)\n                    a, b = population[indices]\n                    mutant = np.clip(best_individual + F * (a - b), self.lower_bound, self.upper_bound)\n\n                # Opposition-based learning\n                opposite = self.lower_bound + self.upper_bound - mutant\n                opposite = np.clip(opposite, self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Evaluate opposite individual\n                opposite_fitness = func(opposite)\n                eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i] and trial_fitness <= opposite_fitness:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                elif opposite_fitness < fitness[i]:\n                    population[i] = opposite\n                    fitness[i] = opposite_fitness\n\n                # Update best if needed\n                if fitness[i] < best_fitness:\n                    best_individual = population[i]\n                    best_fitness = fitness[i]\n\n                if eval_count >= self.budget:\n                    break\n\n            # Enhanced local search around the best individual\n            neighborhood_size = int(self.local_search_intensity * self.population_size)\n            local_neighbors = best_individual + np.random.uniform(-0.1, 0.1, (neighborhood_size, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n\n            if np.min(local_fitness) < best_fitness:\n                best_local_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_local_index]\n                best_fitness = local_fitness[best_local_index]\n\n            # Self-adaptive population management\n            if eval_count < self.budget * 0.5 and np.random.rand() < 0.1:\n                new_indices = np.random.choice(self.population_size, size=self.population_size // 2, replace=False)\n                new_population = np.random.uniform(self.lower_bound, self.upper_bound, (len(new_indices), self.dim))\n                for idx, new_ind in zip(new_indices, new_population):\n                    population[idx] = new_ind\n                    fitness[idx] = func(new_ind)\n                    eval_count += 1\n\n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        return best_individual", "name": "EnhancedDifferentialEvolution", "description": "A multi-strategy adaptive differential evolution that incorporates opposition-based learning and self-adaptive population management for accelerated convergence.", "configspace": "", "generation": 58, "fitness": 0.3143902109094562, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.24.", "error": "", "parent_id": "60b3a51e-22ed-4cc2-9a37-d742ccc0f871", "metadata": {"aucs": [0.7910388465774849, 0.5835521136942301, 0.7376204143460788, 0.7826187855447319, 0.6161900707342205, 0.7051133002279169, 0.8211967345999897, 0.5943522673261754, 0.7342648796327835, 0.6329212041658702, 0.08428255949413566, 0.3870759650644422, 0.4874239801380058, 0.3742095752656541, 0.4868300344842088, 0.5468875896839154, 0.24568561884691142, 0.2915687001990428, 0.15556835382827772, 0.10421586615055234, 0.11002681349710708, 0.12205241789774812, 0.15101635370100552, 0.11860895328260979, 0.10822168827367151, 0.13137291757195835, 0.14092628530572204, 0.10420630625691407, 0.09361890764388792, 0.10731694297380057, 0.12331583226465415, 0.1196927251847999, 0.0960616368550603, 0.10491984626475492, 0.08709215264995418, 0.09601046956207082, 0.9769608718226939, 0.9617253723071818, 0.9715903970665658, 0.958205887543486, 0.959374753841048, 0.9595532646206301, 0.9539443325243537, 0.9502699683651626, 0.9864986349851729, 0.28816943312991694, 0.3341200045660032, 0.4028441872586215, 0.5104162110272645, 0.2957218055079224, 0.40640105664959736, 0.37478361315027076, 0.3710557095753805, 0.4005285497676916, 0.7385005142902248, 0.5278911271394173, 0.7485158763930277, 0.20613848239132337, 0.5000166548400621, 0.2072088455836748, 0.6978158272864141, 0.45121437760394567, 0.4081961817377804, 0.41913817164317724, 0.15926565240514556, 0.39535911885015207, 0.11772166356015801, 0.1570312323459928, 0.4463417659957081, 0.3607377859048313, 0.16863503673895253, 0.18529626200996718, 0.5586726569050475, 0.16717388554219692, 0.13164999391514598, 0.47773839082103253, 0.2308801357196717, 0.3983903080925477, 0.4077866415421736, 0.22539977637390907, 0.43202861248248214, 0.31649550121328507, 0.10690465430620066, 0.07788124648075467, 0.12007768527626428, 0.252491037366534, 0.11407598042942879, 0.17938290634275422, 0.09114653709797671, 0.08414464052620518, 0.4721427268758259, 0.23290926871463036, 0.25416924309033884, 0.4121861279194634, 0.4092904027176313, 0.2644166699509737, 0.5565813121370521, 0.23822883681092977, 0.38014034354738224, 0.02781027080584586, 0.01547811954726419, 0.07075177137471023, 0.0822619975189216, 0.04913202161914454, 0.052441047208463765, 0.08895016642338882, 0.012635963070486422, 0.09502215465697228, 0.21201961423440574, 0.16820510029506663, 0.17651733501295563, 0.2650687444109372, 0.15120179565358027, 0.17912262193594486, 0.3362089132511791, 0.14161800544267167, 0.10424716481702201, 0.6327128869102873, 0.4775487236696897, 0.5395806490891573, 0.6388073105784433, 0.5140156478352781, 0.504949174421923, 0.6792523612379222, 0.4548769900639531, 0.6106597312335194, 0.12827434560544115, 0.08508400988848175, 0.0848870008187993, 0.1513079954840607, 0.07971450326641083, 0.11310464253446384, 0.11851841640890415, 0.09952255215980443, 0.11647002942613649, 0.14388750755741353, 0.1737362052521808, 0.1838917819871524, 0.30044859647413036, 0.23540591752038686, 0.1745813362775036, 0.14510929694910757, 0.19045657796469795, 0.1951666419987621, 0.422108211715696, 0.2650901816376723, 0.2865377018080054, 0.43805535762043923, 0.2735309115558966, 0.28393729437771886, 0.4030855220266921, 0.2687899573955398, 0.2966051534624724, 0.21711810170790313, 0.24421895799141535, 0.27492618456866025, 0.29694001055142605, 0.26419291623217367, 0.286688717918569, 0.2891975605826156, 0.23922518611092003, 0.22189544581525122, 0.2226964728192946, 0.2096744051581948, 0.19100809060531487, 0.21969468282022664, 0.1990353859819729, 0.21392665046849346, 0.22477824005743086, 0.1990138673421339, 0.19433610234376242, 0.1917175558598293, 0.19087288952744497, 0.24839450804041974, 0.19674489045178278, 0.18716478933585923, 0.19177656251492736, 0.48001133028251475, 0.1960135426966262, 0.22201825309295176, 0.8052072824422354, 0.19675763227919285, 0.7452803325065227, 0.8722613792215861, 0.43541065147274094, 0.15963929807040045, 0.5876566129145946, 0.17001562773080037, 0.17318815704354507, 0.7840978420753368, 0.20954075011000006, 0.6531244114166158, 0.2070732247372027, 0.6363662015065215, 0.4943310179945798, 0.21287391869028893, 0.15299301428587297, 0.2086850240102308, 0.1753260174857615, 0.18049836796558338, 0.18947315940999232, 0.1889415508095882, 0.1837133222964058, 0.18893736203858513, 0.17795351640055157, 0.17451418325522805, 0.18747527295268207, 0.09510242539779301, 0.09358968593139727, 0.08323776320621368, 0.0949606788098094, 0.08212610442377388, 0.07117895058601476, 0.0784021902031844, 0.08965090613962656, 0.09036522643376266]}, "mutation_prompt": null}
{"id": "28a64e8c-6dd3-4a3f-b661-20a38acfbd46", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(60, self.budget // 8)  # Increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.7  # Improved differential weight for exploration-exploitation\n        self.CR_base = 0.9  # Adjusted crossover probability\n        self.adaptation_rate = 0.05  # Increased adaptive change rate\n        self.local_search_intensity = 0.15  # Enhanced local search intensity\n        self.cooling_rate = 0.99  # Adaptive cooling schedule\n        self.mutation_strategy = 'rand-to-best'  # New strategy for mutation\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        # Track the best solution found\n        best_index = np.argmin(fitness)\n        best_individual = population[best_index]\n        best_fitness = fitness[best_index]\n        current_CR = self.CR_base\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Adaptive F and CR with cooling\n                F = self.F_base * (self.cooling_rate ** (eval_count / self.budget))\n                current_CR = max(0.1, current_CR * (1 - self.adaptation_rate))\n\n                # Enhanced mutation strategy\n                target = population[i]\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(target + F * (best_individual - target) + F * (a - b), self.lower_bound, self.upper_bound)\n\n                # Self-repairing crossover\n                trial = np.where(np.random.rand(self.dim) < current_CR, mutant, target)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                # Evaluate trial individual with stochastic tunneling\n                trial_fitness = func(trial) + 0.01 * (np.random.rand() - 0.5)\n                eval_count += 1\n\n                # Selection and elitism\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Cooperative local search around the best individual\n            neighborhood_size = int(self.local_search_intensity * self.population_size)\n            local_neighbors = best_individual + np.random.uniform(-0.05, 0.05, (neighborhood_size, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n\n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_local_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_local_index]\n                best_fitness = local_fitness[best_local_index]\n\n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        return best_individual", "name": "EnhancedDifferentialEvolution", "description": "An enhanced differential evolution with adaptive cooling, self-repairing crossover, and stochastic tunneling for improved exploration and faster convergence.", "configspace": "", "generation": 59, "fitness": 0.205424096627376, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.18.", "error": "", "parent_id": "60b3a51e-22ed-4cc2-9a37-d742ccc0f871", "metadata": {"aucs": [0.4821228829865206, 0.4811008105558974, 0.4760513191021324, 0.517842854572917, 0.5008267762528679, 0.4565956603998026, 0.4438830884807291, 0.47139502613043394, 0.4665169009986805, 0.13415767905469345, 0.07595113476322313, 0.08220292738814838, 0.0840592531121298, 0.09356131249996502, 0.12350257017284327, 0.10551304023598473, 0.08487970283962165, 0.10710885653488988, 0.12222971508881675, 0.1126461364785335, 0.15643077185143683, 0.12598335691802498, 0.14170055166850892, 0.1254512486533138, 0.13625396414057955, 0.14662860963402868, 0.14421974803985482, 0.09944609661241577, 0.11702830513112772, 0.09774196429876592, 0.11213041656450129, 0.10610009547108001, 0.10435889101232443, 0.1412632634894473, 0.12007044811453393, 0.11712575725010388, 0.8383392522285744, 0.8405914725414845, 0.8633842024518157, 0.9110970859672222, 0.8247057183479004, 0.8350659188026697, 0.8132343796016779, 0.9208761433908865, 0.8557387631744671, 0.26109264163774737, 0.2374972253781481, 0.17752482572708705, 0.3221929370116453, 0.16807316672039418, 0.21182930057862936, 0.23837588003484733, 0.23938470956968427, 0.24075159300690485, 0.163850643347911, 0.17989033043708602, 0.12103022037855593, 0.21697126333838435, 0.21222870459449872, 0.22954380368776983, 0.18877295459125298, 0.16896413651981423, 0.21005517243904037, 0.13562421826731408, 0.1426622738245955, 0.15720900437216823, 0.14176562831472983, 0.1371554048206215, 0.11971991080348021, 0.10376919679936347, 0.15018710585698503, 0.1308582999417225, 0.11038230146795192, 0.10328410271997779, 0.08511075945882729, 0.122747486668628, 0.13303584508771527, 0.13805773278891542, 0.11802411956802605, 0.11909431323162445, 0.14771665147920954, 0.12475271638661212, 9.999999999998899e-05, 0.019185751764764447, 0.04345445930765601, 0.0012606257013030309, 0.008100491161427303, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07903620131581135, 0.04984089814983639, 0.08510225801052662, 0.05899686991563591, 0.0620517221544713, 0.0560821525962063, 0.10647149745599405, 0.057809768910889625, 0.0824782083812996, 0.00536083935150744, 0.005482957740315708, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0044111043214632994, 0.017358647791698933, 0.01486253591333786, 0.11386721199964644, 0.1234170110747147, 0.0951821108607892, 0.11553524764311407, 0.06251219353505244, 0.10945072236396058, 0.0722833761440217, 0.11415033749859849, 0.07983837872129917, 0.4254055993995409, 0.3529236187723541, 0.39195293468231596, 0.4040939248034795, 0.4177014596275499, 0.3961697083420439, 0.4449277268708727, 0.3645814841941767, 0.36208323362667694, 0.101946119859196, 0.10026939275416713, 0.13966960310858945, 0.12209517919406643, 0.08660879429035084, 0.08067394675242923, 0.08918868721112505, 0.09280817798670993, 0.08094189615161573, 0.1932373123421791, 0.17747604551612461, 0.1690789874556169, 0.2013085329439117, 0.1947496480756552, 0.14806028109439884, 0.1925490679474856, 0.16226837265860417, 0.23152757446755146, 0.2092552738469211, 0.19024704412123106, 0.2191429866240916, 0.2098196700090843, 0.24287866005227, 0.2126487709950745, 0.20132805053456182, 0.22069938001727096, 0.2093960818858146, 0.1678224562106574, 0.16456381880124793, 0.18470428789608273, 0.13241655815631515, 0.1640880488893537, 0.1985086749978432, 0.1590635706766207, 0.17640204126792014, 0.15035139036757428, 0.18223783855334807, 0.19583503590242768, 0.19653149656618984, 0.20670893964690773, 0.19778727087485382, 0.20880609115321003, 0.193310145334895, 0.1761373896357794, 0.1707596118064143, 0.18174501780505248, 0.18424934448999486, 0.18891218407753652, 0.1777051319186388, 0.18720075147246185, 0.19979149279977548, 0.19129524160786493, 0.196710996408078, 0.19869915537037564, 0.2849415623308629, 0.18382742762533266, 0.34560748121040974, 0.29151069600254675, 0.2931543982531466, 0.41395604588099055, 0.31342832409047683, 0.45964167630396224, 0.49697072477421156, 0.3940659525423029, 0.33059338336840105, 0.3007288348850541, 0.45929796789444854, 0.32659385722805545, 0.22183493044527247, 0.3102520763621013, 0.2424795263537507, 0.3534503349351187, 0.18510795674971525, 0.1803216184724139, 0.18140968542034608, 0.21005028417379656, 0.19285230453504676, 0.1745520394815061, 0.2090590554171533, 0.17918473894493148, 0.21844489825824043, 0.06512163862163978, 0.061553223963534354, 0.0680800779447076, 0.07655968962109894, 0.07827006139254644, 0.0792013245973594, 0.07243650337609142, 0.08226576016567833, 0.09205736533965081]}, "mutation_prompt": null}
{"id": "ec99e2dc-36dd-4b70-9fb0-6285f697cac9", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(60, self.budget // 8)  # Increased population size for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.5  # Adjusted for better exploration\n        self.CR_base = 0.9  # Increased to promote diversity\n        self.adaptation_rate = 0.05  # Increased adaptation rate for faster parameter adjustment\n        self.local_search_intensity = 0.15  # Increased local search intensity\n        self.mutation_prob = 0.7  # Probability of best or rand mutation\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        # Track the best solution found\n        best_index = np.argmin(fitness)\n        best_individual = population[best_index]\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Self-adaptive F and CR\n                F = np.clip(self.F_base + self.adaptation_rate * np.random.randn(), 0, 1)\n                CR = np.clip(self.CR_base + self.adaptation_rate * np.random.randn(), 0, 1)\n\n                # Choose mutation strategy based on a probability\n                if np.random.rand() < self.mutation_prob:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = population[indices]\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(self.population_size, 2, replace=False)\n                    a, b = population[indices]\n                    mutant = np.clip(best_individual + F * (a - b), self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n\n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection and elitism\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Enhanced cooperative local search around the best individual\n            neighborhood_size = int(self.local_search_intensity * self.population_size)\n            local_neighbors = best_individual + np.random.normal(0, 0.05, (neighborhood_size, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n\n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_local_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_local_index]\n                best_fitness = local_fitness[best_local_index]\n\n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        return best_individual", "name": "EnhancedHybridAdaptiveDifferentialEvolution", "description": "An enhanced hybrid adaptive differential evolution with increased local search adaptation and self-adaptive parameter tuning for rapid convergence.", "configspace": "", "generation": 60, "fitness": 0.474910577260961, "feedback": "The algorithm EnhancedHybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.28.", "error": "", "parent_id": "60b3a51e-22ed-4cc2-9a37-d742ccc0f871", "metadata": {"aucs": [0.870997610873655, 0.876937349254849, 0.8628821214606534, 0.8781794510016624, 0.8772296468912268, 0.8694279318528029, 0.8756843654306008, 0.8726768563847991, 0.8598523983391932, 0.7477842665418626, 0.7505830115174412, 0.7273487673266275, 0.7189706160361924, 0.7360234772212559, 0.7429061262623435, 0.7438642610252675, 0.7560429492372163, 0.7467399915536672, 0.16512467121215724, 0.21203315310966409, 0.36256095224927487, 0.16722241556246864, 0.13854119174963164, 0.3333937421616463, 0.13516368482132823, 0.14772951992740369, 0.15692171902064456, 0.1564408366174984, 0.1353579238051421, 0.14422112246044583, 0.11484204674412235, 0.11348023152341102, 0.11138379259342324, 0.14321803866866378, 0.14280534633632092, 0.15859257836490215, 0.9799585186455763, 0.9503327389088712, 0.9724501584066897, 0.9571617360165604, 0.9859598542069689, 0.9718842750065484, 0.9760859368284891, 0.9848955505579943, 0.973482908644332, 0.6071385211387058, 0.6173177688242826, 0.6131191937365257, 0.6198810082831014, 0.6308754058002048, 0.6151046424041569, 0.5929618643435774, 0.6259420273296028, 0.6123827674671722, 0.8398909658399296, 0.8539463927768597, 0.8286288287924357, 0.8479342703448974, 0.88641759183554, 0.8924952684036396, 0.8466961223205589, 0.8895895616883716, 0.8513347130888925, 0.6474349245531625, 0.13233776457818802, 0.6015251038894203, 0.12842010025943162, 0.6650660782032273, 0.729896318050316, 0.5838451394599409, 0.6038932677285569, 0.7486964038653956, 0.6027977688129897, 0.12904105617894945, 0.4970570551982538, 0.6338783710380922, 0.1311763787354625, 0.654584992183878, 0.13347577211066708, 0.5834411824896677, 0.6644167530846077, 0.5801341813173042, 0.6517131199065661, 0.5747597642597722, 0.5450781855850122, 0.6264774567937635, 0.5973118877387971, 0.5922806442473407, 0.6058774307227208, 0.5307442727477565, 0.7246104456113118, 0.7196658854680926, 0.6937459743116989, 0.6929901166276469, 0.6764640766292062, 0.6877991243894017, 0.7095399141637933, 0.7431058503302441, 0.7141560428367603, 0.5111644149668872, 0.12354566074955964, 0.13808117097245265, 0.16417221084055578, 0.5071824081123578, 0.2800834292901856, 0.15227794024262242, 0.2060402404781626, 0.43032493661029814, 0.49899493882997625, 0.5191627329886238, 0.4963062823251455, 0.519113603089481, 0.5317078511278232, 0.5517407313988787, 0.4828361527779109, 0.5174869321995552, 0.5274905608509252, 0.8230889833159312, 0.8274699863485728, 0.802146867581838, 0.7996643983062854, 0.8111585569300906, 0.8076406107590844, 0.8097513012737546, 0.813623972927586, 0.8012792400647224, 0.1543570750637966, 0.11202371696330105, 0.16342062676402602, 0.11988433445212554, 0.14401205285359286, 0.1247286910495965, 0.15758369478141976, 0.13863798943727346, 0.12049367302351399, 0.30905398943833184, 0.222262321964814, 0.21822555431598334, 0.1939458291385081, 0.4463802150027981, 0.2623165071326464, 0.388702947695691, 0.39316509265836086, 0.5641051301559905, 0.5559964566010401, 0.5794900739564952, 0.5592162804406543, 0.5334386158196133, 0.5634881082285331, 0.5764055782840386, 0.6324910585494613, 0.6113997600794387, 0.5576296411418729, 0.45822871852814717, 0.4632290950314738, 0.479100132440759, 0.46157879635820986, 0.43372108776671126, 0.4521519413829479, 0.4772208737947904, 0.47949489037925097, 0.4336084838960391, 0.21664866446744402, 0.21020796781048734, 0.20391775129587275, 0.2102933753324162, 0.21488300958379658, 0.22832035167615627, 0.19642172451381434, 0.19848521525915352, 0.24607068311088864, 0.22638461450377823, 0.21955924768255364, 0.22099698523152322, 0.2464495276526275, 0.2015667282287935, 0.20552757969012359, 0.20783549005238355, 0.21796835920185642, 0.21117204849685445, 0.17313527134759987, 0.8910706378954903, 0.15211568904684047, 0.8901467250816121, 0.19936136052459064, 0.1733889867309919, 0.14219936505632336, 0.15934671658200672, 0.21046538462018194, 0.8813767329362526, 0.8404360913909095, 0.8400914666175698, 0.2116666932825344, 0.16800672632850167, 0.8253102176423769, 0.16810764576068138, 0.21002542641758581, 0.8761756538100725, 0.21770435341516903, 0.19684888208430695, 0.20589586690149797, 0.18355856139871507, 0.20310480967848143, 0.18729717612734564, 0.18811472821621278, 0.1933542490469048, 0.1996172762222207, 0.08091856304424327, 0.08559185525502855, 0.09926782238828946, 0.07769180530251996, 0.08145907572888011, 0.09784577550374873, 0.08813891779584104, 0.09794845121770268, 0.09199369335995033]}, "mutation_prompt": null}
{"id": "fe90df2e-5840-4781-8982-eeaf0cae8d31", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(80, self.budget // 10)  # Adjusted population size for balance\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.6  # Slightly increased to enhance exploration\n        self.CR_base = 0.85  # Adjusted for a balanced crossover\n        self.adaptation_rate = 0.1  # Increased for more dynamic parameter changes\n        self.local_search_intensity = 0.2  # Enhanced local search intensity\n        self.mutation_prob = 0.6  # Balanced probability for mutation strategy\n        self.elite_frac = 0.2  # Fraction of best individuals for elite-biased mutation\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        # Track the best solution found\n        best_index = np.argmin(fitness)\n        best_individual = population[best_index]\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Self-adaptive F and CR with dynamic adjustment\n                F = np.clip(self.F_base + self.adaptation_rate * np.random.randn(), 0.4, 0.9)\n                CR = np.clip(self.CR_base + self.adaptation_rate * np.random.randn(), 0.7, 1.0)\n\n                # Elite-biased mutation strategy\n                if np.random.rand() < self.mutation_prob:\n                    elite_count = max(1, int(self.elite_frac * self.population_size))\n                    elite_indices = np.argpartition(fitness, elite_count)[:elite_count]\n                    a, b = population[np.random.choice(elite_indices, 2, replace=False)]\n                    c = population[np.random.choice(self.population_size)]\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = population[indices]\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n\n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection and elitism\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Enhanced cooperative local search around the best individual\n            neighborhood_size = int(self.local_search_intensity * self.population_size)\n            local_neighbors = best_individual + np.random.normal(0, 0.05, (neighborhood_size, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n\n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_local_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_local_index]\n                best_fitness = local_fitness[best_local_index]\n\n            population[np.argmin(fitness)] = best_individual\n            fitness[np.argmin(fitness)] = best_fitness\n\n        # Return best found solution\n        return best_individual", "name": "EnhancedHybridAdaptiveDifferentialEvolution", "description": "EnhancedHybridAdaptiveDifferentialEvolution with dynamic parameter control and elite-biased adaptation for faster convergence.", "configspace": "", "generation": 61, "fitness": 0.42564416472861655, "feedback": "The algorithm EnhancedHybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.25.", "error": "", "parent_id": "ec99e2dc-36dd-4b70-9fb0-6285f697cac9", "metadata": {"aucs": [0.829691627248866, 0.8232004380395438, 0.8197367352629912, 0.8288669226820133, 0.8344699420388058, 0.8380789871677141, 0.8209449038535557, 0.8278459343459379, 0.8356542463391734, 0.6768239543858591, 0.6643555780995196, 0.652696069592999, 0.6637596993939446, 0.6676762830715661, 0.6570360372416708, 0.6414106699118345, 0.6792328187265533, 0.6909184339040637, 0.27260276518035376, 0.19831141781574846, 0.13538355963213977, 0.14426485964543512, 0.15969392847652963, 0.19204912073644353, 0.15718154836540144, 0.28571866546671554, 0.15585767745064572, 0.13685948139078008, 0.15901581580465718, 0.1445046446194992, 0.20528808124382036, 0.12802285824894477, 0.15040333049280086, 0.1538380044913178, 0.14035075115043105, 0.1447675620212876, 0.986985233608579, 0.9892496946920514, 0.9813778182380654, 0.9736743601364684, 0.9827430487379192, 0.9859434792948009, 0.9828844405453268, 0.9835607161539639, 0.9792339656032087, 0.45362269421917667, 0.4873539223328638, 0.48772880317476686, 0.4969899981263106, 0.5380088967516736, 0.4850517125582956, 0.45411329558971525, 0.4985198604300862, 0.489604539906801, 0.8134479440135117, 0.7664021213844128, 0.7795557637200006, 0.8069701519237364, 0.8102553236596962, 0.8431490218217215, 0.7781813558004849, 0.7845360692229674, 0.8187165815774936, 0.4598043523251426, 0.4661509539000601, 0.12765912194482354, 0.528609355119589, 0.4987495549173566, 0.3824178359430128, 0.5099540042110808, 0.5326942251984654, 0.4472519595626724, 0.4480295434000764, 0.45042720278879367, 0.1285048528183208, 0.4439334579892592, 0.5028248146396321, 0.47484298164930583, 0.4326479363490886, 0.4581897065864289, 0.4920810484947631, 0.3557308405888, 0.41897367645607486, 0.4403018195511186, 0.4178770029999762, 0.41905733239776144, 0.4358619999902522, 0.45216498944680583, 0.4209275125966597, 0.4451937038995819, 0.5324049601962193, 0.5663253322714765, 0.5668364194991434, 0.5102333351035682, 0.5244209529230944, 0.5449140969957945, 0.5241587649124513, 0.6122170607045907, 0.5722443465229965, 0.18241512536173154, 0.1161320818624243, 0.15173670294142283, 0.28886491211990006, 0.1888757338059336, 0.3211739264929493, 0.254629080868106, 0.3192567953647847, 0.12123167209891905, 0.3428609768739005, 0.3637954021387363, 0.37452523727079146, 0.31518613683690033, 0.36179322452915075, 0.3532165677270185, 0.336172961211626, 0.35257198891898567, 0.3300201132623988, 0.7233243870350223, 0.7300402417317851, 0.7509452924773932, 0.7150069496696042, 0.7344373045282573, 0.7316550547301511, 0.6974187365268885, 0.7205774075339715, 0.7577874060249432, 0.13980125489248785, 0.11645612157874563, 0.13107590772698585, 0.144737305547044, 0.1418200608313529, 0.14616602181497584, 0.11702071488810306, 0.11001926260526684, 0.12360361087521776, 0.41609744104385005, 0.2659244466313485, 0.1626653223900566, 0.27400873726773545, 0.25168269010717315, 0.16140535014725288, 0.20972215792630722, 0.22280801955243812, 0.30072327886638417, 0.4228884940472314, 0.45400755539183824, 0.413853674204568, 0.39224316712447405, 0.3994287565534833, 0.44463094832023176, 0.46377103544208453, 0.4573952904617813, 0.48013486787398585, 0.3461345706054232, 0.3392883221493983, 0.3330243212371766, 0.3245897422063072, 0.35602688839653474, 0.30202228148726995, 0.3799527777319639, 0.38610041780806437, 0.3513021522464552, 0.20113996005856916, 0.20491749445257001, 0.22018446861294527, 0.21042230267820305, 0.19989723668380233, 0.2317206945868313, 0.18922475520332505, 0.20147928114196556, 0.18993944357060588, 0.36388873255349674, 0.2013000416792624, 0.4783365364064943, 0.20954734312329015, 0.1987768127877051, 0.34382423705739074, 0.4919314170460646, 0.31002672518441, 0.19631062843221758, 0.8705675997858453, 0.18452481031663082, 0.7077672015954162, 0.8189586508973009, 0.18553981701618827, 0.16967776567940496, 0.6731527784985969, 0.1667320782923143, 0.8086066856679313, 0.7332015741045401, 0.1680192860306291, 0.7445164637125832, 0.7312182222891984, 0.20822580485722697, 0.7273624020723675, 0.2122269248961991, 0.791179548581149, 0.2088611234421579, 0.1985998720662927, 0.20097154351821211, 0.18523297326885035, 0.1949387092067465, 0.20586768759464258, 0.18473030819150404, 0.19856093421749021, 0.24544142459069074, 0.1946427879710756, 0.08670284161029596, 0.07552162191038692, 0.0904234747093644, 0.08070615406894355, 0.08482015625548156, 0.0809835475786882, 0.08881889909270846, 0.0789900087782246, 0.09280417817415765]}, "mutation_prompt": null}
{"id": "aa14cfc5-2e9c-4a40-82af-c9c487123913", "solution": "import numpy as np\n\nclass DynamicAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(60, self.budget // 6)  # Slightly reduced population size for speed\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.6  # Increased for more aggressive search\n        self.CR_base = 0.85  # Slightly decreased to allow more variation\n        self.adaptation_rate = 0.1  # Higher rate for quicker adaptation\n        self.local_search_intensity = 0.3  # Intensified local search\n        self.mutation_prob = 0.8  # Increased probability for more frequent rand-based mutation\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        # Track the best solution found\n        best_index = np.argmin(fitness)\n        best_individual = population[best_index]\n        best_fitness = fitness[best_index]\n        \n        # Adaptive thresholds\n        F_min, F_max = 0.4, 0.9\n        CR_min, CR_max = 0.6, 1.0\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Self-adaptive F and CR\n                F = np.clip(self.F_base + self.adaptation_rate * np.random.randn(), F_min, F_max)\n                CR = np.clip(self.CR_base + self.adaptation_rate * np.random.randn(), CR_min, CR_max)\n\n                # Choose mutation strategy based on a probability\n                if np.random.rand() < self.mutation_prob:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = population[indices]\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(self.population_size, 2, replace=False)\n                    a, b = population[indices]\n                    mutant = np.clip(best_individual + F * (a - b), self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n\n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection and elitism\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Enhanced cooperative local search around the best individual\n            neighborhood_size = int(self.local_search_intensity * self.population_size)\n            local_neighbors = best_individual + np.random.normal(0, 0.02, (neighborhood_size, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n\n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_local_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_local_index]\n                best_fitness = local_fitness[best_local_index]\n\n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        return best_individual", "name": "DynamicAdaptiveDifferentialEvolution", "description": "A dynamic adaptive differential evolution algorithm with progressive parameter tuning and intensified local search to expedite convergence.", "configspace": "", "generation": 62, "fitness": 0.3500130374378586, "feedback": "The algorithm DynamicAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.24.", "error": "", "parent_id": "ec99e2dc-36dd-4b70-9fb0-6285f697cac9", "metadata": {"aucs": [0.7615243821248805, 0.7918016217178241, 0.7606660757214505, 0.7919626202805111, 0.7795468056227669, 0.7634707407532231, 0.7865889434598797, 0.7658210390903968, 0.7799108382008398, 0.5607977206473221, 0.5659515720391399, 0.5801001979613201, 0.5829081823281812, 0.5762590124433105, 0.5812615268835162, 0.5527019912307225, 0.595100890533904, 0.5824839544074778, 0.14806690251971888, 0.13521410863404437, 0.17992039949602645, 0.1840025334493257, 0.11577042890738753, 0.1542055154294627, 0.17971247903684395, 0.12831142017658148, 0.15581204040404573, 0.11338325555991013, 0.11982649912792243, 0.1307838681223471, 0.13418563755498558, 0.10146891008261405, 0.13283973970701757, 0.1286294548074105, 0.10103838246113106, 0.12726649952621816, 0.9653651286995727, 0.9680358468721811, 0.9582827912437566, 0.9631079988298424, 0.9668661738302627, 0.9643542701271319, 0.970885438353881, 0.9639302965468777, 0.9583334990161251, 0.36433326492549156, 0.39144678887589013, 0.3706351386995861, 0.36967761653033815, 0.3756877232414869, 0.4023759228052134, 0.3956295369869923, 0.38023110127975857, 0.4035031462518516, 0.7238634346895066, 0.7017375762455391, 0.6517716167799115, 0.8106218505429644, 0.7373004949942132, 0.7894776580416335, 0.735707126952005, 0.7846784526880299, 0.7821140578307455, 0.37871026812723807, 0.3771613796041796, 0.3597114747619704, 0.1239059617990741, 0.3567417139217134, 0.1292371557340246, 0.3534749084684137, 0.29494272058577087, 0.3063915329099992, 0.22360327690328696, 0.2692560464619901, 0.22039754612176032, 0.3148001345584489, 0.3182346057231049, 0.3391806374988592, 0.3347533465114627, 0.3687959649715359, 0.159148558030467, 0.2910101319377555, 0.2462987929894761, 0.28356319759298165, 0.2159164016121422, 0.25516280042602546, 0.25828339512366416, 0.23982006201332595, 0.24072018154752495, 0.2216637623475779, 0.34268844192112036, 0.36817062417410884, 0.3344529904015924, 0.40182978909464295, 0.34995213302506323, 0.3572688803823397, 0.4509332664869973, 0.410019095923308, 0.3896619368555764, 0.04457234613549832, 0.07501769341520681, 0.09733249510852782, 0.1655001716618404, 0.18364380115160917, 0.10464134247849743, 0.12397775380371256, 0.18094645958051292, 0.07772443175485277, 0.23976984729488238, 0.23417844747406258, 0.22515143228738066, 0.25094633174585923, 0.2666235887866889, 0.26830104910930863, 0.2385121852417682, 0.24312519119081377, 0.22365941919802512, 0.6270036525729156, 0.627090996632105, 0.6566232922437092, 0.6068805957190628, 0.611171556793576, 0.5883554360464301, 0.6307034226580213, 0.6108135275849031, 0.634547235420059, 0.10699121648714205, 0.12736760198023478, 0.10608515301780286, 0.14860008306319028, 0.10179858220510396, 0.1266033399520191, 0.12876608464525252, 0.1331139380631452, 0.0769927586959549, 0.16873486698452544, 0.17849856838893097, 0.1802745812057034, 0.2696133517929268, 0.15170933884764504, 0.17778090077794662, 0.1814848939360698, 0.1748921700292434, 0.17055485679877125, 0.37177514177802495, 0.38896333713821407, 0.3987758701542208, 0.3584957596513685, 0.38600462487906717, 0.37860051520544125, 0.3574381043606134, 0.40799427041501357, 0.3931325785079878, 0.28224206703583776, 0.3317942762714341, 0.2694018143130744, 0.2456247585390161, 0.29528542416487225, 0.259922978741571, 0.2837552859223412, 0.2932767698523535, 0.3155055807581677, 0.22689675678980736, 0.24981649455613308, 0.20261247230633195, 0.2589020505148808, 0.2018471482833245, 0.21531058307711215, 0.20400616051113707, 0.2116750691462026, 0.19602936418249028, 0.2061086608773447, 0.1948152827378934, 0.2599881393566562, 0.20043426737024606, 0.20382110832593814, 0.22647548722811894, 0.2536995196879649, 0.2172524221750618, 0.26208883005112615, 0.7438534318439578, 0.20839308131921186, 0.1824772159209036, 0.647985136318022, 0.1752346440209812, 0.7011113072244155, 0.16156738616635646, 0.19378924212128656, 0.1830752059600549, 0.7723540776600263, 0.20489431939821312, 0.20111595195352416, 0.6528265444171121, 0.6995687112820405, 0.674485172944518, 0.20522283298831712, 0.20651083099842116, 0.20435252606529486, 0.2351682019487863, 0.2097635669379948, 0.2102681065192623, 0.2136567338819525, 0.20060546820991854, 0.2084165834216869, 0.1957256775204933, 0.198660710090115, 0.21205577144404575, 0.0841820305021469, 0.0849770065425155, 0.08649760445723331, 0.09288186646093999, 0.0857060626351891, 0.08823003023747134, 0.08462498486609071, 0.08932756413392451, 0.08169227445823857]}, "mutation_prompt": null}
{"id": "da12ee4d-ecd2-4533-8cc6-7277c417cc03", "solution": "import numpy as np\n\nclass MultiTieredCooperativeDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_size = 20\n        self.population_growth_rate = 1.2\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.8\n        self.CR_base = 0.9\n        self.adaptation_rate = 0.05\n        self.local_search_intensity = 0.2\n        self.mutation_prob = 0.5\n\n    def __call__(self, func):\n        eval_count = 0\n        population_size = self.base_population_size\n        best_fitness = np.inf\n        best_individual = None\n\n        while eval_count < self.budget:\n            # Dynamic population scaling\n            population_size = int(min(self.budget - eval_count, population_size * self.population_growth_rate))\n            population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n            fitness = np.array([func(ind) for ind in population])\n            eval_count += population_size\n\n            # Update the best solution\n            current_best_index = np.argmin(fitness)\n            current_best_fitness = fitness[current_best_index]\n            if current_best_fitness < best_fitness:\n                best_fitness = current_best_fitness\n                best_individual = population[current_best_index]\n\n            # Differential Evolution with adaptive parameters\n            for i in range(population_size):\n                F = np.clip(self.F_base + self.adaptation_rate * np.random.randn(), 0, 1)\n                CR = np.clip(self.CR_base + self.adaptation_rate * np.random.randn(), 0, 1)\n\n                if np.random.rand() < self.mutation_prob:\n                    indices = np.random.choice(population_size, 3, replace=False)\n                    a, b, c = population[indices]\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(population_size, 2, replace=False)\n                    a, b = population[indices]\n                    mutant = np.clip(best_individual + F * (a - b), self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_individual = trial\n\n                if eval_count >= self.budget:\n                    break\n\n            # Enhanced local search around the current best\n            neighborhood_size = int(self.local_search_intensity * population_size)\n            local_neighbors = best_individual + np.random.normal(0, 0.02, (neighborhood_size, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n\n            if np.min(local_fitness) < best_fitness:\n                best_local_index = np.argmin(local_fitness)\n                best_fitness = local_fitness[best_local_index]\n                best_individual = local_neighbors[best_local_index]\n\n        return best_individual", "name": "MultiTieredCooperativeDifferentialEvolution", "description": "Multi-tiered Cooperative Differential Evolution with Dynamic Population and Adaptive Mutation Strategies for Accelerated Convergence.", "configspace": "", "generation": 63, "fitness": 0.1490795919248358, "feedback": "The algorithm MultiTieredCooperativeDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.19.", "error": "", "parent_id": "ec99e2dc-36dd-4b70-9fb0-6285f697cac9", "metadata": {"aucs": [0.16012045262422125, 0.2078323155738574, 0.21788617242574382, 0.2030099743854823, 0.2664789132676656, 0.21033377258312114, 0.18904572314533852, 0.231736099437166, 0.1783695798955881, 0.0033245575306276587, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04890311645990264, 0.08154808364216826, 0.06083899173748086, 0.05897045322620065, 0.1023882418505162, 0.05922007206829216, 0.05806553923526958, 0.05372226965671767, 0.06671840448513999, 0.07170367837194613, 0.07614011144096222, 0.0733487160916626, 0.05849434268421483, 0.055951498367221575, 0.03894866392059049, 0.04860426349356162, 0.07511424692465063, 0.07390324042339758, 0.9852239335644406, 0.9919461519555535, 0.9854659452296123, 0.9618241559281736, 0.9862573520924894, 0.985978487056355, 0.9866952973982932, 0.990389454808403, 0.9773960587702735, 0.10964522415046107, 0.08443525051334888, 0.0844078812289587, 0.08230154364726827, 0.0876266440146739, 0.08716285236221533, 0.09731535102289568, 0.1284623285034291, 0.0852709262171063, 0.12651403436216913, 0.1395074611580499, 0.1288395695144251, 0.1656965671128695, 0.14719586313511845, 0.12525642544829918, 0.14910687118731036, 0.14765403908714436, 0.14310081435336874, 0.009325974170030005, 0.010442812103140908, 0.002416649617063338, 0.03819435153054762, 0.016775194680012984, 0.032446952781829186, 0.026883456672292416, 0.004474652150164959, 0.1384036438166797, 0.0819115765900833, 0.05999567783231374, 0.04404975508010989, 0.023451219035671378, 0.06263661024786094, 0.05976844851304142, 0.03566567371677376, 0.0057240021741638, 0.03552528377210351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04891366333560654, 0.06655987080652936, 0.05175531950058543, 0.07812712941259548, 0.05011031633056462, 0.13233387376865868, 0.15392546278758978, 0.05419245715326382, 0.05647792410046004, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01670479395687019, 0.01582730809606414, 0.028570271661169655, 0.019190639106575147, 9.999999999998899e-05, 0.00907280278383693, 0.02283637335880284, 0.014107155128844528, 0.04716390670715043, 0.2028796113992999, 0.1824650590646376, 0.2343328438715263, 0.1810798558348775, 0.19036001879923692, 0.2449371275638691, 0.20015565415708525, 0.23324594018964284, 0.27473762816759617, 0.061713509620088036, 0.07601443983788558, 0.0866218818524962, 0.06697977775298314, 0.05302164341973581, 0.05255341311343287, 0.13209848482165687, 0.05227896365150608, 0.10770547892039772, 0.1734066248502082, 0.14631858045406865, 0.18234673497564613, 0.19751092074732335, 0.18418072004400943, 0.215580251542004, 0.23952413527397198, 0.18117242774345654, 0.2566228889564479, 0.1762008272145369, 0.1864100984028647, 0.19528130984335967, 0.16035267866696923, 0.21691427507838135, 0.17469107128384642, 0.18898326573943003, 0.184819799499228, 0.16356560379301954, 0.13097907157036293, 0.10117187659318838, 0.14569463448533682, 0.12565520596433055, 0.1517007339171612, 0.10560615047955724, 0.14411627636160118, 0.1423988450402589, 0.12498979363549201, 0.18054661720627407, 0.176958201981136, 0.16499151720848781, 0.16847065832127595, 0.1562903613291433, 0.16297447693179024, 0.17527017509336906, 0.18519745589370795, 0.18171874811659194, 0.17731384853790588, 0.1514639899587943, 0.18194238398793638, 0.16459092022107635, 0.15647929741576294, 0.15570154691401727, 0.1679411289424796, 0.17534521049082108, 0.20658027563986525, 0.17225013242291864, 0.2847302069647685, 0.17139138405439192, 0.17603058589181897, 0.18831052751185517, 0.1896990418266823, 0.23430261167010646, 0.21444060539175835, 0.27888436131834504, 0.32076446918267587, 0.12802040173709917, 0.19545619443861795, 0.16939262609776595, 0.2399947989048895, 0.23901092699154403, 0.15515800246294853, 0.28228631637215396, 0.2615688160776829, 0.19940328336035829, 0.19539523218593002, 0.19181666654833351, 0.18968643598501678, 0.20200611333941665, 0.20924276478232728, 0.20740466095767174, 0.18742762582645156, 0.1972437884059095, 0.0598796286291301, 0.12370202279045173, 0.06095807573389955, 0.06576686625484707, 0.07495783621319896, 0.08753093666534884, 0.06297796953498214, 0.0535522723018359, 0.05333553729648921]}, "mutation_prompt": null}
{"id": "b22948cb-6022-4e81-9c1e-5ffab0023b08", "solution": "import numpy as np\n\nclass SynergisticHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(80, self.budget // 6)  # Larger population for greater diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.7  # Enhanced exploration with increased differential weight\n        self.CR_base = 0.85  # Balanced crossover rate for diversity and exploitation\n        self.adaptation_rate = 0.1  # More aggressive adaptation rate\n        self.local_search_intensity = 0.2  # Intensified local search for rapid convergence\n        self.mutation_prob = 0.75  # Adjusted mutation probability\n        self.elitism_rate = 0.1  # Elitism to retain top performers\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        # Track the best solution found\n        best_index = np.argmin(fitness)\n        best_individual = population[best_index]\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            next_generation = []\n\n            for i in range(self.population_size):\n                # Self-adaptive F and CR\n                F = np.clip(self.F_base + self.adaptation_rate * np.random.randn(), 0, 1.5)\n                CR = np.clip(self.CR_base + self.adaptation_rate * np.random.randn(), 0, 1)\n\n                # Choose mutation strategy based on a probability\n                if np.random.rand() < self.mutation_prob:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = population[indices]\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(self.population_size, 2, replace=False)\n                    a, b = population[indices]\n                    mutant = np.clip(best_individual + F * (a - b), self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n\n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection and elitism\n                if trial_fitness < fitness[i]:\n                    next_generation.append((trial, trial_fitness))\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                else:\n                    next_generation.append((population[i], fitness[i]))\n\n                if eval_count >= self.budget:\n                    break\n\n            # Sort new generation based on fitness and apply elitism\n            next_generation.sort(key=lambda x: x[1])\n            population = np.array([ind for ind, _ in next_generation[:self.population_size]])\n            fitness = np.array([fit for _, fit in next_generation[:self.population_size]])\n\n            # Enhanced cooperative local search around the best individual\n            neighborhood_size = int(self.local_search_intensity * self.population_size)\n            local_neighbors = best_individual + np.random.normal(0, 0.05, (neighborhood_size, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n\n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_local_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_local_index]\n                best_fitness = local_fitness[best_local_index]\n\n            # Inject best individual back into population\n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        return best_individual", "name": "SynergisticHybridAdaptiveDifferentialEvolution", "description": "A synergistic hybrid adaptive differential evolution combining novel mutation strategies and intelligent diversity management for enhanced convergence.", "configspace": "", "generation": 64, "fitness": 0.2712495592916621, "feedback": "The algorithm SynergisticHybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "ec99e2dc-36dd-4b70-9fb0-6285f697cac9", "metadata": {"aucs": [0.5992209611749719, 0.5958493270304774, 0.5875869483328623, 0.624897696361058, 0.6091107352543067, 0.623954257928292, 0.6075592846078277, 0.6209562127695906, 0.6288834759445132, 0.26866773330898264, 0.3040460659786308, 0.2588113627250914, 0.25445005954939126, 0.26154012809738914, 0.2956837379979296, 0.29983940895830397, 0.2783286352663056, 0.2878596718160137, 0.11631432992456248, 0.11440070558366866, 0.11544258479428027, 0.09651248655717104, 0.10106146427480511, 0.10961737685202588, 0.11118986432365163, 0.12239520903919743, 0.12066260553263564, 0.11282060111353875, 0.08676944961538069, 0.11003364478990241, 0.10302075930871413, 0.14256182038167042, 0.12514776209003853, 0.11837505675830162, 0.09735140948838539, 0.11205705357111617, 0.9643992083227262, 0.9773636985855256, 0.9659412190478865, 0.974360203453705, 0.9759286015860423, 0.9713459472384931, 0.9784586596737785, 0.9738821696308031, 0.9833902873277861, 0.29448598879069654, 0.29624944724615454, 0.3102905180321017, 0.29505043165759504, 0.3273726976838488, 0.2810624965740077, 0.2794685966399868, 0.28099084573801536, 0.3152780013252716, 0.5035365846890696, 0.5254607385102448, 0.4396098410027506, 0.6613952272639727, 0.6165833948143435, 0.51980075324946, 0.6585563497994922, 0.5849604677946696, 0.4206901941545296, 0.17806060977161464, 0.27635155494930974, 0.19715155580365062, 0.18380835964871145, 0.17465104166819878, 0.2146887155950128, 0.19610672744470448, 0.15450837880435342, 0.23369503826710092, 0.18846886698889032, 0.16200993676859576, 0.16635319477021238, 0.19991876039534606, 0.18894230172178494, 0.18049170638101664, 0.21640992225050582, 0.16649136536743736, 0.2172988152479296, 0.08334136412076765, 0.06988285726609156, 0.08435212520148849, 0.11839686061805821, 0.09920545458250285, 0.07875570457886338, 0.08578006259735904, 0.08102508450977075, 0.08330419975937564, 0.2519875784333798, 0.22272528728244, 0.2199550032905878, 0.17910191794970054, 0.22221042552681858, 0.23202890951596655, 0.20529605831454278, 0.2548458931335629, 0.2294693077824227, 0.0324382239681994, 0.02481023477478428, 0.018788490465753815, 0.03263228088271097, 0.037347551921122824, 0.05462868359990136, 0.03143714951470433, 0.028027550523625933, 0.02221368369334309, 0.14320221941284217, 0.14980290280330466, 0.1542384469392919, 0.17238356577768643, 0.14803361837379347, 0.1629336461950035, 0.1370391626685381, 0.13382419128810985, 0.14783804072180773, 0.45278821331345176, 0.4906729856123401, 0.46336918093832113, 0.4832436095238313, 0.48049272600342685, 0.45498663322410704, 0.47100308111340317, 0.4649092622967198, 0.4867960284258518, 0.12768161591320348, 0.1259660808452724, 0.11156536993357968, 0.08662852861365988, 0.1100676209235627, 0.08709155430388527, 0.11275483415552157, 0.1298215094856079, 0.1002328178257631, 0.1496635418092972, 0.16680619497279736, 0.15660332730802662, 0.18073881967681826, 0.23718430706434468, 0.1732283975501403, 0.21870418240114398, 0.24729406618085026, 0.1908382010799874, 0.30199862538847744, 0.29938557794605836, 0.30325793553722447, 0.28811930652571904, 0.28199691778741065, 0.281851715655542, 0.320644738920835, 0.32691391430692907, 0.33123295244492723, 0.22114106112809273, 0.22155471222367584, 0.2377379037154227, 0.2314309249531863, 0.18931939033499834, 0.20920259059363921, 0.22149592098633353, 0.23752459321769925, 0.20929789626241224, 0.19252405029884434, 0.1844275171315779, 0.19721881570931632, 0.19507281339180882, 0.22963656261486154, 0.19464841778816777, 0.205828325784846, 0.18246337766595788, 0.18360374391154155, 0.17998092789946474, 0.18355988327044592, 0.1914362890113953, 0.22433503476309158, 0.18742793115562129, 0.20407889547434555, 0.1767361424427749, 0.18436945910359637, 0.23561170417979893, 0.18953818769677022, 0.673643807124803, 0.6628214718948846, 0.7254787514194416, 0.19627500832373923, 0.191657344636459, 0.6088615052113956, 0.19239599287146136, 0.18269947968828193, 0.48189052180903, 0.2031095413674996, 0.1670326493696893, 0.20493701246010465, 0.5193508360185142, 0.18987970521985964, 0.19629307693508313, 0.5911082584354992, 0.46447516086631047, 0.18164086851857142, 0.18629070191458363, 0.18801335456006507, 0.1889062888952575, 0.186215811007167, 0.18707423837520387, 0.18965776976668092, 0.18526851027519742, 0.19552330239623472, 0.08665820444784444, 0.08094180108955173, 0.08177533781041657, 0.07879609016472788, 0.07459204836169919, 0.07828116989437406, 0.09203315350073704, 0.08038417982855395, 0.07062135805582781]}, "mutation_prompt": null}
{"id": "38a8f887-c19f-4122-b1fd-bffc00657798", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(60, self.budget // 8)  # Increased population size for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.5  # Adjusted for better exploration\n        self.CR_base = 0.9  # Increased to promote diversity\n        self.adaptation_rate = 0.05  # Increased adaptation rate for faster parameter adjustment\n        self.local_search_intensity = 0.15  # Increased local search intensity\n        self.mutation_prob = 0.7  # Probability of best or rand mutation\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        # Track the best solution found\n        best_index = np.argmin(fitness)\n        best_individual = population[best_index]\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Self-adaptive F and CR\n                F = np.clip(self.F_base + self.adaptation_rate * np.random.randn(), 0, 1)\n                CR = np.clip(self.CR_base + self.adaptation_rate * np.random.randn(), 0, 1)\n\n                # Choose mutation strategy based on a probability\n                if np.random.rand() < self.mutation_prob:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = population[indices]\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(self.population_size, 2, replace=False)\n                    a, b = population[indices]\n                    mutant = np.clip(best_individual + F * (a - b), self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n\n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection and elitism\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Enhanced cooperative local search around the best individual\n            neighborhood_size = int(self.local_search_intensity * self.population_size)\n            local_neighbors = best_individual + np.random.normal(0, 0.05, (neighborhood_size, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n\n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_local_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_local_index]\n                best_fitness = local_fitness[best_local_index]\n\n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        return best_individual", "name": "EnhancedHybridAdaptiveDifferentialEvolution", "description": "An enhanced hybrid adaptive differential evolution with increased local search adaptation and self-adaptive parameter tuning for rapid convergence.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ec99e2dc-36dd-4b70-9fb0-6285f697cac9", "metadata": {"aucs": [0.870997610873655, 0.876937349254849, 0.8628821214606534, 0.8781794510016624, 0.8772296468912268, 0.8694279318528029, 0.8756843654306008, 0.8726768563847991, 0.8598523983391932, 0.7477842665418626, 0.7505830115174412, 0.7273487673266275, 0.7189706160361924, 0.7360234772212559, 0.7429061262623435, 0.7438642610252675, 0.7560429492372163, 0.7467399915536672, 0.16512467121215724, 0.21203315310966409, 0.36256095224927487, 0.16722241556246864, 0.13854119174963164, 0.3333937421616463, 0.13516368482132823, 0.14772951992740369, 0.15692171902064456, 0.1564408366174984, 0.1353579238051421, 0.14422112246044583, 0.11484204674412235, 0.11348023152341102, 0.11138379259342324, 0.14321803866866378, 0.14280534633632092, 0.15859257836490215, 0.9799585186455763, 0.9503327389088712, 0.9724501584066897, 0.9571617360165604, 0.9859598542069689, 0.9718842750065484, 0.9760859368284891, 0.9848955505579943, 0.973482908644332, 0.6071385211387058, 0.6173177688242826, 0.6131191937365257, 0.6198810082831014, 0.6308754058002048, 0.6151046424041569, 0.5929618643435774, 0.6259420273296028, 0.6123827674671722, 0.8398909658399296, 0.8539463927768597, 0.8286288287924357, 0.8479342703448974, 0.88641759183554, 0.8924952684036396, 0.8466961223205589, 0.8895895616883716, 0.8513347130888925, 0.6474349245531625, 0.13233776457818802, 0.6015251038894203, 0.12842010025943162, 0.6650660782032273, 0.729896318050316, 0.5838451394599409, 0.6038932677285569, 0.7486964038653956, 0.6027977688129897, 0.12904105617894945, 0.4970570551982538, 0.6338783710380922, 0.1311763787354625, 0.654584992183878, 0.13347577211066708, 0.5834411824896677, 0.6644167530846077, 0.5801341813173042, 0.6517131199065661, 0.5747597642597722, 0.5450781855850122, 0.6264774567937635, 0.5973118877387971, 0.5922806442473407, 0.6058774307227208, 0.5307442727477565, 0.7246104456113118, 0.7196658854680926, 0.6937459743116989, 0.6929901166276469, 0.6764640766292062, 0.6877991243894017, 0.7095399141637933, 0.7431058503302441, 0.7141560428367603, 0.5111644149668872, 0.12354566074955964, 0.13808117097245265, 0.16417221084055578, 0.5071824081123578, 0.2800834292901856, 0.15227794024262242, 0.2060402404781626, 0.43032493661029814, 0.49899493882997625, 0.5191627329886238, 0.4963062823251455, 0.519113603089481, 0.5317078511278232, 0.5517407313988787, 0.4828361527779109, 0.5174869321995552, 0.5274905608509252, 0.8230889833159312, 0.8274699863485728, 0.802146867581838, 0.7996643983062854, 0.8111585569300906, 0.8076406107590844, 0.8097513012737546, 0.813623972927586, 0.8012792400647224, 0.1543570750637966, 0.11202371696330105, 0.16342062676402602, 0.11988433445212554, 0.14401205285359286, 0.1247286910495965, 0.15758369478141976, 0.13863798943727346, 0.12049367302351399, 0.30905398943833184, 0.222262321964814, 0.21822555431598334, 0.1939458291385081, 0.4463802150027981, 0.2623165071326464, 0.388702947695691, 0.39316509265836086, 0.5641051301559905, 0.5559964566010401, 0.5794900739564952, 0.5592162804406543, 0.5334386158196133, 0.5634881082285331, 0.5764055782840386, 0.6324910585494613, 0.6113997600794387, 0.5576296411418729, 0.45822871852814717, 0.4632290950314738, 0.479100132440759, 0.46157879635820986, 0.43372108776671126, 0.4521519413829479, 0.4772208737947904, 0.47949489037925097, 0.4336084838960391, 0.21664866446744402, 0.21020796781048734, 0.20391775129587275, 0.2102933753324162, 0.21488300958379658, 0.22832035167615627, 0.19642172451381434, 0.19848521525915352, 0.24607068311088864, 0.22638461450377823, 0.21955924768255364, 0.22099698523152322, 0.2464495276526275, 0.2015667282287935, 0.20552757969012359, 0.20783549005238355, 0.21796835920185642, 0.21117204849685445, 0.17313527134759987, 0.8910706378954903, 0.15211568904684047, 0.8901467250816121, 0.19936136052459064, 0.1733889867309919, 0.14219936505632336, 0.15934671658200672, 0.21046538462018194, 0.8813767329362526, 0.8404360913909095, 0.8400914666175698, 0.2116666932825344, 0.16800672632850167, 0.8253102176423769, 0.16810764576068138, 0.21002542641758581, 0.8761756538100725, 0.21770435341516903, 0.19684888208430695, 0.20589586690149797, 0.18355856139871507, 0.20310480967848143, 0.18729717612734564, 0.18811472821621278, 0.1933542490469048, 0.1996172762222207, 0.08091856304424327, 0.08559185525502855, 0.09926782238828946, 0.07769180530251996, 0.08145907572888011, 0.09784577550374873, 0.08813891779584104, 0.09794845121770268, 0.09199369335995033]}, "mutation_prompt": null}
{"id": "4112bc38-11fb-4f11-85e5-9514eab2d364", "solution": "import numpy as np\n\nclass ChaoticAdaptiveSwarmDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(60, self.budget // 8) \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.8  # Increased to accelerate exploration\n        self.CR_base = 0.8  # Adjusted for convergence balance\n        self.adaptation_rate = 0.1  # Further increased for rapid adaptation\n        self.local_search_intensity = 0.1  # Adjusted for strategic local search\n        self.mutation_prob = 0.6  # Slightly reduced to balance exploration\n        self.chaos_coefficient = 0.3  # Introduced for chaotic local search\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        # Track the best solution found\n        best_index = np.argmin(fitness)\n        best_individual = population[best_index]\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Self-adaptive F and CR\n                F = np.clip(self.F_base + self.adaptation_rate * np.random.randn(), 0.4, 1)\n                CR = np.clip(self.CR_base + self.adaptation_rate * np.random.randn(), 0.1, 1)\n\n                # Choose mutation strategy based on a probability\n                if np.random.rand() < self.mutation_prob:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = population[indices]\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(self.population_size, 2, replace=False)\n                    a, b = population[indices]\n                    mutant = np.clip(best_individual + F * (a - b), self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n\n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection and elitism\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Chaotic local search around the best individual\n            neighborhood_size = int(self.local_search_intensity * self.population_size)\n            x = best_individual + np.random.normal(0, self.chaos_coefficient, (neighborhood_size, self.dim))\n            x = np.clip(x, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in x])\n            eval_count += len(x)\n\n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_local_index = np.argmin(local_fitness)\n                best_individual = x[best_local_index]\n                best_fitness = local_fitness[best_local_index]\n\n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        return best_individual", "name": "ChaoticAdaptiveSwarmDE", "description": "A dynamically adaptive swarm intelligence algorithm combining differential evolution with strategic chaotic local search for enhanced convergence speed and solution accuracy.", "configspace": "", "generation": 66, "fitness": 0.298547064754336, "feedback": "The algorithm ChaoticAdaptiveSwarmDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.23.", "error": "", "parent_id": "ec99e2dc-36dd-4b70-9fb0-6285f697cac9", "metadata": {"aucs": [0.6944285926446765, 0.7059661365207095, 0.6898247346748427, 0.7164830540479975, 0.7169126619154882, 0.7271727339225309, 0.7138555653706081, 0.7451680474824324, 0.7246549996382514, 0.466936362453515, 0.46558207362047954, 0.47678002280620946, 0.43891492688212863, 0.5055113352895401, 0.48410398098878327, 0.5054851452832082, 0.4551694489125553, 0.46176270672398634, 0.11702680498825535, 0.17550153350762976, 0.11632218528669513, 0.12781877049478807, 0.11582436642521188, 0.1166773588842569, 0.11822812251276082, 0.12490000345489538, 0.1266733246193209, 0.10611870381846222, 0.11829724114789808, 0.10777866279091963, 0.1285705288287452, 0.12057776632782624, 0.11637465208817599, 0.12389665913666936, 0.11230543349299438, 0.10088112414938755, 0.9833886105316434, 0.9694777006939402, 0.9698969658487068, 0.9802922746700173, 0.9691314767533433, 0.9832539850123746, 0.9863185996923299, 0.9879027920884363, 0.9738396177277387, 0.282360713883019, 0.2922882775915455, 0.3053192091853686, 0.2988182830868412, 0.2592344548649428, 0.30443695787866476, 0.2978137550964711, 0.28957638203369185, 0.29157086680322686, 0.6246673472831521, 0.573329535670704, 0.47525517752512825, 0.580291826163011, 0.547101777613373, 0.6377841258774246, 0.5974097588248575, 0.5647813048579744, 0.5799157961637462, 0.2555519412444184, 0.2437808682511432, 0.23354464351793114, 0.19112995884528272, 0.2208246027173706, 0.22590672149519075, 0.2056347045815995, 0.24969005278975975, 0.23970538351424053, 0.26304060287156605, 0.23470491184840525, 0.21181527430045366, 0.2709540390428016, 0.3027345559998905, 0.23488794439836735, 0.25944345172660466, 0.25818323348811056, 0.21483454780466893, 0.11313370209099971, 0.13249129455927, 0.10173072884693779, 0.14243129306889946, 0.11844765873636731, 0.07193488014442517, 0.10082385597405696, 0.090992135877078, 0.07025169152734467, 0.20967785763051705, 0.2219209118565233, 0.2111271332235608, 0.21758288662782665, 0.20312312370363073, 0.2279904121882329, 0.2355981450442266, 0.27906247289366115, 0.3020040810177995, 0.03490682512972654, 0.03551299686722176, 0.027133481321943376, 0.036535568550909225, 0.04446379201987327, 0.027104430149079373, 0.039255602989925364, 0.04915061432561196, 0.0715740108918006, 0.1578944800863442, 0.1676979585486954, 0.14692617456448354, 0.16735826542447396, 0.16278520899225113, 0.17589393743429993, 0.17890727292262254, 0.17079041874222, 0.1564463458356724, 0.5120788030897707, 0.4950084908375867, 0.5292844830715145, 0.5164368264518664, 0.516277181002637, 0.5265701426944858, 0.5211676676358128, 0.4951021679265549, 0.4958555186101685, 0.09585546201081763, 0.09013084367176893, 0.09821467789328397, 0.09055160933314255, 0.10224861073347657, 0.09458753492233862, 0.09078209952447158, 0.09481417354993826, 0.09554833262566209, 0.16335463126365646, 0.17926741358411802, 0.15896409775092724, 0.19989880667978555, 0.2053767469812513, 0.20371472618791786, 0.18762019959105214, 0.1739562143577541, 0.19856785508063535, 0.32203187926429877, 0.29534948269250516, 0.31506460444536455, 0.29151793256389535, 0.2968425382599126, 0.29304177304803947, 0.3460311399262611, 0.329747462740245, 0.3108930482774128, 0.22732702895871637, 0.23658905334135805, 0.24173906066208573, 0.22600220825989115, 0.25732651310700316, 0.21621732153905104, 0.269560801900413, 0.2450354438295631, 0.24628814132803256, 0.18812279136108778, 0.18810746676761436, 0.1895182288492251, 0.22985758376444365, 0.2063948819899436, 0.20843143572009637, 0.19640686837240595, 0.19219681667976185, 0.17579170895152563, 0.20564603700988815, 0.20446906187141922, 0.2103606884048551, 0.17883171343096493, 0.20157800569210216, 0.20125622417657707, 0.19713849957498253, 0.2051661962218374, 0.20820115212095192, 0.6919372863407713, 0.1747708279163649, 0.770137422356063, 0.6777782935792616, 0.19911234280738477, 0.7400536250976804, 0.6864389650387868, 0.16901597681032976, 0.6856320909761355, 0.5372016020084605, 0.20686509001823594, 0.5822853009592994, 0.20395857665246808, 0.1798260523984916, 0.1535093453617019, 0.20933719685529217, 0.647994481305212, 0.21047547242301456, 0.18083044494938993, 0.18740368011109654, 0.1862111992315536, 0.18964435823690395, 0.17006390354328105, 0.2082117362719509, 0.1916524219414757, 0.1751263373216616, 0.19445529005017226, 0.07740933201582212, 0.0842715946770346, 0.08013001114628948, 0.07409014411040449, 0.07349885630868902, 0.07544858244248387, 0.07539549158903025, 0.08190261146544475, 0.07780149765197875]}, "mutation_prompt": null}
{"id": "ffe86f06-67b6-44ae-a1b7-26050ec693cf", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(80, self.budget // 6)  # Further increased population size for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.6  # Adjusted for more balanced exploration and exploitation\n        self.CR_base = 0.85  # Experimenting with crossover for better convergence\n        self.adaptation_rate = 0.1  # Increased adaptation rate for more dynamic adjustments\n        self.local_search_intensity = 0.2  # Enhanced local search intensity\n        self.mutation_prob = 0.8  # Slightly increased probability of best or rand mutation\n        self.progressive_search_factor = 0.1  # Factor for progressive neighborhood search\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        # Track the best solution found\n        best_index = np.argmin(fitness)\n        best_individual = population[best_index]\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Dynamic scaling of F and CR based on progress\n                progress = eval_count / self.budget\n                F = np.clip(self.F_base + self.adaptation_rate * np.random.randn() * (1 - progress), 0, 1)\n                CR = np.clip(self.CR_base + self.adaptation_rate * np.random.randn() * (1 - progress), 0, 1)\n\n                # Choose mutation strategy based on a probability\n                if np.random.rand() < self.mutation_prob:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = population[indices]\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(self.population_size, 2, replace=False)\n                    a, b = population[indices]\n                    mutant = np.clip(best_individual + F * (a - b), self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n\n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection and elitism\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Progressive cooperative local search around the best individual\n            neighborhood_size = int(self.local_search_intensity * self.population_size)\n            search_radius = self.progressive_search_factor * (5.0 - 5.0 * progress)  # Reduce search space as we progress\n            local_neighbors = best_individual + np.random.normal(0, search_radius, (neighborhood_size, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n\n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_local_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_local_index]\n                best_fitness = local_fitness[best_local_index]\n\n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        return best_individual", "name": "EnhancedHybridAdaptiveDifferentialEvolution", "description": "An enhanced hybrid adaptive differential evolution with progressive neighborhood search and dynamic parameter scaling for improved convergence speed.", "configspace": "", "generation": 67, "fitness": 0.3051719776887923, "feedback": "The algorithm EnhancedHybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.", "error": "", "parent_id": "ec99e2dc-36dd-4b70-9fb0-6285f697cac9", "metadata": {"aucs": [0.6960435086097687, 0.6927121594185612, 0.7116802082639161, 0.7152281246262921, 0.7091970110707004, 0.7217495638100816, 0.7051639463413575, 0.6883687036760124, 0.7136408837160847, 0.4474050615453232, 0.42863887010824675, 0.44856148427143827, 0.4376362582726211, 0.4382922232448089, 0.45942780945352346, 0.42482571289255855, 0.48206751656304736, 0.4935526932434732, 0.1022020775378818, 0.1053342652079231, 0.11370551246547134, 0.10844333065344292, 0.12125066523040517, 0.1127691336996024, 0.12292967268065791, 0.09734048685111651, 0.09923031399997129, 0.10650534343875484, 0.10896376673467967, 0.10735633895468111, 0.10232443961091797, 0.10579342376086787, 0.10593553976485692, 0.09845954970476545, 0.09621076229331771, 0.09830066963853556, 0.9644160618275476, 0.968248817980085, 0.9766025396076398, 0.9743116402884983, 0.9625143616993408, 0.9662507027908669, 0.9770267499353824, 0.9756334735057741, 0.9781381551415997, 0.3188976161429158, 0.3108137993231044, 0.30566948356134294, 0.3054822747766158, 0.31152575340581157, 0.31860697393280746, 0.33089867506910275, 0.30206225278485344, 0.31110507278176613, 0.609288550094178, 0.6711890408881913, 0.6834822470761415, 0.700510916219329, 0.7167639550752558, 0.7093409518989346, 0.5868030829169347, 0.6352163968598723, 0.6040916945461514, 0.2557997998488508, 0.25204277643573036, 0.2629601696315972, 0.18126803158236515, 0.2572324211216529, 0.26210660297061616, 0.2876462739696696, 0.24063792156508568, 0.2673053085717334, 0.2536230690477381, 0.21685480873800744, 0.23605147719920982, 0.26768353064041117, 0.28011925715195907, 0.2895741642329629, 0.29149417954022216, 0.27456573878299073, 0.2853689517674106, 0.18471274585605224, 0.15043917939757323, 0.18136390918290968, 0.16085471612747138, 0.13845462688512722, 0.13006321400387788, 0.15665764281015293, 0.15016134083448562, 0.16716304038771646, 0.2651348227809164, 0.3006708663362945, 0.2998119580615115, 0.2953425131015155, 0.27842696712478276, 0.2760455821243596, 0.3137086943434432, 0.30170921985603316, 0.32163266389465794, 0.0475491918231955, 0.059436979293488235, 0.07479626273880369, 0.09609881494428918, 0.10245811018485529, 0.10927258888758584, 0.09877415806425616, 0.09976826429329488, 0.05386151314748444, 0.19206843856204814, 0.17140899245502728, 0.17093063327441138, 0.20196139204921526, 0.18682420544144362, 0.18802381528345335, 0.16349776127789228, 0.17556159435159757, 0.16374893590004336, 0.5569625156264429, 0.5307937305866359, 0.5733755328381116, 0.5769157427127736, 0.5339099502869886, 0.5511146183196307, 0.5467111031180552, 0.5392048768537001, 0.556623555161434, 0.10061058818385882, 0.10096405054030533, 0.1039730722112927, 0.10118496501375684, 0.07917960104726551, 0.09653595629128864, 0.08859882306440581, 0.10087563810835587, 0.10255881578348303, 0.20949910745744715, 0.22325016368920658, 0.19958522641265242, 0.18183274781778713, 0.20505772248118115, 0.13089643321002908, 0.16522316194516806, 0.16785840767491333, 0.19299026758248383, 0.32792071838589787, 0.32807705005414534, 0.3383596157680657, 0.31584218689305, 0.331125164015561, 0.3443804198642936, 0.3457249478616127, 0.37325897019841503, 0.32501417028934576, 0.2511213201059249, 0.25892182752628734, 0.25872543713379703, 0.2509129520903579, 0.24757749525830508, 0.2633467501798141, 0.2624074799967141, 0.26212152599118, 0.2718370765356969, 0.19443276846355528, 0.19918605870785444, 0.20559468320456242, 0.1760675443793458, 0.20790653090970068, 0.19871904841761312, 0.18290396042357027, 0.1981707288594191, 0.19502378133135478, 0.1883487183612188, 0.19455980088850922, 0.20598236599349384, 0.18956422817952567, 0.22575776162528483, 0.20811554611649208, 0.19095631298565585, 0.18847153947268902, 0.19024443962094295, 0.17495810033173187, 0.18605987070519237, 0.1934992388266794, 0.7267070823927755, 0.6888615616346374, 0.16717635060404534, 0.6683271042729246, 0.18212923571462925, 0.5792020023245051, 0.5675839689412128, 0.16880474679946622, 0.20578604939268585, 0.7011124727392384, 0.2051831527519301, 0.163204318141966, 0.204078641042033, 0.2090802524181914, 0.20972765053593734, 0.19189188303780125, 0.17065091254223064, 0.1998294038752939, 0.18481148922680568, 0.18582458848233752, 0.1732393861284912, 0.20388651839823857, 0.1888687005675087, 0.18869860321356546, 0.08437903593877327, 0.07321383312129603, 0.07534879646297199, 0.07120383397194041, 0.09119512506620142, 0.08939772052463213, 0.07217120059070348, 0.08761591168432425, 0.07760302890314363]}, "mutation_prompt": null}
{"id": "7ff80e65-9d5d-40ff-82a9-ae15419a6427", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(60, self.budget // 8)  # Increased population size for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.5  # Adjusted for better exploration\n        self.CR_base = 0.9  # Increased to promote diversity\n        self.adaptation_rate = 0.05  # Increased adaptation rate for faster parameter adjustment\n        self.local_search_intensity = 0.15  # Increased local search intensity\n        self.mutation_prob = 0.7  # Probability of best or rand mutation\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        # Track the best solution found\n        best_index = np.argmin(fitness)\n        best_individual = population[best_index]\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Self-adaptive F and CR\n                F = np.clip(self.F_base + self.adaptation_rate * np.random.randn(), 0, 1)\n                CR = np.clip(self.CR_base + self.adaptation_rate * np.random.randn(), 0, 1)\n\n                # Choose mutation strategy based on a probability\n                if np.random.rand() < self.mutation_prob:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = population[indices]\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(self.population_size, 2, replace=False)\n                    a, b = population[indices]\n                    mutant = np.clip(best_individual + F * (a - b), self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n\n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection and elitism\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Enhanced cooperative local search around the best individual\n            neighborhood_size = int(self.local_search_intensity * self.population_size)\n            local_neighbors = best_individual + np.random.normal(0, 0.05, (neighborhood_size, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n\n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_local_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_local_index]\n                best_fitness = local_fitness[best_local_index]\n\n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        return best_individual", "name": "EnhancedHybridAdaptiveDifferentialEvolution", "description": "An enhanced hybrid adaptive differential evolution with increased local search adaptation and self-adaptive parameter tuning for rapid convergence.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ec99e2dc-36dd-4b70-9fb0-6285f697cac9", "metadata": {"aucs": [0.870997610873655, 0.876937349254849, 0.8628821214606534, 0.8781794510016624, 0.8772296468912268, 0.8694279318528029, 0.8756843654306008, 0.8726768563847991, 0.8598523983391932, 0.7477842665418626, 0.7505830115174412, 0.7273487673266275, 0.7189706160361924, 0.7360234772212559, 0.7429061262623435, 0.7438642610252675, 0.7560429492372163, 0.7467399915536672, 0.16512467121215724, 0.21203315310966409, 0.36256095224927487, 0.16722241556246864, 0.13854119174963164, 0.3333937421616463, 0.13516368482132823, 0.14772951992740369, 0.15692171902064456, 0.1564408366174984, 0.1353579238051421, 0.14422112246044583, 0.11484204674412235, 0.11348023152341102, 0.11138379259342324, 0.14321803866866378, 0.14280534633632092, 0.15859257836490215, 0.9799585186455763, 0.9503327389088712, 0.9724501584066897, 0.9571617360165604, 0.9859598542069689, 0.9718842750065484, 0.9760859368284891, 0.9848955505579943, 0.973482908644332, 0.6071385211387058, 0.6173177688242826, 0.6131191937365257, 0.6198810082831014, 0.6308754058002048, 0.6151046424041569, 0.5929618643435774, 0.6259420273296028, 0.6123827674671722, 0.8398909658399296, 0.8539463927768597, 0.8286288287924357, 0.8479342703448974, 0.88641759183554, 0.8924952684036396, 0.8466961223205589, 0.8895895616883716, 0.8513347130888925, 0.6474349245531625, 0.13233776457818802, 0.6015251038894203, 0.12842010025943162, 0.6650660782032273, 0.729896318050316, 0.5838451394599409, 0.6038932677285569, 0.7486964038653956, 0.6027977688129897, 0.12904105617894945, 0.4970570551982538, 0.6338783710380922, 0.1311763787354625, 0.654584992183878, 0.13347577211066708, 0.5834411824896677, 0.6644167530846077, 0.5801341813173042, 0.6517131199065661, 0.5747597642597722, 0.5450781855850122, 0.6264774567937635, 0.5973118877387971, 0.5922806442473407, 0.6058774307227208, 0.5307442727477565, 0.7246104456113118, 0.7196658854680926, 0.6937459743116989, 0.6929901166276469, 0.6764640766292062, 0.6877991243894017, 0.7095399141637933, 0.7431058503302441, 0.7141560428367603, 0.5111644149668872, 0.12354566074955964, 0.13808117097245265, 0.16417221084055578, 0.5071824081123578, 0.2800834292901856, 0.15227794024262242, 0.2060402404781626, 0.43032493661029814, 0.49899493882997625, 0.5191627329886238, 0.4963062823251455, 0.519113603089481, 0.5317078511278232, 0.5517407313988787, 0.4828361527779109, 0.5174869321995552, 0.5274905608509252, 0.8230889833159312, 0.8274699863485728, 0.802146867581838, 0.7996643983062854, 0.8111585569300906, 0.8076406107590844, 0.8097513012737546, 0.813623972927586, 0.8012792400647224, 0.1543570750637966, 0.11202371696330105, 0.16342062676402602, 0.11988433445212554, 0.14401205285359286, 0.1247286910495965, 0.15758369478141976, 0.13863798943727346, 0.12049367302351399, 0.30905398943833184, 0.222262321964814, 0.21822555431598334, 0.1939458291385081, 0.4463802150027981, 0.2623165071326464, 0.388702947695691, 0.39316509265836086, 0.5641051301559905, 0.5559964566010401, 0.5794900739564952, 0.5592162804406543, 0.5334386158196133, 0.5634881082285331, 0.5764055782840386, 0.6324910585494613, 0.6113997600794387, 0.5576296411418729, 0.45822871852814717, 0.4632290950314738, 0.479100132440759, 0.46157879635820986, 0.43372108776671126, 0.4521519413829479, 0.4772208737947904, 0.47949489037925097, 0.4336084838960391, 0.21664866446744402, 0.21020796781048734, 0.20391775129587275, 0.2102933753324162, 0.21488300958379658, 0.22832035167615627, 0.19642172451381434, 0.19848521525915352, 0.24607068311088864, 0.22638461450377823, 0.21955924768255364, 0.22099698523152322, 0.2464495276526275, 0.2015667282287935, 0.20552757969012359, 0.20783549005238355, 0.21796835920185642, 0.21117204849685445, 0.17313527134759987, 0.8910706378954903, 0.15211568904684047, 0.8901467250816121, 0.19936136052459064, 0.1733889867309919, 0.14219936505632336, 0.15934671658200672, 0.21046538462018194, 0.8813767329362526, 0.8404360913909095, 0.8400914666175698, 0.2116666932825344, 0.16800672632850167, 0.8253102176423769, 0.16810764576068138, 0.21002542641758581, 0.8761756538100725, 0.21770435341516903, 0.19684888208430695, 0.20589586690149797, 0.18355856139871507, 0.20310480967848143, 0.18729717612734564, 0.18811472821621278, 0.1933542490469048, 0.1996172762222207, 0.08091856304424327, 0.08559185525502855, 0.09926782238828946, 0.07769180530251996, 0.08145907572888011, 0.09784577550374873, 0.08813891779584104, 0.09794845121770268, 0.09199369335995033]}, "mutation_prompt": null}
{"id": "fae7f83d-c283-40d8-a8a5-06cced147622", "solution": "import numpy as np\n\nclass SwiftHybridEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(80, self.budget // 6)  # Larger population for higher diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.6  # Slightly increased to enhance exploration\n        self.CR_base = 0.85  # Balanced for exploration and exploitation\n        self.adaptation_rate = 0.1  # Faster adaptation\n        self.local_search_intensity = 0.2  # More intense local search\n        self.mutation_prob = 0.6  # Balanced mutation probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        # Track the best solution found\n        best_index = np.argmin(fitness)\n        best_individual = population[best_index]\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Self-adaptive F and CR\n                F = np.clip(self.F_base + self.adaptation_rate * np.random.randn(), 0, 1)\n                CR = np.clip(self.CR_base + self.adaptation_rate * np.random.randn(), 0, 1)\n\n                # Choose mutation strategy based on a probability\n                if np.random.rand() < self.mutation_prob:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = population[indices]\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(self.population_size, 2, replace=False)\n                    a, b = population[indices]\n                    mutant = np.clip(best_individual + F * (a - b), self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n\n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection and elitism\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Enhanced cooperative swarm dynamics around the best individual\n            neighborhood_size = int(self.local_search_intensity * self.population_size)\n            local_neighbors = best_individual + np.random.normal(0, 0.1, (neighborhood_size, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n\n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_local_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_local_index]\n                best_fitness = local_fitness[best_local_index]\n\n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        return best_individual", "name": "SwiftHybridEvolutionStrategy", "description": "A hybrid evolution strategy combining adaptive differential evolution with cooperative swarm dynamics for faster convergence and optimal solution discovery.", "configspace": "", "generation": 69, "fitness": 0.3649744656579625, "feedback": "The algorithm SwiftHybridEvolutionStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.25.", "error": "", "parent_id": "ec99e2dc-36dd-4b70-9fb0-6285f697cac9", "metadata": {"aucs": [0.7929283507765789, 0.7850630045253543, 0.7727894259002654, 0.7813489521059804, 0.7969396298301079, 0.7960193588241575, 0.7924547677880174, 0.7905185071472286, 0.7846431651086814, 0.5559977595968012, 0.5927289776093616, 0.5989644433504158, 0.586372726805672, 0.5805742633540705, 0.5734218221234808, 0.5690647162356361, 0.5861561608220307, 0.5828224591987593, 0.11610559387494956, 0.12905752179315533, 0.12213829989415936, 0.14170612346768352, 0.18623817492541317, 0.18259294515504088, 0.20652619158850116, 0.14294520246418418, 0.1345172567360805, 0.1323160467524256, 0.11145147317493143, 0.12427489858759833, 0.11698233378104228, 0.12494722068548103, 0.11343864466144948, 0.12172736661246597, 0.11179433707421826, 0.1373160002449042, 0.9755566036571285, 0.980863222432391, 0.9796894144158463, 0.9738100225190706, 0.970310788218619, 0.9878522323151093, 0.9807549603981437, 0.9804132380006674, 0.9826683543765871, 0.36111256435884653, 0.3909598960831526, 0.34771352163207614, 0.3641940604995474, 0.3717640835936231, 0.39334121050064397, 0.3831462721714699, 0.35491693548234604, 0.33296049836844654, 0.5530841160709361, 0.7828425476842954, 0.7276122027011633, 0.7606936694657817, 0.7186126371695616, 0.8005796829459575, 0.7843132367126673, 0.7855363567665907, 0.7469145296488144, 0.4232211358185224, 0.49086629501134316, 0.12990112199377668, 0.12612777549508758, 0.3783609953816094, 0.4078784989407973, 0.1259353559825217, 0.4577461911773576, 0.39043152969688755, 0.3082040864205665, 0.3966059994461608, 0.46081967099256926, 0.43167968193133965, 0.12961236841059254, 0.37034460167288674, 0.4078642881084157, 0.2778686591126126, 0.3241215604472423, 0.29545009496014296, 0.29929015588409813, 0.28007513758827973, 0.2855655730466943, 0.28220440439697725, 0.23172493763273483, 0.2944007829326706, 0.26977694940223074, 0.2766485500712288, 0.37099259003682084, 0.4018220502135694, 0.41620463835021726, 0.4232013726777215, 0.4154298685352986, 0.3743759166883449, 0.47505734725526394, 0.44713870344258144, 0.4643032319559047, 0.09549182707959591, 0.20505561272170103, 0.11934018587112516, 0.2019712614241964, 0.22835662106023602, 0.18304939630707195, 0.12298957200467464, 0.09313680597804197, 0.07402292032536573, 0.24711859403347047, 0.24102252754664255, 0.2586181919524517, 0.2781956322169703, 0.2551651228566081, 0.2788116717131349, 0.25691589641017865, 0.2601957350651094, 0.2790614017577293, 0.6700630411457091, 0.6568537212499976, 0.6756025337978794, 0.6837360731348733, 0.668542734162519, 0.6687812107231176, 0.6707806129831464, 0.6363921448539112, 0.6679634090979454, 0.13921265255272497, 0.12358969824704613, 0.1299957091807088, 0.10560799568475143, 0.11099521173936333, 0.11045643502228863, 0.1321148492316705, 0.11733056460196822, 0.11486443331107421, 0.1895388869650002, 0.286968741874273, 0.1570920872325431, 0.20027926461835666, 0.2553115771321304, 0.28138748136123115, 0.18841233530291468, 0.1722734829256115, 0.17356332552392872, 0.4126867691585405, 0.38615930575277, 0.41648730762375796, 0.33428385724998544, 0.37865923236741006, 0.3459156004024748, 0.424702168153517, 0.38500473766802557, 0.4503430839666045, 0.3010748675432585, 0.31014969501308887, 0.3254532467084129, 0.309135739473256, 0.2907817278975874, 0.33803115068809864, 0.29767033070659854, 0.3447535784413215, 0.3248807867727629, 0.19675140846372274, 0.20510412443757597, 0.21201965002470968, 0.1811980610701207, 0.26975851223879765, 0.20153514947313944, 0.19355973361776468, 0.20901696384851143, 0.18516025451901896, 0.21807559016728217, 0.4934467126082085, 0.20975514536153916, 0.19640679584500897, 0.22704939156873238, 0.23599498528163743, 0.22459954284241224, 0.27913132645154715, 0.22582710079325186, 0.14833560345831498, 0.18791412314788347, 0.7128839819305941, 0.8197926870694827, 0.1989034076242343, 0.1671954365784255, 0.7323703719167082, 0.16048637878887473, 0.21136202623672262, 0.7500124902466997, 0.1551240466107534, 0.7562650835458959, 0.773766695425775, 0.20399811374403043, 0.20953138529359683, 0.7723939725438453, 0.20953962804774384, 0.20989084298702898, 0.17964184715794707, 0.18890566367441752, 0.18953214652060946, 0.18881754726701305, 0.18134859243155144, 0.1868847786189396, 0.17868522828054023, 0.17305111899592485, 0.1788860314407269, 0.07953917947746703, 0.08771776338767501, 0.08278838156853385, 0.078666632505214, 0.0771521142567344, 0.07985038859247273, 0.0815480350714759, 0.0693336758158355, 0.07722325580193623]}, "mutation_prompt": null}
{"id": "59998e17-ce73-42e0-bbf5-1fe816fdbcf8", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(60, self.budget // 8)  # Increased population size for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.5  # Adjusted for better exploration\n        self.CR_base = 0.9  # Increased to promote diversity\n        self.adaptation_rate = 0.05  # Increased adaptation rate for faster parameter adjustment\n        self.local_search_intensity = 0.15  # Increased local search intensity\n        self.mutation_prob = 0.7  # Probability of best or rand mutation\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        # Track the best solution found\n        best_index = np.argmin(fitness)\n        best_individual = population[best_index]\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Self-adaptive F and CR\n                F = np.clip(self.F_base + self.adaptation_rate * np.random.randn(), 0, 1)\n                CR = np.clip(self.CR_base + self.adaptation_rate * np.random.randn(), 0, 1)\n\n                # Choose mutation strategy based on a probability\n                if np.random.rand() < self.mutation_prob:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = population[indices]\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(self.population_size, 2, replace=False)\n                    a, b = population[indices]\n                    mutant = np.clip(best_individual + F * (a - b), self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n\n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection and elitism\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Enhanced cooperative local search around the best individual\n            neighborhood_size = int(self.local_search_intensity * self.population_size)\n            local_neighbors = best_individual + np.random.normal(0, 0.05, (neighborhood_size, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n\n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_local_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_local_index]\n                best_fitness = local_fitness[best_local_index]\n\n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        return best_individual", "name": "EnhancedHybridAdaptiveDifferentialEvolution", "description": "An enhanced hybrid adaptive differential evolution with increased local search adaptation and self-adaptive parameter tuning for rapid convergence.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ec99e2dc-36dd-4b70-9fb0-6285f697cac9", "metadata": {"aucs": [0.870997610873655, 0.876937349254849, 0.8628821214606534, 0.8781794510016624, 0.8772296468912268, 0.8694279318528029, 0.8756843654306008, 0.8726768563847991, 0.8598523983391932, 0.7477842665418626, 0.7505830115174412, 0.7273487673266275, 0.7189706160361924, 0.7360234772212559, 0.7429061262623435, 0.7438642610252675, 0.7560429492372163, 0.7467399915536672, 0.16512467121215724, 0.21203315310966409, 0.36256095224927487, 0.16722241556246864, 0.13854119174963164, 0.3333937421616463, 0.13516368482132823, 0.14772951992740369, 0.15692171902064456, 0.1564408366174984, 0.1353579238051421, 0.14422112246044583, 0.11484204674412235, 0.11348023152341102, 0.11138379259342324, 0.14321803866866378, 0.14280534633632092, 0.15859257836490215, 0.9799585186455763, 0.9503327389088712, 0.9724501584066897, 0.9571617360165604, 0.9859598542069689, 0.9718842750065484, 0.9760859368284891, 0.9848955505579943, 0.973482908644332, 0.6071385211387058, 0.6173177688242826, 0.6131191937365257, 0.6198810082831014, 0.6308754058002048, 0.6151046424041569, 0.5929618643435774, 0.6259420273296028, 0.6123827674671722, 0.8398909658399296, 0.8539463927768597, 0.8286288287924357, 0.8479342703448974, 0.88641759183554, 0.8924952684036396, 0.8466961223205589, 0.8895895616883716, 0.8513347130888925, 0.6474349245531625, 0.13233776457818802, 0.6015251038894203, 0.12842010025943162, 0.6650660782032273, 0.729896318050316, 0.5838451394599409, 0.6038932677285569, 0.7486964038653956, 0.6027977688129897, 0.12904105617894945, 0.4970570551982538, 0.6338783710380922, 0.1311763787354625, 0.654584992183878, 0.13347577211066708, 0.5834411824896677, 0.6644167530846077, 0.5801341813173042, 0.6517131199065661, 0.5747597642597722, 0.5450781855850122, 0.6264774567937635, 0.5973118877387971, 0.5922806442473407, 0.6058774307227208, 0.5307442727477565, 0.7246104456113118, 0.7196658854680926, 0.6937459743116989, 0.6929901166276469, 0.6764640766292062, 0.6877991243894017, 0.7095399141637933, 0.7431058503302441, 0.7141560428367603, 0.5111644149668872, 0.12354566074955964, 0.13808117097245265, 0.16417221084055578, 0.5071824081123578, 0.2800834292901856, 0.15227794024262242, 0.2060402404781626, 0.43032493661029814, 0.49899493882997625, 0.5191627329886238, 0.4963062823251455, 0.519113603089481, 0.5317078511278232, 0.5517407313988787, 0.4828361527779109, 0.5174869321995552, 0.5274905608509252, 0.8230889833159312, 0.8274699863485728, 0.802146867581838, 0.7996643983062854, 0.8111585569300906, 0.8076406107590844, 0.8097513012737546, 0.813623972927586, 0.8012792400647224, 0.1543570750637966, 0.11202371696330105, 0.16342062676402602, 0.11988433445212554, 0.14401205285359286, 0.1247286910495965, 0.15758369478141976, 0.13863798943727346, 0.12049367302351399, 0.30905398943833184, 0.222262321964814, 0.21822555431598334, 0.1939458291385081, 0.4463802150027981, 0.2623165071326464, 0.388702947695691, 0.39316509265836086, 0.5641051301559905, 0.5559964566010401, 0.5794900739564952, 0.5592162804406543, 0.5334386158196133, 0.5634881082285331, 0.5764055782840386, 0.6324910585494613, 0.6113997600794387, 0.5576296411418729, 0.45822871852814717, 0.4632290950314738, 0.479100132440759, 0.46157879635820986, 0.43372108776671126, 0.4521519413829479, 0.4772208737947904, 0.47949489037925097, 0.4336084838960391, 0.21664866446744402, 0.21020796781048734, 0.20391775129587275, 0.2102933753324162, 0.21488300958379658, 0.22832035167615627, 0.19642172451381434, 0.19848521525915352, 0.24607068311088864, 0.22638461450377823, 0.21955924768255364, 0.22099698523152322, 0.2464495276526275, 0.2015667282287935, 0.20552757969012359, 0.20783549005238355, 0.21796835920185642, 0.21117204849685445, 0.17313527134759987, 0.8910706378954903, 0.15211568904684047, 0.8901467250816121, 0.19936136052459064, 0.1733889867309919, 0.14219936505632336, 0.15934671658200672, 0.21046538462018194, 0.8813767329362526, 0.8404360913909095, 0.8400914666175698, 0.2116666932825344, 0.16800672632850167, 0.8253102176423769, 0.16810764576068138, 0.21002542641758581, 0.8761756538100725, 0.21770435341516903, 0.19684888208430695, 0.20589586690149797, 0.18355856139871507, 0.20310480967848143, 0.18729717612734564, 0.18811472821621278, 0.1933542490469048, 0.1996172762222207, 0.08091856304424327, 0.08559185525502855, 0.09926782238828946, 0.07769180530251996, 0.08145907572888011, 0.09784577550374873, 0.08813891779584104, 0.09794845121770268, 0.09199369335995033]}, "mutation_prompt": null}
{"id": "eeccad76-e104-413f-a24b-9b666d4873ff", "solution": "import numpy as np\n\nclass IntegratedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = min(60, self.budget // 8)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.5\n        self.CR_base = 0.9\n        self.adaptation_rate = 0.1  # Increased adaptation rate for faster parameter adjustments\n        self.local_search_intensity = 0.2  # Enhanced local search intensity\n        self.mutation_prob = 0.8  # Increased mutation probability for broader exploration\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.initial_population_size\n\n        # Track the best solution found\n        best_index = np.argmin(fitness)\n        best_individual = population[best_index]\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            # Dynamic population resizing\n            current_population_size = self.initial_population_size - (eval_count // (self.budget // 4))\n            current_population_size = max(10, current_population_size)\n            population = population[:current_population_size]\n            fitness = fitness[:current_population_size]\n\n            for i in range(current_population_size):\n                # Self-adaptive F and CR\n                F = np.clip(self.F_base + self.adaptation_rate * np.random.randn(), 0, 1)\n                CR = np.clip(self.CR_base + self.adaptation_rate * np.random.randn(), 0, 1)\n\n                # Choose mutation strategy based on a probability\n                if np.random.rand() < self.mutation_prob:\n                    indices = np.random.choice(current_population_size, 3, replace=False)\n                    a, b, c = population[indices]\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(current_population_size, 2, replace=False)\n                    a, b = population[indices]\n                    mutant = np.clip(best_individual + F * (a - b), self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n\n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection and elitism\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Advanced cooperative local search around the best individual\n            neighborhood_size = int(self.local_search_intensity * current_population_size)\n            local_neighbors = best_individual + np.random.normal(0, 0.05, (neighborhood_size, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n\n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_local_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_local_index]\n                best_fitness = local_fitness[best_local_index]\n\n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        return best_individual", "name": "IntegratedAdaptiveDifferentialEvolution", "description": "An integrated adaptive differential evolution with dynamic population resizing and advanced local search to accelerate convergence.", "configspace": "", "generation": 71, "fitness": 0.45223178582560125, "feedback": "The algorithm IntegratedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.27.", "error": "", "parent_id": "ec99e2dc-36dd-4b70-9fb0-6285f697cac9", "metadata": {"aucs": [0.8504785096150344, 0.8455222345997605, 0.8414275801141057, 0.8490813411669734, 0.8496846607064319, 0.836413213266673, 0.8550784706602638, 0.8513648478562827, 0.8501736363533152, 0.7067538827362772, 0.6976108504747032, 0.6977001909094668, 0.7212379158726221, 0.7129171990571772, 0.6907284174156101, 0.6798392657354579, 0.7208894383439766, 0.6955335960099513, 0.12949582496468226, 0.1378816449752419, 0.3921455955443398, 0.1662777941129634, 0.3790061223835032, 0.12612993564153818, 0.2864042352638976, 0.23371223467599955, 0.42929169910791276, 0.12557593223534846, 0.13000512679972376, 0.13441440604881083, 0.11336054948687202, 0.13253062486499767, 0.17238494850081565, 0.13905476278287443, 0.16443374921961473, 0.13288464197605832, 0.977779329142018, 0.9565235691233384, 0.9568732465172466, 0.97897262954054, 0.9607080673689745, 0.9833723777632375, 0.9750865941756776, 0.980542251926371, 0.9711576706735634, 0.5767035408054101, 0.5875888192340288, 0.5322095107988043, 0.581635321527451, 0.5460436495527565, 0.5742312919611083, 0.5860745852566921, 0.5692027838631417, 0.6020835672289473, 0.8524954757649965, 0.8167961829332815, 0.8348532044108498, 0.8461338815480681, 0.8437359482620226, 0.20840090023613111, 0.8865465419733611, 0.8731699683233256, 0.8712478219180378, 0.1332188989883698, 0.5734959155532924, 0.5693625015946857, 0.13072845551617707, 0.13526983150902305, 0.602457276771899, 0.6275575553538173, 0.5798204894674786, 0.5064484687833115, 0.6206945723539959, 0.5791877771060407, 0.13051850324152092, 0.6867662330711167, 0.5570286848128321, 0.5707004299651102, 0.645013112710665, 0.6012884951027596, 0.1304045778667734, 0.5385911922280975, 0.5606277690474399, 0.5339701680084699, 0.48505058557338754, 0.5423428659179923, 0.4922885302464727, 0.5925268051436154, 0.5427153997792857, 0.5497662156245586, 0.6571269406038365, 0.6575580313119106, 0.6655194281606464, 0.684033382531801, 0.6907128109222641, 0.6099259624289093, 0.6683104551898377, 0.640287689350598, 0.6417588990526428, 0.4331794243389744, 0.16487532503001534, 0.06534763299617607, 0.17096690368756795, 0.1472500706206996, 0.43254489272465046, 0.33675947197956757, 0.2133988997654973, 0.09439614467570223, 0.4617873287721732, 0.46346349801224795, 0.4197622406688801, 0.4670456059420418, 0.4620336753537726, 0.4645763365609802, 0.4500305383700788, 0.45169033177429296, 0.443655451105085, 0.778678180566121, 0.7746193759117747, 0.7685422354173183, 0.7828866244618122, 0.7822556888853532, 0.7635639593003899, 0.7767324202118455, 0.788505762493012, 0.772906086170531, 0.14103957088589647, 0.1495128810852655, 0.15054002943501876, 0.1629320671397767, 0.11158234057456029, 0.1308777227453145, 0.10617384472062241, 0.14308616129588847, 0.1312085667705265, 0.28924766707150995, 0.2405512323384954, 0.1874981603021184, 0.3818577587728379, 0.31023218231507976, 0.18201104858485861, 0.19726994813262466, 0.29298306418656583, 0.22204662791654306, 0.4952317121339316, 0.4830900647330062, 0.5253007300107371, 0.5297800939293176, 0.5211341653121824, 0.5570428710808746, 0.5870138513089058, 0.5368834051182719, 0.5455613497612182, 0.39031347765688573, 0.36464974137010187, 0.3851682121319029, 0.42960977024833724, 0.4353816256499561, 0.41220304557892473, 0.431182488104372, 0.4384246485803477, 0.20921332698038397, 0.20024527942886738, 0.20562049412293093, 0.19672651259911056, 0.2232658005515139, 0.19768167925965952, 0.2507181399761923, 0.22601113150284902, 0.2071707044242289, 0.20468110002361284, 0.24041179879453733, 0.24288071277989443, 0.18999987936564988, 0.25820987829618713, 0.23809111787534343, 0.20306451739381592, 0.19912491668295929, 0.2386945967112929, 0.48642361706906145, 0.1821090396964039, 0.1859077190741132, 0.15275806591241303, 0.8487478437624967, 0.19800530381564407, 0.8909979396371824, 0.8876383062124112, 0.159623020955713, 0.18329066559592333, 0.8587812484085727, 0.796383911867263, 0.7804911947191902, 0.8346422019173252, 0.16571701546087203, 0.1644396623753177, 0.7637587705096096, 0.20963754680940538, 0.21048330600210396, 0.18175667792797578, 0.19413438748637624, 0.19606527672739182, 0.17967775916267548, 0.2086965506080527, 0.18925714720691023, 0.17729173592314906, 0.1997343114654372, 0.1922509561275002, 0.09034072254506864, 0.08792862156058456, 0.08809000875025164, 0.08688776948317134, 0.11049484916997676, 0.08581653456323435, 0.08465136769778325, 0.0793527215741433, 0.08724541880150771]}, "mutation_prompt": null}
{"id": "2eed1419-fc0d-41e8-8ef8-e11b36d543e7", "solution": "import numpy as np\n\nclass DynamicEnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = min(80, self.budget // 10)  # Larger initial population for diverse exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.6  # Slightly higher base for mutation factor to maintain diversity\n        self.CR_base = 0.85  # Reduced to balance exploration and exploitation\n        self.adaptation_rate = 0.1  # Further increased adaptation rate\n        self.local_search_intensity = 0.2  # Increased local search intensity\n        self.mutation_prob = 0.8  # Higher probability for rand mutation\n        self.dynamic_population_reduction = 0.95  # Reduce population size iteratively\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.initial_population_size\n\n        # Track the best solution found\n        best_index = np.argmin(fitness)\n        best_individual = population[best_index]\n        best_fitness = fitness[best_index]\n\n        current_population_size = self.initial_population_size\n\n        while eval_count < self.budget:\n            next_population_size = int(current_population_size * self.dynamic_population_reduction)\n            next_population_size = max(4, next_population_size)  # Ensure a minimum viable population\n\n            for i in range(current_population_size):\n                # Self-adaptive F and CR\n                F = np.clip(self.F_base + self.adaptation_rate * np.random.randn(), 0, 1)\n                CR = np.clip(self.CR_base + self.adaptation_rate * np.random.randn(), 0, 1)\n\n                # Choose mutation strategy based on a probability\n                if np.random.rand() < self.mutation_prob:\n                    indices = np.random.choice(current_population_size, 3, replace=False)\n                    a, b, c = population[indices]\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(current_population_size, 2, replace=False)\n                    a, b = population[indices]\n                    mutant = np.clip(best_individual + F * (a - b), self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n\n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection and elitism\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Enhanced cooperative local search around the best individual\n            neighborhood_size = int(self.local_search_intensity * current_population_size)\n            local_neighbors = best_individual + np.random.normal(0, 0.05, (neighborhood_size, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n\n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_local_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_local_index]\n                best_fitness = local_fitness[best_local_index]\n\n            population = population[:next_population_size]  # Adjust population size dynamically\n            fitness = fitness[:next_population_size]\n            current_population_size = next_population_size\n\n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        return best_individual", "name": "DynamicEnhancedHybridDifferentialEvolution", "description": "A hybrid enhanced differential evolution algorithm with dynamic population adjustment and selective pressure increase for accelerated convergence.", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('zero-size array to reduction operation minimum which has no identity').", "error": "ValueError('zero-size array to reduction operation minimum which has no identity')", "parent_id": "ec99e2dc-36dd-4b70-9fb0-6285f697cac9", "metadata": {}, "mutation_prompt": null}
{"id": "8bb757b3-d316-44ac-9ff1-1ea8060ac816", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(80, self.budget // 6)  # Dynamic population size for better coverage\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.6  # Improved exploration factor\n        self.CR_base = 0.85  # Balanced crossover rate\n        self.adaptation_rate = 0.07  # Slightly increased adaptation rate for better tuning\n        self.local_search_intensity = 0.10  # Adjusted local search intensity\n        self.mutation_prob = 0.8  # Higher mutation probability for diversity\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        # Track the best solution found\n        best_index = np.argmin(fitness)\n        best_individual = population[best_index]\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Self-adaptive F and CR\n                F = np.clip(self.F_base + self.adaptation_rate * np.random.randn(), 0.4, 0.9)\n                CR = np.clip(self.CR_base + self.adaptation_rate * np.random.randn(), 0.5, 1.0)\n\n                # Choose mutation strategy based on a probability\n                if np.random.rand() < self.mutation_prob:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = population[indices]\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(self.population_size, 2, replace=False)\n                    a, b = population[indices]\n                    mutant = np.clip(best_individual + F * (a - b), self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n\n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Greedy selection strategy\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                else:\n                    eval_count -= 1  # Revert count if no improvement\n\n                if eval_count >= self.budget:\n                    break\n\n            # Enhanced cooperative local search around the best individual\n            neighborhood_size = max(1, int(self.local_search_intensity * self.population_size))\n            local_neighbors = best_individual + np.random.normal(0, 0.1, (neighborhood_size, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n\n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_local_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_local_index]\n                best_fitness = local_fitness[best_local_index]\n\n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n            # Dynamic population resizing\n            if eval_count < self.budget / 2 and np.random.rand() < 0.1:\n                self.population_size = max(20, int(self.population_size * 0.9))\n\n        # Return best found solution\n        return best_individual", "name": "EnhancedDynamicDifferentialEvolution", "description": "A hybrid adaptive differential evolution with enhanced greedy selection, dynamic population resizing, and adaptive search scaling for accelerated convergence.", "configspace": "", "generation": 73, "fitness": 0.3933112265061318, "feedback": "The algorithm EnhancedDynamicDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.24.", "error": "", "parent_id": "ec99e2dc-36dd-4b70-9fb0-6285f697cac9", "metadata": {"aucs": [0.7671122208854854, 0.766265274428475, 0.7735383910666406, 0.7702867318303427, 0.7817543178073151, 0.7728196030903721, 0.7621593585775378, 0.7569679609823003, 0.7691901331189842, 0.571134110308313, 0.6165708143096289, 0.6124471776996407, 0.5954786707952002, 0.6136313472916021, 0.6080272575778862, 0.5712601078685916, 0.6167768409505332, 0.628328098818401, 0.12208703558947032, 0.3307428677967633, 0.13681036302294303, 0.2330846505937867, 0.12090665165614789, 0.32162839132690957, 0.12793816551525028, 0.1376217598697722, 0.4093812998212818, 0.11149955947799639, 0.14217552910151843, 0.1319794546018016, 0.11649722337018809, 0.12239806813822685, 0.11428196762356857, 0.10148903006120058, 0.14386428307559274, 0.125440163586356, 0.9593265053883749, 0.9789464787198101, 0.9661707527191284, 0.962198506206834, 0.9658061120272305, 0.9690386827220333, 0.9627080089317329, 0.9783759351330844, 0.9830206108199712, 0.42049324474369065, 0.5314107457309717, 0.5032906069564211, 0.4452173027294062, 0.5520151173670176, 0.5541933808562148, 0.4547178951965105, 0.5412904242296798, 0.5374445584905362, 0.6876990273122572, 0.6972976887018661, 0.6647934694957667, 0.7060019406854037, 0.7214199639592159, 0.7409147617429834, 0.7001520990046772, 0.7635603189783826, 0.7146830039627385, 0.4406867021995302, 0.5594844724931867, 0.501331257622347, 0.12413239922492159, 0.5305748203429195, 0.5089630168311232, 0.3947670767969972, 0.5088518401011868, 0.5198663525579948, 0.2913804060185723, 0.2726131527072524, 0.38697250413709405, 0.4176593867473958, 0.46752578561414726, 0.44658439691389473, 0.4069204787526588, 0.44245646664048943, 0.48255643368174683, 0.299347950110172, 0.42247601498000287, 0.3714563115992088, 0.30488264501611606, 0.3565394665636522, 0.349720614921591, 0.32822372894372664, 0.4138338446007651, 0.4391591534799385, 0.43397619738813387, 0.41917216009557945, 0.49780306678439257, 0.4381868647338134, 0.5072105978414073, 0.517632508793011, 0.48300258422561393, 0.5452918988426443, 0.5536716706853225, 0.1224420824494995, 0.06883199347557489, 0.12236649042701142, 0.25287367885476075, 0.268153265729721, 0.3082714423337204, 0.0860538979674077, 0.08354120072085003, 0.19253514816585882, 0.2790120340413764, 0.27795428104063424, 0.299221951935262, 0.296618572054388, 0.3255733836943383, 0.391162478127591, 0.280593898485048, 0.31820171508939743, 0.29261779062786153, 0.6356652926989674, 0.6853553765580591, 0.683372281636695, 0.6443792896370557, 0.6687967024506718, 0.6839304943065316, 0.6403096945263946, 0.6821218273513487, 0.6256363515519536, 0.12835086915472982, 0.1235518055027236, 0.09354754729117631, 0.1565763929505174, 0.1255963657334942, 0.1112043253583117, 0.12815865226532264, 0.11807713554233523, 0.09969402091011248, 0.17617296314282904, 0.18825545841516556, 0.17451721860497726, 0.19825414284099507, 0.4144105440384508, 0.18972846311925695, 0.14746992801457526, 0.3009200870819353, 0.2006195859293607, 0.4025533999757005, 0.44684584003608374, 0.4413863239067657, 0.4279532073035258, 0.4407763127454538, 0.5157568450926484, 0.41981860211312116, 0.48395255438557416, 0.5632504872205779, 0.27711401796738644, 0.35184403345153903, 0.34252592417973093, 0.26972413386271343, 0.37276550338847403, 0.3391944837642612, 0.2685385119260937, 0.39070667031499584, 0.38755172974613783, 0.1887410671609966, 0.20339746278958415, 0.21730929458625048, 0.20596840336878408, 0.18810728221498874, 0.19539059854001328, 0.18761500294609923, 0.20647616567858618, 0.20395310216879114, 0.4043681515715598, 0.2209998791792005, 0.22191160526395315, 0.4558930901672418, 0.21385232878353244, 0.4645894908051077, 0.41337121692958156, 0.46334764964080966, 0.22388898091919252, 0.14726138475823736, 0.7266357209415603, 0.18168502665452546, 0.7564569100110774, 0.19837653947248268, 0.19829179197929125, 0.7084534756745369, 0.1704962331797647, 0.16614701782606156, 0.7111447849640388, 0.16857664806360773, 0.6768738195559059, 0.2042513821967843, 0.5828980718659715, 0.6651181812824936, 0.1898768325317658, 0.12661408411101405, 0.20116363773192725, 0.18837778433042263, 0.19636512490327274, 0.18093589202021, 0.1841740767787462, 0.18115004831775794, 0.19336235422225656, 0.19127403018873623, 0.19137675600470727, 0.18180781980237015, 0.08779823506838458, 0.08172927684296083, 0.09448789980974837, 0.0754288648047381, 0.0827513954922593, 0.0811061404010146, 0.07315414544056476, 0.07409183206940306, 0.07271797666006585]}, "mutation_prompt": null}
{"id": "7eb5a09e-14e5-4ac0-84ec-905e97f8fc23", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(60, self.budget // 8)  # Increased population size for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.5  # Adjusted for better exploration\n        self.CR_base = 0.9  # Increased to promote diversity\n        self.adaptation_rate = 0.05  # Increased adaptation rate for faster parameter adjustment\n        self.local_search_intensity = 0.15  # Increased local search intensity\n        self.mutation_prob = 0.7  # Probability of best or rand mutation\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        # Track the best solution found\n        best_index = np.argmin(fitness)\n        best_individual = population[best_index]\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Self-adaptive F and CR\n                F = np.clip(self.F_base + self.adaptation_rate * np.random.randn(), 0, 1)\n                CR = np.clip(self.CR_base + self.adaptation_rate * np.random.randn(), 0, 1)\n\n                # Choose mutation strategy based on a probability\n                if np.random.rand() < self.mutation_prob:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = population[indices]\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(self.population_size, 2, replace=False)\n                    a, b = population[indices]\n                    mutant = np.clip(best_individual + F * (a - b), self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n\n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection and elitism\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Enhanced cooperative local search around the best individual\n            neighborhood_size = int(self.local_search_intensity * self.population_size)\n            local_neighbors = best_individual + np.random.normal(0, 0.05, (neighborhood_size, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n\n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_local_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_local_index]\n                best_fitness = local_fitness[best_local_index]\n\n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        return best_individual", "name": "EnhancedHybridAdaptiveDifferentialEvolution", "description": "An enhanced hybrid adaptive differential evolution with increased local search adaptation and self-adaptive parameter tuning for rapid convergence.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ec99e2dc-36dd-4b70-9fb0-6285f697cac9", "metadata": {"aucs": [0.870997610873655, 0.876937349254849, 0.8628821214606534, 0.8781794510016624, 0.8772296468912268, 0.8694279318528029, 0.8756843654306008, 0.8726768563847991, 0.8598523983391932, 0.7477842665418626, 0.7505830115174412, 0.7273487673266275, 0.7189706160361924, 0.7360234772212559, 0.7429061262623435, 0.7438642610252675, 0.7560429492372163, 0.7467399915536672, 0.16512467121215724, 0.21203315310966409, 0.36256095224927487, 0.16722241556246864, 0.13854119174963164, 0.3333937421616463, 0.13516368482132823, 0.14772951992740369, 0.15692171902064456, 0.1564408366174984, 0.1353579238051421, 0.14422112246044583, 0.11484204674412235, 0.11348023152341102, 0.11138379259342324, 0.14321803866866378, 0.14280534633632092, 0.15859257836490215, 0.9799585186455763, 0.9503327389088712, 0.9724501584066897, 0.9571617360165604, 0.9859598542069689, 0.9718842750065484, 0.9760859368284891, 0.9848955505579943, 0.973482908644332, 0.6071385211387058, 0.6173177688242826, 0.6131191937365257, 0.6198810082831014, 0.6308754058002048, 0.6151046424041569, 0.5929618643435774, 0.6259420273296028, 0.6123827674671722, 0.8398909658399296, 0.8539463927768597, 0.8286288287924357, 0.8479342703448974, 0.88641759183554, 0.8924952684036396, 0.8466961223205589, 0.8895895616883716, 0.8513347130888925, 0.6474349245531625, 0.13233776457818802, 0.6015251038894203, 0.12842010025943162, 0.6650660782032273, 0.729896318050316, 0.5838451394599409, 0.6038932677285569, 0.7486964038653956, 0.6027977688129897, 0.12904105617894945, 0.4970570551982538, 0.6338783710380922, 0.1311763787354625, 0.654584992183878, 0.13347577211066708, 0.5834411824896677, 0.6644167530846077, 0.5801341813173042, 0.6517131199065661, 0.5747597642597722, 0.5450781855850122, 0.6264774567937635, 0.5973118877387971, 0.5922806442473407, 0.6058774307227208, 0.5307442727477565, 0.7246104456113118, 0.7196658854680926, 0.6937459743116989, 0.6929901166276469, 0.6764640766292062, 0.6877991243894017, 0.7095399141637933, 0.7431058503302441, 0.7141560428367603, 0.5111644149668872, 0.12354566074955964, 0.13808117097245265, 0.16417221084055578, 0.5071824081123578, 0.2800834292901856, 0.15227794024262242, 0.2060402404781626, 0.43032493661029814, 0.49899493882997625, 0.5191627329886238, 0.4963062823251455, 0.519113603089481, 0.5317078511278232, 0.5517407313988787, 0.4828361527779109, 0.5174869321995552, 0.5274905608509252, 0.8230889833159312, 0.8274699863485728, 0.802146867581838, 0.7996643983062854, 0.8111585569300906, 0.8076406107590844, 0.8097513012737546, 0.813623972927586, 0.8012792400647224, 0.1543570750637966, 0.11202371696330105, 0.16342062676402602, 0.11988433445212554, 0.14401205285359286, 0.1247286910495965, 0.15758369478141976, 0.13863798943727346, 0.12049367302351399, 0.30905398943833184, 0.222262321964814, 0.21822555431598334, 0.1939458291385081, 0.4463802150027981, 0.2623165071326464, 0.388702947695691, 0.39316509265836086, 0.5641051301559905, 0.5559964566010401, 0.5794900739564952, 0.5592162804406543, 0.5334386158196133, 0.5634881082285331, 0.5764055782840386, 0.6324910585494613, 0.6113997600794387, 0.5576296411418729, 0.45822871852814717, 0.4632290950314738, 0.479100132440759, 0.46157879635820986, 0.43372108776671126, 0.4521519413829479, 0.4772208737947904, 0.47949489037925097, 0.4336084838960391, 0.21664866446744402, 0.21020796781048734, 0.20391775129587275, 0.2102933753324162, 0.21488300958379658, 0.22832035167615627, 0.19642172451381434, 0.19848521525915352, 0.24607068311088864, 0.22638461450377823, 0.21955924768255364, 0.22099698523152322, 0.2464495276526275, 0.2015667282287935, 0.20552757969012359, 0.20783549005238355, 0.21796835920185642, 0.21117204849685445, 0.17313527134759987, 0.8910706378954903, 0.15211568904684047, 0.8901467250816121, 0.19936136052459064, 0.1733889867309919, 0.14219936505632336, 0.15934671658200672, 0.21046538462018194, 0.8813767329362526, 0.8404360913909095, 0.8400914666175698, 0.2116666932825344, 0.16800672632850167, 0.8253102176423769, 0.16810764576068138, 0.21002542641758581, 0.8761756538100725, 0.21770435341516903, 0.19684888208430695, 0.20589586690149797, 0.18355856139871507, 0.20310480967848143, 0.18729717612734564, 0.18811472821621278, 0.1933542490469048, 0.1996172762222207, 0.08091856304424327, 0.08559185525502855, 0.09926782238828946, 0.07769180530251996, 0.08145907572888011, 0.09784577550374873, 0.08813891779584104, 0.09794845121770268, 0.09199369335995033]}, "mutation_prompt": null}
{"id": "39233d7f-f5de-4b3a-aca7-97ef6162dccf", "solution": "import numpy as np\n\nclass DynamicLandscapeAdaptationDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(80, self.budget // 10)  # Larger population for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.6  # Initial value for differential weight\n        self.CR_base = 0.9  # High crossover rate for diverse trial vectors\n        self.adaptation_rate = 0.1  # More aggressive adaptation\n        self.local_search_intensity = 0.2  # Increased local search intensity\n        self.mutation_prob = 0.6  # Probability of using best mutation strategy\n        self.early_stopping_threshold = 1e-8  # Stopping condition for minimal improvement\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_individual = population[best_index]\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                F = np.clip(self.F_base + self.adaptation_rate * np.random.randn(), 0, 1)\n                CR = np.clip(self.CR_base + self.adaptation_rate * np.random.randn(), 0, 1)\n\n                if np.random.rand() < self.mutation_prob:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = population[indices]\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(self.population_size, 2, replace=False)\n                    a, b = population[indices]\n                    mutant = np.clip(best_individual + F * (a - b), self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        if abs(best_fitness - trial_fitness) < self.early_stopping_threshold:\n                            return best_individual\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            neighborhood_size = int(self.local_search_intensity * self.population_size)\n            local_neighbors = best_individual + np.random.normal(0, 0.1, (neighborhood_size, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n\n            if np.min(local_fitness) < best_fitness:\n                best_local_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_local_index]\n                best_fitness = local_fitness[best_local_index]\n\n            self.dynamic_parameter_update(fitness, population)\n\n        return best_individual\n\n    def dynamic_parameter_update(self, fitness, population):\n        # Update parameters based on landscape analysis\n        diversity = np.std(population, axis=0).mean()\n        if diversity < 0.1:\n            self.F_base *= 0.9  # Reduce F if diversity is low\n        else:\n            self.F_base *= 1.1\n        self.F_base = np.clip(self.F_base, 0.4, 0.9)", "name": "DynamicLandscapeAdaptationDE", "description": "An enhanced adaptive differential evolution incorporating dynamic landscape analysis-driven parameter control for improved convergence speed.", "configspace": "", "generation": 75, "fitness": 0.2651117054705457, "feedback": "The algorithm DynamicLandscapeAdaptationDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.22.", "error": "", "parent_id": "ec99e2dc-36dd-4b70-9fb0-6285f697cac9", "metadata": {"aucs": [0.6468907915714193, 0.6449246451275605, 0.6361794783242868, 0.7107854780226316, 0.6079348988302841, 0.6689439610727053, 0.6700740121288715, 0.686889499662759, 0.6559409796275935, 0.3130162789165023, 0.2709586710467028, 0.33224376163361036, 0.31567255267047145, 0.2687476090577906, 0.3066157146881242, 0.25815640781736304, 0.31613199315142415, 0.30773076454917314, 0.10846422435173153, 0.10129524004774193, 0.11795324917477068, 0.11097076985053611, 0.09686274710482645, 0.11445849371073036, 0.11533062827140894, 0.09854493805130404, 0.09841524507734012, 0.08610127275158097, 0.10211006107529796, 0.09852563923095659, 0.08826183935927734, 0.08882134902711603, 0.10197509525630499, 0.09301530897299837, 0.09461237515620291, 0.08391712599979839, 0.974871899071165, 0.981025990210378, 0.9767239115391189, 0.983133598278652, 0.9706647496930471, 0.9878851183824563, 0.9877138634216194, 0.9706106832564194, 0.9806510307033602, 0.30125290941315963, 0.2799636814647165, 0.2821167133331405, 0.29220975145398675, 0.2874044685410252, 0.2821870363188864, 0.2808111500099242, 0.26869223862069214, 0.266260285919377, 0.38744092518973006, 0.3549028157501658, 0.33012020829943123, 0.46030914357523733, 0.31302601143137976, 0.43575482596737625, 0.4889269031686253, 0.43293898079882087, 0.31784265141672474, 0.18971355044468818, 0.18077126631373708, 0.14665948407165164, 0.12182770700065726, 0.19548530183076385, 0.2051292609226939, 0.17058097377799897, 0.20352648586945232, 0.1259123739609398, 0.251415580633923, 0.12123194155413053, 0.18515605439436345, 0.16865865440770922, 0.19630234258044732, 0.17679269213647386, 0.16250503087265245, 0.20197263911269125, 0.2193208633228687, 0.06401646416601181, 0.015300450929939147, 0.045995833576712, 0.0646497491948429, 0.06482830904695625, 0.037082568999601606, 0.06619376682679068, 0.043127283897304136, 0.03459337267496976, 0.22433111157484542, 0.18150625594506786, 0.19403212610061482, 0.1614533047361365, 0.1531755191437687, 0.1760715974376379, 0.21373173314679184, 0.16171167784889762, 0.19242501071786455, 0.0033307578180808983, 0.0011839716213346563, 0.010873981279173162, 0.007065801092785984, 0.010196056011487431, 0.005115047497369241, 0.010688084870877912, 0.005758685101002858, 0.0016252699085809175, 0.11402399597248347, 0.11991193926927013, 0.15516239948139932, 0.14290488109169508, 0.12598680155234143, 0.12718997088392847, 0.11650124529747063, 0.11974208190244628, 0.11147325472573133, 0.5225865146858317, 0.5202418622845876, 0.5081490020183816, 0.5582575681725723, 0.5411958977764206, 0.5544143840660376, 0.5816960889709969, 0.5403327580539139, 0.5394876419433765, 0.15629104530755356, 0.10587408705097312, 0.0965847396640267, 0.09160491871034226, 0.08081978680720403, 0.1171135563965916, 0.11300542109554612, 0.12580535805322657, 0.11059785439806524, 0.18436398453842162, 0.3115876492961741, 0.1570920872325431, 0.1785274610320322, 0.240963218790758, 0.26202495078415133, 0.22518666439573287, 0.2679758969159165, 0.17912841027687687, 0.2551227396212439, 0.24530329594574474, 0.32158904713581526, 0.27430012262112924, 0.2981972614815711, 0.2654242798297096, 0.29004889620233054, 0.28583577181310404, 0.3050846418641313, 0.1861769821165753, 0.19383685097686776, 0.20028086858475613, 0.16907923380659562, 0.18616783918403712, 0.1901492556323845, 0.22465793430767078, 0.22382476209177826, 0.22077601860073326, 0.1973666244950134, 0.20800284652798695, 0.1784737335929285, 0.19950925519509033, 0.18223692045665196, 0.19109306200001142, 0.21611526639243162, 0.1827539115293645, 0.2004599100593255, 0.20946544390323252, 0.22323861585521232, 0.21450039195301784, 0.1841249180911939, 0.19747600724364855, 0.17840858660955816, 0.18808266910439642, 0.18636427726030436, 0.17513641882070619, 0.18714121220034252, 0.6396777565820986, 0.5571759215965898, 0.200264576993064, 0.5861012734492272, 0.18166893336353374, 0.4558184879687397, 0.42059070449782143, 0.29791591649273463, 0.45657067831676856, 0.1681793029920161, 0.2061370140632265, 0.538482176444506, 0.6209346565791354, 0.3954741010746319, 0.469210987682001, 0.6130600927409752, 0.40353389847188215, 0.19271962609538362, 0.17806339824001893, 0.19202983371577664, 0.20604179441552994, 0.17913097873656092, 0.18147759305035638, 0.1946670196435596, 0.17729341140688737, 0.183415718136136, 0.07302645831686405, 0.0713645250815147, 0.08214905137062345, 0.07398460910358695, 0.07278889680262268, 0.06765751458724423, 0.07436701610396557, 0.07565009542023149, 0.07195247012934303]}, "mutation_prompt": null}
{"id": "f03279ee-c4d8-4f9e-8478-f62b85b65151", "solution": "import numpy as np\n\nclass CooperativeHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)  # Adjusted population for balance\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.7  # Increased for better exploration\n        self.CR_base = 0.85  # Slightly decreased for more controlled diversity\n        self.adaptation_rate = 0.1  # Adjusted for dynamic adaptation\n        self.local_search_intensity = 0.2  # Enhanced local search intensity\n        self.mutation_prob = 0.8  # Increased probability of best or rand mutation\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        # Track the best solution found\n        best_index = np.argmin(fitness)\n        best_individual = population[best_index]\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Self-adaptive F and CR\n                F = np.clip(self.F_base + self.adaptation_rate * np.random.randn(), 0.4, 1)  # Wider range\n                CR = np.clip(self.CR_base + self.adaptation_rate * np.random.randn(), 0.4, 1)  # Wider range\n\n                # Choose mutation strategy based on a probability\n                if np.random.rand() < self.mutation_prob:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = population[indices]\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(self.population_size, 2, replace=False)\n                    a, b = population[indices]\n                    mutant = np.clip(best_individual + F * (a - b), self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n\n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection and elitism\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                else:\n                    # Enhanced elitism: redistribute best individual to maintain diversity\n                    if np.random.rand() < 0.1:\n                        population[i] = best_individual\n\n                if eval_count >= self.budget:\n                    break\n\n            # Enhanced cooperative local search around the best individual\n            neighborhood_size = int(self.local_search_intensity * self.population_size)\n            local_neighbors = best_individual + np.random.normal(0, 0.1, (neighborhood_size, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n\n            # Update best if any local neighbor is better\n            min_local_fitness = np.min(local_fitness)\n            if min_local_fitness < best_fitness:\n                best_local_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_local_index]\n                best_fitness = min_local_fitness\n\n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        return best_individual", "name": "CooperativeHybridAdaptiveDifferentialEvolution", "description": "A cooperative hybrid adaptive differential evolution with dynamic parameter adjustment and enhanced elitism for accelerated convergence.", "configspace": "", "generation": 76, "fitness": 0.41313853739141637, "feedback": "The algorithm CooperativeHybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.27.", "error": "", "parent_id": "ec99e2dc-36dd-4b70-9fb0-6285f697cac9", "metadata": {"aucs": [0.8255305515331093, 0.8195520381384691, 0.8352103419460738, 0.8275019531643019, 0.831751257004864, 0.8318288968167903, 0.8215901505985697, 0.8431416076836746, 0.8300730264939943, 0.6683147217076169, 0.6719196006335477, 0.6771987561209336, 0.669986132261086, 0.6841499885582446, 0.635143244720112, 0.6569780522257276, 0.69626468858899, 0.6660750877479842, 0.1784490817226877, 0.1660250948470211, 0.14178694560707095, 0.12147310617369544, 0.13916656937850835, 0.6863202735492384, 0.17627756897823565, 0.12289392029284885, 0.15747209557323172, 0.10602408272465458, 0.13033205803536618, 0.17298015300661573, 0.08830047045445444, 0.15034134091382, 0.10876859711492393, 0.1255240203175776, 0.11899431184735654, 0.15473415017669945, 0.9750369958149198, 0.9711812478997852, 0.9850981360524342, 0.9704756241452297, 0.975626983143143, 0.962147351912765, 0.986028328150388, 0.9630408714349683, 0.9747123995401223, 0.6593865519052129, 0.6330927668462603, 0.6335640780322358, 0.6720882830861452, 0.620650875413781, 0.6755561203461719, 0.6765420984255569, 0.6002103463711232, 0.5841241129620764, 0.21183868986149268, 0.8519827488994223, 0.23078249110896198, 0.814805183642173, 0.21134783729832174, 0.8156909186133479, 0.8172540596615138, 0.8393817501938675, 0.8482993971238245, 0.4795527122107658, 0.1296238125166599, 0.5760066349219679, 0.4890755296894709, 0.46986140633325657, 0.1311057435714198, 0.7025686742050667, 0.13381404583520906, 0.5552096959897495, 0.5172828156961823, 0.38125660286322793, 0.489560985743138, 0.5115145013822586, 0.49048909947052, 0.5117082396284163, 0.6003426179079021, 0.5717780340535006, 0.4637610791454464, 0.46248141703351586, 0.35786931018576285, 0.06354933841265098, 0.22239979219621253, 0.4107601883741605, 0.29174351365551154, 0.3424807689242729, 0.5128073689358363, 0.5663959681929351, 0.5618422235000678, 0.4502804959756532, 0.5497916877129914, 0.17687663050964197, 0.5052712432901455, 0.4896316704544079, 0.6494104420217828, 0.45155146827826975, 0.5315185149504231, 0.06876465249806984, 0.0813896300212813, 0.0727080879216464, 0.28747744877462567, 0.29387950986009337, 0.3308640705054333, 0.12896235280348722, 0.16816220113795755, 0.11932499907174365, 0.3136095075010942, 0.38862100647532705, 0.3238703416122577, 0.36247662651970425, 0.34535913021987186, 0.39656359522612783, 0.32846794279698976, 0.41949040879583355, 0.3692639008718416, 0.7449057806542683, 0.7407668448510777, 0.6269121980324321, 0.744229825517874, 0.7447566871436465, 0.7494750018955809, 0.7405950542375676, 0.764977257427451, 0.7356359386944877, 0.12119645295081105, 0.12104614115889889, 0.12037226994803607, 0.11320139788987105, 0.08779131472943902, 0.0794653477727113, 0.16055496080721843, 0.06267210960504277, 0.09418037001831048, 0.1622403991706578, 0.19609474321851317, 0.2364000635953195, 0.696148740120951, 0.7420481787512132, 0.6733283767053119, 0.1825827955296382, 0.29020844378225064, 0.19357597679829042, 0.2694975850608271, 0.4879761567192201, 0.37379653568848825, 0.5397357255231847, 0.5021031521044224, 0.4887876937283542, 0.5334707647114266, 0.6029378444765248, 0.4008675081011801, 0.32237529611878024, 0.35694713204216855, 0.25050250869243806, 0.366790012764167, 0.17616023549383153, 0.3580504269845446, 0.32319303777914354, 0.24912304263097285, 0.4089960630189423, 0.1714067157694248, 0.20458222792728575, 0.1863554532472258, 0.21347197318829425, 0.20534816662897237, 0.17555634259859598, 0.22488847915911725, 0.20631468859019597, 0.20747345507454407, 0.22441330032337148, 0.21885615590749086, 0.2192522289011155, 0.1864676229869211, 0.19040176385296226, 0.7504655623630683, 0.20719997009571944, 0.19806510875376937, 0.19226116390758075, 0.8855724698296993, 0.2130321682515588, 0.15378257061186162, 0.1778066155608351, 0.20060561193771997, 0.19864431336713795, 0.17863745888695048, 0.16424712347299408, 0.8931764949704573, 0.8827969925552851, 0.21113031593628895, 0.8266328004702022, 0.8263726871963286, 0.15311840429614954, 0.1680356331707118, 0.2093986926956365, 0.8317538365905144, 0.21319346362608105, 0.2061254268144337, 0.1761899940648174, 0.1751067178059158, 0.21328206376318948, 0.17848447496490571, 0.23316634490364097, 0.19826791905336305, 0.1755079667851207, 0.18179569951449026, 0.08566013849813903, 0.07783062148833231, 0.08351521930406636, 0.08087099936351938, 0.09630426776963108, 0.07202547995871389, 0.06867170926270572, 0.05772571561594608, 0.07155202134232497]}, "mutation_prompt": null}
{"id": "2b753165-a7c8-4b43-b3f3-3a0afaef9208", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(60, self.budget // 8)  # Increased population size for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.5  # Adjusted for better exploration\n        self.CR_base = 0.9  # Increased to promote diversity\n        self.adaptation_rate = 0.05  # Increased adaptation rate for faster parameter adjustment\n        self.local_search_intensity = 0.15  # Increased local search intensity\n        self.mutation_prob = 0.7  # Probability of best or rand mutation\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        # Track the best solution found\n        best_index = np.argmin(fitness)\n        best_individual = population[best_index]\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Self-adaptive F and CR\n                F = np.clip(self.F_base + self.adaptation_rate * np.random.randn(), 0, 1)\n                CR = np.clip(self.CR_base + self.adaptation_rate * np.random.randn(), 0, 1)\n\n                # Choose mutation strategy based on a probability\n                if np.random.rand() < self.mutation_prob:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = population[indices]\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(self.population_size, 2, replace=False)\n                    a, b = population[indices]\n                    mutant = np.clip(best_individual + F * (a - b), self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n\n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection and elitism\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Enhanced cooperative local search around the best individual\n            neighborhood_size = int(self.local_search_intensity * self.population_size)\n            local_neighbors = best_individual + np.random.normal(0, 0.05, (neighborhood_size, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n\n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_local_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_local_index]\n                best_fitness = local_fitness[best_local_index]\n\n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        return best_individual", "name": "EnhancedHybridAdaptiveDifferentialEvolution", "description": "An enhanced hybrid adaptive differential evolution with increased local search adaptation and self-adaptive parameter tuning for rapid convergence.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ec99e2dc-36dd-4b70-9fb0-6285f697cac9", "metadata": {"aucs": [0.870997610873655, 0.876937349254849, 0.8628821214606534, 0.8781794510016624, 0.8772296468912268, 0.8694279318528029, 0.8756843654306008, 0.8726768563847991, 0.8598523983391932, 0.7477842665418626, 0.7505830115174412, 0.7273487673266275, 0.7189706160361924, 0.7360234772212559, 0.7429061262623435, 0.7438642610252675, 0.7560429492372163, 0.7467399915536672, 0.16512467121215724, 0.21203315310966409, 0.36256095224927487, 0.16722241556246864, 0.13854119174963164, 0.3333937421616463, 0.13516368482132823, 0.14772951992740369, 0.15692171902064456, 0.1564408366174984, 0.1353579238051421, 0.14422112246044583, 0.11484204674412235, 0.11348023152341102, 0.11138379259342324, 0.14321803866866378, 0.14280534633632092, 0.15859257836490215, 0.9799585186455763, 0.9503327389088712, 0.9724501584066897, 0.9571617360165604, 0.9859598542069689, 0.9718842750065484, 0.9760859368284891, 0.9848955505579943, 0.973482908644332, 0.6071385211387058, 0.6173177688242826, 0.6131191937365257, 0.6198810082831014, 0.6308754058002048, 0.6151046424041569, 0.5929618643435774, 0.6259420273296028, 0.6123827674671722, 0.8398909658399296, 0.8539463927768597, 0.8286288287924357, 0.8479342703448974, 0.88641759183554, 0.8924952684036396, 0.8466961223205589, 0.8895895616883716, 0.8513347130888925, 0.6474349245531625, 0.13233776457818802, 0.6015251038894203, 0.12842010025943162, 0.6650660782032273, 0.729896318050316, 0.5838451394599409, 0.6038932677285569, 0.7486964038653956, 0.6027977688129897, 0.12904105617894945, 0.4970570551982538, 0.6338783710380922, 0.1311763787354625, 0.654584992183878, 0.13347577211066708, 0.5834411824896677, 0.6644167530846077, 0.5801341813173042, 0.6517131199065661, 0.5747597642597722, 0.5450781855850122, 0.6264774567937635, 0.5973118877387971, 0.5922806442473407, 0.6058774307227208, 0.5307442727477565, 0.7246104456113118, 0.7196658854680926, 0.6937459743116989, 0.6929901166276469, 0.6764640766292062, 0.6877991243894017, 0.7095399141637933, 0.7431058503302441, 0.7141560428367603, 0.5111644149668872, 0.12354566074955964, 0.13808117097245265, 0.16417221084055578, 0.5071824081123578, 0.2800834292901856, 0.15227794024262242, 0.2060402404781626, 0.43032493661029814, 0.49899493882997625, 0.5191627329886238, 0.4963062823251455, 0.519113603089481, 0.5317078511278232, 0.5517407313988787, 0.4828361527779109, 0.5174869321995552, 0.5274905608509252, 0.8230889833159312, 0.8274699863485728, 0.802146867581838, 0.7996643983062854, 0.8111585569300906, 0.8076406107590844, 0.8097513012737546, 0.813623972927586, 0.8012792400647224, 0.1543570750637966, 0.11202371696330105, 0.16342062676402602, 0.11988433445212554, 0.14401205285359286, 0.1247286910495965, 0.15758369478141976, 0.13863798943727346, 0.12049367302351399, 0.30905398943833184, 0.222262321964814, 0.21822555431598334, 0.1939458291385081, 0.4463802150027981, 0.2623165071326464, 0.388702947695691, 0.39316509265836086, 0.5641051301559905, 0.5559964566010401, 0.5794900739564952, 0.5592162804406543, 0.5334386158196133, 0.5634881082285331, 0.5764055782840386, 0.6324910585494613, 0.6113997600794387, 0.5576296411418729, 0.45822871852814717, 0.4632290950314738, 0.479100132440759, 0.46157879635820986, 0.43372108776671126, 0.4521519413829479, 0.4772208737947904, 0.47949489037925097, 0.4336084838960391, 0.21664866446744402, 0.21020796781048734, 0.20391775129587275, 0.2102933753324162, 0.21488300958379658, 0.22832035167615627, 0.19642172451381434, 0.19848521525915352, 0.24607068311088864, 0.22638461450377823, 0.21955924768255364, 0.22099698523152322, 0.2464495276526275, 0.2015667282287935, 0.20552757969012359, 0.20783549005238355, 0.21796835920185642, 0.21117204849685445, 0.17313527134759987, 0.8910706378954903, 0.15211568904684047, 0.8901467250816121, 0.19936136052459064, 0.1733889867309919, 0.14219936505632336, 0.15934671658200672, 0.21046538462018194, 0.8813767329362526, 0.8404360913909095, 0.8400914666175698, 0.2116666932825344, 0.16800672632850167, 0.8253102176423769, 0.16810764576068138, 0.21002542641758581, 0.8761756538100725, 0.21770435341516903, 0.19684888208430695, 0.20589586690149797, 0.18355856139871507, 0.20310480967848143, 0.18729717612734564, 0.18811472821621278, 0.1933542490469048, 0.1996172762222207, 0.08091856304424327, 0.08559185525502855, 0.09926782238828946, 0.07769180530251996, 0.08145907572888011, 0.09784577550374873, 0.08813891779584104, 0.09794845121770268, 0.09199369335995033]}, "mutation_prompt": null}
{"id": "f2ebafd9-18cc-457f-acde-f135f8bf6fb5", "solution": "import numpy as np\n\nclass DynamicAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(80, max(20, self.budget // 5))  # Adjusted population size for better adaptation\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.4  # Tweaked for enhanced exploration\n        self.CR_base = 0.85  # Adjusted to maintain diversity\n        self.adaptation_rate = 0.1  # Increased for rapid parameter adjustment\n        self.local_search_intensity = 0.2  # Intensified local search\n        self.mutation_prob = 0.8  # Increased probability for mutation flexibility\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        # Track the best solution found\n        best_index = np.argmin(fitness)\n        best_individual = population[best_index]\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            new_population = []\n            for i in range(self.population_size):\n                # Self-adaptive F and CR\n                F = np.clip(self.F_base + self.adaptation_rate * np.random.randn(), 0.1, 0.9)\n                CR = np.clip(self.CR_base + self.adaptation_rate * np.random.randn(), 0.1, 0.95)\n\n                # Probabilistic mutation strategy\n                if np.random.rand() < self.mutation_prob:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = population[indices]\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(self.population_size, 2, replace=False)\n                    a, b = population[indices]\n                    mutant = np.clip(best_individual + F * (a - b), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n\n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial)\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n                else:\n                    new_population.append(population[i])\n\n                if eval_count >= self.budget:\n                    break\n\n            population = np.array(new_population)\n\n            # Enhanced local search around the best solution\n            if eval_count < self.budget:\n                neighborhood_size = int(self.local_search_intensity * self.population_size)\n                local_neighbors = best_individual + np.random.normal(0, 0.03, (neighborhood_size, self.dim))\n                local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n                local_fitness = np.array([func(ind) for ind in local_neighbors])\n                eval_count += len(local_neighbors)\n\n                # Update best if any local neighbor is better\n                if np.min(local_fitness) < best_fitness:\n                    best_local_index = np.argmin(local_fitness)\n                    best_individual = local_neighbors[best_local_index]\n                    best_fitness = local_fitness[best_local_index]\n\n        # Return best found solution\n        return best_individual", "name": "DynamicAdaptiveDifferentialEvolution", "description": "A dynamic adaptive differential evolution algorithm with probabilistic mutation, improved local search, and accelerated parameter adaptation for faster convergence.", "configspace": "", "generation": 78, "fitness": 0.38551098388826993, "feedback": "The algorithm DynamicAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.25.", "error": "", "parent_id": "ec99e2dc-36dd-4b70-9fb0-6285f697cac9", "metadata": {"aucs": [0.7998402094847632, 0.8022491708569417, 0.8003890508755205, 0.8013961043396486, 0.7810612073803881, 0.7865299077193173, 0.7981484378216002, 0.797028834842436, 0.8064221082117157, 0.5779591572840947, 0.5564108010234957, 0.5785336997999659, 0.6040138300244096, 0.592344134035836, 0.603711277592468, 0.5938604630610601, 0.5742806784695403, 0.614110383677446, 0.20533258271212662, 0.18339007642601335, 0.14005726290284948, 0.1449723977131704, 0.2898056717096591, 0.12184844669320283, 0.192115128620152, 0.156186447815855, 0.14967114437824802, 0.15588510642997755, 0.13680217252579874, 0.13347273240712088, 0.13441044987573114, 0.14010737150732455, 0.13915399019296526, 0.12673470800465914, 0.1409680459069954, 0.12871702858576295, 0.9347846096779198, 0.9816178841822515, 0.9410028695537043, 0.9310779449031199, 0.9801030037948926, 0.9506556423203292, 0.9731352329078663, 0.9500148604270576, 0.972836147717029, 0.47931673652297146, 0.4603986869432142, 0.4263464303861241, 0.4454794521966867, 0.45778653440523454, 0.47554263296005883, 0.4614410108596261, 0.48894013355269794, 0.46593164902784934, 0.8255153015342126, 0.7464526643090776, 0.812787956998178, 0.2696300028895482, 0.727045864721328, 0.8952489534249881, 0.772087379849268, 0.7898717064118415, 0.7838920624987066, 0.35577258279649726, 0.3104944038627583, 0.2557965411433363, 0.5162924631209433, 0.3401479145258255, 0.31930946956040274, 0.37617532997399017, 0.31193051878682954, 0.12891674791462815, 0.12818534033216789, 0.33949100266118415, 0.4345752013208225, 0.3392511822369493, 0.3514572244678027, 0.5446895397132386, 0.37884241630891813, 0.3140395027366564, 0.12844151003463444, 0.1309243753536532, 0.3253694350944667, 0.37278749842972225, 0.259504821222973, 0.28835987481656944, 0.10379255176301083, 0.2682511355182694, 0.38313579440106715, 0.321139646219902, 0.5202363933235966, 0.5024282950086416, 0.4739903104098536, 0.4560489679667268, 0.4941754246581884, 0.45436508988916935, 0.49990748298562526, 0.49671210723936077, 0.503961399796441, 0.09733453867246933, 0.14713809341572648, 0.25524524755668365, 0.239291147412786, 0.08415346202370111, 0.08719147370330738, 0.12706154992586982, 0.10759387300721301, 0.317666766502679, 0.3094907988608181, 0.28234709261923596, 0.2940170009010764, 0.3099988340247273, 0.32647455863415764, 0.3117923103974378, 0.2674792172524283, 0.2554227714836169, 0.31361328820638124, 0.6792970954402578, 0.677207379548628, 0.6950030759579258, 0.655891726120932, 0.6666663430484581, 0.6487051989602656, 0.6476555239845592, 0.6712573436199396, 0.682374120330514, 0.13250916326767714, 0.13474997381689702, 0.12549784829518196, 0.14079038768949392, 0.1352102174321772, 0.11085597718594331, 0.11039913024945125, 0.13882609390397682, 0.10145453547513839, 0.21118515822270334, 0.16266003037109333, 0.17496681895103106, 0.19715356505227233, 0.17498066646693056, 0.2294714906907328, 0.37523384945934113, 0.1955147112001805, 0.1749051187699523, 0.43323606380403756, 0.412971694506561, 0.4492387023375004, 0.42670535012555066, 0.4527187354349772, 0.4374629678611406, 0.46168422422872013, 0.47900793793804497, 0.45445945449602587, 0.31419762606829116, 0.2521461119996411, 0.37928123741213804, 0.34450909552480913, 0.3329422837371817, 0.35326918170153254, 0.23733817038064164, 0.20931438661400015, 0.3116414698154817, 0.19108474600219705, 0.22341782573996438, 0.19884194229204832, 0.23097416698126583, 0.2048686561356582, 0.20833167502864192, 0.19694264151730367, 0.20973324384166914, 0.20467019661565466, 0.5947828675411144, 0.21668644066110476, 0.4378886802821427, 0.4227847262860226, 0.5559479860147716, 0.22343495335410313, 0.23908615510740094, 0.45545470145412614, 0.21285478733632213, 0.13049190487110573, 0.1841578326950326, 0.9096578038134744, 0.8249373186095561, 0.1979448419268901, 0.16614626147017897, 0.7793654685104758, 0.16567267298492594, 0.16801615630768885, 0.8038617312031652, 0.7528190596365995, 0.2042178467133362, 0.16471002042832894, 0.7073577739857884, 0.15649012066909052, 0.2049254522363615, 0.8152379941450061, 0.8021097008529912, 0.19910915376753002, 0.2009391769029757, 0.18902432458856588, 0.19731154817072116, 0.1861845559936225, 0.18850727989907223, 0.20537932424106342, 0.1901055729509521, 0.20334141428259456, 0.1064844795142551, 0.08656700256775052, 0.08627320121462123, 0.08869052089689955, 0.08685256156116428, 0.08654197795280272, 0.08659674251760807, 0.09419045972238671, 0.08074453629308642]}, "mutation_prompt": null}
{"id": "b674ad77-7864-42ee-af68-3ea88ea941ed", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolutionV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 10)  # Adjusted population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.6  # Fine-tuned for balanced exploration and exploitation\n        self.CR_base = 0.85  # Dynamically adjusted for exploration\n        self.adaptation_rate = 0.1  # Increased for more responsive adaptation\n        self.local_search_intensity = 0.2  # Enhanced local search intensity\n        self.mutation_prob = 0.6  # Balanced probability of mutation strategies\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        # Track the best solution found\n        best_index = np.argmin(fitness)\n        best_individual = population[best_index]\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Self-adaptive F and CR with dynamic adjustment\n                F = np.clip(self.F_base + self.adaptation_rate * np.random.randn(), 0.4, 0.9)\n                CR = np.clip(self.CR_base + (best_fitness / (1 + fitness[i])) * self.adaptation_rate * np.random.randn(), 0.6, 1)\n\n                # Choose mutation strategy based on a probability\n                if np.random.rand() < self.mutation_prob:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = population[indices]\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(self.population_size, 2, replace=False)\n                    a, b = population[indices]\n                    mutant = np.clip(best_individual + F * (a - b), self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n\n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection and elitism\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Strategic diversity introduction\n            if eval_count % (self.population_size // 2) == 0:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size // 5, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                eval_count += len(new_individuals)\n                replace_indices = np.argsort(fitness)[-len(new_individuals):]\n                for idx, new_idx in enumerate(replace_indices):\n                    population[new_idx] = new_individuals[idx]\n                    fitness[new_idx] = new_fitness[idx]\n\n            # Enhanced cooperative local search around the best individual\n            neighborhood_size = int(self.local_search_intensity * self.population_size)\n            local_neighbors = best_individual + np.random.normal(0, 0.05, (neighborhood_size, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n\n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_local_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_local_index]\n                best_fitness = local_fitness[best_local_index]\n\n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        return best_individual", "name": "EnhancedHybridAdaptiveDifferentialEvolutionV2", "description": "A novel hybrid adaptive differential evolution with strategic diversity introduction and dynamic crossover adaptation for accelerated convergence.", "configspace": "", "generation": 79, "fitness": 0.4132599523802475, "feedback": "The algorithm EnhancedHybridAdaptiveDifferentialEvolutionV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.26.", "error": "", "parent_id": "ec99e2dc-36dd-4b70-9fb0-6285f697cac9", "metadata": {"aucs": [0.8523107160215162, 0.832518477510855, 0.8361981208880163, 0.8348701451629397, 0.8484637369596095, 0.8532426448190272, 0.8539157048570827, 0.8400265202606468, 0.8390298693362961, 0.6596849710073716, 0.6963826577881302, 0.6751069406760587, 0.7066078169569341, 0.7106386590454783, 0.6961274830701727, 0.6817304201213421, 0.6770800590866449, 0.703447885629997, 0.1450893106884349, 0.14700571440494947, 0.31592565896835045, 0.3278565428408069, 0.30363615090296237, 0.3927219348911746, 0.1845902365702683, 0.38474693101103064, 0.2858027484068659, 0.415454154322338, 0.12098319579929429, 0.21117731738637635, 0.13816345548026987, 0.12970599893218682, 0.13572994142123485, 0.11692484096638367, 0.15038577732767422, 0.12407338333209861, 0.9805164739614092, 0.9725311210036607, 0.9744095597963924, 0.9689880286504395, 0.9804650140544652, 0.9783861509290439, 0.9810417147172535, 0.9773939974652841, 0.9802285525231718, 0.4827018988471631, 0.4745678765923321, 0.5307802950361573, 0.5541854671128448, 0.5255754689594854, 0.4893593130978694, 0.589434668446059, 0.5243816482146668, 0.5521548013130628, 0.8155051087987785, 0.8431556970851177, 0.7855255577565957, 0.278208640649405, 0.8517718811699374, 0.26997665685621275, 0.8491023363985893, 0.8064680065717723, 0.8087297525412325, 0.4756367997393388, 0.48579621670108986, 0.627775277876066, 0.49303701693033786, 0.1839170259877022, 0.2333194563431712, 0.5379870745232377, 0.3916158731106939, 0.5847598247149535, 0.1331894216231918, 0.4481646419207618, 0.43014735432638873, 0.13399542508297657, 0.5569934921865671, 0.6173448773848602, 0.13225105340072263, 0.5144609179468664, 0.5112952431761245, 0.3793880992758404, 0.3018420131184062, 0.15573574405491564, 0.49133261889176516, 0.4256364044228801, 0.44789205596144344, 0.4621718611999336, 0.4298863206619268, 0.46488610120529694, 0.6213940249342553, 0.5808207192524915, 0.576060191276226, 0.510899605409384, 0.5628525199808339, 0.5793745326444235, 0.5871898354881061, 0.549789692989692, 0.6236037934875307, 0.07740131389559535, 0.1879977136529457, 0.18902083035195538, 0.13237450507263748, 0.12509629484197282, 0.21792847216214084, 0.09954215188165072, 0.292899851733913, 0.11131594335120587, 0.37710206111764344, 0.3339596646132852, 0.3956100461754455, 0.36540265075953715, 0.4031144980151147, 0.3452667198143001, 0.3546208529451652, 0.3654564491375223, 0.32842248295277154, 0.7498086787016058, 0.7701234873384375, 0.7532049387556765, 0.7490641178209203, 0.7387815805222586, 0.7756624530761815, 0.7395700618793026, 0.740388640611892, 0.7476852707539128, 0.09667277507653893, 0.11451608028139437, 0.13164362807832386, 0.0997161558904136, 0.1262476305027247, 0.12492962337818048, 0.1114798425674991, 0.10925357903996935, 0.12868423867487688, 0.4549667161083677, 0.1848424067319684, 0.19920362505362577, 0.18836739223571974, 0.2038394718138844, 0.22260830977716928, 0.18206513439838734, 0.19261553892490912, 0.5148752821293445, 0.44360034739876697, 0.47363471423339676, 0.47190672338884265, 0.4685008862149286, 0.44596772313614896, 0.43265330645008615, 0.48508999309155265, 0.489879343180757, 0.5076389655330767, 0.3573425536811179, 0.40243631431623295, 0.3007463432043024, 0.3992728230620264, 0.3776842449292832, 0.3729910924937254, 0.39548848044746343, 0.3386061812137886, 0.317245707212259, 0.18961951699046642, 0.2091277796342077, 0.2016295972718397, 0.19155557510474508, 0.20461704816267678, 0.19190434011785218, 0.1955531208764505, 0.20826713107664152, 0.22480138475731115, 0.23261812863589415, 0.5878048454536786, 0.22924130541925292, 0.20709362308354973, 0.21752550998221454, 0.20019496729810704, 0.2169597537719169, 0.2169093159918507, 0.22214535982185868, 0.17267269758510684, 0.18570414373691602, 0.15311310632819763, 0.17879168026822312, 0.19867317742982282, 0.12424165495525963, 0.8581838013813401, 0.17429932786265523, 0.8002420142833764, 0.8139786613186661, 0.2102950589914766, 0.8271233789250261, 0.20683995773077912, 0.7569347427444301, 0.20254899860334885, 0.21435376222460112, 0.1678045804189271, 0.21228571290932174, 0.18178152421939908, 0.1961986738336643, 0.18605228184371947, 0.1893390522423951, 0.1810873642796088, 0.18863221722510148, 0.1778688199140761, 0.17417518388614917, 0.17848692117247156, 0.08734462020824685, 0.09470854399031592, 0.08214228432836213, 0.08892795655879182, 0.08165255192398546, 0.08582595486191003, 0.10592454445871735, 0.07908443638748264, 0.06988217723539725]}, "mutation_prompt": null}
{"id": "a8903665-0180-4141-ac43-8cc95f1ca894", "solution": "import numpy as np\n\nclass RefinedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(80, self.budget // 7)  # Further increased population size for enhanced exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.6  # Slightly higher for more aggressive mutation\n        self.CR_base = 0.8  # Reduced to balance exploration and exploitation\n        self.adaptation_rate = 0.1  # Further increased adaptation rate for dynamic response\n        self.local_search_intensity = 0.2  # Enhanced local search intensity\n        self.mutation_prob = 0.75  # Adjusted probability for better strategy mix\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        # Track the best solution found\n        best_index = np.argmin(fitness)\n        best_individual = population[best_index]\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Self-adaptive F and CR\n                F = np.clip(self.F_base + self.adaptation_rate * np.random.rand(), 0, 1)\n                CR = np.clip(self.CR_base + self.adaptation_rate * np.random.rand(), 0, 1)\n\n                # Choose mutation strategy based on a probability\n                if np.random.rand() < self.mutation_prob:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = population[indices]\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(self.population_size, 2, replace=False)\n                    a, b = population[indices]\n                    mutant = np.clip(best_individual + F * (a - b), self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n\n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection and elitism\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Enhanced cooperative local search around the best individual\n            neighborhood_size = int(self.local_search_intensity * self.population_size)\n            local_neighbors = best_individual + np.random.normal(0, 0.02, (neighborhood_size, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n\n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_local_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_local_index]\n                best_fitness = local_fitness[best_local_index]\n\n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        return best_individual", "name": "RefinedHybridAdaptiveDifferentialEvolution", "description": "A refined hybrid adaptive differential evolution with stochastic local search and dynamic parameter adjustment to enhance convergence speed and precision.", "configspace": "", "generation": 80, "fitness": 0.3070425670956272, "feedback": "The algorithm RefinedHybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.22.", "error": "", "parent_id": "ec99e2dc-36dd-4b70-9fb0-6285f697cac9", "metadata": {"aucs": [0.6939132099877081, 0.6480053752611445, 0.713806361086871, 0.7197482258823003, 0.7228277831035802, 0.7071056849161674, 0.7074630462053304, 0.6916616459093111, 0.7203462240624929, 0.40605604614200874, 0.4069235017299897, 0.4171947503262352, 0.4131819355254922, 0.4209142875159889, 0.4381141804646588, 0.4103421963145273, 0.43815874560383594, 0.40637826003225974, 0.12204124804553684, 0.14869401936168503, 0.12621821400145583, 0.11082147995396807, 0.10983546954275025, 0.16077987712592856, 0.1440072287996096, 0.11585836716548492, 0.1349940754980915, 0.11215298501111792, 0.12603807672316947, 0.1561888903212092, 0.12446944121951942, 0.1440268087136385, 0.1161714504910144, 0.10069591314070803, 0.1334965243375844, 0.11665283704532081, 0.9727646340363391, 0.9716122754100411, 0.9658871527741069, 0.9550885991462235, 0.938098465545765, 0.9818964353926726, 0.9751902993003186, 0.9819444650259516, 0.9602796439338208, 0.3353862459764324, 0.3363774631080594, 0.32924390476969734, 0.29199344025029983, 0.31030369420378334, 0.32795561068104406, 0.29990673135190815, 0.36317214386455465, 0.3292865842538373, 0.64009883189551, 0.7571933386665748, 0.5342619096679794, 0.6317921491322411, 0.5984575060553277, 0.6504899286503742, 0.6515737637182948, 0.5153369707681523, 0.6399911096743682, 0.2642543887426222, 0.23466200964399564, 0.1935789370741069, 0.24976725679546952, 0.2332920441090991, 0.23628455635915024, 0.27247710680890525, 0.1604244198208853, 0.23117319848402962, 0.2626810341054894, 0.2339937940104495, 0.19724709867663082, 0.2721256598463787, 0.23635585414505045, 0.2515258170321837, 0.28231222076867424, 0.23838484359156376, 0.12435401486531905, 0.13659822195076798, 0.09974063083915319, 0.1098203625314571, 0.12503694098712947, 0.1490034645592777, 0.11286748260890311, 0.13832598745515512, 0.14825569652201032, 0.12494264345781625, 0.24206553708245993, 0.23282965891073248, 0.2730542994071824, 0.23433122206330637, 0.23028247543453828, 0.21222650274207833, 0.29088484835162165, 0.2614296227654487, 0.30246694749841785, 0.03507446848835338, 0.08992839300447109, 0.05080595446636693, 0.06721896649178982, 0.029730795622420203, 0.09961351273883479, 0.07791843089805006, 0.04801144321267403, 0.04560122783251097, 0.18753995062263873, 0.17806052588310173, 0.19186048156986335, 0.19908981865464237, 0.20036454501194945, 0.1802084826208653, 0.18316798727014516, 0.1754963803341716, 0.17158127756915764, 0.52906805174462, 0.523992226257567, 0.5157850972823184, 0.5546818581073977, 0.5231691332827755, 0.5223865305617907, 0.5379379138719651, 0.5005862327936805, 0.51093512590069, 0.13737264440245978, 0.11155862224834434, 0.09013657974242284, 0.12507422456036021, 0.1509034842641913, 0.1576869799956243, 0.11221131007892604, 0.10334600160276308, 0.12059795059068423, 0.21506728787063256, 0.18662506547249902, 0.19161373826220773, 0.1855957374546564, 0.21687257037959407, 0.15311379578880446, 0.1670911250824345, 0.15873300348171082, 0.18961745113538442, 0.3143398136317538, 0.30588041562830626, 0.3159938614495801, 0.2970458689443398, 0.30896642923846684, 0.3033047726948548, 0.31689013789240594, 0.3317603282828503, 0.3100552297014034, 0.24561315222971003, 0.24243580312711654, 0.22179419152891955, 0.1986742077945346, 0.21848552199561466, 0.26622623723164074, 0.2410158812576576, 0.27543087434064606, 0.24659914372828484, 0.19790136692973048, 0.25783699704878504, 0.20662661694173856, 0.20924803354492538, 0.20829958598501808, 0.20838566786986146, 0.21000655929442624, 0.24383891714038242, 0.183367542064786, 0.18910773228853384, 0.2350891163077956, 0.1953208014029627, 0.2184511229017123, 0.20993439208900988, 0.22358262162036002, 0.18871065609193627, 0.19310399187605043, 0.21478628764471586, 0.1676594413499224, 0.15075812817590273, 0.6961975511722098, 0.693705140054172, 0.6457295826192275, 0.616054823368213, 0.6545221125759382, 0.16157167758857305, 0.4801631584591972, 0.630377194384442, 0.20486967851848148, 0.6769311006911729, 0.19930781474921133, 0.5393002250336096, 0.47903094316730277, 0.19448748535632, 0.603055470210581, 0.20516338858067007, 0.20645639563198215, 0.20512294241182516, 0.20346493130458265, 0.19495353098808277, 0.18804468494860416, 0.20903257664174257, 0.20248171788860736, 0.2204885850064564, 0.21708508979887653, 0.08702852080407353, 0.10684736617342949, 0.09035657650515239, 0.07933541540050215, 0.07581113795502659, 0.08879425485901171, 0.0906331291577066, 0.08207662278527572, 0.0872293702212199]}, "mutation_prompt": null}
{"id": "0b68327e-f83c-4e44-ac6e-ec5d81583545", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(60, self.budget // 8)  # Increased population size for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.5  # Adjusted for better exploration\n        self.CR_base = 0.9  # Increased to promote diversity\n        self.adaptation_rate = 0.05  # Increased adaptation rate for faster parameter adjustment\n        self.local_search_intensity = 0.15  # Increased local search intensity\n        self.mutation_prob = 0.7  # Probability of best or rand mutation\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        # Track the best solution found\n        best_index = np.argmin(fitness)\n        best_individual = population[best_index]\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Self-adaptive F and CR\n                F = np.clip(self.F_base + self.adaptation_rate * np.random.randn(), 0, 1)\n                CR = np.clip(self.CR_base + self.adaptation_rate * np.random.randn(), 0, 1)\n\n                # Choose mutation strategy based on a probability\n                if np.random.rand() < self.mutation_prob:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = population[indices]\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(self.population_size, 2, replace=False)\n                    a, b = population[indices]\n                    mutant = np.clip(best_individual + F * (a - b), self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n\n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection and elitism\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Enhanced cooperative local search around the best individual\n            neighborhood_size = int(self.local_search_intensity * self.population_size)\n            local_neighbors = best_individual + np.random.normal(0, 0.05, (neighborhood_size, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n\n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_local_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_local_index]\n                best_fitness = local_fitness[best_local_index]\n\n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        return best_individual", "name": "EnhancedHybridAdaptiveDifferentialEvolution", "description": "An enhanced hybrid adaptive differential evolution with increased local search adaptation and self-adaptive parameter tuning for rapid convergence.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ec99e2dc-36dd-4b70-9fb0-6285f697cac9", "metadata": {"aucs": [0.870997610873655, 0.876937349254849, 0.8628821214606534, 0.8781794510016624, 0.8772296468912268, 0.8694279318528029, 0.8756843654306008, 0.8726768563847991, 0.8598523983391932, 0.7477842665418626, 0.7505830115174412, 0.7273487673266275, 0.7189706160361924, 0.7360234772212559, 0.7429061262623435, 0.7438642610252675, 0.7560429492372163, 0.7467399915536672, 0.16512467121215724, 0.21203315310966409, 0.36256095224927487, 0.16722241556246864, 0.13854119174963164, 0.3333937421616463, 0.13516368482132823, 0.14772951992740369, 0.15692171902064456, 0.1564408366174984, 0.1353579238051421, 0.14422112246044583, 0.11484204674412235, 0.11348023152341102, 0.11138379259342324, 0.14321803866866378, 0.14280534633632092, 0.15859257836490215, 0.9799585186455763, 0.9503327389088712, 0.9724501584066897, 0.9571617360165604, 0.9859598542069689, 0.9718842750065484, 0.9760859368284891, 0.9848955505579943, 0.973482908644332, 0.6071385211387058, 0.6173177688242826, 0.6131191937365257, 0.6198810082831014, 0.6308754058002048, 0.6151046424041569, 0.5929618643435774, 0.6259420273296028, 0.6123827674671722, 0.8398909658399296, 0.8539463927768597, 0.8286288287924357, 0.8479342703448974, 0.88641759183554, 0.8924952684036396, 0.8466961223205589, 0.8895895616883716, 0.8513347130888925, 0.6474349245531625, 0.13233776457818802, 0.6015251038894203, 0.12842010025943162, 0.6650660782032273, 0.729896318050316, 0.5838451394599409, 0.6038932677285569, 0.7486964038653956, 0.6027977688129897, 0.12904105617894945, 0.4970570551982538, 0.6338783710380922, 0.1311763787354625, 0.654584992183878, 0.13347577211066708, 0.5834411824896677, 0.6644167530846077, 0.5801341813173042, 0.6517131199065661, 0.5747597642597722, 0.5450781855850122, 0.6264774567937635, 0.5973118877387971, 0.5922806442473407, 0.6058774307227208, 0.5307442727477565, 0.7246104456113118, 0.7196658854680926, 0.6937459743116989, 0.6929901166276469, 0.6764640766292062, 0.6877991243894017, 0.7095399141637933, 0.7431058503302441, 0.7141560428367603, 0.5111644149668872, 0.12354566074955964, 0.13808117097245265, 0.16417221084055578, 0.5071824081123578, 0.2800834292901856, 0.15227794024262242, 0.2060402404781626, 0.43032493661029814, 0.49899493882997625, 0.5191627329886238, 0.4963062823251455, 0.519113603089481, 0.5317078511278232, 0.5517407313988787, 0.4828361527779109, 0.5174869321995552, 0.5274905608509252, 0.8230889833159312, 0.8274699863485728, 0.802146867581838, 0.7996643983062854, 0.8111585569300906, 0.8076406107590844, 0.8097513012737546, 0.813623972927586, 0.8012792400647224, 0.1543570750637966, 0.11202371696330105, 0.16342062676402602, 0.11988433445212554, 0.14401205285359286, 0.1247286910495965, 0.15758369478141976, 0.13863798943727346, 0.12049367302351399, 0.30905398943833184, 0.222262321964814, 0.21822555431598334, 0.1939458291385081, 0.4463802150027981, 0.2623165071326464, 0.388702947695691, 0.39316509265836086, 0.5641051301559905, 0.5559964566010401, 0.5794900739564952, 0.5592162804406543, 0.5334386158196133, 0.5634881082285331, 0.5764055782840386, 0.6324910585494613, 0.6113997600794387, 0.5576296411418729, 0.45822871852814717, 0.4632290950314738, 0.479100132440759, 0.46157879635820986, 0.43372108776671126, 0.4521519413829479, 0.4772208737947904, 0.47949489037925097, 0.4336084838960391, 0.21664866446744402, 0.21020796781048734, 0.20391775129587275, 0.2102933753324162, 0.21488300958379658, 0.22832035167615627, 0.19642172451381434, 0.19848521525915352, 0.24607068311088864, 0.22638461450377823, 0.21955924768255364, 0.22099698523152322, 0.2464495276526275, 0.2015667282287935, 0.20552757969012359, 0.20783549005238355, 0.21796835920185642, 0.21117204849685445, 0.17313527134759987, 0.8910706378954903, 0.15211568904684047, 0.8901467250816121, 0.19936136052459064, 0.1733889867309919, 0.14219936505632336, 0.15934671658200672, 0.21046538462018194, 0.8813767329362526, 0.8404360913909095, 0.8400914666175698, 0.2116666932825344, 0.16800672632850167, 0.8253102176423769, 0.16810764576068138, 0.21002542641758581, 0.8761756538100725, 0.21770435341516903, 0.19684888208430695, 0.20589586690149797, 0.18355856139871507, 0.20310480967848143, 0.18729717612734564, 0.18811472821621278, 0.1933542490469048, 0.1996172762222207, 0.08091856304424327, 0.08559185525502855, 0.09926782238828946, 0.07769180530251996, 0.08145907572888011, 0.09784577550374873, 0.08813891779584104, 0.09794845121770268, 0.09199369335995033]}, "mutation_prompt": null}
{"id": "b2b913dc-4e9a-4d5c-8491-807a23bc89be", "solution": "import numpy as np\n\nclass ImprovedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = min(80, self.budget // 6)  # Dynamic population size for initial diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.6  # Increased for better exploration\n        self.CR_base = 0.8  # Slightly reduced to maintain exploration-exploitation balance\n        self.adaptation_rate = 0.1  # Higher adaptation rate for faster parameter adjustment\n        self.mutation_prob = 0.6  # Adjusted mutation probability\n        self.reduction_factor = 0.95  # Factor to reduce population size dynamically\n\n    def __call__(self, func):\n        # Initialize population\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        # Track the best solution found\n        best_index = np.argmin(fitness)\n        best_individual = population[best_index]\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(population_size):\n                # Self-adaptive F and CR\n                F = np.clip(self.F_base + self.adaptation_rate * np.random.randn(), 0, 1)\n                CR = np.clip(self.CR_base + self.adaptation_rate * np.random.randn(), 0, 1)\n\n                # Diverse mutation strategy choice\n                if np.random.rand() < self.mutation_prob:\n                    indices = np.random.choice(population_size, 4, replace=False)\n                    a, b, c, d = population[indices]\n                    mutant = np.clip(a + F * (b - c + d - b), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(population_size, 3, replace=False)\n                    a, b, c = population[indices]\n                    mutant = np.clip(best_individual + F * (a - b + c - a), self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n\n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection and elitism\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Dynamic population size adjustment\n            population_size = max(int(population_size * self.reduction_factor), 4)\n            population = population[:population_size]\n            fitness = fitness[:population_size]\n\n            # Reinitialize worst individuals to introduce diversity periodically\n            if eval_count < self.budget // 2 and eval_count % (10 * population_size) == 0:\n                worst_indices = np.argsort(fitness)[-int(0.1 * population_size):]\n                for idx in worst_indices:\n                    population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    fitness[idx] = func(population[idx])\n                    eval_count += 1\n\n        # Return best found solution\n        return best_individual", "name": "ImprovedAdaptiveDifferentialEvolution", "description": "An improved adaptive differential evolution integrating dynamic population resizing and a diverse mutation strategy for enhanced convergence speed.", "configspace": "", "generation": 82, "fitness": 0.24373616495432093, "feedback": "The algorithm ImprovedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.21.", "error": "", "parent_id": "ec99e2dc-36dd-4b70-9fb0-6285f697cac9", "metadata": {"aucs": [0.7109191691301282, 0.5370053077125054, 0.5593964080529195, 0.6461762633233317, 0.552280448184133, 0.6031289438562804, 0.581008998139239, 0.672502089348946, 0.5742910649167358, 0.3310145540081403, 0.28191682614215174, 0.25380520126463435, 0.31174568129334634, 0.1860483583028406, 0.2510113380082595, 0.29237636029305636, 0.17125381508161808, 0.2103693827064309, 0.12807391096354692, 0.11181109105937992, 0.12008920454196137, 0.0982546176544451, 0.11661710381822799, 0.14947590787002807, 0.11161855059678982, 0.10937011708862898, 0.112989672452113, 0.09517395359266434, 0.12522520798697678, 0.09836214061069948, 0.13728536123032375, 0.10557434737408566, 0.12375622010118548, 0.17173324013658897, 0.08915093255860451, 0.1209450436439834, 0.9697303052413343, 0.9822033975092412, 0.984315858701517, 0.9673570731617099, 0.9740971169553598, 0.9822612704439856, 0.9695106983484751, 0.9745335909363126, 0.9825847809694058, 0.22454960382721534, 0.2502661583199418, 0.19595688935868372, 0.20648285144598988, 0.271945263093027, 0.1695737409132354, 0.19160475511147745, 0.295217669058084, 0.23129950759702278, 0.3147070023290409, 0.27371278857859194, 0.20595154341983768, 0.31312598765562516, 0.8941014407208164, 0.2706100276270824, 0.3064289426450044, 0.34985472700269526, 0.23167258160127902, 0.197673819340088, 0.14297512953874814, 0.16169826783020147, 0.13698109173447026, 0.14518572360588367, 0.20845311681674916, 0.12743352218517667, 0.18191874906375138, 0.16173415343356246, 0.12957044981772847, 0.1191262643973574, 0.0526535751284537, 0.1544982192553772, 0.1936382177168443, 0.1539401623327039, 0.12877793445378793, 0.12159204234419396, 0.16212267335807262, 0.029985507068533535, 0.07872219779043754, 9.999999999998899e-05, 0.05650238641275118, 0.037818504830861244, 9.999999999998899e-05, 9.999999999998899e-05, 0.014729444040238238, 0.009880970138972045, 0.18366755317305605, 0.09831493617802955, 0.17691389371298993, 0.13702037423058244, 0.1158699743208339, 0.18736814219213782, 0.12810092392412986, 0.2707643726515434, 0.13685634485896792, 0.08987530771210328, 9.999999999998899e-05, 0.05784955095275235, 0.05236709793645511, 0.026835788495716995, 0.16314847741435368, 0.008632265291547037, 0.07079783031707543, 0.028982716114460683, 0.17968694883909297, 0.09633496404023556, 0.15925610859226946, 0.11628558651097465, 0.14592066885900234, 0.13341757735321003, 0.07679902355904944, 0.11091146260587648, 0.22310688384909716, 0.4153381226389916, 0.5210935103501768, 0.44109608833159375, 0.4976049619725783, 0.4744363989093001, 0.4396031322642555, 0.40836718552152884, 0.480312442301601, 0.4265463758481194, 0.10396099997494934, 0.08943052580585786, 0.10580716939303147, 0.10459428027353712, 0.09670963427493606, 0.1192158069934478, 0.11979906199252799, 0.10343202218252723, 0.10080005739443099, 0.15428250264494958, 0.11760946438043396, 0.1516799322147837, 0.14602385014979424, 0.20059026983859718, 0.19149019113928756, 0.17420200720002688, 0.18287302952296758, 0.18121179891990058, 0.316508553904868, 0.27109702956557313, 0.3432330530044647, 0.35096456930907516, 0.31450481873689573, 0.20151966921276399, 0.3014740552921389, 0.3583629685476135, 0.273514433642587, 0.2122406996951569, 0.22832389745281634, 0.19488064314378517, 0.20533356052836715, 0.25415509122667634, 0.2074534929153895, 0.25174470515137004, 0.25286214550301034, 0.23110485097022337, 0.20900599704194456, 0.19168490344535394, 0.20721837747238803, 0.22592564531461956, 0.2013964894471708, 0.25428468366659596, 0.21718163844869243, 0.22507730003486226, 0.21753180972670472, 0.19696333355508777, 0.1900534679962228, 0.1917923116129968, 0.20292259639179777, 0.20496203861642437, 0.20748128625745577, 0.21865463156773335, 0.22600937589848513, 0.18777073577700332, 0.5610234581531457, 0.2844704371023945, 0.18083239028935016, 0.5019281751081306, 0.19179319170136166, 0.44563618721496845, 0.14113170098409988, 0.1628590079119604, 0.3400560243402917, 0.3299484598721524, 0.22231293812576747, 0.3779924634309023, 0.163624206531772, 0.20316480500713574, 0.15217565176821535, 0.5410391821985687, 0.10400221774628404, 0.21106617088998514, 0.19051739279586022, 0.19738972920478304, 0.18339830539864288, 0.2065808316202179, 0.2069369604126785, 0.1845813281555212, 0.18590358986561473, 0.18732859752793896, 0.18443427240652233, 0.10167660994527938, 0.0919058712763503, 0.0974883503491566, 0.08417095152099596, 0.0819916172983629, 0.08598519555639395, 0.09221682411037724, 0.08346875509694052, 0.07416479476933668]}, "mutation_prompt": null}
{"id": "6b9cd121-17fc-4bd9-9dd2-1bd6cbc5a959", "solution": "import numpy as np\n\nclass AdvancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(80, self.budget // 6)  # Further increased population size for enhanced diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.7  # Adjusting for more balanced exploration-exploitation\n        self.CR_base = 0.8  # Adjusted to enhance convergence properties\n        self.adaptation_rate = 0.1  # Increased for more dynamic parameter adjustment\n        self.local_search_intensity = 0.2  # Further increased local search intensity\n        self.elitism_rate = 0.1  # Inclusion of elitism for retaining top performers\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        # Track the best solution found\n        best_index = np.argmin(fitness)\n        best_individual = population[best_index]\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Dynamic F and CR\n                F = np.clip(self.F_base + self.adaptation_rate * np.random.uniform(-1, 1), 0, 1)\n                CR = np.clip(self.CR_base + self.adaptation_rate * np.random.uniform(-1, 1), 0, 1)\n\n                # Choose mutation strategy based on a probability\n                if np.random.rand() < 0.5:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = population[indices]\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(self.population_size, 2, replace=False)\n                    a, b = population[indices]\n                    mutant = np.clip(best_individual + F * (a - b), self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n\n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection and elitism\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Intensified cooperative local search around the best individual\n            neighborhood_size = int(self.local_search_intensity * self.population_size)\n            local_neighbors = best_individual + np.random.normal(0, 0.03, (neighborhood_size, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n\n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_local_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_local_index]\n                best_fitness = local_fitness[best_local_index]\n\n            # Implement elitist learning\n            elite_indices = np.argsort(fitness)[:int(self.elitism_rate * self.population_size)]\n            elite_population = population[elite_indices]\n            population[:len(elite_population)] = elite_population\n            fitness[:len(elite_population)] = fitness[elite_indices]\n\n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        return best_individual", "name": "AdvancedHybridDifferentialEvolution", "description": "An advanced hybrid differential evolution employing adaptive differential weighting, a dynamic crossover strategy, and intensified local search with elitist learning for improved convergence.", "configspace": "", "generation": 83, "fitness": 0.3438149892135703, "feedback": "The algorithm AdvancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.24.", "error": "", "parent_id": "ec99e2dc-36dd-4b70-9fb0-6285f697cac9", "metadata": {"aucs": [0.766691590184017, 0.7454982134630812, 0.7666550973456128, 0.7631374411639191, 0.7985961582843175, 0.7746769073473299, 0.7661763833767952, 0.7835121375789162, 0.7603580670825432, 0.5119338554681963, 0.5389224550222468, 0.5232863375175767, 0.5273213946182933, 0.5195368191251801, 0.5342284443777638, 0.5096868319667573, 0.5478189360846146, 0.5644847094609866, 0.15042105087340785, 0.3785373956577157, 0.14762494452393382, 0.13723131476251604, 0.19774932588731908, 0.3961436914563745, 0.28909315837068483, 0.17912986044945356, 0.15748611137449975, 0.13447056337842245, 0.11461467792598556, 0.13683048781820362, 0.13763086912955658, 0.1375865698896469, 0.14254927294391329, 0.13385750944245445, 0.1196373846953811, 0.18985973977709547, 0.9833748137684253, 0.9872180425882818, 0.972464602027142, 0.974755154862477, 0.9873256519271626, 0.9880881318186562, 0.9832930617108144, 0.9820850226188823, 0.9770600203583127, 0.32235328101600536, 0.32659056383655427, 0.3439964714696494, 0.3604412542917116, 0.36755550725108366, 0.3579293440145007, 0.3648429773069435, 0.35130192882371325, 0.3398279181218551, 0.6519467785567457, 0.6881296682744528, 0.6602618562978997, 0.6571121440450477, 0.7114003521904434, 0.6898425118589562, 0.7250325258643802, 0.758589035426775, 0.7210638772836027, 0.2654867776168395, 0.12670145138697375, 0.32699174566163225, 0.3259389388985061, 0.24045518398693688, 0.36778748761628155, 0.29920109856731103, 0.29324141455224084, 0.3343498425184762, 0.2563607093566783, 0.32897332034432347, 0.29204888269374285, 0.30711107459006604, 0.2806664883130885, 0.2800675510364866, 0.31762853441647554, 0.32361638486122457, 0.3068772174407348, 0.10898175476918315, 0.15928030597118958, 0.1558813403207896, 0.14130770005245208, 0.12072807217004633, 0.10962865060221971, 0.149841567426113, 0.1633406498782466, 0.21166009519854156, 0.27497947939060297, 0.34538694732617437, 0.2980992542434747, 0.33084562364609216, 0.3226128000248536, 0.3093336458606517, 0.32602990482180993, 0.3363650644886388, 0.33335911050818556, 0.03884874463743748, 0.060239804330499136, 0.044476252139718286, 0.055617927084997465, 0.17544830039275605, 0.10283557311085789, 0.1064229662704691, 0.09541486544590283, 0.05743011148906485, 0.20081432340843852, 0.21026630238862576, 0.20748114929020578, 0.23536833520522027, 0.22198650557681798, 0.22743881829539514, 0.19543016289030857, 0.17283619075973822, 0.18985167282054605, 0.559779903815428, 0.6096804755917924, 0.5723586838278205, 0.5567247184276692, 0.5574823333331138, 0.5878851384565629, 0.588302510801636, 0.5668170691349197, 0.5521154820013994, 0.09765401430792275, 0.10592643943111402, 0.10789867882992898, 0.11174388592340123, 0.1297385806747603, 0.11496209288759529, 0.10194167780381136, 0.10979484725749156, 0.10911952497554978, 0.16639807567419307, 0.19973705686288945, 0.1722865792661218, 0.19528863732009571, 0.22105916619491395, 0.1651098728680216, 0.3228511724527551, 0.23171382830764264, 0.1805856046177351, 0.38104592265153325, 0.36367660042392924, 0.3329454288015016, 0.31484539034171166, 0.3591425057203014, 0.34618547353790174, 0.40093100030439044, 0.4202774280425903, 0.41878128149938876, 0.3135639646684174, 0.2706724874910036, 0.25592650781172566, 0.28237858082731815, 0.19291833471387554, 0.2561181601699779, 0.3358927313723863, 0.295024352570726, 0.24800072375446502, 0.2131425042697771, 0.18635514280302912, 0.19236063583985175, 0.21193786847491058, 0.20659935899628368, 0.18959016160208997, 0.20465391644542097, 0.19257290455913745, 0.20088760246233073, 0.21928251118688846, 0.19079835141684176, 0.23340418834234866, 0.4272795405901152, 0.46549900540302946, 0.21599092706505163, 0.20990193283762337, 0.1887532854301377, 0.18749944150871856, 0.15913624275431393, 0.18285772304986658, 0.8271001709799708, 0.1754072983932372, 0.20043575389439083, 0.8567517875411748, 0.749806896485745, 0.14349981279995683, 0.7515524918832859, 0.8168873754786813, 0.20837394318961155, 0.6304770522429902, 0.20316347030679804, 0.6504685514195052, 0.16409090014588035, 0.16507884636653503, 0.7776974146518061, 0.7004190261549149, 0.21680169051740317, 0.19075085084584087, 0.1941147079337826, 0.20290311562740815, 0.23062121946466807, 0.19704512800239105, 0.2225834534577893, 0.23504758493574807, 0.18362376576996342, 0.09793584918025466, 0.08889641461411102, 0.08736976319106837, 0.10227367878720994, 0.09723116479363858, 0.08015998284820669, 0.09207186709883664, 0.08053796884467357, 0.09484021996703418]}, "mutation_prompt": null}
{"id": "10e8b754-51ba-472b-a3a5-c33db41a3299", "solution": "import numpy as np\n\nclass RefinedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(60, self.budget // 8)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.5\n        self.CR_base = 0.9\n        self.adaptation_rate = 0.05\n        self.local_search_intensity = 0.2  # Increased local search intensity for better exploration\n        self.mutation_prob = 0.8  # Increased probability for rand mutation for diversity\n        self.dynamic_adaptation_threshold = 0.1  # Adaptive threshold for dynamic adjustments\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        best_index = np.argmin(fitness)\n        best_individual = population[best_index]\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                F = np.clip(self.F_base + self.adaptation_rate * np.random.randn(), 0, 1)\n                CR = np.clip(self.CR_base + self.adaptation_rate * np.random.randn(), 0, 1)\n\n                if np.random.rand() < self.mutation_prob:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = population[indices]\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(self.population_size, 2, replace=False)\n                    a, b = population[indices]\n                    mutant = np.clip(best_individual + F * (a - b), self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Dynamic fitness-based adaptation\n            fitness_std = np.std(fitness)\n            if fitness_std < self.dynamic_adaptation_threshold:\n                self.F_base = min(self.F_base + 0.1, 0.9)\n                self.CR_base = max(self.CR_base - 0.1, 0.1)\n            else:\n                self.F_base = max(self.F_base - 0.1, 0.1)\n                self.CR_base = min(self.CR_base + 0.1, 0.9)\n\n            neighborhood_size = int(self.local_search_intensity * self.population_size)\n            local_neighbors = best_individual + np.random.normal(0, 0.05, (neighborhood_size, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n\n            if np.min(local_fitness) < best_fitness:\n                best_local_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_local_index]\n                best_fitness = local_fitness[best_local_index]\n\n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        return best_individual", "name": "RefinedHybridAdaptiveDifferentialEvolution", "description": "A refined hybrid adaptive differential evolution incorporating dynamic fitness-based adaptation and enhanced local exploration for accelerated convergence.", "configspace": "", "generation": 84, "fitness": 0.2602303405047535, "feedback": "The algorithm RefinedHybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.23.", "error": "", "parent_id": "ec99e2dc-36dd-4b70-9fb0-6285f697cac9", "metadata": {"aucs": [0.7236296035850055, 0.6856650167562044, 0.6984814616371714, 0.6794488767632137, 0.764647317385897, 0.7131941556480275, 0.7776936725286656, 0.7031174125291642, 0.8255675293942701, 0.001647048443593091, 0.5005500186737203, 0.3761961901821854, 0.539984052242762, 0.06082546713347092, 9.999999999998899e-05, 0.05427017608582141, 0.37534518071192513, 0.02084866406021446, 0.09645482801372018, 0.11665556236267727, 0.09702315896564229, 0.13402792499472238, 0.11690337796892947, 0.11691945027653605, 0.11323647157140071, 0.11213059302230755, 0.11222556154606877, 0.06636992104061956, 0.0703766065804905, 0.11667200166962577, 0.14442595266241098, 0.16217409303009556, 0.11769739930512568, 0.10054882054336922, 0.0970027741044498, 0.10084390175702396, 0.9584139772098269, 0.7924652086593438, 0.9664070648947556, 0.9502918054633666, 0.9801582846712542, 0.9508025223572287, 0.98561283088554, 0.9843903389330464, 0.9596738861740721, 0.4114894396815647, 0.3523633893959015, 0.3707232949075172, 0.38975601146798067, 0.37560577240835535, 0.36004574387979127, 0.36225013441807163, 0.3884134368742441, 0.3408282254824644, 0.24307172652751885, 0.18963186525099063, 0.16601314042424198, 0.27803879291661937, 0.1732085195116706, 0.27626387399689845, 0.1524146149978456, 0.22575847648552194, 0.5203269111754354, 0.13614813553131044, 0.20303513607603085, 0.16081810913127503, 0.1089953158652901, 0.13142917668751708, 0.17970714012052924, 0.19703386371611076, 0.17605139170698514, 0.19191098266200357, 0.15703190825603452, 0.1916092167347282, 0.16056740740390518, 0.2692576694393297, 0.39472586441763413, 0.18815736964591456, 0.16892999614474924, 0.22600620170111585, 0.2008410308498404, 9.999999999998899e-05, 9.999999999998899e-05, 0.08129781663386781, 0.04343981529454999, 0.06660925246905658, 0.009299207738190707, 0.0018085396720783908, 0.041896238045321166, 0.017069240569409505, 0.13540969282769189, 0.06350155358661336, 0.10923366454666228, 0.09648290051617714, 0.12379679345323436, 0.05107017421296989, 0.09700924013276435, 0.11363641682038872, 0.0707089970628354, 0.05611235326559649, 0.1070134876515596, 0.16166635018559206, 0.2866981769976582, 0.2600842242343331, 0.29523887899533174, 0.11022316193053028, 0.14208256349960247, 0.13018201845611344, 0.15422901240045306, 0.09656070031664588, 0.03473552415498948, 0.29356999791276484, 0.04654510119050137, 0.1309362341632726, 0.0592543927971777, 0.09062860189195965, 0.22006646268857577, 0.5137454200697782, 0.47410532237486736, 0.5042649795483829, 0.47284773741383956, 0.4759586486395092, 0.5210661968310717, 0.4861129255584743, 0.44876002634815215, 0.4774845029196051, 0.11775723382107772, 0.11842674978067591, 0.11033894061115113, 0.05329221023935715, 0.06242153715616061, 0.08056395450047826, 0.06280584047876747, 0.07701922637010139, 0.10377645921178957, 0.2992402113235124, 0.23190591717024667, 0.22456689061574076, 0.19382795359110283, 0.2665366394866846, 0.23946251855458311, 0.2044649649801672, 0.1998916001299349, 0.31180370069452557, 0.23230715678471403, 0.1969110469886466, 0.31251636649634207, 0.3117891412902416, 0.2230936342574955, 0.22884347979588016, 0.19231487403538283, 0.3864262655146409, 0.20988583267123118, 0.12791790966714922, 0.15347494093428338, 0.3021625041004148, 0.16850867065322095, 0.23155855015549753, 0.2171039587982302, 0.1522246401811741, 0.268144155411152, 0.2243223311827479, 0.2274604166237819, 0.23864220731429098, 0.21115568388627404, 0.2727320540791667, 0.19653021505656154, 0.19868293623852795, 0.241693381349823, 0.21726868549159695, 0.22330090598204155, 0.1676117452042396, 0.1809349965103132, 0.18980352444806847, 0.16760308547013936, 0.20121756892086828, 0.18868261406493125, 0.1798606124056754, 0.18468193221925167, 0.2121483173919857, 0.14796166831324475, 0.8054803855323641, 0.15301901594490552, 0.8724731289553487, 0.2000110302201853, 0.16901887937936466, 0.14268685876302756, 0.15964723206151743, 0.7644331284996959, 0.4396297839409381, 0.21144425964704028, 0.1680720384166754, 0.2104430030392096, 0.48486362098308433, 0.16799798119112164, 0.16754021557952492, 0.43785643939824637, 0.7237270772212939, 0.21038447842283392, 0.21891176745808982, 0.20635677955871723, 0.2017950766394242, 0.20069055903201927, 0.2162005786073823, 0.20898596208010634, 0.2370478545187189, 0.22779207382195166, 0.10043729884872832, 0.10364056892282136, 0.10097237031600126, 0.110244371757931, 0.08072414834358643, 0.09235657324554303, 0.07837445651287833, 0.08370135272694201, 0.09499464649820677]}, "mutation_prompt": null}
{"id": "18db010e-e839-47af-91be-622407b025dc", "solution": "import numpy as np\n\nclass SynergisticAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(70, self.budget // 7)  # Adjusted population size for diversity and exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.6  # Slightly increased for stronger mutation\n        self.CR_base = 0.85  # Balanced crossover rate to maintain exploration\n        self.adaptation_rate = 0.07  # More aggressive adaptation rate\n        self.local_search_intensity = 0.2  # Enhanced local search intensity\n        self.mutation_prob = 0.65  # Balancing exploration and exploitation\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        # Track the best solution found\n        best_index = np.argmin(fitness)\n        best_individual = population[best_index]\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            dynamic_neighbors = max(1, int(self.population_size * 0.1))  # Dynamic neighborhood size\n            for i in range(self.population_size):\n                # Self-adaptive F and CR with dynamic adjustment\n                F = np.clip(self.F_base + self.adaptation_rate * np.random.randn(), 0, 1)\n                CR = np.clip(self.CR_base + self.adaptation_rate * np.random.randn(), 0, 1)\n\n                # Choose mutation strategy based on a probability\n                if np.random.rand() < self.mutation_prob:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = population[indices]\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(self.population_size, 2, replace=False)\n                    a, b = population[indices]\n                    mutant = np.clip(best_individual + F * (a - b), self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n\n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection and elitism\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Enhanced cooperative local search around the best individual\n            neighborhood_size = int(self.local_search_intensity * self.population_size)\n            local_neighbors = best_individual + np.random.normal(0, 0.05, (neighborhood_size, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n\n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_local_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_local_index]\n                best_fitness = local_fitness[best_local_index]\n\n            population[np.random.choice(dynamic_neighbors)] = best_individual\n            fitness[np.random.choice(dynamic_neighbors)] = best_fitness\n\n        # Return best found solution\n        return best_individual", "name": "SynergisticAdaptiveDifferentialEvolution", "description": "Synergistic Adaptive Differential Evolution with Dynamic Neighborhoods: An enhanced DE approach integrating dynamic neighborhoods and adaptive parameter strategies for accelerated convergence in optimization.", "configspace": "", "generation": 85, "fitness": 0.3860646007039628, "feedback": "The algorithm SynergisticAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.25.", "error": "", "parent_id": "ec99e2dc-36dd-4b70-9fb0-6285f697cac9", "metadata": {"aucs": [0.7982804825512843, 0.7863290330579162, 0.8034043707026025, 0.7998207917191613, 0.8128373418425169, 0.8035113363028817, 0.8062301863216607, 0.8039563336967461, 0.7952454907343182, 0.6116872792824023, 0.6120483297533172, 0.5874038941203257, 0.6153257668862528, 0.594930145980687, 0.6160547983597262, 0.6009636541788257, 0.6021763457581939, 0.6064249331404145, 0.13863291367202113, 0.16582918583245176, 0.15968287305362683, 0.1640933940259982, 0.13398879237537298, 0.13222516222602698, 0.1670565079646078, 0.1663494546504799, 0.1519398070291501, 0.13686855010177912, 0.12973125326525436, 0.1456151451069012, 0.13332960584043363, 0.1347057422511354, 0.17272922392415768, 0.11681029597009762, 0.1333737930616944, 0.1067293015902645, 0.9715732512738043, 0.9714425529022135, 0.9831687445247964, 0.978426814291682, 0.9838026429890114, 0.9824342909519783, 0.9839728617370963, 0.9812181824670148, 0.9747138935600178, 0.43645828537982534, 0.4524452390883268, 0.38641682777345254, 0.44017613319186844, 0.4326111093598297, 0.45018839620890594, 0.42500058297795085, 0.4482651604654303, 0.4635967174872502, 0.6838829889959004, 0.7444184688744927, 0.8238257329865781, 0.809623076081868, 0.8083764686488369, 0.8180180883587291, 0.7585587566033136, 0.7644188945078916, 0.8274606172991701, 0.12853296121167423, 0.12953790720989422, 0.11556627845427614, 0.40994323393267096, 0.46830938998531535, 0.5704454745605839, 0.5217894139979213, 0.5252647786678344, 0.44084894998219193, 0.4221283904433232, 0.12327833943452593, 0.4769777342027668, 0.44428896446711064, 0.4122856302923775, 0.4735407887029981, 0.13137400805154575, 0.38820637497480115, 0.502569636199834, 0.33774722953202185, 0.20237981195164567, 0.3863386238177787, 0.2916194040201511, 0.30434032868565775, 0.3365253706054002, 0.31818107381862804, 0.36155192626614174, 0.31552618098703566, 0.47116967064030624, 0.4676014661092631, 0.5010877270879114, 0.4984852353839099, 0.4616751499482058, 0.46710611298946036, 0.456732078310082, 0.49802734551330685, 0.4773673947576914, 0.06111202491756107, 0.08730226248811357, 0.25371622154300766, 0.19168491398566512, 0.243139418498026, 0.11914251554155486, 0.10718160381638042, 0.23280917079534347, 0.14139426525630483, 0.28208367519618227, 0.3231689590509239, 0.290942674917255, 0.29386030608880986, 0.3303325557253539, 0.2977834414077627, 0.2980341460765733, 0.29028264262774517, 0.2967130534837197, 0.6945853722645532, 0.6684500480609082, 0.7063518161805359, 0.6707357176791988, 0.6690011361860354, 0.6788266354226582, 0.6667334937304031, 0.6866753608588849, 0.6726645502907768, 0.11044234724773794, 0.10899207401163713, 0.14962840661393706, 0.10722166979512182, 0.15408432125940075, 0.09560314600141995, 0.10856762375822049, 0.11394547973648728, 0.11743880192697032, 0.20801878650227223, 0.26180858533533047, 0.4307456896927361, 0.21240704448137349, 0.5535175029091861, 0.1995101965070426, 0.2461115466094429, 0.38856161069411077, 0.4502355739765337, 0.42057494205742385, 0.3924843417538998, 0.43344238443819594, 0.4022383791017964, 0.410189253359032, 0.39300207750547866, 0.42542280420353484, 0.48328360009457916, 0.4072435442288541, 0.2500742880790482, 0.25059171228444743, 0.29188653494262384, 0.32594594743534133, 0.26791811075038663, 0.30022366582422466, 0.34236095366104013, 0.35023806915340716, 0.33034425010615054, 0.21353675912934833, 0.20979265561329363, 0.2081615992123962, 0.19837373787880275, 0.1893572901899776, 0.18833476791430026, 0.25361931932003456, 0.21751985172515365, 0.20349627778139323, 0.21963501992462164, 0.22006970691487382, 0.20183015430835782, 0.20007267557839892, 0.23927192525052232, 0.18775774637946518, 0.18867219012752978, 0.21253343737701524, 0.2179681063361496, 0.1469161709743355, 0.18452706875122693, 0.18470993263560154, 0.7475558152675786, 0.1982446954373791, 0.8109617655225916, 0.7492939120752291, 0.15979246469559039, 0.1247914998956059, 0.8146210720517049, 0.20621198628799042, 0.78654265908555, 0.2057434080070688, 0.7658793772225796, 0.731214528239833, 0.20882592038141246, 0.12788071748030672, 0.16319799543478253, 0.1836605851083254, 0.19830708543623032, 0.2071700291834161, 0.19596503155373035, 0.1975485756630263, 0.20273678132384998, 0.2642614978935217, 0.22968035692603705, 0.19439548527642014, 0.09479395007869007, 0.08258913501905585, 0.09911542705768028, 0.08308047817646036, 0.07751713423807594, 0.09827136467291109, 0.09668881414171826, 0.09572548506917389, 0.08335239618682022]}, "mutation_prompt": null}
{"id": "86821eed-7696-44d1-9178-0bcaa6b3ec18", "solution": "import numpy as np\n\nclass EnhancedDynamicPopulationDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = min(60, self.budget // 8)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.6  # Slightly increased to enhance exploration\n        self.CR_base = 0.85  # Reduced for tighter convergence\n        self.adaptation_rate = 0.07  # More adaptive rate for parameter tuning\n        self.local_search_intensity = 0.2  # Further increased for aggressive local search\n        self.mutation_prob = 0.5  # Balanced probability between mutation strategies\n\n    def __call__(self, func):\n        # Initialize dynamic population\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n\n        # Track the best solution found\n        best_index = np.argmin(fitness)\n        best_individual = population[best_index]\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            # Dynamic population adaptation\n            if eval_count > self.budget // 2:\n                population_size = max(20, population_size // 2)\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n            for i in range(population_size):\n                # Self-adaptive F and CR\n                F = np.clip(self.F_base + self.adaptation_rate * np.random.randn(), 0, 1)\n                CR = np.clip(self.CR_base + self.adaptation_rate * np.random.randn(), 0, 1)\n\n                if np.random.rand() < self.mutation_prob:\n                    indices = np.random.choice(population_size, 3, replace=False)\n                    a, b, c = population[indices]\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(best_individual + F * (population[(i+1) % population_size] - population[(i+2) % population_size]), self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n\n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection and elitism\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Enhanced cooperative local search around the best individual\n            neighborhood_size = int(self.local_search_intensity * population_size)\n            local_neighbors = best_individual + np.random.normal(0, 0.05, (neighborhood_size, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n\n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_local_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_local_index]\n                best_fitness = local_fitness[best_local_index]\n\n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        return best_individual", "name": "EnhancedDynamicPopulationDifferentialEvolution", "description": "Leverage dynamic population adaptation and dual mutation strategies for accelerated convergence in differential evolution.", "configspace": "", "generation": 86, "fitness": 0.4208761831260875, "feedback": "The algorithm EnhancedDynamicPopulationDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.26.", "error": "", "parent_id": "ec99e2dc-36dd-4b70-9fb0-6285f697cac9", "metadata": {"aucs": [0.8490311583501223, 0.8418432826753595, 0.8356128296189874, 0.8339160504301656, 0.849548664366619, 0.8611837022501535, 0.8337623869600402, 0.839110798285919, 0.8440000507225841, 0.6559235545000052, 0.676516427831062, 0.6767746541806985, 0.6761756727214094, 0.6817252300156434, 0.6648893164888676, 0.6628764738091162, 0.6592406111741114, 0.6959258742951351, 0.15210707832837156, 0.42913353779572727, 0.1669956372415904, 0.47526452951214204, 0.13000885768923576, 0.14202743221611258, 0.1510334965338057, 0.12876696769286755, 0.15407986359766201, 0.12425246476429597, 0.1274227479057195, 0.13913597694521962, 0.1248595839244504, 0.12451021210256208, 0.14683011663746892, 0.13017143452131918, 0.12047366440654039, 0.11515414624061782, 0.9782731339188036, 0.9914741304265706, 0.9809207595528604, 0.9677128799500847, 0.9766446904935069, 0.9792305469640317, 0.9809465312656327, 0.9784372459064995, 0.985274589784178, 0.5165017522984168, 0.5106481225996453, 0.45718115874026677, 0.5430268210577859, 0.5043306675624053, 0.521121092789038, 0.5109660634220408, 0.5261807391419637, 0.5350383888630472, 0.8105096914026897, 0.855150901127988, 0.7884672660133518, 0.8325030661604637, 0.8495927389113275, 0.7846377263624946, 0.8162797018513803, 0.8562284771497849, 0.816274240503128, 0.5517205376154001, 0.5985171972110233, 0.5834314613552796, 0.12307373736616412, 0.5625804148128991, 0.5809070096011197, 0.5861061289079548, 0.5517688287253193, 0.4948372600457267, 0.4412403739885604, 0.13070707245408775, 0.6349165572794342, 0.6228400574007633, 0.5991729279986284, 0.573340538977833, 0.5753507672322762, 0.6355254859167427, 0.5931578609332602, 0.3913190035391796, 0.5130265837710141, 0.45514247855115597, 0.4626903013294188, 0.5218997230957825, 0.31814372489569753, 0.47210892943380844, 0.5118783105268323, 0.5248071171410061, 0.4849112346105604, 0.5578892506983766, 0.5697458909594797, 0.5983466420261501, 0.6438520975190503, 0.4074137344539328, 0.5249495557808979, 0.538655838240335, 0.5977620396668097, 0.08122263403513608, 0.1477367670075579, 0.23024873178458682, 0.4008077107510659, 0.3076685076670099, 0.29514474435331317, 0.12248036063556034, 0.24577477820559057, 0.14406297909306287, 0.3151408163190864, 0.36754102939463795, 0.3474335763089018, 0.3683392483975062, 0.39980030477536, 0.457308909550595, 0.35480436239012825, 0.32575080133793255, 0.3625680115679184, 0.7596316737531067, 0.7269107809626857, 0.7553843568509562, 0.7557668616421087, 0.7589549624412282, 0.7492636606153551, 0.7627953914441277, 0.7706401030463843, 0.6324463638715554, 0.11607043028964292, 0.12757104790340457, 0.11568108445001468, 0.13902976575177706, 0.15518096374916945, 0.13293201170691593, 0.09867609666790322, 0.11218328805335509, 0.10062609295626457, 0.2227337902741099, 0.1836984202826022, 0.2097259761682122, 0.20121341203211507, 0.29086818606454534, 0.5347458802573024, 0.6038213008934235, 0.1644330570123248, 0.18536198994590392, 0.48557713963956506, 0.4415144592407567, 0.4095592125582185, 0.47717341899671306, 0.44457662663533914, 0.4867230233919181, 0.5908221503288031, 0.49784891165544254, 0.5005438630115261, 0.40688968555490945, 0.23057321874654768, 0.3643784228256549, 0.43613097494494346, 0.35145528238332113, 0.3342989010087444, 0.3046656960100591, 0.4169862586374071, 0.2654969156776622, 0.1995932860223747, 0.20999349188215977, 0.20347545989035876, 0.20199829884370513, 0.20528701155791307, 0.21725504928799377, 0.21406087509699023, 0.21986531219436312, 0.23735969830241443, 0.5373535263146723, 0.23512511230339794, 0.19886453911873536, 0.19536361113660727, 0.21474883770274544, 0.234553084843805, 0.6513020595378377, 0.19548338781976005, 0.23060539149332948, 0.16485385223754856, 0.1873099534696282, 0.16588648444905596, 0.1680173970806036, 0.19859345347101498, 0.19681227396220913, 0.14199150622172618, 0.16153131596784753, 0.17038861724646415, 0.8259123258223701, 0.20743086921349085, 0.8083042953440414, 0.2118305397061373, 0.208040033950032, 0.15418177949250622, 0.21107980272611204, 0.21220797702200367, 0.21099880881033195, 0.19073873392061014, 0.20114334490169272, 0.19032437479778197, 0.18141738981412836, 0.1930325140840674, 0.18440510951012368, 0.20905330301196579, 0.19823927018420728, 0.1985351750603852, 0.09065297493487412, 0.09433230880116372, 0.08749613369889053, 0.0858697599979088, 0.08279263116353908, 0.08703962186167369, 0.07914419750930934, 0.07604658229485117, 0.07836314122338806]}, "mutation_prompt": null}
{"id": "08329668-65ef-4dae-8a0a-f25d74f0097d", "solution": "import numpy as np\n\nclass AdvancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 6)  # Dynamic population size adjustment\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.4  # Fine-tuned for better balance\n        self.CR_base = 0.8  # Balanced crossover rate\n        self.adaptation_rate = 0.1  # Faster adaptation to changing search dynamics\n        self.local_search_intensity = 0.2  # Enhanced local search\n        self.mutation_prob = 0.5  # Balanced mutation strategy probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        # Track the best solution found\n        best_index = np.argmin(fitness)\n        best_individual = population[best_index]\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Self-adaptive F and CR\n                F = np.clip(self.F_base + self.adaptation_rate * np.random.randn(), 0, 1)\n                CR = np.clip(self.CR_base + self.adaptation_rate * np.random.randn(), 0, 1)\n\n                # Multi-phase mutation strategy\n                if np.random.rand() < self.mutation_prob:\n                    indices = np.random.choice(self.population_size, 4, replace=False)\n                    a, b, c, d = population[indices]\n                    mutant = np.clip(a + F * (b - c + d - a), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = population[indices]\n                    mutant = np.clip(best_individual + F * (a - b + c - best_individual), self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n\n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection and elitism\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Dynamic local search around the best individual\n            if np.random.rand() < self.local_search_intensity:\n                neighborhood_size = int(self.local_search_intensity * self.population_size)\n                local_neighbors = best_individual + np.random.normal(0, 0.03, (neighborhood_size, self.dim))\n                local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n                local_fitness = np.array([func(ind) for ind in local_neighbors])\n                eval_count += len(local_neighbors)\n\n                if np.min(local_fitness) < best_fitness:\n                    best_local_index = np.argmin(local_fitness)\n                    best_individual = local_neighbors[best_local_index]\n                    best_fitness = local_fitness[best_local_index]\n\n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        return best_individual", "name": "AdvancedAdaptiveDifferentialEvolution", "description": "An advanced adaptive differential evolution with dynamic population and multi-phase mutation for improved convergence speed.", "configspace": "", "generation": 87, "fitness": 0.3830664171370848, "feedback": "The algorithm AdvancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.28.", "error": "", "parent_id": "ec99e2dc-36dd-4b70-9fb0-6285f697cac9", "metadata": {"aucs": [0.9280778161579535, 0.9285724251535045, 0.9293472091143014, 0.9318783526543271, 0.9268880908958231, 0.9316670568845622, 0.9268100376055038, 0.9307626609265716, 0.9317912076357706, 0.3961857087452264, 0.8405841375709043, 0.8717721046822728, 0.8095647914009803, 0.8390995366793125, 0.12617448680861076, 0.2287778705324398, 0.8560297403852838, 0.2527112908108078, 0.14169653917812997, 0.1794495514118296, 0.6797740860656311, 0.12496339994574124, 0.14234089809956962, 0.14402823956762456, 0.15749386628778483, 0.12497330417672059, 0.15786381403305805, 0.11510828538106088, 0.11558989742375103, 0.13646927480159865, 0.115232100852529, 0.1106093791099041, 0.09020905393535927, 0.1292157318391579, 0.11478394379855872, 0.1317468831159797, 0.9240564634166387, 0.9260682119019861, 0.8985594379665522, 0.8989494365641861, 0.9069863747449343, 0.9496446757930639, 0.9199923056311002, 0.8995938702866231, 0.9470855922121599, 0.6376620519612408, 0.29535223296697366, 0.5123140508471342, 0.726849749887708, 0.42288259642951753, 0.4140427644639645, 0.3287404275278476, 0.6393067464243749, 0.35162262982354764, 0.9003994101718538, 0.9139837842001877, 0.2550603695108069, 0.9201818726555575, 0.9166488272077717, 0.9350647469175206, 0.2319037309568841, 0.2370174770756336, 0.8962431198731668, 0.19707676371567295, 0.13452186197579807, 0.20198113622876157, 0.3783168477962344, 0.1343635844879455, 0.16211327330958536, 0.20458440899577568, 0.19762297154139663, 0.1945235167955559, 0.1351228571048929, 0.5461675242440565, 0.15949508291467285, 0.3750520857045684, 0.21551758555394118, 0.18093922145448504, 0.34812293858063015, 0.21266913620268724, 0.14651755292954238, 0.4243435973479043, 0.1562937065321668, 0.15300191587537115, 0.2535186644173607, 0.06249284341961303, 0.05499199370349939, 0.10117895412874511, 0.22097345795945544, 0.18676397900757435, 0.5262603418055332, 0.303776880473691, 0.5558622962209494, 0.5598650743380844, 0.2640381939002532, 0.2599896620897989, 0.1858369211380584, 0.5216910350604469, 0.3028854127151238, 0.21313721321288503, 0.3112852341645578, 0.09756706405926785, 0.437729932382277, 0.2352387645935441, 0.25009780892927247, 0.1682285274878743, 0.12274924898458395, 0.35483083301061447, 0.4205061551812145, 0.3691335762876864, 0.29211686984505525, 0.4629697538177293, 0.316888427775895, 0.2249204253834195, 0.18688869226341542, 0.30694692680000035, 0.3065763455312528, 0.7085755176854782, 0.7043782172617314, 0.7133888997738381, 0.7330006745585288, 0.6347248005680078, 0.7191206796405953, 0.7827839714974206, 0.6399880728005184, 0.5714268372315028, 0.14106022457405265, 0.13419164224720248, 0.1156975173742969, 0.09188518582803695, 0.1422108287773317, 0.14613998225889935, 0.15656484754908362, 0.16928834339486498, 0.15558779583663496, 0.24893642681435024, 0.5030318081136542, 0.18470947530043447, 0.4534071052474511, 0.48519809705357075, 0.23486533185996072, 0.4285288086719189, 0.4546941226905459, 0.5246686972073715, 0.29282211249752477, 0.6658742589411542, 0.8161077829846416, 0.7949721818678002, 0.6254711856168294, 0.7954796248038364, 0.6069556597200267, 0.5839557382204572, 0.8098202666567927, 0.23964458957284696, 0.29621599013580713, 0.31070722331286693, 0.3361412431339922, 0.3280394399022566, 0.6615868925710078, 0.2691801400761419, 0.29659365078638267, 0.2446116789999433, 0.22163053380290154, 0.22233080912386616, 0.2725101929316349, 0.23648698081197594, 0.21214728121464954, 0.2696843302522599, 0.23389626735114066, 0.24140130854002195, 0.2239797243377064, 0.8450786358683979, 0.21154420155269282, 0.19678983021740137, 0.1932229207432713, 0.21148113354779252, 0.18689169356186108, 0.22257656425483696, 0.2497437627309701, 0.22257741059995717, 0.14776028716479617, 0.1875156062340595, 0.15359544591310825, 0.17744081412478063, 0.9278707603296656, 0.19971264103314101, 0.1424101983774817, 0.898491971831474, 0.2112557657836115, 0.9156072620971775, 0.21236626146994186, 0.07352205912965126, 0.21251260699432684, 0.16797992540002382, 0.16821022930758678, 0.21228281967127016, 0.1667957646907542, 0.7493722833404113, 0.18339665157670693, 0.1783881800474748, 0.18639739890595997, 0.18858649690580953, 0.18430578378379447, 0.20595845554325432, 0.1948043326176082, 0.18748084479264604, 0.18405586381069128, 0.09764819058408047, 0.10351570784416686, 0.12098155849560577, 0.09503413848103304, 0.09669021272212885, 0.0925260023630573, 0.08839227884006517, 0.10063470045083345, 0.1018986374237395]}, "mutation_prompt": null}
{"id": "2a674df6-6cb0-4eae-878e-097142bdca31", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolution_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(60, self.budget // 10)  # Adjusted for more focused exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.7  # Increased for more aggressive exploration\n        self.CR_base = 0.8  # Slightly decreased for better balance\n        self.adaptation_rate = 0.1  # Further increased for responsive adaptation\n        self.local_search_intensity = 0.2  # Enhanced local search for exploitation\n        self.mutation_prob = 0.6  # Tweaked for a balanced mutation strategy\n        self.dynamic_size = True  # Enable dynamic adjustment of population size\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        # Track the best solution found\n        best_index = np.argmin(fitness)\n        best_individual = population[best_index]\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Self-adaptive F and CR with enhanced random variation\n                F = np.clip(self.F_base + self.adaptation_rate * np.random.uniform(-0.5, 0.5), 0, 1)\n                CR = np.clip(self.CR_base + self.adaptation_rate * np.random.uniform(-0.5, 0.5), 0, 1)\n\n                # Choose mutation strategy based on a probability\n                if np.random.rand() < self.mutation_prob:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = population[indices]\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(self.population_size, 2, replace=False)\n                    a, b = population[indices]\n                    mutant = np.clip(best_individual + F * (a - b), self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n\n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection and elitism\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Enhanced cooperative local search around the best individual\n            neighborhood_size = int(self.local_search_intensity * self.population_size)\n            local_neighbors = best_individual + np.random.normal(0, 0.03, (neighborhood_size, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n\n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_local_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_local_index]\n                best_fitness = local_fitness[best_local_index]\n\n            # Dynamic adjustment of population size\n            if self.dynamic_size and eval_count < self.budget // 2:\n                self.population_size = min(self.population_size + 1, 100)\n                population = np.vstack((population, np.random.uniform(self.lower_bound, self.upper_bound, (1, self.dim))))\n                fitness = np.append(fitness, [func(population[-1])])\n                eval_count += 1\n\n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        return best_individual", "name": "EnhancedHybridAdaptiveDifferentialEvolution_v2", "description": "An enhanced hybrid adaptive differential evolution with dynamic population size adjustment, adaptive control parameters, and improved exploration-exploitation balance for faster convergence.", "configspace": "", "generation": 88, "fitness": 0.27681338181101, "feedback": "The algorithm EnhancedHybridAdaptiveDifferentialEvolution_v2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "ec99e2dc-36dd-4b70-9fb0-6285f697cac9", "metadata": {"aucs": [0.6658108835437281, 0.6552440715539529, 0.6736706508575641, 0.6858737086333486, 0.7035122146557895, 0.6775235682700973, 0.692387160244432, 0.6704660703476097, 0.6846313540074218, 0.36253289147096635, 0.35352840628193416, 0.3451974742500774, 0.32993172085429057, 0.36370289820691737, 0.387222009314237, 0.32537366531481704, 0.34885628110089406, 0.35720094237344713, 0.13795545666985343, 0.13005885597322553, 0.12347773125140393, 0.1389256584941313, 0.11272730736540448, 0.16672911767632992, 0.12094778103386084, 0.11854424588570744, 0.12761121745064608, 0.1180462365259991, 0.10348455676076285, 0.1364972662101811, 0.10870382618125363, 0.13365502460754908, 0.11093560645701961, 0.11280880727660292, 0.10738956597046512, 0.1497167327155826, 0.9773147332593172, 0.9621601283745584, 0.9801837522994028, 0.9851898323030699, 0.9922155769235025, 0.9810880195063857, 0.9851831967979437, 0.9812219475332199, 0.9777467777417639, 0.274445838721324, 0.3194716873574889, 0.31287151786791, 0.29990133030327626, 0.29635526872140894, 0.29766019855093606, 0.31000204872553827, 0.28275385132320885, 0.29308275453420995, 0.45853207025339815, 0.5361677043628733, 0.42953154009438466, 0.6071774167764303, 0.5655509665646132, 0.566915215070048, 0.8004783375558503, 0.5385966942319018, 0.5381984351357068, 0.16562048108749772, 0.1107381695862063, 0.19351253980629612, 0.21900975472919926, 0.22604451143348103, 0.16498528316342087, 0.20943578701072052, 0.19530629843376812, 0.2029688169819367, 0.14066345447054396, 0.15499139460806255, 0.20545545169417012, 0.2456454036945963, 0.22489130804341972, 0.12529432149563358, 0.21330166808861717, 0.17914456416381086, 0.2112610966598083, 0.05044144496526226, 0.047961477784483786, 0.07680082200722804, 0.07546091837085256, 0.04155454041702911, 0.039203202638080414, 0.0760808458997646, 0.058852020835362784, 0.055185167417595604, 0.15426868936617388, 0.1851659801014638, 0.17681510036358705, 0.18055283460254323, 0.18631138795530222, 0.157574757140036, 0.21904686557875053, 0.1857429139133565, 0.17105117458866026, 0.009964753803419435, 0.015004429812254472, 0.021950238409534917, 0.020290158461568564, 0.024910463858780152, 0.022942406837903384, 0.04697188812624642, 0.03541370111218334, 0.026573529308109523, 0.15175387842175292, 0.17716633931121284, 0.14889985933244876, 0.13902738201555276, 0.15229195527242023, 0.14438989787504652, 0.1411642650835585, 0.15682436670314814, 0.15855768494925704, 0.4802539691261716, 0.4586484911685802, 0.48531807937996774, 0.49883509750219934, 0.49492616018419955, 0.4904086507576524, 0.5129273192718742, 0.5039291418958767, 0.500450485211742, 0.10854579347687743, 0.11543789274544247, 0.15115034041158937, 0.12298477294330701, 0.11917934363249827, 0.10538435050056483, 0.11437488089202685, 0.099083602222932, 0.12092319232837712, 0.3632441216686316, 0.1815600723656332, 0.16769244832872043, 0.19077856392381354, 0.18493754176220778, 0.14395556415399402, 0.18885807898026596, 0.1348114336382703, 0.14476372829403805, 0.3094934600513657, 0.29703961992613914, 0.3141249677177457, 0.28889958321283005, 0.2907204587685811, 0.26730192376403006, 0.31070159066426184, 0.306095163619582, 0.3247927089183713, 0.2216413086723138, 0.1998204843889051, 0.2377484705206946, 0.21932289881927614, 0.223240004114707, 0.24949034319475627, 0.21062597675528139, 0.23669428087430067, 0.24227655457883335, 0.19080406503893166, 0.22795661582421178, 0.20049607038017525, 0.19777175785719714, 0.17864790529018315, 0.2099049937901566, 0.19685416825430735, 0.18494656450431124, 0.20309787543761781, 0.1937506000994762, 0.18840112031336342, 0.197377163622399, 0.2083239353460905, 0.2235719189630857, 0.20560875560461767, 0.2380920619099094, 0.2072055591539409, 0.19534269877011234, 0.7486179952761742, 0.5129990530971198, 0.16877080496356445, 0.721118685747113, 0.1940806510757067, 0.6012153908047446, 0.17035434491421653, 0.16928999968084957, 0.17193783418768593, 0.4856100805778122, 0.588908179953494, 0.21203982331666382, 0.1256918357485589, 0.1637617227575241, 0.4247185534206799, 0.20612524257289533, 0.21103306098725294, 0.6343087576315198, 0.18711475459066873, 0.19896916632001904, 0.20651126914818663, 0.1981544462989504, 0.19446492083244815, 0.18210738878556387, 0.1885303080027032, 0.18795109940277333, 0.1966005300458581, 0.0862452780443127, 0.08469936434050829, 0.09047418272811591, 0.08150132501574625, 0.08045538728838941, 0.08480624424124306, 0.07514686404994486, 0.07956217463027337, 0.08495155074106153]}, "mutation_prompt": null}
{"id": "4af810a1-cb2d-425b-a8c9-eff9698f72d5", "solution": "import numpy as np\n\nclass RefinedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(80, self.budget // 8)  # Slightly increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.6  # Adjusted for balanced exploration and exploitation\n        self.CR_base = 0.85  # Slightly decreased to enhance adaptation\n        self.adaptation_rate = 0.07  # Increased adaptation rate for quicker parameter tuning\n        self.local_search_intensity = 0.2  # Increased local search intensity\n        self.mutation_prob = 0.75  # Higher probability for adaptive mutation strategy\n        self.resizing_frequency = 0.1  # Frequency to adjust population size\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        # Track the best solution found\n        best_index = np.argmin(fitness)\n        best_individual = population[best_index]\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Self-adaptive F and CR\n                F = np.clip(self.F_base + self.adaptation_rate * np.random.randn(), 0, 1)\n                CR = np.clip(self.CR_base + self.adaptation_rate * np.random.randn(), 0, 1)\n\n                # Choose mutation strategy based on a probability\n                if np.random.rand() < self.mutation_prob:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = population[indices]\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(self.population_size, 2, replace=False)\n                    a, b = population[indices]\n                    mutant = np.clip(best_individual + F * (a - b), self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n\n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection and elitism\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Adaptive population resizing\n            if eval_count / self.budget % self.resizing_frequency < self.resizing_frequency / 2:\n                new_size = int(self.population_size * 1.1)\n                if new_size <= self.budget - eval_count:\n                    new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (new_size - self.population_size, self.dim))\n                    new_fitness = np.array([func(ind) for ind in new_individuals])\n                    population = np.vstack((population, new_individuals))\n                    fitness = np.hstack((fitness, new_fitness))\n                    eval_count += new_individuals.shape[0]\n\n            # Intensified local search around the best individual\n            neighborhood_size = int(self.local_search_intensity * self.population_size)\n            local_neighbors = best_individual + np.random.normal(0, 0.05, (neighborhood_size, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n\n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_local_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_local_index]\n                best_fitness = local_fitness[best_local_index]\n\n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        return best_individual", "name": "RefinedHybridAdaptiveDifferentialEvolution", "description": "A refined hybrid adaptive differential evolution with enhanced parameter tuning, adaptive population resizing, and intensified local search for accelerated convergence.", "configspace": "", "generation": 89, "fitness": 0.32353917695249984, "feedback": "The algorithm RefinedHybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.23.", "error": "", "parent_id": "ec99e2dc-36dd-4b70-9fb0-6285f697cac9", "metadata": {"aucs": [0.7282637788835702, 0.7001021396789824, 0.7212591754894553, 0.7489804360865131, 0.7204328904350669, 0.7193010175864152, 0.7187567251548572, 0.707333640326306, 0.7255045886977162, 0.48842009490402716, 0.47082384169825386, 0.482584517968607, 0.4534798228292499, 0.4636997151504183, 0.4602242436868178, 0.49860151285546594, 0.46917356859365067, 0.4799641701462689, 0.11746237179407382, 0.13233177412201602, 0.13456872368207184, 0.15109807360249816, 0.1280690748812673, 0.13621248206031522, 0.12447559405454389, 0.1379528041586635, 0.1487531210268901, 0.12045835382001746, 0.13256678639774944, 0.10481141910504643, 0.14523002728065582, 0.11693819187342014, 0.10270843958464304, 0.13009953235054905, 0.1203832266279884, 0.09583112152202444, 0.9544570479117666, 0.9628931786294473, 0.9590539467198151, 0.9564030160987609, 0.9593946630615449, 0.9555355364648486, 0.9684395811680463, 0.9799405646288823, 0.939251761641707, 0.3263120433735084, 0.36717669048453616, 0.29620615835142394, 0.3286491455862035, 0.33089928311584704, 0.31780015578691734, 0.3366450699287371, 0.3381284021546729, 0.3315675454832817, 0.6145779141400218, 0.6999446543629974, 0.6314676577876752, 0.70247582692312, 0.6942498452440231, 0.7066409414153496, 0.6905679835642785, 0.6307445932053697, 0.7127718054701719, 0.3110880206077923, 0.12101910701502461, 0.24436852049809432, 0.3252274460710499, 0.3079332523301094, 0.22727917453701763, 0.30102300304213825, 0.27734009751299094, 0.30046133404057973, 0.11981064548164089, 0.17887908098638472, 0.282972534770627, 0.23522137075366545, 0.2513597465903976, 0.2430860450731972, 0.33498896862860794, 0.3049847117116321, 0.3287073385561805, 0.20150329572778647, 0.18712129279877532, 0.16550424516875462, 0.13935369947880794, 0.1478453472731066, 0.1588082859577058, 0.18289771508997155, 0.18944281940808227, 0.16058410571241766, 0.3104414722723964, 0.28818671988827615, 0.27911679324699956, 0.25552278748299173, 0.3072528981514572, 0.2695897041700458, 0.3338870013357783, 0.32325585154275127, 0.3269255817288097, 0.036568729853156734, 0.04423465569799334, 0.10589215015663689, 0.12460191706433887, 0.0838400700726959, 0.12407413687705537, 0.1213688288389021, 0.047802612111049525, 0.06628254079268536, 0.20956070209211863, 0.19107205885671097, 0.20295441468330833, 0.21986072628225917, 0.21392337679567497, 0.19918415240468534, 0.18594626520251967, 0.1713008059955713, 0.20826484617581686, 0.5553532758200526, 0.5552436299709659, 0.5733919729553255, 0.5974021617256029, 0.5465062058289034, 0.5556230962671569, 0.5837263333781169, 0.5385597414254863, 0.5966781730796719, 0.11349197443326542, 0.10040743050134893, 0.11128474295885371, 0.12988334332653628, 0.08955671689324995, 0.09402198870683642, 0.13998417808313712, 0.10823095184010378, 0.1388629631575643, 0.19460074221177293, 0.20167819876971627, 0.17856205793171898, 0.20793811267796392, 0.1576032123351695, 0.23492036084228285, 0.25446612171511496, 0.18586491871799604, 0.14662672109487884, 0.3189659879461417, 0.3052038120052495, 0.3445887338682474, 0.31438800169452885, 0.3218998033501309, 0.31672388380770267, 0.3792298878915098, 0.3694247383641319, 0.3344623314591868, 0.2269638299475727, 0.2405226650482859, 0.2831399751584692, 0.23874583555739004, 0.2280190095680984, 0.2747834495563851, 0.2552820530640689, 0.26631143913264377, 0.2511197660532495, 0.19859565742912333, 0.19800090048355834, 0.20408008091348662, 0.21346608504640585, 0.19869684787573383, 0.19701811495896404, 0.17878605436554262, 0.19141408301278207, 0.20831588145469637, 0.20032469901347427, 0.2149190879772871, 0.25921475960117546, 0.19328222210768942, 0.36906425839332324, 0.20163007392081522, 0.19069392285588416, 0.20122483779556655, 0.20016162275297178, 0.7096221790669638, 0.18144416121239493, 0.7976089256876564, 0.6766478426602127, 0.19704144095664455, 0.5152248487578877, 0.16282288344264684, 0.15971012750010227, 0.7389687871083546, 0.6902622980553217, 0.167394137819183, 0.6606745809369985, 0.1605835540954864, 0.6702526786723043, 0.20601045846901256, 0.2134056711385659, 0.6257471212366639, 0.6810195109984023, 0.19669140640749105, 0.19177573039247087, 0.1794346389740682, 0.20910746903117838, 0.204563945094009, 0.18774988196606912, 0.19215182934249386, 0.18570834056266705, 0.18275064737396207, 0.09015652573103194, 0.07180735385529058, 0.08867463174836099, 0.08350426359859009, 0.096817599267784, 0.07915273672720124, 0.09425024036084628, 0.07886932829412086, 0.06894570970298919]}, "mutation_prompt": null}
{"id": "7afea0e1-9efa-40d3-b2ef-c8b512cc88be", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(80, self.budget // 6)  # Increased population size for better coverage\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.6  # Adjusted for improved balance between exploration and exploitation\n        self.CR_base = 0.8  # Adjusted for a better trade-off in crossover\n        self.adaptation_rate = 0.1  # Higher adaptation rate for more dynamic parameter tuning\n        self.local_search_intensity = 0.2  # Increased local search intensity for thorough exploitation\n        self.mutation_prob = 0.6  # Adjusted probability for mutation strategy diversification\n        self.exploration_weight = 0.1  # New parameter to encourage exploration\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        # Track the best solution found\n        best_index = np.argmin(fitness)\n        best_individual = population[best_index]\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Self-adaptive F and CR\n                F = np.clip(self.F_base + self.adaptation_rate * np.random.randn(), 0, 1)\n                CR = np.clip(self.CR_base + self.adaptation_rate * np.random.randn(), 0, 1)\n\n                # Choose mutation strategy based on a probability\n                if np.random.rand() < self.mutation_prob:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = population[indices]\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(self.population_size, 2, replace=False)\n                    a, b = population[indices]\n                    mutant = np.clip(best_individual + F * (a - b), self.lower_bound, self.upper_bound)\n\n                # Exploration component\n                exploration = self.exploration_weight * np.random.randn(self.dim)\n                trial = np.clip(np.where(np.random.rand(self.dim) < CR, mutant, population[i]) + exploration,\n                                self.lower_bound, self.upper_bound)\n\n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection and elitism\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Enhanced cooperative local search around the best individual\n            neighborhood_size = int(self.local_search_intensity * self.population_size)\n            local_neighbors = best_individual + np.random.normal(0, 0.05, (neighborhood_size, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n\n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_local_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_local_index]\n                best_fitness = local_fitness[best_local_index]\n\n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        return best_individual", "name": "EnhancedHybridAdaptiveDifferentialEvolution", "description": "An adaptive hybrid differential evolution with enhanced local exploration and dynamic parameter adaptation for faster convergence.", "configspace": "", "generation": 90, "fitness": 0.25533896260926436, "feedback": "The algorithm EnhancedHybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "ec99e2dc-36dd-4b70-9fb0-6285f697cac9", "metadata": {"aucs": [0.49285054001988204, 0.5057788184121362, 0.47497227458678504, 0.5036038320832583, 0.4929472977458288, 0.47771957372328877, 0.5042429699468176, 0.4670587752125924, 0.4720402456082228, 0.05479577625565957, 0.057601525855564994, 0.07866235690591106, 0.06795560781435339, 0.042662480665961455, 0.04793666411481112, 0.06288621608376577, 0.07097757779579461, 0.03752325583001148, 0.10273569377333336, 0.11687747116749092, 0.13054704847365683, 0.1051208769505978, 0.0990096397430269, 0.1313668382295211, 0.1226324324604906, 0.1283342862623167, 0.14572626212486772, 0.11070404061711092, 0.1223209200860017, 0.09477322913533659, 0.12555401945043287, 0.12791200942394754, 0.10582347965113437, 0.10485579817943691, 0.10538939548083248, 0.0971329986977647, 0.9639181072495634, 0.951288328343197, 0.9559809524891141, 0.9726413715043023, 0.9779040884171261, 0.9468612949153961, 0.9547411032085369, 0.955184296997617, 0.9538657522498255, 0.3152825189669055, 0.3155049679950289, 0.3346511196615424, 0.3313977463401694, 0.33261224211565943, 0.31389677603888955, 0.3263444331134733, 0.3287556774092085, 0.31855334325323537, 0.7177084801885432, 0.37340664066010465, 0.5666458657339777, 0.7092456978398832, 0.5478513828482416, 0.3126261636796822, 0.757892013320218, 0.36757734064150804, 0.8122945320576087, 0.2512014198951179, 0.15387560290077362, 0.1942278612258279, 0.16900877022551408, 0.12985575472769195, 0.16451996497345822, 0.16697899603896116, 0.1580981920961796, 0.12878445339283484, 0.12225057189776323, 0.16291157798035527, 0.17071631677383448, 0.20049903823444148, 0.18875898090148935, 0.19314785930239042, 0.23840889485701422, 0.20320179303559982, 0.16215691158431023, 0.005999011452503922, 0.02719787015968922, 0.05031314893193617, 0.03071105194008339, 0.03220187053677759, 0.04479141017015664, 0.013647607664021733, 0.1039860657197822, 0.04188979933946613, 0.1060072551172272, 0.14659011494351604, 0.11814232900712063, 0.10667531986394352, 0.1282525629145328, 0.10231171008900874, 0.14363734569477693, 0.11553435545903412, 0.12717287081135742, 0.0007614039215153579, 9.999999999998899e-05, 0.0003423704219632784, 9.999999999998899e-05, 0.006568591571536442, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11525756066864212, 0.11308728375968335, 0.10576461672603232, 0.135253555491463, 0.13827244959448182, 0.1298538946010136, 0.11698156619479483, 0.11027259451423455, 0.10585995394453496, 0.43719476976033267, 0.44664601517521096, 0.43918016032364504, 0.42800265536235205, 0.4476469899405148, 0.4398902879880269, 0.4351679698427955, 0.4405788445960769, 0.4225603052342406, 0.10020847626771245, 0.10956102402024082, 0.12526948822887551, 0.11961668537450809, 0.11693754471386242, 0.14307572210568797, 0.10138060080835043, 0.11794680939127788, 0.14561005566017737, 0.1799210444821029, 0.32434788344020027, 0.18805946113261873, 0.18571543142386282, 0.20337347404944794, 0.2602800261637416, 0.23738341777511396, 0.18531468276437824, 0.2809633346035204, 0.3158241900463532, 0.2886457410743767, 0.2730834441423934, 0.2959499187428011, 0.29961082230908465, 0.2950692067993531, 0.30272645051779423, 0.29877138987055607, 0.2977630373865766, 0.2510597687831432, 0.20720700398435288, 0.2369398504420761, 0.24419216384486786, 0.19003288249912842, 0.1896536342217925, 0.22738770179883028, 0.2131780883134179, 0.17577959578889624, 0.21055240461214775, 0.2256572495221042, 0.19323023796122885, 0.20269803274900455, 0.20772025310241127, 0.22234154913851856, 0.2073142183279706, 0.25632015594195945, 0.2111316972225401, 0.19490114322066288, 0.22535570589878728, 0.19744790227543163, 0.3282163040188508, 0.19664318101716882, 0.21680085461149845, 0.1877144805272578, 0.20032563108040735, 0.22855950199950137, 0.13985355482992767, 0.16292830627534638, 0.739012126547621, 0.6626138193088069, 0.19675164153991287, 0.5894442126579367, 0.6907470563681593, 0.6271122827811344, 0.2010941528227277, 0.7428454124013885, 0.5917244843617939, 0.16247832544796492, 0.1925317521871419, 0.20810071430993027, 0.459486631142641, 0.5647737174057772, 0.20556651975951035, 0.5999263803846548, 0.195791443429844, 0.1737290958861024, 0.19463725373352214, 0.18307624051330695, 0.18573050215142872, 0.236659420397758, 0.18268573165782298, 0.18452920181997357, 0.17631749062255475, 0.07696418222131962, 0.08095443941447078, 0.08401028503842067, 0.08420176637118748, 0.0809068940218256, 0.07779326290998201, 0.09102045576676743, 0.08808393118914859, 0.07528971442627841]}, "mutation_prompt": null}
{"id": "7ccd3e81-2472-4317-8dcf-8e03133d4128", "solution": "import numpy as np\n\nclass GradientInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, self.budget // 8)  # Adjusted population size for balance\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.6  # Enhanced exploration factor\n        self.CR_base = 0.85  # Adaptive crossover rate\n        self.adaptation_rate = 0.1  # Higher adaptation rate\n        self.local_search_intensity = 0.1  # Tuned local search intensity\n        self.mutation_prob = 0.75  # Higher mutation probability\n        self.gradient_weight = 0.1  # Introduced gradient component\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        # Track the best solution found\n        best_index = np.argmin(fitness)\n        best_individual = population[best_index]\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Self-adaptive F and CR with gradient feedback\n                F = np.clip(self.F_base + self.adaptation_rate * np.random.randn(), 0, 1)\n                CR = np.clip(self.CR_base + self.adaptation_rate * np.random.randn(), 0, 1)\n\n                # Choose mutation strategy\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Calculate gradient-based adjustment\n                gradient = self.gradient_weight * (best_individual - population[i])\n                trial = np.where(np.random.rand(self.dim) < CR, mutant + gradient, population[i])\n\n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection and elitism\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Dynamic local search around the best individual\n            neighborhood_size = int(self.local_search_intensity * self.population_size)\n            local_neighbors = best_individual + np.random.normal(0, 0.02, (neighborhood_size, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n\n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_local_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_local_index]\n                best_fitness = local_fitness[best_local_index]\n\n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        return best_individual", "name": "GradientInspiredDifferentialEvolution", "description": "A Gradient-Inspired Differential Evolution with dynamic feedback mechanisms to enhance global exploration and local exploitation for improved convergence.", "configspace": "", "generation": 91, "fitness": 0.3526208728383959, "feedback": "The algorithm GradientInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.24.", "error": "", "parent_id": "ec99e2dc-36dd-4b70-9fb0-6285f697cac9", "metadata": {"aucs": [0.764209019246676, 0.7534405326824242, 0.7580113206147744, 0.7827785742354899, 0.7797666488812138, 0.780653625629624, 0.7718990475992126, 0.7911598184474109, 0.7728900890000407, 0.5704257007810294, 0.57600162915907, 0.5911906649664602, 0.5961793207944142, 0.549940187588851, 0.5947499646921557, 0.5890536604012573, 0.5590705486092072, 0.5755223450375202, 0.11633309296118399, 0.16336599331306556, 0.14855023000660295, 0.1424113947314658, 0.1381340837294902, 0.13856052119559825, 0.14769653735868304, 0.12928775111653634, 0.147890103446624, 0.12803794230169951, 0.11359757918901725, 0.12083995152493066, 0.12145405838699685, 0.15449789661215085, 0.11389459642871658, 0.12806745589047464, 0.11379739837572267, 0.13869971108235424, 0.9816317906857972, 0.9841892806112043, 0.950027850332093, 0.9509542566833145, 0.9349937423919967, 0.966322484165815, 0.9813748703973051, 0.9709337903506959, 0.9444100061313788, 0.3952996636963043, 0.386786418934134, 0.39660221169691134, 0.44457886217101994, 0.4094088065119218, 0.4312681766483959, 0.419462435467152, 0.4134470346636029, 0.42479599231725595, 0.7147573978039565, 0.8230445344443398, 0.6476814951600287, 0.7387925518713477, 0.6661066601926935, 0.7043053150318475, 0.7404898640753155, 0.7185407627093185, 0.7603540932297225, 0.2944986796204452, 0.31544179962251206, 0.3097376692369468, 0.2809112750423187, 0.3205442710504165, 0.29660297526591506, 0.3050854302555007, 0.35435213588540093, 0.3420347387094397, 0.2811190766380267, 0.28578924661276894, 0.22854192657274996, 0.3447659110990805, 0.2926011143115299, 0.3242497035847054, 0.3594706765228659, 0.2829876716256312, 0.30523222838189346, 0.22363117299673774, 0.255846300721262, 0.24386324277305726, 0.19976324550572977, 0.24754480510777488, 0.25904380167732144, 0.2229674485049854, 0.27277607176724417, 0.2641060280650086, 0.3557165004367816, 0.33835869076634084, 0.40714417857489116, 0.3345304027827469, 0.33017150697808373, 0.3678693583416165, 0.405246403905279, 0.36272479640100186, 0.3672734217515051, 0.08150366181257107, 0.052135889726525386, 0.02755728469491847, 0.16006861647677506, 0.12393899145458331, 0.1531107579023645, 0.06075575795957122, 0.08277871321055885, 0.08626697464868083, 0.23043618815465494, 0.21473809308309488, 0.2138943461477234, 0.23810113353823958, 0.2503955678463219, 0.25811047791092356, 0.23604898160513765, 0.22740720811404402, 0.25572859340242926, 0.6079370734166127, 0.6071085796078607, 0.5956811938142369, 0.6417746717957217, 0.6158961274501015, 0.6004825280849689, 0.6065124897762557, 0.6237398565369178, 0.6041578793870293, 0.15576452564860443, 0.12953294009005256, 0.1261146728287169, 0.09602977214070474, 0.12659984145714365, 0.10301318102914103, 0.12682625481758059, 0.11829762986086567, 0.13703757398908234, 0.1295445033156013, 0.17670838876205996, 0.16791118583561893, 0.15924508109028834, 0.22098600329688656, 0.15582727300392707, 0.17827497937637238, 0.21765683976537697, 0.14620507159480056, 0.33489295007304887, 0.3583854304711305, 0.3523702653927884, 0.3702922463190019, 0.37338922140032527, 0.33135452882808725, 0.38224514936552856, 0.3873838056068306, 0.3676048589177492, 0.23724463836376475, 0.2733153523701142, 0.29497516927788414, 0.2788142557743689, 0.25666320220993344, 0.2477841951916817, 0.26880066734588304, 0.2912219328725325, 0.2925659070223019, 0.17695999992221112, 0.2278553245480881, 0.1851637804542976, 0.21082935151337445, 0.21467529046687361, 0.18839074666298905, 0.19677132268980724, 0.19921369297329572, 0.1970028219951031, 0.20503219883278334, 0.19556721529937027, 0.2204477156401179, 0.19616427238849254, 0.23851244603472, 0.22241878174002117, 0.19567887537190432, 0.22556832958083883, 0.19352016318505394, 0.6696784131728498, 0.4540761746300075, 0.1788209518935775, 0.6806506497075492, 0.7038429130230215, 0.5127331134555593, 0.7092233237006218, 0.728580991270825, 0.6033658885167977, 0.35117380392499276, 0.3374845615811217, 0.4132409126534855, 0.46606302615493955, 0.5860146949172622, 0.41377448026481156, 0.20746596939593454, 0.3304021630195426, 0.28977208506834196, 0.20765452566787834, 0.20234656537090956, 0.1892299129777686, 0.2007627209682984, 0.19320191290786548, 0.19404828542519514, 0.19038500902780364, 0.19370979826331947, 0.19909776184132988, 0.10279973490216165, 0.0869201074375664, 0.08757021321688263, 0.07993317846869852, 0.08761909040900095, 0.08060739595428423, 0.10733351928653811, 0.07019462097888174, 0.09424735058541878]}, "mutation_prompt": null}
{"id": "e0534362-d8e2-4b30-a097-e39eaba3a595", "solution": "import numpy as np\n\nclass EnhancedHybridDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(80, self.budget // 6)  # Further increased population size for initial exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.6  # Adjusted further for balanced exploration and exploitation\n        self.CR_base = 0.85  # Slightly lowered for diverse recombination\n        self.adaptation_rate = 0.1  # Increased adaptation rate for dynamic changes\n        self.local_search_intensity = 0.2  # Boosted local search intensity\n        self.mutation_variant_prob = 0.6  # Dynamic variant of best/rand mutation\n        self.reduction_factor = 0.9  # Factor to reduce population size over generations\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        # Track the best solution found\n        best_index = np.argmin(fitness)\n        best_individual = population[best_index]\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Self-adaptive F and CR\n                F = np.clip(self.F_base + self.adaptation_rate * np.random.randn(), 0, 1)\n                CR = np.clip(self.CR_base + self.adaptation_rate * np.random.randn(), 0, 1)\n\n                # Dynamic mutation strategy\n                if np.random.rand() < self.mutation_variant_prob:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = population[indices]\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(self.population_size, 2, replace=False)\n                    a, b = population[indices]\n                    mutant = np.clip(best_individual + F * (a - b), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n\n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection and elitism\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Enhanced local search around the best individual\n            neighborhood_size = int(self.local_search_intensity * self.population_size)\n            local_neighbors = best_individual + np.random.normal(0, 0.1, (neighborhood_size, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n\n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_local_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_local_index]\n                best_fitness = local_fitness[best_local_index]\n\n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n            # Dynamically reduce the population size\n            if eval_count >= self.budget * 0.5:\n                new_size = max(int(self.population_size * self.reduction_factor), 10)\n                population = population[:new_size]\n                fitness = fitness[:new_size]\n                self.population_size = new_size\n\n        # Return best found solution\n        return best_individual", "name": "EnhancedHybridDynamicDifferentialEvolution", "description": "A hybrid adaptive differential evolution with enhanced mutation strategies and dynamic population adaptation for improved convergence.", "configspace": "", "generation": 92, "fitness": 0.365869601201105, "feedback": "The algorithm EnhancedHybridDynamicDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.25.", "error": "", "parent_id": "ec99e2dc-36dd-4b70-9fb0-6285f697cac9", "metadata": {"aucs": [0.7929356293308143, 0.7850630045253543, 0.7726593572456714, 0.7812355214613854, 0.7969396298301079, 0.7960193588241575, 0.7924334965909395, 0.7905185071472286, 0.7846678772615574, 0.578913425410127, 0.6068207504225791, 0.6143231820483966, 0.5988666041807422, 0.5960925967685091, 0.588061602556244, 0.590423590098025, 0.601044283976091, 0.6007459977805616, 0.1141572010814289, 0.1261109388640993, 0.1297447803472893, 0.14409261542817842, 0.14818029544817202, 0.1467589031275569, 0.14234689321667937, 0.14552966847485715, 0.14516939309874055, 0.12481968241895391, 0.114613462290869, 0.1273465244187526, 0.13829051698065942, 0.12063218275643717, 0.2500188450166746, 0.11834083607806423, 0.10949607074671708, 0.14562955162740654, 0.9755566036571285, 0.980863222432391, 0.9796894144158463, 0.9738100225190706, 0.970310788218619, 0.9878522323151093, 0.9807549603981437, 0.9804132380006674, 0.9826683543765871, 0.3659944091524677, 0.39125757904073777, 0.34617574236907045, 0.4793746093244813, 0.4581709961068373, 0.4407918324647734, 0.4784618894320355, 0.43739941022902007, 0.45974743160875065, 0.5673614355723994, 0.7828425476842954, 0.7276122027011633, 0.7606936694657817, 0.7186126371695616, 0.8005796829459575, 0.7843132367126673, 0.7855363567665907, 0.7469145296488144, 0.5467637078163877, 0.557939590671779, 0.12990147030674903, 0.12612833438198123, 0.33953065981376085, 0.5332613408743125, 0.12593608663148714, 0.5572683323131618, 0.34862209633563657, 0.25403376921757326, 0.30565810792279735, 0.4880744047769653, 0.5441549635707694, 0.1296123747611404, 0.3314552846753087, 0.34257019049605786, 0.19549838115349638, 0.23384051403784845, 0.27545695766177514, 0.27488457860473625, 0.2693773257693328, 0.20384449853681308, 0.2763126775334235, 0.2517740157818926, 0.23630754084865335, 0.22314900068230425, 0.2492719286043079, 0.37213149884924146, 0.3757903921559286, 0.3977558697896417, 0.3888800220119506, 0.3584652741435751, 0.3179417891582609, 0.43605104764450175, 0.3850467993918142, 0.40539149549513187, 0.09797334692552517, 0.26039114196475066, 0.1063599750144254, 0.15941567174769966, 0.17237160051243394, 0.07234670831578005, 0.11408575982569058, 0.08712767498162666, 0.06686868224419196, 0.2435804150114772, 0.2890470574213727, 0.23683073794510978, 0.24727715958873064, 0.2830425723019393, 0.2894842031295166, 0.24762703721586454, 0.3079593777341234, 0.2916123754997527, 0.6394567733234121, 0.6329926250464927, 0.6493650564825002, 0.6327310896783118, 0.6220844844916389, 0.6133055203256121, 0.6510725866375933, 0.6066112270654341, 0.648456535729417, 0.14026123177448246, 0.1297748002225726, 0.1458147090924904, 0.10861258506622218, 0.11558052843970834, 0.1127739471031367, 0.13257029524106934, 0.11546546359859244, 0.11789376146739794, 0.18837847418940135, 0.338248722895356, 0.16542354072072263, 0.20039294667603835, 0.24960032500193396, 0.3255301174145232, 0.23320976721237874, 0.17881286877730507, 0.1593426593051912, 0.40141031044746855, 0.3683207868506877, 0.39396235473117147, 0.3294656046544002, 0.3979947771944876, 0.35687402550009695, 0.40628866503022165, 0.38844930677432543, 0.47012992871345405, 0.30963347783364537, 0.3099198386181421, 0.36067651185611116, 0.28569870473985204, 0.28536367283154873, 0.35902623653580823, 0.30829068815660543, 0.3461340101808149, 0.3037080309200433, 0.1991676499294066, 0.18425715962393152, 0.21201965002470968, 0.17998830095963325, 0.2921927592467384, 0.1999365157486056, 0.19887791124548448, 0.2108756077474988, 0.18695567543949654, 0.21831545768883986, 0.5503935793478868, 0.2102118447821456, 0.1964047476482037, 0.22755227641948872, 0.2358100709284936, 0.4184812295403856, 0.20869714141096984, 0.22577717576427214, 0.1483356034663713, 0.18791412305010158, 0.7128839819305941, 0.8197926870694827, 0.1989034076851478, 0.16719543657398772, 0.7323703719167082, 0.160486397535484, 0.21136202744253718, 0.7474276012779407, 0.1551240461006751, 0.7567647649689377, 0.773766695425775, 0.20399812825310248, 0.20953138562961393, 0.7723939725438453, 0.2095396280314611, 0.20989084298777871, 0.19590787089379524, 0.19106670026028427, 0.1932563471937646, 0.18881754726701305, 0.1801394574527181, 0.18623721781823144, 0.17868522828054023, 0.1707397478823417, 0.1894851576125306, 0.07982984048686015, 0.08828444109980649, 0.08352672897300362, 0.07738691936669728, 0.07278721862278925, 0.07916715522937046, 0.08157770688207089, 0.07919767681094492, 0.07874983596286567]}, "mutation_prompt": null}
{"id": "9ce4a9d1-ecd3-4335-a9b5-50d9c48fddc1", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = min(80, self.budget // 7)  # Increased initial population size for enhanced exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.6  # Adaptively tuned F for balanced exploration-exploitation\n        self.CR_base = 0.85  # Moderate CR to maintain diversity\n        self.adaptation_rate = 0.1  # Enhanced adaptation for rapid parameter tuning\n        self.local_search_intensity = 0.2  # Higher local search intensity targeting promising regions\n        self.mutation_prob = 0.8  # Increased probability for best mutation strategy\n        self.shrink_factor = 0.95  # Dynamic shrinking of the population size\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.initial_population_size\n\n        best_index = np.argmin(fitness)\n        best_individual = population[best_index]\n        best_fitness = fitness[best_index]\n\n        current_population_size = self.initial_population_size\n\n        while eval_count < self.budget:\n            for i in range(current_population_size):\n                F = np.clip(self.F_base + self.adaptation_rate * np.random.randn(), 0, 1)\n                CR = np.clip(self.CR_base + self.adaptation_rate * np.random.randn(), 0, 1)\n\n                if np.random.rand() < self.mutation_prob:\n                    indices = np.random.choice(current_population_size, 3, replace=False)\n                    a, b, c = population[indices]\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(current_population_size, 2, replace=False)\n                    a, b = population[indices]\n                    mutant = np.clip(best_individual + F * (a - b), self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            neighborhood_size = int(self.local_search_intensity * current_population_size)\n            local_neighbors = best_individual + np.random.normal(0, 0.05, (neighborhood_size, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n\n            if np.min(local_fitness) < best_fitness:\n                best_local_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_local_index]\n                best_fitness = local_fitness[best_local_index]\n\n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n            if eval_count < self.budget:\n                current_population_size = max(5, int(self.shrink_factor * current_population_size))  # Ensures minimum population size\n\n        return best_individual", "name": "EnhancedDynamicDifferentialEvolution", "description": "A novel adaptive differential evolution enhanced with diversity-driven local search and dynamic population resizing for accelerated convergence.", "configspace": "", "generation": 93, "fitness": 0.2649949640333906, "feedback": "The algorithm EnhancedDynamicDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "ec99e2dc-36dd-4b70-9fb0-6285f697cac9", "metadata": {"aucs": [0.5439859653649018, 0.6173842336498951, 0.5860100920443951, 0.5813567314884716, 0.6612211491061024, 0.6216928949656119, 0.603652142743118, 0.4998347696194404, 0.5818947987266292, 0.21509795953219868, 0.1917506705912294, 0.22856139887484783, 0.20846628452011617, 0.42707448972256146, 0.2307067816804247, 0.10694321029474618, 0.22461063004024395, 0.12023170660850324, 0.15376227033330125, 0.11412554692205301, 0.11105914240873882, 0.11258963467217309, 0.12538207319508365, 0.12509444349355747, 0.11662081321089479, 0.178437120162786, 0.1731091302381088, 0.10285670818836756, 0.11167574505251265, 0.17281706415789888, 0.11422331580498923, 0.10457718958444695, 0.13054747249013932, 0.14912089060852718, 0.12616618992779005, 0.11652648009250921, 0.9527985648180197, 0.956360781898784, 0.946850074856376, 0.9589409838999515, 0.9598319970126576, 0.9632824081050282, 0.9736417934590336, 0.9651270885259162, 0.9713646215351605, 0.39285477764771215, 0.3487968799118456, 0.32829234452327216, 0.339702109912865, 0.3740415211898688, 0.3704111550300908, 0.3524407910955477, 0.32754006567403127, 0.3664342494727222, 0.425942833934871, 0.3817985312754102, 0.5509855781376232, 0.3639917978218372, 0.2737482561861372, 0.8266180653840429, 0.761833327378672, 0.4230230475929335, 0.3720614193930899, 0.23927640321180077, 0.12346243803386092, 0.09879655975857626, 0.11127023183663676, 0.15501483249099823, 0.17399437687854824, 0.1768529551820941, 0.1291445141988139, 0.1267234183758279, 0.12497888338285068, 0.15640541800905028, 0.15895615805790986, 0.15418494679555628, 0.16368470708300942, 0.13631249079593677, 0.13044924327628704, 0.1238909373897148, 0.13267613329408012, 0.1155589544590192, 9.999999999998899e-05, 0.08620074444124182, 0.03517236739535745, 9.999999999998899e-05, 0.0548960081777925, 0.04517084872931987, 0.044239237833199496, 0.056560890746933046, 0.20813433761639488, 0.05479446203540794, 0.24325034452596062, 0.13366652475026497, 0.13568895799312364, 0.037106232716165866, 0.24914110578386284, 0.12443221532210536, 0.3845656668215456, 0.07067264389361405, 0.04761436928557072, 0.04083194437446602, 0.10810210236889128, 0.050505096920471115, 0.09558294338100737, 0.014446483980307123, 0.05484522245113255, 0.0823269491124462, 0.17740330746108246, 0.24652034343335927, 0.12384819692610416, 0.1795370334056966, 0.19202265450107836, 0.16230664390525484, 0.1699514062205315, 0.09466161379029814, 0.18073664403998113, 0.49146150532836086, 0.47168836781207224, 0.440105195142933, 0.4934213101859828, 0.5297316784915711, 0.459019365734749, 0.5545241133820175, 0.5004545824270366, 0.5848168439111796, 0.12687539765737277, 0.15199235274468703, 0.1065681812619077, 0.09130337135411137, 0.15796569738328692, 0.1414408725281484, 0.09630843562414515, 0.09951356941695377, 0.15205882671993876, 0.1928770538043506, 0.20531359209253364, 0.18942644291297628, 0.2823551341587768, 0.4306765673613602, 0.15473811015079186, 0.17174904142580438, 0.19875939172607737, 0.23669126190934098, 0.3107296466846119, 0.35165680537414423, 0.2410004916261005, 0.27126475963820207, 0.31175457205804946, 0.3122121003116758, 0.34289537589479246, 0.3178570970015274, 0.3160275392594182, 0.19378557438794597, 0.28000278554469993, 0.2626444875328998, 0.25502713659879506, 0.27571486033280557, 0.29779836033829565, 0.23319044884775297, 0.27448874869119433, 0.27281058985772155, 0.21919915588285643, 0.17812530244108515, 0.21724641574555037, 0.21474216875072272, 0.17423164282655867, 0.1971480569228603, 0.2149773020096648, 0.19269835686239156, 0.1946223762034669, 0.2024081268462361, 0.17941736712300715, 0.20862327905978284, 0.19876311881621855, 0.20775025903653255, 0.19227211217785722, 0.24324545608749326, 0.1901727043706929, 0.1978760158233861, 0.14792882692736642, 0.7537218675723425, 0.1859302041330434, 0.7852973243901115, 0.19759146188972487, 0.16490826711625428, 0.18277593125247305, 0.8669284748446768, 0.16588564087971913, 0.5293158718205462, 0.16756335032921432, 0.20395399834997163, 0.423980400186188, 0.1624548334137622, 0.16662278086374405, 0.20525431306166297, 0.21073860221694762, 0.15365108434803643, 0.19550187372327776, 0.22854818513836428, 0.1795631864821018, 0.19804621606043893, 0.20315802421045137, 0.17987556716765152, 0.20011561624786667, 0.17091478657643944, 0.19710225516647784, 0.0975617783429581, 0.07479420847840923, 0.1012571986925781, 0.10414616427358792, 0.07081917914540303, 0.09192469278458115, 0.09854766272480486, 0.08515360005466377, 0.0965105900897173]}, "mutation_prompt": null}
{"id": "87727068-b895-4459-b676-ae43e9a450e2", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(60, self.budget // 8)  # Increased population size for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.5  # Adjusted for better exploration\n        self.CR_base = 0.9  # Increased to promote diversity\n        self.adaptation_rate = 0.05  # Increased adaptation rate for faster parameter adjustment\n        self.local_search_intensity = 0.15  # Increased local search intensity\n        self.mutation_prob = 0.7  # Probability of best or rand mutation\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        # Track the best solution found\n        best_index = np.argmin(fitness)\n        best_individual = population[best_index]\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Self-adaptive F and CR\n                F = np.clip(self.F_base + self.adaptation_rate * np.random.randn(), 0, 1)\n                CR = np.clip(self.CR_base + self.adaptation_rate * np.random.randn(), 0, 1)\n\n                # Choose mutation strategy based on a probability\n                if np.random.rand() < self.mutation_prob:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = population[indices]\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(self.population_size, 2, replace=False)\n                    a, b = population[indices]\n                    mutant = np.clip(best_individual + F * (a - b), self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n\n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection and elitism\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Enhanced cooperative local search around the best individual\n            neighborhood_size = int(self.local_search_intensity * self.population_size)\n            local_neighbors = best_individual + np.random.normal(0, 0.05, (neighborhood_size, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n\n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_local_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_local_index]\n                best_fitness = local_fitness[best_local_index]\n\n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        return best_individual", "name": "EnhancedHybridAdaptiveDifferentialEvolution", "description": "An enhanced hybrid adaptive differential evolution with increased local search adaptation and self-adaptive parameter tuning for rapid convergence.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ec99e2dc-36dd-4b70-9fb0-6285f697cac9", "metadata": {"aucs": [0.870997610873655, 0.876937349254849, 0.8628821214606534, 0.8781794510016624, 0.8772296468912268, 0.8694279318528029, 0.8756843654306008, 0.8726768563847991, 0.8598523983391932, 0.7477842665418626, 0.7505830115174412, 0.7273487673266275, 0.7189706160361924, 0.7360234772212559, 0.7429061262623435, 0.7438642610252675, 0.7560429492372163, 0.7467399915536672, 0.16512467121215724, 0.21203315310966409, 0.36256095224927487, 0.16722241556246864, 0.13854119174963164, 0.3333937421616463, 0.13516368482132823, 0.14772951992740369, 0.15692171902064456, 0.1564408366174984, 0.1353579238051421, 0.14422112246044583, 0.11484204674412235, 0.11348023152341102, 0.11138379259342324, 0.14321803866866378, 0.14280534633632092, 0.15859257836490215, 0.9799585186455763, 0.9503327389088712, 0.9724501584066897, 0.9571617360165604, 0.9859598542069689, 0.9718842750065484, 0.9760859368284891, 0.9848955505579943, 0.973482908644332, 0.6071385211387058, 0.6173177688242826, 0.6131191937365257, 0.6198810082831014, 0.6308754058002048, 0.6151046424041569, 0.5929618643435774, 0.6259420273296028, 0.6123827674671722, 0.8398909658399296, 0.8539463927768597, 0.8286288287924357, 0.8479342703448974, 0.88641759183554, 0.8924952684036396, 0.8466961223205589, 0.8895895616883716, 0.8513347130888925, 0.6474349245531625, 0.13233776457818802, 0.6015251038894203, 0.12842010025943162, 0.6650660782032273, 0.729896318050316, 0.5838451394599409, 0.6038932677285569, 0.7486964038653956, 0.6027977688129897, 0.12904105617894945, 0.4970570551982538, 0.6338783710380922, 0.1311763787354625, 0.654584992183878, 0.13347577211066708, 0.5834411824896677, 0.6644167530846077, 0.5801341813173042, 0.6517131199065661, 0.5747597642597722, 0.5450781855850122, 0.6264774567937635, 0.5973118877387971, 0.5922806442473407, 0.6058774307227208, 0.5307442727477565, 0.7246104456113118, 0.7196658854680926, 0.6937459743116989, 0.6929901166276469, 0.6764640766292062, 0.6877991243894017, 0.7095399141637933, 0.7431058503302441, 0.7141560428367603, 0.5111644149668872, 0.12354566074955964, 0.13808117097245265, 0.16417221084055578, 0.5071824081123578, 0.2800834292901856, 0.15227794024262242, 0.2060402404781626, 0.43032493661029814, 0.49899493882997625, 0.5191627329886238, 0.4963062823251455, 0.519113603089481, 0.5317078511278232, 0.5517407313988787, 0.4828361527779109, 0.5174869321995552, 0.5274905608509252, 0.8230889833159312, 0.8274699863485728, 0.802146867581838, 0.7996643983062854, 0.8111585569300906, 0.8076406107590844, 0.8097513012737546, 0.813623972927586, 0.8012792400647224, 0.1543570750637966, 0.11202371696330105, 0.16342062676402602, 0.11988433445212554, 0.14401205285359286, 0.1247286910495965, 0.15758369478141976, 0.13863798943727346, 0.12049367302351399, 0.30905398943833184, 0.222262321964814, 0.21822555431598334, 0.1939458291385081, 0.4463802150027981, 0.2623165071326464, 0.388702947695691, 0.39316509265836086, 0.5641051301559905, 0.5559964566010401, 0.5794900739564952, 0.5592162804406543, 0.5334386158196133, 0.5634881082285331, 0.5764055782840386, 0.6324910585494613, 0.6113997600794387, 0.5576296411418729, 0.45822871852814717, 0.4632290950314738, 0.479100132440759, 0.46157879635820986, 0.43372108776671126, 0.4521519413829479, 0.4772208737947904, 0.47949489037925097, 0.4336084838960391, 0.21664866446744402, 0.21020796781048734, 0.20391775129587275, 0.2102933753324162, 0.21488300958379658, 0.22832035167615627, 0.19642172451381434, 0.19848521525915352, 0.24607068311088864, 0.22638461450377823, 0.21955924768255364, 0.22099698523152322, 0.2464495276526275, 0.2015667282287935, 0.20552757969012359, 0.20783549005238355, 0.21796835920185642, 0.21117204849685445, 0.17313527134759987, 0.8910706378954903, 0.15211568904684047, 0.8901467250816121, 0.19936136052459064, 0.1733889867309919, 0.14219936505632336, 0.15934671658200672, 0.21046538462018194, 0.8813767329362526, 0.8404360913909095, 0.8400914666175698, 0.2116666932825344, 0.16800672632850167, 0.8253102176423769, 0.16810764576068138, 0.21002542641758581, 0.8761756538100725, 0.21770435341516903, 0.19684888208430695, 0.20589586690149797, 0.18355856139871507, 0.20310480967848143, 0.18729717612734564, 0.18811472821621278, 0.1933542490469048, 0.1996172762222207, 0.08091856304424327, 0.08559185525502855, 0.09926782238828946, 0.07769180530251996, 0.08145907572888011, 0.09784577550374873, 0.08813891779584104, 0.09794845121770268, 0.09199369335995033]}, "mutation_prompt": null}
{"id": "3e2734b5-c907-4007-8756-813ea209ca19", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolutionV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(80, self.budget // 6)  # Increased to enhance exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.6  # Adjusted for balanced exploration and exploitation\n        self.CR_base = 0.85  # Tuned to encourage diverse offspring\n        self.adaptation_rate = 0.1  # Increased for more responsive parameter change\n        self.local_search_intensity = 0.2  # Intensified local search\n        self.mutation_prob = 0.75  # Slightly increased to balance strategies\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_individual = population[best_index]\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                F = np.clip(self.F_base + self.adaptation_rate * np.random.standard_normal(), 0.3, 0.9)\n                CR = np.clip(self.CR_base + self.adaptation_rate * np.random.standard_normal(), 0.6, 1.0)\n\n                if np.random.rand() < self.mutation_prob:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = population[indices]\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(self.population_size, 2, replace=False)\n                    a, b = population[indices]\n                    mutant = np.clip(best_individual + F * (a - b), self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            neighborhood_size = int(self.local_search_intensity * self.population_size)\n            local_neighbors = best_individual + np.random.normal(0, 0.05, (neighborhood_size, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n\n            if np.min(local_fitness) < best_fitness:\n                best_local_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_local_index]\n                best_fitness = local_fitness[best_local_index]\n\n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        return best_individual", "name": "EnhancedHybridAdaptiveDifferentialEvolutionV2", "description": "A hybrid adaptive differential evolution with dynamic parameter adjustment, enhanced diversity, and intensified local search for accelerated convergence.", "configspace": "", "generation": 95, "fitness": 0.3315065439832658, "feedback": "The algorithm EnhancedHybridAdaptiveDifferentialEvolutionV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.23.", "error": "", "parent_id": "ec99e2dc-36dd-4b70-9fb0-6285f697cac9", "metadata": {"aucs": [0.7561388184213942, 0.7481547292578467, 0.7424580941545791, 0.7481146252322384, 0.7398636500893689, 0.7678778297078095, 0.747804977971187, 0.756965330207828, 0.7542134991209468, 0.4668407726146937, 0.50350354118045, 0.5226210373631031, 0.5110538465186978, 0.5117265576470237, 0.5098820571742432, 0.46489807915686443, 0.49673523637525374, 0.498367785494673, 0.12501455014537755, 0.13453089262197593, 0.15542499311068492, 0.1123904345375617, 0.13555251976875748, 0.11820891854165805, 0.12556100272205617, 0.13809299335671166, 0.1337783233251153, 0.11971033032863221, 0.10467839624867958, 0.11993948376719599, 0.11259794885660612, 0.11147503624599231, 0.123325697977689, 0.12960240995916772, 0.13029851538293247, 0.1080954824851158, 0.9640020100271531, 0.9719240591088737, 0.9703573571804037, 0.9782690213203525, 0.9751711947904005, 0.964507063020841, 0.9716534076209532, 0.975731215453399, 0.9713096064208248, 0.31536567873572086, 0.36112141869000514, 0.3056026335700206, 0.3610817151204777, 0.37087887034599554, 0.33191654960165495, 0.3589186109549525, 0.32940674131434267, 0.363169108732856, 0.7014902624947248, 0.7559265431883806, 0.7379195653760091, 0.7070242728447134, 0.6500897766768077, 0.7969377776274166, 0.661791603138582, 0.6990355478014015, 0.6451085548132972, 0.35186734490487215, 0.35305206428893554, 0.3435427788108414, 0.32600814923125543, 0.32596454714727985, 0.4193215008389911, 0.33881043387799104, 0.31739811559499354, 0.3709406129639171, 0.3251508300567262, 0.13088196108208994, 0.3627378901079653, 0.35647854694642855, 0.22252993318162384, 0.3991386347866047, 0.12293720408937092, 0.28958642289620795, 0.3989778227152717, 0.1750198250330921, 0.19154998307367632, 0.19521667938589016, 0.1717937204430534, 0.2102108133546663, 0.19502546871891058, 0.18792047701298586, 0.2100706197944261, 0.19077906418428314, 0.3205917194750426, 0.35519794445506137, 0.3538907853806088, 0.33227872092827015, 0.3239653912076479, 0.3501971940639681, 0.415562096875029, 0.369693181020171, 0.36395739881426514, 0.049956062658567335, 0.07544144903537198, 0.12370133492703661, 0.14360237372280227, 0.14324902198607414, 0.1439400867655113, 0.07025623850777651, 0.05993687699299499, 0.11533450488945651, 0.2300337706538641, 0.20520399546002355, 0.19386464133556436, 0.2207183196870881, 0.20692952797733177, 0.23608344395638847, 0.22332097661092043, 0.2059512181988281, 0.23052570888262525, 0.5754444954649949, 0.5732266878305114, 0.5738568787391216, 0.62586934860053, 0.5635942405344849, 0.5898710137062446, 0.5799244713732532, 0.5500095220519333, 0.6077952280627433, 0.12746016112777947, 0.14178807609929878, 0.11357065317320625, 0.17057256219363004, 0.1202412003514921, 0.09340614459968488, 0.10848721327526722, 0.13615047539763614, 0.1960156840925833, 0.1799895992239875, 0.18168808365842948, 0.1565901930206952, 0.18073881967681826, 0.23718430706434468, 0.1732283975501403, 0.18001162854902064, 0.15501022197445924, 0.23005872821006357, 0.3533478126470153, 0.35648009021299076, 0.3365815301229895, 0.35877711593023076, 0.3407327732381522, 0.31929427211498573, 0.3845413074942331, 0.404260738777537, 0.3813646365515805, 0.2376665958647861, 0.25383598603998137, 0.2797174636727411, 0.232208784630082, 0.28181508703145275, 0.2603470605798378, 0.29275217486058236, 0.3161134346087936, 0.297481944604403, 0.213171755606002, 0.197010865551706, 0.19936096782840218, 0.19602632537968034, 0.2130864806570575, 0.22098339222063956, 0.19960736562789883, 0.2279928485052014, 0.20148908051423942, 0.2800817980423742, 0.3305241763738195, 0.20450936921791174, 0.19047529573053035, 0.2292139603456288, 0.2847446877516052, 0.3704456909235828, 0.19830298182636807, 0.19944407762647975, 0.163762480093551, 0.18750046624236383, 0.1823425408749353, 0.7736035130481951, 0.1962933351011008, 0.19537489186442614, 0.7885900516814233, 0.1684669673982686, 0.7841695483411149, 0.6398318597284578, 0.15417389816631222, 0.2038266910441967, 0.6495007731002893, 0.19536184189124184, 0.20465987404142316, 0.12589282603961727, 0.20838646909701297, 0.20874683819361095, 0.1798343865600338, 0.18054892287395818, 0.18250780318037296, 0.18721775925835793, 0.1745702940522711, 0.1810325073612311, 0.1915685813155117, 0.1832771525369783, 0.19414788859893573, 0.07717993241055388, 0.07862123250018449, 0.07755905054271384, 0.08148446935014586, 0.07574855999559926, 0.0820185785166837, 0.0765422961893708, 0.08536315773463632, 0.09262810511516562]}, "mutation_prompt": null}
{"id": "81baece1-994c-4938-ba63-55e1b99ebb9f", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(60, self.budget // 8)  # Increased population size for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.5  # Adjusted for better exploration\n        self.CR_base = 0.9  # Increased to promote diversity\n        self.adaptation_rate = 0.05  # Increased adaptation rate for faster parameter adjustment\n        self.local_search_intensity = 0.15  # Increased local search intensity\n        self.mutation_prob = 0.7  # Probability of best or rand mutation\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        # Track the best solution found\n        best_index = np.argmin(fitness)\n        best_individual = population[best_index]\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Self-adaptive F and CR\n                F = np.clip(self.F_base + self.adaptation_rate * np.random.randn(), 0, 1)\n                CR = np.clip(self.CR_base + self.adaptation_rate * np.random.randn(), 0, 1)\n\n                # Choose mutation strategy based on a probability\n                if np.random.rand() < self.mutation_prob:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = population[indices]\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(self.population_size, 2, replace=False)\n                    a, b = population[indices]\n                    mutant = np.clip(best_individual + F * (a - b), self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n\n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection and elitism\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Enhanced cooperative local search around the best individual\n            neighborhood_size = int(self.local_search_intensity * self.population_size)\n            local_neighbors = best_individual + np.random.normal(0, 0.05, (neighborhood_size, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n\n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_local_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_local_index]\n                best_fitness = local_fitness[best_local_index]\n\n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        return best_individual", "name": "EnhancedHybridAdaptiveDifferentialEvolution", "description": "An enhanced hybrid adaptive differential evolution with increased local search adaptation and self-adaptive parameter tuning for rapid convergence.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ec99e2dc-36dd-4b70-9fb0-6285f697cac9", "metadata": {"aucs": [0.870997610873655, 0.876937349254849, 0.8628821214606534, 0.8781794510016624, 0.8772296468912268, 0.8694279318528029, 0.8756843654306008, 0.8726768563847991, 0.8598523983391932, 0.7477842665418626, 0.7505830115174412, 0.7273487673266275, 0.7189706160361924, 0.7360234772212559, 0.7429061262623435, 0.7438642610252675, 0.7560429492372163, 0.7467399915536672, 0.16512467121215724, 0.21203315310966409, 0.36256095224927487, 0.16722241556246864, 0.13854119174963164, 0.3333937421616463, 0.13516368482132823, 0.14772951992740369, 0.15692171902064456, 0.1564408366174984, 0.1353579238051421, 0.14422112246044583, 0.11484204674412235, 0.11348023152341102, 0.11138379259342324, 0.14321803866866378, 0.14280534633632092, 0.15859257836490215, 0.9799585186455763, 0.9503327389088712, 0.9724501584066897, 0.9571617360165604, 0.9859598542069689, 0.9718842750065484, 0.9760859368284891, 0.9848955505579943, 0.973482908644332, 0.6071385211387058, 0.6173177688242826, 0.6131191937365257, 0.6198810082831014, 0.6308754058002048, 0.6151046424041569, 0.5929618643435774, 0.6259420273296028, 0.6123827674671722, 0.8398909658399296, 0.8539463927768597, 0.8286288287924357, 0.8479342703448974, 0.88641759183554, 0.8924952684036396, 0.8466961223205589, 0.8895895616883716, 0.8513347130888925, 0.6474349245531625, 0.13233776457818802, 0.6015251038894203, 0.12842010025943162, 0.6650660782032273, 0.729896318050316, 0.5838451394599409, 0.6038932677285569, 0.7486964038653956, 0.6027977688129897, 0.12904105617894945, 0.4970570551982538, 0.6338783710380922, 0.1311763787354625, 0.654584992183878, 0.13347577211066708, 0.5834411824896677, 0.6644167530846077, 0.5801341813173042, 0.6517131199065661, 0.5747597642597722, 0.5450781855850122, 0.6264774567937635, 0.5973118877387971, 0.5922806442473407, 0.6058774307227208, 0.5307442727477565, 0.7246104456113118, 0.7196658854680926, 0.6937459743116989, 0.6929901166276469, 0.6764640766292062, 0.6877991243894017, 0.7095399141637933, 0.7431058503302441, 0.7141560428367603, 0.5111644149668872, 0.12354566074955964, 0.13808117097245265, 0.16417221084055578, 0.5071824081123578, 0.2800834292901856, 0.15227794024262242, 0.2060402404781626, 0.43032493661029814, 0.49899493882997625, 0.5191627329886238, 0.4963062823251455, 0.519113603089481, 0.5317078511278232, 0.5517407313988787, 0.4828361527779109, 0.5174869321995552, 0.5274905608509252, 0.8230889833159312, 0.8274699863485728, 0.802146867581838, 0.7996643983062854, 0.8111585569300906, 0.8076406107590844, 0.8097513012737546, 0.813623972927586, 0.8012792400647224, 0.1543570750637966, 0.11202371696330105, 0.16342062676402602, 0.11988433445212554, 0.14401205285359286, 0.1247286910495965, 0.15758369478141976, 0.13863798943727346, 0.12049367302351399, 0.30905398943833184, 0.222262321964814, 0.21822555431598334, 0.1939458291385081, 0.4463802150027981, 0.2623165071326464, 0.388702947695691, 0.39316509265836086, 0.5641051301559905, 0.5559964566010401, 0.5794900739564952, 0.5592162804406543, 0.5334386158196133, 0.5634881082285331, 0.5764055782840386, 0.6324910585494613, 0.6113997600794387, 0.5576296411418729, 0.45822871852814717, 0.4632290950314738, 0.479100132440759, 0.46157879635820986, 0.43372108776671126, 0.4521519413829479, 0.4772208737947904, 0.47949489037925097, 0.4336084838960391, 0.21664866446744402, 0.21020796781048734, 0.20391775129587275, 0.2102933753324162, 0.21488300958379658, 0.22832035167615627, 0.19642172451381434, 0.19848521525915352, 0.24607068311088864, 0.22638461450377823, 0.21955924768255364, 0.22099698523152322, 0.2464495276526275, 0.2015667282287935, 0.20552757969012359, 0.20783549005238355, 0.21796835920185642, 0.21117204849685445, 0.17313527134759987, 0.8910706378954903, 0.15211568904684047, 0.8901467250816121, 0.19936136052459064, 0.1733889867309919, 0.14219936505632336, 0.15934671658200672, 0.21046538462018194, 0.8813767329362526, 0.8404360913909095, 0.8400914666175698, 0.2116666932825344, 0.16800672632850167, 0.8253102176423769, 0.16810764576068138, 0.21002542641758581, 0.8761756538100725, 0.21770435341516903, 0.19684888208430695, 0.20589586690149797, 0.18355856139871507, 0.20310480967848143, 0.18729717612734564, 0.18811472821621278, 0.1933542490469048, 0.1996172762222207, 0.08091856304424327, 0.08559185525502855, 0.09926782238828946, 0.07769180530251996, 0.08145907572888011, 0.09784577550374873, 0.08813891779584104, 0.09794845121770268, 0.09199369335995033]}, "mutation_prompt": null}
{"id": "c934db4c-68af-4254-b314-8245fc4f58db", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(60, self.budget // 8)  # Increased population size for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.5  # Adjusted for better exploration\n        self.CR_base = 0.9  # Increased to promote diversity\n        self.adaptation_rate = 0.05  # Increased adaptation rate for faster parameter adjustment\n        self.local_search_intensity = 0.15  # Increased local search intensity\n        self.mutation_prob = 0.7  # Probability of best or rand mutation\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        # Track the best solution found\n        best_index = np.argmin(fitness)\n        best_individual = population[best_index]\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Self-adaptive F and CR\n                F = np.clip(self.F_base + self.adaptation_rate * np.random.randn(), 0, 1)\n                CR = np.clip(self.CR_base + self.adaptation_rate * np.random.randn(), 0, 1)\n\n                # Choose mutation strategy based on a probability\n                if np.random.rand() < self.mutation_prob:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = population[indices]\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(self.population_size, 2, replace=False)\n                    a, b = population[indices]\n                    mutant = np.clip(best_individual + F * (a - b), self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n\n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection and elitism\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Enhanced cooperative local search around the best individual\n            neighborhood_size = int(self.local_search_intensity * self.population_size)\n            local_neighbors = best_individual + np.random.normal(0, 0.05, (neighborhood_size, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n\n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_local_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_local_index]\n                best_fitness = local_fitness[best_local_index]\n\n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        return best_individual", "name": "EnhancedHybridAdaptiveDifferentialEvolution", "description": "An enhanced hybrid adaptive differential evolution with increased local search adaptation and self-adaptive parameter tuning for rapid convergence.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ec99e2dc-36dd-4b70-9fb0-6285f697cac9", "metadata": {"aucs": [0.870997610873655, 0.876937349254849, 0.8628821214606534, 0.8781794510016624, 0.8772296468912268, 0.8694279318528029, 0.8756843654306008, 0.8726768563847991, 0.8598523983391932, 0.7477842665418626, 0.7505830115174412, 0.7273487673266275, 0.7189706160361924, 0.7360234772212559, 0.7429061262623435, 0.7438642610252675, 0.7560429492372163, 0.7467399915536672, 0.16512467121215724, 0.21203315310966409, 0.36256095224927487, 0.16722241556246864, 0.13854119174963164, 0.3333937421616463, 0.13516368482132823, 0.14772951992740369, 0.15692171902064456, 0.1564408366174984, 0.1353579238051421, 0.14422112246044583, 0.11484204674412235, 0.11348023152341102, 0.11138379259342324, 0.14321803866866378, 0.14280534633632092, 0.15859257836490215, 0.9799585186455763, 0.9503327389088712, 0.9724501584066897, 0.9571617360165604, 0.9859598542069689, 0.9718842750065484, 0.9760859368284891, 0.9848955505579943, 0.973482908644332, 0.6071385211387058, 0.6173177688242826, 0.6131191937365257, 0.6198810082831014, 0.6308754058002048, 0.6151046424041569, 0.5929618643435774, 0.6259420273296028, 0.6123827674671722, 0.8398909658399296, 0.8539463927768597, 0.8286288287924357, 0.8479342703448974, 0.88641759183554, 0.8924952684036396, 0.8466961223205589, 0.8895895616883716, 0.8513347130888925, 0.6474349245531625, 0.13233776457818802, 0.6015251038894203, 0.12842010025943162, 0.6650660782032273, 0.729896318050316, 0.5838451394599409, 0.6038932677285569, 0.7486964038653956, 0.6027977688129897, 0.12904105617894945, 0.4970570551982538, 0.6338783710380922, 0.1311763787354625, 0.654584992183878, 0.13347577211066708, 0.5834411824896677, 0.6644167530846077, 0.5801341813173042, 0.6517131199065661, 0.5747597642597722, 0.5450781855850122, 0.6264774567937635, 0.5973118877387971, 0.5922806442473407, 0.6058774307227208, 0.5307442727477565, 0.7246104456113118, 0.7196658854680926, 0.6937459743116989, 0.6929901166276469, 0.6764640766292062, 0.6877991243894017, 0.7095399141637933, 0.7431058503302441, 0.7141560428367603, 0.5111644149668872, 0.12354566074955964, 0.13808117097245265, 0.16417221084055578, 0.5071824081123578, 0.2800834292901856, 0.15227794024262242, 0.2060402404781626, 0.43032493661029814, 0.49899493882997625, 0.5191627329886238, 0.4963062823251455, 0.519113603089481, 0.5317078511278232, 0.5517407313988787, 0.4828361527779109, 0.5174869321995552, 0.5274905608509252, 0.8230889833159312, 0.8274699863485728, 0.802146867581838, 0.7996643983062854, 0.8111585569300906, 0.8076406107590844, 0.8097513012737546, 0.813623972927586, 0.8012792400647224, 0.1543570750637966, 0.11202371696330105, 0.16342062676402602, 0.11988433445212554, 0.14401205285359286, 0.1247286910495965, 0.15758369478141976, 0.13863798943727346, 0.12049367302351399, 0.30905398943833184, 0.222262321964814, 0.21822555431598334, 0.1939458291385081, 0.4463802150027981, 0.2623165071326464, 0.388702947695691, 0.39316509265836086, 0.5641051301559905, 0.5559964566010401, 0.5794900739564952, 0.5592162804406543, 0.5334386158196133, 0.5634881082285331, 0.5764055782840386, 0.6324910585494613, 0.6113997600794387, 0.5576296411418729, 0.45822871852814717, 0.4632290950314738, 0.479100132440759, 0.46157879635820986, 0.43372108776671126, 0.4521519413829479, 0.4772208737947904, 0.47949489037925097, 0.4336084838960391, 0.21664866446744402, 0.21020796781048734, 0.20391775129587275, 0.2102933753324162, 0.21488300958379658, 0.22832035167615627, 0.19642172451381434, 0.19848521525915352, 0.24607068311088864, 0.22638461450377823, 0.21955924768255364, 0.22099698523152322, 0.2464495276526275, 0.2015667282287935, 0.20552757969012359, 0.20783549005238355, 0.21796835920185642, 0.21117204849685445, 0.17313527134759987, 0.8910706378954903, 0.15211568904684047, 0.8901467250816121, 0.19936136052459064, 0.1733889867309919, 0.14219936505632336, 0.15934671658200672, 0.21046538462018194, 0.8813767329362526, 0.8404360913909095, 0.8400914666175698, 0.2116666932825344, 0.16800672632850167, 0.8253102176423769, 0.16810764576068138, 0.21002542641758581, 0.8761756538100725, 0.21770435341516903, 0.19684888208430695, 0.20589586690149797, 0.18355856139871507, 0.20310480967848143, 0.18729717612734564, 0.18811472821621278, 0.1933542490469048, 0.1996172762222207, 0.08091856304424327, 0.08559185525502855, 0.09926782238828946, 0.07769180530251996, 0.08145907572888011, 0.09784577550374873, 0.08813891779584104, 0.09794845121770268, 0.09199369335995033]}, "mutation_prompt": null}
{"id": "753ac3bf-1bb8-4595-81d6-810cc74f0bac", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = min(60, self.budget // 8)\n        self.population_size = self.initial_population_size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.5\n        self.CR_base = 0.9\n        self.adaptation_rate = 0.05\n        self.local_search_intensity = 0.15\n        self.mutation_prob = 0.7\n        self.dynamic_population = True  # Enable dynamic population resizing\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        best_index = np.argmin(fitness)\n        best_individual = population[best_index]\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                F = np.clip(self.F_base + self.adaptation_rate * np.random.randn(), 0, 1)\n                CR = np.clip(self.CR_base + self.adaptation_rate * np.random.randn(), 0, 1)\n\n                if np.random.rand() < self.mutation_prob:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = population[indices]\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(self.population_size, 2, replace=False)\n                    a, b = population[indices]\n                    mutant = np.clip(best_individual + F * (a - b), self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            neighborhood_size = int(self.local_search_intensity * self.population_size)\n            local_neighbors = best_individual + np.random.normal(0, 0.05, (neighborhood_size, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n\n            if np.min(local_fitness) < best_fitness:\n                best_local_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_local_index]\n                best_fitness = local_fitness[best_local_index]\n\n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n            if self.dynamic_population:\n                improvement_rate = (best_fitness - fitness[best_index]) / best_fitness\n                if improvement_rate < 0.01 and neighborhood_size > 1:\n                    self.population_size = max(10, self.population_size // 2)\n                else:\n                    self.population_size = min(self.initial_population_size, self.population_size + 2)\n\n        return best_individual", "name": "EnhancedHybridAdaptiveDifferentialEvolution", "description": "An enhanced hybrid adaptive differential evolution with dynamic population resizing and adaptive local search to improve convergence speed.", "configspace": "", "generation": 98, "fitness": 0.33106372942760537, "feedback": "The algorithm EnhancedHybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.28.", "error": "", "parent_id": "ec99e2dc-36dd-4b70-9fb0-6285f697cac9", "metadata": {"aucs": [0.9494237858384041, 0.9230018782894827, 0.9344147324008907, 0.9419234366323801, 0.9336696529266008, 0.9333081763701393, 0.8969611742543437, 0.9135011355902933, 0.9326356757825555, 0.8679619559071671, 0.8244775582557039, 0.8865687535991518, 0.8636126041851704, 0.05044324789370769, 0.8309803844286915, 0.7769463263257602, 0.8683366227087586, 0.7502527823499798, 0.1427888493103514, 0.24791327710096922, 0.141370291905195, 0.08994770044957845, 0.16062367150812007, 0.10178879702791588, 0.0940436441396747, 0.08951481341065759, 0.05212802775200087, 0.12501101484434185, 0.13544047362885137, 0.14480341257926155, 0.07326802245757968, 0.09279280153620717, 0.0971960791977472, 0.11866980119692538, 0.11650353494437549, 0.09600895130401244, 0.9789817593086095, 0.965306838713924, 0.9724501584066897, 0.9658737659789196, 0.9824080969016117, 0.9819012175545773, 0.9820208919481158, 0.9829424287894547, 0.9826303986139403, 0.47608539642648684, 0.47249810331235365, 0.5622861950487095, 0.7213520390103139, 0.518747594988417, 0.5914128089334968, 0.788443204963886, 0.5384094243874423, 0.6122977309858981, 0.13144949901534897, 0.3863039452288267, 0.22947231548110614, 0.22142547459860185, 0.28315386965871026, 0.3652359057975797, 0.12068958582806899, 0.1785486827614181, 0.1547180307083923, 0.13572506904712223, 0.13234787601588194, 0.20851620276622895, 0.12584636957846218, 0.19366389985277765, 0.1253099653112948, 0.21741967087845004, 0.12685209642029804, 0.21432013046222187, 0.20887350697001472, 0.15706332684642, 0.20067393825316393, 0.20336061808755213, 0.19521626621181287, 0.1934256333425256, 0.40708420798317024, 0.21397714175618243, 0.24289627184622942, 0.005411074985582132, 0.09210758324459078, 0.17616498043635276, 0.07004341048300011, 0.008058491352719632, 0.07002424833008003, 0.27178344284041356, 0.24304338455008478, 0.511885391439187, 0.12424597725201803, 0.16999601515294793, 0.15393724229459327, 0.1496328843930802, 0.4009598840990444, 0.13864619752704943, 0.11263681343712217, 0.20945222064829172, 0.15591508716987734, 0.14438919487415658, 0.07110294615780655, 0.061271527272659276, 0.1406689640922747, 0.3947834740405993, 0.10385513678135083, 0.11299518923451801, 0.11604863074285443, 0.19692811125729437, 0.1661990499977779, 0.14747775607445068, 0.1772912723854586, 0.4461800492900698, 0.2918382581890865, 0.4201936042531521, 0.17111593375252, 0.3222404678281806, 0.29583252891996803, 0.671134646571421, 0.5848747206379926, 0.6201360363657149, 0.576300763172727, 0.5856222036325709, 0.7127054894459943, 0.5972819219651799, 0.5774030294309276, 0.6085522452744527, 0.07754760382769477, 0.1615407806664343, 0.1181245704185876, 0.09008471293989351, 0.0800721830940816, 0.1192264298679514, 0.12135733880680544, 0.16717051933149873, 0.12050285179959719, 0.21249749508655436, 0.2646525282969471, 0.21722376648468789, 0.2350112998786411, 0.17605257189982582, 0.41711115655895337, 0.20504872170731447, 0.16111864620536676, 0.2786112562570111, 0.38478283673602687, 0.4075713180036291, 0.301248699690742, 0.37041489265197536, 0.28179439739582135, 0.2943272913286532, 0.20293008559416903, 0.2574244307385919, 0.25187257988846845, 0.328099830117617, 0.4163041142461835, 0.4061867672337609, 0.28564341798530624, 0.17977520204417619, 0.21904633923827233, 0.34096983053341823, 0.37307644951278596, 0.2108351707939572, 0.21664866446744402, 0.21020796781048734, 0.22766733378938375, 0.19274542179295318, 0.20283935065899505, 0.19446337744495323, 0.20572305099291344, 0.24035073589862177, 0.22735839863566643, 0.186040939018278, 0.19877587729745216, 0.22481948693751197, 0.20039863837114513, 0.18688152568101424, 0.1763157168286773, 0.21233945338436044, 0.1801488849161278, 0.21252257246134332, 0.1733372524446144, 0.954485237375305, 0.1710696222721736, 0.9532655192505315, 0.20087519132757947, 0.9401043375714168, 0.1429566009892962, 0.15935127237935598, 0.21047652865340882, 0.855476601254583, 0.16954421723088364, 0.07358283661201981, 0.21021994540599165, 0.7773842340339598, 0.16885580392795496, 0.16811414395758406, 0.2100368319979573, 0.8721775661928937, 0.17541119250882597, 0.17461338018600947, 0.2104955081821227, 0.17017844571106666, 0.20599768957981945, 0.1827963041423104, 0.1873517851818991, 0.1933542490469048, 0.1785391812041307, 0.08808943281955794, 0.08516707469446427, 0.09483720768260029, 0.08595315025152361, 0.07820554303016103, 0.08641149484900978, 0.08241661331830652, 0.09520128356168955, 0.06570870999527778]}, "mutation_prompt": null}
{"id": "e7095c75-0ebb-41ba-bbe4-a1014302a915", "solution": "import numpy as np\n\nclass MultiStrategyAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(80, self.budget // 7)  # Increased for more diverse search\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F_base = 0.5  # Base mutation factor for exploration\n        self.CR_base = 0.85  # Base crossover rate for diversity\n        self.adaptation_rate = 0.1  # Faster parameter adaptation\n        self.local_search_intensity = 0.1  # Reduced to balance exploration/exploitation\n        self.mutation_prob = 0.6  # Balance between mutation strategies\n        self.elite_ratio = 0.2  # Top percentage of population considered as elite\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        # Track the best solution found\n        best_index = np.argmin(fitness)\n        best_individual = population[best_index]\n        best_fitness = fitness[best_index]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Self-adaptive F and CR\n                F = np.clip(self.F_base + self.adaptation_rate * np.random.randn(), 0.4, 1)\n                CR = np.clip(self.CR_base + self.adaptation_rate * np.random.randn(), 0.5, 1)\n\n                # Select mutation strategy\n                if np.random.rand() < self.mutation_prob:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = population[indices]\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    elite_indices = np.argsort(fitness)[:int(self.elite_ratio * self.population_size)]\n                    elite_ind = population[np.random.choice(elite_indices)]\n                    indices = np.random.choice(self.population_size, 2, replace=False)\n                    a, b = population[indices]\n                    mutant = np.clip(elite_ind + F * (a - b), self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n\n                # Evaluate trial individual\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_individual = trial\n                        best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            # Dynamic local search around the best individual\n            neighborhood_size = int(self.local_search_intensity * self.population_size)\n            local_neighbors = best_individual + np.random.normal(0, 0.1, (neighborhood_size, self.dim))\n            local_neighbors = np.clip(local_neighbors, self.lower_bound, self.upper_bound)\n            local_fitness = np.array([func(ind) for ind in local_neighbors])\n            eval_count += len(local_neighbors)\n\n            # Update best if any local neighbor is better\n            if np.min(local_fitness) < best_fitness:\n                best_local_index = np.argmin(local_fitness)\n                best_individual = local_neighbors[best_local_index]\n                best_fitness = local_fitness[best_local_index]\n\n            population[0] = best_individual\n            fitness[0] = best_fitness\n\n        # Return best found solution\n        return best_individual", "name": "MultiStrategyAdaptiveDifferentialEvolution", "description": "A multi-strategy adaptive differential evolution with dynamic local search adaptation and crossover rate variation for accelerated convergence.", "configspace": "", "generation": 99, "fitness": 0.3806527891401689, "feedback": "The algorithm MultiStrategyAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.25.", "error": "", "parent_id": "ec99e2dc-36dd-4b70-9fb0-6285f697cac9", "metadata": {"aucs": [0.7804788772692397, 0.7928539990811097, 0.7919672519863142, 0.8072726751597396, 0.796727392079026, 0.7978292266992326, 0.7952225781169711, 0.7991504264777964, 0.7990503158693809, 0.6319306074389724, 0.6105876202359382, 0.6260363352792608, 0.6209852745440992, 0.6108643881758515, 0.6359716787976246, 0.60626704798525, 0.6298653684110223, 0.637065952079696, 0.1360061558141631, 0.13625366497453228, 0.13466883409129737, 0.11937826433987664, 0.116388815180968, 0.12285622730632273, 0.1190272202369308, 0.13496876044351047, 0.11753092719968117, 0.11069788525246882, 0.1197020351424749, 0.11473262383502336, 0.10836015072919913, 0.12666868681776577, 0.12978084441256665, 0.11368026128578113, 0.12649322835783627, 0.12176319734598962, 0.9547139011520183, 0.9667329345707621, 0.9512349301094117, 0.9463555528948832, 0.9713563207609757, 0.9531374724502325, 0.9370058269472387, 0.9642924184364118, 0.9586872049789822, 0.44474772302032173, 0.45363263732381065, 0.44969151308506794, 0.47851859259160945, 0.439556205533428, 0.44031486943307396, 0.4617941868274248, 0.47390376739454054, 0.48252261803189966, 0.7136737340621842, 0.7587244884373552, 0.7086942266089631, 0.7731843966572692, 0.7486769043233774, 0.7718281972410772, 0.7754679929730187, 0.7841501147912532, 0.7496868088569799, 0.345270986594191, 0.31631446022403864, 0.40788654379164546, 0.3609303990760485, 0.41416747740108206, 0.44488256858495756, 0.33909191577416675, 0.4580751526742357, 0.39114940779485163, 0.2756731908340526, 0.35086296148431284, 0.31649651660065226, 0.3664064237582535, 0.30464183685730095, 0.4291348456812455, 0.3868756497349285, 0.41006149457897134, 0.4001552827492758, 0.30702303917621643, 0.3365117487104786, 0.3290341324677206, 0.31985500963616265, 0.324830743857897, 0.34472915798989945, 0.30604029544845823, 0.35494663866685305, 0.3336881919725212, 0.4885752198628225, 0.48226043000734575, 0.43158719529983924, 0.4325790906345054, 0.4893224894823819, 0.43566533498520876, 0.4873066510770314, 0.49662488765674473, 0.5107904266056718, 0.22036363797153535, 0.11743885031352219, 0.16921837625685787, 0.21155889160012975, 0.24844957464353734, 0.10824792264488847, 0.111113904609623, 0.16413762023627554, 0.11003840614478799, 0.3061975182598451, 0.28943766257089865, 0.2911709216516136, 0.30883174118816714, 0.31223226450073815, 0.30342550619098607, 0.28764505051606926, 0.28878043082851723, 0.2984152415389366, 0.6934112833741624, 0.7012550809803743, 0.708700376696613, 0.6783791787694393, 0.6856311264295651, 0.6657763520498666, 0.6871008397447929, 0.7052819108551553, 0.6945598020153588, 0.11002943645483354, 0.10432198046299856, 0.10472821331601112, 0.13077421168267678, 0.14555828147027916, 0.12050378905877956, 0.11039527484724598, 0.10531251209329207, 0.10756762970016953, 0.2062931988407194, 0.14939141351027863, 0.17931506393028307, 0.17094235175233585, 0.262265935470694, 0.1666401520981754, 0.23684421250571763, 0.23585058857863483, 0.23575979875464304, 0.41031511939163023, 0.3959871174183264, 0.41542585830602696, 0.4441421513833853, 0.4315297640708644, 0.42264363207944444, 0.42568436320340963, 0.4507060040578108, 0.43173371030137186, 0.32702820813368194, 0.28877189307924844, 0.28680955248241535, 0.3211985171857995, 0.28850380089651695, 0.28298284786109484, 0.3752878744427389, 0.3158312029246214, 0.35069029942655905, 0.20251355337545285, 0.2098713829783494, 0.2528620905362243, 0.21828060256535087, 0.19445334415404925, 0.1955717092707937, 0.20504380663666333, 0.20810981645734217, 0.19956752706859326, 0.2244093537894929, 0.2741455313807304, 0.40537955480924204, 0.209474849148944, 0.21254554622816224, 0.21284859675318601, 0.21321181303224213, 0.2706858209989611, 0.22403807653657837, 0.7346156504367523, 0.8142805003866069, 0.70285787622185, 0.7621904456533293, 0.19918634064236884, 0.19580209070075139, 0.16963176332765417, 0.16887739154782944, 0.7978017413086368, 0.7089608912196013, 0.20688506787256966, 0.21126071842548144, 0.2018400662274633, 0.20492605436583133, 0.6461554328895927, 0.20904587574245193, 0.21134979127128206, 0.2105376895019665, 0.1789348311774871, 0.1799243026376307, 0.19594880505757506, 0.1773506883126953, 0.17080677756587415, 0.18132834524899666, 0.1775147597837322, 0.18523862664361124, 0.19122207480762776, 0.08748889254746006, 0.08159395814805304, 0.08429459931127381, 0.09391758333808042, 0.08201045003572527, 0.0813877112873439, 0.08252285804615345, 0.07944740742933609, 0.08546785000203305]}, "mutation_prompt": null}
