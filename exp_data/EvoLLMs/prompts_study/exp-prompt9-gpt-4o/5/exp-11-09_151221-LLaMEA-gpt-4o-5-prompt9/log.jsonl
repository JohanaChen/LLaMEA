{"id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 0, "fitness": 0.16732779317190907, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.11.", "error": "", "parent_id": null, "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "5ce22d23-745b-4738-99af-5dcb32514510", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "aafeaed3-c584-4101-a104-6637b5ed4a33", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "690c8948-8bb7-4281-8788-6d2d6623d9f7", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.15  # Slightly increased mutation probability\n        self.crossover_rate = 0.8  # Slightly increased crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _adaptive_mutation_factor(self, fitness, idx):\n        # Introduce an adaptive mutation factor based on fitness\n        sorted_indices = np.argsort(fitness)\n        rank = np.where(sorted_indices == idx)[0][0]\n        return 0.5 + 0.5 * (rank / (self.population_size - 1))\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutation_factor = self._adaptive_mutation_factor(fitness=np.array([func(ind) for ind in population]), idx=idx)\n        mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Enhanced HybridGADE with Adaptive Differential Mutation to Boost Convergence Speed.", "configspace": "", "generation": 3, "fitness": 0.0705349611320861, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.06.", "error": "", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.21977821395245523, 0.14811142137415123, 0.19449352925729146, 0.09409875855272198, 0.08406478779670545, 0.13491976278572404, 0.16621327400310348, 0.13462685091377857, 0.13883999368645294, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05006794701569417, 0.03982622072132458, 0.029958089293787404, 0.05075572143874019, 0.036294816524466644, 0.04662140056058961, 0.031314828248105164, 0.029274307226931695, 0.034332168211805625, 0.02777099806868777, 0.008123138120079365, 0.013078658803627685, 0.027194135249281715, 0.013299862585038125, 0.012571522302188387, 0.004901206857825802, 0.026413619789563914, 0.02231404807814419, 0.053657548667809585, 0.04596326611857038, 0.04916302072487466, 0.0577504267496779, 0.0574587353265581, 0.03998312629618628, 0.06568720646758797, 0.05337040800360626, 0.05462809757030118, 0.06069480836146135, 0.051954952046805336, 0.0030767328211041, 0.036356863145159735, 0.029916185502429693, 0.0737499365956159, 9.999999999998899e-05, 0.027508217059092566, 0.04647041735671387, 0.14616962977527292, 0.10370276929724365, 0.1122251103548566, 0.1089988349383264, 0.11490770207229706, 0.03360286259783529, 0.06631280990930832, 0.07842394216093307, 0.11643023860111568, 9.999999999998899e-05, 0.0028161654014505766, 0.000178589783134675, 0.00729694087734678, 9.999999999998899e-05, 0.03595671301628922, 0.018472172936176312, 0.004804917433300582, 0.010369759738864004, 0.04992638366891766, 0.03587828468374332, 0.027745791988172952, 0.02257022680462273, 0.018308467464425826, 0.036467270825516374, 0.02498639281673609, 0.01713183663362272, 0.05631041429901562, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031873201767903425, 0.030214394478633944, 0.041218096872374876, 0.023383765857808214, 0.013440662997942998, 0.024286744500912394, 0.051492699826192756, 0.024038155964707264, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004795906106591641, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2090276111396686, 0.16974879816224842, 0.18401667302195124, 0.11313425116582987, 0.13764195232955867, 0.15819651900316445, 0.15998919891972696, 0.17703936765769268, 0.23207295231739056, 0.01764313430195341, 0.016923880054450113, 0.0248345478009383, 0.026508660768051584, 0.031231718942943187, 0.029391799402093466, 0.03211798352285933, 0.038098212616820115, 0.045334561173907106, 0.11248853893696831, 0.0882372167168689, 0.09170457667632947, 0.10938464199295761, 0.12081936520389969, 0.08994151882092849, 0.10247742768628265, 0.10084067380899764, 0.11976160982404149, 0.12027757421418683, 0.13159265942970144, 0.15309691735505693, 0.16143522442141822, 0.1604688314609244, 0.17923530141939514, 0.1554601782005337, 0.1763557464568164, 0.12996582718090088, 0.057721037740581016, 0.0799604988868019, 0.09748388217618653, 0.10318384026889948, 0.10225214361464319, 0.1175237165375469, 0.10458018993663987, 0.10184095695785922, 0.07890377290109918, 0.1489367285602966, 0.14324696382126445, 0.13429923977968317, 0.14723798747064887, 0.14218058984500181, 0.14805690287363926, 0.14928869403030365, 0.1328871838974406, 0.1618350801961136, 0.1527896880449905, 0.0970559274342262, 0.12225934312486064, 0.11520149617098674, 0.11577912519723832, 0.1244654363440475, 0.12119178307227407, 0.09937701646080654, 0.12789979495162807, 0.14519301082288572, 0.12720279376117216, 0.11068236708447654, 0.23686468898747082, 0.12453632836437478, 0.12227589486156198, 0.12359616800201989, 0.09643604708838482, 0.11739270052414907, 0.07578071642615247, 0.10147357320308692, 0.09500945989732956, 0.13953955631192494, 0.08345011753388787, 0.062455266689755984, 0.08808526712556997, 0.09522618647652648, 0.05396313027813726, 0.15597548491605517, 0.15100589457249503, 0.14969452588179533, 0.15768186097278902, 0.14314050142829104, 0.14656866933727142, 0.166806335959378, 0.1442478225437348, 0.1511093747097939, 0.05456705167079179, 0.04121671753333922, 0.04272723914886012, 0.039420021963458396, 0.04010897423864013, 0.05195663463908873, 0.04319411095765502, 0.04906016643533406, 0.04868518509638253]}, "mutation_prompt": null}
{"id": "1a9ec274-ac64-45b2-9023-87c0b63e15a9", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "84d65f60-296d-4a8a-b5fd-55e0d962c864", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "11c570f5-ba2c-4eeb-b6d0-42464eb07a8c", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "37ff1bdb-ab31-4eef-b19c-1d95f2ace8a1", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_scale = 0.1  # Added parameter for mutation scaling\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * self.mutation_scale, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.9)  # Adaptive mutation scale\n\n        return best", "name": "HybridGADE", "description": "Enhanced Hybrid Genetic Algorithm with Self-Adaptive Parameters for Improved Convergence.", "configspace": "", "generation": 7, "fitness": 0.16442479352908632, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.11.", "error": "", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.48071502319740256, 0.4904964088481294, 0.48062345778205007, 0.13020149001595216, 0.17773501413327308, 0.355383392293815, 0.4074021696639869, 0.3198363594380276, 0.18128880000820846, 0.10459058176666913, 0.14967768361601053, 0.06108049833539353, 9.999999999998899e-05, 0.14706862951368127, 0.0405005649280501, 9.999999999998899e-05, 0.027366516662192808, 9.999999999998899e-05, 0.08570017764225135, 0.08241633083595712, 0.09193127642281507, 0.11134887075378663, 0.11689591752430117, 0.08685527782001168, 0.09208480926486029, 0.08794450927615927, 0.09574759697460433, 0.09125607294755878, 0.062255957699427045, 0.06863722267567429, 0.0661155929342978, 0.07936224278396331, 0.08647299547284204, 0.06527970274477135, 0.08302304899576318, 0.06830440009593508, 0.14582561045267994, 0.1345826127962635, 0.09041511281059078, 0.07197453212810256, 0.3074294050817482, 0.27560081167546613, 0.07412882181253955, 0.11331916946081622, 0.18687429684208212, 0.11096396087064908, 0.10486183975362895, 0.06389193399456727, 0.10261018242474451, 0.15448114145541203, 0.17694872291028163, 0.08325971346657934, 0.26001268860004967, 0.09647157941187401, 0.39314032895427975, 0.20106751812643953, 0.20558384495749704, 0.5880287990359815, 0.6355239418792293, 0.2194976218815402, 0.1615472521674497, 0.217451021947775, 0.20238833560220681, 0.10587212458931261, 0.16467608082348673, 0.16956050991642624, 0.38002770011758435, 0.20192942077818765, 0.17238935849300452, 0.15609118092426866, 0.09250449588502452, 0.1835153318563404, 0.20473968703435053, 0.1315977657926245, 0.14090557965433692, 0.1215088659002107, 0.1497222356555492, 0.1108672754498341, 0.13349958843007548, 0.17843917540771326, 0.23321873809343552, 0.09767764476604313, 0.08600741863255823, 0.05451140841920643, 0.16524348762898722, 0.1614671042255872, 0.01612362167666559, 0.06017396169701861, 0.085797726891365, 0.09261495485221916, 0.23278339803555925, 0.16560944527403731, 0.21460432977466548, 0.11499677272587028, 0.12193302560161734, 0.05223726650375904, 0.17063702834003358, 0.1732799109987806, 0.09163373845547029, 9.999999999998899e-05, 0.1170780395875568, 0.0958503598890953, 0.05350102106369725, 0.07319648060634176, 0.13580890249581112, 9.999999999998899e-05, 9.999999999998899e-05, 0.052458369658225146, 0.09974444274645866, 0.08523565838249214, 0.14525906794917298, 9.999999999998899e-05, 9.999999999998899e-05, 0.02250751682036556, 0.05859162394827122, 0.1294424772034548, 0.007600466297295161, 0.4004105386590734, 0.566176592040945, 0.3455814971685025, 0.1848539130037351, 0.4109619101257743, 0.32088755254562107, 0.27733307510788896, 0.33817841719474595, 0.3747229162978831, 0.06952383134843598, 0.03898961708534188, 0.048861004224829085, 0.10949545755162493, 0.07879166316413633, 0.09099786915232921, 0.08859276103882185, 0.09034593481432807, 0.0981408755308637, 0.14673590696170136, 0.1359807246161332, 0.12282718897216705, 0.14081137556900591, 0.13583006844535161, 0.18315661231560876, 0.14379940770627164, 0.11922350181010155, 0.12314467820335462, 0.23461208244053589, 0.2468252525735415, 0.2586018289899452, 0.2882066238089056, 0.24200436255366575, 0.28761525080575967, 0.25336382796897783, 0.2524066750888444, 0.2315667637583343, 0.10273644865433396, 0.16144141215215146, 0.20199182788658543, 0.12577472891702124, 0.22277236929561084, 0.17459244927667883, 0.17678748278434342, 0.18705581193604992, 0.17306847431920847, 0.22382601837912675, 0.18817112656165425, 0.2150964837640016, 0.18599263873904415, 0.18099385259323664, 0.1869657753127537, 0.1908064369713509, 0.1794631944982461, 0.2077853332616585, 0.1693438173599383, 0.1633658955456, 0.1649979131573691, 0.17031146057450264, 0.1802785214502488, 0.1647441252498556, 0.17265916942537274, 0.1602342785233284, 0.1638361359497852, 0.1850887289234865, 0.17796195852154373, 0.17633594363775296, 0.4869563779449946, 0.16998858610600232, 0.23108348750697838, 0.1353240961019555, 0.15324253329450854, 0.18420406659589872, 0.4255646194851892, 0.3448681010411716, 0.4127625836032629, 0.31699278020346944, 0.18144954469228125, 0.16520010440452515, 0.1591732292853698, 0.18660982240695534, 0.1595418049370796, 0.1766529665766875, 0.1810896618254948, 0.1845350199885124, 0.16297602149423251, 0.1613267418123503, 0.17920462136571402, 0.16869524811721548, 0.17897316613415082, 0.17361748864724247, 0.08321468691204048, 0.07558536355554224, 0.08087829411325131, 0.07570929155660111, 0.07865275417675655, 0.07504919742252625, 0.08523702319416893, 0.07979519834145454, 0.06861236765639356]}, "mutation_prompt": null}
{"id": "4083364d-5c2d-44a1-89ca-339ef455b95b", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "0e1b82b9-d619-4d07-9779-f45d12b5e91c", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "45aa4310-d56b-429b-a2a4-dcc4539aac7c", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "3c8adaf1-a53a-492b-91d2-03ee2f1782f0", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "6890e4d2-7e2c-46a1-acb7-17c51b34b461", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "c02e737a-b595-466e-85d5-c049db286fa2", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "0b4fd9d0-f79e-45e8-af73-80e7de2d4c2d", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "152f50a1-4913-45c3-a326-1c74735fe2c7", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "7d2f9b13-2cd7-42d2-a185-7674ba89fe1c", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "e27ae51b-38a5-4f94-9fd3-019769dd3d02", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "9dfee6a6-07e4-4086-9060-90b85fb1b544", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "24b4c03e-e0b5-42cb-bf32-9fc0100b3d06", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "e5db6187-4f0b-41d7-8828-f87c158b5ea5", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "ef336207-112b-4a9d-a714-ccec54dc4700", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "71f88d19-5e6e-4d2a-a13a-7cd20108a722", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "668e752c-0828-41e5-92d9-48603748f5b8", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "e9012485-4d25-4d6b-a109-e6eb7549dcd1", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "4d8b5360-2758-4259-96e1-c9365d6f6cfb", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "0dbf6047-0eec-461f-994f-8b14292ffc09", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "467f579b-10a6-48c9-b9b8-b5d3d8cfc2b0", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "1752931b-551d-434b-aa6d-7b04865cc148", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "c358b6ee-576d-41bd-9639-f42c405469ee", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "447f1ed0-6a2c-4d8c-b9ca-a71833034e1c", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "935da593-70b9-4094-8b94-8d21ebf83c51", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "e2637b1d-d8f2-458d-8319-ebf469a36b97", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "ddbbfb9b-dd3d-4f41-8531-18a04ad97e1a", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "c51b842a-3ea6-49b6-ba00-44d0f2ce26af", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "3f34ddfe-ba7a-42ad-94c6-a5e769b7c20d", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "559d19eb-cede-4e6b-9a14-aea40702b179", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "bcef02df-c986-4911-9fde-b90a2f3bc3a1", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "04b1b79a-21cc-4de9-902f-9aa86fbdd006", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "29ed767f-6717-4498-b1e3-d665e4538333", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "db8a7cd9-7b18-4f62-b3bd-858fadf47f99", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "a0dd32f4-7925-49b6-98fb-9abd8c106871", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "086fd4b8-70db-4616-8295-97cafee22a58", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "86289865-255f-4674-b3a4-f3ce7b0e46dc", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "9f455519-6ea5-4f0b-af54-0378ba5c94b9", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factor = 0.8  # Addition for adaptive mutation\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            factor = 0.1 + 0.1 * np.random.rand()  # Dynamic adjustment\n            return np.clip(offspring + mutation_vector * factor, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + self.scaling_factor * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            if eval_count % 100 == 0 and eval_count <= self.budget // 2:\n                self.population_size = int(self.population_size * 1.1)  # Adaptive population size increase\n\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Enhanced HybridGADE with Adaptive Population Size and Dynamic Mutation for Improved Convergence.", "configspace": "", "generation": 44, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 25 is out of bounds for axis 0 with size 25').", "error": "IndexError('index 25 is out of bounds for axis 0 with size 25')", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {}, "mutation_prompt": null}
{"id": "151bf876-c898-4929-bddf-3f0efb695e90", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "12a5e8c5-6758-4128-9a34-8d0074d89eb0", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "02c26ae8-93fb-4d60-852d-4a768a4c0f03", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "34cc0cad-c2a1-4348-b26a-0eec75a8e21e", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "af868ca7-061c-4a24-8cf0-9c322f77aaa1", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "729ba453-a4fa-4299-b0c3-5797da670137", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        # Adaptive Crossover Rate\n        crossover_rate = self.crossover_rate * np.random.rand()\n        if np.random.rand() < crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            # Elitism: Retain the best individual\n            new_population[0] = best\n            for i in range(1, self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Enhanced hybrid search by integrating elitism and adaptive crossover rates for improved convergence.", "configspace": "", "generation": 50, "fitness": 0.13335140660143566, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.10.", "error": "", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.42121186546610123, 0.3379217218833117, 0.4223868387524926, 0.19861192394315286, 0.29822699061604285, 0.28205927178228063, 0.2424084144576778, 0.4105373930778924, 0.22138614089275865, 0.003104334414872234, 0.021402596001787066, 0.004622906272642058, 9.999999999998899e-05, 9.999999999998899e-05, 0.033519985263229635, 9.999999999998899e-05, 0.008429077876235036, 0.010081041701756277, 0.0676129255897917, 0.06144424485615496, 0.05767294544637047, 0.07084285838810733, 0.07884894951294297, 0.08241329291838151, 0.07668281608607774, 0.07539342509019786, 0.0963873944091691, 0.04837917963133964, 0.06406507639179948, 0.05931383563690673, 0.056120581363304556, 0.044779943074451545, 0.040035496387597624, 0.0330317758531552, 0.05827965400884749, 0.05606341901175327, 0.08319660353476643, 0.10400718619449889, 0.14689831266644182, 0.061615424857714984, 0.10446204576841611, 0.15160405182251668, 0.0755582222489527, 0.31786124222646617, 0.09810135446694934, 0.14899268173828406, 0.08069188127337257, 0.08467045886724811, 0.1318868286879784, 0.11168595561127681, 0.15769699042252017, 0.1387760571627139, 0.08021347599843798, 0.056600965048125396, 0.3170912253922894, 0.22504850725880587, 0.3215738483752284, 0.24630908892787162, 0.5265687504411652, 0.16026891387810194, 0.19111664451829014, 0.15711940627351173, 0.23788341722003759, 0.07348977913207877, 0.052499458965134416, 0.03055642321107299, 0.08013909537931962, 0.10308210433279041, 0.12609410003040156, 0.11368696435979486, 0.13342636739786917, 0.13861246488836787, 0.13163700829471803, 0.1029990446206106, 0.1019533618466878, 0.1229401186899669, 0.1160053025755704, 0.09680190846161896, 0.14647494445196263, 0.10425510340880939, 0.10038299991669686, 9.999999999998899e-05, 9.999999999998899e-05, 0.0404487699320214, 0.04822019326412319, 0.06399280531860474, 0.00025249936385918215, 0.005416418083415198, 0.0046870880647896795, 0.13245137571906107, 0.1284987288355156, 0.180051288644, 0.12033800620324797, 0.07848605831960409, 0.06810235941623688, 0.09911379711675383, 0.09297324387729622, 0.19413019471677606, 0.09323331292298265, 9.999999999998899e-05, 0.024679287933461413, 0.004821688134195923, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005111469704825344, 0.0003418425735659536, 0.015190578383260656, 0.022058396884825027, 0.069325017932785, 0.02491394377486189, 9.999999999998899e-05, 0.03391620093026959, 0.0002483166487891042, 0.07525398293646735, 0.03110874956927623, 0.07638264968435737, 0.3571324772634892, 0.3488855389334825, 0.3397267598399095, 0.281407891439136, 0.26850633402021806, 0.1920193679551102, 0.31146001101242027, 0.2563403561296359, 0.357123553600585, 0.0535709671389355, 0.03643872454726682, 0.01701097401713325, 0.08080743924687672, 0.04652141451479397, 0.07767766294747147, 0.07286221933732828, 0.08207531219005249, 0.0721225718741263, 0.11298738707158151, 0.10661647734517488, 0.13609341339194103, 0.14542672542034818, 0.12135667940115014, 0.14055146475831026, 0.14014719306632828, 0.1206791456174926, 0.1429753803661068, 0.16665497746960334, 0.2266176476749412, 0.19726464629204554, 0.24855622167783975, 0.22836076782549442, 0.22958523842757972, 0.16980896382452026, 0.2195383874226251, 0.1624290550170192, 0.11438734081811996, 0.1470780761231001, 0.14547163261220653, 0.19116915106769716, 0.16473905211824424, 0.20563963611103853, 0.1326273853639024, 0.14990385136469664, 0.12993616280774822, 0.17179639392355162, 0.17276364876428218, 0.18933424938852306, 0.17714860719127823, 0.16392158476494967, 0.17366802837528172, 0.18593650932818817, 0.17806218892418146, 0.19486637335800516, 0.16578966351920243, 0.15629861943108514, 0.16146697390073272, 0.16071455730984674, 0.15870518286597435, 0.15893492359020933, 0.16515968213709786, 0.16105713898199414, 0.16599180003301883, 0.15507138927960473, 0.1669994548443896, 0.13933552342782696, 0.3949754635859781, 0.2074181932307072, 0.269524835253244, 0.12666824041451707, 0.16456074618711314, 0.21158897110573205, 0.32971836934981624, 0.26253466416096827, 0.07562225152400714, 0.14517836651939164, 0.1487113459177013, 0.2352716660909384, 0.2511750219827902, 0.18385374080138073, 0.393838773841399, 0.17163856245753317, 0.16592373033167185, 0.16916402363955263, 0.17190974175801366, 0.15367963273974838, 0.15986093567651039, 0.1701381261333731, 0.15781484412776225, 0.16696082224106212, 0.06482095819312839, 0.05844494346433382, 0.05444541459654062, 0.07970554285355569, 0.06200517831562524, 0.06791920137742458, 0.06348542857052086, 0.06037362214411046, 0.06309566572663594]}, "mutation_prompt": null}
{"id": "d3636752-7541-4d5f-9374-39e237f58e7c", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "3436011f-6e18-4f57-a09d-83e4992f289a", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "98f02821-953b-4840-a548-5d488566f0dd", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "9bf29baf-3c32-41f8-b4b9-cf248d2a3b28", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "b39fa138-a243-4381-aa16-8048dd72f5ee", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "54350c1a-b462-43fe-a7b4-7d644925c8f1", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Hybrid Genetic Algorithm with Differential Evolution and Adaptive Mutation for Efficient Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.4474850825896802, 0.47628234729614705, 0.4654895202304269, 0.14453501052485174, 0.16216402114622308, 0.39668610196025555, 0.39029055095726606, 0.3223464537891614, 0.2524075490120583, 0.16101194506424776, 0.09937754332258553, 0.24092705975086703, 0.022675109368796798, 0.06111204660764469, 0.06813239897053913, 9.999999999998899e-05, 0.02429595555283337, 9.999999999998899e-05, 0.0892948149801781, 0.09485405777334222, 0.08833774417665641, 0.09194202759008663, 0.08505753061407573, 0.08951855558348198, 0.07934994345990565, 0.08916016444113828, 0.10208377315623307, 0.08640249710432202, 0.05399943803679308, 0.07375870502515591, 0.06828868806535415, 0.08077589957364995, 0.06517007289928967, 0.03767950772270201, 0.0970143370496136, 0.06746043768534615, 0.31520889195544666, 0.10434120443505202, 0.1025198730351854, 0.07420835832225092, 0.33683851297528966, 0.335487343249285, 0.07745855066342866, 0.11379461894813925, 0.20624968176465874, 0.09997265614133555, 0.12142196248550119, 0.05767575667024594, 0.1051666648571552, 0.20837375359168286, 0.20134175183255354, 0.07646554794664318, 0.2108783548088491, 0.08772782270497992, 0.2165391120568917, 0.663525029768841, 0.20522973621655993, 0.33173879681713814, 0.5299579523520701, 0.3447458797565911, 0.17074950210630557, 0.36454318180749, 0.19468306705938787, 0.09853189666101425, 0.10055001335657576, 0.13375246735250002, 0.3597940408281367, 0.19527104032405118, 0.17815349888277143, 0.16052521615930093, 0.0956926314025226, 0.2404754192994093, 0.14968124213102907, 0.1424176660137345, 0.11886568196771607, 0.12204424699558714, 0.14692107436146196, 0.11890764162008671, 0.13596855627157878, 0.1511038255027417, 0.09874829971596588, 0.0741680280345276, 0.10754733188212762, 0.030832809621617163, 0.126777139855333, 0.1010909365529471, 9.999999999998899e-05, 0.08066189706191129, 0.06725118881367076, 0.08717010942969117, 0.15137533113761603, 0.15124902711594257, 0.33698813446170117, 0.07983854011813185, 0.12404555527576544, 0.04043621565779432, 0.13796940670985058, 0.13903165976537035, 0.09368022386714181, 0.0016912690282903098, 0.11951994650915188, 0.11107344903014582, 0.05572711549800202, 0.05299228225027597, 0.10119253925365579, 0.006258931977767834, 0.046826894268258035, 0.072338428418675, 0.09728002713274253, 0.1266595749249001, 0.17590084999468214, 9.999999999998899e-05, 0.0046831947775796134, 0.024472166557865438, 0.07776893891764614, 0.10987319566035125, 0.0479488255262851, 0.40370710704334345, 0.5038033843039609, 0.33550032196716173, 0.20312548161486144, 0.3924291881387909, 0.3510101957381234, 0.3171398718358942, 0.37608050560030737, 0.39625006553356446, 0.06154124338735878, 0.03978710453953771, 0.04081312534360659, 0.10398431566115618, 0.0776079448824728, 0.08310792947878987, 0.11295289739715586, 0.08228105963802412, 0.08547043632765872, 0.14451242295943667, 0.13000405713726537, 0.1352014473587695, 0.14922544778539726, 0.13583006844535161, 0.14367012570810767, 0.14779451577371894, 0.12343447653477413, 0.12931526772035518, 0.18516210602368155, 0.27013855973086653, 0.2907976152852677, 0.2906266536422719, 0.2246094513741247, 0.2605834636715876, 0.31508898037888444, 0.23177373436223647, 0.23262573370516115, 0.13362198084688082, 0.19807169075411468, 0.16330600836384124, 0.16392927852068861, 0.21732316795125628, 0.18963743954214374, 0.24538928898142642, 0.21167767206078847, 0.16379102995793215, 0.21889162594963985, 0.20819853252215392, 0.18579302008484455, 0.1811209109869627, 0.18181814960359732, 0.19778806433762453, 0.1949537228418693, 0.18568641478298842, 0.18164374322062582, 0.16949257309571508, 0.17515144864480592, 0.17393446110396582, 0.16811330821587622, 0.18111706240971726, 0.17372046431561938, 0.16761256073662423, 0.16405093759285627, 0.16572189781566082, 0.18769025751753787, 0.17834833657802263, 0.176116666603367, 0.41024087731755043, 0.19690994875953438, 0.2270922600804015, 0.13539841228606198, 0.15293512765173922, 0.25014734123423854, 0.47389131534287154, 0.3905526340470695, 0.4423748779587977, 0.35919576212891424, 0.19332641800030992, 0.19392300464780587, 0.1596009666781545, 0.18656495922719252, 0.16923682115112826, 0.16924703060507107, 0.1789525473600705, 0.17838582569671413, 0.17442108087487318, 0.16270440518543838, 0.177548980373881, 0.1699300083388645, 0.18583185543931457, 0.17744896048143177, 0.08176574986958418, 0.07925659795038487, 0.07243617169928207, 0.08232171989646009, 0.06830380417258242, 0.07456849695501788, 0.069999815812119, 0.06628029649412182, 0.07897515010373934]}, "mutation_prompt": null}
{"id": "7e160d97-9cf1-4748-ae91-31ed3315a9e9", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.15  # Increased mutation probability\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.elite_fraction = 0.1  # Introduced elitism\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:num_elites]\n            new_population[:num_elites] = population[elite_indices]  # Preserve elite\n\n            for i in range(num_elites, self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Enhanced Hybrid Genetic Algorithm by adjusting mutation rate and introducing elitism strategy for improved convergence.", "configspace": "", "generation": 57, "fitness": 0.19690322864984988, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.14.", "error": "", "parent_id": "f62dd58d-5025-4812-ad54-a6442306bcc0", "metadata": {"aucs": [0.6247114153021083, 0.42738253376852586, 0.586214198386817, 0.5106272365552055, 0.6293938241851913, 0.46923198934866517, 0.4160683137328659, 0.46955861214096006, 0.4429959184543685, 0.19540489436300956, 0.031562762202257955, 9.999999999998899e-05, 0.007583759945297475, 0.06644086047014475, 0.00011220776841369684, 0.10583931459645068, 9.999999999998899e-05, 0.07440988201539456, 0.09033478130540717, 0.08656783934375856, 0.0824928561153474, 0.09034325096552787, 0.08761930392429562, 0.08352448705774274, 0.08018564594197763, 0.09780380166033031, 0.08212512558017426, 0.06990059745502675, 0.05467238939467878, 0.07347203928296897, 0.08741576547233831, 0.08572852717753454, 0.06469576080757922, 0.07192210026596335, 0.07343127254800552, 0.045573026325567256, 0.2843341159923599, 0.13157071939340725, 0.11509788056463255, 0.2509075743582396, 0.4900583005294211, 0.5283215684754967, 0.25341700122144484, 0.554313727773017, 0.6869334929694377, 0.19529891741896677, 0.09697968317684302, 0.2408326395600725, 0.15917070645444054, 0.09796096157026546, 0.13756578402327546, 0.020923527808422326, 0.24721842007340877, 0.22576940597363204, 0.20532330909455154, 0.41813451099752785, 0.6389425892393552, 0.23982933007835494, 0.26666132992772607, 0.553584590195674, 0.20024038421277912, 0.16798467596684807, 0.22455866415050274, 0.11669036279467093, 0.11323486887981582, 0.12740680428493234, 0.1265939498787959, 0.08973793798816565, 0.10498503057806197, 0.1372422796079027, 0.13432635619290068, 0.14785019393770105, 0.1368204127373338, 0.1408984291235873, 0.16483955316039178, 0.18109815481214397, 0.24015233208633546, 0.11581893806056198, 0.15071335337265468, 0.157872266523707, 0.1509123343996478, 0.2023661790154765, 0.18467676532174615, 0.042041699865024595, 0.11530449984014701, 0.22062684907056396, 0.08282086905126418, 0.06555815452631908, 0.08624250942655975, 0.1348902927391118, 0.13610918432433594, 0.33976196915065804, 0.2915344818234735, 0.10461504650187958, 0.2802194601057554, 0.11308647867692034, 0.1370557616636532, 0.19970127722320363, 0.0888053271373761, 9.999999999998899e-05, 0.09027108647076076, 0.08329260137243677, 0.030337763937414053, 0.05311761841023033, 0.12598552256202933, 0.08899361975258346, 0.12065337449214042, 0.12126029730624233, 0.005515842083595679, 0.14119270473440682, 0.18854695411591982, 0.1998039620255413, 0.068076685101494, 0.026799031118520555, 0.12117494858960143, 0.2404708148798297, 0.13072498625926487, 0.42631211618989917, 0.4040625276240303, 0.3614440532816341, 0.3384325518531791, 0.45242246333853775, 0.3645372519441682, 0.47364243547596674, 0.38512398333636944, 0.4020832926381962, 0.06435315382364115, 0.06626901832542809, 0.06581483668273125, 0.08196890499981513, 0.07654322184219653, 0.08489060385262548, 0.09934977113941346, 0.09397922452479435, 0.09406917721928876, 0.13321533046203826, 0.13209730595894575, 0.11175543104785579, 0.1478576168072363, 0.1338627662210572, 0.12087071224924062, 0.13652609765096535, 0.16022625369874566, 0.1364237311333072, 0.2531139413788692, 0.2819788828732398, 0.24099070018803592, 0.3410806143071258, 0.25677074423163715, 0.2935336648116311, 0.289172740702473, 0.28070312634583783, 0.3120511931357146, 0.17852400590647122, 0.20491513630485747, 0.2116619586833356, 0.2453688835325002, 0.27399214547140704, 0.18968231292475457, 0.23669773475084877, 0.18614819460741983, 0.15294464989274836, 0.2125358386884052, 0.210528033769955, 0.20769908932473247, 0.21351050312325237, 0.19665326095162416, 0.2015692797188715, 0.1973344659021633, 0.20044914538171088, 0.22631635903620662, 0.16607672436337872, 0.18660490233187188, 0.1700340950490027, 0.16631565483919708, 0.19072727849088544, 0.17236779356813148, 0.17701643392317856, 0.1867547946202206, 0.1622526614225358, 0.17693304244339048, 0.2976232609184568, 0.41013706831982644, 0.1534505417092994, 0.5035086201018272, 0.5952824126239691, 0.11717053052067494, 0.5198437546150152, 0.33775904288889935, 0.5677221021867467, 0.25567238579621143, 0.256672069397168, 0.36893460639592834, 0.18688070714036142, 0.35746047168586403, 0.16097091949565656, 0.15349410245069117, 0.19054452152620027, 0.15769860492323118, 0.1647783859080546, 0.1734904072143545, 0.1747317844200723, 0.16840823765451296, 0.17926949355656796, 0.1958186196444991, 0.1547217833208686, 0.16662948911717812, 0.07585435529737428, 0.0736419146208418, 0.0845078731601896, 0.07069173992683897, 0.07482358395164679, 0.06604361539698256, 0.07391767941134009, 0.07930095177642871, 0.06808964882007496]}, "mutation_prompt": null}
{"id": "7bddcd39-6108-4131-99e4-455a06b3836c", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.1  # Adaptive mutation probability\n        self.crossover_rate = 0.8  # Adaptive crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.elite_fraction = 0.1\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        if np.random.rand() < self.crossover_rate:\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring, generation, max_generations):\n        adaptive_mutation_prob = self.mutation_prob * (1 - generation / max_generations)\n        if np.random.rand() < adaptive_mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func, generation, max_generations):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial, generation, max_generations)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n        max_generations = self.budget // self.population_size\n        generation = 0\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:num_elites]\n            new_population[:num_elites] = population[elite_indices]\n\n            for i in range(num_elites, self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func, generation, max_generations)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n            \n            generation += 1\n        \n        return best", "name": "HybridGADE", "description": "Adaptive Mutation and Crossover Strategy for Improved Convergence.", "configspace": "", "generation": 58, "fitness": 0.19610085881617184, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.14.", "error": "", "parent_id": "7e160d97-9cf1-4748-ae91-31ed3315a9e9", "metadata": {"aucs": [0.5674679489975274, 0.6763225551878292, 0.7591336669870132, 0.30126495392064734, 0.5142570070592012, 0.6605704871091658, 0.4233116796133072, 0.4629586982621161, 0.36508318041042687, 0.06940971319163114, 0.05754218615278239, 9.999999999998899e-05, 0.08540306178746482, 0.09379096041107482, 0.017832498126308383, 9.999999999998899e-05, 0.06497877395057172, 0.005349688470225211, 0.07525339733246095, 0.1025055886074373, 0.10321244870764401, 0.08627142510377761, 0.09655071481371635, 0.08796406390214984, 0.09688414991403482, 0.09330716760914726, 0.08740470485172469, 0.07636885432854612, 0.07844949395960432, 0.08484505368607731, 0.08959666181105663, 0.06427349731113208, 0.050339074514897386, 0.06583704220109698, 0.09116989478712278, 0.0667468007764015, 0.15592037729425157, 0.08315535722879308, 0.7114874716144912, 0.07974588841176866, 0.10978111088028286, 0.11835859404812377, 0.32984949572324906, 0.08949650410118304, 0.16128189250379732, 0.22084511311862087, 0.21268155993112492, 0.11036411147638392, 0.10013536179278126, 0.1333537349060553, 0.21296525987184356, 0.10368217908627142, 0.2678513054903523, 0.16296989221137737, 0.7203106103718626, 0.5459665103785906, 0.14826530936933102, 0.35621673239703555, 0.2630802532425962, 0.5599116631852663, 0.21569181849342345, 0.1493015898166863, 0.3537665603295258, 0.21045876206718994, 0.11710861684076357, 0.1850134558454387, 0.1614367960737716, 0.1857817994347576, 0.11971954373858384, 0.18619187614327315, 0.15051027072486578, 0.13906492834627848, 0.12224555716775887, 0.12778339548703133, 0.28932292224462497, 0.18058397762725087, 0.18865155491784658, 0.12719401774628025, 0.13065980885241713, 0.15521926917954043, 0.1907982575780217, 0.16726252126302066, 0.23546112617824722, 0.044320391341020504, 0.15981622250630712, 0.3422262694182704, 0.019657877098179788, 0.05391479245574815, 0.07336776125911548, 0.12130424872655532, 0.38867990742546166, 0.1907536839733982, 0.21523480379693516, 0.23199912205606488, 0.1061043097124601, 0.08571598729157026, 0.23406458780152983, 0.13693736635829368, 0.11650624605976245, 0.03737350524383254, 0.12070236685907643, 0.11200528263670473, 0.10279160331198056, 0.1199937763886968, 0.07266967057557772, 0.14940683576713487, 0.08869575931579077, 0.11175146112473389, 0.06225010426219091, 0.07924206056493965, 0.08375642289297924, 0.023677107888175897, 0.06654187496395592, 0.026967940985603178, 0.17343685399039455, 0.20709235915719715, 0.09037320081542843, 0.35429732074814124, 0.5730542338974391, 0.35689906365919455, 0.4067028888509835, 0.5787685406170371, 0.2940512001960277, 0.43871912282207326, 0.5252782700042127, 0.5994216044751421, 0.06856956910926293, 0.055746861555775684, 0.08317143303049268, 0.09128660392828647, 0.05940068921034958, 0.08147962924155594, 0.09303020174490884, 0.09494648585589582, 0.07961713266637194, 0.16844096170865996, 0.1544245989760431, 0.12083656415802213, 0.14455540055928617, 0.1257108126176949, 0.15776808360049055, 0.1463812639132679, 0.13312298827575486, 0.14039337337641333, 0.23500821651139747, 0.296522204384987, 0.2448035677086703, 0.3390093261489303, 0.23365004551834312, 0.2861447347287641, 0.34088958497230726, 0.3483505032361024, 0.2815359722323565, 0.23003349351772417, 0.24958129720578537, 0.19669050322587078, 0.28076526626673837, 0.24307239244475853, 0.31577408032154275, 0.23700964678736713, 0.30824326980853034, 0.18857661321765995, 0.19523093954042858, 0.1861077637773222, 0.19230620099822893, 0.2075783303937394, 0.21654403229509167, 0.1850197944229799, 0.20626196330058288, 0.21938965135178456, 0.19382703032491788, 0.1615460817501676, 0.17165727000694764, 0.1879781442018449, 0.16546290049749712, 0.17693193790580608, 0.1859427254589553, 0.18264373067758222, 0.1654576860154391, 0.17512799926854206, 0.28857877000702403, 0.2655294657962889, 0.16217535934184635, 0.1579982646352044, 0.1628889683114506, 0.44361119863171916, 0.12371328545493909, 0.15923071462512473, 0.14740965554059293, 0.5234795644366022, 0.15025483496625458, 0.37451066880589956, 0.38212188075290865, 0.33011884091096166, 0.2934196802118819, 0.2058305122912123, 0.3440585154721638, 0.28505850670919985, 0.1873002227666991, 0.17470483405505544, 0.1672143621657144, 0.15469798609109386, 0.177413557916546, 0.18395710539693777, 0.1742112121846099, 0.18977279556772841, 0.16376137678725122, 0.09228895778375878, 0.07722228492265326, 0.06873979921113293, 0.08721094291980391, 0.07398019413800538, 0.08448460015740189, 0.081273615387367, 0.07337179087745715, 0.07134780722572454]}, "mutation_prompt": null}
{"id": "2155f422-22f4-41d2-aec7-ca715fdc2db2", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.15\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.elite_fraction = 0.1\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        diversity = np.std(parent1 - parent2)\n        if np.random.rand() < self.crossover_rate * (1 + diversity):  # Adaptive crossover\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        diversity = np.std(b - c)\n        mutant = np.clip(a + 0.8 * (b - c) * (1 + diversity), self.lower_bound, self.upper_bound)  # Adaptive mutation\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:num_elites]\n            new_population[:num_elites] = population[elite_indices]\n\n            for i in range(num_elites, self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Enhanced Hybrid Genetic Algorithm by introducing adaptive mutation and crossover rates based on fitness diversity for improved exploration-exploitation balance.", "configspace": "", "generation": 59, "fitness": 0.2393733170017269, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.18.", "error": "", "parent_id": "7e160d97-9cf1-4748-ae91-31ed3315a9e9", "metadata": {"aucs": [0.6421743905090479, 0.6717020118401242, 0.5378176832901458, 0.4748249444252264, 0.535820233609771, 0.7199110933316066, 0.5793262170925216, 0.6320767113811596, 0.594806865215757, 0.22843392877353874, 0.14308594272362518, 0.2660027135993698, 0.2923230114212976, 0.24084894933462642, 0.27485368224391626, 0.19064246657484174, 0.2699166067866948, 0.22344012654908185, 0.10704799809772181, 0.08575664246574943, 0.09860707247319445, 0.09404260202570314, 0.09513914323503181, 0.08026086628811702, 0.11261871887455999, 0.08652117091733524, 0.10131717390431627, 0.08450778632665246, 0.06879288980873133, 0.07001256866388572, 0.07698021938456345, 0.07942952206383003, 0.06370614369029082, 0.0629218364671511, 0.07217133181637359, 0.08637823598456651, 0.4980212937045603, 0.869602677246745, 0.6351735094018282, 0.17161360991800845, 0.6339722778147999, 0.6890034622199067, 0.793188745933201, 0.7086552426671385, 0.6937678835948311, 0.2250520983423192, 0.19922569072070528, 0.22719922289978578, 0.20653700544755915, 0.21146552058651014, 0.20418357383428565, 0.19869759200216364, 0.14870555811112374, 0.2074976798324657, 0.6459259315882784, 0.648225433662905, 0.650079610661288, 0.6765020604544567, 0.6690609115336531, 0.467283108588712, 0.6017672823315339, 0.4651825278817945, 0.6038487844770358, 0.13448685854141096, 0.1341707259535524, 0.09930395536897918, 0.12869736554173505, 0.18602087860184047, 0.13672692216165083, 0.12493078110130573, 0.12767623168336306, 0.13479084595166113, 0.11115387332696025, 0.21212212026766797, 0.1254343161204894, 0.1587247961659921, 0.1512754026443155, 0.11727618362633618, 0.18685712696517043, 0.17493584502699921, 0.12816158021681767, 0.1291921996218912, 0.2670782279209497, 0.124076412940889, 0.13319371460251261, 0.12105165674860496, 0.14461996725038917, 0.19473993858016514, 0.14286838704691018, 0.13556208187632024, 0.24830113315066182, 0.16157492761655323, 0.2479909495683631, 0.18733012321077902, 0.2520032839408999, 0.17328172375007966, 0.21980454250068826, 0.19555089055145736, 0.18779456101624015, 0.10912932898462391, 0.13438412234635866, 0.06905017356854548, 0.12331529357222704, 0.09973910839939182, 0.12490110975646385, 0.15467494921778557, 0.07101120952452689, 0.0700791081658203, 0.17631271645818836, 0.24694915490924974, 0.18641231760040788, 0.20338862354116893, 0.19143500051370943, 0.18086942615481783, 0.21027659424532896, 0.23034686461877407, 0.2445669959550666, 0.5774743110795042, 0.6009010532467953, 0.5661660318447606, 0.48677744231648135, 0.48321097095443133, 0.3909856176500971, 0.5220081945294528, 0.5169226253472615, 0.547681719950079, 0.098357078495236, 0.09044756309358504, 0.09262408555249513, 0.08558900475471709, 0.09780348463321786, 0.08598745130217833, 0.08018687403005131, 0.1220946994819525, 0.09351516622878242, 0.15434818888554613, 0.1310410152485718, 0.12772492125872503, 0.13288378245589427, 0.16298627000710897, 0.14059327272472788, 0.13159245904383465, 0.14117231877510839, 0.14677192572340025, 0.2382819636479342, 0.27084012787706946, 0.2943620203018862, 0.2717416340737089, 0.29646497046672193, 0.2919793416343893, 0.24613714808956189, 0.32637137352732604, 0.2854673026837473, 0.21381780801405514, 0.19227208435855114, 0.22164394444283797, 0.23252321983180224, 0.2086756933959395, 0.23601140326381365, 0.21111905482702042, 0.25798022290372613, 0.1932534031286952, 0.17401159609736117, 0.1930749466879399, 0.1727393147600642, 0.1845003853992081, 0.19833847808323868, 0.1775907152884807, 0.19727016129343478, 0.18493557071064803, 0.1716421541812715, 0.18480382184022204, 0.17121045536690982, 0.16576915332428865, 0.16619888232550728, 0.1652908073871322, 0.16912954451757867, 0.16802089898458394, 0.17188055433372662, 0.1577457883424177, 0.2709593166919866, 0.17097988151784116, 0.14864226604299002, 0.3428769508249213, 0.36428634091649814, 0.17927364228159226, 0.16957906384453414, 0.16661002073399378, 0.30084217008411107, 0.35889631111069986, 0.44948201960542666, 0.21418957427891627, 0.1498060612173635, 0.2533694610958317, 0.1512701359346844, 0.2004636958720326, 0.2146323899417525, 0.23168762548764166, 0.18892554066718048, 0.1704150364995921, 0.17505681567115572, 0.16960080669429423, 0.16858191937696232, 0.16063425488431515, 0.17113672641015842, 0.1792751748575392, 0.16637680872418292, 0.06736978140131122, 0.07552499857695472, 0.08268958393551584, 0.07808660264686218, 0.07737034626800865, 0.07477407598272545, 0.06523869459001175, 0.07978198448673157, 0.0857464938691106]}, "mutation_prompt": null}
{"id": "6af5ade6-6562-4e54-85cf-4bf5db01eaa2", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.2  # Slightly increased mutation probability\n        self.crossover_rate = 0.75  # Slightly increased crossover rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.elite_fraction = 0.1\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        diversity = np.std(parent1 - parent2)\n        if np.random.rand() < self.crossover_rate * (1 + diversity):\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.normal(0, 0.2, self.dim)  # Changed from uniform to normal distribution\n            return np.clip(offspring + mutation_vector, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        diversity = np.std(b - c)\n        mutant = np.clip(a + 0.9 * (b - c) * (1 + diversity), self.lower_bound, self.upper_bound)  # Slightly increased scaling factor\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:num_elites]\n            new_population[:num_elites] = population[elite_indices]\n\n            for i in range(num_elites, self.population_size):\n                parent_idx = self._select_parents(fitness)\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Improved Hybrid Genetic Algorithm with enhanced adaptive mutation strategy and elite preserving for faster convergence.", "configspace": "", "generation": 60, "fitness": 0.22492301125957437, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.17.", "error": "", "parent_id": "2155f422-22f4-41d2-aec7-ca715fdc2db2", "metadata": {"aucs": [0.5348337102724028, 0.5669856788139616, 0.5626137190720604, 0.544386788078299, 0.46010205082208433, 0.6066747375144551, 0.6061277431430854, 0.5815435718771045, 0.4671590686870648, 0.1763085415206016, 0.13155874481952246, 0.20374366234112973, 0.11024636332920768, 0.18184301036497907, 0.21614651955294417, 0.2067184500163448, 0.07187378685890167, 0.15394602571238247, 0.07996318032826821, 0.08883469644128761, 0.08128545502798656, 0.07917012948373137, 0.1067532035553439, 0.07518891866216926, 0.0869506428520197, 0.0971743518547532, 0.08198927644728315, 0.07564412919818186, 0.06245278327696979, 0.07269089520103211, 0.07887561787065533, 0.06409748423742223, 0.06313019521795138, 0.0704809239445432, 0.06009330599208329, 0.05794507460495957, 0.813141909569456, 0.6830172526516958, 0.7826892110374867, 0.844091049337311, 0.7092410802101669, 0.6117813349121451, 0.8942415436737808, 0.6867222678283529, 0.7114581500331326, 0.21218595423837938, 0.23202474806741002, 0.2613793948499108, 0.19791206598959177, 0.19985767090555762, 0.23514529028740827, 0.2274327608478961, 0.22412763057614238, 0.226367064517351, 0.5574117936456926, 0.4072128634134127, 0.5297125161647303, 0.6044454638282626, 0.6031154569874342, 0.5451018837863395, 0.6434980222180667, 0.49279693949140824, 0.4719439651074243, 0.13077708545431266, 0.05347428116863684, 0.07390022239209426, 0.12247467783478028, 0.0959434186227327, 0.22151102635724718, 0.15032701859606246, 0.12956990881022923, 0.12845405223583894, 0.13867484980838796, 0.16256584893814852, 0.1360538650866876, 0.11332161367369187, 0.12815599721909932, 0.16217196138019263, 0.23640066931103643, 0.1260345642080578, 0.12330430816776683, 0.0832252114871268, 0.09849214798386963, 0.11913334004094156, 0.11554113288728673, 0.037204902405687634, 0.0673441585793837, 0.07273692452042446, 0.2094980441652874, 0.17990145150179448, 0.16242059830786093, 0.12021774331236934, 0.2426702033767424, 0.2242198852409102, 0.1334079885183581, 0.09309064248154542, 0.22859405475839345, 0.18886204018685715, 0.15700003704271626, 0.10201022451493758, 0.07911742430214075, 0.161160108549544, 0.11792662485106398, 0.08463757706751218, 0.13724504743242527, 0.10930790353697195, 9.999999999998899e-05, 0.09616822640929823, 0.20337809950219965, 0.16369492434647415, 0.24416778291804542, 0.1696415025924345, 0.21373924639300823, 0.14790541744984764, 0.2269640071962593, 0.2131010142244224, 0.19131364893122438, 0.40207042429804585, 0.5469905822657343, 0.4521335828899179, 0.43409079096033876, 0.45652053232965806, 0.4330951968890461, 0.48773939017728285, 0.4893367260190641, 0.5034333733096529, 0.10067478369269489, 0.1014732029917097, 0.07834975558086843, 0.06956117510606852, 0.08475284524737414, 0.08416293845530398, 0.07957685384501167, 0.07718647893905872, 0.08773500201329443, 0.13030951137022162, 0.11908580991394846, 0.13529826955139557, 0.1318476625460604, 0.15315229780567097, 0.14651119477829122, 0.14969319229111266, 0.125681847493742, 0.13606359354674247, 0.24751435014084222, 0.2661008072200687, 0.2746927055895503, 0.29082398817200505, 0.30767669256863883, 0.29102178821771807, 0.23413006676919312, 0.29895380690190887, 0.29276512353970796, 0.19395172143874662, 0.21384659543864037, 0.21403314355402858, 0.2403873158455111, 0.18930255503784932, 0.21009072703985598, 0.18827910810625081, 0.18944292698017318, 0.1573226993973984, 0.17923725940560942, 0.17551212324648424, 0.18998477036503048, 0.162764908019293, 0.1857009903611787, 0.17660533852404425, 0.1774272841190686, 0.18585820450347434, 0.1801931713094993, 0.1619942546098575, 0.17641011253167693, 0.1710244253837403, 0.19511991649381355, 0.16556756668186445, 0.16617615451133427, 0.18323818896217414, 0.17240568337044693, 0.15986933075109588, 0.16955529008439285, 0.16352337308569642, 0.19164902151242968, 0.26032606731781704, 0.2179288260053276, 0.17554473471848342, 0.16596652170570925, 0.16919991817716185, 0.2189196290624944, 0.28395645204734665, 0.12433410788877008, 0.22279303059266153, 0.14931862392915551, 0.2303304033159871, 0.15087458249736996, 0.28135226243879086, 0.27943593544012224, 0.22359408688850002, 0.1734376063593972, 0.16086928502321585, 0.2045255134670898, 0.1659345927704735, 0.17893329522729529, 0.17241499180283404, 0.16925809023342497, 0.17107311872266895, 0.17058577869361857, 0.08294701780928082, 0.07253480748713659, 0.07355457290632261, 0.06834611287439296, 0.08722892721047248, 0.0682749576787619, 0.08789703872694021, 0.0676847438860817, 0.06547191761587479]}, "mutation_prompt": null}
{"id": "c62432da-1ece-4d40-8301-85ce41db2727", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.15\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.elite_fraction = 0.1\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        diversity = np.std(parent1 - parent2)\n        if np.random.rand() < self.crossover_rate * (1 + diversity):  # Adaptive crossover\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        diversity = np.std(b - c)\n        mutant = np.clip(a + 0.8 * (b - c) * (1 + diversity), self.lower_bound, self.upper_bound)  # Adaptive mutation\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:num_elites]\n            new_population[:num_elites] = population[elite_indices]\n\n            for i in range(num_elites, self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Enhanced Hybrid Genetic Algorithm by introducing adaptive mutation and crossover rates based on fitness diversity for improved exploration-exploitation balance.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2155f422-22f4-41d2-aec7-ca715fdc2db2", "metadata": {"aucs": [0.6421743905090479, 0.6717020118401242, 0.5378176832901458, 0.4748249444252264, 0.535820233609771, 0.7199110933316066, 0.5793262170925216, 0.6320767113811596, 0.594806865215757, 0.22843392877353874, 0.14308594272362518, 0.2660027135993698, 0.2923230114212976, 0.24084894933462642, 0.27485368224391626, 0.19064246657484174, 0.2699166067866948, 0.22344012654908185, 0.10704799809772181, 0.08575664246574943, 0.09860707247319445, 0.09404260202570314, 0.09513914323503181, 0.08026086628811702, 0.11261871887455999, 0.08652117091733524, 0.10131717390431627, 0.08450778632665246, 0.06879288980873133, 0.07001256866388572, 0.07698021938456345, 0.07942952206383003, 0.06370614369029082, 0.0629218364671511, 0.07217133181637359, 0.08637823598456651, 0.4980212937045603, 0.869602677246745, 0.6351735094018282, 0.17161360991800845, 0.6339722778147999, 0.6890034622199067, 0.793188745933201, 0.7086552426671385, 0.6937678835948311, 0.2250520983423192, 0.19922569072070528, 0.22719922289978578, 0.20653700544755915, 0.21146552058651014, 0.20418357383428565, 0.19869759200216364, 0.14870555811112374, 0.2074976798324657, 0.6459259315882784, 0.648225433662905, 0.650079610661288, 0.6765020604544567, 0.6690609115336531, 0.467283108588712, 0.6017672823315339, 0.4651825278817945, 0.6038487844770358, 0.13448685854141096, 0.1341707259535524, 0.09930395536897918, 0.12869736554173505, 0.18602087860184047, 0.13672692216165083, 0.12493078110130573, 0.12767623168336306, 0.13479084595166113, 0.11115387332696025, 0.21212212026766797, 0.1254343161204894, 0.1587247961659921, 0.1512754026443155, 0.11727618362633618, 0.18685712696517043, 0.17493584502699921, 0.12816158021681767, 0.1291921996218912, 0.2670782279209497, 0.124076412940889, 0.13319371460251261, 0.12105165674860496, 0.14461996725038917, 0.19473993858016514, 0.14286838704691018, 0.13556208187632024, 0.24830113315066182, 0.16157492761655323, 0.2479909495683631, 0.18733012321077902, 0.2520032839408999, 0.17328172375007966, 0.21980454250068826, 0.19555089055145736, 0.18779456101624015, 0.10912932898462391, 0.13438412234635866, 0.06905017356854548, 0.12331529357222704, 0.09973910839939182, 0.12490110975646385, 0.15467494921778557, 0.07101120952452689, 0.0700791081658203, 0.17631271645818836, 0.24694915490924974, 0.18641231760040788, 0.20338862354116893, 0.19143500051370943, 0.18086942615481783, 0.21027659424532896, 0.23034686461877407, 0.2445669959550666, 0.5774743110795042, 0.6009010532467953, 0.5661660318447606, 0.48677744231648135, 0.48321097095443133, 0.3909856176500971, 0.5220081945294528, 0.5169226253472615, 0.547681719950079, 0.098357078495236, 0.09044756309358504, 0.09262408555249513, 0.08558900475471709, 0.09780348463321786, 0.08598745130217833, 0.08018687403005131, 0.1220946994819525, 0.09351516622878242, 0.15434818888554613, 0.1310410152485718, 0.12772492125872503, 0.13288378245589427, 0.16298627000710897, 0.14059327272472788, 0.13159245904383465, 0.14117231877510839, 0.14677192572340025, 0.2382819636479342, 0.27084012787706946, 0.2943620203018862, 0.2717416340737089, 0.29646497046672193, 0.2919793416343893, 0.24613714808956189, 0.32637137352732604, 0.2854673026837473, 0.21381780801405514, 0.19227208435855114, 0.22164394444283797, 0.23252321983180224, 0.2086756933959395, 0.23601140326381365, 0.21111905482702042, 0.25798022290372613, 0.1932534031286952, 0.17401159609736117, 0.1930749466879399, 0.1727393147600642, 0.1845003853992081, 0.19833847808323868, 0.1775907152884807, 0.19727016129343478, 0.18493557071064803, 0.1716421541812715, 0.18480382184022204, 0.17121045536690982, 0.16576915332428865, 0.16619888232550728, 0.1652908073871322, 0.16912954451757867, 0.16802089898458394, 0.17188055433372662, 0.1577457883424177, 0.2709593166919866, 0.17097988151784116, 0.14864226604299002, 0.3428769508249213, 0.36428634091649814, 0.17927364228159226, 0.16957906384453414, 0.16661002073399378, 0.30084217008411107, 0.35889631111069986, 0.44948201960542666, 0.21418957427891627, 0.1498060612173635, 0.2533694610958317, 0.1512701359346844, 0.2004636958720326, 0.2146323899417525, 0.23168762548764166, 0.18892554066718048, 0.1704150364995921, 0.17505681567115572, 0.16960080669429423, 0.16858191937696232, 0.16063425488431515, 0.17113672641015842, 0.1792751748575392, 0.16637680872418292, 0.06736978140131122, 0.07552499857695472, 0.08268958393551584, 0.07808660264686218, 0.07737034626800865, 0.07477407598272545, 0.06523869459001175, 0.07978198448673157, 0.0857464938691106]}, "mutation_prompt": null}
{"id": "fde3ecd3-0bd8-4837-bd1c-823ff8e278c2", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.15\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.elite_fraction = 0.1\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        diversity = np.std(parent1 - parent2)\n        if np.random.rand() < self.crossover_rate * (1 + diversity):  # Adaptive crossover\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        diversity = np.std(b - c)\n        mutant = np.clip(a + 0.8 * (b - c) * (1 + diversity), self.lower_bound, self.upper_bound)  # Adaptive mutation\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:num_elites]\n            new_population[:num_elites] = population[elite_indices]\n\n            for i in range(num_elites, self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Enhanced Hybrid Genetic Algorithm by introducing adaptive mutation and crossover rates based on fitness diversity for improved exploration-exploitation balance.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2155f422-22f4-41d2-aec7-ca715fdc2db2", "metadata": {"aucs": [0.6421743905090479, 0.6717020118401242, 0.5378176832901458, 0.4748249444252264, 0.535820233609771, 0.7199110933316066, 0.5793262170925216, 0.6320767113811596, 0.594806865215757, 0.22843392877353874, 0.14308594272362518, 0.2660027135993698, 0.2923230114212976, 0.24084894933462642, 0.27485368224391626, 0.19064246657484174, 0.2699166067866948, 0.22344012654908185, 0.10704799809772181, 0.08575664246574943, 0.09860707247319445, 0.09404260202570314, 0.09513914323503181, 0.08026086628811702, 0.11261871887455999, 0.08652117091733524, 0.10131717390431627, 0.08450778632665246, 0.06879288980873133, 0.07001256866388572, 0.07698021938456345, 0.07942952206383003, 0.06370614369029082, 0.0629218364671511, 0.07217133181637359, 0.08637823598456651, 0.4980212937045603, 0.869602677246745, 0.6351735094018282, 0.17161360991800845, 0.6339722778147999, 0.6890034622199067, 0.793188745933201, 0.7086552426671385, 0.6937678835948311, 0.2250520983423192, 0.19922569072070528, 0.22719922289978578, 0.20653700544755915, 0.21146552058651014, 0.20418357383428565, 0.19869759200216364, 0.14870555811112374, 0.2074976798324657, 0.6459259315882784, 0.648225433662905, 0.650079610661288, 0.6765020604544567, 0.6690609115336531, 0.467283108588712, 0.6017672823315339, 0.4651825278817945, 0.6038487844770358, 0.13448685854141096, 0.1341707259535524, 0.09930395536897918, 0.12869736554173505, 0.18602087860184047, 0.13672692216165083, 0.12493078110130573, 0.12767623168336306, 0.13479084595166113, 0.11115387332696025, 0.21212212026766797, 0.1254343161204894, 0.1587247961659921, 0.1512754026443155, 0.11727618362633618, 0.18685712696517043, 0.17493584502699921, 0.12816158021681767, 0.1291921996218912, 0.2670782279209497, 0.124076412940889, 0.13319371460251261, 0.12105165674860496, 0.14461996725038917, 0.19473993858016514, 0.14286838704691018, 0.13556208187632024, 0.24830113315066182, 0.16157492761655323, 0.2479909495683631, 0.18733012321077902, 0.2520032839408999, 0.17328172375007966, 0.21980454250068826, 0.19555089055145736, 0.18779456101624015, 0.10912932898462391, 0.13438412234635866, 0.06905017356854548, 0.12331529357222704, 0.09973910839939182, 0.12490110975646385, 0.15467494921778557, 0.07101120952452689, 0.0700791081658203, 0.17631271645818836, 0.24694915490924974, 0.18641231760040788, 0.20338862354116893, 0.19143500051370943, 0.18086942615481783, 0.21027659424532896, 0.23034686461877407, 0.2445669959550666, 0.5774743110795042, 0.6009010532467953, 0.5661660318447606, 0.48677744231648135, 0.48321097095443133, 0.3909856176500971, 0.5220081945294528, 0.5169226253472615, 0.547681719950079, 0.098357078495236, 0.09044756309358504, 0.09262408555249513, 0.08558900475471709, 0.09780348463321786, 0.08598745130217833, 0.08018687403005131, 0.1220946994819525, 0.09351516622878242, 0.15434818888554613, 0.1310410152485718, 0.12772492125872503, 0.13288378245589427, 0.16298627000710897, 0.14059327272472788, 0.13159245904383465, 0.14117231877510839, 0.14677192572340025, 0.2382819636479342, 0.27084012787706946, 0.2943620203018862, 0.2717416340737089, 0.29646497046672193, 0.2919793416343893, 0.24613714808956189, 0.32637137352732604, 0.2854673026837473, 0.21381780801405514, 0.19227208435855114, 0.22164394444283797, 0.23252321983180224, 0.2086756933959395, 0.23601140326381365, 0.21111905482702042, 0.25798022290372613, 0.1932534031286952, 0.17401159609736117, 0.1930749466879399, 0.1727393147600642, 0.1845003853992081, 0.19833847808323868, 0.1775907152884807, 0.19727016129343478, 0.18493557071064803, 0.1716421541812715, 0.18480382184022204, 0.17121045536690982, 0.16576915332428865, 0.16619888232550728, 0.1652908073871322, 0.16912954451757867, 0.16802089898458394, 0.17188055433372662, 0.1577457883424177, 0.2709593166919866, 0.17097988151784116, 0.14864226604299002, 0.3428769508249213, 0.36428634091649814, 0.17927364228159226, 0.16957906384453414, 0.16661002073399378, 0.30084217008411107, 0.35889631111069986, 0.44948201960542666, 0.21418957427891627, 0.1498060612173635, 0.2533694610958317, 0.1512701359346844, 0.2004636958720326, 0.2146323899417525, 0.23168762548764166, 0.18892554066718048, 0.1704150364995921, 0.17505681567115572, 0.16960080669429423, 0.16858191937696232, 0.16063425488431515, 0.17113672641015842, 0.1792751748575392, 0.16637680872418292, 0.06736978140131122, 0.07552499857695472, 0.08268958393551584, 0.07808660264686218, 0.07737034626800865, 0.07477407598272545, 0.06523869459001175, 0.07978198448673157, 0.0857464938691106]}, "mutation_prompt": null}
{"id": "84794a27-9ec7-4257-af8a-5c83299455b4", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.15\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.elite_fraction = 0.1\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        diversity = np.std(parent1 - parent2)\n        if np.random.rand() < self.crossover_rate * (1 + diversity):  # Adaptive crossover\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        diversity = np.std(b - c)\n        mutant = np.clip(a + 0.8 * (b - c) * (1 + diversity), self.lower_bound, self.upper_bound)  # Adaptive mutation\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:num_elites]\n            new_population[:num_elites] = population[elite_indices]\n\n            for i in range(num_elites, self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Enhanced Hybrid Genetic Algorithm by introducing adaptive mutation and crossover rates based on fitness diversity for improved exploration-exploitation balance.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2155f422-22f4-41d2-aec7-ca715fdc2db2", "metadata": {"aucs": [0.6421743905090479, 0.6717020118401242, 0.5378176832901458, 0.4748249444252264, 0.535820233609771, 0.7199110933316066, 0.5793262170925216, 0.6320767113811596, 0.594806865215757, 0.22843392877353874, 0.14308594272362518, 0.2660027135993698, 0.2923230114212976, 0.24084894933462642, 0.27485368224391626, 0.19064246657484174, 0.2699166067866948, 0.22344012654908185, 0.10704799809772181, 0.08575664246574943, 0.09860707247319445, 0.09404260202570314, 0.09513914323503181, 0.08026086628811702, 0.11261871887455999, 0.08652117091733524, 0.10131717390431627, 0.08450778632665246, 0.06879288980873133, 0.07001256866388572, 0.07698021938456345, 0.07942952206383003, 0.06370614369029082, 0.0629218364671511, 0.07217133181637359, 0.08637823598456651, 0.4980212937045603, 0.869602677246745, 0.6351735094018282, 0.17161360991800845, 0.6339722778147999, 0.6890034622199067, 0.793188745933201, 0.7086552426671385, 0.6937678835948311, 0.2250520983423192, 0.19922569072070528, 0.22719922289978578, 0.20653700544755915, 0.21146552058651014, 0.20418357383428565, 0.19869759200216364, 0.14870555811112374, 0.2074976798324657, 0.6459259315882784, 0.648225433662905, 0.650079610661288, 0.6765020604544567, 0.6690609115336531, 0.467283108588712, 0.6017672823315339, 0.4651825278817945, 0.6038487844770358, 0.13448685854141096, 0.1341707259535524, 0.09930395536897918, 0.12869736554173505, 0.18602087860184047, 0.13672692216165083, 0.12493078110130573, 0.12767623168336306, 0.13479084595166113, 0.11115387332696025, 0.21212212026766797, 0.1254343161204894, 0.1587247961659921, 0.1512754026443155, 0.11727618362633618, 0.18685712696517043, 0.17493584502699921, 0.12816158021681767, 0.1291921996218912, 0.2670782279209497, 0.124076412940889, 0.13319371460251261, 0.12105165674860496, 0.14461996725038917, 0.19473993858016514, 0.14286838704691018, 0.13556208187632024, 0.24830113315066182, 0.16157492761655323, 0.2479909495683631, 0.18733012321077902, 0.2520032839408999, 0.17328172375007966, 0.21980454250068826, 0.19555089055145736, 0.18779456101624015, 0.10912932898462391, 0.13438412234635866, 0.06905017356854548, 0.12331529357222704, 0.09973910839939182, 0.12490110975646385, 0.15467494921778557, 0.07101120952452689, 0.0700791081658203, 0.17631271645818836, 0.24694915490924974, 0.18641231760040788, 0.20338862354116893, 0.19143500051370943, 0.18086942615481783, 0.21027659424532896, 0.23034686461877407, 0.2445669959550666, 0.5774743110795042, 0.6009010532467953, 0.5661660318447606, 0.48677744231648135, 0.48321097095443133, 0.3909856176500971, 0.5220081945294528, 0.5169226253472615, 0.547681719950079, 0.098357078495236, 0.09044756309358504, 0.09262408555249513, 0.08558900475471709, 0.09780348463321786, 0.08598745130217833, 0.08018687403005131, 0.1220946994819525, 0.09351516622878242, 0.15434818888554613, 0.1310410152485718, 0.12772492125872503, 0.13288378245589427, 0.16298627000710897, 0.14059327272472788, 0.13159245904383465, 0.14117231877510839, 0.14677192572340025, 0.2382819636479342, 0.27084012787706946, 0.2943620203018862, 0.2717416340737089, 0.29646497046672193, 0.2919793416343893, 0.24613714808956189, 0.32637137352732604, 0.2854673026837473, 0.21381780801405514, 0.19227208435855114, 0.22164394444283797, 0.23252321983180224, 0.2086756933959395, 0.23601140326381365, 0.21111905482702042, 0.25798022290372613, 0.1932534031286952, 0.17401159609736117, 0.1930749466879399, 0.1727393147600642, 0.1845003853992081, 0.19833847808323868, 0.1775907152884807, 0.19727016129343478, 0.18493557071064803, 0.1716421541812715, 0.18480382184022204, 0.17121045536690982, 0.16576915332428865, 0.16619888232550728, 0.1652908073871322, 0.16912954451757867, 0.16802089898458394, 0.17188055433372662, 0.1577457883424177, 0.2709593166919866, 0.17097988151784116, 0.14864226604299002, 0.3428769508249213, 0.36428634091649814, 0.17927364228159226, 0.16957906384453414, 0.16661002073399378, 0.30084217008411107, 0.35889631111069986, 0.44948201960542666, 0.21418957427891627, 0.1498060612173635, 0.2533694610958317, 0.1512701359346844, 0.2004636958720326, 0.2146323899417525, 0.23168762548764166, 0.18892554066718048, 0.1704150364995921, 0.17505681567115572, 0.16960080669429423, 0.16858191937696232, 0.16063425488431515, 0.17113672641015842, 0.1792751748575392, 0.16637680872418292, 0.06736978140131122, 0.07552499857695472, 0.08268958393551584, 0.07808660264686218, 0.07737034626800865, 0.07477407598272545, 0.06523869459001175, 0.07978198448673157, 0.0857464938691106]}, "mutation_prompt": null}
{"id": "29a16a7b-baf0-4c8b-8ccd-020468676901", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.15\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.elite_fraction = 0.1\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        diversity = np.std(parent1 - parent2)\n        if np.random.rand() < self.crossover_rate * (1 + diversity):  # Adaptive crossover\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        diversity = np.std(b - c)\n        mutant = np.clip(a + 0.8 * (b - c) * (1 + diversity), self.lower_bound, self.upper_bound)  # Adaptive mutation\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:num_elites]\n            new_population[:num_elites] = population[elite_indices]\n\n            for i in range(num_elites, self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Enhanced Hybrid Genetic Algorithm by introducing adaptive mutation and crossover rates based on fitness diversity for improved exploration-exploitation balance.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2155f422-22f4-41d2-aec7-ca715fdc2db2", "metadata": {"aucs": [0.6421743905090479, 0.6717020118401242, 0.5378176832901458, 0.4748249444252264, 0.535820233609771, 0.7199110933316066, 0.5793262170925216, 0.6320767113811596, 0.594806865215757, 0.22843392877353874, 0.14308594272362518, 0.2660027135993698, 0.2923230114212976, 0.24084894933462642, 0.27485368224391626, 0.19064246657484174, 0.2699166067866948, 0.22344012654908185, 0.10704799809772181, 0.08575664246574943, 0.09860707247319445, 0.09404260202570314, 0.09513914323503181, 0.08026086628811702, 0.11261871887455999, 0.08652117091733524, 0.10131717390431627, 0.08450778632665246, 0.06879288980873133, 0.07001256866388572, 0.07698021938456345, 0.07942952206383003, 0.06370614369029082, 0.0629218364671511, 0.07217133181637359, 0.08637823598456651, 0.4980212937045603, 0.869602677246745, 0.6351735094018282, 0.17161360991800845, 0.6339722778147999, 0.6890034622199067, 0.793188745933201, 0.7086552426671385, 0.6937678835948311, 0.2250520983423192, 0.19922569072070528, 0.22719922289978578, 0.20653700544755915, 0.21146552058651014, 0.20418357383428565, 0.19869759200216364, 0.14870555811112374, 0.2074976798324657, 0.6459259315882784, 0.648225433662905, 0.650079610661288, 0.6765020604544567, 0.6690609115336531, 0.467283108588712, 0.6017672823315339, 0.4651825278817945, 0.6038487844770358, 0.13448685854141096, 0.1341707259535524, 0.09930395536897918, 0.12869736554173505, 0.18602087860184047, 0.13672692216165083, 0.12493078110130573, 0.12767623168336306, 0.13479084595166113, 0.11115387332696025, 0.21212212026766797, 0.1254343161204894, 0.1587247961659921, 0.1512754026443155, 0.11727618362633618, 0.18685712696517043, 0.17493584502699921, 0.12816158021681767, 0.1291921996218912, 0.2670782279209497, 0.124076412940889, 0.13319371460251261, 0.12105165674860496, 0.14461996725038917, 0.19473993858016514, 0.14286838704691018, 0.13556208187632024, 0.24830113315066182, 0.16157492761655323, 0.2479909495683631, 0.18733012321077902, 0.2520032839408999, 0.17328172375007966, 0.21980454250068826, 0.19555089055145736, 0.18779456101624015, 0.10912932898462391, 0.13438412234635866, 0.06905017356854548, 0.12331529357222704, 0.09973910839939182, 0.12490110975646385, 0.15467494921778557, 0.07101120952452689, 0.0700791081658203, 0.17631271645818836, 0.24694915490924974, 0.18641231760040788, 0.20338862354116893, 0.19143500051370943, 0.18086942615481783, 0.21027659424532896, 0.23034686461877407, 0.2445669959550666, 0.5774743110795042, 0.6009010532467953, 0.5661660318447606, 0.48677744231648135, 0.48321097095443133, 0.3909856176500971, 0.5220081945294528, 0.5169226253472615, 0.547681719950079, 0.098357078495236, 0.09044756309358504, 0.09262408555249513, 0.08558900475471709, 0.09780348463321786, 0.08598745130217833, 0.08018687403005131, 0.1220946994819525, 0.09351516622878242, 0.15434818888554613, 0.1310410152485718, 0.12772492125872503, 0.13288378245589427, 0.16298627000710897, 0.14059327272472788, 0.13159245904383465, 0.14117231877510839, 0.14677192572340025, 0.2382819636479342, 0.27084012787706946, 0.2943620203018862, 0.2717416340737089, 0.29646497046672193, 0.2919793416343893, 0.24613714808956189, 0.32637137352732604, 0.2854673026837473, 0.21381780801405514, 0.19227208435855114, 0.22164394444283797, 0.23252321983180224, 0.2086756933959395, 0.23601140326381365, 0.21111905482702042, 0.25798022290372613, 0.1932534031286952, 0.17401159609736117, 0.1930749466879399, 0.1727393147600642, 0.1845003853992081, 0.19833847808323868, 0.1775907152884807, 0.19727016129343478, 0.18493557071064803, 0.1716421541812715, 0.18480382184022204, 0.17121045536690982, 0.16576915332428865, 0.16619888232550728, 0.1652908073871322, 0.16912954451757867, 0.16802089898458394, 0.17188055433372662, 0.1577457883424177, 0.2709593166919866, 0.17097988151784116, 0.14864226604299002, 0.3428769508249213, 0.36428634091649814, 0.17927364228159226, 0.16957906384453414, 0.16661002073399378, 0.30084217008411107, 0.35889631111069986, 0.44948201960542666, 0.21418957427891627, 0.1498060612173635, 0.2533694610958317, 0.1512701359346844, 0.2004636958720326, 0.2146323899417525, 0.23168762548764166, 0.18892554066718048, 0.1704150364995921, 0.17505681567115572, 0.16960080669429423, 0.16858191937696232, 0.16063425488431515, 0.17113672641015842, 0.1792751748575392, 0.16637680872418292, 0.06736978140131122, 0.07552499857695472, 0.08268958393551584, 0.07808660264686218, 0.07737034626800865, 0.07477407598272545, 0.06523869459001175, 0.07978198448673157, 0.0857464938691106]}, "mutation_prompt": null}
{"id": "c2351d9c-cc40-4dc5-a52a-013b6e5e4aa3", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.15\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.elite_fraction = 0.1\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        diversity = np.std(parent1 - parent2)\n        if np.random.rand() < self.crossover_rate * (1 + diversity):  # Adaptive crossover\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        diversity = np.std(b - c)\n        mutant = np.clip(a + 0.8 * (b - c) * (1 + diversity), self.lower_bound, self.upper_bound)  # Adaptive mutation\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:num_elites]\n            new_population[:num_elites] = population[elite_indices]\n\n            for i in range(num_elites, self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Enhanced Hybrid Genetic Algorithm by introducing adaptive mutation and crossover rates based on fitness diversity for improved exploration-exploitation balance.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2155f422-22f4-41d2-aec7-ca715fdc2db2", "metadata": {"aucs": [0.6421743905090479, 0.6717020118401242, 0.5378176832901458, 0.4748249444252264, 0.535820233609771, 0.7199110933316066, 0.5793262170925216, 0.6320767113811596, 0.594806865215757, 0.22843392877353874, 0.14308594272362518, 0.2660027135993698, 0.2923230114212976, 0.24084894933462642, 0.27485368224391626, 0.19064246657484174, 0.2699166067866948, 0.22344012654908185, 0.10704799809772181, 0.08575664246574943, 0.09860707247319445, 0.09404260202570314, 0.09513914323503181, 0.08026086628811702, 0.11261871887455999, 0.08652117091733524, 0.10131717390431627, 0.08450778632665246, 0.06879288980873133, 0.07001256866388572, 0.07698021938456345, 0.07942952206383003, 0.06370614369029082, 0.0629218364671511, 0.07217133181637359, 0.08637823598456651, 0.4980212937045603, 0.869602677246745, 0.6351735094018282, 0.17161360991800845, 0.6339722778147999, 0.6890034622199067, 0.793188745933201, 0.7086552426671385, 0.6937678835948311, 0.2250520983423192, 0.19922569072070528, 0.22719922289978578, 0.20653700544755915, 0.21146552058651014, 0.20418357383428565, 0.19869759200216364, 0.14870555811112374, 0.2074976798324657, 0.6459259315882784, 0.648225433662905, 0.650079610661288, 0.6765020604544567, 0.6690609115336531, 0.467283108588712, 0.6017672823315339, 0.4651825278817945, 0.6038487844770358, 0.13448685854141096, 0.1341707259535524, 0.09930395536897918, 0.12869736554173505, 0.18602087860184047, 0.13672692216165083, 0.12493078110130573, 0.12767623168336306, 0.13479084595166113, 0.11115387332696025, 0.21212212026766797, 0.1254343161204894, 0.1587247961659921, 0.1512754026443155, 0.11727618362633618, 0.18685712696517043, 0.17493584502699921, 0.12816158021681767, 0.1291921996218912, 0.2670782279209497, 0.124076412940889, 0.13319371460251261, 0.12105165674860496, 0.14461996725038917, 0.19473993858016514, 0.14286838704691018, 0.13556208187632024, 0.24830113315066182, 0.16157492761655323, 0.2479909495683631, 0.18733012321077902, 0.2520032839408999, 0.17328172375007966, 0.21980454250068826, 0.19555089055145736, 0.18779456101624015, 0.10912932898462391, 0.13438412234635866, 0.06905017356854548, 0.12331529357222704, 0.09973910839939182, 0.12490110975646385, 0.15467494921778557, 0.07101120952452689, 0.0700791081658203, 0.17631271645818836, 0.24694915490924974, 0.18641231760040788, 0.20338862354116893, 0.19143500051370943, 0.18086942615481783, 0.21027659424532896, 0.23034686461877407, 0.2445669959550666, 0.5774743110795042, 0.6009010532467953, 0.5661660318447606, 0.48677744231648135, 0.48321097095443133, 0.3909856176500971, 0.5220081945294528, 0.5169226253472615, 0.547681719950079, 0.098357078495236, 0.09044756309358504, 0.09262408555249513, 0.08558900475471709, 0.09780348463321786, 0.08598745130217833, 0.08018687403005131, 0.1220946994819525, 0.09351516622878242, 0.15434818888554613, 0.1310410152485718, 0.12772492125872503, 0.13288378245589427, 0.16298627000710897, 0.14059327272472788, 0.13159245904383465, 0.14117231877510839, 0.14677192572340025, 0.2382819636479342, 0.27084012787706946, 0.2943620203018862, 0.2717416340737089, 0.29646497046672193, 0.2919793416343893, 0.24613714808956189, 0.32637137352732604, 0.2854673026837473, 0.21381780801405514, 0.19227208435855114, 0.22164394444283797, 0.23252321983180224, 0.2086756933959395, 0.23601140326381365, 0.21111905482702042, 0.25798022290372613, 0.1932534031286952, 0.17401159609736117, 0.1930749466879399, 0.1727393147600642, 0.1845003853992081, 0.19833847808323868, 0.1775907152884807, 0.19727016129343478, 0.18493557071064803, 0.1716421541812715, 0.18480382184022204, 0.17121045536690982, 0.16576915332428865, 0.16619888232550728, 0.1652908073871322, 0.16912954451757867, 0.16802089898458394, 0.17188055433372662, 0.1577457883424177, 0.2709593166919866, 0.17097988151784116, 0.14864226604299002, 0.3428769508249213, 0.36428634091649814, 0.17927364228159226, 0.16957906384453414, 0.16661002073399378, 0.30084217008411107, 0.35889631111069986, 0.44948201960542666, 0.21418957427891627, 0.1498060612173635, 0.2533694610958317, 0.1512701359346844, 0.2004636958720326, 0.2146323899417525, 0.23168762548764166, 0.18892554066718048, 0.1704150364995921, 0.17505681567115572, 0.16960080669429423, 0.16858191937696232, 0.16063425488431515, 0.17113672641015842, 0.1792751748575392, 0.16637680872418292, 0.06736978140131122, 0.07552499857695472, 0.08268958393551584, 0.07808660264686218, 0.07737034626800865, 0.07477407598272545, 0.06523869459001175, 0.07978198448673157, 0.0857464938691106]}, "mutation_prompt": null}
{"id": "70764c1d-9af3-4360-b0a0-ab21161d25c5", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.15\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.elite_fraction = 0.1\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        diversity = np.std(parent1 - parent2)\n        if np.random.rand() < self.crossover_rate * (1 + diversity):  # Adaptive crossover\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        diversity = np.std(b - c)\n        mutant = np.clip(a + 0.8 * (b - c) * (1 + diversity), self.lower_bound, self.upper_bound)  # Adaptive mutation\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:num_elites]\n            new_population[:num_elites] = population[elite_indices]\n\n            for i in range(num_elites, self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Enhanced Hybrid Genetic Algorithm by introducing adaptive mutation and crossover rates based on fitness diversity for improved exploration-exploitation balance.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2155f422-22f4-41d2-aec7-ca715fdc2db2", "metadata": {"aucs": [0.6421743905090479, 0.6717020118401242, 0.5378176832901458, 0.4748249444252264, 0.535820233609771, 0.7199110933316066, 0.5793262170925216, 0.6320767113811596, 0.594806865215757, 0.22843392877353874, 0.14308594272362518, 0.2660027135993698, 0.2923230114212976, 0.24084894933462642, 0.27485368224391626, 0.19064246657484174, 0.2699166067866948, 0.22344012654908185, 0.10704799809772181, 0.08575664246574943, 0.09860707247319445, 0.09404260202570314, 0.09513914323503181, 0.08026086628811702, 0.11261871887455999, 0.08652117091733524, 0.10131717390431627, 0.08450778632665246, 0.06879288980873133, 0.07001256866388572, 0.07698021938456345, 0.07942952206383003, 0.06370614369029082, 0.0629218364671511, 0.07217133181637359, 0.08637823598456651, 0.4980212937045603, 0.869602677246745, 0.6351735094018282, 0.17161360991800845, 0.6339722778147999, 0.6890034622199067, 0.793188745933201, 0.7086552426671385, 0.6937678835948311, 0.2250520983423192, 0.19922569072070528, 0.22719922289978578, 0.20653700544755915, 0.21146552058651014, 0.20418357383428565, 0.19869759200216364, 0.14870555811112374, 0.2074976798324657, 0.6459259315882784, 0.648225433662905, 0.650079610661288, 0.6765020604544567, 0.6690609115336531, 0.467283108588712, 0.6017672823315339, 0.4651825278817945, 0.6038487844770358, 0.13448685854141096, 0.1341707259535524, 0.09930395536897918, 0.12869736554173505, 0.18602087860184047, 0.13672692216165083, 0.12493078110130573, 0.12767623168336306, 0.13479084595166113, 0.11115387332696025, 0.21212212026766797, 0.1254343161204894, 0.1587247961659921, 0.1512754026443155, 0.11727618362633618, 0.18685712696517043, 0.17493584502699921, 0.12816158021681767, 0.1291921996218912, 0.2670782279209497, 0.124076412940889, 0.13319371460251261, 0.12105165674860496, 0.14461996725038917, 0.19473993858016514, 0.14286838704691018, 0.13556208187632024, 0.24830113315066182, 0.16157492761655323, 0.2479909495683631, 0.18733012321077902, 0.2520032839408999, 0.17328172375007966, 0.21980454250068826, 0.19555089055145736, 0.18779456101624015, 0.10912932898462391, 0.13438412234635866, 0.06905017356854548, 0.12331529357222704, 0.09973910839939182, 0.12490110975646385, 0.15467494921778557, 0.07101120952452689, 0.0700791081658203, 0.17631271645818836, 0.24694915490924974, 0.18641231760040788, 0.20338862354116893, 0.19143500051370943, 0.18086942615481783, 0.21027659424532896, 0.23034686461877407, 0.2445669959550666, 0.5774743110795042, 0.6009010532467953, 0.5661660318447606, 0.48677744231648135, 0.48321097095443133, 0.3909856176500971, 0.5220081945294528, 0.5169226253472615, 0.547681719950079, 0.098357078495236, 0.09044756309358504, 0.09262408555249513, 0.08558900475471709, 0.09780348463321786, 0.08598745130217833, 0.08018687403005131, 0.1220946994819525, 0.09351516622878242, 0.15434818888554613, 0.1310410152485718, 0.12772492125872503, 0.13288378245589427, 0.16298627000710897, 0.14059327272472788, 0.13159245904383465, 0.14117231877510839, 0.14677192572340025, 0.2382819636479342, 0.27084012787706946, 0.2943620203018862, 0.2717416340737089, 0.29646497046672193, 0.2919793416343893, 0.24613714808956189, 0.32637137352732604, 0.2854673026837473, 0.21381780801405514, 0.19227208435855114, 0.22164394444283797, 0.23252321983180224, 0.2086756933959395, 0.23601140326381365, 0.21111905482702042, 0.25798022290372613, 0.1932534031286952, 0.17401159609736117, 0.1930749466879399, 0.1727393147600642, 0.1845003853992081, 0.19833847808323868, 0.1775907152884807, 0.19727016129343478, 0.18493557071064803, 0.1716421541812715, 0.18480382184022204, 0.17121045536690982, 0.16576915332428865, 0.16619888232550728, 0.1652908073871322, 0.16912954451757867, 0.16802089898458394, 0.17188055433372662, 0.1577457883424177, 0.2709593166919866, 0.17097988151784116, 0.14864226604299002, 0.3428769508249213, 0.36428634091649814, 0.17927364228159226, 0.16957906384453414, 0.16661002073399378, 0.30084217008411107, 0.35889631111069986, 0.44948201960542666, 0.21418957427891627, 0.1498060612173635, 0.2533694610958317, 0.1512701359346844, 0.2004636958720326, 0.2146323899417525, 0.23168762548764166, 0.18892554066718048, 0.1704150364995921, 0.17505681567115572, 0.16960080669429423, 0.16858191937696232, 0.16063425488431515, 0.17113672641015842, 0.1792751748575392, 0.16637680872418292, 0.06736978140131122, 0.07552499857695472, 0.08268958393551584, 0.07808660264686218, 0.07737034626800865, 0.07477407598272545, 0.06523869459001175, 0.07978198448673157, 0.0857464938691106]}, "mutation_prompt": null}
{"id": "44b3c54f-d27e-4f60-b424-ffaad089d72d", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.15\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.elite_fraction = 0.1\n        self.dynamic_population = True  # New dynamic population flag\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        diversity = np.std(parent1 - parent2)\n        if np.random.rand() < self.crossover_rate * (1 + diversity):\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        diversity = np.std(b - c)\n        mutant = np.clip(a + 0.8 * (b - c) * (1 + diversity), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            num_elites = max(1, int(self.elite_fraction * self.population_size * (1 + eval_count / self.budget)))  # Adaptive elitism\n            elite_indices = np.argsort(fitness)[:num_elites]\n            new_population[:num_elites] = population[elite_indices]\n\n            for i in range(num_elites, self.population_size):\n                parent_idx = self._select_parents(fitness)\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n\n            if self.dynamic_population and eval_count < self.budget:  # Optional resizing\n                self.population_size = min(self.population_size + 1, int(self.budget/10))\n\n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Enhanced Hybrid Genetic Algorithm by introducing dynamic population resizing and adaptive elitism to balance exploration and exploitation.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 25 is out of bounds for axis 0 with size 25').", "error": "IndexError('index 25 is out of bounds for axis 0 with size 25')", "parent_id": "2155f422-22f4-41d2-aec7-ca715fdc2db2", "metadata": {}, "mutation_prompt": null}
{"id": "c55c3758-effb-40f7-915b-cda7454ab5dd", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.15\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.elite_fraction = 0.1\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        diversity = np.std(parent1 - parent2)\n        if np.random.rand() < self.crossover_rate * (1 + diversity):  # Adaptive crossover\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        diversity = np.std(b - c)\n        mutant = np.clip(a + 0.8 * (b - c) * (1 + diversity), self.lower_bound, self.upper_bound)  # Adaptive mutation\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:num_elites]\n            new_population[:num_elites] = population[elite_indices]\n\n            for i in range(num_elites, self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Enhanced Hybrid Genetic Algorithm by introducing adaptive mutation and crossover rates based on fitness diversity for improved exploration-exploitation balance.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2155f422-22f4-41d2-aec7-ca715fdc2db2", "metadata": {"aucs": [0.6421743905090479, 0.6717020118401242, 0.5378176832901458, 0.4748249444252264, 0.535820233609771, 0.7199110933316066, 0.5793262170925216, 0.6320767113811596, 0.594806865215757, 0.22843392877353874, 0.14308594272362518, 0.2660027135993698, 0.2923230114212976, 0.24084894933462642, 0.27485368224391626, 0.19064246657484174, 0.2699166067866948, 0.22344012654908185, 0.10704799809772181, 0.08575664246574943, 0.09860707247319445, 0.09404260202570314, 0.09513914323503181, 0.08026086628811702, 0.11261871887455999, 0.08652117091733524, 0.10131717390431627, 0.08450778632665246, 0.06879288980873133, 0.07001256866388572, 0.07698021938456345, 0.07942952206383003, 0.06370614369029082, 0.0629218364671511, 0.07217133181637359, 0.08637823598456651, 0.4980212937045603, 0.869602677246745, 0.6351735094018282, 0.17161360991800845, 0.6339722778147999, 0.6890034622199067, 0.793188745933201, 0.7086552426671385, 0.6937678835948311, 0.2250520983423192, 0.19922569072070528, 0.22719922289978578, 0.20653700544755915, 0.21146552058651014, 0.20418357383428565, 0.19869759200216364, 0.14870555811112374, 0.2074976798324657, 0.6459259315882784, 0.648225433662905, 0.650079610661288, 0.6765020604544567, 0.6690609115336531, 0.467283108588712, 0.6017672823315339, 0.4651825278817945, 0.6038487844770358, 0.13448685854141096, 0.1341707259535524, 0.09930395536897918, 0.12869736554173505, 0.18602087860184047, 0.13672692216165083, 0.12493078110130573, 0.12767623168336306, 0.13479084595166113, 0.11115387332696025, 0.21212212026766797, 0.1254343161204894, 0.1587247961659921, 0.1512754026443155, 0.11727618362633618, 0.18685712696517043, 0.17493584502699921, 0.12816158021681767, 0.1291921996218912, 0.2670782279209497, 0.124076412940889, 0.13319371460251261, 0.12105165674860496, 0.14461996725038917, 0.19473993858016514, 0.14286838704691018, 0.13556208187632024, 0.24830113315066182, 0.16157492761655323, 0.2479909495683631, 0.18733012321077902, 0.2520032839408999, 0.17328172375007966, 0.21980454250068826, 0.19555089055145736, 0.18779456101624015, 0.10912932898462391, 0.13438412234635866, 0.06905017356854548, 0.12331529357222704, 0.09973910839939182, 0.12490110975646385, 0.15467494921778557, 0.07101120952452689, 0.0700791081658203, 0.17631271645818836, 0.24694915490924974, 0.18641231760040788, 0.20338862354116893, 0.19143500051370943, 0.18086942615481783, 0.21027659424532896, 0.23034686461877407, 0.2445669959550666, 0.5774743110795042, 0.6009010532467953, 0.5661660318447606, 0.48677744231648135, 0.48321097095443133, 0.3909856176500971, 0.5220081945294528, 0.5169226253472615, 0.547681719950079, 0.098357078495236, 0.09044756309358504, 0.09262408555249513, 0.08558900475471709, 0.09780348463321786, 0.08598745130217833, 0.08018687403005131, 0.1220946994819525, 0.09351516622878242, 0.15434818888554613, 0.1310410152485718, 0.12772492125872503, 0.13288378245589427, 0.16298627000710897, 0.14059327272472788, 0.13159245904383465, 0.14117231877510839, 0.14677192572340025, 0.2382819636479342, 0.27084012787706946, 0.2943620203018862, 0.2717416340737089, 0.29646497046672193, 0.2919793416343893, 0.24613714808956189, 0.32637137352732604, 0.2854673026837473, 0.21381780801405514, 0.19227208435855114, 0.22164394444283797, 0.23252321983180224, 0.2086756933959395, 0.23601140326381365, 0.21111905482702042, 0.25798022290372613, 0.1932534031286952, 0.17401159609736117, 0.1930749466879399, 0.1727393147600642, 0.1845003853992081, 0.19833847808323868, 0.1775907152884807, 0.19727016129343478, 0.18493557071064803, 0.1716421541812715, 0.18480382184022204, 0.17121045536690982, 0.16576915332428865, 0.16619888232550728, 0.1652908073871322, 0.16912954451757867, 0.16802089898458394, 0.17188055433372662, 0.1577457883424177, 0.2709593166919866, 0.17097988151784116, 0.14864226604299002, 0.3428769508249213, 0.36428634091649814, 0.17927364228159226, 0.16957906384453414, 0.16661002073399378, 0.30084217008411107, 0.35889631111069986, 0.44948201960542666, 0.21418957427891627, 0.1498060612173635, 0.2533694610958317, 0.1512701359346844, 0.2004636958720326, 0.2146323899417525, 0.23168762548764166, 0.18892554066718048, 0.1704150364995921, 0.17505681567115572, 0.16960080669429423, 0.16858191937696232, 0.16063425488431515, 0.17113672641015842, 0.1792751748575392, 0.16637680872418292, 0.06736978140131122, 0.07552499857695472, 0.08268958393551584, 0.07808660264686218, 0.07737034626800865, 0.07477407598272545, 0.06523869459001175, 0.07978198448673157, 0.0857464938691106]}, "mutation_prompt": null}
{"id": "d9b7b0f7-ea2e-43bf-a21e-13732e2c4a07", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.15\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.elite_fraction = 0.1\n        self.dynamic_scaling_factor = 1.2  # New addition for dynamic scaling\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        diversity = np.std(parent1 - parent2)\n        if np.random.rand() < self.crossover_rate * (1 + diversity):  # Adaptive crossover\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        diversity = np.std(b - c)\n        mutant = np.clip(a + 0.8 * (b - c) * (1 + diversity), self.lower_bound, self.upper_bound)  # Adaptive mutation\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n        prev_best = fitness[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:num_elites]\n            new_population[:num_elites] = population[elite_indices]\n\n            for i in range(num_elites, self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            current_best = fitness[current_best_idx]\n            if current_best < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n            \n            # Dynamic population scaling based on convergence\n            if prev_best - current_best < 1e-6:  # Convergence threshold\n                self.population_size = min(int(self.population_size * self.dynamic_scaling_factor), self.budget - eval_count)\n            prev_best = current_best\n        \n        return best", "name": "HybridGADE", "description": "Improved Hybrid Genetic Algorithm by incorporating dynamic population scaling based on convergence speed to enhance exploration and exploitation balance.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 28 is out of bounds for axis 0 with size 25').", "error": "IndexError('index 28 is out of bounds for axis 0 with size 25')", "parent_id": "2155f422-22f4-41d2-aec7-ca715fdc2db2", "metadata": {}, "mutation_prompt": null}
{"id": "3c211bfe-db74-4112-9a20-b22c234c3fa6", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.15\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.elite_fraction = 0.1\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        diversity = np.std(parent1 - parent2)\n        if np.random.rand() < self.crossover_rate * (1 + diversity):  # Adaptive crossover\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        diversity = np.std(b - c)\n        mutant = np.clip(a + 0.8 * (b - c) * (1 + diversity), self.lower_bound, self.upper_bound)  # Adaptive mutation\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:num_elites]\n            new_population[:num_elites] = population[elite_indices]\n\n            for i in range(num_elites, self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Enhanced Hybrid Genetic Algorithm by introducing adaptive mutation and crossover rates based on fitness diversity for improved exploration-exploitation balance.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2155f422-22f4-41d2-aec7-ca715fdc2db2", "metadata": {"aucs": [0.6421743905090479, 0.6717020118401242, 0.5378176832901458, 0.4748249444252264, 0.535820233609771, 0.7199110933316066, 0.5793262170925216, 0.6320767113811596, 0.594806865215757, 0.22843392877353874, 0.14308594272362518, 0.2660027135993698, 0.2923230114212976, 0.24084894933462642, 0.27485368224391626, 0.19064246657484174, 0.2699166067866948, 0.22344012654908185, 0.10704799809772181, 0.08575664246574943, 0.09860707247319445, 0.09404260202570314, 0.09513914323503181, 0.08026086628811702, 0.11261871887455999, 0.08652117091733524, 0.10131717390431627, 0.08450778632665246, 0.06879288980873133, 0.07001256866388572, 0.07698021938456345, 0.07942952206383003, 0.06370614369029082, 0.0629218364671511, 0.07217133181637359, 0.08637823598456651, 0.4980212937045603, 0.869602677246745, 0.6351735094018282, 0.17161360991800845, 0.6339722778147999, 0.6890034622199067, 0.793188745933201, 0.7086552426671385, 0.6937678835948311, 0.2250520983423192, 0.19922569072070528, 0.22719922289978578, 0.20653700544755915, 0.21146552058651014, 0.20418357383428565, 0.19869759200216364, 0.14870555811112374, 0.2074976798324657, 0.6459259315882784, 0.648225433662905, 0.650079610661288, 0.6765020604544567, 0.6690609115336531, 0.467283108588712, 0.6017672823315339, 0.4651825278817945, 0.6038487844770358, 0.13448685854141096, 0.1341707259535524, 0.09930395536897918, 0.12869736554173505, 0.18602087860184047, 0.13672692216165083, 0.12493078110130573, 0.12767623168336306, 0.13479084595166113, 0.11115387332696025, 0.21212212026766797, 0.1254343161204894, 0.1587247961659921, 0.1512754026443155, 0.11727618362633618, 0.18685712696517043, 0.17493584502699921, 0.12816158021681767, 0.1291921996218912, 0.2670782279209497, 0.124076412940889, 0.13319371460251261, 0.12105165674860496, 0.14461996725038917, 0.19473993858016514, 0.14286838704691018, 0.13556208187632024, 0.24830113315066182, 0.16157492761655323, 0.2479909495683631, 0.18733012321077902, 0.2520032839408999, 0.17328172375007966, 0.21980454250068826, 0.19555089055145736, 0.18779456101624015, 0.10912932898462391, 0.13438412234635866, 0.06905017356854548, 0.12331529357222704, 0.09973910839939182, 0.12490110975646385, 0.15467494921778557, 0.07101120952452689, 0.0700791081658203, 0.17631271645818836, 0.24694915490924974, 0.18641231760040788, 0.20338862354116893, 0.19143500051370943, 0.18086942615481783, 0.21027659424532896, 0.23034686461877407, 0.2445669959550666, 0.5774743110795042, 0.6009010532467953, 0.5661660318447606, 0.48677744231648135, 0.48321097095443133, 0.3909856176500971, 0.5220081945294528, 0.5169226253472615, 0.547681719950079, 0.098357078495236, 0.09044756309358504, 0.09262408555249513, 0.08558900475471709, 0.09780348463321786, 0.08598745130217833, 0.08018687403005131, 0.1220946994819525, 0.09351516622878242, 0.15434818888554613, 0.1310410152485718, 0.12772492125872503, 0.13288378245589427, 0.16298627000710897, 0.14059327272472788, 0.13159245904383465, 0.14117231877510839, 0.14677192572340025, 0.2382819636479342, 0.27084012787706946, 0.2943620203018862, 0.2717416340737089, 0.29646497046672193, 0.2919793416343893, 0.24613714808956189, 0.32637137352732604, 0.2854673026837473, 0.21381780801405514, 0.19227208435855114, 0.22164394444283797, 0.23252321983180224, 0.2086756933959395, 0.23601140326381365, 0.21111905482702042, 0.25798022290372613, 0.1932534031286952, 0.17401159609736117, 0.1930749466879399, 0.1727393147600642, 0.1845003853992081, 0.19833847808323868, 0.1775907152884807, 0.19727016129343478, 0.18493557071064803, 0.1716421541812715, 0.18480382184022204, 0.17121045536690982, 0.16576915332428865, 0.16619888232550728, 0.1652908073871322, 0.16912954451757867, 0.16802089898458394, 0.17188055433372662, 0.1577457883424177, 0.2709593166919866, 0.17097988151784116, 0.14864226604299002, 0.3428769508249213, 0.36428634091649814, 0.17927364228159226, 0.16957906384453414, 0.16661002073399378, 0.30084217008411107, 0.35889631111069986, 0.44948201960542666, 0.21418957427891627, 0.1498060612173635, 0.2533694610958317, 0.1512701359346844, 0.2004636958720326, 0.2146323899417525, 0.23168762548764166, 0.18892554066718048, 0.1704150364995921, 0.17505681567115572, 0.16960080669429423, 0.16858191937696232, 0.16063425488431515, 0.17113672641015842, 0.1792751748575392, 0.16637680872418292, 0.06736978140131122, 0.07552499857695472, 0.08268958393551584, 0.07808660264686218, 0.07737034626800865, 0.07477407598272545, 0.06523869459001175, 0.07978198448673157, 0.0857464938691106]}, "mutation_prompt": null}
{"id": "13350d9c-4d46-4982-a128-16149ad40611", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.15\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.elite_fraction = 0.1\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        diversity = np.std(parent1 - parent2)\n        if np.random.rand() < self.crossover_rate * (1 + diversity):  # Adaptive crossover\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring, global_best_fitness, current_fitness):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            scaling_factor = 0.1 * np.abs(global_best_fitness - current_fitness) / (np.abs(global_best_fitness) + 1e-10)\n            return np.clip(offspring + mutation_vector * scaling_factor, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func, fitness):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        diversity = np.std(b - c)\n        mutant = np.clip(a + 0.8 * (b - c) * (1 + diversity), self.lower_bound, self.upper_bound)  # Adaptive mutation\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial, fitness[np.argmin(fitness)], fitness[idx])\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:num_elites]\n            new_population[:num_elites] = population[elite_indices]\n\n            for i in range(num_elites, self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func, fitness)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Enhanced Hybrid GA with adaptive mutation scaling based on function value differences for improved convergence.", "configspace": "", "generation": 71, "fitness": 0.21735329171721482, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.15.", "error": "", "parent_id": "2155f422-22f4-41d2-aec7-ca715fdc2db2", "metadata": {"aucs": [0.6640278944236835, 0.6372297601274416, 0.5687801258775339, 0.3958807086057814, 0.6509973121544204, 0.6678662497463139, 0.44244014942649523, 0.5003555253576211, 0.5724815284161797, 0.16996089858847319, 0.07666122475118842, 0.2483201373999333, 0.20178643661124707, 0.07837934628213716, 0.2023124333794284, 0.06960983176553981, 0.21759186965568755, 0.3022323539968873, 0.11757606323332526, 0.07091317545687525, 0.08632951347693363, 0.09064426672977266, 0.12139674602161554, 0.09841226863949526, 0.08448914814014152, 0.07505220532186774, 0.07624083468438858, 0.08256752344166185, 0.07718774359816338, 0.07179754339263578, 0.06962133367108636, 0.08746935727390226, 0.07006637407024185, 0.07250804943033595, 0.07345859684261336, 0.07452060121282944, 0.2762780315474227, 0.45896247312458627, 0.2508350144534838, 0.4282531140875986, 0.2978150493429368, 0.6064779362787074, 0.37538801679492695, 0.48269416827012035, 0.3911783947512556, 0.18380568818316922, 0.15377197751607508, 0.2121317830801671, 0.18194611892846546, 0.158281421313889, 0.1398278580677037, 0.1072704222021974, 0.14791012887645538, 0.27661347872257047, 0.6492316664396355, 0.19929327358397708, 0.6648971591256749, 0.547162877850065, 0.690941052821248, 0.6823276908681499, 0.6294001337647408, 0.26067159598695333, 0.6443728845091556, 0.1419557202905316, 0.1161053578416047, 0.11054242822590499, 0.12953174189782024, 0.12701827398339505, 0.119354521317239, 0.11871181337882974, 0.14076097670458565, 0.11977303963531682, 0.1298493241203088, 0.19461586175491297, 0.1430346230141869, 0.14513718255693697, 0.13509949312878666, 0.14668790145861133, 0.1179929636670457, 0.1307813647207524, 0.12504471534367168, 0.09693351345129253, 0.1284882556495932, 0.10817212308581292, 0.06813200318694546, 0.12082851232946579, 0.092901804941664, 0.13842962751252652, 0.09783700044755728, 0.2284267844265322, 0.13282563416263948, 0.12173747791911282, 0.21576314626209558, 0.13021685573848463, 0.2327428251445265, 0.13815917504395525, 0.29320710964782204, 0.21393373138928562, 0.2411274823757138, 0.09987212670214596, 0.10488460220774543, 0.10291439893455334, 0.11903563742407752, 0.08094511247063796, 0.1327035401740121, 0.11870022592613227, 0.1233772699696265, 0.09200254181696177, 0.2560159669528278, 0.16875261523064278, 0.2843580934362403, 0.22827527780056467, 0.2579018242012676, 0.1900811729738322, 0.128425595162589, 0.11605394112139544, 0.1911472322738179, 0.4356293431992062, 0.4489761730313455, 0.42304095552135845, 0.5442079996241818, 0.4272279326331496, 0.5222398493310771, 0.5295607232350266, 0.5276237223544393, 0.45664539006760085, 0.09446557065185512, 0.0926702131584407, 0.0807161033138395, 0.09178646224955478, 0.07440195446817921, 0.07500016932324849, 0.08437777807879798, 0.11171223152193288, 0.0894776385663596, 0.14175496139521748, 0.14215277830516715, 0.12998574804781915, 0.15023697943782421, 0.1386289935857129, 0.14149908400111944, 0.13144227649483708, 0.11481487786895483, 0.12856378019879755, 0.2959025144619102, 0.2545972598167494, 0.31403566649465, 0.291844175375394, 0.3068468307119335, 0.30568190516532134, 0.28637547531626883, 0.29663578012153435, 0.305240626330212, 0.12641702691091727, 0.19403911006701646, 0.2112214200345055, 0.2463707342422753, 0.2087394249811535, 0.21957808273674517, 0.19731940282773408, 0.22075127498341007, 0.24684296291406516, 0.19605511172174273, 0.2026802704941899, 0.204515326300997, 0.18455662487876823, 0.19899563585906077, 0.22180103342707258, 0.2023503383476073, 0.18880913742370542, 0.19592884117555454, 0.16973624198950144, 0.169984550117799, 0.17650333142861585, 0.1765730373421529, 0.16670096674772084, 0.1734860213524333, 0.16820851805340775, 0.18294411733998828, 0.16887071418661947, 0.1658074136650326, 0.1681092803494072, 0.15260458888799022, 0.22722141857278721, 0.16592709782267434, 0.15344985805640377, 0.16882396958576773, 0.2916849838503144, 0.21768616147358144, 0.420159829389649, 0.5305710824404747, 0.4421570753021109, 0.15426041466008833, 0.15998148369501086, 0.15257184078949682, 0.2288006891554618, 0.19510754611608516, 0.1685122066129674, 0.1865554317481447, 0.16943071956171918, 0.1824328289157232, 0.18863851268932175, 0.17211233246899516, 0.171171679744466, 0.20417691098513935, 0.17927493946644535, 0.1685974754873687, 0.09037636650919811, 0.06851804128761962, 0.12227935543461832, 0.07450230743124264, 0.06652172432588521, 0.0732106782814681, 0.07164223634518352, 0.07298976703913262, 0.0642514991979013]}, "mutation_prompt": null}
{"id": "bcc876dc-5650-4bc4-b5d8-fb0664268905", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.15\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.elite_fraction = 0.1\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        diversity = np.std(parent1 - parent2)\n        if np.random.rand() < self.crossover_rate * (1 + diversity):  # Adaptive crossover\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring, fitness, best):\n        fitness_diff = np.abs(func(offspring) - func(best))\n        mutation_step = 0.1 * (1 / (1 + fitness_diff))  # Fitness-based mutation step size\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * mutation_step, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        diversity = np.std(b - c)\n        mutant = np.clip(a + 0.8 * (b - c) * (1 + diversity), self.lower_bound, self.upper_bound)  # Adaptive mutation\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial, self._evaluate_population(func, [trial])[0], best)  # Pass fitness\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:num_elites]\n            new_population[:num_elites] = population[elite_indices]\n\n            for i in range(num_elites, self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Enhanced Diversity-Driven Hybrid Genetic Algorithm by incorporating fitness-based mutation step size adjustment for faster convergence.", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "2155f422-22f4-41d2-aec7-ca715fdc2db2", "metadata": {}, "mutation_prompt": null}
{"id": "fafef393-c62d-4afe-a983-d130440564ab", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.15\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.elite_fraction = 0.1\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        diversity = np.std(parent1 - parent2)\n        if np.random.rand() < self.crossover_rate * (1 + diversity):  # Adaptive crossover\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        diversity = np.std(b - c)\n        mutant = np.clip(a + 0.8 * (b - c) * (1 + diversity), self.lower_bound, self.upper_bound)  # Adaptive mutation\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:num_elites]\n            new_population[:num_elites] = population[elite_indices]\n\n            for i in range(num_elites, self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Enhanced Hybrid Genetic Algorithm by introducing adaptive mutation and crossover rates based on fitness diversity for improved exploration-exploitation balance.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2155f422-22f4-41d2-aec7-ca715fdc2db2", "metadata": {"aucs": [0.6421743905090479, 0.6717020118401242, 0.5378176832901458, 0.4748249444252264, 0.535820233609771, 0.7199110933316066, 0.5793262170925216, 0.6320767113811596, 0.594806865215757, 0.22843392877353874, 0.14308594272362518, 0.2660027135993698, 0.2923230114212976, 0.24084894933462642, 0.27485368224391626, 0.19064246657484174, 0.2699166067866948, 0.22344012654908185, 0.10704799809772181, 0.08575664246574943, 0.09860707247319445, 0.09404260202570314, 0.09513914323503181, 0.08026086628811702, 0.11261871887455999, 0.08652117091733524, 0.10131717390431627, 0.08450778632665246, 0.06879288980873133, 0.07001256866388572, 0.07698021938456345, 0.07942952206383003, 0.06370614369029082, 0.0629218364671511, 0.07217133181637359, 0.08637823598456651, 0.4980212937045603, 0.869602677246745, 0.6351735094018282, 0.17161360991800845, 0.6339722778147999, 0.6890034622199067, 0.793188745933201, 0.7086552426671385, 0.6937678835948311, 0.2250520983423192, 0.19922569072070528, 0.22719922289978578, 0.20653700544755915, 0.21146552058651014, 0.20418357383428565, 0.19869759200216364, 0.14870555811112374, 0.2074976798324657, 0.6459259315882784, 0.648225433662905, 0.650079610661288, 0.6765020604544567, 0.6690609115336531, 0.467283108588712, 0.6017672823315339, 0.4651825278817945, 0.6038487844770358, 0.13448685854141096, 0.1341707259535524, 0.09930395536897918, 0.12869736554173505, 0.18602087860184047, 0.13672692216165083, 0.12493078110130573, 0.12767623168336306, 0.13479084595166113, 0.11115387332696025, 0.21212212026766797, 0.1254343161204894, 0.1587247961659921, 0.1512754026443155, 0.11727618362633618, 0.18685712696517043, 0.17493584502699921, 0.12816158021681767, 0.1291921996218912, 0.2670782279209497, 0.124076412940889, 0.13319371460251261, 0.12105165674860496, 0.14461996725038917, 0.19473993858016514, 0.14286838704691018, 0.13556208187632024, 0.24830113315066182, 0.16157492761655323, 0.2479909495683631, 0.18733012321077902, 0.2520032839408999, 0.17328172375007966, 0.21980454250068826, 0.19555089055145736, 0.18779456101624015, 0.10912932898462391, 0.13438412234635866, 0.06905017356854548, 0.12331529357222704, 0.09973910839939182, 0.12490110975646385, 0.15467494921778557, 0.07101120952452689, 0.0700791081658203, 0.17631271645818836, 0.24694915490924974, 0.18641231760040788, 0.20338862354116893, 0.19143500051370943, 0.18086942615481783, 0.21027659424532896, 0.23034686461877407, 0.2445669959550666, 0.5774743110795042, 0.6009010532467953, 0.5661660318447606, 0.48677744231648135, 0.48321097095443133, 0.3909856176500971, 0.5220081945294528, 0.5169226253472615, 0.547681719950079, 0.098357078495236, 0.09044756309358504, 0.09262408555249513, 0.08558900475471709, 0.09780348463321786, 0.08598745130217833, 0.08018687403005131, 0.1220946994819525, 0.09351516622878242, 0.15434818888554613, 0.1310410152485718, 0.12772492125872503, 0.13288378245589427, 0.16298627000710897, 0.14059327272472788, 0.13159245904383465, 0.14117231877510839, 0.14677192572340025, 0.2382819636479342, 0.27084012787706946, 0.2943620203018862, 0.2717416340737089, 0.29646497046672193, 0.2919793416343893, 0.24613714808956189, 0.32637137352732604, 0.2854673026837473, 0.21381780801405514, 0.19227208435855114, 0.22164394444283797, 0.23252321983180224, 0.2086756933959395, 0.23601140326381365, 0.21111905482702042, 0.25798022290372613, 0.1932534031286952, 0.17401159609736117, 0.1930749466879399, 0.1727393147600642, 0.1845003853992081, 0.19833847808323868, 0.1775907152884807, 0.19727016129343478, 0.18493557071064803, 0.1716421541812715, 0.18480382184022204, 0.17121045536690982, 0.16576915332428865, 0.16619888232550728, 0.1652908073871322, 0.16912954451757867, 0.16802089898458394, 0.17188055433372662, 0.1577457883424177, 0.2709593166919866, 0.17097988151784116, 0.14864226604299002, 0.3428769508249213, 0.36428634091649814, 0.17927364228159226, 0.16957906384453414, 0.16661002073399378, 0.30084217008411107, 0.35889631111069986, 0.44948201960542666, 0.21418957427891627, 0.1498060612173635, 0.2533694610958317, 0.1512701359346844, 0.2004636958720326, 0.2146323899417525, 0.23168762548764166, 0.18892554066718048, 0.1704150364995921, 0.17505681567115572, 0.16960080669429423, 0.16858191937696232, 0.16063425488431515, 0.17113672641015842, 0.1792751748575392, 0.16637680872418292, 0.06736978140131122, 0.07552499857695472, 0.08268958393551584, 0.07808660264686218, 0.07737034626800865, 0.07477407598272545, 0.06523869459001175, 0.07978198448673157, 0.0857464938691106]}, "mutation_prompt": null}
{"id": "5a0f2ac1-06f1-4ceb-8287-3588a5853371", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.15\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.elite_fraction = 0.1\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        diversity = np.std(parent1 - parent2)\n        if np.random.rand() < self.crossover_rate * (1 + diversity):  # Adaptive crossover\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        diversity = np.std(b - c)\n        mutant = np.clip(a + 0.8 * (b - c) * (1 + diversity), self.lower_bound, self.upper_bound)  # Adaptive mutation\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:num_elites]\n            new_population[:num_elites] = population[elite_indices]\n\n            for i in range(num_elites, self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Enhanced Hybrid Genetic Algorithm by introducing adaptive mutation and crossover rates based on fitness diversity for improved exploration-exploitation balance.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2155f422-22f4-41d2-aec7-ca715fdc2db2", "metadata": {"aucs": [0.6421743905090479, 0.6717020118401242, 0.5378176832901458, 0.4748249444252264, 0.535820233609771, 0.7199110933316066, 0.5793262170925216, 0.6320767113811596, 0.594806865215757, 0.22843392877353874, 0.14308594272362518, 0.2660027135993698, 0.2923230114212976, 0.24084894933462642, 0.27485368224391626, 0.19064246657484174, 0.2699166067866948, 0.22344012654908185, 0.10704799809772181, 0.08575664246574943, 0.09860707247319445, 0.09404260202570314, 0.09513914323503181, 0.08026086628811702, 0.11261871887455999, 0.08652117091733524, 0.10131717390431627, 0.08450778632665246, 0.06879288980873133, 0.07001256866388572, 0.07698021938456345, 0.07942952206383003, 0.06370614369029082, 0.0629218364671511, 0.07217133181637359, 0.08637823598456651, 0.4980212937045603, 0.869602677246745, 0.6351735094018282, 0.17161360991800845, 0.6339722778147999, 0.6890034622199067, 0.793188745933201, 0.7086552426671385, 0.6937678835948311, 0.2250520983423192, 0.19922569072070528, 0.22719922289978578, 0.20653700544755915, 0.21146552058651014, 0.20418357383428565, 0.19869759200216364, 0.14870555811112374, 0.2074976798324657, 0.6459259315882784, 0.648225433662905, 0.650079610661288, 0.6765020604544567, 0.6690609115336531, 0.467283108588712, 0.6017672823315339, 0.4651825278817945, 0.6038487844770358, 0.13448685854141096, 0.1341707259535524, 0.09930395536897918, 0.12869736554173505, 0.18602087860184047, 0.13672692216165083, 0.12493078110130573, 0.12767623168336306, 0.13479084595166113, 0.11115387332696025, 0.21212212026766797, 0.1254343161204894, 0.1587247961659921, 0.1512754026443155, 0.11727618362633618, 0.18685712696517043, 0.17493584502699921, 0.12816158021681767, 0.1291921996218912, 0.2670782279209497, 0.124076412940889, 0.13319371460251261, 0.12105165674860496, 0.14461996725038917, 0.19473993858016514, 0.14286838704691018, 0.13556208187632024, 0.24830113315066182, 0.16157492761655323, 0.2479909495683631, 0.18733012321077902, 0.2520032839408999, 0.17328172375007966, 0.21980454250068826, 0.19555089055145736, 0.18779456101624015, 0.10912932898462391, 0.13438412234635866, 0.06905017356854548, 0.12331529357222704, 0.09973910839939182, 0.12490110975646385, 0.15467494921778557, 0.07101120952452689, 0.0700791081658203, 0.17631271645818836, 0.24694915490924974, 0.18641231760040788, 0.20338862354116893, 0.19143500051370943, 0.18086942615481783, 0.21027659424532896, 0.23034686461877407, 0.2445669959550666, 0.5774743110795042, 0.6009010532467953, 0.5661660318447606, 0.48677744231648135, 0.48321097095443133, 0.3909856176500971, 0.5220081945294528, 0.5169226253472615, 0.547681719950079, 0.098357078495236, 0.09044756309358504, 0.09262408555249513, 0.08558900475471709, 0.09780348463321786, 0.08598745130217833, 0.08018687403005131, 0.1220946994819525, 0.09351516622878242, 0.15434818888554613, 0.1310410152485718, 0.12772492125872503, 0.13288378245589427, 0.16298627000710897, 0.14059327272472788, 0.13159245904383465, 0.14117231877510839, 0.14677192572340025, 0.2382819636479342, 0.27084012787706946, 0.2943620203018862, 0.2717416340737089, 0.29646497046672193, 0.2919793416343893, 0.24613714808956189, 0.32637137352732604, 0.2854673026837473, 0.21381780801405514, 0.19227208435855114, 0.22164394444283797, 0.23252321983180224, 0.2086756933959395, 0.23601140326381365, 0.21111905482702042, 0.25798022290372613, 0.1932534031286952, 0.17401159609736117, 0.1930749466879399, 0.1727393147600642, 0.1845003853992081, 0.19833847808323868, 0.1775907152884807, 0.19727016129343478, 0.18493557071064803, 0.1716421541812715, 0.18480382184022204, 0.17121045536690982, 0.16576915332428865, 0.16619888232550728, 0.1652908073871322, 0.16912954451757867, 0.16802089898458394, 0.17188055433372662, 0.1577457883424177, 0.2709593166919866, 0.17097988151784116, 0.14864226604299002, 0.3428769508249213, 0.36428634091649814, 0.17927364228159226, 0.16957906384453414, 0.16661002073399378, 0.30084217008411107, 0.35889631111069986, 0.44948201960542666, 0.21418957427891627, 0.1498060612173635, 0.2533694610958317, 0.1512701359346844, 0.2004636958720326, 0.2146323899417525, 0.23168762548764166, 0.18892554066718048, 0.1704150364995921, 0.17505681567115572, 0.16960080669429423, 0.16858191937696232, 0.16063425488431515, 0.17113672641015842, 0.1792751748575392, 0.16637680872418292, 0.06736978140131122, 0.07552499857695472, 0.08268958393551584, 0.07808660264686218, 0.07737034626800865, 0.07477407598272545, 0.06523869459001175, 0.07978198448673157, 0.0857464938691106]}, "mutation_prompt": null}
{"id": "be518e54-e3e0-4e89-b0a8-06248a5fa2c5", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.15\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.elite_fraction = 0.1\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        tournament_size = 5\n        indices = np.random.choice(self.population_size, tournament_size, replace=False)\n        selected_fitness = fitness[indices]\n        return indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        diversity = np.std(parent1 - parent2)\n        if np.random.rand() < self.crossover_rate * (1 + diversity):  # Adaptive crossover\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        diversity = np.std(b - c)\n        mutant = np.clip(a + 0.8 * (b - c) * (1 + diversity), self.lower_bound, self.upper_bound)  # Adaptive mutation\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:num_elites]\n            new_population[:num_elites] = population[elite_indices]\n\n            for i in range(num_elites, self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Enhanced Hybrid Genetic Algorithm with adaptive tournament selection strategy for improved convergence speed.", "configspace": "", "generation": 75, "fitness": 0.2393733170017269, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.18.", "error": "", "parent_id": "2155f422-22f4-41d2-aec7-ca715fdc2db2", "metadata": {"aucs": [0.6421743905090479, 0.6717020118401242, 0.5378176832901458, 0.4748249444252264, 0.535820233609771, 0.7199110933316066, 0.5793262170925216, 0.6320767113811596, 0.594806865215757, 0.22843392877353874, 0.14308594272362518, 0.2660027135993698, 0.2923230114212976, 0.24084894933462642, 0.27485368224391626, 0.19064246657484174, 0.2699166067866948, 0.22344012654908185, 0.10704799809772181, 0.08575664246574943, 0.09860707247319445, 0.09404260202570314, 0.09513914323503181, 0.08026086628811702, 0.11261871887455999, 0.08652117091733524, 0.10131717390431627, 0.08450778632665246, 0.06879288980873133, 0.07001256866388572, 0.07698021938456345, 0.07942952206383003, 0.06370614369029082, 0.0629218364671511, 0.07217133181637359, 0.08637823598456651, 0.4980212937045603, 0.869602677246745, 0.6351735094018282, 0.17161360991800845, 0.6339722778147999, 0.6890034622199067, 0.793188745933201, 0.7086552426671385, 0.6937678835948311, 0.2250520983423192, 0.19922569072070528, 0.22719922289978578, 0.20653700544755915, 0.21146552058651014, 0.20418357383428565, 0.19869759200216364, 0.14870555811112374, 0.2074976798324657, 0.6459259315882784, 0.648225433662905, 0.650079610661288, 0.6765020604544567, 0.6690609115336531, 0.467283108588712, 0.6017672823315339, 0.4651825278817945, 0.6038487844770358, 0.13448685854141096, 0.1341707259535524, 0.09930395536897918, 0.12869736554173505, 0.18602087860184047, 0.13672692216165083, 0.12493078110130573, 0.12767623168336306, 0.13479084595166113, 0.11115387332696025, 0.21212212026766797, 0.1254343161204894, 0.1587247961659921, 0.1512754026443155, 0.11727618362633618, 0.18685712696517043, 0.17493584502699921, 0.12816158021681767, 0.1291921996218912, 0.2670782279209497, 0.124076412940889, 0.13319371460251261, 0.12105165674860496, 0.14461996725038917, 0.19473993858016514, 0.14286838704691018, 0.13556208187632024, 0.24830113315066182, 0.16157492761655323, 0.2479909495683631, 0.18733012321077902, 0.2520032839408999, 0.17328172375007966, 0.21980454250068826, 0.19555089055145736, 0.18779456101624015, 0.10912932898462391, 0.13438412234635866, 0.06905017356854548, 0.12331529357222704, 0.09973910839939182, 0.12490110975646385, 0.15467494921778557, 0.07101120952452689, 0.0700791081658203, 0.17631271645818836, 0.24694915490924974, 0.18641231760040788, 0.20338862354116893, 0.19143500051370943, 0.18086942615481783, 0.21027659424532896, 0.23034686461877407, 0.2445669959550666, 0.5774743110795042, 0.6009010532467953, 0.5661660318447606, 0.48677744231648135, 0.48321097095443133, 0.3909856176500971, 0.5220081945294528, 0.5169226253472615, 0.547681719950079, 0.098357078495236, 0.09044756309358504, 0.09262408555249513, 0.08558900475471709, 0.09780348463321786, 0.08598745130217833, 0.08018687403005131, 0.1220946994819525, 0.09351516622878242, 0.15434818888554613, 0.1310410152485718, 0.12772492125872503, 0.13288378245589427, 0.16298627000710897, 0.14059327272472788, 0.13159245904383465, 0.14117231877510839, 0.14677192572340025, 0.2382819636479342, 0.27084012787706946, 0.2943620203018862, 0.2717416340737089, 0.29646497046672193, 0.2919793416343893, 0.24613714808956189, 0.32637137352732604, 0.2854673026837473, 0.21381780801405514, 0.19227208435855114, 0.22164394444283797, 0.23252321983180224, 0.2086756933959395, 0.23601140326381365, 0.21111905482702042, 0.25798022290372613, 0.1932534031286952, 0.17401159609736117, 0.1930749466879399, 0.1727393147600642, 0.1845003853992081, 0.19833847808323868, 0.1775907152884807, 0.19727016129343478, 0.18493557071064803, 0.1716421541812715, 0.18480382184022204, 0.17121045536690982, 0.16576915332428865, 0.16619888232550728, 0.1652908073871322, 0.16912954451757867, 0.16802089898458394, 0.17188055433372662, 0.1577457883424177, 0.2709593166919866, 0.17097988151784116, 0.14864226604299002, 0.3428769508249213, 0.36428634091649814, 0.17927364228159226, 0.16957906384453414, 0.16661002073399378, 0.30084217008411107, 0.35889631111069986, 0.44948201960542666, 0.21418957427891627, 0.1498060612173635, 0.2533694610958317, 0.1512701359346844, 0.2004636958720326, 0.2146323899417525, 0.23168762548764166, 0.18892554066718048, 0.1704150364995921, 0.17505681567115572, 0.16960080669429423, 0.16858191937696232, 0.16063425488431515, 0.17113672641015842, 0.1792751748575392, 0.16637680872418292, 0.06736978140131122, 0.07552499857695472, 0.08268958393551584, 0.07808660264686218, 0.07737034626800865, 0.07477407598272545, 0.06523869459001175, 0.07978198448673157, 0.0857464938691106]}, "mutation_prompt": null}
{"id": "6ede4740-9a67-4308-9e42-de28d98da4b1", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.15\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.elite_fraction = 0.1\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        diversity = np.std(parent1 - parent2)\n        if np.random.rand() < self.crossover_rate * (1 + diversity):  # Adaptive crossover\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        diversity = np.std(b - c)\n        mutant = np.clip(a + 0.8 * (b - c) * (1 + diversity), self.lower_bound, self.upper_bound)  # Adaptive mutation\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:num_elites]\n            new_population[:num_elites] = population[elite_indices]\n\n            for i in range(num_elites, self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Enhanced Hybrid Genetic Algorithm by introducing adaptive mutation and crossover rates based on fitness diversity for improved exploration-exploitation balance.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2155f422-22f4-41d2-aec7-ca715fdc2db2", "metadata": {"aucs": [0.6421743905090479, 0.6717020118401242, 0.5378176832901458, 0.4748249444252264, 0.535820233609771, 0.7199110933316066, 0.5793262170925216, 0.6320767113811596, 0.594806865215757, 0.22843392877353874, 0.14308594272362518, 0.2660027135993698, 0.2923230114212976, 0.24084894933462642, 0.27485368224391626, 0.19064246657484174, 0.2699166067866948, 0.22344012654908185, 0.10704799809772181, 0.08575664246574943, 0.09860707247319445, 0.09404260202570314, 0.09513914323503181, 0.08026086628811702, 0.11261871887455999, 0.08652117091733524, 0.10131717390431627, 0.08450778632665246, 0.06879288980873133, 0.07001256866388572, 0.07698021938456345, 0.07942952206383003, 0.06370614369029082, 0.0629218364671511, 0.07217133181637359, 0.08637823598456651, 0.4980212937045603, 0.869602677246745, 0.6351735094018282, 0.17161360991800845, 0.6339722778147999, 0.6890034622199067, 0.793188745933201, 0.7086552426671385, 0.6937678835948311, 0.2250520983423192, 0.19922569072070528, 0.22719922289978578, 0.20653700544755915, 0.21146552058651014, 0.20418357383428565, 0.19869759200216364, 0.14870555811112374, 0.2074976798324657, 0.6459259315882784, 0.648225433662905, 0.650079610661288, 0.6765020604544567, 0.6690609115336531, 0.467283108588712, 0.6017672823315339, 0.4651825278817945, 0.6038487844770358, 0.13448685854141096, 0.1341707259535524, 0.09930395536897918, 0.12869736554173505, 0.18602087860184047, 0.13672692216165083, 0.12493078110130573, 0.12767623168336306, 0.13479084595166113, 0.11115387332696025, 0.21212212026766797, 0.1254343161204894, 0.1587247961659921, 0.1512754026443155, 0.11727618362633618, 0.18685712696517043, 0.17493584502699921, 0.12816158021681767, 0.1291921996218912, 0.2670782279209497, 0.124076412940889, 0.13319371460251261, 0.12105165674860496, 0.14461996725038917, 0.19473993858016514, 0.14286838704691018, 0.13556208187632024, 0.24830113315066182, 0.16157492761655323, 0.2479909495683631, 0.18733012321077902, 0.2520032839408999, 0.17328172375007966, 0.21980454250068826, 0.19555089055145736, 0.18779456101624015, 0.10912932898462391, 0.13438412234635866, 0.06905017356854548, 0.12331529357222704, 0.09973910839939182, 0.12490110975646385, 0.15467494921778557, 0.07101120952452689, 0.0700791081658203, 0.17631271645818836, 0.24694915490924974, 0.18641231760040788, 0.20338862354116893, 0.19143500051370943, 0.18086942615481783, 0.21027659424532896, 0.23034686461877407, 0.2445669959550666, 0.5774743110795042, 0.6009010532467953, 0.5661660318447606, 0.48677744231648135, 0.48321097095443133, 0.3909856176500971, 0.5220081945294528, 0.5169226253472615, 0.547681719950079, 0.098357078495236, 0.09044756309358504, 0.09262408555249513, 0.08558900475471709, 0.09780348463321786, 0.08598745130217833, 0.08018687403005131, 0.1220946994819525, 0.09351516622878242, 0.15434818888554613, 0.1310410152485718, 0.12772492125872503, 0.13288378245589427, 0.16298627000710897, 0.14059327272472788, 0.13159245904383465, 0.14117231877510839, 0.14677192572340025, 0.2382819636479342, 0.27084012787706946, 0.2943620203018862, 0.2717416340737089, 0.29646497046672193, 0.2919793416343893, 0.24613714808956189, 0.32637137352732604, 0.2854673026837473, 0.21381780801405514, 0.19227208435855114, 0.22164394444283797, 0.23252321983180224, 0.2086756933959395, 0.23601140326381365, 0.21111905482702042, 0.25798022290372613, 0.1932534031286952, 0.17401159609736117, 0.1930749466879399, 0.1727393147600642, 0.1845003853992081, 0.19833847808323868, 0.1775907152884807, 0.19727016129343478, 0.18493557071064803, 0.1716421541812715, 0.18480382184022204, 0.17121045536690982, 0.16576915332428865, 0.16619888232550728, 0.1652908073871322, 0.16912954451757867, 0.16802089898458394, 0.17188055433372662, 0.1577457883424177, 0.2709593166919866, 0.17097988151784116, 0.14864226604299002, 0.3428769508249213, 0.36428634091649814, 0.17927364228159226, 0.16957906384453414, 0.16661002073399378, 0.30084217008411107, 0.35889631111069986, 0.44948201960542666, 0.21418957427891627, 0.1498060612173635, 0.2533694610958317, 0.1512701359346844, 0.2004636958720326, 0.2146323899417525, 0.23168762548764166, 0.18892554066718048, 0.1704150364995921, 0.17505681567115572, 0.16960080669429423, 0.16858191937696232, 0.16063425488431515, 0.17113672641015842, 0.1792751748575392, 0.16637680872418292, 0.06736978140131122, 0.07552499857695472, 0.08268958393551584, 0.07808660264686218, 0.07737034626800865, 0.07477407598272545, 0.06523869459001175, 0.07978198448673157, 0.0857464938691106]}, "mutation_prompt": null}
{"id": "e685d8f6-7ae4-410c-9b23-e0125bfb6e0d", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.15\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.elite_fraction = 0.1\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        diversity = np.std(parent1 - parent2)\n        if np.random.rand() < self.crossover_rate * (1 + diversity):  # Adaptive crossover\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        diversity = np.std(b - c)\n        mutant = np.clip(a + 0.8 * (b - c) * (1 + diversity), self.lower_bound, self.upper_bound)  # Adaptive mutation\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:num_elites]\n            new_population[:num_elites] = population[elite_indices]\n\n            for i in range(num_elites, self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Enhanced Hybrid Genetic Algorithm by introducing adaptive mutation and crossover rates based on fitness diversity for improved exploration-exploitation balance.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2155f422-22f4-41d2-aec7-ca715fdc2db2", "metadata": {"aucs": [0.6421743905090479, 0.6717020118401242, 0.5378176832901458, 0.4748249444252264, 0.535820233609771, 0.7199110933316066, 0.5793262170925216, 0.6320767113811596, 0.594806865215757, 0.22843392877353874, 0.14308594272362518, 0.2660027135993698, 0.2923230114212976, 0.24084894933462642, 0.27485368224391626, 0.19064246657484174, 0.2699166067866948, 0.22344012654908185, 0.10704799809772181, 0.08575664246574943, 0.09860707247319445, 0.09404260202570314, 0.09513914323503181, 0.08026086628811702, 0.11261871887455999, 0.08652117091733524, 0.10131717390431627, 0.08450778632665246, 0.06879288980873133, 0.07001256866388572, 0.07698021938456345, 0.07942952206383003, 0.06370614369029082, 0.0629218364671511, 0.07217133181637359, 0.08637823598456651, 0.4980212937045603, 0.869602677246745, 0.6351735094018282, 0.17161360991800845, 0.6339722778147999, 0.6890034622199067, 0.793188745933201, 0.7086552426671385, 0.6937678835948311, 0.2250520983423192, 0.19922569072070528, 0.22719922289978578, 0.20653700544755915, 0.21146552058651014, 0.20418357383428565, 0.19869759200216364, 0.14870555811112374, 0.2074976798324657, 0.6459259315882784, 0.648225433662905, 0.650079610661288, 0.6765020604544567, 0.6690609115336531, 0.467283108588712, 0.6017672823315339, 0.4651825278817945, 0.6038487844770358, 0.13448685854141096, 0.1341707259535524, 0.09930395536897918, 0.12869736554173505, 0.18602087860184047, 0.13672692216165083, 0.12493078110130573, 0.12767623168336306, 0.13479084595166113, 0.11115387332696025, 0.21212212026766797, 0.1254343161204894, 0.1587247961659921, 0.1512754026443155, 0.11727618362633618, 0.18685712696517043, 0.17493584502699921, 0.12816158021681767, 0.1291921996218912, 0.2670782279209497, 0.124076412940889, 0.13319371460251261, 0.12105165674860496, 0.14461996725038917, 0.19473993858016514, 0.14286838704691018, 0.13556208187632024, 0.24830113315066182, 0.16157492761655323, 0.2479909495683631, 0.18733012321077902, 0.2520032839408999, 0.17328172375007966, 0.21980454250068826, 0.19555089055145736, 0.18779456101624015, 0.10912932898462391, 0.13438412234635866, 0.06905017356854548, 0.12331529357222704, 0.09973910839939182, 0.12490110975646385, 0.15467494921778557, 0.07101120952452689, 0.0700791081658203, 0.17631271645818836, 0.24694915490924974, 0.18641231760040788, 0.20338862354116893, 0.19143500051370943, 0.18086942615481783, 0.21027659424532896, 0.23034686461877407, 0.2445669959550666, 0.5774743110795042, 0.6009010532467953, 0.5661660318447606, 0.48677744231648135, 0.48321097095443133, 0.3909856176500971, 0.5220081945294528, 0.5169226253472615, 0.547681719950079, 0.098357078495236, 0.09044756309358504, 0.09262408555249513, 0.08558900475471709, 0.09780348463321786, 0.08598745130217833, 0.08018687403005131, 0.1220946994819525, 0.09351516622878242, 0.15434818888554613, 0.1310410152485718, 0.12772492125872503, 0.13288378245589427, 0.16298627000710897, 0.14059327272472788, 0.13159245904383465, 0.14117231877510839, 0.14677192572340025, 0.2382819636479342, 0.27084012787706946, 0.2943620203018862, 0.2717416340737089, 0.29646497046672193, 0.2919793416343893, 0.24613714808956189, 0.32637137352732604, 0.2854673026837473, 0.21381780801405514, 0.19227208435855114, 0.22164394444283797, 0.23252321983180224, 0.2086756933959395, 0.23601140326381365, 0.21111905482702042, 0.25798022290372613, 0.1932534031286952, 0.17401159609736117, 0.1930749466879399, 0.1727393147600642, 0.1845003853992081, 0.19833847808323868, 0.1775907152884807, 0.19727016129343478, 0.18493557071064803, 0.1716421541812715, 0.18480382184022204, 0.17121045536690982, 0.16576915332428865, 0.16619888232550728, 0.1652908073871322, 0.16912954451757867, 0.16802089898458394, 0.17188055433372662, 0.1577457883424177, 0.2709593166919866, 0.17097988151784116, 0.14864226604299002, 0.3428769508249213, 0.36428634091649814, 0.17927364228159226, 0.16957906384453414, 0.16661002073399378, 0.30084217008411107, 0.35889631111069986, 0.44948201960542666, 0.21418957427891627, 0.1498060612173635, 0.2533694610958317, 0.1512701359346844, 0.2004636958720326, 0.2146323899417525, 0.23168762548764166, 0.18892554066718048, 0.1704150364995921, 0.17505681567115572, 0.16960080669429423, 0.16858191937696232, 0.16063425488431515, 0.17113672641015842, 0.1792751748575392, 0.16637680872418292, 0.06736978140131122, 0.07552499857695472, 0.08268958393551584, 0.07808660264686218, 0.07737034626800865, 0.07477407598272545, 0.06523869459001175, 0.07978198448673157, 0.0857464938691106]}, "mutation_prompt": null}
{"id": "80a577ef-b4c0-4328-ba1e-01d124de1e7d", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.15\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.elite_fraction = 0.1\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        diversity = np.std(parent1 - parent2)\n        if np.random.rand() < self.crossover_rate * (1 + diversity):  # Adaptive crossover\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        diversity = np.std(b - c)\n        mutant = np.clip(a + 0.8 * (b - c) * (1 + diversity), self.lower_bound, self.upper_bound)  # Adaptive mutation\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:num_elites]\n            new_population[:num_elites] = population[elite_indices]\n\n            for i in range(num_elites, self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Enhanced Hybrid Genetic Algorithm by introducing adaptive mutation and crossover rates based on fitness diversity for improved exploration-exploitation balance.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2155f422-22f4-41d2-aec7-ca715fdc2db2", "metadata": {"aucs": [0.6421743905090479, 0.6717020118401242, 0.5378176832901458, 0.4748249444252264, 0.535820233609771, 0.7199110933316066, 0.5793262170925216, 0.6320767113811596, 0.594806865215757, 0.22843392877353874, 0.14308594272362518, 0.2660027135993698, 0.2923230114212976, 0.24084894933462642, 0.27485368224391626, 0.19064246657484174, 0.2699166067866948, 0.22344012654908185, 0.10704799809772181, 0.08575664246574943, 0.09860707247319445, 0.09404260202570314, 0.09513914323503181, 0.08026086628811702, 0.11261871887455999, 0.08652117091733524, 0.10131717390431627, 0.08450778632665246, 0.06879288980873133, 0.07001256866388572, 0.07698021938456345, 0.07942952206383003, 0.06370614369029082, 0.0629218364671511, 0.07217133181637359, 0.08637823598456651, 0.4980212937045603, 0.869602677246745, 0.6351735094018282, 0.17161360991800845, 0.6339722778147999, 0.6890034622199067, 0.793188745933201, 0.7086552426671385, 0.6937678835948311, 0.2250520983423192, 0.19922569072070528, 0.22719922289978578, 0.20653700544755915, 0.21146552058651014, 0.20418357383428565, 0.19869759200216364, 0.14870555811112374, 0.2074976798324657, 0.6459259315882784, 0.648225433662905, 0.650079610661288, 0.6765020604544567, 0.6690609115336531, 0.467283108588712, 0.6017672823315339, 0.4651825278817945, 0.6038487844770358, 0.13448685854141096, 0.1341707259535524, 0.09930395536897918, 0.12869736554173505, 0.18602087860184047, 0.13672692216165083, 0.12493078110130573, 0.12767623168336306, 0.13479084595166113, 0.11115387332696025, 0.21212212026766797, 0.1254343161204894, 0.1587247961659921, 0.1512754026443155, 0.11727618362633618, 0.18685712696517043, 0.17493584502699921, 0.12816158021681767, 0.1291921996218912, 0.2670782279209497, 0.124076412940889, 0.13319371460251261, 0.12105165674860496, 0.14461996725038917, 0.19473993858016514, 0.14286838704691018, 0.13556208187632024, 0.24830113315066182, 0.16157492761655323, 0.2479909495683631, 0.18733012321077902, 0.2520032839408999, 0.17328172375007966, 0.21980454250068826, 0.19555089055145736, 0.18779456101624015, 0.10912932898462391, 0.13438412234635866, 0.06905017356854548, 0.12331529357222704, 0.09973910839939182, 0.12490110975646385, 0.15467494921778557, 0.07101120952452689, 0.0700791081658203, 0.17631271645818836, 0.24694915490924974, 0.18641231760040788, 0.20338862354116893, 0.19143500051370943, 0.18086942615481783, 0.21027659424532896, 0.23034686461877407, 0.2445669959550666, 0.5774743110795042, 0.6009010532467953, 0.5661660318447606, 0.48677744231648135, 0.48321097095443133, 0.3909856176500971, 0.5220081945294528, 0.5169226253472615, 0.547681719950079, 0.098357078495236, 0.09044756309358504, 0.09262408555249513, 0.08558900475471709, 0.09780348463321786, 0.08598745130217833, 0.08018687403005131, 0.1220946994819525, 0.09351516622878242, 0.15434818888554613, 0.1310410152485718, 0.12772492125872503, 0.13288378245589427, 0.16298627000710897, 0.14059327272472788, 0.13159245904383465, 0.14117231877510839, 0.14677192572340025, 0.2382819636479342, 0.27084012787706946, 0.2943620203018862, 0.2717416340737089, 0.29646497046672193, 0.2919793416343893, 0.24613714808956189, 0.32637137352732604, 0.2854673026837473, 0.21381780801405514, 0.19227208435855114, 0.22164394444283797, 0.23252321983180224, 0.2086756933959395, 0.23601140326381365, 0.21111905482702042, 0.25798022290372613, 0.1932534031286952, 0.17401159609736117, 0.1930749466879399, 0.1727393147600642, 0.1845003853992081, 0.19833847808323868, 0.1775907152884807, 0.19727016129343478, 0.18493557071064803, 0.1716421541812715, 0.18480382184022204, 0.17121045536690982, 0.16576915332428865, 0.16619888232550728, 0.1652908073871322, 0.16912954451757867, 0.16802089898458394, 0.17188055433372662, 0.1577457883424177, 0.2709593166919866, 0.17097988151784116, 0.14864226604299002, 0.3428769508249213, 0.36428634091649814, 0.17927364228159226, 0.16957906384453414, 0.16661002073399378, 0.30084217008411107, 0.35889631111069986, 0.44948201960542666, 0.21418957427891627, 0.1498060612173635, 0.2533694610958317, 0.1512701359346844, 0.2004636958720326, 0.2146323899417525, 0.23168762548764166, 0.18892554066718048, 0.1704150364995921, 0.17505681567115572, 0.16960080669429423, 0.16858191937696232, 0.16063425488431515, 0.17113672641015842, 0.1792751748575392, 0.16637680872418292, 0.06736978140131122, 0.07552499857695472, 0.08268958393551584, 0.07808660264686218, 0.07737034626800865, 0.07477407598272545, 0.06523869459001175, 0.07978198448673157, 0.0857464938691106]}, "mutation_prompt": null}
{"id": "61e61afa-9fc3-41ae-8e12-8ffed996a311", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.15\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.elite_fraction = 0.15  # Increased slightly\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        elite_index = selected_indices[np.argmin(selected_fitness)]\n        if np.random.rand() < 0.05:  # Introduce stochastic scaling\n            elite_index = np.random.choice(indices, 1)[0]\n        return elite_index\n    \n    def _crossover(self, parent1, parent2):\n        diversity = np.std(parent1 - parent2)\n        if np.random.rand() < self.crossover_rate * (1 + diversity):\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_scale = np.random.uniform(0.05, 0.15)  # Stochastic scaling\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * mutation_scale, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        diversity = np.std(b - c)\n        mutant = np.clip(a + 0.8 * (b - c) * (1 + diversity), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:num_elites]\n            new_population[:num_elites] = population[elite_indices]\n\n            for i in range(num_elites, self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Improved HybridGADE by integrating stochastic scaling in mutation and incorporating elitism in selection to accelerate convergence.", "configspace": "", "generation": 79, "fitness": 0.22670667285140653, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.17.", "error": "", "parent_id": "2155f422-22f4-41d2-aec7-ca715fdc2db2", "metadata": {"aucs": [0.5607458138502479, 0.579001609985905, 0.6454506138530531, 0.5432903850947721, 0.6683129392230982, 0.593601226644724, 0.66960499340038, 0.5390200208879066, 0.5590557461838703, 0.1836653032395914, 0.27246193221732584, 0.09901134430398983, 0.1308813236404669, 0.17465009224033934, 0.0722828244792525, 0.19768069455162973, 0.11362306743302275, 0.07351504951843801, 0.09376842670715357, 0.09114287036715318, 0.11201879677431426, 0.09507221708404956, 0.09131502144769532, 0.11772869952045362, 0.09112145299982, 0.09508190636450231, 0.09875972280122569, 0.07696349372987987, 0.07993298944240845, 0.07465905839705134, 0.08872774630603564, 0.07060443881838563, 0.0805964870570024, 0.07649848328899245, 0.06553651573739938, 0.0842237289786475, 0.489585429647593, 0.8493122093454119, 0.8102545093923771, 0.22739410394942972, 0.7350987555634452, 0.5977961721430012, 0.7353629658254086, 0.12048602651066942, 0.7483124339045258, 0.25939930344845574, 0.198676992621443, 0.27298034330422993, 0.15971433055305928, 0.20884548626190258, 0.17798492486289652, 0.18831342251904082, 0.2121599958153758, 0.18097064364148996, 0.6858199739112862, 0.6228911821323607, 0.5944676209597626, 0.6929269567037849, 0.7149812347575158, 0.7079586277463261, 0.21656830919266135, 0.29362260143173424, 0.6103411245263141, 0.11853305306226525, 0.12273697070771139, 0.13186584890404973, 0.13652535123867438, 0.20076027162061771, 0.17637820105090596, 0.13839679353457846, 0.12934492331504466, 0.23494592528141967, 0.1115406023746105, 0.14669403389895963, 0.14297258453146333, 0.13587533571826205, 0.1274747322775971, 0.15923793562234445, 0.16810195003854445, 0.13907413134951274, 0.12653180535002195, 0.1951204021135079, 0.10607588796897593, 0.1022438120517436, 0.14118153705334568, 0.1329750868567693, 0.20912784282811236, 0.14305791208157848, 0.13325886788792451, 0.17982536294757956, 0.2551549066620895, 0.1785145173329662, 0.28220928862548256, 0.1812086098271466, 0.1485889953959868, 0.17926844524708174, 0.27406382881324576, 0.26294154192082586, 0.21586534909030974, 0.10338385651539972, 0.10329775800445606, 0.11075027392117609, 0.10707713318112833, 0.13409377838105052, 0.1812645198274787, 0.12771438157526205, 0.10464740518212623, 0.10693310657931487, 0.1803684208031573, 0.104749408285704, 0.20836931049108998, 0.1459007700516859, 0.13129928366471666, 0.1382194215143021, 0.26015208082921915, 0.19444879053476516, 0.12205133964824, 0.5095246546136818, 0.4579064164654616, 0.44361297347166173, 0.4874529843810018, 0.41273858834670896, 0.403254324883908, 0.42986001361940473, 0.5221535397823824, 0.5487569732699953, 0.07538685780045129, 0.08186474433184632, 0.09260010663686713, 0.08906728510778772, 0.06892181570262779, 0.09644704358843115, 0.09167323166193131, 0.09552663243367587, 0.07985637979282034, 0.12221138543738252, 0.13557390672367275, 0.14598551185546071, 0.15983268749769886, 0.1396901644671893, 0.12550247061382036, 0.1323091557808742, 0.13729987263267174, 0.11773930313010605, 0.2916583084303275, 0.2883313539996586, 0.3159663372383005, 0.27250345014903354, 0.3006984695655045, 0.3164054969589861, 0.24091087387323273, 0.22089530717661843, 0.28029212139237203, 0.18559615976016186, 0.1794966174422723, 0.28641779490914476, 0.2822070139387508, 0.22300099212771185, 0.26996310153882863, 0.24641785483400658, 0.20019777241940473, 0.22087954268664767, 0.18795028450773832, 0.18226313980708075, 0.16923754870191698, 0.17723583022314793, 0.1757261285258006, 0.18577602602593424, 0.18957998695187928, 0.1718333778575648, 0.18827291472211416, 0.1793157330854105, 0.16634720512810441, 0.17339008118858423, 0.1927566152004262, 0.1739368711462248, 0.1580253334153363, 0.1766752250981466, 0.17540284245046456, 0.1786727585723551, 0.29676598204950944, 0.1759309754236883, 0.1396198536321197, 0.17623866057189208, 0.16510712838512287, 0.17680821687256498, 0.1727440819718271, 0.15528495678015675, 0.24407025988140785, 0.18152493682693271, 0.22716581247802436, 0.14914001932579413, 0.462797909888797, 0.1540232490109973, 0.147525371658481, 0.20176133535510454, 0.17055554949148977, 0.19605139392821802, 0.17729167671400814, 0.18701412649565408, 0.16608952807667243, 0.17544632832626794, 0.1765624655181809, 0.19201979702556993, 0.16857343565034077, 0.1746045659555835, 0.1535618272925875, 0.07610237443764234, 0.07270905306182263, 0.08964095175487041, 0.07573228964671341, 0.08524364855410349, 0.07065657902590516, 0.06849722269846426, 0.064608520289136, 0.06995935595622782]}, "mutation_prompt": null}
{"id": "69e55e2b-5d5f-4e14-8838-947ac8d2e95d", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.15\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.elite_fraction = 0.1\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        diversity = np.std(parent1 - parent2)\n        if np.random.rand() < self.crossover_rate * (1 + diversity):  # Adaptive crossover\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        diversity = np.std(b - c)\n        mutant = np.clip(a + 0.8 * (b - c) * (1 + diversity), self.lower_bound, self.upper_bound)  # Adaptive mutation\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:num_elites]\n            new_population[:num_elites] = population[elite_indices]\n\n            for i in range(num_elites, self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Enhanced Hybrid Genetic Algorithm by introducing adaptive mutation and crossover rates based on fitness diversity for improved exploration-exploitation balance.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2155f422-22f4-41d2-aec7-ca715fdc2db2", "metadata": {"aucs": [0.6421743905090479, 0.6717020118401242, 0.5378176832901458, 0.4748249444252264, 0.535820233609771, 0.7199110933316066, 0.5793262170925216, 0.6320767113811596, 0.594806865215757, 0.22843392877353874, 0.14308594272362518, 0.2660027135993698, 0.2923230114212976, 0.24084894933462642, 0.27485368224391626, 0.19064246657484174, 0.2699166067866948, 0.22344012654908185, 0.10704799809772181, 0.08575664246574943, 0.09860707247319445, 0.09404260202570314, 0.09513914323503181, 0.08026086628811702, 0.11261871887455999, 0.08652117091733524, 0.10131717390431627, 0.08450778632665246, 0.06879288980873133, 0.07001256866388572, 0.07698021938456345, 0.07942952206383003, 0.06370614369029082, 0.0629218364671511, 0.07217133181637359, 0.08637823598456651, 0.4980212937045603, 0.869602677246745, 0.6351735094018282, 0.17161360991800845, 0.6339722778147999, 0.6890034622199067, 0.793188745933201, 0.7086552426671385, 0.6937678835948311, 0.2250520983423192, 0.19922569072070528, 0.22719922289978578, 0.20653700544755915, 0.21146552058651014, 0.20418357383428565, 0.19869759200216364, 0.14870555811112374, 0.2074976798324657, 0.6459259315882784, 0.648225433662905, 0.650079610661288, 0.6765020604544567, 0.6690609115336531, 0.467283108588712, 0.6017672823315339, 0.4651825278817945, 0.6038487844770358, 0.13448685854141096, 0.1341707259535524, 0.09930395536897918, 0.12869736554173505, 0.18602087860184047, 0.13672692216165083, 0.12493078110130573, 0.12767623168336306, 0.13479084595166113, 0.11115387332696025, 0.21212212026766797, 0.1254343161204894, 0.1587247961659921, 0.1512754026443155, 0.11727618362633618, 0.18685712696517043, 0.17493584502699921, 0.12816158021681767, 0.1291921996218912, 0.2670782279209497, 0.124076412940889, 0.13319371460251261, 0.12105165674860496, 0.14461996725038917, 0.19473993858016514, 0.14286838704691018, 0.13556208187632024, 0.24830113315066182, 0.16157492761655323, 0.2479909495683631, 0.18733012321077902, 0.2520032839408999, 0.17328172375007966, 0.21980454250068826, 0.19555089055145736, 0.18779456101624015, 0.10912932898462391, 0.13438412234635866, 0.06905017356854548, 0.12331529357222704, 0.09973910839939182, 0.12490110975646385, 0.15467494921778557, 0.07101120952452689, 0.0700791081658203, 0.17631271645818836, 0.24694915490924974, 0.18641231760040788, 0.20338862354116893, 0.19143500051370943, 0.18086942615481783, 0.21027659424532896, 0.23034686461877407, 0.2445669959550666, 0.5774743110795042, 0.6009010532467953, 0.5661660318447606, 0.48677744231648135, 0.48321097095443133, 0.3909856176500971, 0.5220081945294528, 0.5169226253472615, 0.547681719950079, 0.098357078495236, 0.09044756309358504, 0.09262408555249513, 0.08558900475471709, 0.09780348463321786, 0.08598745130217833, 0.08018687403005131, 0.1220946994819525, 0.09351516622878242, 0.15434818888554613, 0.1310410152485718, 0.12772492125872503, 0.13288378245589427, 0.16298627000710897, 0.14059327272472788, 0.13159245904383465, 0.14117231877510839, 0.14677192572340025, 0.2382819636479342, 0.27084012787706946, 0.2943620203018862, 0.2717416340737089, 0.29646497046672193, 0.2919793416343893, 0.24613714808956189, 0.32637137352732604, 0.2854673026837473, 0.21381780801405514, 0.19227208435855114, 0.22164394444283797, 0.23252321983180224, 0.2086756933959395, 0.23601140326381365, 0.21111905482702042, 0.25798022290372613, 0.1932534031286952, 0.17401159609736117, 0.1930749466879399, 0.1727393147600642, 0.1845003853992081, 0.19833847808323868, 0.1775907152884807, 0.19727016129343478, 0.18493557071064803, 0.1716421541812715, 0.18480382184022204, 0.17121045536690982, 0.16576915332428865, 0.16619888232550728, 0.1652908073871322, 0.16912954451757867, 0.16802089898458394, 0.17188055433372662, 0.1577457883424177, 0.2709593166919866, 0.17097988151784116, 0.14864226604299002, 0.3428769508249213, 0.36428634091649814, 0.17927364228159226, 0.16957906384453414, 0.16661002073399378, 0.30084217008411107, 0.35889631111069986, 0.44948201960542666, 0.21418957427891627, 0.1498060612173635, 0.2533694610958317, 0.1512701359346844, 0.2004636958720326, 0.2146323899417525, 0.23168762548764166, 0.18892554066718048, 0.1704150364995921, 0.17505681567115572, 0.16960080669429423, 0.16858191937696232, 0.16063425488431515, 0.17113672641015842, 0.1792751748575392, 0.16637680872418292, 0.06736978140131122, 0.07552499857695472, 0.08268958393551584, 0.07808660264686218, 0.07737034626800865, 0.07477407598272545, 0.06523869459001175, 0.07978198448673157, 0.0857464938691106]}, "mutation_prompt": null}
{"id": "a763c927-6604-429d-aab3-64e2fc599e39", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.15\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.elite_fraction = 0.1\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        diversity = np.std(parent1 - parent2)\n        if np.random.rand() < self.crossover_rate * (1 + diversity):  # Adaptive crossover\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        diversity = np.std(b - c)\n        mutant = np.clip(a + 0.8 * (b - c) * (1 + diversity), self.lower_bound, self.upper_bound)  # Adaptive mutation\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:num_elites]\n            new_population[:num_elites] = population[elite_indices]\n\n            for i in range(num_elites, self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Enhanced Hybrid Genetic Algorithm by introducing adaptive mutation and crossover rates based on fitness diversity for improved exploration-exploitation balance.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2155f422-22f4-41d2-aec7-ca715fdc2db2", "metadata": {"aucs": [0.6421743905090479, 0.6717020118401242, 0.5378176832901458, 0.4748249444252264, 0.535820233609771, 0.7199110933316066, 0.5793262170925216, 0.6320767113811596, 0.594806865215757, 0.22843392877353874, 0.14308594272362518, 0.2660027135993698, 0.2923230114212976, 0.24084894933462642, 0.27485368224391626, 0.19064246657484174, 0.2699166067866948, 0.22344012654908185, 0.10704799809772181, 0.08575664246574943, 0.09860707247319445, 0.09404260202570314, 0.09513914323503181, 0.08026086628811702, 0.11261871887455999, 0.08652117091733524, 0.10131717390431627, 0.08450778632665246, 0.06879288980873133, 0.07001256866388572, 0.07698021938456345, 0.07942952206383003, 0.06370614369029082, 0.0629218364671511, 0.07217133181637359, 0.08637823598456651, 0.4980212937045603, 0.869602677246745, 0.6351735094018282, 0.17161360991800845, 0.6339722778147999, 0.6890034622199067, 0.793188745933201, 0.7086552426671385, 0.6937678835948311, 0.2250520983423192, 0.19922569072070528, 0.22719922289978578, 0.20653700544755915, 0.21146552058651014, 0.20418357383428565, 0.19869759200216364, 0.14870555811112374, 0.2074976798324657, 0.6459259315882784, 0.648225433662905, 0.650079610661288, 0.6765020604544567, 0.6690609115336531, 0.467283108588712, 0.6017672823315339, 0.4651825278817945, 0.6038487844770358, 0.13448685854141096, 0.1341707259535524, 0.09930395536897918, 0.12869736554173505, 0.18602087860184047, 0.13672692216165083, 0.12493078110130573, 0.12767623168336306, 0.13479084595166113, 0.11115387332696025, 0.21212212026766797, 0.1254343161204894, 0.1587247961659921, 0.1512754026443155, 0.11727618362633618, 0.18685712696517043, 0.17493584502699921, 0.12816158021681767, 0.1291921996218912, 0.2670782279209497, 0.124076412940889, 0.13319371460251261, 0.12105165674860496, 0.14461996725038917, 0.19473993858016514, 0.14286838704691018, 0.13556208187632024, 0.24830113315066182, 0.16157492761655323, 0.2479909495683631, 0.18733012321077902, 0.2520032839408999, 0.17328172375007966, 0.21980454250068826, 0.19555089055145736, 0.18779456101624015, 0.10912932898462391, 0.13438412234635866, 0.06905017356854548, 0.12331529357222704, 0.09973910839939182, 0.12490110975646385, 0.15467494921778557, 0.07101120952452689, 0.0700791081658203, 0.17631271645818836, 0.24694915490924974, 0.18641231760040788, 0.20338862354116893, 0.19143500051370943, 0.18086942615481783, 0.21027659424532896, 0.23034686461877407, 0.2445669959550666, 0.5774743110795042, 0.6009010532467953, 0.5661660318447606, 0.48677744231648135, 0.48321097095443133, 0.3909856176500971, 0.5220081945294528, 0.5169226253472615, 0.547681719950079, 0.098357078495236, 0.09044756309358504, 0.09262408555249513, 0.08558900475471709, 0.09780348463321786, 0.08598745130217833, 0.08018687403005131, 0.1220946994819525, 0.09351516622878242, 0.15434818888554613, 0.1310410152485718, 0.12772492125872503, 0.13288378245589427, 0.16298627000710897, 0.14059327272472788, 0.13159245904383465, 0.14117231877510839, 0.14677192572340025, 0.2382819636479342, 0.27084012787706946, 0.2943620203018862, 0.2717416340737089, 0.29646497046672193, 0.2919793416343893, 0.24613714808956189, 0.32637137352732604, 0.2854673026837473, 0.21381780801405514, 0.19227208435855114, 0.22164394444283797, 0.23252321983180224, 0.2086756933959395, 0.23601140326381365, 0.21111905482702042, 0.25798022290372613, 0.1932534031286952, 0.17401159609736117, 0.1930749466879399, 0.1727393147600642, 0.1845003853992081, 0.19833847808323868, 0.1775907152884807, 0.19727016129343478, 0.18493557071064803, 0.1716421541812715, 0.18480382184022204, 0.17121045536690982, 0.16576915332428865, 0.16619888232550728, 0.1652908073871322, 0.16912954451757867, 0.16802089898458394, 0.17188055433372662, 0.1577457883424177, 0.2709593166919866, 0.17097988151784116, 0.14864226604299002, 0.3428769508249213, 0.36428634091649814, 0.17927364228159226, 0.16957906384453414, 0.16661002073399378, 0.30084217008411107, 0.35889631111069986, 0.44948201960542666, 0.21418957427891627, 0.1498060612173635, 0.2533694610958317, 0.1512701359346844, 0.2004636958720326, 0.2146323899417525, 0.23168762548764166, 0.18892554066718048, 0.1704150364995921, 0.17505681567115572, 0.16960080669429423, 0.16858191937696232, 0.16063425488431515, 0.17113672641015842, 0.1792751748575392, 0.16637680872418292, 0.06736978140131122, 0.07552499857695472, 0.08268958393551584, 0.07808660264686218, 0.07737034626800865, 0.07477407598272545, 0.06523869459001175, 0.07978198448673157, 0.0857464938691106]}, "mutation_prompt": null}
{"id": "25111790-3ad4-41f1-8308-dde05ddbdc8f", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.15\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.elite_fraction = 0.1\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        diversity = np.std(parent1 - parent2)\n        if np.random.rand() < self.crossover_rate * (1 + diversity):  # Adaptive crossover\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        diversity = np.std(b - c)\n        mutant = np.clip(a + 0.8 * (b - c) * (1 + diversity), self.lower_bound, self.upper_bound)  # Adaptive mutation\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:num_elites]\n            new_population[:num_elites] = population[elite_indices]\n\n            for i in range(num_elites, self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Enhanced Hybrid Genetic Algorithm by introducing adaptive mutation and crossover rates based on fitness diversity for improved exploration-exploitation balance.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2155f422-22f4-41d2-aec7-ca715fdc2db2", "metadata": {"aucs": [0.6421743905090479, 0.6717020118401242, 0.5378176832901458, 0.4748249444252264, 0.535820233609771, 0.7199110933316066, 0.5793262170925216, 0.6320767113811596, 0.594806865215757, 0.22843392877353874, 0.14308594272362518, 0.2660027135993698, 0.2923230114212976, 0.24084894933462642, 0.27485368224391626, 0.19064246657484174, 0.2699166067866948, 0.22344012654908185, 0.10704799809772181, 0.08575664246574943, 0.09860707247319445, 0.09404260202570314, 0.09513914323503181, 0.08026086628811702, 0.11261871887455999, 0.08652117091733524, 0.10131717390431627, 0.08450778632665246, 0.06879288980873133, 0.07001256866388572, 0.07698021938456345, 0.07942952206383003, 0.06370614369029082, 0.0629218364671511, 0.07217133181637359, 0.08637823598456651, 0.4980212937045603, 0.869602677246745, 0.6351735094018282, 0.17161360991800845, 0.6339722778147999, 0.6890034622199067, 0.793188745933201, 0.7086552426671385, 0.6937678835948311, 0.2250520983423192, 0.19922569072070528, 0.22719922289978578, 0.20653700544755915, 0.21146552058651014, 0.20418357383428565, 0.19869759200216364, 0.14870555811112374, 0.2074976798324657, 0.6459259315882784, 0.648225433662905, 0.650079610661288, 0.6765020604544567, 0.6690609115336531, 0.467283108588712, 0.6017672823315339, 0.4651825278817945, 0.6038487844770358, 0.13448685854141096, 0.1341707259535524, 0.09930395536897918, 0.12869736554173505, 0.18602087860184047, 0.13672692216165083, 0.12493078110130573, 0.12767623168336306, 0.13479084595166113, 0.11115387332696025, 0.21212212026766797, 0.1254343161204894, 0.1587247961659921, 0.1512754026443155, 0.11727618362633618, 0.18685712696517043, 0.17493584502699921, 0.12816158021681767, 0.1291921996218912, 0.2670782279209497, 0.124076412940889, 0.13319371460251261, 0.12105165674860496, 0.14461996725038917, 0.19473993858016514, 0.14286838704691018, 0.13556208187632024, 0.24830113315066182, 0.16157492761655323, 0.2479909495683631, 0.18733012321077902, 0.2520032839408999, 0.17328172375007966, 0.21980454250068826, 0.19555089055145736, 0.18779456101624015, 0.10912932898462391, 0.13438412234635866, 0.06905017356854548, 0.12331529357222704, 0.09973910839939182, 0.12490110975646385, 0.15467494921778557, 0.07101120952452689, 0.0700791081658203, 0.17631271645818836, 0.24694915490924974, 0.18641231760040788, 0.20338862354116893, 0.19143500051370943, 0.18086942615481783, 0.21027659424532896, 0.23034686461877407, 0.2445669959550666, 0.5774743110795042, 0.6009010532467953, 0.5661660318447606, 0.48677744231648135, 0.48321097095443133, 0.3909856176500971, 0.5220081945294528, 0.5169226253472615, 0.547681719950079, 0.098357078495236, 0.09044756309358504, 0.09262408555249513, 0.08558900475471709, 0.09780348463321786, 0.08598745130217833, 0.08018687403005131, 0.1220946994819525, 0.09351516622878242, 0.15434818888554613, 0.1310410152485718, 0.12772492125872503, 0.13288378245589427, 0.16298627000710897, 0.14059327272472788, 0.13159245904383465, 0.14117231877510839, 0.14677192572340025, 0.2382819636479342, 0.27084012787706946, 0.2943620203018862, 0.2717416340737089, 0.29646497046672193, 0.2919793416343893, 0.24613714808956189, 0.32637137352732604, 0.2854673026837473, 0.21381780801405514, 0.19227208435855114, 0.22164394444283797, 0.23252321983180224, 0.2086756933959395, 0.23601140326381365, 0.21111905482702042, 0.25798022290372613, 0.1932534031286952, 0.17401159609736117, 0.1930749466879399, 0.1727393147600642, 0.1845003853992081, 0.19833847808323868, 0.1775907152884807, 0.19727016129343478, 0.18493557071064803, 0.1716421541812715, 0.18480382184022204, 0.17121045536690982, 0.16576915332428865, 0.16619888232550728, 0.1652908073871322, 0.16912954451757867, 0.16802089898458394, 0.17188055433372662, 0.1577457883424177, 0.2709593166919866, 0.17097988151784116, 0.14864226604299002, 0.3428769508249213, 0.36428634091649814, 0.17927364228159226, 0.16957906384453414, 0.16661002073399378, 0.30084217008411107, 0.35889631111069986, 0.44948201960542666, 0.21418957427891627, 0.1498060612173635, 0.2533694610958317, 0.1512701359346844, 0.2004636958720326, 0.2146323899417525, 0.23168762548764166, 0.18892554066718048, 0.1704150364995921, 0.17505681567115572, 0.16960080669429423, 0.16858191937696232, 0.16063425488431515, 0.17113672641015842, 0.1792751748575392, 0.16637680872418292, 0.06736978140131122, 0.07552499857695472, 0.08268958393551584, 0.07808660264686218, 0.07737034626800865, 0.07477407598272545, 0.06523869459001175, 0.07978198448673157, 0.0857464938691106]}, "mutation_prompt": null}
{"id": "9b91a71b-ea98-4088-bb3e-86e929719ab9", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.15\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.elite_fraction = 0.1\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        fitness_rank = np.argsort(np.argsort(fitness))  # Rank-based selection\n        selection_prob = (1 / (fitness_rank + 1)) / np.sum(1 / (fitness_rank + 1))\n        return np.random.choice(np.arange(self.population_size), p=selection_prob)\n    \n    def _crossover(self, parent1, parent2):\n        diversity = np.std(parent1 - parent2)\n        if np.random.rand() < self.crossover_rate * (1 + diversity):\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        diversity = np.std(b - c)\n        mutant = np.clip(a + 0.8 * (b - c) * (1 + diversity), self.lower_bound, self.upper_bound)\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:num_elites]\n            new_population[:num_elites] = population[elite_indices]\n\n            for i in range(num_elites, self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Introducing a Rank-Based Parent Selection Mechanism for Enhanced Genetic Diversity and Faster Convergence.", "configspace": "", "generation": 83, "fitness": 0.2310171990089987, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.16.", "error": "", "parent_id": "2155f422-22f4-41d2-aec7-ca715fdc2db2", "metadata": {"aucs": [0.5766058997034533, 0.5679591683961327, 0.5198402154443883, 0.5572757590288492, 0.5060297583941785, 0.5617399828751146, 0.5356689747106779, 0.4801091113901327, 0.479297604175976, 0.2533738698959562, 0.2529351911044102, 0.23842171178803206, 0.22393368968688132, 0.3005753406821542, 0.36454626118014577, 0.14227359328559264, 0.2627884975454897, 0.22596822468047917, 0.08195144497356599, 0.09727726755880395, 0.0771971994022379, 0.09359239663799124, 0.08393309964346751, 0.10244868977516486, 0.09905053410532871, 0.10754352433198167, 0.09686841859828943, 0.07066196428496319, 0.08128882066343535, 0.06774668612815604, 0.0701677191054465, 0.07272729740483341, 0.08137348104847264, 0.06800240246117883, 0.06861819506415745, 0.09747863208611074, 0.6190073997491271, 0.6956678604564601, 0.8252227957548206, 0.7501985754521483, 0.6468235813688801, 0.20225512959732117, 0.709438001583546, 0.5735642134240897, 0.19236902723297544, 0.2158140366196013, 0.16347776805202952, 0.2253947473100847, 0.24374875468572688, 0.21804108144844303, 0.2163928425745939, 0.2146570193807137, 0.22509009450908324, 0.21111158825012877, 0.6083713073822863, 0.6240012972900184, 0.49234440270395197, 0.6394963954334445, 0.7256368534745479, 0.6586270737220412, 0.6011556799171676, 0.49561675697302765, 0.5135693516706856, 0.10691051203603308, 0.11055681883148938, 0.1067506963231899, 0.13173355150287647, 0.1867819329237297, 0.11502204672075189, 0.11180399821751363, 0.11808617497270624, 0.1343735197606868, 0.128720439240117, 0.12667452776831978, 0.12113686692897141, 0.14049781242942194, 0.12213879854478005, 0.12297068075760687, 0.12726971031719203, 0.2749322524255875, 0.13182133832663, 0.016462192669195463, 0.16042649565810518, 0.13055212999788923, 0.15073109899675963, 0.21540552435978266, 0.1811944056071102, 0.05699501144168406, 0.16558743487261196, 0.11492636124908462, 0.3317929903559296, 0.21830793820240701, 0.22262744663048595, 0.1441546248714567, 0.14637229771315596, 0.1996002382065234, 0.20757128160794758, 0.21697722365061722, 0.17810568332958432, 0.13007814775673032, 0.1183344952528752, 0.10281641347884074, 0.12356091465933805, 0.09317840088348661, 0.09057528690804117, 0.1297868895822738, 0.08752081331752648, 0.18341646781451726, 0.22427403062192852, 0.20224898838415195, 0.15984980615276256, 0.2081712979780992, 0.21595926250604702, 0.21465514953693532, 0.12776148974047297, 0.1438036271592339, 0.1715853490628082, 0.4698956846898147, 0.4559694992823916, 0.48422494802501115, 0.4346054053097582, 0.4079312561527825, 0.3584450538622739, 0.4475214583116349, 0.4843773245496359, 0.5709379884360859, 0.08712235183057637, 0.08383977447106339, 0.09421845443129206, 0.07998263639204162, 0.08559087678410127, 0.08834031144795118, 0.09843954722931525, 0.09494382555660175, 0.08107934682046414, 0.137489492733615, 0.14605256659787424, 0.15642155796806723, 0.14315106870133054, 0.12440970891852432, 0.1349963194892636, 0.16380552338053656, 0.13579932430405628, 0.1492904906993081, 0.2660388153714188, 0.2792701540575938, 0.27722514362344086, 0.3009729434990851, 0.26868230286637995, 0.29160587076485833, 0.2860108034468447, 0.2981490062554527, 0.3046788032752379, 0.19924692274533096, 0.2265501318967974, 0.21765279430498463, 0.2636917326246031, 0.22177205290852697, 0.23314295495897974, 0.2647847945158396, 0.22045533786414884, 0.2284529236422228, 0.18171499184445616, 0.17680061060614227, 0.1899075528323817, 0.1832660211232665, 0.21737280143618587, 0.20520567102688358, 0.19266683077130986, 0.17899977330959993, 0.18956692988477952, 0.1661862571345446, 0.17939277451973323, 0.16516420647263708, 0.16989441702273234, 0.17968107827559865, 0.1620762232056544, 0.16558675812924206, 0.17389066967144595, 0.17084389634756159, 0.17011663476453776, 0.39530203557041454, 0.2917543374754622, 0.3175056191767416, 0.1660266280358519, 0.3043248413204588, 0.15804825114520482, 0.16560123319581965, 0.36907659648969027, 0.1892416070063223, 0.16019637182918556, 0.5094560034619524, 0.15521411800409146, 0.15796791395846121, 0.23501314461735734, 0.19993006634487565, 0.18900141118300995, 0.16302882820546294, 0.19484491526271486, 0.17036431206095715, 0.1655438669810244, 0.1735190351490704, 0.1807350945912113, 0.16523419420552854, 0.1663968679192569, 0.1671353421110322, 0.16817051425879814, 0.07414324910133341, 0.092656844258588, 0.07103488728070406, 0.06267739947895679, 0.06911438235233147, 0.07305140884425276, 0.09015174433450579, 0.06614166220610862, 0.07859772364859308]}, "mutation_prompt": null}
{"id": "947b266c-ff6b-4671-8a74-a7bbddc4e874", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.15\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.elite_fraction = 0.1\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        diversity = np.std(parent1 - parent2)\n        if np.random.rand() < self.crossover_rate * (1 + diversity):  # Adaptive crossover\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        diversity = np.std(b - c)\n        mutant = np.clip(a + 0.8 * (b - c) * (1 + diversity), self.lower_bound, self.upper_bound)  # Adaptive mutation\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:num_elites]\n            new_population[:num_elites] = population[elite_indices]\n\n            for i in range(num_elites, self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n\n            # Dynamically adjust elitism based on convergence status\n            if eval_count % (0.1 * self.budget) == 0:  # Check interval\n                avg_fitness = np.mean(fitness)\n                if np.std(fitness) < 0.05 * avg_fitness:  # Low diversity\n                    self.elite_fraction = min(0.2, self.elite_fraction + 0.02)\n                else:\n                    self.elite_fraction = max(0.05, self.elite_fraction - 0.01)\n\n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Enhanced Hybrid Genetic Algorithm with adaptive elitism integration for dynamic exploration-exploitation enhancement.", "configspace": "", "generation": 84, "fitness": 0.2393733170017269, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.18.", "error": "", "parent_id": "2155f422-22f4-41d2-aec7-ca715fdc2db2", "metadata": {"aucs": [0.6421743905090479, 0.6717020118401242, 0.5378176832901458, 0.4748249444252264, 0.535820233609771, 0.7199110933316066, 0.5793262170925216, 0.6320767113811596, 0.594806865215757, 0.22843392877353874, 0.14308594272362518, 0.2660027135993698, 0.2923230114212976, 0.24084894933462642, 0.27485368224391626, 0.19064246657484174, 0.2699166067866948, 0.22344012654908185, 0.10704799809772181, 0.08575664246574943, 0.09860707247319445, 0.09404260202570314, 0.09513914323503181, 0.08026086628811702, 0.11261871887455999, 0.08652117091733524, 0.10131717390431627, 0.08450778632665246, 0.06879288980873133, 0.07001256866388572, 0.07698021938456345, 0.07942952206383003, 0.06370614369029082, 0.0629218364671511, 0.07217133181637359, 0.08637823598456651, 0.4980212937045603, 0.869602677246745, 0.6351735094018282, 0.17161360991800845, 0.6339722778147999, 0.6890034622199067, 0.793188745933201, 0.7086552426671385, 0.6937678835948311, 0.2250520983423192, 0.19922569072070528, 0.22719922289978578, 0.20653700544755915, 0.21146552058651014, 0.20418357383428565, 0.19869759200216364, 0.14870555811112374, 0.2074976798324657, 0.6459259315882784, 0.648225433662905, 0.650079610661288, 0.6765020604544567, 0.6690609115336531, 0.467283108588712, 0.6017672823315339, 0.4651825278817945, 0.6038487844770358, 0.13448685854141096, 0.1341707259535524, 0.09930395536897918, 0.12869736554173505, 0.18602087860184047, 0.13672692216165083, 0.12493078110130573, 0.12767623168336306, 0.13479084595166113, 0.11115387332696025, 0.21212212026766797, 0.1254343161204894, 0.1587247961659921, 0.1512754026443155, 0.11727618362633618, 0.18685712696517043, 0.17493584502699921, 0.12816158021681767, 0.1291921996218912, 0.2670782279209497, 0.124076412940889, 0.13319371460251261, 0.12105165674860496, 0.14461996725038917, 0.19473993858016514, 0.14286838704691018, 0.13556208187632024, 0.24830113315066182, 0.16157492761655323, 0.2479909495683631, 0.18733012321077902, 0.2520032839408999, 0.17328172375007966, 0.21980454250068826, 0.19555089055145736, 0.18779456101624015, 0.10912932898462391, 0.13438412234635866, 0.06905017356854548, 0.12331529357222704, 0.09973910839939182, 0.12490110975646385, 0.15467494921778557, 0.07101120952452689, 0.0700791081658203, 0.17631271645818836, 0.24694915490924974, 0.18641231760040788, 0.20338862354116893, 0.19143500051370943, 0.18086942615481783, 0.21027659424532896, 0.23034686461877407, 0.2445669959550666, 0.5774743110795042, 0.6009010532467953, 0.5661660318447606, 0.48677744231648135, 0.48321097095443133, 0.3909856176500971, 0.5220081945294528, 0.5169226253472615, 0.547681719950079, 0.098357078495236, 0.09044756309358504, 0.09262408555249513, 0.08558900475471709, 0.09780348463321786, 0.08598745130217833, 0.08018687403005131, 0.1220946994819525, 0.09351516622878242, 0.15434818888554613, 0.1310410152485718, 0.12772492125872503, 0.13288378245589427, 0.16298627000710897, 0.14059327272472788, 0.13159245904383465, 0.14117231877510839, 0.14677192572340025, 0.2382819636479342, 0.27084012787706946, 0.2943620203018862, 0.2717416340737089, 0.29646497046672193, 0.2919793416343893, 0.24613714808956189, 0.32637137352732604, 0.2854673026837473, 0.21381780801405514, 0.19227208435855114, 0.22164394444283797, 0.23252321983180224, 0.2086756933959395, 0.23601140326381365, 0.21111905482702042, 0.25798022290372613, 0.1932534031286952, 0.17401159609736117, 0.1930749466879399, 0.1727393147600642, 0.1845003853992081, 0.19833847808323868, 0.1775907152884807, 0.19727016129343478, 0.18493557071064803, 0.1716421541812715, 0.18480382184022204, 0.17121045536690982, 0.16576915332428865, 0.16619888232550728, 0.1652908073871322, 0.16912954451757867, 0.16802089898458394, 0.17188055433372662, 0.1577457883424177, 0.2709593166919866, 0.17097988151784116, 0.14864226604299002, 0.3428769508249213, 0.36428634091649814, 0.17927364228159226, 0.16957906384453414, 0.16661002073399378, 0.30084217008411107, 0.35889631111069986, 0.44948201960542666, 0.21418957427891627, 0.1498060612173635, 0.2533694610958317, 0.1512701359346844, 0.2004636958720326, 0.2146323899417525, 0.23168762548764166, 0.18892554066718048, 0.1704150364995921, 0.17505681567115572, 0.16960080669429423, 0.16858191937696232, 0.16063425488431515, 0.17113672641015842, 0.1792751748575392, 0.16637680872418292, 0.06736978140131122, 0.07552499857695472, 0.08268958393551584, 0.07808660264686218, 0.07737034626800865, 0.07477407598272545, 0.06523869459001175, 0.07978198448673157, 0.0857464938691106]}, "mutation_prompt": null}
{"id": "3cd1c448-ef47-44be-88c2-e7d9eba22dd4", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = max(5 * dim, 20)\n        self.population_size = self.initial_population_size\n        self.mutation_prob = 0.15\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.elite_fraction = 0.1\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        diversity = np.std(parent1 - parent2)\n        if np.random.rand() < self.crossover_rate * (1 + diversity):  # Adaptive crossover\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        diversity = np.std(b - c)\n        mutant = np.clip(a + 0.8 * (b - c) * (1 + diversity), self.lower_bound, self.upper_bound)  # Adaptive mutation\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def _adjust_population_size(self, prev_best_fitness, current_best_fitness):\n        if current_best_fitness < prev_best_fitness:\n            self.population_size = min(self.population_size + 1, self.initial_population_size * 2)\n        else:\n            self.population_size = max(self.population_size - 1, self.initial_population_size)\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:num_elites]\n            new_population[:num_elites] = population[elite_indices]\n\n            prev_best_fitness = fitness[best_idx]\n\n            for i in range(num_elites, self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            current_best_fitness = fitness[current_best_idx]\n            self._adjust_population_size(prev_best_fitness, current_best_fitness)\n\n            if current_best_fitness < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Introduced a dynamic population size adjustment based on convergence speed to enhance adaptability and convergence efficiency.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 25 is out of bounds for axis 0 with size 25').", "error": "IndexError('index 25 is out of bounds for axis 0 with size 25')", "parent_id": "2155f422-22f4-41d2-aec7-ca715fdc2db2", "metadata": {}, "mutation_prompt": null}
{"id": "11de5600-4b1d-4109-92c2-1d8886051754", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.15\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.elite_fraction = 0.1\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        diversity = np.std(parent1 - parent2)\n        if np.random.rand() < self.crossover_rate * (1 + diversity):  # Adaptive crossover\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring, diversity_factor):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            scale = 0.1 * (1 + diversity_factor)  # Dynamic mutation scaling\n            return np.clip(offspring + mutation_vector * scale, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        diversity = np.std(b - c)\n        mutant = np.clip(a + 0.8 * (b - c) * (1 + diversity), self.lower_bound, self.upper_bound)  # Adaptive mutation\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial, diversity)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            num_elites = max(int(self.elite_fraction * self.population_size * (1 + np.std(fitness))), 1)  # Adaptive elite selection\n            elite_indices = np.argsort(fitness)[:num_elites]\n            new_population[:num_elites] = population[elite_indices]\n\n            for i in range(num_elites, self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Introduced adaptive elite selection and dynamic mutation scaling to boost convergence speed and optimization performance.", "configspace": "", "generation": 86, "fitness": 0.040979985293036446, "feedback": "The algorithm HybridGADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.05.", "error": "", "parent_id": "2155f422-22f4-41d2-aec7-ca715fdc2db2", "metadata": {"aucs": [0.07181397830146763, 0.06432772651221763, 0.09169502728636048, 0.08952233024927114, 0.062138895920524906, 0.07709668639236078, 0.07795415841203734, 0.07431300570909605, 0.06711154613058024, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01467079663371329, 0.005375109906600173, 0.010643411704069683, 0.0012186513362246743, 0.006669962766643223, 0.018248263482334326, 9.999999999998899e-05, 0.010674738340807233, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01959972157639278, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.045179741609489454, 0.04219942533172094, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.03775594762470191, 0.052233822106523387, 0.0667108215001172, 0.02725496812965944, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.11141543037622592, 0.14838054695461433, 0.09425923977458062, 0.09708865527373767, 0.09580441870675127, 0.1240568991094797, 0.09716408355800721, 0.1210557193025883, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006101769545772684, 9.999999999998899e-05, 0.01759993274736349, 9.999999999998899e-05, 9.999999999998899e-05, 0.0267656688986897, 0.07037543064596374, 0.06735693451091307, 0.059328965068867756, 0.09855305120349966, 0.10852972522114013, 0.05643121168494414, 0.08808199726801991, 0.05671393358747501, 0.07726393575557644, 0.09606267484187503, 0.0962505644704219, 0.14352810184653642, 0.13800672315110074, 0.09261918780562917, 0.1025140421398899, 0.12028165949079228, 0.17377774300845283, 0.2998964706518539, 0.033318937593247444, 0.034008147686441226, 0.05463654710198407, 0.056957211629895754, 0.06406947898089654, 0.06342850570876157, 0.0837317855149382, 0.09386031173166853, 0.06412526395900253, 0.0916346253723066, 0.06586919676070013, 0.13345086981233123, 0.10289055837941885, 0.07855245954393053, 0.08853961034790592, 0.12245976138762271, 0.07872931414554718, 0.1261963614278906, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05568623559107733, 0.07466602457976645, 0.08167024703901915, 0.06718871428537254, 0.1207914665021157, 0.06661401029160186, 0.07245568600050101, 0.09643604708838482, 0.0693612576838919, 0.03824121102611444, 0.10051730792859848, 0.068359240967509, 0.0506857903344724, 0.03738259240699027, 0.045511073114331335, 0.04690376827171172, 0.05688580952621014, 0.04143420019681854, 0.19989062504120048, 0.16482416570762415, 0.14763022729669195, 0.19146980149841164, 0.1731572751654361, 0.18424263724442258, 0.14969714796693134, 0.10862764757569365, 0.1830123367496057, 0.0021768943126481144, 0.015916393435176368, 0.031393493129599714, 0.027015293023570086, 0.018487330591705486, 0.020045516730027746, 0.011149453589241465, 9.999999999998899e-05, 0.01745630416284416]}, "mutation_prompt": null}
{"id": "4e5422b7-887f-4eaf-a98d-e87dc3349e10", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.15\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.elite_fraction = 0.1\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        diversity = np.std(parent1 - parent2)\n        if np.random.rand() < self.crossover_rate * (1 + diversity):  # Adaptive crossover\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        diversity = np.std(b - c)\n        mutant = np.clip(a + 0.8 * (b - c) * (1 + diversity), self.lower_bound, self.upper_bound)  # Adaptive mutation\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:num_elites]\n            new_population[:num_elites] = population[elite_indices]\n\n            for i in range(num_elites, self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Enhanced Hybrid Genetic Algorithm by introducing adaptive mutation and crossover rates based on fitness diversity for improved exploration-exploitation balance.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2155f422-22f4-41d2-aec7-ca715fdc2db2", "metadata": {"aucs": [0.6421743905090479, 0.6717020118401242, 0.5378176832901458, 0.4748249444252264, 0.535820233609771, 0.7199110933316066, 0.5793262170925216, 0.6320767113811596, 0.594806865215757, 0.22843392877353874, 0.14308594272362518, 0.2660027135993698, 0.2923230114212976, 0.24084894933462642, 0.27485368224391626, 0.19064246657484174, 0.2699166067866948, 0.22344012654908185, 0.10704799809772181, 0.08575664246574943, 0.09860707247319445, 0.09404260202570314, 0.09513914323503181, 0.08026086628811702, 0.11261871887455999, 0.08652117091733524, 0.10131717390431627, 0.08450778632665246, 0.06879288980873133, 0.07001256866388572, 0.07698021938456345, 0.07942952206383003, 0.06370614369029082, 0.0629218364671511, 0.07217133181637359, 0.08637823598456651, 0.4980212937045603, 0.869602677246745, 0.6351735094018282, 0.17161360991800845, 0.6339722778147999, 0.6890034622199067, 0.793188745933201, 0.7086552426671385, 0.6937678835948311, 0.2250520983423192, 0.19922569072070528, 0.22719922289978578, 0.20653700544755915, 0.21146552058651014, 0.20418357383428565, 0.19869759200216364, 0.14870555811112374, 0.2074976798324657, 0.6459259315882784, 0.648225433662905, 0.650079610661288, 0.6765020604544567, 0.6690609115336531, 0.467283108588712, 0.6017672823315339, 0.4651825278817945, 0.6038487844770358, 0.13448685854141096, 0.1341707259535524, 0.09930395536897918, 0.12869736554173505, 0.18602087860184047, 0.13672692216165083, 0.12493078110130573, 0.12767623168336306, 0.13479084595166113, 0.11115387332696025, 0.21212212026766797, 0.1254343161204894, 0.1587247961659921, 0.1512754026443155, 0.11727618362633618, 0.18685712696517043, 0.17493584502699921, 0.12816158021681767, 0.1291921996218912, 0.2670782279209497, 0.124076412940889, 0.13319371460251261, 0.12105165674860496, 0.14461996725038917, 0.19473993858016514, 0.14286838704691018, 0.13556208187632024, 0.24830113315066182, 0.16157492761655323, 0.2479909495683631, 0.18733012321077902, 0.2520032839408999, 0.17328172375007966, 0.21980454250068826, 0.19555089055145736, 0.18779456101624015, 0.10912932898462391, 0.13438412234635866, 0.06905017356854548, 0.12331529357222704, 0.09973910839939182, 0.12490110975646385, 0.15467494921778557, 0.07101120952452689, 0.0700791081658203, 0.17631271645818836, 0.24694915490924974, 0.18641231760040788, 0.20338862354116893, 0.19143500051370943, 0.18086942615481783, 0.21027659424532896, 0.23034686461877407, 0.2445669959550666, 0.5774743110795042, 0.6009010532467953, 0.5661660318447606, 0.48677744231648135, 0.48321097095443133, 0.3909856176500971, 0.5220081945294528, 0.5169226253472615, 0.547681719950079, 0.098357078495236, 0.09044756309358504, 0.09262408555249513, 0.08558900475471709, 0.09780348463321786, 0.08598745130217833, 0.08018687403005131, 0.1220946994819525, 0.09351516622878242, 0.15434818888554613, 0.1310410152485718, 0.12772492125872503, 0.13288378245589427, 0.16298627000710897, 0.14059327272472788, 0.13159245904383465, 0.14117231877510839, 0.14677192572340025, 0.2382819636479342, 0.27084012787706946, 0.2943620203018862, 0.2717416340737089, 0.29646497046672193, 0.2919793416343893, 0.24613714808956189, 0.32637137352732604, 0.2854673026837473, 0.21381780801405514, 0.19227208435855114, 0.22164394444283797, 0.23252321983180224, 0.2086756933959395, 0.23601140326381365, 0.21111905482702042, 0.25798022290372613, 0.1932534031286952, 0.17401159609736117, 0.1930749466879399, 0.1727393147600642, 0.1845003853992081, 0.19833847808323868, 0.1775907152884807, 0.19727016129343478, 0.18493557071064803, 0.1716421541812715, 0.18480382184022204, 0.17121045536690982, 0.16576915332428865, 0.16619888232550728, 0.1652908073871322, 0.16912954451757867, 0.16802089898458394, 0.17188055433372662, 0.1577457883424177, 0.2709593166919866, 0.17097988151784116, 0.14864226604299002, 0.3428769508249213, 0.36428634091649814, 0.17927364228159226, 0.16957906384453414, 0.16661002073399378, 0.30084217008411107, 0.35889631111069986, 0.44948201960542666, 0.21418957427891627, 0.1498060612173635, 0.2533694610958317, 0.1512701359346844, 0.2004636958720326, 0.2146323899417525, 0.23168762548764166, 0.18892554066718048, 0.1704150364995921, 0.17505681567115572, 0.16960080669429423, 0.16858191937696232, 0.16063425488431515, 0.17113672641015842, 0.1792751748575392, 0.16637680872418292, 0.06736978140131122, 0.07552499857695472, 0.08268958393551584, 0.07808660264686218, 0.07737034626800865, 0.07477407598272545, 0.06523869459001175, 0.07978198448673157, 0.0857464938691106]}, "mutation_prompt": null}
{"id": "19be4eac-4085-4d73-8b34-5fbf02a7ec98", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.15\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.elite_fraction = 0.1\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        diversity = np.std(parent1 - parent2)\n        if np.random.rand() < self.crossover_rate * (1 + diversity):  # Adaptive crossover\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        diversity = np.std(b - c)\n        mutant = np.clip(a + 0.8 * (b - c) * (1 + diversity), self.lower_bound, self.upper_bound)  # Adaptive mutation\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:num_elites]\n            new_population[:num_elites] = population[elite_indices]\n\n            for i in range(num_elites, self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Enhanced Hybrid Genetic Algorithm by introducing adaptive mutation and crossover rates based on fitness diversity for improved exploration-exploitation balance.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2155f422-22f4-41d2-aec7-ca715fdc2db2", "metadata": {"aucs": [0.6421743905090479, 0.6717020118401242, 0.5378176832901458, 0.4748249444252264, 0.535820233609771, 0.7199110933316066, 0.5793262170925216, 0.6320767113811596, 0.594806865215757, 0.22843392877353874, 0.14308594272362518, 0.2660027135993698, 0.2923230114212976, 0.24084894933462642, 0.27485368224391626, 0.19064246657484174, 0.2699166067866948, 0.22344012654908185, 0.10704799809772181, 0.08575664246574943, 0.09860707247319445, 0.09404260202570314, 0.09513914323503181, 0.08026086628811702, 0.11261871887455999, 0.08652117091733524, 0.10131717390431627, 0.08450778632665246, 0.06879288980873133, 0.07001256866388572, 0.07698021938456345, 0.07942952206383003, 0.06370614369029082, 0.0629218364671511, 0.07217133181637359, 0.08637823598456651, 0.4980212937045603, 0.869602677246745, 0.6351735094018282, 0.17161360991800845, 0.6339722778147999, 0.6890034622199067, 0.793188745933201, 0.7086552426671385, 0.6937678835948311, 0.2250520983423192, 0.19922569072070528, 0.22719922289978578, 0.20653700544755915, 0.21146552058651014, 0.20418357383428565, 0.19869759200216364, 0.14870555811112374, 0.2074976798324657, 0.6459259315882784, 0.648225433662905, 0.650079610661288, 0.6765020604544567, 0.6690609115336531, 0.467283108588712, 0.6017672823315339, 0.4651825278817945, 0.6038487844770358, 0.13448685854141096, 0.1341707259535524, 0.09930395536897918, 0.12869736554173505, 0.18602087860184047, 0.13672692216165083, 0.12493078110130573, 0.12767623168336306, 0.13479084595166113, 0.11115387332696025, 0.21212212026766797, 0.1254343161204894, 0.1587247961659921, 0.1512754026443155, 0.11727618362633618, 0.18685712696517043, 0.17493584502699921, 0.12816158021681767, 0.1291921996218912, 0.2670782279209497, 0.124076412940889, 0.13319371460251261, 0.12105165674860496, 0.14461996725038917, 0.19473993858016514, 0.14286838704691018, 0.13556208187632024, 0.24830113315066182, 0.16157492761655323, 0.2479909495683631, 0.18733012321077902, 0.2520032839408999, 0.17328172375007966, 0.21980454250068826, 0.19555089055145736, 0.18779456101624015, 0.10912932898462391, 0.13438412234635866, 0.06905017356854548, 0.12331529357222704, 0.09973910839939182, 0.12490110975646385, 0.15467494921778557, 0.07101120952452689, 0.0700791081658203, 0.17631271645818836, 0.24694915490924974, 0.18641231760040788, 0.20338862354116893, 0.19143500051370943, 0.18086942615481783, 0.21027659424532896, 0.23034686461877407, 0.2445669959550666, 0.5774743110795042, 0.6009010532467953, 0.5661660318447606, 0.48677744231648135, 0.48321097095443133, 0.3909856176500971, 0.5220081945294528, 0.5169226253472615, 0.547681719950079, 0.098357078495236, 0.09044756309358504, 0.09262408555249513, 0.08558900475471709, 0.09780348463321786, 0.08598745130217833, 0.08018687403005131, 0.1220946994819525, 0.09351516622878242, 0.15434818888554613, 0.1310410152485718, 0.12772492125872503, 0.13288378245589427, 0.16298627000710897, 0.14059327272472788, 0.13159245904383465, 0.14117231877510839, 0.14677192572340025, 0.2382819636479342, 0.27084012787706946, 0.2943620203018862, 0.2717416340737089, 0.29646497046672193, 0.2919793416343893, 0.24613714808956189, 0.32637137352732604, 0.2854673026837473, 0.21381780801405514, 0.19227208435855114, 0.22164394444283797, 0.23252321983180224, 0.2086756933959395, 0.23601140326381365, 0.21111905482702042, 0.25798022290372613, 0.1932534031286952, 0.17401159609736117, 0.1930749466879399, 0.1727393147600642, 0.1845003853992081, 0.19833847808323868, 0.1775907152884807, 0.19727016129343478, 0.18493557071064803, 0.1716421541812715, 0.18480382184022204, 0.17121045536690982, 0.16576915332428865, 0.16619888232550728, 0.1652908073871322, 0.16912954451757867, 0.16802089898458394, 0.17188055433372662, 0.1577457883424177, 0.2709593166919866, 0.17097988151784116, 0.14864226604299002, 0.3428769508249213, 0.36428634091649814, 0.17927364228159226, 0.16957906384453414, 0.16661002073399378, 0.30084217008411107, 0.35889631111069986, 0.44948201960542666, 0.21418957427891627, 0.1498060612173635, 0.2533694610958317, 0.1512701359346844, 0.2004636958720326, 0.2146323899417525, 0.23168762548764166, 0.18892554066718048, 0.1704150364995921, 0.17505681567115572, 0.16960080669429423, 0.16858191937696232, 0.16063425488431515, 0.17113672641015842, 0.1792751748575392, 0.16637680872418292, 0.06736978140131122, 0.07552499857695472, 0.08268958393551584, 0.07808660264686218, 0.07737034626800865, 0.07477407598272545, 0.06523869459001175, 0.07978198448673157, 0.0857464938691106]}, "mutation_prompt": null}
{"id": "6f510007-4b11-429f-b86d-0800fa3381f3", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.15\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.elite_fraction = 0.1\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        diversity = np.std(parent1 - parent2)\n        if np.random.rand() < self.crossover_rate * (1 + diversity):  # Adaptive crossover\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        diversity = np.std(b - c)\n        mutant = np.clip(a + 0.8 * (b - c) * (1 + diversity), self.lower_bound, self.upper_bound)  # Adaptive mutation\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:num_elites]\n            new_population[:num_elites] = population[elite_indices]\n\n            for i in range(num_elites, self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Enhanced Hybrid Genetic Algorithm by introducing adaptive mutation and crossover rates based on fitness diversity for improved exploration-exploitation balance.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2155f422-22f4-41d2-aec7-ca715fdc2db2", "metadata": {"aucs": [0.6421743905090479, 0.6717020118401242, 0.5378176832901458, 0.4748249444252264, 0.535820233609771, 0.7199110933316066, 0.5793262170925216, 0.6320767113811596, 0.594806865215757, 0.22843392877353874, 0.14308594272362518, 0.2660027135993698, 0.2923230114212976, 0.24084894933462642, 0.27485368224391626, 0.19064246657484174, 0.2699166067866948, 0.22344012654908185, 0.10704799809772181, 0.08575664246574943, 0.09860707247319445, 0.09404260202570314, 0.09513914323503181, 0.08026086628811702, 0.11261871887455999, 0.08652117091733524, 0.10131717390431627, 0.08450778632665246, 0.06879288980873133, 0.07001256866388572, 0.07698021938456345, 0.07942952206383003, 0.06370614369029082, 0.0629218364671511, 0.07217133181637359, 0.08637823598456651, 0.4980212937045603, 0.869602677246745, 0.6351735094018282, 0.17161360991800845, 0.6339722778147999, 0.6890034622199067, 0.793188745933201, 0.7086552426671385, 0.6937678835948311, 0.2250520983423192, 0.19922569072070528, 0.22719922289978578, 0.20653700544755915, 0.21146552058651014, 0.20418357383428565, 0.19869759200216364, 0.14870555811112374, 0.2074976798324657, 0.6459259315882784, 0.648225433662905, 0.650079610661288, 0.6765020604544567, 0.6690609115336531, 0.467283108588712, 0.6017672823315339, 0.4651825278817945, 0.6038487844770358, 0.13448685854141096, 0.1341707259535524, 0.09930395536897918, 0.12869736554173505, 0.18602087860184047, 0.13672692216165083, 0.12493078110130573, 0.12767623168336306, 0.13479084595166113, 0.11115387332696025, 0.21212212026766797, 0.1254343161204894, 0.1587247961659921, 0.1512754026443155, 0.11727618362633618, 0.18685712696517043, 0.17493584502699921, 0.12816158021681767, 0.1291921996218912, 0.2670782279209497, 0.124076412940889, 0.13319371460251261, 0.12105165674860496, 0.14461996725038917, 0.19473993858016514, 0.14286838704691018, 0.13556208187632024, 0.24830113315066182, 0.16157492761655323, 0.2479909495683631, 0.18733012321077902, 0.2520032839408999, 0.17328172375007966, 0.21980454250068826, 0.19555089055145736, 0.18779456101624015, 0.10912932898462391, 0.13438412234635866, 0.06905017356854548, 0.12331529357222704, 0.09973910839939182, 0.12490110975646385, 0.15467494921778557, 0.07101120952452689, 0.0700791081658203, 0.17631271645818836, 0.24694915490924974, 0.18641231760040788, 0.20338862354116893, 0.19143500051370943, 0.18086942615481783, 0.21027659424532896, 0.23034686461877407, 0.2445669959550666, 0.5774743110795042, 0.6009010532467953, 0.5661660318447606, 0.48677744231648135, 0.48321097095443133, 0.3909856176500971, 0.5220081945294528, 0.5169226253472615, 0.547681719950079, 0.098357078495236, 0.09044756309358504, 0.09262408555249513, 0.08558900475471709, 0.09780348463321786, 0.08598745130217833, 0.08018687403005131, 0.1220946994819525, 0.09351516622878242, 0.15434818888554613, 0.1310410152485718, 0.12772492125872503, 0.13288378245589427, 0.16298627000710897, 0.14059327272472788, 0.13159245904383465, 0.14117231877510839, 0.14677192572340025, 0.2382819636479342, 0.27084012787706946, 0.2943620203018862, 0.2717416340737089, 0.29646497046672193, 0.2919793416343893, 0.24613714808956189, 0.32637137352732604, 0.2854673026837473, 0.21381780801405514, 0.19227208435855114, 0.22164394444283797, 0.23252321983180224, 0.2086756933959395, 0.23601140326381365, 0.21111905482702042, 0.25798022290372613, 0.1932534031286952, 0.17401159609736117, 0.1930749466879399, 0.1727393147600642, 0.1845003853992081, 0.19833847808323868, 0.1775907152884807, 0.19727016129343478, 0.18493557071064803, 0.1716421541812715, 0.18480382184022204, 0.17121045536690982, 0.16576915332428865, 0.16619888232550728, 0.1652908073871322, 0.16912954451757867, 0.16802089898458394, 0.17188055433372662, 0.1577457883424177, 0.2709593166919866, 0.17097988151784116, 0.14864226604299002, 0.3428769508249213, 0.36428634091649814, 0.17927364228159226, 0.16957906384453414, 0.16661002073399378, 0.30084217008411107, 0.35889631111069986, 0.44948201960542666, 0.21418957427891627, 0.1498060612173635, 0.2533694610958317, 0.1512701359346844, 0.2004636958720326, 0.2146323899417525, 0.23168762548764166, 0.18892554066718048, 0.1704150364995921, 0.17505681567115572, 0.16960080669429423, 0.16858191937696232, 0.16063425488431515, 0.17113672641015842, 0.1792751748575392, 0.16637680872418292, 0.06736978140131122, 0.07552499857695472, 0.08268958393551584, 0.07808660264686218, 0.07737034626800865, 0.07477407598272545, 0.06523869459001175, 0.07978198448673157, 0.0857464938691106]}, "mutation_prompt": null}
{"id": "bac013ba-6707-40fc-ab65-7b096a9ecf73", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.15\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.elite_fraction = 0.1\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        diversity = np.std(parent1 - parent2)\n        if np.random.rand() < self.crossover_rate * (1 + diversity):  # Adaptive crossover\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        diversity = np.std(b - c)\n        mutant = np.clip(a + 0.8 * (b - c) * (1 + diversity), self.lower_bound, self.upper_bound)  # Adaptive mutation\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:num_elites]\n            new_population[:num_elites] = population[elite_indices]\n\n            for i in range(num_elites, self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Enhanced Hybrid Genetic Algorithm by introducing adaptive mutation and crossover rates based on fitness diversity for improved exploration-exploitation balance.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2155f422-22f4-41d2-aec7-ca715fdc2db2", "metadata": {"aucs": [0.6421743905090479, 0.6717020118401242, 0.5378176832901458, 0.4748249444252264, 0.535820233609771, 0.7199110933316066, 0.5793262170925216, 0.6320767113811596, 0.594806865215757, 0.22843392877353874, 0.14308594272362518, 0.2660027135993698, 0.2923230114212976, 0.24084894933462642, 0.27485368224391626, 0.19064246657484174, 0.2699166067866948, 0.22344012654908185, 0.10704799809772181, 0.08575664246574943, 0.09860707247319445, 0.09404260202570314, 0.09513914323503181, 0.08026086628811702, 0.11261871887455999, 0.08652117091733524, 0.10131717390431627, 0.08450778632665246, 0.06879288980873133, 0.07001256866388572, 0.07698021938456345, 0.07942952206383003, 0.06370614369029082, 0.0629218364671511, 0.07217133181637359, 0.08637823598456651, 0.4980212937045603, 0.869602677246745, 0.6351735094018282, 0.17161360991800845, 0.6339722778147999, 0.6890034622199067, 0.793188745933201, 0.7086552426671385, 0.6937678835948311, 0.2250520983423192, 0.19922569072070528, 0.22719922289978578, 0.20653700544755915, 0.21146552058651014, 0.20418357383428565, 0.19869759200216364, 0.14870555811112374, 0.2074976798324657, 0.6459259315882784, 0.648225433662905, 0.650079610661288, 0.6765020604544567, 0.6690609115336531, 0.467283108588712, 0.6017672823315339, 0.4651825278817945, 0.6038487844770358, 0.13448685854141096, 0.1341707259535524, 0.09930395536897918, 0.12869736554173505, 0.18602087860184047, 0.13672692216165083, 0.12493078110130573, 0.12767623168336306, 0.13479084595166113, 0.11115387332696025, 0.21212212026766797, 0.1254343161204894, 0.1587247961659921, 0.1512754026443155, 0.11727618362633618, 0.18685712696517043, 0.17493584502699921, 0.12816158021681767, 0.1291921996218912, 0.2670782279209497, 0.124076412940889, 0.13319371460251261, 0.12105165674860496, 0.14461996725038917, 0.19473993858016514, 0.14286838704691018, 0.13556208187632024, 0.24830113315066182, 0.16157492761655323, 0.2479909495683631, 0.18733012321077902, 0.2520032839408999, 0.17328172375007966, 0.21980454250068826, 0.19555089055145736, 0.18779456101624015, 0.10912932898462391, 0.13438412234635866, 0.06905017356854548, 0.12331529357222704, 0.09973910839939182, 0.12490110975646385, 0.15467494921778557, 0.07101120952452689, 0.0700791081658203, 0.17631271645818836, 0.24694915490924974, 0.18641231760040788, 0.20338862354116893, 0.19143500051370943, 0.18086942615481783, 0.21027659424532896, 0.23034686461877407, 0.2445669959550666, 0.5774743110795042, 0.6009010532467953, 0.5661660318447606, 0.48677744231648135, 0.48321097095443133, 0.3909856176500971, 0.5220081945294528, 0.5169226253472615, 0.547681719950079, 0.098357078495236, 0.09044756309358504, 0.09262408555249513, 0.08558900475471709, 0.09780348463321786, 0.08598745130217833, 0.08018687403005131, 0.1220946994819525, 0.09351516622878242, 0.15434818888554613, 0.1310410152485718, 0.12772492125872503, 0.13288378245589427, 0.16298627000710897, 0.14059327272472788, 0.13159245904383465, 0.14117231877510839, 0.14677192572340025, 0.2382819636479342, 0.27084012787706946, 0.2943620203018862, 0.2717416340737089, 0.29646497046672193, 0.2919793416343893, 0.24613714808956189, 0.32637137352732604, 0.2854673026837473, 0.21381780801405514, 0.19227208435855114, 0.22164394444283797, 0.23252321983180224, 0.2086756933959395, 0.23601140326381365, 0.21111905482702042, 0.25798022290372613, 0.1932534031286952, 0.17401159609736117, 0.1930749466879399, 0.1727393147600642, 0.1845003853992081, 0.19833847808323868, 0.1775907152884807, 0.19727016129343478, 0.18493557071064803, 0.1716421541812715, 0.18480382184022204, 0.17121045536690982, 0.16576915332428865, 0.16619888232550728, 0.1652908073871322, 0.16912954451757867, 0.16802089898458394, 0.17188055433372662, 0.1577457883424177, 0.2709593166919866, 0.17097988151784116, 0.14864226604299002, 0.3428769508249213, 0.36428634091649814, 0.17927364228159226, 0.16957906384453414, 0.16661002073399378, 0.30084217008411107, 0.35889631111069986, 0.44948201960542666, 0.21418957427891627, 0.1498060612173635, 0.2533694610958317, 0.1512701359346844, 0.2004636958720326, 0.2146323899417525, 0.23168762548764166, 0.18892554066718048, 0.1704150364995921, 0.17505681567115572, 0.16960080669429423, 0.16858191937696232, 0.16063425488431515, 0.17113672641015842, 0.1792751748575392, 0.16637680872418292, 0.06736978140131122, 0.07552499857695472, 0.08268958393551584, 0.07808660264686218, 0.07737034626800865, 0.07477407598272545, 0.06523869459001175, 0.07978198448673157, 0.0857464938691106]}, "mutation_prompt": null}
{"id": "e14df3d6-3c46-47ff-b4dd-a122015e1542", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_size = max(5 * dim, 20)\n        self.population_size = self.base_population_size\n        self.mutation_prob = 0.15\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.elite_fraction = 0.1\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        diversity = np.std(parent1 - parent2)\n        if np.random.rand() < self.crossover_rate * (1 + diversity):  # Adaptive crossover\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        diversity = np.std(b - c)\n        mutant = np.clip(a + 0.8 * (b - c) * (1 + diversity), self.lower_bound, self.upper_bound)  # Adaptive mutation\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:num_elites]\n            new_population[:num_elites] = population[elite_indices]\n\n            for i in range(num_elites, self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n            \n            # Dynamic population resizing based on progress\n            self.population_size = int(self.base_population_size * (1 + 0.5 * (eval_count / self.budget)))\n            population = np.resize(population, (self.population_size, self.dim))\n        \n        return best", "name": "HybridGADE", "description": "Enhanced Hybrid Genetic Algorithm with dynamic population resizing based on evaluation progress for improved convergence speed.", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 25 is out of bounds for axis 0 with size 25').", "error": "IndexError('index 25 is out of bounds for axis 0 with size 25')", "parent_id": "2155f422-22f4-41d2-aec7-ca715fdc2db2", "metadata": {}, "mutation_prompt": null}
{"id": "248388ba-9aa4-4e56-a949-60217bc0f78a", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.15\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.elite_fraction = 0.1\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        diversity = np.std(parent1 - parent2)\n        if np.random.rand() < self.crossover_rate * (1 + diversity):  # Adaptive crossover\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        diversity = np.std(b - c)\n        mutant = np.clip(a + 0.8 * (b - c) * (1 + diversity), self.lower_bound, self.upper_bound)  # Adaptive mutation\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:num_elites]\n            new_population[:num_elites] = population[elite_indices]\n\n            for i in range(num_elites, self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Enhanced Hybrid Genetic Algorithm by introducing adaptive mutation and crossover rates based on fitness diversity for improved exploration-exploitation balance.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2155f422-22f4-41d2-aec7-ca715fdc2db2", "metadata": {"aucs": [0.6421743905090479, 0.6717020118401242, 0.5378176832901458, 0.4748249444252264, 0.535820233609771, 0.7199110933316066, 0.5793262170925216, 0.6320767113811596, 0.594806865215757, 0.22843392877353874, 0.14308594272362518, 0.2660027135993698, 0.2923230114212976, 0.24084894933462642, 0.27485368224391626, 0.19064246657484174, 0.2699166067866948, 0.22344012654908185, 0.10704799809772181, 0.08575664246574943, 0.09860707247319445, 0.09404260202570314, 0.09513914323503181, 0.08026086628811702, 0.11261871887455999, 0.08652117091733524, 0.10131717390431627, 0.08450778632665246, 0.06879288980873133, 0.07001256866388572, 0.07698021938456345, 0.07942952206383003, 0.06370614369029082, 0.0629218364671511, 0.07217133181637359, 0.08637823598456651, 0.4980212937045603, 0.869602677246745, 0.6351735094018282, 0.17161360991800845, 0.6339722778147999, 0.6890034622199067, 0.793188745933201, 0.7086552426671385, 0.6937678835948311, 0.2250520983423192, 0.19922569072070528, 0.22719922289978578, 0.20653700544755915, 0.21146552058651014, 0.20418357383428565, 0.19869759200216364, 0.14870555811112374, 0.2074976798324657, 0.6459259315882784, 0.648225433662905, 0.650079610661288, 0.6765020604544567, 0.6690609115336531, 0.467283108588712, 0.6017672823315339, 0.4651825278817945, 0.6038487844770358, 0.13448685854141096, 0.1341707259535524, 0.09930395536897918, 0.12869736554173505, 0.18602087860184047, 0.13672692216165083, 0.12493078110130573, 0.12767623168336306, 0.13479084595166113, 0.11115387332696025, 0.21212212026766797, 0.1254343161204894, 0.1587247961659921, 0.1512754026443155, 0.11727618362633618, 0.18685712696517043, 0.17493584502699921, 0.12816158021681767, 0.1291921996218912, 0.2670782279209497, 0.124076412940889, 0.13319371460251261, 0.12105165674860496, 0.14461996725038917, 0.19473993858016514, 0.14286838704691018, 0.13556208187632024, 0.24830113315066182, 0.16157492761655323, 0.2479909495683631, 0.18733012321077902, 0.2520032839408999, 0.17328172375007966, 0.21980454250068826, 0.19555089055145736, 0.18779456101624015, 0.10912932898462391, 0.13438412234635866, 0.06905017356854548, 0.12331529357222704, 0.09973910839939182, 0.12490110975646385, 0.15467494921778557, 0.07101120952452689, 0.0700791081658203, 0.17631271645818836, 0.24694915490924974, 0.18641231760040788, 0.20338862354116893, 0.19143500051370943, 0.18086942615481783, 0.21027659424532896, 0.23034686461877407, 0.2445669959550666, 0.5774743110795042, 0.6009010532467953, 0.5661660318447606, 0.48677744231648135, 0.48321097095443133, 0.3909856176500971, 0.5220081945294528, 0.5169226253472615, 0.547681719950079, 0.098357078495236, 0.09044756309358504, 0.09262408555249513, 0.08558900475471709, 0.09780348463321786, 0.08598745130217833, 0.08018687403005131, 0.1220946994819525, 0.09351516622878242, 0.15434818888554613, 0.1310410152485718, 0.12772492125872503, 0.13288378245589427, 0.16298627000710897, 0.14059327272472788, 0.13159245904383465, 0.14117231877510839, 0.14677192572340025, 0.2382819636479342, 0.27084012787706946, 0.2943620203018862, 0.2717416340737089, 0.29646497046672193, 0.2919793416343893, 0.24613714808956189, 0.32637137352732604, 0.2854673026837473, 0.21381780801405514, 0.19227208435855114, 0.22164394444283797, 0.23252321983180224, 0.2086756933959395, 0.23601140326381365, 0.21111905482702042, 0.25798022290372613, 0.1932534031286952, 0.17401159609736117, 0.1930749466879399, 0.1727393147600642, 0.1845003853992081, 0.19833847808323868, 0.1775907152884807, 0.19727016129343478, 0.18493557071064803, 0.1716421541812715, 0.18480382184022204, 0.17121045536690982, 0.16576915332428865, 0.16619888232550728, 0.1652908073871322, 0.16912954451757867, 0.16802089898458394, 0.17188055433372662, 0.1577457883424177, 0.2709593166919866, 0.17097988151784116, 0.14864226604299002, 0.3428769508249213, 0.36428634091649814, 0.17927364228159226, 0.16957906384453414, 0.16661002073399378, 0.30084217008411107, 0.35889631111069986, 0.44948201960542666, 0.21418957427891627, 0.1498060612173635, 0.2533694610958317, 0.1512701359346844, 0.2004636958720326, 0.2146323899417525, 0.23168762548764166, 0.18892554066718048, 0.1704150364995921, 0.17505681567115572, 0.16960080669429423, 0.16858191937696232, 0.16063425488431515, 0.17113672641015842, 0.1792751748575392, 0.16637680872418292, 0.06736978140131122, 0.07552499857695472, 0.08268958393551584, 0.07808660264686218, 0.07737034626800865, 0.07477407598272545, 0.06523869459001175, 0.07978198448673157, 0.0857464938691106]}, "mutation_prompt": null}
{"id": "cfb05091-8f04-4c57-8f2d-f559cb95999d", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.15\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.elite_fraction = 0.1\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        diversity = np.std(parent1 - parent2)\n        if np.random.rand() < self.crossover_rate * (1 + diversity):  # Adaptive crossover\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        diversity = np.std(b - c)\n        mutant = np.clip(a + 0.8 * (b - c) * (1 + diversity), self.lower_bound, self.upper_bound)  # Adaptive mutation\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:num_elites]\n            new_population[:num_elites] = population[elite_indices]\n\n            for i in range(num_elites, self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Enhanced Hybrid Genetic Algorithm by introducing adaptive mutation and crossover rates based on fitness diversity for improved exploration-exploitation balance.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2155f422-22f4-41d2-aec7-ca715fdc2db2", "metadata": {"aucs": [0.6421743905090479, 0.6717020118401242, 0.5378176832901458, 0.4748249444252264, 0.535820233609771, 0.7199110933316066, 0.5793262170925216, 0.6320767113811596, 0.594806865215757, 0.22843392877353874, 0.14308594272362518, 0.2660027135993698, 0.2923230114212976, 0.24084894933462642, 0.27485368224391626, 0.19064246657484174, 0.2699166067866948, 0.22344012654908185, 0.10704799809772181, 0.08575664246574943, 0.09860707247319445, 0.09404260202570314, 0.09513914323503181, 0.08026086628811702, 0.11261871887455999, 0.08652117091733524, 0.10131717390431627, 0.08450778632665246, 0.06879288980873133, 0.07001256866388572, 0.07698021938456345, 0.07942952206383003, 0.06370614369029082, 0.0629218364671511, 0.07217133181637359, 0.08637823598456651, 0.4980212937045603, 0.869602677246745, 0.6351735094018282, 0.17161360991800845, 0.6339722778147999, 0.6890034622199067, 0.793188745933201, 0.7086552426671385, 0.6937678835948311, 0.2250520983423192, 0.19922569072070528, 0.22719922289978578, 0.20653700544755915, 0.21146552058651014, 0.20418357383428565, 0.19869759200216364, 0.14870555811112374, 0.2074976798324657, 0.6459259315882784, 0.648225433662905, 0.650079610661288, 0.6765020604544567, 0.6690609115336531, 0.467283108588712, 0.6017672823315339, 0.4651825278817945, 0.6038487844770358, 0.13448685854141096, 0.1341707259535524, 0.09930395536897918, 0.12869736554173505, 0.18602087860184047, 0.13672692216165083, 0.12493078110130573, 0.12767623168336306, 0.13479084595166113, 0.11115387332696025, 0.21212212026766797, 0.1254343161204894, 0.1587247961659921, 0.1512754026443155, 0.11727618362633618, 0.18685712696517043, 0.17493584502699921, 0.12816158021681767, 0.1291921996218912, 0.2670782279209497, 0.124076412940889, 0.13319371460251261, 0.12105165674860496, 0.14461996725038917, 0.19473993858016514, 0.14286838704691018, 0.13556208187632024, 0.24830113315066182, 0.16157492761655323, 0.2479909495683631, 0.18733012321077902, 0.2520032839408999, 0.17328172375007966, 0.21980454250068826, 0.19555089055145736, 0.18779456101624015, 0.10912932898462391, 0.13438412234635866, 0.06905017356854548, 0.12331529357222704, 0.09973910839939182, 0.12490110975646385, 0.15467494921778557, 0.07101120952452689, 0.0700791081658203, 0.17631271645818836, 0.24694915490924974, 0.18641231760040788, 0.20338862354116893, 0.19143500051370943, 0.18086942615481783, 0.21027659424532896, 0.23034686461877407, 0.2445669959550666, 0.5774743110795042, 0.6009010532467953, 0.5661660318447606, 0.48677744231648135, 0.48321097095443133, 0.3909856176500971, 0.5220081945294528, 0.5169226253472615, 0.547681719950079, 0.098357078495236, 0.09044756309358504, 0.09262408555249513, 0.08558900475471709, 0.09780348463321786, 0.08598745130217833, 0.08018687403005131, 0.1220946994819525, 0.09351516622878242, 0.15434818888554613, 0.1310410152485718, 0.12772492125872503, 0.13288378245589427, 0.16298627000710897, 0.14059327272472788, 0.13159245904383465, 0.14117231877510839, 0.14677192572340025, 0.2382819636479342, 0.27084012787706946, 0.2943620203018862, 0.2717416340737089, 0.29646497046672193, 0.2919793416343893, 0.24613714808956189, 0.32637137352732604, 0.2854673026837473, 0.21381780801405514, 0.19227208435855114, 0.22164394444283797, 0.23252321983180224, 0.2086756933959395, 0.23601140326381365, 0.21111905482702042, 0.25798022290372613, 0.1932534031286952, 0.17401159609736117, 0.1930749466879399, 0.1727393147600642, 0.1845003853992081, 0.19833847808323868, 0.1775907152884807, 0.19727016129343478, 0.18493557071064803, 0.1716421541812715, 0.18480382184022204, 0.17121045536690982, 0.16576915332428865, 0.16619888232550728, 0.1652908073871322, 0.16912954451757867, 0.16802089898458394, 0.17188055433372662, 0.1577457883424177, 0.2709593166919866, 0.17097988151784116, 0.14864226604299002, 0.3428769508249213, 0.36428634091649814, 0.17927364228159226, 0.16957906384453414, 0.16661002073399378, 0.30084217008411107, 0.35889631111069986, 0.44948201960542666, 0.21418957427891627, 0.1498060612173635, 0.2533694610958317, 0.1512701359346844, 0.2004636958720326, 0.2146323899417525, 0.23168762548764166, 0.18892554066718048, 0.1704150364995921, 0.17505681567115572, 0.16960080669429423, 0.16858191937696232, 0.16063425488431515, 0.17113672641015842, 0.1792751748575392, 0.16637680872418292, 0.06736978140131122, 0.07552499857695472, 0.08268958393551584, 0.07808660264686218, 0.07737034626800865, 0.07477407598272545, 0.06523869459001175, 0.07978198448673157, 0.0857464938691106]}, "mutation_prompt": null}
{"id": "5d22f6a5-6ca2-45d6-ba5e-55c2de711944", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.15\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.elite_fraction = 0.1\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        diversity = np.std(parent1 - parent2)\n        if np.random.rand() < self.crossover_rate * (1 + diversity):  # Adaptive crossover\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        diversity = np.std(b - c)\n        mutant = np.clip(a + 0.8 * (b - c) * (1 + diversity), self.lower_bound, self.upper_bound)  # Adaptive mutation\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:num_elites]\n            new_population[:num_elites] = population[elite_indices]\n\n            for i in range(num_elites, self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Enhanced Hybrid Genetic Algorithm by introducing adaptive mutation and crossover rates based on fitness diversity for improved exploration-exploitation balance.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2155f422-22f4-41d2-aec7-ca715fdc2db2", "metadata": {"aucs": [0.6421743905090479, 0.6717020118401242, 0.5378176832901458, 0.4748249444252264, 0.535820233609771, 0.7199110933316066, 0.5793262170925216, 0.6320767113811596, 0.594806865215757, 0.22843392877353874, 0.14308594272362518, 0.2660027135993698, 0.2923230114212976, 0.24084894933462642, 0.27485368224391626, 0.19064246657484174, 0.2699166067866948, 0.22344012654908185, 0.10704799809772181, 0.08575664246574943, 0.09860707247319445, 0.09404260202570314, 0.09513914323503181, 0.08026086628811702, 0.11261871887455999, 0.08652117091733524, 0.10131717390431627, 0.08450778632665246, 0.06879288980873133, 0.07001256866388572, 0.07698021938456345, 0.07942952206383003, 0.06370614369029082, 0.0629218364671511, 0.07217133181637359, 0.08637823598456651, 0.4980212937045603, 0.869602677246745, 0.6351735094018282, 0.17161360991800845, 0.6339722778147999, 0.6890034622199067, 0.793188745933201, 0.7086552426671385, 0.6937678835948311, 0.2250520983423192, 0.19922569072070528, 0.22719922289978578, 0.20653700544755915, 0.21146552058651014, 0.20418357383428565, 0.19869759200216364, 0.14870555811112374, 0.2074976798324657, 0.6459259315882784, 0.648225433662905, 0.650079610661288, 0.6765020604544567, 0.6690609115336531, 0.467283108588712, 0.6017672823315339, 0.4651825278817945, 0.6038487844770358, 0.13448685854141096, 0.1341707259535524, 0.09930395536897918, 0.12869736554173505, 0.18602087860184047, 0.13672692216165083, 0.12493078110130573, 0.12767623168336306, 0.13479084595166113, 0.11115387332696025, 0.21212212026766797, 0.1254343161204894, 0.1587247961659921, 0.1512754026443155, 0.11727618362633618, 0.18685712696517043, 0.17493584502699921, 0.12816158021681767, 0.1291921996218912, 0.2670782279209497, 0.124076412940889, 0.13319371460251261, 0.12105165674860496, 0.14461996725038917, 0.19473993858016514, 0.14286838704691018, 0.13556208187632024, 0.24830113315066182, 0.16157492761655323, 0.2479909495683631, 0.18733012321077902, 0.2520032839408999, 0.17328172375007966, 0.21980454250068826, 0.19555089055145736, 0.18779456101624015, 0.10912932898462391, 0.13438412234635866, 0.06905017356854548, 0.12331529357222704, 0.09973910839939182, 0.12490110975646385, 0.15467494921778557, 0.07101120952452689, 0.0700791081658203, 0.17631271645818836, 0.24694915490924974, 0.18641231760040788, 0.20338862354116893, 0.19143500051370943, 0.18086942615481783, 0.21027659424532896, 0.23034686461877407, 0.2445669959550666, 0.5774743110795042, 0.6009010532467953, 0.5661660318447606, 0.48677744231648135, 0.48321097095443133, 0.3909856176500971, 0.5220081945294528, 0.5169226253472615, 0.547681719950079, 0.098357078495236, 0.09044756309358504, 0.09262408555249513, 0.08558900475471709, 0.09780348463321786, 0.08598745130217833, 0.08018687403005131, 0.1220946994819525, 0.09351516622878242, 0.15434818888554613, 0.1310410152485718, 0.12772492125872503, 0.13288378245589427, 0.16298627000710897, 0.14059327272472788, 0.13159245904383465, 0.14117231877510839, 0.14677192572340025, 0.2382819636479342, 0.27084012787706946, 0.2943620203018862, 0.2717416340737089, 0.29646497046672193, 0.2919793416343893, 0.24613714808956189, 0.32637137352732604, 0.2854673026837473, 0.21381780801405514, 0.19227208435855114, 0.22164394444283797, 0.23252321983180224, 0.2086756933959395, 0.23601140326381365, 0.21111905482702042, 0.25798022290372613, 0.1932534031286952, 0.17401159609736117, 0.1930749466879399, 0.1727393147600642, 0.1845003853992081, 0.19833847808323868, 0.1775907152884807, 0.19727016129343478, 0.18493557071064803, 0.1716421541812715, 0.18480382184022204, 0.17121045536690982, 0.16576915332428865, 0.16619888232550728, 0.1652908073871322, 0.16912954451757867, 0.16802089898458394, 0.17188055433372662, 0.1577457883424177, 0.2709593166919866, 0.17097988151784116, 0.14864226604299002, 0.3428769508249213, 0.36428634091649814, 0.17927364228159226, 0.16957906384453414, 0.16661002073399378, 0.30084217008411107, 0.35889631111069986, 0.44948201960542666, 0.21418957427891627, 0.1498060612173635, 0.2533694610958317, 0.1512701359346844, 0.2004636958720326, 0.2146323899417525, 0.23168762548764166, 0.18892554066718048, 0.1704150364995921, 0.17505681567115572, 0.16960080669429423, 0.16858191937696232, 0.16063425488431515, 0.17113672641015842, 0.1792751748575392, 0.16637680872418292, 0.06736978140131122, 0.07552499857695472, 0.08268958393551584, 0.07808660264686218, 0.07737034626800865, 0.07477407598272545, 0.06523869459001175, 0.07978198448673157, 0.0857464938691106]}, "mutation_prompt": null}
{"id": "831e983e-7e0a-4007-aa96-10702656c795", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.15\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.elite_fraction = 0.1\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        diversity = np.std(parent1 - parent2)\n        if np.random.rand() < self.crossover_rate * (1 + diversity):  # Adaptive crossover\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        diversity = np.std(b - c)\n        mutant = np.clip(a + 0.8 * (b - c) * (1 + diversity), self.lower_bound, self.upper_bound)  # Adaptive mutation\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:num_elites]\n            new_population[:num_elites] = population[elite_indices]\n\n            for i in range(num_elites, self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Enhanced Hybrid Genetic Algorithm by introducing adaptive mutation and crossover rates based on fitness diversity for improved exploration-exploitation balance.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2155f422-22f4-41d2-aec7-ca715fdc2db2", "metadata": {"aucs": [0.6421743905090479, 0.6717020118401242, 0.5378176832901458, 0.4748249444252264, 0.535820233609771, 0.7199110933316066, 0.5793262170925216, 0.6320767113811596, 0.594806865215757, 0.22843392877353874, 0.14308594272362518, 0.2660027135993698, 0.2923230114212976, 0.24084894933462642, 0.27485368224391626, 0.19064246657484174, 0.2699166067866948, 0.22344012654908185, 0.10704799809772181, 0.08575664246574943, 0.09860707247319445, 0.09404260202570314, 0.09513914323503181, 0.08026086628811702, 0.11261871887455999, 0.08652117091733524, 0.10131717390431627, 0.08450778632665246, 0.06879288980873133, 0.07001256866388572, 0.07698021938456345, 0.07942952206383003, 0.06370614369029082, 0.0629218364671511, 0.07217133181637359, 0.08637823598456651, 0.4980212937045603, 0.869602677246745, 0.6351735094018282, 0.17161360991800845, 0.6339722778147999, 0.6890034622199067, 0.793188745933201, 0.7086552426671385, 0.6937678835948311, 0.2250520983423192, 0.19922569072070528, 0.22719922289978578, 0.20653700544755915, 0.21146552058651014, 0.20418357383428565, 0.19869759200216364, 0.14870555811112374, 0.2074976798324657, 0.6459259315882784, 0.648225433662905, 0.650079610661288, 0.6765020604544567, 0.6690609115336531, 0.467283108588712, 0.6017672823315339, 0.4651825278817945, 0.6038487844770358, 0.13448685854141096, 0.1341707259535524, 0.09930395536897918, 0.12869736554173505, 0.18602087860184047, 0.13672692216165083, 0.12493078110130573, 0.12767623168336306, 0.13479084595166113, 0.11115387332696025, 0.21212212026766797, 0.1254343161204894, 0.1587247961659921, 0.1512754026443155, 0.11727618362633618, 0.18685712696517043, 0.17493584502699921, 0.12816158021681767, 0.1291921996218912, 0.2670782279209497, 0.124076412940889, 0.13319371460251261, 0.12105165674860496, 0.14461996725038917, 0.19473993858016514, 0.14286838704691018, 0.13556208187632024, 0.24830113315066182, 0.16157492761655323, 0.2479909495683631, 0.18733012321077902, 0.2520032839408999, 0.17328172375007966, 0.21980454250068826, 0.19555089055145736, 0.18779456101624015, 0.10912932898462391, 0.13438412234635866, 0.06905017356854548, 0.12331529357222704, 0.09973910839939182, 0.12490110975646385, 0.15467494921778557, 0.07101120952452689, 0.0700791081658203, 0.17631271645818836, 0.24694915490924974, 0.18641231760040788, 0.20338862354116893, 0.19143500051370943, 0.18086942615481783, 0.21027659424532896, 0.23034686461877407, 0.2445669959550666, 0.5774743110795042, 0.6009010532467953, 0.5661660318447606, 0.48677744231648135, 0.48321097095443133, 0.3909856176500971, 0.5220081945294528, 0.5169226253472615, 0.547681719950079, 0.098357078495236, 0.09044756309358504, 0.09262408555249513, 0.08558900475471709, 0.09780348463321786, 0.08598745130217833, 0.08018687403005131, 0.1220946994819525, 0.09351516622878242, 0.15434818888554613, 0.1310410152485718, 0.12772492125872503, 0.13288378245589427, 0.16298627000710897, 0.14059327272472788, 0.13159245904383465, 0.14117231877510839, 0.14677192572340025, 0.2382819636479342, 0.27084012787706946, 0.2943620203018862, 0.2717416340737089, 0.29646497046672193, 0.2919793416343893, 0.24613714808956189, 0.32637137352732604, 0.2854673026837473, 0.21381780801405514, 0.19227208435855114, 0.22164394444283797, 0.23252321983180224, 0.2086756933959395, 0.23601140326381365, 0.21111905482702042, 0.25798022290372613, 0.1932534031286952, 0.17401159609736117, 0.1930749466879399, 0.1727393147600642, 0.1845003853992081, 0.19833847808323868, 0.1775907152884807, 0.19727016129343478, 0.18493557071064803, 0.1716421541812715, 0.18480382184022204, 0.17121045536690982, 0.16576915332428865, 0.16619888232550728, 0.1652908073871322, 0.16912954451757867, 0.16802089898458394, 0.17188055433372662, 0.1577457883424177, 0.2709593166919866, 0.17097988151784116, 0.14864226604299002, 0.3428769508249213, 0.36428634091649814, 0.17927364228159226, 0.16957906384453414, 0.16661002073399378, 0.30084217008411107, 0.35889631111069986, 0.44948201960542666, 0.21418957427891627, 0.1498060612173635, 0.2533694610958317, 0.1512701359346844, 0.2004636958720326, 0.2146323899417525, 0.23168762548764166, 0.18892554066718048, 0.1704150364995921, 0.17505681567115572, 0.16960080669429423, 0.16858191937696232, 0.16063425488431515, 0.17113672641015842, 0.1792751748575392, 0.16637680872418292, 0.06736978140131122, 0.07552499857695472, 0.08268958393551584, 0.07808660264686218, 0.07737034626800865, 0.07477407598272545, 0.06523869459001175, 0.07978198448673157, 0.0857464938691106]}, "mutation_prompt": null}
{"id": "ff3c8e11-79d5-4e77-8d46-f77dbc9d980c", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.15\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.elite_fraction = 0.1\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        diversity = np.std(parent1 - parent2)\n        if np.random.rand() < self.crossover_rate * (1 + diversity):  # Adaptive crossover\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        diversity = np.std(b - c)\n        mutant = np.clip(a + 0.8 * (b - c) * (1 + diversity), self.lower_bound, self.upper_bound)  # Adaptive mutation\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:num_elites]\n            new_population[:num_elites] = population[elite_indices]\n\n            for i in range(num_elites, self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Enhanced Hybrid Genetic Algorithm by introducing adaptive mutation and crossover rates based on fitness diversity for improved exploration-exploitation balance.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2155f422-22f4-41d2-aec7-ca715fdc2db2", "metadata": {"aucs": [0.6421743905090479, 0.6717020118401242, 0.5378176832901458, 0.4748249444252264, 0.535820233609771, 0.7199110933316066, 0.5793262170925216, 0.6320767113811596, 0.594806865215757, 0.22843392877353874, 0.14308594272362518, 0.2660027135993698, 0.2923230114212976, 0.24084894933462642, 0.27485368224391626, 0.19064246657484174, 0.2699166067866948, 0.22344012654908185, 0.10704799809772181, 0.08575664246574943, 0.09860707247319445, 0.09404260202570314, 0.09513914323503181, 0.08026086628811702, 0.11261871887455999, 0.08652117091733524, 0.10131717390431627, 0.08450778632665246, 0.06879288980873133, 0.07001256866388572, 0.07698021938456345, 0.07942952206383003, 0.06370614369029082, 0.0629218364671511, 0.07217133181637359, 0.08637823598456651, 0.4980212937045603, 0.869602677246745, 0.6351735094018282, 0.17161360991800845, 0.6339722778147999, 0.6890034622199067, 0.793188745933201, 0.7086552426671385, 0.6937678835948311, 0.2250520983423192, 0.19922569072070528, 0.22719922289978578, 0.20653700544755915, 0.21146552058651014, 0.20418357383428565, 0.19869759200216364, 0.14870555811112374, 0.2074976798324657, 0.6459259315882784, 0.648225433662905, 0.650079610661288, 0.6765020604544567, 0.6690609115336531, 0.467283108588712, 0.6017672823315339, 0.4651825278817945, 0.6038487844770358, 0.13448685854141096, 0.1341707259535524, 0.09930395536897918, 0.12869736554173505, 0.18602087860184047, 0.13672692216165083, 0.12493078110130573, 0.12767623168336306, 0.13479084595166113, 0.11115387332696025, 0.21212212026766797, 0.1254343161204894, 0.1587247961659921, 0.1512754026443155, 0.11727618362633618, 0.18685712696517043, 0.17493584502699921, 0.12816158021681767, 0.1291921996218912, 0.2670782279209497, 0.124076412940889, 0.13319371460251261, 0.12105165674860496, 0.14461996725038917, 0.19473993858016514, 0.14286838704691018, 0.13556208187632024, 0.24830113315066182, 0.16157492761655323, 0.2479909495683631, 0.18733012321077902, 0.2520032839408999, 0.17328172375007966, 0.21980454250068826, 0.19555089055145736, 0.18779456101624015, 0.10912932898462391, 0.13438412234635866, 0.06905017356854548, 0.12331529357222704, 0.09973910839939182, 0.12490110975646385, 0.15467494921778557, 0.07101120952452689, 0.0700791081658203, 0.17631271645818836, 0.24694915490924974, 0.18641231760040788, 0.20338862354116893, 0.19143500051370943, 0.18086942615481783, 0.21027659424532896, 0.23034686461877407, 0.2445669959550666, 0.5774743110795042, 0.6009010532467953, 0.5661660318447606, 0.48677744231648135, 0.48321097095443133, 0.3909856176500971, 0.5220081945294528, 0.5169226253472615, 0.547681719950079, 0.098357078495236, 0.09044756309358504, 0.09262408555249513, 0.08558900475471709, 0.09780348463321786, 0.08598745130217833, 0.08018687403005131, 0.1220946994819525, 0.09351516622878242, 0.15434818888554613, 0.1310410152485718, 0.12772492125872503, 0.13288378245589427, 0.16298627000710897, 0.14059327272472788, 0.13159245904383465, 0.14117231877510839, 0.14677192572340025, 0.2382819636479342, 0.27084012787706946, 0.2943620203018862, 0.2717416340737089, 0.29646497046672193, 0.2919793416343893, 0.24613714808956189, 0.32637137352732604, 0.2854673026837473, 0.21381780801405514, 0.19227208435855114, 0.22164394444283797, 0.23252321983180224, 0.2086756933959395, 0.23601140326381365, 0.21111905482702042, 0.25798022290372613, 0.1932534031286952, 0.17401159609736117, 0.1930749466879399, 0.1727393147600642, 0.1845003853992081, 0.19833847808323868, 0.1775907152884807, 0.19727016129343478, 0.18493557071064803, 0.1716421541812715, 0.18480382184022204, 0.17121045536690982, 0.16576915332428865, 0.16619888232550728, 0.1652908073871322, 0.16912954451757867, 0.16802089898458394, 0.17188055433372662, 0.1577457883424177, 0.2709593166919866, 0.17097988151784116, 0.14864226604299002, 0.3428769508249213, 0.36428634091649814, 0.17927364228159226, 0.16957906384453414, 0.16661002073399378, 0.30084217008411107, 0.35889631111069986, 0.44948201960542666, 0.21418957427891627, 0.1498060612173635, 0.2533694610958317, 0.1512701359346844, 0.2004636958720326, 0.2146323899417525, 0.23168762548764166, 0.18892554066718048, 0.1704150364995921, 0.17505681567115572, 0.16960080669429423, 0.16858191937696232, 0.16063425488431515, 0.17113672641015842, 0.1792751748575392, 0.16637680872418292, 0.06736978140131122, 0.07552499857695472, 0.08268958393551584, 0.07808660264686218, 0.07737034626800865, 0.07477407598272545, 0.06523869459001175, 0.07978198448673157, 0.0857464938691106]}, "mutation_prompt": null}
{"id": "7398e557-c3e8-4f4b-a608-b41e8eab2e3f", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.15\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.elite_fraction = 0.1\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        diversity = np.std(parent1 - parent2)\n        if np.random.rand() < self.crossover_rate * (1 + diversity):  # Adaptive crossover\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        diversity = np.std(b - c)\n        mutant = np.clip(a + 0.8 * (b - c) * (1 + diversity), self.lower_bound, self.upper_bound)  # Adaptive mutation\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:num_elites]\n            new_population[:num_elites] = population[elite_indices]\n\n            for i in range(num_elites, self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Enhanced Hybrid Genetic Algorithm by introducing adaptive mutation and crossover rates based on fitness diversity for improved exploration-exploitation balance.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2155f422-22f4-41d2-aec7-ca715fdc2db2", "metadata": {"aucs": [0.6421743905090479, 0.6717020118401242, 0.5378176832901458, 0.4748249444252264, 0.535820233609771, 0.7199110933316066, 0.5793262170925216, 0.6320767113811596, 0.594806865215757, 0.22843392877353874, 0.14308594272362518, 0.2660027135993698, 0.2923230114212976, 0.24084894933462642, 0.27485368224391626, 0.19064246657484174, 0.2699166067866948, 0.22344012654908185, 0.10704799809772181, 0.08575664246574943, 0.09860707247319445, 0.09404260202570314, 0.09513914323503181, 0.08026086628811702, 0.11261871887455999, 0.08652117091733524, 0.10131717390431627, 0.08450778632665246, 0.06879288980873133, 0.07001256866388572, 0.07698021938456345, 0.07942952206383003, 0.06370614369029082, 0.0629218364671511, 0.07217133181637359, 0.08637823598456651, 0.4980212937045603, 0.869602677246745, 0.6351735094018282, 0.17161360991800845, 0.6339722778147999, 0.6890034622199067, 0.793188745933201, 0.7086552426671385, 0.6937678835948311, 0.2250520983423192, 0.19922569072070528, 0.22719922289978578, 0.20653700544755915, 0.21146552058651014, 0.20418357383428565, 0.19869759200216364, 0.14870555811112374, 0.2074976798324657, 0.6459259315882784, 0.648225433662905, 0.650079610661288, 0.6765020604544567, 0.6690609115336531, 0.467283108588712, 0.6017672823315339, 0.4651825278817945, 0.6038487844770358, 0.13448685854141096, 0.1341707259535524, 0.09930395536897918, 0.12869736554173505, 0.18602087860184047, 0.13672692216165083, 0.12493078110130573, 0.12767623168336306, 0.13479084595166113, 0.11115387332696025, 0.21212212026766797, 0.1254343161204894, 0.1587247961659921, 0.1512754026443155, 0.11727618362633618, 0.18685712696517043, 0.17493584502699921, 0.12816158021681767, 0.1291921996218912, 0.2670782279209497, 0.124076412940889, 0.13319371460251261, 0.12105165674860496, 0.14461996725038917, 0.19473993858016514, 0.14286838704691018, 0.13556208187632024, 0.24830113315066182, 0.16157492761655323, 0.2479909495683631, 0.18733012321077902, 0.2520032839408999, 0.17328172375007966, 0.21980454250068826, 0.19555089055145736, 0.18779456101624015, 0.10912932898462391, 0.13438412234635866, 0.06905017356854548, 0.12331529357222704, 0.09973910839939182, 0.12490110975646385, 0.15467494921778557, 0.07101120952452689, 0.0700791081658203, 0.17631271645818836, 0.24694915490924974, 0.18641231760040788, 0.20338862354116893, 0.19143500051370943, 0.18086942615481783, 0.21027659424532896, 0.23034686461877407, 0.2445669959550666, 0.5774743110795042, 0.6009010532467953, 0.5661660318447606, 0.48677744231648135, 0.48321097095443133, 0.3909856176500971, 0.5220081945294528, 0.5169226253472615, 0.547681719950079, 0.098357078495236, 0.09044756309358504, 0.09262408555249513, 0.08558900475471709, 0.09780348463321786, 0.08598745130217833, 0.08018687403005131, 0.1220946994819525, 0.09351516622878242, 0.15434818888554613, 0.1310410152485718, 0.12772492125872503, 0.13288378245589427, 0.16298627000710897, 0.14059327272472788, 0.13159245904383465, 0.14117231877510839, 0.14677192572340025, 0.2382819636479342, 0.27084012787706946, 0.2943620203018862, 0.2717416340737089, 0.29646497046672193, 0.2919793416343893, 0.24613714808956189, 0.32637137352732604, 0.2854673026837473, 0.21381780801405514, 0.19227208435855114, 0.22164394444283797, 0.23252321983180224, 0.2086756933959395, 0.23601140326381365, 0.21111905482702042, 0.25798022290372613, 0.1932534031286952, 0.17401159609736117, 0.1930749466879399, 0.1727393147600642, 0.1845003853992081, 0.19833847808323868, 0.1775907152884807, 0.19727016129343478, 0.18493557071064803, 0.1716421541812715, 0.18480382184022204, 0.17121045536690982, 0.16576915332428865, 0.16619888232550728, 0.1652908073871322, 0.16912954451757867, 0.16802089898458394, 0.17188055433372662, 0.1577457883424177, 0.2709593166919866, 0.17097988151784116, 0.14864226604299002, 0.3428769508249213, 0.36428634091649814, 0.17927364228159226, 0.16957906384453414, 0.16661002073399378, 0.30084217008411107, 0.35889631111069986, 0.44948201960542666, 0.21418957427891627, 0.1498060612173635, 0.2533694610958317, 0.1512701359346844, 0.2004636958720326, 0.2146323899417525, 0.23168762548764166, 0.18892554066718048, 0.1704150364995921, 0.17505681567115572, 0.16960080669429423, 0.16858191937696232, 0.16063425488431515, 0.17113672641015842, 0.1792751748575392, 0.16637680872418292, 0.06736978140131122, 0.07552499857695472, 0.08268958393551584, 0.07808660264686218, 0.07737034626800865, 0.07477407598272545, 0.06523869459001175, 0.07978198448673157, 0.0857464938691106]}, "mutation_prompt": null}
{"id": "3f61d3d1-4dda-4b47-94e4-057eefe3d207", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.15\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.elite_fraction = 0.1\n        self.dynamic_pop_size_factor = 0.95  # New dynamic factor for population size adjustment\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        diversity = np.std(parent1 - parent2)\n        if np.random.rand() < self.crossover_rate * (1 + diversity):  # Adaptive crossover\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        diversity = np.std(b - c)\n        mutant = np.clip(a + 0.8 * (b - c) * (1 + diversity), self.lower_bound, self.upper_bound)  # Adaptive mutation\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:num_elites]\n            new_population[:num_elites] = population[elite_indices]\n\n            for i in range(num_elites, self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            if eval_count < self.budget:  # Adjust population size dynamically\n                self.population_size = max(int(self.population_size * self.dynamic_pop_size_factor), 10)\n                population = population[:self.population_size]\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Enhanced Hybrid Genetic Algorithm using dynamic population size adjustment for improved convergence speed.", "configspace": "", "generation": 98, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 15 is out of bounds for axis 0 with size 15').", "error": "IndexError('index 15 is out of bounds for axis 0 with size 15')", "parent_id": "2155f422-22f4-41d2-aec7-ca715fdc2db2", "metadata": {}, "mutation_prompt": null}
{"id": "130fbe0c-6138-4d87-9ecc-d893d05d916c", "solution": "import numpy as np\n\nclass HybridGADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5 * dim, 20)\n        self.mutation_prob = 0.15\n        self.crossover_rate = 0.7\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.elite_fraction = 0.1\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        return np.array([func(ind) for ind in population])\n    \n    def _select_parents(self, fitness):\n        indices = np.arange(self.population_size)\n        selected_indices = np.random.choice(indices, 3, replace=False)\n        selected_fitness = fitness[selected_indices]\n        return selected_indices[np.argmin(selected_fitness)]\n    \n    def _crossover(self, parent1, parent2):\n        diversity = np.std(parent1 - parent2)\n        if np.random.rand() < self.crossover_rate * (1 + diversity):  # Adaptive crossover\n            alpha = np.random.rand()\n            return alpha * parent1 + (1 - alpha) * parent2\n        return parent1\n    \n    def _mutate(self, offspring):\n        if np.random.rand() < self.mutation_prob:\n            mutation_vector = np.random.uniform(-1, 1, self.dim)\n            return np.clip(offspring + mutation_vector * 0.1, self.lower_bound, self.upper_bound)\n        return offspring\n\n    def _differential_evolution(self, population, idx, best, func):\n        a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n        diversity = np.std(b - c)\n        mutant = np.clip(a + 0.8 * (b - c) * (1 + diversity), self.lower_bound, self.upper_bound)  # Adaptive mutation\n        trial = self._crossover(population[idx], mutant)\n        trial = self._mutate(trial)\n        return trial if func(trial) < func(population[idx]) else population[idx]\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            new_population = np.copy(population)\n            num_elites = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:num_elites]\n            new_population[:num_elites] = population[elite_indices]\n\n            for i in range(num_elites, self.population_size):\n                parent_idx = self._select_parents(fitness)\n                parent = population[parent_idx]\n                offspring = self._differential_evolution(population, i, best, func)\n                new_population[i] = offspring\n                eval_count += 1\n                if eval_count >= self.budget:\n                    break\n            \n            population = new_population\n            fitness = self._evaluate_population(func, population)\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < fitness[best_idx]:\n                best_idx = current_best_idx\n                best = population[best_idx]\n        \n        return best", "name": "HybridGADE", "description": "Enhanced Hybrid Genetic Algorithm by introducing adaptive mutation and crossover rates based on fitness diversity for improved exploration-exploitation balance.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2155f422-22f4-41d2-aec7-ca715fdc2db2", "metadata": {"aucs": [0.6421743905090479, 0.6717020118401242, 0.5378176832901458, 0.4748249444252264, 0.535820233609771, 0.7199110933316066, 0.5793262170925216, 0.6320767113811596, 0.594806865215757, 0.22843392877353874, 0.14308594272362518, 0.2660027135993698, 0.2923230114212976, 0.24084894933462642, 0.27485368224391626, 0.19064246657484174, 0.2699166067866948, 0.22344012654908185, 0.10704799809772181, 0.08575664246574943, 0.09860707247319445, 0.09404260202570314, 0.09513914323503181, 0.08026086628811702, 0.11261871887455999, 0.08652117091733524, 0.10131717390431627, 0.08450778632665246, 0.06879288980873133, 0.07001256866388572, 0.07698021938456345, 0.07942952206383003, 0.06370614369029082, 0.0629218364671511, 0.07217133181637359, 0.08637823598456651, 0.4980212937045603, 0.869602677246745, 0.6351735094018282, 0.17161360991800845, 0.6339722778147999, 0.6890034622199067, 0.793188745933201, 0.7086552426671385, 0.6937678835948311, 0.2250520983423192, 0.19922569072070528, 0.22719922289978578, 0.20653700544755915, 0.21146552058651014, 0.20418357383428565, 0.19869759200216364, 0.14870555811112374, 0.2074976798324657, 0.6459259315882784, 0.648225433662905, 0.650079610661288, 0.6765020604544567, 0.6690609115336531, 0.467283108588712, 0.6017672823315339, 0.4651825278817945, 0.6038487844770358, 0.13448685854141096, 0.1341707259535524, 0.09930395536897918, 0.12869736554173505, 0.18602087860184047, 0.13672692216165083, 0.12493078110130573, 0.12767623168336306, 0.13479084595166113, 0.11115387332696025, 0.21212212026766797, 0.1254343161204894, 0.1587247961659921, 0.1512754026443155, 0.11727618362633618, 0.18685712696517043, 0.17493584502699921, 0.12816158021681767, 0.1291921996218912, 0.2670782279209497, 0.124076412940889, 0.13319371460251261, 0.12105165674860496, 0.14461996725038917, 0.19473993858016514, 0.14286838704691018, 0.13556208187632024, 0.24830113315066182, 0.16157492761655323, 0.2479909495683631, 0.18733012321077902, 0.2520032839408999, 0.17328172375007966, 0.21980454250068826, 0.19555089055145736, 0.18779456101624015, 0.10912932898462391, 0.13438412234635866, 0.06905017356854548, 0.12331529357222704, 0.09973910839939182, 0.12490110975646385, 0.15467494921778557, 0.07101120952452689, 0.0700791081658203, 0.17631271645818836, 0.24694915490924974, 0.18641231760040788, 0.20338862354116893, 0.19143500051370943, 0.18086942615481783, 0.21027659424532896, 0.23034686461877407, 0.2445669959550666, 0.5774743110795042, 0.6009010532467953, 0.5661660318447606, 0.48677744231648135, 0.48321097095443133, 0.3909856176500971, 0.5220081945294528, 0.5169226253472615, 0.547681719950079, 0.098357078495236, 0.09044756309358504, 0.09262408555249513, 0.08558900475471709, 0.09780348463321786, 0.08598745130217833, 0.08018687403005131, 0.1220946994819525, 0.09351516622878242, 0.15434818888554613, 0.1310410152485718, 0.12772492125872503, 0.13288378245589427, 0.16298627000710897, 0.14059327272472788, 0.13159245904383465, 0.14117231877510839, 0.14677192572340025, 0.2382819636479342, 0.27084012787706946, 0.2943620203018862, 0.2717416340737089, 0.29646497046672193, 0.2919793416343893, 0.24613714808956189, 0.32637137352732604, 0.2854673026837473, 0.21381780801405514, 0.19227208435855114, 0.22164394444283797, 0.23252321983180224, 0.2086756933959395, 0.23601140326381365, 0.21111905482702042, 0.25798022290372613, 0.1932534031286952, 0.17401159609736117, 0.1930749466879399, 0.1727393147600642, 0.1845003853992081, 0.19833847808323868, 0.1775907152884807, 0.19727016129343478, 0.18493557071064803, 0.1716421541812715, 0.18480382184022204, 0.17121045536690982, 0.16576915332428865, 0.16619888232550728, 0.1652908073871322, 0.16912954451757867, 0.16802089898458394, 0.17188055433372662, 0.1577457883424177, 0.2709593166919866, 0.17097988151784116, 0.14864226604299002, 0.3428769508249213, 0.36428634091649814, 0.17927364228159226, 0.16957906384453414, 0.16661002073399378, 0.30084217008411107, 0.35889631111069986, 0.44948201960542666, 0.21418957427891627, 0.1498060612173635, 0.2533694610958317, 0.1512701359346844, 0.2004636958720326, 0.2146323899417525, 0.23168762548764166, 0.18892554066718048, 0.1704150364995921, 0.17505681567115572, 0.16960080669429423, 0.16858191937696232, 0.16063425488431515, 0.17113672641015842, 0.1792751748575392, 0.16637680872418292, 0.06736978140131122, 0.07552499857695472, 0.08268958393551584, 0.07808660264686218, 0.07737034626800865, 0.07477407598272545, 0.06523869459001175, 0.07978198448673157, 0.0857464938691106]}, "mutation_prompt": null}
