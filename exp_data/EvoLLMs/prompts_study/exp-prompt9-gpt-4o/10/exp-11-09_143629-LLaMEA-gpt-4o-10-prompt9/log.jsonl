{"id": "ccb2030d-37e7-4dea-b52d-d174546641ef", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, target, a, b, c, F=0.8):\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                a, b, c = self.select_parents()\n                mutant = self.mutate(target, a, b, c)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridDifferentialEvolution", "description": "Hybrid Differential Evolution with Adaptive Crossover and Mutation for exploring diverse regions and exploiting promising areas efficiently.", "configspace": "", "generation": 0, "fitness": 0.261332256345072, "feedback": "The algorithm HybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.21.", "error": "", "parent_id": null, "metadata": {"aucs": [0.6303508354012273, 0.5881740726649367, 0.5891367376365919, 0.6568358532205242, 0.6555401612365537, 0.65296100072555, 0.6637250105621948, 0.6265200288477026, 0.6187073213074975, 0.37439341304077844, 0.3800832742909276, 0.40121637057003157, 0.36186636213755163, 0.39349809186942775, 0.37504237839940546, 0.3676173354635739, 0.4193998164447448, 0.37875790113541397, 0.08457234728953755, 0.09768538036614738, 0.09939994212135517, 0.09869526375611914, 0.10221110508964115, 0.09338603933660983, 0.09402119400699771, 0.08731927456072386, 0.0975070629226138, 0.0846779025785136, 0.08475860204237373, 0.10875946924860236, 0.08593690562373735, 0.09274532457230034, 0.08477075380675247, 0.08852976634851817, 0.08869646286835409, 0.09196649997552997, 0.9806164642140757, 0.9131818418276485, 0.9674545387139455, 0.9574454447453314, 0.9162789564746359, 0.937231638163827, 0.9708179656152067, 0.9572804101259852, 0.9689147118055341, 0.28767841534904903, 0.27664866878666927, 0.2767787090641307, 0.2923089614211929, 0.2936114022452716, 0.2978810074614271, 0.3049580789019337, 0.2947505647469819, 0.3244318716073322, 0.4526956263143981, 0.5248197934116622, 0.41221304718668095, 0.5446581167637885, 0.5107403124377873, 0.5252956318567661, 0.48803742374257464, 0.5922773014258165, 0.505131848408342, 0.18994771786815068, 0.17033309018921095, 0.18962320003970023, 0.1910976729789471, 0.20456379799817226, 0.2070114110775435, 0.20124931116062617, 0.15631712961686228, 0.1529920834026519, 0.3055112677980847, 0.1845900816905398, 0.2276708148330614, 0.18309171089383114, 0.1441194727355769, 0.1969768063407772, 0.14134762277706048, 0.1792125223003732, 0.19596984723449518, 0.10801259564742283, 0.10967396084522951, 0.13301285818910424, 0.12525735077891154, 0.12275425545154262, 0.11890239086965615, 0.133685315045173, 0.11501453728025224, 0.11283451563224478, 0.2539429787238767, 0.25896604227405284, 0.25913870931783944, 0.24087463892121008, 0.2149830053963011, 0.2187834475285385, 0.27922647490104313, 0.2924978657640861, 0.28086858341926335, 0.028143112581165197, 0.039852708190292296, 0.017294577783444454, 0.043772841013424824, 0.02461714117929914, 0.04127468037370052, 0.04327819683910983, 0.04587756189208636, 0.05844591588151238, 0.16455666449639217, 0.15526429165349842, 0.15266820615463972, 0.16384632922330133, 0.15995796486835245, 0.16239319887670844, 0.15369415611647597, 0.15767720857427558, 0.16742728621304837, 0.45465858219947897, 0.47302634420768974, 0.48483373588285883, 0.5086286141823626, 0.4832328721843345, 0.4946498136198044, 0.4602369260347182, 0.48678270611797436, 0.48532356754305794, 0.0844803077644134, 0.08415303633101867, 0.10025593786815001, 0.08432894306818195, 0.09502256669064424, 0.08987697026955177, 0.08039373434577479, 0.07934987507880142, 0.09686658210897281, 0.16801503062757928, 0.17302141451976039, 0.15502553429251453, 0.16352084702203262, 0.13602443403332198, 0.13638572837206264, 0.16024913837653498, 0.12693231315176212, 0.16391225786162578, 0.2874423904336383, 0.25031984715689437, 0.2840692816521003, 0.24230536005838954, 0.23905103299313368, 0.2594671564596721, 0.27418700571780275, 0.294969186889666, 0.28426947115397716, 0.21751662185266252, 0.19659104531943938, 0.1939266368330259, 0.19054678573538264, 0.190122406672665, 0.20111429963049443, 0.19993247051676832, 0.2110290629383278, 0.21386775057452556, 0.18996915365687672, 0.1663641699353139, 0.19324255631970033, 0.17364760462161344, 0.1870411048485292, 0.19408361306047373, 0.19284687291941127, 0.17892342692630614, 0.20398711381524892, 0.17165340471788326, 0.1967187745695591, 0.18302442806360586, 0.17590332188346436, 0.1765885235593807, 0.17347456612798162, 0.1776861424187095, 0.17522357168451674, 0.18793134262210875, 0.15921784572767506, 0.6129508645813364, 0.6642467290753948, 0.1786883177057873, 0.18378424769521984, 0.18073628786737195, 0.15403689036891155, 0.20886084501698632, 0.342656479443594, 0.18670770639170065, 0.19405961062195598, 0.18446824984255095, 0.35460133867526933, 0.2680880141132066, 0.18146512164890416, 0.20313234900068633, 0.4998942066599751, 0.20536619896909192, 0.18783732924635088, 0.18023815829916234, 0.20220339461419934, 0.18749187771032993, 0.16688167222158756, 0.19104640338469214, 0.1754204263818494, 0.18923353842363744, 0.17298381898649295, 0.06350994990888392, 0.07711820996947749, 0.06395195290550271, 0.07669306676589549, 0.07181442078783418, 0.06805418663340457, 0.07552370055913327, 0.06568610617668169, 0.07719139294140276]}, "mutation_prompt": null}
{"id": "0c35517c-b52c-42b5-88cf-3a16244cb7cd", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, target, a, b, c, F=0.8):\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                a, b, c = self.select_parents()\n                mutant = self.mutate(target, a, b, c)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridDifferentialEvolution", "description": "Hybrid Differential Evolution with Adaptive Crossover and Mutation for exploring diverse regions and exploiting promising areas efficiently.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ccb2030d-37e7-4dea-b52d-d174546641ef", "metadata": {"aucs": [0.6303508354012273, 0.5881740726649367, 0.5891367376365919, 0.6568358532205242, 0.6555401612365537, 0.65296100072555, 0.6637250105621948, 0.6265200288477026, 0.6187073213074975, 0.37439341304077844, 0.3800832742909276, 0.40121637057003157, 0.36186636213755163, 0.39349809186942775, 0.37504237839940546, 0.3676173354635739, 0.4193998164447448, 0.37875790113541397, 0.08457234728953755, 0.09768538036614738, 0.09939994212135517, 0.09869526375611914, 0.10221110508964115, 0.09338603933660983, 0.09402119400699771, 0.08731927456072386, 0.0975070629226138, 0.0846779025785136, 0.08475860204237373, 0.10875946924860236, 0.08593690562373735, 0.09274532457230034, 0.08477075380675247, 0.08852976634851817, 0.08869646286835409, 0.09196649997552997, 0.9806164642140757, 0.9131818418276485, 0.9674545387139455, 0.9574454447453314, 0.9162789564746359, 0.937231638163827, 0.9708179656152067, 0.9572804101259852, 0.9689147118055341, 0.28767841534904903, 0.27664866878666927, 0.2767787090641307, 0.2923089614211929, 0.2936114022452716, 0.2978810074614271, 0.3049580789019337, 0.2947505647469819, 0.3244318716073322, 0.4526956263143981, 0.5248197934116622, 0.41221304718668095, 0.5446581167637885, 0.5107403124377873, 0.5252956318567661, 0.48803742374257464, 0.5922773014258165, 0.505131848408342, 0.18994771786815068, 0.17033309018921095, 0.18962320003970023, 0.1910976729789471, 0.20456379799817226, 0.2070114110775435, 0.20124931116062617, 0.15631712961686228, 0.1529920834026519, 0.3055112677980847, 0.1845900816905398, 0.2276708148330614, 0.18309171089383114, 0.1441194727355769, 0.1969768063407772, 0.14134762277706048, 0.1792125223003732, 0.19596984723449518, 0.10801259564742283, 0.10967396084522951, 0.13301285818910424, 0.12525735077891154, 0.12275425545154262, 0.11890239086965615, 0.133685315045173, 0.11501453728025224, 0.11283451563224478, 0.2539429787238767, 0.25896604227405284, 0.25913870931783944, 0.24087463892121008, 0.2149830053963011, 0.2187834475285385, 0.27922647490104313, 0.2924978657640861, 0.28086858341926335, 0.028143112581165197, 0.039852708190292296, 0.017294577783444454, 0.043772841013424824, 0.02461714117929914, 0.04127468037370052, 0.04327819683910983, 0.04587756189208636, 0.05844591588151238, 0.16455666449639217, 0.15526429165349842, 0.15266820615463972, 0.16384632922330133, 0.15995796486835245, 0.16239319887670844, 0.15369415611647597, 0.15767720857427558, 0.16742728621304837, 0.45465858219947897, 0.47302634420768974, 0.48483373588285883, 0.5086286141823626, 0.4832328721843345, 0.4946498136198044, 0.4602369260347182, 0.48678270611797436, 0.48532356754305794, 0.0844803077644134, 0.08415303633101867, 0.10025593786815001, 0.08432894306818195, 0.09502256669064424, 0.08987697026955177, 0.08039373434577479, 0.07934987507880142, 0.09686658210897281, 0.16801503062757928, 0.17302141451976039, 0.15502553429251453, 0.16352084702203262, 0.13602443403332198, 0.13638572837206264, 0.16024913837653498, 0.12693231315176212, 0.16391225786162578, 0.2874423904336383, 0.25031984715689437, 0.2840692816521003, 0.24230536005838954, 0.23905103299313368, 0.2594671564596721, 0.27418700571780275, 0.294969186889666, 0.28426947115397716, 0.21751662185266252, 0.19659104531943938, 0.1939266368330259, 0.19054678573538264, 0.190122406672665, 0.20111429963049443, 0.19993247051676832, 0.2110290629383278, 0.21386775057452556, 0.18996915365687672, 0.1663641699353139, 0.19324255631970033, 0.17364760462161344, 0.1870411048485292, 0.19408361306047373, 0.19284687291941127, 0.17892342692630614, 0.20398711381524892, 0.17165340471788326, 0.1967187745695591, 0.18302442806360586, 0.17590332188346436, 0.1765885235593807, 0.17347456612798162, 0.1776861424187095, 0.17522357168451674, 0.18793134262210875, 0.15921784572767506, 0.6129508645813364, 0.6642467290753948, 0.1786883177057873, 0.18378424769521984, 0.18073628786737195, 0.15403689036891155, 0.20886084501698632, 0.342656479443594, 0.18670770639170065, 0.19405961062195598, 0.18446824984255095, 0.35460133867526933, 0.2680880141132066, 0.18146512164890416, 0.20313234900068633, 0.4998942066599751, 0.20536619896909192, 0.18783732924635088, 0.18023815829916234, 0.20220339461419934, 0.18749187771032993, 0.16688167222158756, 0.19104640338469214, 0.1754204263818494, 0.18923353842363744, 0.17298381898649295, 0.06350994990888392, 0.07711820996947749, 0.06395195290550271, 0.07669306676589549, 0.07181442078783418, 0.06805418663340457, 0.07552370055913327, 0.06568610617668169, 0.07719139294140276]}, "mutation_prompt": null}
{"id": "511fa492-9ea8-46d6-ac13-e82bad692531", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, target, a, b, c, F=0.8):\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                a, b, c = self.select_parents()\n                mutant = self.mutate(target, a, b, c)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridDifferentialEvolution", "description": "Hybrid Differential Evolution with Adaptive Crossover and Mutation for exploring diverse regions and exploiting promising areas efficiently.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ccb2030d-37e7-4dea-b52d-d174546641ef", "metadata": {"aucs": [0.6303508354012273, 0.5881740726649367, 0.5891367376365919, 0.6568358532205242, 0.6555401612365537, 0.65296100072555, 0.6637250105621948, 0.6265200288477026, 0.6187073213074975, 0.37439341304077844, 0.3800832742909276, 0.40121637057003157, 0.36186636213755163, 0.39349809186942775, 0.37504237839940546, 0.3676173354635739, 0.4193998164447448, 0.37875790113541397, 0.08457234728953755, 0.09768538036614738, 0.09939994212135517, 0.09869526375611914, 0.10221110508964115, 0.09338603933660983, 0.09402119400699771, 0.08731927456072386, 0.0975070629226138, 0.0846779025785136, 0.08475860204237373, 0.10875946924860236, 0.08593690562373735, 0.09274532457230034, 0.08477075380675247, 0.08852976634851817, 0.08869646286835409, 0.09196649997552997, 0.9806164642140757, 0.9131818418276485, 0.9674545387139455, 0.9574454447453314, 0.9162789564746359, 0.937231638163827, 0.9708179656152067, 0.9572804101259852, 0.9689147118055341, 0.28767841534904903, 0.27664866878666927, 0.2767787090641307, 0.2923089614211929, 0.2936114022452716, 0.2978810074614271, 0.3049580789019337, 0.2947505647469819, 0.3244318716073322, 0.4526956263143981, 0.5248197934116622, 0.41221304718668095, 0.5446581167637885, 0.5107403124377873, 0.5252956318567661, 0.48803742374257464, 0.5922773014258165, 0.505131848408342, 0.18994771786815068, 0.17033309018921095, 0.18962320003970023, 0.1910976729789471, 0.20456379799817226, 0.2070114110775435, 0.20124931116062617, 0.15631712961686228, 0.1529920834026519, 0.3055112677980847, 0.1845900816905398, 0.2276708148330614, 0.18309171089383114, 0.1441194727355769, 0.1969768063407772, 0.14134762277706048, 0.1792125223003732, 0.19596984723449518, 0.10801259564742283, 0.10967396084522951, 0.13301285818910424, 0.12525735077891154, 0.12275425545154262, 0.11890239086965615, 0.133685315045173, 0.11501453728025224, 0.11283451563224478, 0.2539429787238767, 0.25896604227405284, 0.25913870931783944, 0.24087463892121008, 0.2149830053963011, 0.2187834475285385, 0.27922647490104313, 0.2924978657640861, 0.28086858341926335, 0.028143112581165197, 0.039852708190292296, 0.017294577783444454, 0.043772841013424824, 0.02461714117929914, 0.04127468037370052, 0.04327819683910983, 0.04587756189208636, 0.05844591588151238, 0.16455666449639217, 0.15526429165349842, 0.15266820615463972, 0.16384632922330133, 0.15995796486835245, 0.16239319887670844, 0.15369415611647597, 0.15767720857427558, 0.16742728621304837, 0.45465858219947897, 0.47302634420768974, 0.48483373588285883, 0.5086286141823626, 0.4832328721843345, 0.4946498136198044, 0.4602369260347182, 0.48678270611797436, 0.48532356754305794, 0.0844803077644134, 0.08415303633101867, 0.10025593786815001, 0.08432894306818195, 0.09502256669064424, 0.08987697026955177, 0.08039373434577479, 0.07934987507880142, 0.09686658210897281, 0.16801503062757928, 0.17302141451976039, 0.15502553429251453, 0.16352084702203262, 0.13602443403332198, 0.13638572837206264, 0.16024913837653498, 0.12693231315176212, 0.16391225786162578, 0.2874423904336383, 0.25031984715689437, 0.2840692816521003, 0.24230536005838954, 0.23905103299313368, 0.2594671564596721, 0.27418700571780275, 0.294969186889666, 0.28426947115397716, 0.21751662185266252, 0.19659104531943938, 0.1939266368330259, 0.19054678573538264, 0.190122406672665, 0.20111429963049443, 0.19993247051676832, 0.2110290629383278, 0.21386775057452556, 0.18996915365687672, 0.1663641699353139, 0.19324255631970033, 0.17364760462161344, 0.1870411048485292, 0.19408361306047373, 0.19284687291941127, 0.17892342692630614, 0.20398711381524892, 0.17165340471788326, 0.1967187745695591, 0.18302442806360586, 0.17590332188346436, 0.1765885235593807, 0.17347456612798162, 0.1776861424187095, 0.17522357168451674, 0.18793134262210875, 0.15921784572767506, 0.6129508645813364, 0.6642467290753948, 0.1786883177057873, 0.18378424769521984, 0.18073628786737195, 0.15403689036891155, 0.20886084501698632, 0.342656479443594, 0.18670770639170065, 0.19405961062195598, 0.18446824984255095, 0.35460133867526933, 0.2680880141132066, 0.18146512164890416, 0.20313234900068633, 0.4998942066599751, 0.20536619896909192, 0.18783732924635088, 0.18023815829916234, 0.20220339461419934, 0.18749187771032993, 0.16688167222158756, 0.19104640338469214, 0.1754204263818494, 0.18923353842363744, 0.17298381898649295, 0.06350994990888392, 0.07711820996947749, 0.06395195290550271, 0.07669306676589549, 0.07181442078783418, 0.06805418663340457, 0.07552370055913327, 0.06568610617668169, 0.07719139294140276]}, "mutation_prompt": null}
{"id": "b7f9a431-cc65-4f0c-90f7-429a4577c4ef", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, target, a, b, c, F=0.8):\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                a, b, c = self.select_parents()\n                mutant = self.mutate(target, a, b, c)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridDifferentialEvolution", "description": "Hybrid Differential Evolution with Adaptive Crossover and Mutation for exploring diverse regions and exploiting promising areas efficiently.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ccb2030d-37e7-4dea-b52d-d174546641ef", "metadata": {"aucs": [0.6303508354012273, 0.5881740726649367, 0.5891367376365919, 0.6568358532205242, 0.6555401612365537, 0.65296100072555, 0.6637250105621948, 0.6265200288477026, 0.6187073213074975, 0.37439341304077844, 0.3800832742909276, 0.40121637057003157, 0.36186636213755163, 0.39349809186942775, 0.37504237839940546, 0.3676173354635739, 0.4193998164447448, 0.37875790113541397, 0.08457234728953755, 0.09768538036614738, 0.09939994212135517, 0.09869526375611914, 0.10221110508964115, 0.09338603933660983, 0.09402119400699771, 0.08731927456072386, 0.0975070629226138, 0.0846779025785136, 0.08475860204237373, 0.10875946924860236, 0.08593690562373735, 0.09274532457230034, 0.08477075380675247, 0.08852976634851817, 0.08869646286835409, 0.09196649997552997, 0.9806164642140757, 0.9131818418276485, 0.9674545387139455, 0.9574454447453314, 0.9162789564746359, 0.937231638163827, 0.9708179656152067, 0.9572804101259852, 0.9689147118055341, 0.28767841534904903, 0.27664866878666927, 0.2767787090641307, 0.2923089614211929, 0.2936114022452716, 0.2978810074614271, 0.3049580789019337, 0.2947505647469819, 0.3244318716073322, 0.4526956263143981, 0.5248197934116622, 0.41221304718668095, 0.5446581167637885, 0.5107403124377873, 0.5252956318567661, 0.48803742374257464, 0.5922773014258165, 0.505131848408342, 0.18994771786815068, 0.17033309018921095, 0.18962320003970023, 0.1910976729789471, 0.20456379799817226, 0.2070114110775435, 0.20124931116062617, 0.15631712961686228, 0.1529920834026519, 0.3055112677980847, 0.1845900816905398, 0.2276708148330614, 0.18309171089383114, 0.1441194727355769, 0.1969768063407772, 0.14134762277706048, 0.1792125223003732, 0.19596984723449518, 0.10801259564742283, 0.10967396084522951, 0.13301285818910424, 0.12525735077891154, 0.12275425545154262, 0.11890239086965615, 0.133685315045173, 0.11501453728025224, 0.11283451563224478, 0.2539429787238767, 0.25896604227405284, 0.25913870931783944, 0.24087463892121008, 0.2149830053963011, 0.2187834475285385, 0.27922647490104313, 0.2924978657640861, 0.28086858341926335, 0.028143112581165197, 0.039852708190292296, 0.017294577783444454, 0.043772841013424824, 0.02461714117929914, 0.04127468037370052, 0.04327819683910983, 0.04587756189208636, 0.05844591588151238, 0.16455666449639217, 0.15526429165349842, 0.15266820615463972, 0.16384632922330133, 0.15995796486835245, 0.16239319887670844, 0.15369415611647597, 0.15767720857427558, 0.16742728621304837, 0.45465858219947897, 0.47302634420768974, 0.48483373588285883, 0.5086286141823626, 0.4832328721843345, 0.4946498136198044, 0.4602369260347182, 0.48678270611797436, 0.48532356754305794, 0.0844803077644134, 0.08415303633101867, 0.10025593786815001, 0.08432894306818195, 0.09502256669064424, 0.08987697026955177, 0.08039373434577479, 0.07934987507880142, 0.09686658210897281, 0.16801503062757928, 0.17302141451976039, 0.15502553429251453, 0.16352084702203262, 0.13602443403332198, 0.13638572837206264, 0.16024913837653498, 0.12693231315176212, 0.16391225786162578, 0.2874423904336383, 0.25031984715689437, 0.2840692816521003, 0.24230536005838954, 0.23905103299313368, 0.2594671564596721, 0.27418700571780275, 0.294969186889666, 0.28426947115397716, 0.21751662185266252, 0.19659104531943938, 0.1939266368330259, 0.19054678573538264, 0.190122406672665, 0.20111429963049443, 0.19993247051676832, 0.2110290629383278, 0.21386775057452556, 0.18996915365687672, 0.1663641699353139, 0.19324255631970033, 0.17364760462161344, 0.1870411048485292, 0.19408361306047373, 0.19284687291941127, 0.17892342692630614, 0.20398711381524892, 0.17165340471788326, 0.1967187745695591, 0.18302442806360586, 0.17590332188346436, 0.1765885235593807, 0.17347456612798162, 0.1776861424187095, 0.17522357168451674, 0.18793134262210875, 0.15921784572767506, 0.6129508645813364, 0.6642467290753948, 0.1786883177057873, 0.18378424769521984, 0.18073628786737195, 0.15403689036891155, 0.20886084501698632, 0.342656479443594, 0.18670770639170065, 0.19405961062195598, 0.18446824984255095, 0.35460133867526933, 0.2680880141132066, 0.18146512164890416, 0.20313234900068633, 0.4998942066599751, 0.20536619896909192, 0.18783732924635088, 0.18023815829916234, 0.20220339461419934, 0.18749187771032993, 0.16688167222158756, 0.19104640338469214, 0.1754204263818494, 0.18923353842363744, 0.17298381898649295, 0.06350994990888392, 0.07711820996947749, 0.06395195290550271, 0.07669306676589549, 0.07181442078783418, 0.06805418663340457, 0.07552370055913327, 0.06568610617668169, 0.07719139294140276]}, "mutation_prompt": null}
{"id": "f86edd94-ea48-484f-8b31-b1cb143ed36d", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, target, a, b, c, F=0.8):\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                a, b, c = self.select_parents()\n                mutant = self.mutate(target, a, b, c)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridDifferentialEvolution", "description": "Hybrid Differential Evolution with Adaptive Crossover and Mutation for exploring diverse regions and exploiting promising areas efficiently.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ccb2030d-37e7-4dea-b52d-d174546641ef", "metadata": {"aucs": [0.6303508354012273, 0.5881740726649367, 0.5891367376365919, 0.6568358532205242, 0.6555401612365537, 0.65296100072555, 0.6637250105621948, 0.6265200288477026, 0.6187073213074975, 0.37439341304077844, 0.3800832742909276, 0.40121637057003157, 0.36186636213755163, 0.39349809186942775, 0.37504237839940546, 0.3676173354635739, 0.4193998164447448, 0.37875790113541397, 0.08457234728953755, 0.09768538036614738, 0.09939994212135517, 0.09869526375611914, 0.10221110508964115, 0.09338603933660983, 0.09402119400699771, 0.08731927456072386, 0.0975070629226138, 0.0846779025785136, 0.08475860204237373, 0.10875946924860236, 0.08593690562373735, 0.09274532457230034, 0.08477075380675247, 0.08852976634851817, 0.08869646286835409, 0.09196649997552997, 0.9806164642140757, 0.9131818418276485, 0.9674545387139455, 0.9574454447453314, 0.9162789564746359, 0.937231638163827, 0.9708179656152067, 0.9572804101259852, 0.9689147118055341, 0.28767841534904903, 0.27664866878666927, 0.2767787090641307, 0.2923089614211929, 0.2936114022452716, 0.2978810074614271, 0.3049580789019337, 0.2947505647469819, 0.3244318716073322, 0.4526956263143981, 0.5248197934116622, 0.41221304718668095, 0.5446581167637885, 0.5107403124377873, 0.5252956318567661, 0.48803742374257464, 0.5922773014258165, 0.505131848408342, 0.18994771786815068, 0.17033309018921095, 0.18962320003970023, 0.1910976729789471, 0.20456379799817226, 0.2070114110775435, 0.20124931116062617, 0.15631712961686228, 0.1529920834026519, 0.3055112677980847, 0.1845900816905398, 0.2276708148330614, 0.18309171089383114, 0.1441194727355769, 0.1969768063407772, 0.14134762277706048, 0.1792125223003732, 0.19596984723449518, 0.10801259564742283, 0.10967396084522951, 0.13301285818910424, 0.12525735077891154, 0.12275425545154262, 0.11890239086965615, 0.133685315045173, 0.11501453728025224, 0.11283451563224478, 0.2539429787238767, 0.25896604227405284, 0.25913870931783944, 0.24087463892121008, 0.2149830053963011, 0.2187834475285385, 0.27922647490104313, 0.2924978657640861, 0.28086858341926335, 0.028143112581165197, 0.039852708190292296, 0.017294577783444454, 0.043772841013424824, 0.02461714117929914, 0.04127468037370052, 0.04327819683910983, 0.04587756189208636, 0.05844591588151238, 0.16455666449639217, 0.15526429165349842, 0.15266820615463972, 0.16384632922330133, 0.15995796486835245, 0.16239319887670844, 0.15369415611647597, 0.15767720857427558, 0.16742728621304837, 0.45465858219947897, 0.47302634420768974, 0.48483373588285883, 0.5086286141823626, 0.4832328721843345, 0.4946498136198044, 0.4602369260347182, 0.48678270611797436, 0.48532356754305794, 0.0844803077644134, 0.08415303633101867, 0.10025593786815001, 0.08432894306818195, 0.09502256669064424, 0.08987697026955177, 0.08039373434577479, 0.07934987507880142, 0.09686658210897281, 0.16801503062757928, 0.17302141451976039, 0.15502553429251453, 0.16352084702203262, 0.13602443403332198, 0.13638572837206264, 0.16024913837653498, 0.12693231315176212, 0.16391225786162578, 0.2874423904336383, 0.25031984715689437, 0.2840692816521003, 0.24230536005838954, 0.23905103299313368, 0.2594671564596721, 0.27418700571780275, 0.294969186889666, 0.28426947115397716, 0.21751662185266252, 0.19659104531943938, 0.1939266368330259, 0.19054678573538264, 0.190122406672665, 0.20111429963049443, 0.19993247051676832, 0.2110290629383278, 0.21386775057452556, 0.18996915365687672, 0.1663641699353139, 0.19324255631970033, 0.17364760462161344, 0.1870411048485292, 0.19408361306047373, 0.19284687291941127, 0.17892342692630614, 0.20398711381524892, 0.17165340471788326, 0.1967187745695591, 0.18302442806360586, 0.17590332188346436, 0.1765885235593807, 0.17347456612798162, 0.1776861424187095, 0.17522357168451674, 0.18793134262210875, 0.15921784572767506, 0.6129508645813364, 0.6642467290753948, 0.1786883177057873, 0.18378424769521984, 0.18073628786737195, 0.15403689036891155, 0.20886084501698632, 0.342656479443594, 0.18670770639170065, 0.19405961062195598, 0.18446824984255095, 0.35460133867526933, 0.2680880141132066, 0.18146512164890416, 0.20313234900068633, 0.4998942066599751, 0.20536619896909192, 0.18783732924635088, 0.18023815829916234, 0.20220339461419934, 0.18749187771032993, 0.16688167222158756, 0.19104640338469214, 0.1754204263818494, 0.18923353842363744, 0.17298381898649295, 0.06350994990888392, 0.07711820996947749, 0.06395195290550271, 0.07669306676589549, 0.07181442078783418, 0.06805418663340457, 0.07552370055913327, 0.06568610617668169, 0.07719139294140276]}, "mutation_prompt": null}
{"id": "bca393d6-ed4d-4d6d-b456-c59c9b7688ed", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, target, a, b, c, F=0.8):\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                a, b, c = self.select_parents()\n                mutant = self.mutate(target, a, b, c)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridDifferentialEvolution", "description": "Hybrid Differential Evolution with Adaptive Crossover and Mutation for exploring diverse regions and exploiting promising areas efficiently.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ccb2030d-37e7-4dea-b52d-d174546641ef", "metadata": {"aucs": [0.6303508354012273, 0.5881740726649367, 0.5891367376365919, 0.6568358532205242, 0.6555401612365537, 0.65296100072555, 0.6637250105621948, 0.6265200288477026, 0.6187073213074975, 0.37439341304077844, 0.3800832742909276, 0.40121637057003157, 0.36186636213755163, 0.39349809186942775, 0.37504237839940546, 0.3676173354635739, 0.4193998164447448, 0.37875790113541397, 0.08457234728953755, 0.09768538036614738, 0.09939994212135517, 0.09869526375611914, 0.10221110508964115, 0.09338603933660983, 0.09402119400699771, 0.08731927456072386, 0.0975070629226138, 0.0846779025785136, 0.08475860204237373, 0.10875946924860236, 0.08593690562373735, 0.09274532457230034, 0.08477075380675247, 0.08852976634851817, 0.08869646286835409, 0.09196649997552997, 0.9806164642140757, 0.9131818418276485, 0.9674545387139455, 0.9574454447453314, 0.9162789564746359, 0.937231638163827, 0.9708179656152067, 0.9572804101259852, 0.9689147118055341, 0.28767841534904903, 0.27664866878666927, 0.2767787090641307, 0.2923089614211929, 0.2936114022452716, 0.2978810074614271, 0.3049580789019337, 0.2947505647469819, 0.3244318716073322, 0.4526956263143981, 0.5248197934116622, 0.41221304718668095, 0.5446581167637885, 0.5107403124377873, 0.5252956318567661, 0.48803742374257464, 0.5922773014258165, 0.505131848408342, 0.18994771786815068, 0.17033309018921095, 0.18962320003970023, 0.1910976729789471, 0.20456379799817226, 0.2070114110775435, 0.20124931116062617, 0.15631712961686228, 0.1529920834026519, 0.3055112677980847, 0.1845900816905398, 0.2276708148330614, 0.18309171089383114, 0.1441194727355769, 0.1969768063407772, 0.14134762277706048, 0.1792125223003732, 0.19596984723449518, 0.10801259564742283, 0.10967396084522951, 0.13301285818910424, 0.12525735077891154, 0.12275425545154262, 0.11890239086965615, 0.133685315045173, 0.11501453728025224, 0.11283451563224478, 0.2539429787238767, 0.25896604227405284, 0.25913870931783944, 0.24087463892121008, 0.2149830053963011, 0.2187834475285385, 0.27922647490104313, 0.2924978657640861, 0.28086858341926335, 0.028143112581165197, 0.039852708190292296, 0.017294577783444454, 0.043772841013424824, 0.02461714117929914, 0.04127468037370052, 0.04327819683910983, 0.04587756189208636, 0.05844591588151238, 0.16455666449639217, 0.15526429165349842, 0.15266820615463972, 0.16384632922330133, 0.15995796486835245, 0.16239319887670844, 0.15369415611647597, 0.15767720857427558, 0.16742728621304837, 0.45465858219947897, 0.47302634420768974, 0.48483373588285883, 0.5086286141823626, 0.4832328721843345, 0.4946498136198044, 0.4602369260347182, 0.48678270611797436, 0.48532356754305794, 0.0844803077644134, 0.08415303633101867, 0.10025593786815001, 0.08432894306818195, 0.09502256669064424, 0.08987697026955177, 0.08039373434577479, 0.07934987507880142, 0.09686658210897281, 0.16801503062757928, 0.17302141451976039, 0.15502553429251453, 0.16352084702203262, 0.13602443403332198, 0.13638572837206264, 0.16024913837653498, 0.12693231315176212, 0.16391225786162578, 0.2874423904336383, 0.25031984715689437, 0.2840692816521003, 0.24230536005838954, 0.23905103299313368, 0.2594671564596721, 0.27418700571780275, 0.294969186889666, 0.28426947115397716, 0.21751662185266252, 0.19659104531943938, 0.1939266368330259, 0.19054678573538264, 0.190122406672665, 0.20111429963049443, 0.19993247051676832, 0.2110290629383278, 0.21386775057452556, 0.18996915365687672, 0.1663641699353139, 0.19324255631970033, 0.17364760462161344, 0.1870411048485292, 0.19408361306047373, 0.19284687291941127, 0.17892342692630614, 0.20398711381524892, 0.17165340471788326, 0.1967187745695591, 0.18302442806360586, 0.17590332188346436, 0.1765885235593807, 0.17347456612798162, 0.1776861424187095, 0.17522357168451674, 0.18793134262210875, 0.15921784572767506, 0.6129508645813364, 0.6642467290753948, 0.1786883177057873, 0.18378424769521984, 0.18073628786737195, 0.15403689036891155, 0.20886084501698632, 0.342656479443594, 0.18670770639170065, 0.19405961062195598, 0.18446824984255095, 0.35460133867526933, 0.2680880141132066, 0.18146512164890416, 0.20313234900068633, 0.4998942066599751, 0.20536619896909192, 0.18783732924635088, 0.18023815829916234, 0.20220339461419934, 0.18749187771032993, 0.16688167222158756, 0.19104640338469214, 0.1754204263818494, 0.18923353842363744, 0.17298381898649295, 0.06350994990888392, 0.07711820996947749, 0.06395195290550271, 0.07669306676589549, 0.07181442078783418, 0.06805418663340457, 0.07552370055913327, 0.06568610617668169, 0.07719139294140276]}, "mutation_prompt": null}
{"id": "f267d220-6b61-4d7d-8e93-a60aecbad430", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, target, a, b, c, F=0.8):\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                a, b, c = self.select_parents()\n                mutant = self.mutate(target, a, b, c)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridDifferentialEvolution", "description": "Hybrid Differential Evolution with Adaptive Crossover and Mutation for exploring diverse regions and exploiting promising areas efficiently.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ccb2030d-37e7-4dea-b52d-d174546641ef", "metadata": {"aucs": [0.6303508354012273, 0.5881740726649367, 0.5891367376365919, 0.6568358532205242, 0.6555401612365537, 0.65296100072555, 0.6637250105621948, 0.6265200288477026, 0.6187073213074975, 0.37439341304077844, 0.3800832742909276, 0.40121637057003157, 0.36186636213755163, 0.39349809186942775, 0.37504237839940546, 0.3676173354635739, 0.4193998164447448, 0.37875790113541397, 0.08457234728953755, 0.09768538036614738, 0.09939994212135517, 0.09869526375611914, 0.10221110508964115, 0.09338603933660983, 0.09402119400699771, 0.08731927456072386, 0.0975070629226138, 0.0846779025785136, 0.08475860204237373, 0.10875946924860236, 0.08593690562373735, 0.09274532457230034, 0.08477075380675247, 0.08852976634851817, 0.08869646286835409, 0.09196649997552997, 0.9806164642140757, 0.9131818418276485, 0.9674545387139455, 0.9574454447453314, 0.9162789564746359, 0.937231638163827, 0.9708179656152067, 0.9572804101259852, 0.9689147118055341, 0.28767841534904903, 0.27664866878666927, 0.2767787090641307, 0.2923089614211929, 0.2936114022452716, 0.2978810074614271, 0.3049580789019337, 0.2947505647469819, 0.3244318716073322, 0.4526956263143981, 0.5248197934116622, 0.41221304718668095, 0.5446581167637885, 0.5107403124377873, 0.5252956318567661, 0.48803742374257464, 0.5922773014258165, 0.505131848408342, 0.18994771786815068, 0.17033309018921095, 0.18962320003970023, 0.1910976729789471, 0.20456379799817226, 0.2070114110775435, 0.20124931116062617, 0.15631712961686228, 0.1529920834026519, 0.3055112677980847, 0.1845900816905398, 0.2276708148330614, 0.18309171089383114, 0.1441194727355769, 0.1969768063407772, 0.14134762277706048, 0.1792125223003732, 0.19596984723449518, 0.10801259564742283, 0.10967396084522951, 0.13301285818910424, 0.12525735077891154, 0.12275425545154262, 0.11890239086965615, 0.133685315045173, 0.11501453728025224, 0.11283451563224478, 0.2539429787238767, 0.25896604227405284, 0.25913870931783944, 0.24087463892121008, 0.2149830053963011, 0.2187834475285385, 0.27922647490104313, 0.2924978657640861, 0.28086858341926335, 0.028143112581165197, 0.039852708190292296, 0.017294577783444454, 0.043772841013424824, 0.02461714117929914, 0.04127468037370052, 0.04327819683910983, 0.04587756189208636, 0.05844591588151238, 0.16455666449639217, 0.15526429165349842, 0.15266820615463972, 0.16384632922330133, 0.15995796486835245, 0.16239319887670844, 0.15369415611647597, 0.15767720857427558, 0.16742728621304837, 0.45465858219947897, 0.47302634420768974, 0.48483373588285883, 0.5086286141823626, 0.4832328721843345, 0.4946498136198044, 0.4602369260347182, 0.48678270611797436, 0.48532356754305794, 0.0844803077644134, 0.08415303633101867, 0.10025593786815001, 0.08432894306818195, 0.09502256669064424, 0.08987697026955177, 0.08039373434577479, 0.07934987507880142, 0.09686658210897281, 0.16801503062757928, 0.17302141451976039, 0.15502553429251453, 0.16352084702203262, 0.13602443403332198, 0.13638572837206264, 0.16024913837653498, 0.12693231315176212, 0.16391225786162578, 0.2874423904336383, 0.25031984715689437, 0.2840692816521003, 0.24230536005838954, 0.23905103299313368, 0.2594671564596721, 0.27418700571780275, 0.294969186889666, 0.28426947115397716, 0.21751662185266252, 0.19659104531943938, 0.1939266368330259, 0.19054678573538264, 0.190122406672665, 0.20111429963049443, 0.19993247051676832, 0.2110290629383278, 0.21386775057452556, 0.18996915365687672, 0.1663641699353139, 0.19324255631970033, 0.17364760462161344, 0.1870411048485292, 0.19408361306047373, 0.19284687291941127, 0.17892342692630614, 0.20398711381524892, 0.17165340471788326, 0.1967187745695591, 0.18302442806360586, 0.17590332188346436, 0.1765885235593807, 0.17347456612798162, 0.1776861424187095, 0.17522357168451674, 0.18793134262210875, 0.15921784572767506, 0.6129508645813364, 0.6642467290753948, 0.1786883177057873, 0.18378424769521984, 0.18073628786737195, 0.15403689036891155, 0.20886084501698632, 0.342656479443594, 0.18670770639170065, 0.19405961062195598, 0.18446824984255095, 0.35460133867526933, 0.2680880141132066, 0.18146512164890416, 0.20313234900068633, 0.4998942066599751, 0.20536619896909192, 0.18783732924635088, 0.18023815829916234, 0.20220339461419934, 0.18749187771032993, 0.16688167222158756, 0.19104640338469214, 0.1754204263818494, 0.18923353842363744, 0.17298381898649295, 0.06350994990888392, 0.07711820996947749, 0.06395195290550271, 0.07669306676589549, 0.07181442078783418, 0.06805418663340457, 0.07552370055913327, 0.06568610617668169, 0.07719139294140276]}, "mutation_prompt": null}
{"id": "c5280e16-42c1-471d-817e-b402f7885d9b", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, target, a, b, c, F=0.8):\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                a, b, c = self.select_parents()\n                mutant = self.mutate(target, a, b, c)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridDifferentialEvolution", "description": "Hybrid Differential Evolution with Adaptive Crossover and Mutation for exploring diverse regions and exploiting promising areas efficiently.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ccb2030d-37e7-4dea-b52d-d174546641ef", "metadata": {"aucs": [0.6303508354012273, 0.5881740726649367, 0.5891367376365919, 0.6568358532205242, 0.6555401612365537, 0.65296100072555, 0.6637250105621948, 0.6265200288477026, 0.6187073213074975, 0.37439341304077844, 0.3800832742909276, 0.40121637057003157, 0.36186636213755163, 0.39349809186942775, 0.37504237839940546, 0.3676173354635739, 0.4193998164447448, 0.37875790113541397, 0.08457234728953755, 0.09768538036614738, 0.09939994212135517, 0.09869526375611914, 0.10221110508964115, 0.09338603933660983, 0.09402119400699771, 0.08731927456072386, 0.0975070629226138, 0.0846779025785136, 0.08475860204237373, 0.10875946924860236, 0.08593690562373735, 0.09274532457230034, 0.08477075380675247, 0.08852976634851817, 0.08869646286835409, 0.09196649997552997, 0.9806164642140757, 0.9131818418276485, 0.9674545387139455, 0.9574454447453314, 0.9162789564746359, 0.937231638163827, 0.9708179656152067, 0.9572804101259852, 0.9689147118055341, 0.28767841534904903, 0.27664866878666927, 0.2767787090641307, 0.2923089614211929, 0.2936114022452716, 0.2978810074614271, 0.3049580789019337, 0.2947505647469819, 0.3244318716073322, 0.4526956263143981, 0.5248197934116622, 0.41221304718668095, 0.5446581167637885, 0.5107403124377873, 0.5252956318567661, 0.48803742374257464, 0.5922773014258165, 0.505131848408342, 0.18994771786815068, 0.17033309018921095, 0.18962320003970023, 0.1910976729789471, 0.20456379799817226, 0.2070114110775435, 0.20124931116062617, 0.15631712961686228, 0.1529920834026519, 0.3055112677980847, 0.1845900816905398, 0.2276708148330614, 0.18309171089383114, 0.1441194727355769, 0.1969768063407772, 0.14134762277706048, 0.1792125223003732, 0.19596984723449518, 0.10801259564742283, 0.10967396084522951, 0.13301285818910424, 0.12525735077891154, 0.12275425545154262, 0.11890239086965615, 0.133685315045173, 0.11501453728025224, 0.11283451563224478, 0.2539429787238767, 0.25896604227405284, 0.25913870931783944, 0.24087463892121008, 0.2149830053963011, 0.2187834475285385, 0.27922647490104313, 0.2924978657640861, 0.28086858341926335, 0.028143112581165197, 0.039852708190292296, 0.017294577783444454, 0.043772841013424824, 0.02461714117929914, 0.04127468037370052, 0.04327819683910983, 0.04587756189208636, 0.05844591588151238, 0.16455666449639217, 0.15526429165349842, 0.15266820615463972, 0.16384632922330133, 0.15995796486835245, 0.16239319887670844, 0.15369415611647597, 0.15767720857427558, 0.16742728621304837, 0.45465858219947897, 0.47302634420768974, 0.48483373588285883, 0.5086286141823626, 0.4832328721843345, 0.4946498136198044, 0.4602369260347182, 0.48678270611797436, 0.48532356754305794, 0.0844803077644134, 0.08415303633101867, 0.10025593786815001, 0.08432894306818195, 0.09502256669064424, 0.08987697026955177, 0.08039373434577479, 0.07934987507880142, 0.09686658210897281, 0.16801503062757928, 0.17302141451976039, 0.15502553429251453, 0.16352084702203262, 0.13602443403332198, 0.13638572837206264, 0.16024913837653498, 0.12693231315176212, 0.16391225786162578, 0.2874423904336383, 0.25031984715689437, 0.2840692816521003, 0.24230536005838954, 0.23905103299313368, 0.2594671564596721, 0.27418700571780275, 0.294969186889666, 0.28426947115397716, 0.21751662185266252, 0.19659104531943938, 0.1939266368330259, 0.19054678573538264, 0.190122406672665, 0.20111429963049443, 0.19993247051676832, 0.2110290629383278, 0.21386775057452556, 0.18996915365687672, 0.1663641699353139, 0.19324255631970033, 0.17364760462161344, 0.1870411048485292, 0.19408361306047373, 0.19284687291941127, 0.17892342692630614, 0.20398711381524892, 0.17165340471788326, 0.1967187745695591, 0.18302442806360586, 0.17590332188346436, 0.1765885235593807, 0.17347456612798162, 0.1776861424187095, 0.17522357168451674, 0.18793134262210875, 0.15921784572767506, 0.6129508645813364, 0.6642467290753948, 0.1786883177057873, 0.18378424769521984, 0.18073628786737195, 0.15403689036891155, 0.20886084501698632, 0.342656479443594, 0.18670770639170065, 0.19405961062195598, 0.18446824984255095, 0.35460133867526933, 0.2680880141132066, 0.18146512164890416, 0.20313234900068633, 0.4998942066599751, 0.20536619896909192, 0.18783732924635088, 0.18023815829916234, 0.20220339461419934, 0.18749187771032993, 0.16688167222158756, 0.19104640338469214, 0.1754204263818494, 0.18923353842363744, 0.17298381898649295, 0.06350994990888392, 0.07711820996947749, 0.06395195290550271, 0.07669306676589549, 0.07181442078783418, 0.06805418663340457, 0.07552370055913327, 0.06568610617668169, 0.07719139294140276]}, "mutation_prompt": null}
{"id": "4f690275-a953-4348-8d11-8360bee8425d", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, target, a, b, c, F=0.8):\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                target = self.population[i]\n                a, b, c = self.select_parents()\n                mutant = self.mutate(target, a, b, c)\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridDifferentialEvolution", "description": "Hybrid Differential Evolution with Adaptive Crossover and Mutation for exploring diverse regions and exploiting promising areas efficiently.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ccb2030d-37e7-4dea-b52d-d174546641ef", "metadata": {"aucs": [0.6303508354012273, 0.5881740726649367, 0.5891367376365919, 0.6568358532205242, 0.6555401612365537, 0.65296100072555, 0.6637250105621948, 0.6265200288477026, 0.6187073213074975, 0.37439341304077844, 0.3800832742909276, 0.40121637057003157, 0.36186636213755163, 0.39349809186942775, 0.37504237839940546, 0.3676173354635739, 0.4193998164447448, 0.37875790113541397, 0.08457234728953755, 0.09768538036614738, 0.09939994212135517, 0.09869526375611914, 0.10221110508964115, 0.09338603933660983, 0.09402119400699771, 0.08731927456072386, 0.0975070629226138, 0.0846779025785136, 0.08475860204237373, 0.10875946924860236, 0.08593690562373735, 0.09274532457230034, 0.08477075380675247, 0.08852976634851817, 0.08869646286835409, 0.09196649997552997, 0.9806164642140757, 0.9131818418276485, 0.9674545387139455, 0.9574454447453314, 0.9162789564746359, 0.937231638163827, 0.9708179656152067, 0.9572804101259852, 0.9689147118055341, 0.28767841534904903, 0.27664866878666927, 0.2767787090641307, 0.2923089614211929, 0.2936114022452716, 0.2978810074614271, 0.3049580789019337, 0.2947505647469819, 0.3244318716073322, 0.4526956263143981, 0.5248197934116622, 0.41221304718668095, 0.5446581167637885, 0.5107403124377873, 0.5252956318567661, 0.48803742374257464, 0.5922773014258165, 0.505131848408342, 0.18994771786815068, 0.17033309018921095, 0.18962320003970023, 0.1910976729789471, 0.20456379799817226, 0.2070114110775435, 0.20124931116062617, 0.15631712961686228, 0.1529920834026519, 0.3055112677980847, 0.1845900816905398, 0.2276708148330614, 0.18309171089383114, 0.1441194727355769, 0.1969768063407772, 0.14134762277706048, 0.1792125223003732, 0.19596984723449518, 0.10801259564742283, 0.10967396084522951, 0.13301285818910424, 0.12525735077891154, 0.12275425545154262, 0.11890239086965615, 0.133685315045173, 0.11501453728025224, 0.11283451563224478, 0.2539429787238767, 0.25896604227405284, 0.25913870931783944, 0.24087463892121008, 0.2149830053963011, 0.2187834475285385, 0.27922647490104313, 0.2924978657640861, 0.28086858341926335, 0.028143112581165197, 0.039852708190292296, 0.017294577783444454, 0.043772841013424824, 0.02461714117929914, 0.04127468037370052, 0.04327819683910983, 0.04587756189208636, 0.05844591588151238, 0.16455666449639217, 0.15526429165349842, 0.15266820615463972, 0.16384632922330133, 0.15995796486835245, 0.16239319887670844, 0.15369415611647597, 0.15767720857427558, 0.16742728621304837, 0.45465858219947897, 0.47302634420768974, 0.48483373588285883, 0.5086286141823626, 0.4832328721843345, 0.4946498136198044, 0.4602369260347182, 0.48678270611797436, 0.48532356754305794, 0.0844803077644134, 0.08415303633101867, 0.10025593786815001, 0.08432894306818195, 0.09502256669064424, 0.08987697026955177, 0.08039373434577479, 0.07934987507880142, 0.09686658210897281, 0.16801503062757928, 0.17302141451976039, 0.15502553429251453, 0.16352084702203262, 0.13602443403332198, 0.13638572837206264, 0.16024913837653498, 0.12693231315176212, 0.16391225786162578, 0.2874423904336383, 0.25031984715689437, 0.2840692816521003, 0.24230536005838954, 0.23905103299313368, 0.2594671564596721, 0.27418700571780275, 0.294969186889666, 0.28426947115397716, 0.21751662185266252, 0.19659104531943938, 0.1939266368330259, 0.19054678573538264, 0.190122406672665, 0.20111429963049443, 0.19993247051676832, 0.2110290629383278, 0.21386775057452556, 0.18996915365687672, 0.1663641699353139, 0.19324255631970033, 0.17364760462161344, 0.1870411048485292, 0.19408361306047373, 0.19284687291941127, 0.17892342692630614, 0.20398711381524892, 0.17165340471788326, 0.1967187745695591, 0.18302442806360586, 0.17590332188346436, 0.1765885235593807, 0.17347456612798162, 0.1776861424187095, 0.17522357168451674, 0.18793134262210875, 0.15921784572767506, 0.6129508645813364, 0.6642467290753948, 0.1786883177057873, 0.18378424769521984, 0.18073628786737195, 0.15403689036891155, 0.20886084501698632, 0.342656479443594, 0.18670770639170065, 0.19405961062195598, 0.18446824984255095, 0.35460133867526933, 0.2680880141132066, 0.18146512164890416, 0.20313234900068633, 0.4998942066599751, 0.20536619896909192, 0.18783732924635088, 0.18023815829916234, 0.20220339461419934, 0.18749187771032993, 0.16688167222158756, 0.19104640338469214, 0.1754204263818494, 0.18923353842363744, 0.17298381898649295, 0.06350994990888392, 0.07711820996947749, 0.06395195290550271, 0.07669306676589549, 0.07181442078783418, 0.06805418663340457, 0.07552370055913327, 0.06568610617668169, 0.07719139294140276]}, "mutation_prompt": null}
{"id": "59daa2a0-f16e-4aa6-90a0-467962392d25", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.8):\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def adaptive_random_search(self):\n        # Introduce a simple random perturbation around the global best for exploration\n        perturbation = np.random.uniform(-0.5, 0.5, self.dim)\n        candidate = np.clip(self.population[self.global_best] + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.1:  # 10% chance to use adaptive random search\n                    trial = self.adaptive_random_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n                \n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.fitness[self.global_best]:\n                        self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridDifferentialEvolution", "description": "Hybrid Differential Evolution with Adaptive Random Search to enhance exploration and exploitation balance for faster convergence.", "configspace": "", "generation": 9, "fitness": 0.30768011127220307, "feedback": "The algorithm HybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.", "error": "", "parent_id": "ccb2030d-37e7-4dea-b52d-d174546641ef", "metadata": {"aucs": [0.6632627818289437, 0.6922600076938976, 0.6727474769545064, 0.6831793781364897, 0.6931864228567788, 0.7112704654163935, 0.6762788735227594, 0.6877669403831868, 0.6881332008922942, 0.3642917767817637, 0.3319488004055168, 0.3635178469066336, 0.3441238789552844, 0.3664673752841705, 0.3771244072890061, 0.36577110996151285, 0.3684543166503771, 0.37535223784159333, 0.11144604164629257, 0.12365291414215185, 0.12611498569300805, 0.12085868575135938, 0.10791295181524418, 0.1007331743003842, 0.11031540114354843, 0.11535575912300122, 0.1308043805093726, 0.1064966168822471, 0.10422564366673936, 0.11524729307407255, 0.10011327340048104, 0.09261783019145298, 0.09055337610988445, 0.09627502265863819, 0.1046658881573308, 0.09313518313064473, 0.972225768001981, 0.9792281766191235, 0.9843426728302413, 0.9455856430166695, 0.9526355388353679, 0.954814718802366, 0.9788163534665784, 0.9669919479112222, 0.9671258974813884, 0.34503321716428825, 0.3443066527448897, 0.3685290840529194, 0.33300746653818236, 0.344756952919426, 0.3589637347832446, 0.3847285223584924, 0.35563251038077315, 0.33780521335117053, 0.64880351768675, 0.6231029426067937, 0.5903615242202711, 0.6397946976405042, 0.6179465054118085, 0.7735312600875053, 0.6254499740284423, 0.5934217543405529, 0.6755280449463665, 0.28734174886721964, 0.21346798216590346, 0.26802855920151436, 0.25714336811261596, 0.24572479336521313, 0.22435431111607995, 0.19552624844340594, 0.23813186118774454, 0.2676030959988437, 0.23433618635013886, 0.2788460249536484, 0.23623964016399934, 0.24944108357322825, 0.279152616643881, 0.21841435033131051, 0.2819708674826541, 0.23264406052992992, 0.32868414971706106, 0.15724258538287084, 0.1650708518026175, 0.1651397963465352, 0.149626801010589, 0.16906509909561196, 0.15343682365566713, 0.15618246079006237, 0.15264701128265112, 0.12397414593356915, 0.2635313820656726, 0.2466011585858785, 0.29323163700690946, 0.24535580972977422, 0.2659376431279138, 0.21806642721554736, 0.3141828474042305, 0.2913059432149867, 0.27523102455918846, 0.02721817256180914, 0.03392542865417547, 0.04938900508283839, 0.06184619874853048, 0.053995924258037675, 0.03758544647001849, 0.05804756187789428, 0.026239940920850136, 0.053635887502342716, 0.18173309443537078, 0.17997453518346007, 0.1841956860343188, 0.17432532212798946, 0.1927774094827811, 0.1974587843334219, 0.1483164052812912, 0.1706601747699571, 0.19035441379470108, 0.5096689204832121, 0.5399651748319467, 0.5535829910622567, 0.5222679559371944, 0.5239022291868808, 0.5264686787329551, 0.5598154311741934, 0.5247219953842206, 0.533582520906724, 0.08300215416420287, 0.1119669045423658, 0.11248044287164272, 0.09820448822780581, 0.09981636623294232, 0.10141321817073645, 0.09596059733237183, 0.09402145277407581, 0.11246847380050118, 0.32580697284447646, 0.2793176197363758, 0.25118027117997777, 0.19070883555287754, 0.4466920401812695, 0.3167468144671651, 0.19113276587831185, 0.3263984395572662, 0.18112259392959085, 0.32798473898395064, 0.3256160113195703, 0.3255108132650957, 0.3034571928911659, 0.30324182407153377, 0.3293706584713001, 0.31104035585309153, 0.32721389175597315, 0.33765278472284554, 0.23221240325567327, 0.22743437898703311, 0.2580245687560373, 0.23761346541767225, 0.2526630629536373, 0.2464627741643871, 0.26017134123855945, 0.25204575403297924, 0.26077524639507266, 0.20359372218472416, 0.1690353948812332, 0.21646412327277909, 0.17899206938498935, 0.19466771484789658, 0.1934032234491141, 0.18511368523571115, 0.18378723514839646, 0.1974796708356843, 0.1852603313315475, 0.1764048375311037, 0.18065580813172433, 0.21778487754158227, 0.21361171702164994, 0.17397009739185154, 0.17723444901412078, 0.19230547844545454, 0.20910176002327718, 0.8479690485678032, 0.7871870697600027, 0.7808572344312197, 0.7938196608275232, 0.2005113984054585, 0.19800154435886996, 0.14244843972504606, 0.1644798868939703, 0.15788428259051202, 0.777871469564005, 0.21084127825819143, 0.7219118074846282, 0.7273622593942701, 0.16648690217043627, 0.7058124870825896, 0.15661423488416726, 0.2081968809489515, 0.15480599309729626, 0.17524795237208723, 0.17434266699658474, 0.2044190521979472, 0.1856036046416113, 0.17586605765972563, 0.18654743077411773, 0.19080899470257384, 0.17081092954037302, 0.18376650975994058, 0.08517472335019338, 0.08131577760077213, 0.08167978700724887, 0.07521818256019919, 0.07255056182899589, 0.08002976207064294, 0.08269023233599293, 0.08556902933963251, 0.08173529094159315]}, "mutation_prompt": null}
{"id": "4ea725b1-fc5f-4923-b623-817366c5a5d7", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.8):\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def adaptive_random_search(self):\n        # Introduce a simple random perturbation around the global best for exploration\n        perturbation = np.random.uniform(-0.5, 0.5, self.dim)\n        candidate = np.clip(self.population[self.global_best] + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.1:  # 10% chance to use adaptive random search\n                    trial = self.adaptive_random_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n                \n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.fitness[self.global_best]:\n                        self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridDifferentialEvolution", "description": "Hybrid Differential Evolution with Adaptive Random Search to enhance exploration and exploitation balance for faster convergence.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "59daa2a0-f16e-4aa6-90a0-467962392d25", "metadata": {"aucs": [0.6632627818289437, 0.6922600076938976, 0.6727474769545064, 0.6831793781364897, 0.6931864228567788, 0.7112704654163935, 0.6762788735227594, 0.6877669403831868, 0.6881332008922942, 0.3642917767817637, 0.3319488004055168, 0.3635178469066336, 0.3441238789552844, 0.3664673752841705, 0.3771244072890061, 0.36577110996151285, 0.3684543166503771, 0.37535223784159333, 0.11144604164629257, 0.12365291414215185, 0.12611498569300805, 0.12085868575135938, 0.10791295181524418, 0.1007331743003842, 0.11031540114354843, 0.11535575912300122, 0.1308043805093726, 0.1064966168822471, 0.10422564366673936, 0.11524729307407255, 0.10011327340048104, 0.09261783019145298, 0.09055337610988445, 0.09627502265863819, 0.1046658881573308, 0.09313518313064473, 0.972225768001981, 0.9792281766191235, 0.9843426728302413, 0.9455856430166695, 0.9526355388353679, 0.954814718802366, 0.9788163534665784, 0.9669919479112222, 0.9671258974813884, 0.34503321716428825, 0.3443066527448897, 0.3685290840529194, 0.33300746653818236, 0.344756952919426, 0.3589637347832446, 0.3847285223584924, 0.35563251038077315, 0.33780521335117053, 0.64880351768675, 0.6231029426067937, 0.5903615242202711, 0.6397946976405042, 0.6179465054118085, 0.7735312600875053, 0.6254499740284423, 0.5934217543405529, 0.6755280449463665, 0.28734174886721964, 0.21346798216590346, 0.26802855920151436, 0.25714336811261596, 0.24572479336521313, 0.22435431111607995, 0.19552624844340594, 0.23813186118774454, 0.2676030959988437, 0.23433618635013886, 0.2788460249536484, 0.23623964016399934, 0.24944108357322825, 0.279152616643881, 0.21841435033131051, 0.2819708674826541, 0.23264406052992992, 0.32868414971706106, 0.15724258538287084, 0.1650708518026175, 0.1651397963465352, 0.149626801010589, 0.16906509909561196, 0.15343682365566713, 0.15618246079006237, 0.15264701128265112, 0.12397414593356915, 0.2635313820656726, 0.2466011585858785, 0.29323163700690946, 0.24535580972977422, 0.2659376431279138, 0.21806642721554736, 0.3141828474042305, 0.2913059432149867, 0.27523102455918846, 0.02721817256180914, 0.03392542865417547, 0.04938900508283839, 0.06184619874853048, 0.053995924258037675, 0.03758544647001849, 0.05804756187789428, 0.026239940920850136, 0.053635887502342716, 0.18173309443537078, 0.17997453518346007, 0.1841956860343188, 0.17432532212798946, 0.1927774094827811, 0.1974587843334219, 0.1483164052812912, 0.1706601747699571, 0.19035441379470108, 0.5096689204832121, 0.5399651748319467, 0.5535829910622567, 0.5222679559371944, 0.5239022291868808, 0.5264686787329551, 0.5598154311741934, 0.5247219953842206, 0.533582520906724, 0.08300215416420287, 0.1119669045423658, 0.11248044287164272, 0.09820448822780581, 0.09981636623294232, 0.10141321817073645, 0.09596059733237183, 0.09402145277407581, 0.11246847380050118, 0.32580697284447646, 0.2793176197363758, 0.25118027117997777, 0.19070883555287754, 0.4466920401812695, 0.3167468144671651, 0.19113276587831185, 0.3263984395572662, 0.18112259392959085, 0.32798473898395064, 0.3256160113195703, 0.3255108132650957, 0.3034571928911659, 0.30324182407153377, 0.3293706584713001, 0.31104035585309153, 0.32721389175597315, 0.33765278472284554, 0.23221240325567327, 0.22743437898703311, 0.2580245687560373, 0.23761346541767225, 0.2526630629536373, 0.2464627741643871, 0.26017134123855945, 0.25204575403297924, 0.26077524639507266, 0.20359372218472416, 0.1690353948812332, 0.21646412327277909, 0.17899206938498935, 0.19466771484789658, 0.1934032234491141, 0.18511368523571115, 0.18378723514839646, 0.1974796708356843, 0.1852603313315475, 0.1764048375311037, 0.18065580813172433, 0.21778487754158227, 0.21361171702164994, 0.17397009739185154, 0.17723444901412078, 0.19230547844545454, 0.20910176002327718, 0.8479690485678032, 0.7871870697600027, 0.7808572344312197, 0.7938196608275232, 0.2005113984054585, 0.19800154435886996, 0.14244843972504606, 0.1644798868939703, 0.15788428259051202, 0.777871469564005, 0.21084127825819143, 0.7219118074846282, 0.7273622593942701, 0.16648690217043627, 0.7058124870825896, 0.15661423488416726, 0.2081968809489515, 0.15480599309729626, 0.17524795237208723, 0.17434266699658474, 0.2044190521979472, 0.1856036046416113, 0.17586605765972563, 0.18654743077411773, 0.19080899470257384, 0.17081092954037302, 0.18376650975994058, 0.08517472335019338, 0.08131577760077213, 0.08167978700724887, 0.07521818256019919, 0.07255056182899589, 0.08002976207064294, 0.08269023233599293, 0.08556902933963251, 0.08173529094159315]}, "mutation_prompt": null}
{"id": "b3ad052f-3fa3-4517-b3fb-3bd37a630618", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.8):\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def adaptive_random_search(self):\n        # Introduce a simple random perturbation around the global best for exploration\n        perturbation = np.random.uniform(-0.5, 0.5, self.dim)\n        candidate = np.clip(self.population[self.global_best] + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.1:  # 10% chance to use adaptive random search\n                    trial = self.adaptive_random_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n                \n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.fitness[self.global_best]:\n                        self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridDifferentialEvolution", "description": "Hybrid Differential Evolution with Adaptive Random Search to enhance exploration and exploitation balance for faster convergence.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "59daa2a0-f16e-4aa6-90a0-467962392d25", "metadata": {"aucs": [0.6632627818289437, 0.6922600076938976, 0.6727474769545064, 0.6831793781364897, 0.6931864228567788, 0.7112704654163935, 0.6762788735227594, 0.6877669403831868, 0.6881332008922942, 0.3642917767817637, 0.3319488004055168, 0.3635178469066336, 0.3441238789552844, 0.3664673752841705, 0.3771244072890061, 0.36577110996151285, 0.3684543166503771, 0.37535223784159333, 0.11144604164629257, 0.12365291414215185, 0.12611498569300805, 0.12085868575135938, 0.10791295181524418, 0.1007331743003842, 0.11031540114354843, 0.11535575912300122, 0.1308043805093726, 0.1064966168822471, 0.10422564366673936, 0.11524729307407255, 0.10011327340048104, 0.09261783019145298, 0.09055337610988445, 0.09627502265863819, 0.1046658881573308, 0.09313518313064473, 0.972225768001981, 0.9792281766191235, 0.9843426728302413, 0.9455856430166695, 0.9526355388353679, 0.954814718802366, 0.9788163534665784, 0.9669919479112222, 0.9671258974813884, 0.34503321716428825, 0.3443066527448897, 0.3685290840529194, 0.33300746653818236, 0.344756952919426, 0.3589637347832446, 0.3847285223584924, 0.35563251038077315, 0.33780521335117053, 0.64880351768675, 0.6231029426067937, 0.5903615242202711, 0.6397946976405042, 0.6179465054118085, 0.7735312600875053, 0.6254499740284423, 0.5934217543405529, 0.6755280449463665, 0.28734174886721964, 0.21346798216590346, 0.26802855920151436, 0.25714336811261596, 0.24572479336521313, 0.22435431111607995, 0.19552624844340594, 0.23813186118774454, 0.2676030959988437, 0.23433618635013886, 0.2788460249536484, 0.23623964016399934, 0.24944108357322825, 0.279152616643881, 0.21841435033131051, 0.2819708674826541, 0.23264406052992992, 0.32868414971706106, 0.15724258538287084, 0.1650708518026175, 0.1651397963465352, 0.149626801010589, 0.16906509909561196, 0.15343682365566713, 0.15618246079006237, 0.15264701128265112, 0.12397414593356915, 0.2635313820656726, 0.2466011585858785, 0.29323163700690946, 0.24535580972977422, 0.2659376431279138, 0.21806642721554736, 0.3141828474042305, 0.2913059432149867, 0.27523102455918846, 0.02721817256180914, 0.03392542865417547, 0.04938900508283839, 0.06184619874853048, 0.053995924258037675, 0.03758544647001849, 0.05804756187789428, 0.026239940920850136, 0.053635887502342716, 0.18173309443537078, 0.17997453518346007, 0.1841956860343188, 0.17432532212798946, 0.1927774094827811, 0.1974587843334219, 0.1483164052812912, 0.1706601747699571, 0.19035441379470108, 0.5096689204832121, 0.5399651748319467, 0.5535829910622567, 0.5222679559371944, 0.5239022291868808, 0.5264686787329551, 0.5598154311741934, 0.5247219953842206, 0.533582520906724, 0.08300215416420287, 0.1119669045423658, 0.11248044287164272, 0.09820448822780581, 0.09981636623294232, 0.10141321817073645, 0.09596059733237183, 0.09402145277407581, 0.11246847380050118, 0.32580697284447646, 0.2793176197363758, 0.25118027117997777, 0.19070883555287754, 0.4466920401812695, 0.3167468144671651, 0.19113276587831185, 0.3263984395572662, 0.18112259392959085, 0.32798473898395064, 0.3256160113195703, 0.3255108132650957, 0.3034571928911659, 0.30324182407153377, 0.3293706584713001, 0.31104035585309153, 0.32721389175597315, 0.33765278472284554, 0.23221240325567327, 0.22743437898703311, 0.2580245687560373, 0.23761346541767225, 0.2526630629536373, 0.2464627741643871, 0.26017134123855945, 0.25204575403297924, 0.26077524639507266, 0.20359372218472416, 0.1690353948812332, 0.21646412327277909, 0.17899206938498935, 0.19466771484789658, 0.1934032234491141, 0.18511368523571115, 0.18378723514839646, 0.1974796708356843, 0.1852603313315475, 0.1764048375311037, 0.18065580813172433, 0.21778487754158227, 0.21361171702164994, 0.17397009739185154, 0.17723444901412078, 0.19230547844545454, 0.20910176002327718, 0.8479690485678032, 0.7871870697600027, 0.7808572344312197, 0.7938196608275232, 0.2005113984054585, 0.19800154435886996, 0.14244843972504606, 0.1644798868939703, 0.15788428259051202, 0.777871469564005, 0.21084127825819143, 0.7219118074846282, 0.7273622593942701, 0.16648690217043627, 0.7058124870825896, 0.15661423488416726, 0.2081968809489515, 0.15480599309729626, 0.17524795237208723, 0.17434266699658474, 0.2044190521979472, 0.1856036046416113, 0.17586605765972563, 0.18654743077411773, 0.19080899470257384, 0.17081092954037302, 0.18376650975994058, 0.08517472335019338, 0.08131577760077213, 0.08167978700724887, 0.07521818256019919, 0.07255056182899589, 0.08002976207064294, 0.08269023233599293, 0.08556902933963251, 0.08173529094159315]}, "mutation_prompt": null}
{"id": "a580d186-d5a9-463a-92ac-58e2bf67566b", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.8):\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def adaptive_random_search(self):\n        # Introduce a simple random perturbation around the global best for exploration\n        perturbation = np.random.uniform(-0.5, 0.5, self.dim)\n        candidate = np.clip(self.population[self.global_best] + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.1:  # 10% chance to use adaptive random search\n                    trial = self.adaptive_random_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n                \n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.fitness[self.global_best]:\n                        self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridDifferentialEvolution", "description": "Hybrid Differential Evolution with Adaptive Random Search to enhance exploration and exploitation balance for faster convergence.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "59daa2a0-f16e-4aa6-90a0-467962392d25", "metadata": {"aucs": [0.6632627818289437, 0.6922600076938976, 0.6727474769545064, 0.6831793781364897, 0.6931864228567788, 0.7112704654163935, 0.6762788735227594, 0.6877669403831868, 0.6881332008922942, 0.3642917767817637, 0.3319488004055168, 0.3635178469066336, 0.3441238789552844, 0.3664673752841705, 0.3771244072890061, 0.36577110996151285, 0.3684543166503771, 0.37535223784159333, 0.11144604164629257, 0.12365291414215185, 0.12611498569300805, 0.12085868575135938, 0.10791295181524418, 0.1007331743003842, 0.11031540114354843, 0.11535575912300122, 0.1308043805093726, 0.1064966168822471, 0.10422564366673936, 0.11524729307407255, 0.10011327340048104, 0.09261783019145298, 0.09055337610988445, 0.09627502265863819, 0.1046658881573308, 0.09313518313064473, 0.972225768001981, 0.9792281766191235, 0.9843426728302413, 0.9455856430166695, 0.9526355388353679, 0.954814718802366, 0.9788163534665784, 0.9669919479112222, 0.9671258974813884, 0.34503321716428825, 0.3443066527448897, 0.3685290840529194, 0.33300746653818236, 0.344756952919426, 0.3589637347832446, 0.3847285223584924, 0.35563251038077315, 0.33780521335117053, 0.64880351768675, 0.6231029426067937, 0.5903615242202711, 0.6397946976405042, 0.6179465054118085, 0.7735312600875053, 0.6254499740284423, 0.5934217543405529, 0.6755280449463665, 0.28734174886721964, 0.21346798216590346, 0.26802855920151436, 0.25714336811261596, 0.24572479336521313, 0.22435431111607995, 0.19552624844340594, 0.23813186118774454, 0.2676030959988437, 0.23433618635013886, 0.2788460249536484, 0.23623964016399934, 0.24944108357322825, 0.279152616643881, 0.21841435033131051, 0.2819708674826541, 0.23264406052992992, 0.32868414971706106, 0.15724258538287084, 0.1650708518026175, 0.1651397963465352, 0.149626801010589, 0.16906509909561196, 0.15343682365566713, 0.15618246079006237, 0.15264701128265112, 0.12397414593356915, 0.2635313820656726, 0.2466011585858785, 0.29323163700690946, 0.24535580972977422, 0.2659376431279138, 0.21806642721554736, 0.3141828474042305, 0.2913059432149867, 0.27523102455918846, 0.02721817256180914, 0.03392542865417547, 0.04938900508283839, 0.06184619874853048, 0.053995924258037675, 0.03758544647001849, 0.05804756187789428, 0.026239940920850136, 0.053635887502342716, 0.18173309443537078, 0.17997453518346007, 0.1841956860343188, 0.17432532212798946, 0.1927774094827811, 0.1974587843334219, 0.1483164052812912, 0.1706601747699571, 0.19035441379470108, 0.5096689204832121, 0.5399651748319467, 0.5535829910622567, 0.5222679559371944, 0.5239022291868808, 0.5264686787329551, 0.5598154311741934, 0.5247219953842206, 0.533582520906724, 0.08300215416420287, 0.1119669045423658, 0.11248044287164272, 0.09820448822780581, 0.09981636623294232, 0.10141321817073645, 0.09596059733237183, 0.09402145277407581, 0.11246847380050118, 0.32580697284447646, 0.2793176197363758, 0.25118027117997777, 0.19070883555287754, 0.4466920401812695, 0.3167468144671651, 0.19113276587831185, 0.3263984395572662, 0.18112259392959085, 0.32798473898395064, 0.3256160113195703, 0.3255108132650957, 0.3034571928911659, 0.30324182407153377, 0.3293706584713001, 0.31104035585309153, 0.32721389175597315, 0.33765278472284554, 0.23221240325567327, 0.22743437898703311, 0.2580245687560373, 0.23761346541767225, 0.2526630629536373, 0.2464627741643871, 0.26017134123855945, 0.25204575403297924, 0.26077524639507266, 0.20359372218472416, 0.1690353948812332, 0.21646412327277909, 0.17899206938498935, 0.19466771484789658, 0.1934032234491141, 0.18511368523571115, 0.18378723514839646, 0.1974796708356843, 0.1852603313315475, 0.1764048375311037, 0.18065580813172433, 0.21778487754158227, 0.21361171702164994, 0.17397009739185154, 0.17723444901412078, 0.19230547844545454, 0.20910176002327718, 0.8479690485678032, 0.7871870697600027, 0.7808572344312197, 0.7938196608275232, 0.2005113984054585, 0.19800154435886996, 0.14244843972504606, 0.1644798868939703, 0.15788428259051202, 0.777871469564005, 0.21084127825819143, 0.7219118074846282, 0.7273622593942701, 0.16648690217043627, 0.7058124870825896, 0.15661423488416726, 0.2081968809489515, 0.15480599309729626, 0.17524795237208723, 0.17434266699658474, 0.2044190521979472, 0.1856036046416113, 0.17586605765972563, 0.18654743077411773, 0.19080899470257384, 0.17081092954037302, 0.18376650975994058, 0.08517472335019338, 0.08131577760077213, 0.08167978700724887, 0.07521818256019919, 0.07255056182899589, 0.08002976207064294, 0.08269023233599293, 0.08556902933963251, 0.08173529094159315]}, "mutation_prompt": null}
{"id": "7d1c305b-dab3-488a-869e-1a7695b5761b", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.8):\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def adaptive_random_search(self):\n        # Introduce a simple random perturbation around the global best for exploration\n        perturbation = np.random.uniform(-0.5, 0.5, self.dim)\n        candidate = np.clip(self.population[self.global_best] + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.1:  # 10% chance to use adaptive random search\n                    trial = self.adaptive_random_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n                \n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.fitness[self.global_best]:\n                        self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridDifferentialEvolution", "description": "Hybrid Differential Evolution with Adaptive Random Search to enhance exploration and exploitation balance for faster convergence.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "59daa2a0-f16e-4aa6-90a0-467962392d25", "metadata": {"aucs": [0.6632627818289437, 0.6922600076938976, 0.6727474769545064, 0.6831793781364897, 0.6931864228567788, 0.7112704654163935, 0.6762788735227594, 0.6877669403831868, 0.6881332008922942, 0.3642917767817637, 0.3319488004055168, 0.3635178469066336, 0.3441238789552844, 0.3664673752841705, 0.3771244072890061, 0.36577110996151285, 0.3684543166503771, 0.37535223784159333, 0.11144604164629257, 0.12365291414215185, 0.12611498569300805, 0.12085868575135938, 0.10791295181524418, 0.1007331743003842, 0.11031540114354843, 0.11535575912300122, 0.1308043805093726, 0.1064966168822471, 0.10422564366673936, 0.11524729307407255, 0.10011327340048104, 0.09261783019145298, 0.09055337610988445, 0.09627502265863819, 0.1046658881573308, 0.09313518313064473, 0.972225768001981, 0.9792281766191235, 0.9843426728302413, 0.9455856430166695, 0.9526355388353679, 0.954814718802366, 0.9788163534665784, 0.9669919479112222, 0.9671258974813884, 0.34503321716428825, 0.3443066527448897, 0.3685290840529194, 0.33300746653818236, 0.344756952919426, 0.3589637347832446, 0.3847285223584924, 0.35563251038077315, 0.33780521335117053, 0.64880351768675, 0.6231029426067937, 0.5903615242202711, 0.6397946976405042, 0.6179465054118085, 0.7735312600875053, 0.6254499740284423, 0.5934217543405529, 0.6755280449463665, 0.28734174886721964, 0.21346798216590346, 0.26802855920151436, 0.25714336811261596, 0.24572479336521313, 0.22435431111607995, 0.19552624844340594, 0.23813186118774454, 0.2676030959988437, 0.23433618635013886, 0.2788460249536484, 0.23623964016399934, 0.24944108357322825, 0.279152616643881, 0.21841435033131051, 0.2819708674826541, 0.23264406052992992, 0.32868414971706106, 0.15724258538287084, 0.1650708518026175, 0.1651397963465352, 0.149626801010589, 0.16906509909561196, 0.15343682365566713, 0.15618246079006237, 0.15264701128265112, 0.12397414593356915, 0.2635313820656726, 0.2466011585858785, 0.29323163700690946, 0.24535580972977422, 0.2659376431279138, 0.21806642721554736, 0.3141828474042305, 0.2913059432149867, 0.27523102455918846, 0.02721817256180914, 0.03392542865417547, 0.04938900508283839, 0.06184619874853048, 0.053995924258037675, 0.03758544647001849, 0.05804756187789428, 0.026239940920850136, 0.053635887502342716, 0.18173309443537078, 0.17997453518346007, 0.1841956860343188, 0.17432532212798946, 0.1927774094827811, 0.1974587843334219, 0.1483164052812912, 0.1706601747699571, 0.19035441379470108, 0.5096689204832121, 0.5399651748319467, 0.5535829910622567, 0.5222679559371944, 0.5239022291868808, 0.5264686787329551, 0.5598154311741934, 0.5247219953842206, 0.533582520906724, 0.08300215416420287, 0.1119669045423658, 0.11248044287164272, 0.09820448822780581, 0.09981636623294232, 0.10141321817073645, 0.09596059733237183, 0.09402145277407581, 0.11246847380050118, 0.32580697284447646, 0.2793176197363758, 0.25118027117997777, 0.19070883555287754, 0.4466920401812695, 0.3167468144671651, 0.19113276587831185, 0.3263984395572662, 0.18112259392959085, 0.32798473898395064, 0.3256160113195703, 0.3255108132650957, 0.3034571928911659, 0.30324182407153377, 0.3293706584713001, 0.31104035585309153, 0.32721389175597315, 0.33765278472284554, 0.23221240325567327, 0.22743437898703311, 0.2580245687560373, 0.23761346541767225, 0.2526630629536373, 0.2464627741643871, 0.26017134123855945, 0.25204575403297924, 0.26077524639507266, 0.20359372218472416, 0.1690353948812332, 0.21646412327277909, 0.17899206938498935, 0.19466771484789658, 0.1934032234491141, 0.18511368523571115, 0.18378723514839646, 0.1974796708356843, 0.1852603313315475, 0.1764048375311037, 0.18065580813172433, 0.21778487754158227, 0.21361171702164994, 0.17397009739185154, 0.17723444901412078, 0.19230547844545454, 0.20910176002327718, 0.8479690485678032, 0.7871870697600027, 0.7808572344312197, 0.7938196608275232, 0.2005113984054585, 0.19800154435886996, 0.14244843972504606, 0.1644798868939703, 0.15788428259051202, 0.777871469564005, 0.21084127825819143, 0.7219118074846282, 0.7273622593942701, 0.16648690217043627, 0.7058124870825896, 0.15661423488416726, 0.2081968809489515, 0.15480599309729626, 0.17524795237208723, 0.17434266699658474, 0.2044190521979472, 0.1856036046416113, 0.17586605765972563, 0.18654743077411773, 0.19080899470257384, 0.17081092954037302, 0.18376650975994058, 0.08517472335019338, 0.08131577760077213, 0.08167978700724887, 0.07521818256019919, 0.07255056182899589, 0.08002976207064294, 0.08269023233599293, 0.08556902933963251, 0.08173529094159315]}, "mutation_prompt": null}
{"id": "18264aae-58f8-4922-bab9-af1c93f96353", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.8):\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def adaptive_random_search(self):\n        # Introduce a simple random perturbation around the global best for exploration\n        perturbation = np.random.uniform(-0.5, 0.5, self.dim)\n        candidate = np.clip(self.population[self.global_best] + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.1:  # 10% chance to use adaptive random search\n                    trial = self.adaptive_random_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n                \n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.fitness[self.global_best]:\n                        self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridDifferentialEvolution", "description": "Hybrid Differential Evolution with Adaptive Random Search to enhance exploration and exploitation balance for faster convergence.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "59daa2a0-f16e-4aa6-90a0-467962392d25", "metadata": {"aucs": [0.6632627818289437, 0.6922600076938976, 0.6727474769545064, 0.6831793781364897, 0.6931864228567788, 0.7112704654163935, 0.6762788735227594, 0.6877669403831868, 0.6881332008922942, 0.3642917767817637, 0.3319488004055168, 0.3635178469066336, 0.3441238789552844, 0.3664673752841705, 0.3771244072890061, 0.36577110996151285, 0.3684543166503771, 0.37535223784159333, 0.11144604164629257, 0.12365291414215185, 0.12611498569300805, 0.12085868575135938, 0.10791295181524418, 0.1007331743003842, 0.11031540114354843, 0.11535575912300122, 0.1308043805093726, 0.1064966168822471, 0.10422564366673936, 0.11524729307407255, 0.10011327340048104, 0.09261783019145298, 0.09055337610988445, 0.09627502265863819, 0.1046658881573308, 0.09313518313064473, 0.972225768001981, 0.9792281766191235, 0.9843426728302413, 0.9455856430166695, 0.9526355388353679, 0.954814718802366, 0.9788163534665784, 0.9669919479112222, 0.9671258974813884, 0.34503321716428825, 0.3443066527448897, 0.3685290840529194, 0.33300746653818236, 0.344756952919426, 0.3589637347832446, 0.3847285223584924, 0.35563251038077315, 0.33780521335117053, 0.64880351768675, 0.6231029426067937, 0.5903615242202711, 0.6397946976405042, 0.6179465054118085, 0.7735312600875053, 0.6254499740284423, 0.5934217543405529, 0.6755280449463665, 0.28734174886721964, 0.21346798216590346, 0.26802855920151436, 0.25714336811261596, 0.24572479336521313, 0.22435431111607995, 0.19552624844340594, 0.23813186118774454, 0.2676030959988437, 0.23433618635013886, 0.2788460249536484, 0.23623964016399934, 0.24944108357322825, 0.279152616643881, 0.21841435033131051, 0.2819708674826541, 0.23264406052992992, 0.32868414971706106, 0.15724258538287084, 0.1650708518026175, 0.1651397963465352, 0.149626801010589, 0.16906509909561196, 0.15343682365566713, 0.15618246079006237, 0.15264701128265112, 0.12397414593356915, 0.2635313820656726, 0.2466011585858785, 0.29323163700690946, 0.24535580972977422, 0.2659376431279138, 0.21806642721554736, 0.3141828474042305, 0.2913059432149867, 0.27523102455918846, 0.02721817256180914, 0.03392542865417547, 0.04938900508283839, 0.06184619874853048, 0.053995924258037675, 0.03758544647001849, 0.05804756187789428, 0.026239940920850136, 0.053635887502342716, 0.18173309443537078, 0.17997453518346007, 0.1841956860343188, 0.17432532212798946, 0.1927774094827811, 0.1974587843334219, 0.1483164052812912, 0.1706601747699571, 0.19035441379470108, 0.5096689204832121, 0.5399651748319467, 0.5535829910622567, 0.5222679559371944, 0.5239022291868808, 0.5264686787329551, 0.5598154311741934, 0.5247219953842206, 0.533582520906724, 0.08300215416420287, 0.1119669045423658, 0.11248044287164272, 0.09820448822780581, 0.09981636623294232, 0.10141321817073645, 0.09596059733237183, 0.09402145277407581, 0.11246847380050118, 0.32580697284447646, 0.2793176197363758, 0.25118027117997777, 0.19070883555287754, 0.4466920401812695, 0.3167468144671651, 0.19113276587831185, 0.3263984395572662, 0.18112259392959085, 0.32798473898395064, 0.3256160113195703, 0.3255108132650957, 0.3034571928911659, 0.30324182407153377, 0.3293706584713001, 0.31104035585309153, 0.32721389175597315, 0.33765278472284554, 0.23221240325567327, 0.22743437898703311, 0.2580245687560373, 0.23761346541767225, 0.2526630629536373, 0.2464627741643871, 0.26017134123855945, 0.25204575403297924, 0.26077524639507266, 0.20359372218472416, 0.1690353948812332, 0.21646412327277909, 0.17899206938498935, 0.19466771484789658, 0.1934032234491141, 0.18511368523571115, 0.18378723514839646, 0.1974796708356843, 0.1852603313315475, 0.1764048375311037, 0.18065580813172433, 0.21778487754158227, 0.21361171702164994, 0.17397009739185154, 0.17723444901412078, 0.19230547844545454, 0.20910176002327718, 0.8479690485678032, 0.7871870697600027, 0.7808572344312197, 0.7938196608275232, 0.2005113984054585, 0.19800154435886996, 0.14244843972504606, 0.1644798868939703, 0.15788428259051202, 0.777871469564005, 0.21084127825819143, 0.7219118074846282, 0.7273622593942701, 0.16648690217043627, 0.7058124870825896, 0.15661423488416726, 0.2081968809489515, 0.15480599309729626, 0.17524795237208723, 0.17434266699658474, 0.2044190521979472, 0.1856036046416113, 0.17586605765972563, 0.18654743077411773, 0.19080899470257384, 0.17081092954037302, 0.18376650975994058, 0.08517472335019338, 0.08131577760077213, 0.08167978700724887, 0.07521818256019919, 0.07255056182899589, 0.08002976207064294, 0.08269023233599293, 0.08556902933963251, 0.08173529094159315]}, "mutation_prompt": null}
{"id": "5ffca867-67f6-4b1b-b6e8-1e56a0b12cc2", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.8):\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def adaptive_random_search(self):\n        # Introduce a simple random perturbation around the global best for exploration\n        perturbation = np.random.uniform(-0.5, 0.5, self.dim)\n        candidate = np.clip(self.population[self.global_best] + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.1:  # 10% chance to use adaptive random search\n                    trial = self.adaptive_random_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n                \n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.fitness[self.global_best]:\n                        self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridDifferentialEvolution", "description": "Hybrid Differential Evolution with Adaptive Random Search to enhance exploration and exploitation balance for faster convergence.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "59daa2a0-f16e-4aa6-90a0-467962392d25", "metadata": {"aucs": [0.6632627818289437, 0.6922600076938976, 0.6727474769545064, 0.6831793781364897, 0.6931864228567788, 0.7112704654163935, 0.6762788735227594, 0.6877669403831868, 0.6881332008922942, 0.3642917767817637, 0.3319488004055168, 0.3635178469066336, 0.3441238789552844, 0.3664673752841705, 0.3771244072890061, 0.36577110996151285, 0.3684543166503771, 0.37535223784159333, 0.11144604164629257, 0.12365291414215185, 0.12611498569300805, 0.12085868575135938, 0.10791295181524418, 0.1007331743003842, 0.11031540114354843, 0.11535575912300122, 0.1308043805093726, 0.1064966168822471, 0.10422564366673936, 0.11524729307407255, 0.10011327340048104, 0.09261783019145298, 0.09055337610988445, 0.09627502265863819, 0.1046658881573308, 0.09313518313064473, 0.972225768001981, 0.9792281766191235, 0.9843426728302413, 0.9455856430166695, 0.9526355388353679, 0.954814718802366, 0.9788163534665784, 0.9669919479112222, 0.9671258974813884, 0.34503321716428825, 0.3443066527448897, 0.3685290840529194, 0.33300746653818236, 0.344756952919426, 0.3589637347832446, 0.3847285223584924, 0.35563251038077315, 0.33780521335117053, 0.64880351768675, 0.6231029426067937, 0.5903615242202711, 0.6397946976405042, 0.6179465054118085, 0.7735312600875053, 0.6254499740284423, 0.5934217543405529, 0.6755280449463665, 0.28734174886721964, 0.21346798216590346, 0.26802855920151436, 0.25714336811261596, 0.24572479336521313, 0.22435431111607995, 0.19552624844340594, 0.23813186118774454, 0.2676030959988437, 0.23433618635013886, 0.2788460249536484, 0.23623964016399934, 0.24944108357322825, 0.279152616643881, 0.21841435033131051, 0.2819708674826541, 0.23264406052992992, 0.32868414971706106, 0.15724258538287084, 0.1650708518026175, 0.1651397963465352, 0.149626801010589, 0.16906509909561196, 0.15343682365566713, 0.15618246079006237, 0.15264701128265112, 0.12397414593356915, 0.2635313820656726, 0.2466011585858785, 0.29323163700690946, 0.24535580972977422, 0.2659376431279138, 0.21806642721554736, 0.3141828474042305, 0.2913059432149867, 0.27523102455918846, 0.02721817256180914, 0.03392542865417547, 0.04938900508283839, 0.06184619874853048, 0.053995924258037675, 0.03758544647001849, 0.05804756187789428, 0.026239940920850136, 0.053635887502342716, 0.18173309443537078, 0.17997453518346007, 0.1841956860343188, 0.17432532212798946, 0.1927774094827811, 0.1974587843334219, 0.1483164052812912, 0.1706601747699571, 0.19035441379470108, 0.5096689204832121, 0.5399651748319467, 0.5535829910622567, 0.5222679559371944, 0.5239022291868808, 0.5264686787329551, 0.5598154311741934, 0.5247219953842206, 0.533582520906724, 0.08300215416420287, 0.1119669045423658, 0.11248044287164272, 0.09820448822780581, 0.09981636623294232, 0.10141321817073645, 0.09596059733237183, 0.09402145277407581, 0.11246847380050118, 0.32580697284447646, 0.2793176197363758, 0.25118027117997777, 0.19070883555287754, 0.4466920401812695, 0.3167468144671651, 0.19113276587831185, 0.3263984395572662, 0.18112259392959085, 0.32798473898395064, 0.3256160113195703, 0.3255108132650957, 0.3034571928911659, 0.30324182407153377, 0.3293706584713001, 0.31104035585309153, 0.32721389175597315, 0.33765278472284554, 0.23221240325567327, 0.22743437898703311, 0.2580245687560373, 0.23761346541767225, 0.2526630629536373, 0.2464627741643871, 0.26017134123855945, 0.25204575403297924, 0.26077524639507266, 0.20359372218472416, 0.1690353948812332, 0.21646412327277909, 0.17899206938498935, 0.19466771484789658, 0.1934032234491141, 0.18511368523571115, 0.18378723514839646, 0.1974796708356843, 0.1852603313315475, 0.1764048375311037, 0.18065580813172433, 0.21778487754158227, 0.21361171702164994, 0.17397009739185154, 0.17723444901412078, 0.19230547844545454, 0.20910176002327718, 0.8479690485678032, 0.7871870697600027, 0.7808572344312197, 0.7938196608275232, 0.2005113984054585, 0.19800154435886996, 0.14244843972504606, 0.1644798868939703, 0.15788428259051202, 0.777871469564005, 0.21084127825819143, 0.7219118074846282, 0.7273622593942701, 0.16648690217043627, 0.7058124870825896, 0.15661423488416726, 0.2081968809489515, 0.15480599309729626, 0.17524795237208723, 0.17434266699658474, 0.2044190521979472, 0.1856036046416113, 0.17586605765972563, 0.18654743077411773, 0.19080899470257384, 0.17081092954037302, 0.18376650975994058, 0.08517472335019338, 0.08131577760077213, 0.08167978700724887, 0.07521818256019919, 0.07255056182899589, 0.08002976207064294, 0.08269023233599293, 0.08556902933963251, 0.08173529094159315]}, "mutation_prompt": null}
{"id": "819cde62-924d-4f5b-8b2d-091d4c0b2b31", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.8):\n        gradient = (b - c)  # Simplified gradient-like direction\n        mutant = np.clip(a + F * gradient, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def adaptive_random_search(self):\n        perturbation = np.random.uniform(-0.5, 0.5, self.dim)\n        candidate = np.clip(self.population[self.global_best] + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.1:\n                    trial = self.adaptive_random_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)  # Use gradient-informed mutation\n                    trial = self.crossover(target, mutant)\n                \n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.fitness[self.global_best]:\n                        self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with Gradient-Informed Mutation for improved convergence by leveraging gradient information to guide search direction.", "configspace": "", "generation": 16, "fitness": 0.30768011127220307, "feedback": "The algorithm HybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.", "error": "", "parent_id": "59daa2a0-f16e-4aa6-90a0-467962392d25", "metadata": {"aucs": [0.6632627818289437, 0.6922600076938976, 0.6727474769545064, 0.6831793781364897, 0.6931864228567788, 0.7112704654163935, 0.6762788735227594, 0.6877669403831868, 0.6881332008922942, 0.3642917767817637, 0.3319488004055168, 0.3635178469066336, 0.3441238789552844, 0.3664673752841705, 0.3771244072890061, 0.36577110996151285, 0.3684543166503771, 0.37535223784159333, 0.11144604164629257, 0.12365291414215185, 0.12611498569300805, 0.12085868575135938, 0.10791295181524418, 0.1007331743003842, 0.11031540114354843, 0.11535575912300122, 0.1308043805093726, 0.1064966168822471, 0.10422564366673936, 0.11524729307407255, 0.10011327340048104, 0.09261783019145298, 0.09055337610988445, 0.09627502265863819, 0.1046658881573308, 0.09313518313064473, 0.972225768001981, 0.9792281766191235, 0.9843426728302413, 0.9455856430166695, 0.9526355388353679, 0.954814718802366, 0.9788163534665784, 0.9669919479112222, 0.9671258974813884, 0.34503321716428825, 0.3443066527448897, 0.3685290840529194, 0.33300746653818236, 0.344756952919426, 0.3589637347832446, 0.3847285223584924, 0.35563251038077315, 0.33780521335117053, 0.64880351768675, 0.6231029426067937, 0.5903615242202711, 0.6397946976405042, 0.6179465054118085, 0.7735312600875053, 0.6254499740284423, 0.5934217543405529, 0.6755280449463665, 0.28734174886721964, 0.21346798216590346, 0.26802855920151436, 0.25714336811261596, 0.24572479336521313, 0.22435431111607995, 0.19552624844340594, 0.23813186118774454, 0.2676030959988437, 0.23433618635013886, 0.2788460249536484, 0.23623964016399934, 0.24944108357322825, 0.279152616643881, 0.21841435033131051, 0.2819708674826541, 0.23264406052992992, 0.32868414971706106, 0.15724258538287084, 0.1650708518026175, 0.1651397963465352, 0.149626801010589, 0.16906509909561196, 0.15343682365566713, 0.15618246079006237, 0.15264701128265112, 0.12397414593356915, 0.2635313820656726, 0.2466011585858785, 0.29323163700690946, 0.24535580972977422, 0.2659376431279138, 0.21806642721554736, 0.3141828474042305, 0.2913059432149867, 0.27523102455918846, 0.02721817256180914, 0.03392542865417547, 0.04938900508283839, 0.06184619874853048, 0.053995924258037675, 0.03758544647001849, 0.05804756187789428, 0.026239940920850136, 0.053635887502342716, 0.18173309443537078, 0.17997453518346007, 0.1841956860343188, 0.17432532212798946, 0.1927774094827811, 0.1974587843334219, 0.1483164052812912, 0.1706601747699571, 0.19035441379470108, 0.5096689204832121, 0.5399651748319467, 0.5535829910622567, 0.5222679559371944, 0.5239022291868808, 0.5264686787329551, 0.5598154311741934, 0.5247219953842206, 0.533582520906724, 0.08300215416420287, 0.1119669045423658, 0.11248044287164272, 0.09820448822780581, 0.09981636623294232, 0.10141321817073645, 0.09596059733237183, 0.09402145277407581, 0.11246847380050118, 0.32580697284447646, 0.2793176197363758, 0.25118027117997777, 0.19070883555287754, 0.4466920401812695, 0.3167468144671651, 0.19113276587831185, 0.3263984395572662, 0.18112259392959085, 0.32798473898395064, 0.3256160113195703, 0.3255108132650957, 0.3034571928911659, 0.30324182407153377, 0.3293706584713001, 0.31104035585309153, 0.32721389175597315, 0.33765278472284554, 0.23221240325567327, 0.22743437898703311, 0.2580245687560373, 0.23761346541767225, 0.2526630629536373, 0.2464627741643871, 0.26017134123855945, 0.25204575403297924, 0.26077524639507266, 0.20359372218472416, 0.1690353948812332, 0.21646412327277909, 0.17899206938498935, 0.19466771484789658, 0.1934032234491141, 0.18511368523571115, 0.18378723514839646, 0.1974796708356843, 0.1852603313315475, 0.1764048375311037, 0.18065580813172433, 0.21778487754158227, 0.21361171702164994, 0.17397009739185154, 0.17723444901412078, 0.19230547844545454, 0.20910176002327718, 0.8479690485678032, 0.7871870697600027, 0.7808572344312197, 0.7938196608275232, 0.2005113984054585, 0.19800154435886996, 0.14244843972504606, 0.1644798868939703, 0.15788428259051202, 0.777871469564005, 0.21084127825819143, 0.7219118074846282, 0.7273622593942701, 0.16648690217043627, 0.7058124870825896, 0.15661423488416726, 0.2081968809489515, 0.15480599309729626, 0.17524795237208723, 0.17434266699658474, 0.2044190521979472, 0.1856036046416113, 0.17586605765972563, 0.18654743077411773, 0.19080899470257384, 0.17081092954037302, 0.18376650975994058, 0.08517472335019338, 0.08131577760077213, 0.08167978700724887, 0.07521818256019919, 0.07255056182899589, 0.08002976207064294, 0.08269023233599293, 0.08556902933963251, 0.08173529094159315]}, "mutation_prompt": null}
{"id": "2b268939-c96f-4485-a975-48f9e02e965b", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.8):\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def adaptive_random_search(self):\n        # Introduce a simple random perturbation around the global best for exploration\n        perturbation = np.random.uniform(-0.5, 0.5, self.dim)\n        candidate = np.clip(self.population[self.global_best] + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.1:  # 10% chance to use adaptive random search\n                    trial = self.adaptive_random_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n                \n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.fitness[self.global_best]:\n                        self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridDifferentialEvolution", "description": "Hybrid Differential Evolution with Adaptive Random Search to enhance exploration and exploitation balance for faster convergence.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "59daa2a0-f16e-4aa6-90a0-467962392d25", "metadata": {"aucs": [0.6632627818289437, 0.6922600076938976, 0.6727474769545064, 0.6831793781364897, 0.6931864228567788, 0.7112704654163935, 0.6762788735227594, 0.6877669403831868, 0.6881332008922942, 0.3642917767817637, 0.3319488004055168, 0.3635178469066336, 0.3441238789552844, 0.3664673752841705, 0.3771244072890061, 0.36577110996151285, 0.3684543166503771, 0.37535223784159333, 0.11144604164629257, 0.12365291414215185, 0.12611498569300805, 0.12085868575135938, 0.10791295181524418, 0.1007331743003842, 0.11031540114354843, 0.11535575912300122, 0.1308043805093726, 0.1064966168822471, 0.10422564366673936, 0.11524729307407255, 0.10011327340048104, 0.09261783019145298, 0.09055337610988445, 0.09627502265863819, 0.1046658881573308, 0.09313518313064473, 0.972225768001981, 0.9792281766191235, 0.9843426728302413, 0.9455856430166695, 0.9526355388353679, 0.954814718802366, 0.9788163534665784, 0.9669919479112222, 0.9671258974813884, 0.34503321716428825, 0.3443066527448897, 0.3685290840529194, 0.33300746653818236, 0.344756952919426, 0.3589637347832446, 0.3847285223584924, 0.35563251038077315, 0.33780521335117053, 0.64880351768675, 0.6231029426067937, 0.5903615242202711, 0.6397946976405042, 0.6179465054118085, 0.7735312600875053, 0.6254499740284423, 0.5934217543405529, 0.6755280449463665, 0.28734174886721964, 0.21346798216590346, 0.26802855920151436, 0.25714336811261596, 0.24572479336521313, 0.22435431111607995, 0.19552624844340594, 0.23813186118774454, 0.2676030959988437, 0.23433618635013886, 0.2788460249536484, 0.23623964016399934, 0.24944108357322825, 0.279152616643881, 0.21841435033131051, 0.2819708674826541, 0.23264406052992992, 0.32868414971706106, 0.15724258538287084, 0.1650708518026175, 0.1651397963465352, 0.149626801010589, 0.16906509909561196, 0.15343682365566713, 0.15618246079006237, 0.15264701128265112, 0.12397414593356915, 0.2635313820656726, 0.2466011585858785, 0.29323163700690946, 0.24535580972977422, 0.2659376431279138, 0.21806642721554736, 0.3141828474042305, 0.2913059432149867, 0.27523102455918846, 0.02721817256180914, 0.03392542865417547, 0.04938900508283839, 0.06184619874853048, 0.053995924258037675, 0.03758544647001849, 0.05804756187789428, 0.026239940920850136, 0.053635887502342716, 0.18173309443537078, 0.17997453518346007, 0.1841956860343188, 0.17432532212798946, 0.1927774094827811, 0.1974587843334219, 0.1483164052812912, 0.1706601747699571, 0.19035441379470108, 0.5096689204832121, 0.5399651748319467, 0.5535829910622567, 0.5222679559371944, 0.5239022291868808, 0.5264686787329551, 0.5598154311741934, 0.5247219953842206, 0.533582520906724, 0.08300215416420287, 0.1119669045423658, 0.11248044287164272, 0.09820448822780581, 0.09981636623294232, 0.10141321817073645, 0.09596059733237183, 0.09402145277407581, 0.11246847380050118, 0.32580697284447646, 0.2793176197363758, 0.25118027117997777, 0.19070883555287754, 0.4466920401812695, 0.3167468144671651, 0.19113276587831185, 0.3263984395572662, 0.18112259392959085, 0.32798473898395064, 0.3256160113195703, 0.3255108132650957, 0.3034571928911659, 0.30324182407153377, 0.3293706584713001, 0.31104035585309153, 0.32721389175597315, 0.33765278472284554, 0.23221240325567327, 0.22743437898703311, 0.2580245687560373, 0.23761346541767225, 0.2526630629536373, 0.2464627741643871, 0.26017134123855945, 0.25204575403297924, 0.26077524639507266, 0.20359372218472416, 0.1690353948812332, 0.21646412327277909, 0.17899206938498935, 0.19466771484789658, 0.1934032234491141, 0.18511368523571115, 0.18378723514839646, 0.1974796708356843, 0.1852603313315475, 0.1764048375311037, 0.18065580813172433, 0.21778487754158227, 0.21361171702164994, 0.17397009739185154, 0.17723444901412078, 0.19230547844545454, 0.20910176002327718, 0.8479690485678032, 0.7871870697600027, 0.7808572344312197, 0.7938196608275232, 0.2005113984054585, 0.19800154435886996, 0.14244843972504606, 0.1644798868939703, 0.15788428259051202, 0.777871469564005, 0.21084127825819143, 0.7219118074846282, 0.7273622593942701, 0.16648690217043627, 0.7058124870825896, 0.15661423488416726, 0.2081968809489515, 0.15480599309729626, 0.17524795237208723, 0.17434266699658474, 0.2044190521979472, 0.1856036046416113, 0.17586605765972563, 0.18654743077411773, 0.19080899470257384, 0.17081092954037302, 0.18376650975994058, 0.08517472335019338, 0.08131577760077213, 0.08167978700724887, 0.07521818256019919, 0.07255056182899589, 0.08002976207064294, 0.08269023233599293, 0.08556902933963251, 0.08173529094159315]}, "mutation_prompt": null}
{"id": "c0cafa58-a007-45c7-96c3-3d7adc567e8b", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.8):\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def adaptive_random_search(self):\n        # Introduce a simple random perturbation around the global best for exploration\n        perturbation = np.random.uniform(-0.5, 0.5, self.dim)\n        candidate = np.clip(self.population[self.global_best] + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.1:  # 10% chance to use adaptive random search\n                    trial = self.adaptive_random_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n                \n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.fitness[self.global_best]:\n                        self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridDifferentialEvolution", "description": "Hybrid Differential Evolution with Adaptive Random Search to enhance exploration and exploitation balance for faster convergence.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "59daa2a0-f16e-4aa6-90a0-467962392d25", "metadata": {"aucs": [0.6632627818289437, 0.6922600076938976, 0.6727474769545064, 0.6831793781364897, 0.6931864228567788, 0.7112704654163935, 0.6762788735227594, 0.6877669403831868, 0.6881332008922942, 0.3642917767817637, 0.3319488004055168, 0.3635178469066336, 0.3441238789552844, 0.3664673752841705, 0.3771244072890061, 0.36577110996151285, 0.3684543166503771, 0.37535223784159333, 0.11144604164629257, 0.12365291414215185, 0.12611498569300805, 0.12085868575135938, 0.10791295181524418, 0.1007331743003842, 0.11031540114354843, 0.11535575912300122, 0.1308043805093726, 0.1064966168822471, 0.10422564366673936, 0.11524729307407255, 0.10011327340048104, 0.09261783019145298, 0.09055337610988445, 0.09627502265863819, 0.1046658881573308, 0.09313518313064473, 0.972225768001981, 0.9792281766191235, 0.9843426728302413, 0.9455856430166695, 0.9526355388353679, 0.954814718802366, 0.9788163534665784, 0.9669919479112222, 0.9671258974813884, 0.34503321716428825, 0.3443066527448897, 0.3685290840529194, 0.33300746653818236, 0.344756952919426, 0.3589637347832446, 0.3847285223584924, 0.35563251038077315, 0.33780521335117053, 0.64880351768675, 0.6231029426067937, 0.5903615242202711, 0.6397946976405042, 0.6179465054118085, 0.7735312600875053, 0.6254499740284423, 0.5934217543405529, 0.6755280449463665, 0.28734174886721964, 0.21346798216590346, 0.26802855920151436, 0.25714336811261596, 0.24572479336521313, 0.22435431111607995, 0.19552624844340594, 0.23813186118774454, 0.2676030959988437, 0.23433618635013886, 0.2788460249536484, 0.23623964016399934, 0.24944108357322825, 0.279152616643881, 0.21841435033131051, 0.2819708674826541, 0.23264406052992992, 0.32868414971706106, 0.15724258538287084, 0.1650708518026175, 0.1651397963465352, 0.149626801010589, 0.16906509909561196, 0.15343682365566713, 0.15618246079006237, 0.15264701128265112, 0.12397414593356915, 0.2635313820656726, 0.2466011585858785, 0.29323163700690946, 0.24535580972977422, 0.2659376431279138, 0.21806642721554736, 0.3141828474042305, 0.2913059432149867, 0.27523102455918846, 0.02721817256180914, 0.03392542865417547, 0.04938900508283839, 0.06184619874853048, 0.053995924258037675, 0.03758544647001849, 0.05804756187789428, 0.026239940920850136, 0.053635887502342716, 0.18173309443537078, 0.17997453518346007, 0.1841956860343188, 0.17432532212798946, 0.1927774094827811, 0.1974587843334219, 0.1483164052812912, 0.1706601747699571, 0.19035441379470108, 0.5096689204832121, 0.5399651748319467, 0.5535829910622567, 0.5222679559371944, 0.5239022291868808, 0.5264686787329551, 0.5598154311741934, 0.5247219953842206, 0.533582520906724, 0.08300215416420287, 0.1119669045423658, 0.11248044287164272, 0.09820448822780581, 0.09981636623294232, 0.10141321817073645, 0.09596059733237183, 0.09402145277407581, 0.11246847380050118, 0.32580697284447646, 0.2793176197363758, 0.25118027117997777, 0.19070883555287754, 0.4466920401812695, 0.3167468144671651, 0.19113276587831185, 0.3263984395572662, 0.18112259392959085, 0.32798473898395064, 0.3256160113195703, 0.3255108132650957, 0.3034571928911659, 0.30324182407153377, 0.3293706584713001, 0.31104035585309153, 0.32721389175597315, 0.33765278472284554, 0.23221240325567327, 0.22743437898703311, 0.2580245687560373, 0.23761346541767225, 0.2526630629536373, 0.2464627741643871, 0.26017134123855945, 0.25204575403297924, 0.26077524639507266, 0.20359372218472416, 0.1690353948812332, 0.21646412327277909, 0.17899206938498935, 0.19466771484789658, 0.1934032234491141, 0.18511368523571115, 0.18378723514839646, 0.1974796708356843, 0.1852603313315475, 0.1764048375311037, 0.18065580813172433, 0.21778487754158227, 0.21361171702164994, 0.17397009739185154, 0.17723444901412078, 0.19230547844545454, 0.20910176002327718, 0.8479690485678032, 0.7871870697600027, 0.7808572344312197, 0.7938196608275232, 0.2005113984054585, 0.19800154435886996, 0.14244843972504606, 0.1644798868939703, 0.15788428259051202, 0.777871469564005, 0.21084127825819143, 0.7219118074846282, 0.7273622593942701, 0.16648690217043627, 0.7058124870825896, 0.15661423488416726, 0.2081968809489515, 0.15480599309729626, 0.17524795237208723, 0.17434266699658474, 0.2044190521979472, 0.1856036046416113, 0.17586605765972563, 0.18654743077411773, 0.19080899470257384, 0.17081092954037302, 0.18376650975994058, 0.08517472335019338, 0.08131577760077213, 0.08167978700724887, 0.07521818256019919, 0.07255056182899589, 0.08002976207064294, 0.08269023233599293, 0.08556902933963251, 0.08173529094159315]}, "mutation_prompt": null}
{"id": "ece3e69f-2f4e-49d8-8ec9-186baf4ee673", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.8):\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def adaptive_random_search(self):\n        # Introduce a simple random perturbation around the global best for exploration\n        perturbation = np.random.uniform(-0.5, 0.5, self.dim)\n        candidate = np.clip(self.population[self.global_best] + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.1:  # 10% chance to use adaptive random search\n                    trial = self.adaptive_random_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n                \n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.fitness[self.global_best]:\n                        self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridDifferentialEvolution", "description": "Hybrid Differential Evolution with Adaptive Random Search to enhance exploration and exploitation balance for faster convergence.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "59daa2a0-f16e-4aa6-90a0-467962392d25", "metadata": {"aucs": [0.6632627818289437, 0.6922600076938976, 0.6727474769545064, 0.6831793781364897, 0.6931864228567788, 0.7112704654163935, 0.6762788735227594, 0.6877669403831868, 0.6881332008922942, 0.3642917767817637, 0.3319488004055168, 0.3635178469066336, 0.3441238789552844, 0.3664673752841705, 0.3771244072890061, 0.36577110996151285, 0.3684543166503771, 0.37535223784159333, 0.11144604164629257, 0.12365291414215185, 0.12611498569300805, 0.12085868575135938, 0.10791295181524418, 0.1007331743003842, 0.11031540114354843, 0.11535575912300122, 0.1308043805093726, 0.1064966168822471, 0.10422564366673936, 0.11524729307407255, 0.10011327340048104, 0.09261783019145298, 0.09055337610988445, 0.09627502265863819, 0.1046658881573308, 0.09313518313064473, 0.972225768001981, 0.9792281766191235, 0.9843426728302413, 0.9455856430166695, 0.9526355388353679, 0.954814718802366, 0.9788163534665784, 0.9669919479112222, 0.9671258974813884, 0.34503321716428825, 0.3443066527448897, 0.3685290840529194, 0.33300746653818236, 0.344756952919426, 0.3589637347832446, 0.3847285223584924, 0.35563251038077315, 0.33780521335117053, 0.64880351768675, 0.6231029426067937, 0.5903615242202711, 0.6397946976405042, 0.6179465054118085, 0.7735312600875053, 0.6254499740284423, 0.5934217543405529, 0.6755280449463665, 0.28734174886721964, 0.21346798216590346, 0.26802855920151436, 0.25714336811261596, 0.24572479336521313, 0.22435431111607995, 0.19552624844340594, 0.23813186118774454, 0.2676030959988437, 0.23433618635013886, 0.2788460249536484, 0.23623964016399934, 0.24944108357322825, 0.279152616643881, 0.21841435033131051, 0.2819708674826541, 0.23264406052992992, 0.32868414971706106, 0.15724258538287084, 0.1650708518026175, 0.1651397963465352, 0.149626801010589, 0.16906509909561196, 0.15343682365566713, 0.15618246079006237, 0.15264701128265112, 0.12397414593356915, 0.2635313820656726, 0.2466011585858785, 0.29323163700690946, 0.24535580972977422, 0.2659376431279138, 0.21806642721554736, 0.3141828474042305, 0.2913059432149867, 0.27523102455918846, 0.02721817256180914, 0.03392542865417547, 0.04938900508283839, 0.06184619874853048, 0.053995924258037675, 0.03758544647001849, 0.05804756187789428, 0.026239940920850136, 0.053635887502342716, 0.18173309443537078, 0.17997453518346007, 0.1841956860343188, 0.17432532212798946, 0.1927774094827811, 0.1974587843334219, 0.1483164052812912, 0.1706601747699571, 0.19035441379470108, 0.5096689204832121, 0.5399651748319467, 0.5535829910622567, 0.5222679559371944, 0.5239022291868808, 0.5264686787329551, 0.5598154311741934, 0.5247219953842206, 0.533582520906724, 0.08300215416420287, 0.1119669045423658, 0.11248044287164272, 0.09820448822780581, 0.09981636623294232, 0.10141321817073645, 0.09596059733237183, 0.09402145277407581, 0.11246847380050118, 0.32580697284447646, 0.2793176197363758, 0.25118027117997777, 0.19070883555287754, 0.4466920401812695, 0.3167468144671651, 0.19113276587831185, 0.3263984395572662, 0.18112259392959085, 0.32798473898395064, 0.3256160113195703, 0.3255108132650957, 0.3034571928911659, 0.30324182407153377, 0.3293706584713001, 0.31104035585309153, 0.32721389175597315, 0.33765278472284554, 0.23221240325567327, 0.22743437898703311, 0.2580245687560373, 0.23761346541767225, 0.2526630629536373, 0.2464627741643871, 0.26017134123855945, 0.25204575403297924, 0.26077524639507266, 0.20359372218472416, 0.1690353948812332, 0.21646412327277909, 0.17899206938498935, 0.19466771484789658, 0.1934032234491141, 0.18511368523571115, 0.18378723514839646, 0.1974796708356843, 0.1852603313315475, 0.1764048375311037, 0.18065580813172433, 0.21778487754158227, 0.21361171702164994, 0.17397009739185154, 0.17723444901412078, 0.19230547844545454, 0.20910176002327718, 0.8479690485678032, 0.7871870697600027, 0.7808572344312197, 0.7938196608275232, 0.2005113984054585, 0.19800154435886996, 0.14244843972504606, 0.1644798868939703, 0.15788428259051202, 0.777871469564005, 0.21084127825819143, 0.7219118074846282, 0.7273622593942701, 0.16648690217043627, 0.7058124870825896, 0.15661423488416726, 0.2081968809489515, 0.15480599309729626, 0.17524795237208723, 0.17434266699658474, 0.2044190521979472, 0.1856036046416113, 0.17586605765972563, 0.18654743077411773, 0.19080899470257384, 0.17081092954037302, 0.18376650975994058, 0.08517472335019338, 0.08131577760077213, 0.08167978700724887, 0.07521818256019919, 0.07255056182899589, 0.08002976207064294, 0.08269023233599293, 0.08556902933963251, 0.08173529094159315]}, "mutation_prompt": null}
{"id": "90f280d6-7f53-4993-b2c2-f7cae284f394", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.8):\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def adaptive_random_search(self):\n        # Introduce a simple random perturbation around the global best for exploration\n        perturbation = np.random.uniform(-0.5, 0.5, self.dim)\n        candidate = np.clip(self.population[self.global_best] + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.1:  # 10% chance to use adaptive random search\n                    trial = self.adaptive_random_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n                \n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.fitness[self.global_best]:\n                        self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridDifferentialEvolution", "description": "Hybrid Differential Evolution with Adaptive Random Search to enhance exploration and exploitation balance for faster convergence.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "59daa2a0-f16e-4aa6-90a0-467962392d25", "metadata": {"aucs": [0.6632627818289437, 0.6922600076938976, 0.6727474769545064, 0.6831793781364897, 0.6931864228567788, 0.7112704654163935, 0.6762788735227594, 0.6877669403831868, 0.6881332008922942, 0.3642917767817637, 0.3319488004055168, 0.3635178469066336, 0.3441238789552844, 0.3664673752841705, 0.3771244072890061, 0.36577110996151285, 0.3684543166503771, 0.37535223784159333, 0.11144604164629257, 0.12365291414215185, 0.12611498569300805, 0.12085868575135938, 0.10791295181524418, 0.1007331743003842, 0.11031540114354843, 0.11535575912300122, 0.1308043805093726, 0.1064966168822471, 0.10422564366673936, 0.11524729307407255, 0.10011327340048104, 0.09261783019145298, 0.09055337610988445, 0.09627502265863819, 0.1046658881573308, 0.09313518313064473, 0.972225768001981, 0.9792281766191235, 0.9843426728302413, 0.9455856430166695, 0.9526355388353679, 0.954814718802366, 0.9788163534665784, 0.9669919479112222, 0.9671258974813884, 0.34503321716428825, 0.3443066527448897, 0.3685290840529194, 0.33300746653818236, 0.344756952919426, 0.3589637347832446, 0.3847285223584924, 0.35563251038077315, 0.33780521335117053, 0.64880351768675, 0.6231029426067937, 0.5903615242202711, 0.6397946976405042, 0.6179465054118085, 0.7735312600875053, 0.6254499740284423, 0.5934217543405529, 0.6755280449463665, 0.28734174886721964, 0.21346798216590346, 0.26802855920151436, 0.25714336811261596, 0.24572479336521313, 0.22435431111607995, 0.19552624844340594, 0.23813186118774454, 0.2676030959988437, 0.23433618635013886, 0.2788460249536484, 0.23623964016399934, 0.24944108357322825, 0.279152616643881, 0.21841435033131051, 0.2819708674826541, 0.23264406052992992, 0.32868414971706106, 0.15724258538287084, 0.1650708518026175, 0.1651397963465352, 0.149626801010589, 0.16906509909561196, 0.15343682365566713, 0.15618246079006237, 0.15264701128265112, 0.12397414593356915, 0.2635313820656726, 0.2466011585858785, 0.29323163700690946, 0.24535580972977422, 0.2659376431279138, 0.21806642721554736, 0.3141828474042305, 0.2913059432149867, 0.27523102455918846, 0.02721817256180914, 0.03392542865417547, 0.04938900508283839, 0.06184619874853048, 0.053995924258037675, 0.03758544647001849, 0.05804756187789428, 0.026239940920850136, 0.053635887502342716, 0.18173309443537078, 0.17997453518346007, 0.1841956860343188, 0.17432532212798946, 0.1927774094827811, 0.1974587843334219, 0.1483164052812912, 0.1706601747699571, 0.19035441379470108, 0.5096689204832121, 0.5399651748319467, 0.5535829910622567, 0.5222679559371944, 0.5239022291868808, 0.5264686787329551, 0.5598154311741934, 0.5247219953842206, 0.533582520906724, 0.08300215416420287, 0.1119669045423658, 0.11248044287164272, 0.09820448822780581, 0.09981636623294232, 0.10141321817073645, 0.09596059733237183, 0.09402145277407581, 0.11246847380050118, 0.32580697284447646, 0.2793176197363758, 0.25118027117997777, 0.19070883555287754, 0.4466920401812695, 0.3167468144671651, 0.19113276587831185, 0.3263984395572662, 0.18112259392959085, 0.32798473898395064, 0.3256160113195703, 0.3255108132650957, 0.3034571928911659, 0.30324182407153377, 0.3293706584713001, 0.31104035585309153, 0.32721389175597315, 0.33765278472284554, 0.23221240325567327, 0.22743437898703311, 0.2580245687560373, 0.23761346541767225, 0.2526630629536373, 0.2464627741643871, 0.26017134123855945, 0.25204575403297924, 0.26077524639507266, 0.20359372218472416, 0.1690353948812332, 0.21646412327277909, 0.17899206938498935, 0.19466771484789658, 0.1934032234491141, 0.18511368523571115, 0.18378723514839646, 0.1974796708356843, 0.1852603313315475, 0.1764048375311037, 0.18065580813172433, 0.21778487754158227, 0.21361171702164994, 0.17397009739185154, 0.17723444901412078, 0.19230547844545454, 0.20910176002327718, 0.8479690485678032, 0.7871870697600027, 0.7808572344312197, 0.7938196608275232, 0.2005113984054585, 0.19800154435886996, 0.14244843972504606, 0.1644798868939703, 0.15788428259051202, 0.777871469564005, 0.21084127825819143, 0.7219118074846282, 0.7273622593942701, 0.16648690217043627, 0.7058124870825896, 0.15661423488416726, 0.2081968809489515, 0.15480599309729626, 0.17524795237208723, 0.17434266699658474, 0.2044190521979472, 0.1856036046416113, 0.17586605765972563, 0.18654743077411773, 0.19080899470257384, 0.17081092954037302, 0.18376650975994058, 0.08517472335019338, 0.08131577760077213, 0.08167978700724887, 0.07521818256019919, 0.07255056182899589, 0.08002976207064294, 0.08269023233599293, 0.08556902933963251, 0.08173529094159315]}, "mutation_prompt": null}
{"id": "53ce667c-8043-4af9-b6f0-617727b059e7", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.5 + np.random.rand() * 0.5):  # Dynamic F factor for mutation\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def adaptive_random_search(self):\n        perturbation = np.random.uniform(-0.5, 0.5, self.dim)\n        candidate = np.clip(self.population[self.global_best] + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.15:  # Increased chance to use adaptive random search\n                    trial = self.adaptive_random_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n                \n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.fitness[self.global_best]:\n                        self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with Adaptive Random Search and a dynamic mutation strategy for improved convergence speed.", "configspace": "", "generation": 21, "fitness": 0.31141278840210884, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.", "error": "", "parent_id": "59daa2a0-f16e-4aa6-90a0-467962392d25", "metadata": {"aucs": [0.7096250909303146, 0.697143818442316, 0.7119301495225946, 0.7112777682176713, 0.729718675027915, 0.7225620564111592, 0.7155957748916941, 0.7243004281067756, 0.7020405328395362, 0.3921181749915358, 0.37889314755031944, 0.37094970184493326, 0.40010068774384744, 0.4494453586285039, 0.398497220605743, 0.37142758903571516, 0.390487970238948, 0.4190169732305843, 0.1113338444116111, 0.10298344401721826, 0.10899264620109494, 0.11809778466749943, 0.10213644928941634, 0.09624475460419668, 0.1103837280465616, 0.1310177443781575, 0.1023648438347392, 0.10714281763583788, 0.11498749504499883, 0.11124069640980738, 0.10759105584052764, 0.09847182904399576, 0.11377384203870866, 0.11916946540722562, 0.09776089583817593, 0.09928311441229454, 0.9610044166467336, 0.9839029196852564, 0.9793769878401474, 0.976047386930374, 0.9733034980804924, 0.9620672724017689, 0.977887604215307, 0.9840952321230705, 0.9713033799446142, 0.3755601085484648, 0.3834863502305932, 0.3531704643915945, 0.36882054855688706, 0.34840421684215117, 0.3975775525298627, 0.3938298134339461, 0.39692870139197056, 0.3885706981075475, 0.7026442479190591, 0.6805350114625934, 0.6537604174045288, 0.7719066374409166, 0.73020049961519, 0.6208429757748491, 0.7097255255147011, 0.6067306429880441, 0.6844648642707444, 0.2824418889095708, 0.20100917108687422, 0.3155121101280457, 0.28665149872588935, 0.31820304757370055, 0.2743092023485094, 0.2887336729648683, 0.3230400399660591, 0.2565392050566746, 0.24175735583702296, 0.2655691809722298, 0.17181309747172124, 0.2671434598711161, 0.2633995745079636, 0.12766170768786655, 0.3017372473585824, 0.27233142619368633, 0.16204383721215376, 0.21317249833036933, 0.2116911629707653, 0.19786386504493514, 0.18332391239753432, 0.2112591395413157, 0.1891413980048372, 0.20136319668266356, 0.16015485507965455, 0.20337290578249745, 0.2998059034446423, 0.30936150784337957, 0.311092559023852, 0.27660185847544094, 0.30674058161188156, 0.29792753854348364, 0.3343852764112736, 0.28909805936008626, 0.3522661016959573, 0.054144042657344627, 0.050600728967152286, 0.05981721648934868, 0.129057344810392, 0.08956305816681576, 0.07158507421426819, 0.07142867068423053, 0.04090622544334965, 0.069254802841206, 0.2161508466376082, 0.20562652652198898, 0.21342186566241883, 0.19593610607366507, 0.18532826082956388, 0.2121505261806398, 0.17413673020164566, 0.19571436496958317, 0.20924711101144755, 0.5718238822743313, 0.5660227841679655, 0.5651368308436044, 0.5646615208718396, 0.5424938150812548, 0.5470477590309852, 0.5891418004380461, 0.5701562920043849, 0.5372732650060887, 0.09486674410354023, 0.08988863537792491, 0.10826617648695047, 0.09086191900962381, 0.0991966070793554, 0.0938843574933721, 0.09352050156329383, 0.1165118516684448, 0.10431854637145843, 0.19893318212406108, 0.3166329420085784, 0.33902114834949004, 0.2312280169533445, 0.19219419237188895, 0.34970373159224155, 0.3994469599522217, 0.2309596766227252, 0.3091474206557575, 0.3049057013823048, 0.3338334271055664, 0.32795134068512566, 0.3128527625897437, 0.3489738868942961, 0.31774040547283244, 0.3448193998051242, 0.3407964431503835, 0.32469812765672756, 0.23610605079476532, 0.27447623564014667, 0.2612397228686355, 0.26192232205574895, 0.24913874162570915, 0.2506545703842563, 0.2418420078342548, 0.27187113946709907, 0.2520922092412835, 0.20100217249040953, 0.2286958286250862, 0.18447671963032697, 0.19750859808465415, 0.17504821321935304, 0.17720796760330015, 0.20859485422185153, 0.19291397002364663, 0.21270194822755117, 0.20717538365489996, 0.20735763875764113, 0.20350592364576847, 0.20533649010906962, 0.22674721646967544, 0.20711415092615648, 0.2095123059421239, 0.23148801631230087, 0.18707284865855178, 0.1869169680094166, 0.12694814464456738, 0.15439087664599827, 0.829113052265307, 0.20092896441460228, 0.19911779331564805, 0.17755389895563656, 0.16316171504094013, 0.16300551599506596, 0.8049534283160587, 0.2125930570062745, 0.783559003699009, 0.08326079969868283, 0.16823179337313576, 0.1532145170727517, 0.11293377042261599, 0.21323051716020547, 0.7553762828506863, 0.17940381007538564, 0.18583335767415965, 0.2066320339358707, 0.19704157522284038, 0.1808682739759242, 0.18536706189583207, 0.19399167477313817, 0.18083675235635033, 0.19020917717132835, 0.09959636640040903, 0.08172650275366378, 0.07453836170510764, 0.07628269836644086, 0.08292669561862254, 0.07598912073182729, 0.08126916879775725, 0.09127601670127494, 0.084324156900484]}, "mutation_prompt": null}
{"id": "4d89b737-0e7d-462a-a4d3-30e240f9e996", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.6 + np.random.rand() * 0.4):  # Modified dynamic F factor for mutation\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        CR = 0.8 + 0.2 * (self.eval_count / self.budget)  # Dynamic crossover rate\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def adaptive_random_search(self):\n        perturbation = np.random.uniform(-0.4, 0.4, self.dim)  # Adjusted perturbation range\n        candidate = np.clip(self.population[self.global_best] + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.2:  # Further increased chance to use adaptive random search\n                    trial = self.adaptive_random_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n                \n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.fitness[self.global_best]:\n                        self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with Dynamic Crossover and Improved Mutation for Faster Convergence.", "configspace": "", "generation": 22, "fitness": 0.2675172989465237, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "53ce667c-8043-4af9-b6f0-617727b059e7", "metadata": {"aucs": [0.6060833527878297, 0.5994252000721682, 0.5670873028977736, 0.6028976381378399, 0.6116517217065858, 0.5992455956593743, 0.6132137692470306, 0.6130312491559855, 0.6338790603611681, 0.2019373781859808, 0.23640632930999805, 0.24644490571754718, 0.21025270486263714, 0.20741400894196782, 0.22210823763830057, 0.22517942387011103, 0.24487735268813926, 0.21987361323997479, 0.13395309450941173, 0.12199807572594867, 0.12950864233017123, 0.1199988785382271, 0.12182892000057854, 0.1477600026128184, 0.11404139951277903, 0.1386394245332977, 0.1307678332465515, 0.10799514256895304, 0.1092125959920549, 0.1097351615211648, 0.11229112435299926, 0.09970761248785254, 0.116655704598703, 0.12318524534735442, 0.10457483036953674, 0.11874487160814229, 0.976718043976516, 0.9846292597532018, 0.9888788406239248, 0.9720341218569853, 0.9552379996763013, 0.957992512033602, 0.9655852289046383, 0.97520016099167, 0.9737851747632853, 0.32980611316164854, 0.29940784625378214, 0.2951952246461679, 0.312764452498137, 0.327055948209504, 0.3069206617262433, 0.30477550641277795, 0.2868366151580122, 0.32125921810063574, 0.48233171878017467, 0.5583473345662416, 0.5931163531562095, 0.4821642175952756, 0.6939569988790015, 0.5562982789766109, 0.5173044297044168, 0.596968419987028, 0.5127737460040025, 0.26794364776634416, 0.20745272516559066, 0.18710737271905953, 0.21637536225459986, 0.20870466530684206, 0.1249954388308403, 0.21690794876397756, 0.2249605246076123, 0.20379421554385047, 0.1817382497459733, 0.24391813153604358, 0.2185302838914558, 0.21326691513316853, 0.2145268632121925, 0.19555362906804308, 0.19839894008716352, 0.2147868906325784, 0.16478458983224353, 0.06861944728118075, 0.08888356029454914, 0.10958373380283626, 0.09376215363577978, 0.08929561340330838, 0.1055971914366215, 0.0769660879220635, 0.09657332506010785, 0.06932824355512235, 0.20132181627789758, 0.18386200177483014, 0.20886440126565653, 0.2150544088706825, 0.20249637253351538, 0.18547175202347677, 0.18601741522871762, 0.2449969804439267, 0.22899580968823374, 0.014594502974480617, 0.011848058083548163, 0.00418699749203022, 0.004536124809790043, 0.017581183606562578, 0.013692838779420513, 0.0213544559430644, 0.0033298641664744055, 0.018079729201961214, 0.15588437162448443, 0.12031098578460242, 0.1432314555188512, 0.13744717884040036, 0.13759415670745834, 0.13890104987966756, 0.13992297903921613, 0.15059811969160075, 0.14282416275617238, 0.4785607538514651, 0.4931305175895574, 0.4865303721586075, 0.48194548666555515, 0.4814043217571533, 0.48183660675750684, 0.48121800704151785, 0.47065731223445295, 0.5082807146217413, 0.1130017721219807, 0.09136088080302829, 0.11717925232874982, 0.09767533657491134, 0.09869777973020533, 0.11121657524316653, 0.11738591862510717, 0.10534465780963254, 0.0901976322946686, 0.29479348049909526, 0.260895151273399, 0.22208800150147145, 0.28537799565916955, 0.285566657349994, 0.33035636369998944, 0.19094124181981764, 0.224765263774255, 0.23159182899398434, 0.28853611237731613, 0.29196412213732914, 0.3045888520519666, 0.2931227280153297, 0.29273743074450553, 0.2974839104666266, 0.30110888632293786, 0.3128579469802465, 0.29711681698974046, 0.23041517418389168, 0.22342693718626305, 0.22871347505527673, 0.19675451336807537, 0.1758223465986568, 0.2256812451779462, 0.22861655298366768, 0.24941235225197267, 0.2371278833387852, 0.20299030667408857, 0.21155934379576924, 0.20959892533426916, 0.2171376286998873, 0.21924045132919845, 0.2157711007037677, 0.21175906993993499, 0.17859617309258446, 0.19999343026104854, 0.2057255154497346, 0.2247553857362694, 0.21219888722200242, 0.2522872647507943, 0.22260041071898362, 0.20405948403630714, 0.20853331563643618, 0.24044966092567854, 0.3219771330901985, 0.19890261681986, 0.13501233131858625, 0.16882707565127364, 0.7329611602358364, 0.2015348615237349, 0.19994273079759284, 0.142752971674866, 0.16474481760079585, 0.7704011222448592, 0.6796396147724122, 0.21189498077903635, 0.21059820712060806, 0.10470654738696195, 0.698345481153587, 0.1532736637549693, 0.10525982118602584, 0.10502593934080329, 0.15710726917511697, 0.19634523830107076, 0.1885955815725353, 0.17577560986997864, 0.18721411286674117, 0.19018764589380321, 0.1926213664012344, 0.210042565634889, 0.18153451120511854, 0.18165204287915138, 0.09424128304255974, 0.08775923926454998, 0.0814365178734684, 0.09553327133494116, 0.08530362837860817, 0.09310344418830263, 0.07061974824918504, 0.09328002065205221, 0.08653212166750912]}, "mutation_prompt": null}
{"id": "bc71561f-44d4-4324-9db3-70d619d8c7b2", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n        self.local_best = np.copy(self.population)\n        self.scaling_factor = np.full(self.pop_size, 0.5 + np.random.rand() * 0.5)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F):\n        perturbation = np.random.normal(0, 0.1, self.dim)  # Injecting Gaussian noise\n        mutant = np.clip(a + F * (b - c) + perturbation, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def adaptive_random_search(self):\n        perturbation = np.random.uniform(-0.5, 0.5, self.dim)\n        candidate = np.clip(self.population[self.global_best] + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.15:\n                    trial = self.adaptive_random_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c, self.scaling_factor[i])\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.scaling_factor[i] = min(1.0, self.scaling_factor[i] * 1.1)  # Adaptive F factor increase\n                    if trial_fitness < self.fitness[self.global_best]:\n                        self.global_best = i\n                        self.local_best[i] = trial\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with adaptive scaling factor and individual learning capability for improved convergence.", "configspace": "", "generation": 23, "fitness": 0.21922886182455179, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.20.", "error": "", "parent_id": "53ce667c-8043-4af9-b6f0-617727b059e7", "metadata": {"aucs": [0.4242067015457792, 0.43550158586065557, 0.4262246008594991, 0.43721753908337724, 0.4549766821261758, 0.44018487704036624, 0.4230587850845684, 0.4467389526912747, 0.4201222292044057, 0.028317285722206154, 0.03183979349328003, 0.045145282049564806, 0.04589098164457606, 0.04793709067913099, 0.04563648717971169, 0.04133743192792172, 0.03857417085371451, 0.048513650726561, 0.09538494680424425, 0.10756689983492174, 0.11377572149537396, 0.09978137399463471, 0.11249112087811464, 0.10030972418297335, 0.09117123424081996, 0.12370569062962455, 0.10698581733084389, 0.09446344467846612, 0.10314866606384909, 0.10243887546284292, 0.09287799632771143, 0.1013510515425241, 0.09952042582511533, 0.07949022178134879, 0.10192514133123243, 0.10892719331327427, 0.9783244159225374, 0.954025060199552, 0.958725971727085, 0.9654368670975271, 0.9474874722833058, 0.9525414656143703, 0.963286205697688, 0.9697328179223323, 0.9813563341912056, 0.27232481186538804, 0.2551480440966637, 0.24950344801729551, 0.2620847143555667, 0.26936371384687763, 0.2712163946408058, 0.24985325038712836, 0.26616234555001084, 0.2579385736927976, 0.318458853411281, 0.3202920165051941, 0.2975665882623886, 0.3276099301772749, 0.34897981198936023, 0.345289399942599, 0.295805397717377, 0.3259422226124067, 0.3011056478290921, 0.15486954304552913, 0.15589253512477586, 0.15027081157268918, 0.1250760622661954, 0.15330221981336667, 0.1258441429899958, 0.15980403522222186, 0.15405608582544772, 0.15748120312020297, 0.14994011328505386, 0.16697931165780122, 0.1680825945128609, 0.1496221579434821, 0.14762278120212868, 0.18266283254309656, 0.181216829924442, 0.202555447248026, 0.16770465959344916, 0.008797638258721041, 0.039254045484876765, 0.020483893211114657, 0.029696286821000784, 0.019394790577698773, 0.012225989624870426, 0.0001646559552133109, 0.012905196258875873, 0.015371754955630035, 0.0899725314617753, 0.12135873589883106, 0.12690548910304966, 0.10504234634280096, 0.05953685226072247, 0.09303903276989167, 0.09844194255486904, 0.12025729807193797, 0.10618796211311232, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08324740973123046, 0.09757548394231286, 0.08181763014308419, 0.09786828899486333, 0.0931673666367655, 0.09757389228244595, 0.09406193965481924, 0.10060711778201237, 0.09857924857910327, 0.3957413823498064, 0.4208539785697045, 0.40525490978988, 0.4026333145944335, 0.43989485645584914, 0.3999060722689496, 0.3874389979067391, 0.38295653659217455, 0.38984434118713196, 0.09630432061273297, 0.11676028933108995, 0.08474032859265246, 0.1031238153871582, 0.1155532977778927, 0.1030665552523542, 0.09861750348825649, 0.09426845649669668, 0.10809827972920705, 0.2046467437093058, 0.19609559211381133, 0.20610894573684813, 0.21692657843011753, 0.2476709807260088, 0.2203737904347769, 0.23728461075002305, 0.2267351778336254, 0.22415570843188948, 0.2719600752177711, 0.27747313498507187, 0.27167554416826356, 0.2763081759794338, 0.2798722653885448, 0.28065563979968733, 0.2719026824006888, 0.2772835879999317, 0.2851585451341455, 0.21617317492043253, 0.22323390153781364, 0.2259029658942362, 0.21549245746733547, 0.2358648970544387, 0.2097308049489366, 0.20831718353151985, 0.20747351810721337, 0.22299636118606836, 0.19265518657875824, 0.2230385954838825, 0.20650926106178225, 0.19912875638337824, 0.21166132438624108, 0.20269299971052346, 0.19527895878196688, 0.21147969566274893, 0.18897982485928855, 0.21142021487288143, 0.22138809231145218, 0.18565115697177592, 0.18944561914876956, 0.1808424937805535, 0.20693945347137577, 0.217350943098938, 0.20226174384518447, 0.18562552126150444, 0.16587308832048253, 0.18584613295570784, 0.1541802881334654, 0.18773208818462483, 0.6156307184330194, 0.1984798616280007, 0.17293294939941284, 0.17754468829545023, 0.6727565049113473, 0.5240900508682125, 0.2119110814449615, 0.4908711759374397, 0.49879367767080784, 0.1674544578472803, 0.4675126745958639, 0.21236313493924408, 0.16631397884696508, 0.1669376044002494, 0.18106959775519904, 0.18158743411122846, 0.18564594355231845, 0.19221391259643306, 0.19840283836122263, 0.19249333708725902, 0.1809772354390211, 0.19839865787692212, 0.2031365703768141, 0.1108181252541115, 0.08433749339425356, 0.08162333131856592, 0.09742883953178738, 0.08584320652832034, 0.0812149390315281, 0.0792737686751358, 0.08337648758208727, 0.08376852146860236]}, "mutation_prompt": null}
{"id": "75300457-a787-4021-9e3f-7766e3b40df6", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.5 + np.random.rand() * 0.5):  # Dynamic F factor for mutation\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def adaptive_random_search(self):\n        perturbation = np.random.uniform(-0.5, 0.5, self.dim)\n        candidate = np.clip(self.population[self.global_best] + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.15:  # Increased chance to use adaptive random search\n                    trial = self.adaptive_random_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n                \n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.fitness[self.global_best]:\n                        self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with Adaptive Random Search and a dynamic mutation strategy for improved convergence speed.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "53ce667c-8043-4af9-b6f0-617727b059e7", "metadata": {"aucs": [0.7096250909303146, 0.697143818442316, 0.7119301495225946, 0.7112777682176713, 0.729718675027915, 0.7225620564111592, 0.7155957748916941, 0.7243004281067756, 0.7020405328395362, 0.3921181749915358, 0.37889314755031944, 0.37094970184493326, 0.40010068774384744, 0.4494453586285039, 0.398497220605743, 0.37142758903571516, 0.390487970238948, 0.4190169732305843, 0.1113338444116111, 0.10298344401721826, 0.10899264620109494, 0.11809778466749943, 0.10213644928941634, 0.09624475460419668, 0.1103837280465616, 0.1310177443781575, 0.1023648438347392, 0.10714281763583788, 0.11498749504499883, 0.11124069640980738, 0.10759105584052764, 0.09847182904399576, 0.11377384203870866, 0.11916946540722562, 0.09776089583817593, 0.09928311441229454, 0.9610044166467336, 0.9839029196852564, 0.9793769878401474, 0.976047386930374, 0.9733034980804924, 0.9620672724017689, 0.977887604215307, 0.9840952321230705, 0.9713033799446142, 0.3755601085484648, 0.3834863502305932, 0.3531704643915945, 0.36882054855688706, 0.34840421684215117, 0.3975775525298627, 0.3938298134339461, 0.39692870139197056, 0.3885706981075475, 0.7026442479190591, 0.6805350114625934, 0.6537604174045288, 0.7719066374409166, 0.73020049961519, 0.6208429757748491, 0.7097255255147011, 0.6067306429880441, 0.6844648642707444, 0.2824418889095708, 0.20100917108687422, 0.3155121101280457, 0.28665149872588935, 0.31820304757370055, 0.2743092023485094, 0.2887336729648683, 0.3230400399660591, 0.2565392050566746, 0.24175735583702296, 0.2655691809722298, 0.17181309747172124, 0.2671434598711161, 0.2633995745079636, 0.12766170768786655, 0.3017372473585824, 0.27233142619368633, 0.16204383721215376, 0.21317249833036933, 0.2116911629707653, 0.19786386504493514, 0.18332391239753432, 0.2112591395413157, 0.1891413980048372, 0.20136319668266356, 0.16015485507965455, 0.20337290578249745, 0.2998059034446423, 0.30936150784337957, 0.311092559023852, 0.27660185847544094, 0.30674058161188156, 0.29792753854348364, 0.3343852764112736, 0.28909805936008626, 0.3522661016959573, 0.054144042657344627, 0.050600728967152286, 0.05981721648934868, 0.129057344810392, 0.08956305816681576, 0.07158507421426819, 0.07142867068423053, 0.04090622544334965, 0.069254802841206, 0.2161508466376082, 0.20562652652198898, 0.21342186566241883, 0.19593610607366507, 0.18532826082956388, 0.2121505261806398, 0.17413673020164566, 0.19571436496958317, 0.20924711101144755, 0.5718238822743313, 0.5660227841679655, 0.5651368308436044, 0.5646615208718396, 0.5424938150812548, 0.5470477590309852, 0.5891418004380461, 0.5701562920043849, 0.5372732650060887, 0.09486674410354023, 0.08988863537792491, 0.10826617648695047, 0.09086191900962381, 0.0991966070793554, 0.0938843574933721, 0.09352050156329383, 0.1165118516684448, 0.10431854637145843, 0.19893318212406108, 0.3166329420085784, 0.33902114834949004, 0.2312280169533445, 0.19219419237188895, 0.34970373159224155, 0.3994469599522217, 0.2309596766227252, 0.3091474206557575, 0.3049057013823048, 0.3338334271055664, 0.32795134068512566, 0.3128527625897437, 0.3489738868942961, 0.31774040547283244, 0.3448193998051242, 0.3407964431503835, 0.32469812765672756, 0.23610605079476532, 0.27447623564014667, 0.2612397228686355, 0.26192232205574895, 0.24913874162570915, 0.2506545703842563, 0.2418420078342548, 0.27187113946709907, 0.2520922092412835, 0.20100217249040953, 0.2286958286250862, 0.18447671963032697, 0.19750859808465415, 0.17504821321935304, 0.17720796760330015, 0.20859485422185153, 0.19291397002364663, 0.21270194822755117, 0.20717538365489996, 0.20735763875764113, 0.20350592364576847, 0.20533649010906962, 0.22674721646967544, 0.20711415092615648, 0.2095123059421239, 0.23148801631230087, 0.18707284865855178, 0.1869169680094166, 0.12694814464456738, 0.15439087664599827, 0.829113052265307, 0.20092896441460228, 0.19911779331564805, 0.17755389895563656, 0.16316171504094013, 0.16300551599506596, 0.8049534283160587, 0.2125930570062745, 0.783559003699009, 0.08326079969868283, 0.16823179337313576, 0.1532145170727517, 0.11293377042261599, 0.21323051716020547, 0.7553762828506863, 0.17940381007538564, 0.18583335767415965, 0.2066320339358707, 0.19704157522284038, 0.1808682739759242, 0.18536706189583207, 0.19399167477313817, 0.18083675235635033, 0.19020917717132835, 0.09959636640040903, 0.08172650275366378, 0.07453836170510764, 0.07628269836644086, 0.08292669561862254, 0.07598912073182729, 0.08126916879775725, 0.09127601670127494, 0.084324156900484]}, "mutation_prompt": null}
{"id": "d25b0c42-a90a-4244-a4f9-3147d8877cf8", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.5 + np.random.rand() * 0.5):  # Dynamic F factor for mutation\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def adaptive_random_search(self):\n        perturbation = np.random.uniform(-0.5, 0.5, self.dim)\n        candidate = np.clip(self.population[self.global_best] + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.15:  # Increased chance to use adaptive random search\n                    trial = self.adaptive_random_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n                \n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.fitness[self.global_best]:\n                        self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with Adaptive Random Search and a dynamic mutation strategy for improved convergence speed.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "53ce667c-8043-4af9-b6f0-617727b059e7", "metadata": {"aucs": [0.7096250909303146, 0.697143818442316, 0.7119301495225946, 0.7112777682176713, 0.729718675027915, 0.7225620564111592, 0.7155957748916941, 0.7243004281067756, 0.7020405328395362, 0.3921181749915358, 0.37889314755031944, 0.37094970184493326, 0.40010068774384744, 0.4494453586285039, 0.398497220605743, 0.37142758903571516, 0.390487970238948, 0.4190169732305843, 0.1113338444116111, 0.10298344401721826, 0.10899264620109494, 0.11809778466749943, 0.10213644928941634, 0.09624475460419668, 0.1103837280465616, 0.1310177443781575, 0.1023648438347392, 0.10714281763583788, 0.11498749504499883, 0.11124069640980738, 0.10759105584052764, 0.09847182904399576, 0.11377384203870866, 0.11916946540722562, 0.09776089583817593, 0.09928311441229454, 0.9610044166467336, 0.9839029196852564, 0.9793769878401474, 0.976047386930374, 0.9733034980804924, 0.9620672724017689, 0.977887604215307, 0.9840952321230705, 0.9713033799446142, 0.3755601085484648, 0.3834863502305932, 0.3531704643915945, 0.36882054855688706, 0.34840421684215117, 0.3975775525298627, 0.3938298134339461, 0.39692870139197056, 0.3885706981075475, 0.7026442479190591, 0.6805350114625934, 0.6537604174045288, 0.7719066374409166, 0.73020049961519, 0.6208429757748491, 0.7097255255147011, 0.6067306429880441, 0.6844648642707444, 0.2824418889095708, 0.20100917108687422, 0.3155121101280457, 0.28665149872588935, 0.31820304757370055, 0.2743092023485094, 0.2887336729648683, 0.3230400399660591, 0.2565392050566746, 0.24175735583702296, 0.2655691809722298, 0.17181309747172124, 0.2671434598711161, 0.2633995745079636, 0.12766170768786655, 0.3017372473585824, 0.27233142619368633, 0.16204383721215376, 0.21317249833036933, 0.2116911629707653, 0.19786386504493514, 0.18332391239753432, 0.2112591395413157, 0.1891413980048372, 0.20136319668266356, 0.16015485507965455, 0.20337290578249745, 0.2998059034446423, 0.30936150784337957, 0.311092559023852, 0.27660185847544094, 0.30674058161188156, 0.29792753854348364, 0.3343852764112736, 0.28909805936008626, 0.3522661016959573, 0.054144042657344627, 0.050600728967152286, 0.05981721648934868, 0.129057344810392, 0.08956305816681576, 0.07158507421426819, 0.07142867068423053, 0.04090622544334965, 0.069254802841206, 0.2161508466376082, 0.20562652652198898, 0.21342186566241883, 0.19593610607366507, 0.18532826082956388, 0.2121505261806398, 0.17413673020164566, 0.19571436496958317, 0.20924711101144755, 0.5718238822743313, 0.5660227841679655, 0.5651368308436044, 0.5646615208718396, 0.5424938150812548, 0.5470477590309852, 0.5891418004380461, 0.5701562920043849, 0.5372732650060887, 0.09486674410354023, 0.08988863537792491, 0.10826617648695047, 0.09086191900962381, 0.0991966070793554, 0.0938843574933721, 0.09352050156329383, 0.1165118516684448, 0.10431854637145843, 0.19893318212406108, 0.3166329420085784, 0.33902114834949004, 0.2312280169533445, 0.19219419237188895, 0.34970373159224155, 0.3994469599522217, 0.2309596766227252, 0.3091474206557575, 0.3049057013823048, 0.3338334271055664, 0.32795134068512566, 0.3128527625897437, 0.3489738868942961, 0.31774040547283244, 0.3448193998051242, 0.3407964431503835, 0.32469812765672756, 0.23610605079476532, 0.27447623564014667, 0.2612397228686355, 0.26192232205574895, 0.24913874162570915, 0.2506545703842563, 0.2418420078342548, 0.27187113946709907, 0.2520922092412835, 0.20100217249040953, 0.2286958286250862, 0.18447671963032697, 0.19750859808465415, 0.17504821321935304, 0.17720796760330015, 0.20859485422185153, 0.19291397002364663, 0.21270194822755117, 0.20717538365489996, 0.20735763875764113, 0.20350592364576847, 0.20533649010906962, 0.22674721646967544, 0.20711415092615648, 0.2095123059421239, 0.23148801631230087, 0.18707284865855178, 0.1869169680094166, 0.12694814464456738, 0.15439087664599827, 0.829113052265307, 0.20092896441460228, 0.19911779331564805, 0.17755389895563656, 0.16316171504094013, 0.16300551599506596, 0.8049534283160587, 0.2125930570062745, 0.783559003699009, 0.08326079969868283, 0.16823179337313576, 0.1532145170727517, 0.11293377042261599, 0.21323051716020547, 0.7553762828506863, 0.17940381007538564, 0.18583335767415965, 0.2066320339358707, 0.19704157522284038, 0.1808682739759242, 0.18536706189583207, 0.19399167477313817, 0.18083675235635033, 0.19020917717132835, 0.09959636640040903, 0.08172650275366378, 0.07453836170510764, 0.07628269836644086, 0.08292669561862254, 0.07598912073182729, 0.08126916879775725, 0.09127601670127494, 0.084324156900484]}, "mutation_prompt": null}
{"id": "210f0070-1ae6-4054-a18b-5ea6a163d066", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 4, replace=False)  # Select 4 for greedy\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.6 + np.random.rand() * 0.4):  # Slightly modified F factor\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.85):  # Slightly tweaked CR\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def adaptive_random_search(self):\n        perturbation = np.random.normal(0, 0.3, self.dim)  # Using normal distribution\n        candidate = np.clip(self.population[self.global_best] + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.2:  # Adjusted probability for adaptive search\n                    trial = self.adaptive_random_search()\n                else:\n                    target = self.population[i]\n                    a, b, c, d = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i] or trial_fitness < self.fitness[d]:  # Greedy replacement\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.fitness[self.global_best]:\n                        self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with Adaptive Random Search, dynamic mutation, and greedy replacement for improved convergence speed.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('arrays used as indices must be of integer (or boolean) type').", "error": "IndexError('arrays used as indices must be of integer (or boolean) type')", "parent_id": "53ce667c-8043-4af9-b6f0-617727b059e7", "metadata": {}, "mutation_prompt": null}
{"id": "5c5a049e-19b5-4f92-b7df-cb9b0fc716a7", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.5 + np.random.rand() * 0.5):  # Dynamic F factor for mutation\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def adaptive_random_search(self):\n        perturbation = np.random.uniform(-0.5, 0.5, self.dim)\n        candidate = np.clip(self.population[self.global_best] + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.15:  # Increased chance to use adaptive random search\n                    trial = self.adaptive_random_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n                \n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.fitness[self.global_best]:\n                        self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with Adaptive Random Search and a dynamic mutation strategy for improved convergence speed.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "53ce667c-8043-4af9-b6f0-617727b059e7", "metadata": {"aucs": [0.7096250909303146, 0.697143818442316, 0.7119301495225946, 0.7112777682176713, 0.729718675027915, 0.7225620564111592, 0.7155957748916941, 0.7243004281067756, 0.7020405328395362, 0.3921181749915358, 0.37889314755031944, 0.37094970184493326, 0.40010068774384744, 0.4494453586285039, 0.398497220605743, 0.37142758903571516, 0.390487970238948, 0.4190169732305843, 0.1113338444116111, 0.10298344401721826, 0.10899264620109494, 0.11809778466749943, 0.10213644928941634, 0.09624475460419668, 0.1103837280465616, 0.1310177443781575, 0.1023648438347392, 0.10714281763583788, 0.11498749504499883, 0.11124069640980738, 0.10759105584052764, 0.09847182904399576, 0.11377384203870866, 0.11916946540722562, 0.09776089583817593, 0.09928311441229454, 0.9610044166467336, 0.9839029196852564, 0.9793769878401474, 0.976047386930374, 0.9733034980804924, 0.9620672724017689, 0.977887604215307, 0.9840952321230705, 0.9713033799446142, 0.3755601085484648, 0.3834863502305932, 0.3531704643915945, 0.36882054855688706, 0.34840421684215117, 0.3975775525298627, 0.3938298134339461, 0.39692870139197056, 0.3885706981075475, 0.7026442479190591, 0.6805350114625934, 0.6537604174045288, 0.7719066374409166, 0.73020049961519, 0.6208429757748491, 0.7097255255147011, 0.6067306429880441, 0.6844648642707444, 0.2824418889095708, 0.20100917108687422, 0.3155121101280457, 0.28665149872588935, 0.31820304757370055, 0.2743092023485094, 0.2887336729648683, 0.3230400399660591, 0.2565392050566746, 0.24175735583702296, 0.2655691809722298, 0.17181309747172124, 0.2671434598711161, 0.2633995745079636, 0.12766170768786655, 0.3017372473585824, 0.27233142619368633, 0.16204383721215376, 0.21317249833036933, 0.2116911629707653, 0.19786386504493514, 0.18332391239753432, 0.2112591395413157, 0.1891413980048372, 0.20136319668266356, 0.16015485507965455, 0.20337290578249745, 0.2998059034446423, 0.30936150784337957, 0.311092559023852, 0.27660185847544094, 0.30674058161188156, 0.29792753854348364, 0.3343852764112736, 0.28909805936008626, 0.3522661016959573, 0.054144042657344627, 0.050600728967152286, 0.05981721648934868, 0.129057344810392, 0.08956305816681576, 0.07158507421426819, 0.07142867068423053, 0.04090622544334965, 0.069254802841206, 0.2161508466376082, 0.20562652652198898, 0.21342186566241883, 0.19593610607366507, 0.18532826082956388, 0.2121505261806398, 0.17413673020164566, 0.19571436496958317, 0.20924711101144755, 0.5718238822743313, 0.5660227841679655, 0.5651368308436044, 0.5646615208718396, 0.5424938150812548, 0.5470477590309852, 0.5891418004380461, 0.5701562920043849, 0.5372732650060887, 0.09486674410354023, 0.08988863537792491, 0.10826617648695047, 0.09086191900962381, 0.0991966070793554, 0.0938843574933721, 0.09352050156329383, 0.1165118516684448, 0.10431854637145843, 0.19893318212406108, 0.3166329420085784, 0.33902114834949004, 0.2312280169533445, 0.19219419237188895, 0.34970373159224155, 0.3994469599522217, 0.2309596766227252, 0.3091474206557575, 0.3049057013823048, 0.3338334271055664, 0.32795134068512566, 0.3128527625897437, 0.3489738868942961, 0.31774040547283244, 0.3448193998051242, 0.3407964431503835, 0.32469812765672756, 0.23610605079476532, 0.27447623564014667, 0.2612397228686355, 0.26192232205574895, 0.24913874162570915, 0.2506545703842563, 0.2418420078342548, 0.27187113946709907, 0.2520922092412835, 0.20100217249040953, 0.2286958286250862, 0.18447671963032697, 0.19750859808465415, 0.17504821321935304, 0.17720796760330015, 0.20859485422185153, 0.19291397002364663, 0.21270194822755117, 0.20717538365489996, 0.20735763875764113, 0.20350592364576847, 0.20533649010906962, 0.22674721646967544, 0.20711415092615648, 0.2095123059421239, 0.23148801631230087, 0.18707284865855178, 0.1869169680094166, 0.12694814464456738, 0.15439087664599827, 0.829113052265307, 0.20092896441460228, 0.19911779331564805, 0.17755389895563656, 0.16316171504094013, 0.16300551599506596, 0.8049534283160587, 0.2125930570062745, 0.783559003699009, 0.08326079969868283, 0.16823179337313576, 0.1532145170727517, 0.11293377042261599, 0.21323051716020547, 0.7553762828506863, 0.17940381007538564, 0.18583335767415965, 0.2066320339358707, 0.19704157522284038, 0.1808682739759242, 0.18536706189583207, 0.19399167477313817, 0.18083675235635033, 0.19020917717132835, 0.09959636640040903, 0.08172650275366378, 0.07453836170510764, 0.07628269836644086, 0.08292669561862254, 0.07598912073182729, 0.08126916879775725, 0.09127601670127494, 0.084324156900484]}, "mutation_prompt": null}
{"id": "00cdefee-0730-4dd9-a354-0909a5df41e9", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.5 + np.random.rand() * 0.5):  # Dynamic F factor for mutation\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def adaptive_random_search(self):\n        perturbation = np.random.uniform(-0.5, 0.5, self.dim)\n        candidate = np.clip(self.population[self.global_best] + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.15:  # Increased chance to use adaptive random search\n                    trial = self.adaptive_random_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n                \n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.fitness[self.global_best]:\n                        self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with Adaptive Random Search and a dynamic mutation strategy for improved convergence speed.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "53ce667c-8043-4af9-b6f0-617727b059e7", "metadata": {"aucs": [0.7096250909303146, 0.697143818442316, 0.7119301495225946, 0.7112777682176713, 0.729718675027915, 0.7225620564111592, 0.7155957748916941, 0.7243004281067756, 0.7020405328395362, 0.3921181749915358, 0.37889314755031944, 0.37094970184493326, 0.40010068774384744, 0.4494453586285039, 0.398497220605743, 0.37142758903571516, 0.390487970238948, 0.4190169732305843, 0.1113338444116111, 0.10298344401721826, 0.10899264620109494, 0.11809778466749943, 0.10213644928941634, 0.09624475460419668, 0.1103837280465616, 0.1310177443781575, 0.1023648438347392, 0.10714281763583788, 0.11498749504499883, 0.11124069640980738, 0.10759105584052764, 0.09847182904399576, 0.11377384203870866, 0.11916946540722562, 0.09776089583817593, 0.09928311441229454, 0.9610044166467336, 0.9839029196852564, 0.9793769878401474, 0.976047386930374, 0.9733034980804924, 0.9620672724017689, 0.977887604215307, 0.9840952321230705, 0.9713033799446142, 0.3755601085484648, 0.3834863502305932, 0.3531704643915945, 0.36882054855688706, 0.34840421684215117, 0.3975775525298627, 0.3938298134339461, 0.39692870139197056, 0.3885706981075475, 0.7026442479190591, 0.6805350114625934, 0.6537604174045288, 0.7719066374409166, 0.73020049961519, 0.6208429757748491, 0.7097255255147011, 0.6067306429880441, 0.6844648642707444, 0.2824418889095708, 0.20100917108687422, 0.3155121101280457, 0.28665149872588935, 0.31820304757370055, 0.2743092023485094, 0.2887336729648683, 0.3230400399660591, 0.2565392050566746, 0.24175735583702296, 0.2655691809722298, 0.17181309747172124, 0.2671434598711161, 0.2633995745079636, 0.12766170768786655, 0.3017372473585824, 0.27233142619368633, 0.16204383721215376, 0.21317249833036933, 0.2116911629707653, 0.19786386504493514, 0.18332391239753432, 0.2112591395413157, 0.1891413980048372, 0.20136319668266356, 0.16015485507965455, 0.20337290578249745, 0.2998059034446423, 0.30936150784337957, 0.311092559023852, 0.27660185847544094, 0.30674058161188156, 0.29792753854348364, 0.3343852764112736, 0.28909805936008626, 0.3522661016959573, 0.054144042657344627, 0.050600728967152286, 0.05981721648934868, 0.129057344810392, 0.08956305816681576, 0.07158507421426819, 0.07142867068423053, 0.04090622544334965, 0.069254802841206, 0.2161508466376082, 0.20562652652198898, 0.21342186566241883, 0.19593610607366507, 0.18532826082956388, 0.2121505261806398, 0.17413673020164566, 0.19571436496958317, 0.20924711101144755, 0.5718238822743313, 0.5660227841679655, 0.5651368308436044, 0.5646615208718396, 0.5424938150812548, 0.5470477590309852, 0.5891418004380461, 0.5701562920043849, 0.5372732650060887, 0.09486674410354023, 0.08988863537792491, 0.10826617648695047, 0.09086191900962381, 0.0991966070793554, 0.0938843574933721, 0.09352050156329383, 0.1165118516684448, 0.10431854637145843, 0.19893318212406108, 0.3166329420085784, 0.33902114834949004, 0.2312280169533445, 0.19219419237188895, 0.34970373159224155, 0.3994469599522217, 0.2309596766227252, 0.3091474206557575, 0.3049057013823048, 0.3338334271055664, 0.32795134068512566, 0.3128527625897437, 0.3489738868942961, 0.31774040547283244, 0.3448193998051242, 0.3407964431503835, 0.32469812765672756, 0.23610605079476532, 0.27447623564014667, 0.2612397228686355, 0.26192232205574895, 0.24913874162570915, 0.2506545703842563, 0.2418420078342548, 0.27187113946709907, 0.2520922092412835, 0.20100217249040953, 0.2286958286250862, 0.18447671963032697, 0.19750859808465415, 0.17504821321935304, 0.17720796760330015, 0.20859485422185153, 0.19291397002364663, 0.21270194822755117, 0.20717538365489996, 0.20735763875764113, 0.20350592364576847, 0.20533649010906962, 0.22674721646967544, 0.20711415092615648, 0.2095123059421239, 0.23148801631230087, 0.18707284865855178, 0.1869169680094166, 0.12694814464456738, 0.15439087664599827, 0.829113052265307, 0.20092896441460228, 0.19911779331564805, 0.17755389895563656, 0.16316171504094013, 0.16300551599506596, 0.8049534283160587, 0.2125930570062745, 0.783559003699009, 0.08326079969868283, 0.16823179337313576, 0.1532145170727517, 0.11293377042261599, 0.21323051716020547, 0.7553762828506863, 0.17940381007538564, 0.18583335767415965, 0.2066320339358707, 0.19704157522284038, 0.1808682739759242, 0.18536706189583207, 0.19399167477313817, 0.18083675235635033, 0.19020917717132835, 0.09959636640040903, 0.08172650275366378, 0.07453836170510764, 0.07628269836644086, 0.08292669561862254, 0.07598912073182729, 0.08126916879775725, 0.09127601670127494, 0.084324156900484]}, "mutation_prompt": null}
{"id": "b5a10bed-181b-49d8-a65a-dda997ca9fce", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.5 + np.random.rand() * 0.5):  # Dynamic F factor for mutation\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def adaptive_random_search(self):\n        perturbation = np.random.uniform(-0.5, 0.5, self.dim)\n        candidate = np.clip(self.population[self.global_best] + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.15:  # Increased chance to use adaptive random search\n                    trial = self.adaptive_random_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n                \n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.fitness[self.global_best]:\n                        self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with Adaptive Random Search and a dynamic mutation strategy for improved convergence speed.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "53ce667c-8043-4af9-b6f0-617727b059e7", "metadata": {"aucs": [0.7096250909303146, 0.697143818442316, 0.7119301495225946, 0.7112777682176713, 0.729718675027915, 0.7225620564111592, 0.7155957748916941, 0.7243004281067756, 0.7020405328395362, 0.3921181749915358, 0.37889314755031944, 0.37094970184493326, 0.40010068774384744, 0.4494453586285039, 0.398497220605743, 0.37142758903571516, 0.390487970238948, 0.4190169732305843, 0.1113338444116111, 0.10298344401721826, 0.10899264620109494, 0.11809778466749943, 0.10213644928941634, 0.09624475460419668, 0.1103837280465616, 0.1310177443781575, 0.1023648438347392, 0.10714281763583788, 0.11498749504499883, 0.11124069640980738, 0.10759105584052764, 0.09847182904399576, 0.11377384203870866, 0.11916946540722562, 0.09776089583817593, 0.09928311441229454, 0.9610044166467336, 0.9839029196852564, 0.9793769878401474, 0.976047386930374, 0.9733034980804924, 0.9620672724017689, 0.977887604215307, 0.9840952321230705, 0.9713033799446142, 0.3755601085484648, 0.3834863502305932, 0.3531704643915945, 0.36882054855688706, 0.34840421684215117, 0.3975775525298627, 0.3938298134339461, 0.39692870139197056, 0.3885706981075475, 0.7026442479190591, 0.6805350114625934, 0.6537604174045288, 0.7719066374409166, 0.73020049961519, 0.6208429757748491, 0.7097255255147011, 0.6067306429880441, 0.6844648642707444, 0.2824418889095708, 0.20100917108687422, 0.3155121101280457, 0.28665149872588935, 0.31820304757370055, 0.2743092023485094, 0.2887336729648683, 0.3230400399660591, 0.2565392050566746, 0.24175735583702296, 0.2655691809722298, 0.17181309747172124, 0.2671434598711161, 0.2633995745079636, 0.12766170768786655, 0.3017372473585824, 0.27233142619368633, 0.16204383721215376, 0.21317249833036933, 0.2116911629707653, 0.19786386504493514, 0.18332391239753432, 0.2112591395413157, 0.1891413980048372, 0.20136319668266356, 0.16015485507965455, 0.20337290578249745, 0.2998059034446423, 0.30936150784337957, 0.311092559023852, 0.27660185847544094, 0.30674058161188156, 0.29792753854348364, 0.3343852764112736, 0.28909805936008626, 0.3522661016959573, 0.054144042657344627, 0.050600728967152286, 0.05981721648934868, 0.129057344810392, 0.08956305816681576, 0.07158507421426819, 0.07142867068423053, 0.04090622544334965, 0.069254802841206, 0.2161508466376082, 0.20562652652198898, 0.21342186566241883, 0.19593610607366507, 0.18532826082956388, 0.2121505261806398, 0.17413673020164566, 0.19571436496958317, 0.20924711101144755, 0.5718238822743313, 0.5660227841679655, 0.5651368308436044, 0.5646615208718396, 0.5424938150812548, 0.5470477590309852, 0.5891418004380461, 0.5701562920043849, 0.5372732650060887, 0.09486674410354023, 0.08988863537792491, 0.10826617648695047, 0.09086191900962381, 0.0991966070793554, 0.0938843574933721, 0.09352050156329383, 0.1165118516684448, 0.10431854637145843, 0.19893318212406108, 0.3166329420085784, 0.33902114834949004, 0.2312280169533445, 0.19219419237188895, 0.34970373159224155, 0.3994469599522217, 0.2309596766227252, 0.3091474206557575, 0.3049057013823048, 0.3338334271055664, 0.32795134068512566, 0.3128527625897437, 0.3489738868942961, 0.31774040547283244, 0.3448193998051242, 0.3407964431503835, 0.32469812765672756, 0.23610605079476532, 0.27447623564014667, 0.2612397228686355, 0.26192232205574895, 0.24913874162570915, 0.2506545703842563, 0.2418420078342548, 0.27187113946709907, 0.2520922092412835, 0.20100217249040953, 0.2286958286250862, 0.18447671963032697, 0.19750859808465415, 0.17504821321935304, 0.17720796760330015, 0.20859485422185153, 0.19291397002364663, 0.21270194822755117, 0.20717538365489996, 0.20735763875764113, 0.20350592364576847, 0.20533649010906962, 0.22674721646967544, 0.20711415092615648, 0.2095123059421239, 0.23148801631230087, 0.18707284865855178, 0.1869169680094166, 0.12694814464456738, 0.15439087664599827, 0.829113052265307, 0.20092896441460228, 0.19911779331564805, 0.17755389895563656, 0.16316171504094013, 0.16300551599506596, 0.8049534283160587, 0.2125930570062745, 0.783559003699009, 0.08326079969868283, 0.16823179337313576, 0.1532145170727517, 0.11293377042261599, 0.21323051716020547, 0.7553762828506863, 0.17940381007538564, 0.18583335767415965, 0.2066320339358707, 0.19704157522284038, 0.1808682739759242, 0.18536706189583207, 0.19399167477313817, 0.18083675235635033, 0.19020917717132835, 0.09959636640040903, 0.08172650275366378, 0.07453836170510764, 0.07628269836644086, 0.08292669561862254, 0.07598912073182729, 0.08126916879775725, 0.09127601670127494, 0.084324156900484]}, "mutation_prompt": null}
{"id": "9a450dd5-8755-4b03-823a-45a4c1005982", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolutionCompetitive:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.4 + np.random.rand() * 0.6):  # Adaptive F factor for mutation\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.85):  # Slightly adjusted CR for better diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def adaptive_random_search(self):\n        perturbation = np.random.uniform(-0.4, 0.4, self.dim)  # Adjusted perturbation range\n        candidate = np.clip(self.population[self.global_best] + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.2:  # Adjusted chance to use adaptive random search\n                    trial = self.adaptive_random_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "EnhancedDifferentialEvolutionCompetitive", "description": "Enhanced Differential Evolution with Competitive Selection and Adaptive Parameter Tuning for improved exploitation and exploration balance.", "configspace": "", "generation": 30, "fitness": 0.3756774813552089, "feedback": "The algorithm EnhancedDifferentialEvolutionCompetitive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.26.", "error": "", "parent_id": "53ce667c-8043-4af9-b6f0-617727b059e7", "metadata": {"aucs": [0.8495133406356231, 0.8466855067780171, 0.8513946570963247, 0.8556915906664728, 0.8508747765242319, 0.8313256708718615, 0.8588043967919298, 0.8558207819599282, 0.8402031023808564, 0.5937843203816686, 0.6206567150332712, 0.6566303118640022, 0.6429896478072117, 0.647561150095118, 0.6573618112310825, 0.6061636411460535, 0.681440254822538, 0.641483380720212, 0.12760909738244552, 0.14345946555952027, 0.21072612745566188, 0.15514896939455136, 0.13972684978093652, 0.11722127765687618, 0.1428735724982647, 0.5119195969265863, 0.1335196676432472, 0.1232043609205622, 0.12382214736356578, 0.12295404957714984, 0.1087966889999088, 0.13572913014562982, 0.1511738120581524, 0.1278881243949903, 0.11353815401379275, 0.1372419546110918, 0.9573142676820708, 0.9530001663972596, 0.9536849873471137, 0.9691416565251385, 0.9774221972800406, 0.9261215900578411, 0.9727345851412048, 0.9843542343393133, 0.9489600307846774, 0.5706473931003133, 0.5263466035348068, 0.5486952593813329, 0.5438335673087453, 0.5238917881866674, 0.5266731432733429, 0.5373338317665586, 0.5249167052308581, 0.5212305310157028, 0.6363248777089893, 0.7556220807077074, 0.22846412946655392, 0.830966751876892, 0.8435046327610771, 0.8088943926043503, 0.6428874948401168, 0.709281712838237, 0.6712664145495992, 0.52613887871172, 0.30604795298135046, 0.23986665994618983, 0.38141742087630637, 0.3267988104599897, 0.36383112666414885, 0.21388423291778547, 0.2106062929075877, 0.24799229104644216, 0.4362299618551474, 0.2480627320318901, 0.12938015146471316, 0.26246219177609664, 0.4159805863978878, 0.2048411749278436, 0.2644894007697426, 0.12129483581760647, 0.12672075684367268, 0.24305770642396474, 0.1924226399964486, 0.2923065930912927, 0.3205285508381919, 0.265864355153162, 0.13340776356457695, 0.34166341456197646, 0.20995361398640633, 0.2486738108371871, 0.47017389707433344, 0.4497762172373859, 0.44002080755220097, 0.368302638841984, 0.4085800807276453, 0.42932539302838035, 0.2695744228279866, 0.46894362265196865, 0.3266525961754392, 0.15332551835117325, 0.06330057551466473, 0.07864125582119919, 0.22109822106370958, 0.1623769432120844, 0.16412516768248642, 0.17337662737260018, 0.14645624223801246, 0.1367405475258482, 0.28178980831639966, 0.26351170610225727, 0.26336837614265174, 0.27372314010532917, 0.2712512744176909, 0.30504947940898264, 0.2822387068458595, 0.29196226772613676, 0.301156860031248, 0.6927570639471088, 0.6591172428269773, 0.6712536747642046, 0.6575510269241709, 0.6620173596840281, 0.6699359091675814, 0.655432007833028, 0.7220484320291843, 0.6790841374712753, 0.11934311323232905, 0.10142751386477555, 0.11715017690154272, 0.1121174016414872, 0.10969688469405414, 0.08796417776700183, 0.11881052099974132, 0.13618160185717443, 0.10202402783296205, 0.2707626687766582, 0.6022559453942372, 0.20831219444508464, 0.5092939168504723, 0.5964002503067694, 0.17651308315311398, 0.6201134962320644, 0.5100796048030397, 0.2623727986610591, 0.21231643067606998, 0.3772631662676055, 0.42468665750268586, 0.412567973177397, 0.4396799682178214, 0.23296224378829034, 0.46395125462648934, 0.4601853873909838, 0.4445041737141784, 0.2855967022955713, 0.24640596819318195, 0.29902517148118746, 0.264560743189969, 0.3271074453272367, 0.3412476068095335, 0.30773549548754275, 0.36637565293486674, 0.3323262625570056, 0.207838815229747, 0.21789308446664468, 0.21510383984593395, 0.22373675148021954, 0.20619641917398868, 0.20185197076238048, 0.2033250519412939, 0.2187049970219398, 0.20312226592432625, 0.535813488203994, 0.6741017459650877, 0.4554443268979236, 0.2467120148565527, 0.20923214475991403, 0.2337314258843275, 0.2530497786572433, 0.2511496973412298, 0.45453617798987567, 0.9136786457395403, 0.12725250276643219, 0.1548554778780613, 0.17355038433038683, 0.2018361053814146, 0.2009988335238726, 0.14297374742891167, 0.17042246595233534, 0.8927019435806154, 0.8713215836241923, 0.21342799392025302, 0.2094505201516419, 0.8209662230556729, 0.21139898162437798, 0.1688870937588257, 0.10534430330520461, 0.10480700262022369, 0.1679727434399425, 0.1833499815402414, 0.19515675001660315, 0.18460727008919675, 0.1859262605963654, 0.17936468176314102, 0.17905755814289293, 0.17593546244017455, 0.1937008247805394, 0.1944227514908241, 0.0911110980351667, 0.09373372619096498, 0.0802896952008525, 0.07900822268337071, 0.0937695611684849, 0.08696590780633029, 0.0883770580070865, 0.09478804872920932, 0.08764660011957659]}, "mutation_prompt": null}
{"id": "1e6a91a1-8c56-4895-a85e-ebd10c77d524", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolutionCompetitive:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n        self.mutation_factor = np.random.uniform(0.4, 0.9, self.pop_size)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self, idx):\n        indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, idx):\n        F = self.mutation_factor[idx]\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.85):\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def adaptive_random_search(self):\n        perturbation = np.random.uniform(-0.4, 0.4, self.dim)\n        candidate = np.clip(self.population[self.global_best] + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.25:\n                    trial = self.adaptive_random_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents(i)\n                    mutant = self.mutate(a, b, c, i)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "EnhancedDifferentialEvolutionCompetitive", "description": "Hybrid Differential Evolution with Enhanced Competitive Selection and Adaptive Mutation for accelerated convergence.", "configspace": "", "generation": 31, "fitness": 0.35745396155002496, "feedback": "The algorithm EnhancedDifferentialEvolutionCompetitive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.25.", "error": "", "parent_id": "9a450dd5-8755-4b03-823a-45a4c1005982", "metadata": {"aucs": [0.8148041894356249, 0.8088010469695361, 0.8050555472395751, 0.8368192947406647, 0.8170936029667735, 0.8134001778719424, 0.8321274359152668, 0.8133065773102156, 0.8040453431126285, 0.5697817052376338, 0.5509167898326739, 0.5261461621574104, 0.5496383337202491, 0.5633141493105577, 0.46969660067465335, 0.515117513299795, 0.5371777335134337, 0.541959698382037, 0.11519919490778374, 0.12639043066232825, 0.12842974547993868, 0.16318527905422486, 0.1297785782886811, 0.10965720312176386, 0.11640073591145561, 0.1619361488943334, 0.1152331226546659, 0.11478090879807312, 0.12048097871662777, 0.11541898449831312, 0.14266215032933882, 0.11225717217674513, 0.1321767406056531, 0.12877459007431735, 0.11904245097032673, 0.1385296916405414, 0.956974083675909, 0.9586193348883878, 0.9852753352083014, 0.9574227818485384, 0.9665438943095821, 0.9666865403583619, 0.9830343899821231, 0.9406428885585102, 0.9902251471077606, 0.47776363788559206, 0.45328371198937, 0.45333883547662435, 0.476987070392799, 0.4590191802165172, 0.44087135655722, 0.49350940801420573, 0.4644961408318288, 0.4821701823970084, 0.6892969651151333, 0.750192200852384, 0.7457890618058062, 0.8564874592154086, 0.8259752726319936, 0.8176532549037241, 0.630499713414568, 0.7425713769013366, 0.2365868726411794, 0.4638676144146632, 0.35978086125021647, 0.2977096558001242, 0.25636011236044376, 0.3266253268045365, 0.3269952824340743, 0.22323728284811872, 0.4257894681471983, 0.3231349479993775, 0.3016721320223791, 0.2815850163685233, 0.11891253476161523, 0.2601312885755527, 0.27800112927342946, 0.2952327012518322, 0.34967985614279784, 0.39302708438835265, 0.37950535971207344, 0.1822423232731072, 0.2465364654847344, 0.2567482227139638, 0.20723916486559057, 0.2216595059837123, 0.21715795767932955, 0.23407870003734088, 0.23613925817413572, 0.21703755038030226, 0.3422640489827161, 0.2905548310360835, 0.3434797756800625, 0.3871169931623669, 0.3374216474495907, 0.2812429970152397, 0.39514993491383443, 0.37149863873173095, 0.36333135583526777, 0.0719581573190613, 0.05725187174317248, 0.07797001855294206, 0.19886296105947843, 0.1302850700659165, 0.10703495949186359, 0.12351595756386546, 0.0748787931809547, 0.10557528266532312, 0.2559467624471333, 0.2232059785500573, 0.23014464536069712, 0.2487010839326892, 0.22522620637918866, 0.24673043689693552, 0.22249965778018077, 0.22111817330245986, 0.21813938782463838, 0.6483316730254964, 0.6221868371476738, 0.6142953709239293, 0.6373756608638775, 0.5777469410152332, 0.6188427908544221, 0.6312769729830454, 0.5881222075187085, 0.6323578050156482, 0.11606680528138802, 0.10044469870169215, 0.10507451974680793, 0.08132485621347263, 0.10149951721756678, 0.10882993661906115, 0.10850476879416349, 0.11378725814483259, 0.11754465757075017, 0.2668717102920177, 0.49405639046650307, 0.20429575571994552, 0.48334813346698213, 0.45789066804183065, 0.2906247312494178, 0.5177857394468159, 0.18985784816304552, 0.4737989811800266, 0.3413883207831424, 0.3685840543186558, 0.3582086467368252, 0.3939129444191929, 0.40244247079627804, 0.3640172505770788, 0.406288471109449, 0.41139172745170205, 0.38523374901229324, 0.28959606576175567, 0.2976832464406135, 0.3134874298693707, 0.29596673875539936, 0.2602824386437781, 0.25602715641551366, 0.3062878046151354, 0.3014670870418785, 0.31638753445364787, 0.19879701911215952, 0.24174821429487148, 0.21670144437740513, 0.2424741694348651, 0.18217601763261304, 0.19695150535998107, 0.22642860555387856, 0.22902589872410295, 0.22435372754199157, 0.24130142337224547, 0.22335331569527683, 0.20180274637498807, 0.24419359366547644, 0.21975545238726246, 0.23296148686491003, 0.23756344896427217, 0.2470142950590869, 0.23374329482712997, 0.18845544376102663, 0.12726237317365607, 0.8996578179025897, 0.1795036403046817, 0.2018109896189525, 0.20138720577258817, 0.9230678695021548, 0.17069002044953052, 0.917112569077585, 0.8442065278897686, 0.21408483910063247, 0.1565093130325984, 0.8153542252142606, 0.16967734984115723, 0.8148638819332251, 0.10539114001341099, 0.21381937004636198, 0.11334041702427289, 0.18765471235474074, 0.17666456587862378, 0.17834681846724976, 0.18384620371718274, 0.19050095399582045, 0.17734975511935958, 0.19100112357872823, 0.1848024838097132, 0.21120079272353431, 0.08553361524438274, 0.08009618523087503, 0.08303625530510306, 0.08214021846281772, 0.08651977521572407, 0.08751368884875688, 0.0808758384351459, 0.08846396765601405, 0.09452717926765564]}, "mutation_prompt": null}
{"id": "50b95c72-be93-4073-bf37-d92992593c02", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolutionCompetitive:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.4 + np.random.rand() * 0.6):  # Adaptive F factor for mutation\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.85):  # Slightly adjusted CR for better diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def adaptive_random_search(self):\n        perturbation = np.random.uniform(-0.4, 0.4, self.dim)  # Adjusted perturbation range\n        candidate = np.clip(self.population[self.global_best] + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.2:  # Adjusted chance to use adaptive random search\n                    trial = self.adaptive_random_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "EnhancedDifferentialEvolutionCompetitive", "description": "Enhanced Differential Evolution with Competitive Selection and Adaptive Parameter Tuning for improved exploitation and exploration balance.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9a450dd5-8755-4b03-823a-45a4c1005982", "metadata": {"aucs": [0.8495133406356231, 0.8466855067780171, 0.8513946570963247, 0.8556915906664728, 0.8508747765242319, 0.8313256708718615, 0.8588043967919298, 0.8558207819599282, 0.8402031023808564, 0.5937843203816686, 0.6206567150332712, 0.6566303118640022, 0.6429896478072117, 0.647561150095118, 0.6573618112310825, 0.6061636411460535, 0.681440254822538, 0.641483380720212, 0.12760909738244552, 0.14345946555952027, 0.21072612745566188, 0.15514896939455136, 0.13972684978093652, 0.11722127765687618, 0.1428735724982647, 0.5119195969265863, 0.1335196676432472, 0.1232043609205622, 0.12382214736356578, 0.12295404957714984, 0.1087966889999088, 0.13572913014562982, 0.1511738120581524, 0.1278881243949903, 0.11353815401379275, 0.1372419546110918, 0.9573142676820708, 0.9530001663972596, 0.9536849873471137, 0.9691416565251385, 0.9774221972800406, 0.9261215900578411, 0.9727345851412048, 0.9843542343393133, 0.9489600307846774, 0.5706473931003133, 0.5263466035348068, 0.5486952593813329, 0.5438335673087453, 0.5238917881866674, 0.5266731432733429, 0.5373338317665586, 0.5249167052308581, 0.5212305310157028, 0.6363248777089893, 0.7556220807077074, 0.22846412946655392, 0.830966751876892, 0.8435046327610771, 0.8088943926043503, 0.6428874948401168, 0.709281712838237, 0.6712664145495992, 0.52613887871172, 0.30604795298135046, 0.23986665994618983, 0.38141742087630637, 0.3267988104599897, 0.36383112666414885, 0.21388423291778547, 0.2106062929075877, 0.24799229104644216, 0.4362299618551474, 0.2480627320318901, 0.12938015146471316, 0.26246219177609664, 0.4159805863978878, 0.2048411749278436, 0.2644894007697426, 0.12129483581760647, 0.12672075684367268, 0.24305770642396474, 0.1924226399964486, 0.2923065930912927, 0.3205285508381919, 0.265864355153162, 0.13340776356457695, 0.34166341456197646, 0.20995361398640633, 0.2486738108371871, 0.47017389707433344, 0.4497762172373859, 0.44002080755220097, 0.368302638841984, 0.4085800807276453, 0.42932539302838035, 0.2695744228279866, 0.46894362265196865, 0.3266525961754392, 0.15332551835117325, 0.06330057551466473, 0.07864125582119919, 0.22109822106370958, 0.1623769432120844, 0.16412516768248642, 0.17337662737260018, 0.14645624223801246, 0.1367405475258482, 0.28178980831639966, 0.26351170610225727, 0.26336837614265174, 0.27372314010532917, 0.2712512744176909, 0.30504947940898264, 0.2822387068458595, 0.29196226772613676, 0.301156860031248, 0.6927570639471088, 0.6591172428269773, 0.6712536747642046, 0.6575510269241709, 0.6620173596840281, 0.6699359091675814, 0.655432007833028, 0.7220484320291843, 0.6790841374712753, 0.11934311323232905, 0.10142751386477555, 0.11715017690154272, 0.1121174016414872, 0.10969688469405414, 0.08796417776700183, 0.11881052099974132, 0.13618160185717443, 0.10202402783296205, 0.2707626687766582, 0.6022559453942372, 0.20831219444508464, 0.5092939168504723, 0.5964002503067694, 0.17651308315311398, 0.6201134962320644, 0.5100796048030397, 0.2623727986610591, 0.21231643067606998, 0.3772631662676055, 0.42468665750268586, 0.412567973177397, 0.4396799682178214, 0.23296224378829034, 0.46395125462648934, 0.4601853873909838, 0.4445041737141784, 0.2855967022955713, 0.24640596819318195, 0.29902517148118746, 0.264560743189969, 0.3271074453272367, 0.3412476068095335, 0.30773549548754275, 0.36637565293486674, 0.3323262625570056, 0.207838815229747, 0.21789308446664468, 0.21510383984593395, 0.22373675148021954, 0.20619641917398868, 0.20185197076238048, 0.2033250519412939, 0.2187049970219398, 0.20312226592432625, 0.535813488203994, 0.6741017459650877, 0.4554443268979236, 0.2467120148565527, 0.20923214475991403, 0.2337314258843275, 0.2530497786572433, 0.2511496973412298, 0.45453617798987567, 0.9136786457395403, 0.12725250276643219, 0.1548554778780613, 0.17355038433038683, 0.2018361053814146, 0.2009988335238726, 0.14297374742891167, 0.17042246595233534, 0.8927019435806154, 0.8713215836241923, 0.21342799392025302, 0.2094505201516419, 0.8209662230556729, 0.21139898162437798, 0.1688870937588257, 0.10534430330520461, 0.10480700262022369, 0.1679727434399425, 0.1833499815402414, 0.19515675001660315, 0.18460727008919675, 0.1859262605963654, 0.17936468176314102, 0.17905755814289293, 0.17593546244017455, 0.1937008247805394, 0.1944227514908241, 0.0911110980351667, 0.09373372619096498, 0.0802896952008525, 0.07900822268337071, 0.0937695611684849, 0.08696590780633029, 0.0883770580070865, 0.09478804872920932, 0.08764660011957659]}, "mutation_prompt": null}
{"id": "fd2eb238-b6b1-4e46-a6ae-1d4ca78247a5", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolutionCompetitive:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.4 + np.random.rand() * 0.6):\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.85):\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (np.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / abs(v) ** (1 / beta)\n        return step\n\n    def adaptive_search_intensification(self):\n        step_size = 0.2\n        levy_step = self.levy_flight()\n        perturbation = step_size * levy_step\n        candidate = np.clip(self.population[self.global_best] + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.3:  # Increased chance to use adaptive search\n                    trial = self.adaptive_search_intensification()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "EnhancedDifferentialEvolutionCompetitive", "description": "Incorporate Lévy flight-inspired adaptive search intensification and strategic population update to enhance convergence speed.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_id": "9a450dd5-8755-4b03-823a-45a4c1005982", "metadata": {}, "mutation_prompt": null}
{"id": "1e7e3c1c-3635-44e3-af7d-693fb9954138", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 9 * dim  # Slightly increased population size for diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.5 + np.random.rand() * 0.5):  # Adaptive F factor for mutation\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=None):  # Dynamic CR for better adaptability\n        if CR is None:\n            CR = 0.8 + 0.1 * (self.eval_count / self.budget)  # Dynamic crossover rate\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def adaptive_random_search(self):\n        perturbation = np.random.uniform(-0.5, 0.5, self.dim)  # Extended perturbation range\n        candidate = np.clip(self.population[self.global_best] + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.25:  # Increased chance to use adaptive random search\n                    trial = self.adaptive_random_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridDifferentialEvolution", "description": "Hybrid Differential Evolution with Adaptive Mutation and Dynamic Crossover for accelerated convergence.", "configspace": "", "generation": 34, "fitness": 0.31786214987371403, "feedback": "The algorithm HybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.", "error": "", "parent_id": "9a450dd5-8755-4b03-823a-45a4c1005982", "metadata": {"aucs": [0.797446908130264, 0.7525502757991107, 0.7425440320973471, 0.7500769011591693, 0.7560164652663612, 0.7569628587665744, 0.7317378396979186, 0.7554957671805523, 0.7607257342627703, 0.4527013746401639, 0.43686185245921383, 0.42645566382700084, 0.4253223565831541, 0.4172115863295076, 0.4625719495348638, 0.4581596443315775, 0.4376397761115294, 0.45225311639723287, 0.13844415578948266, 0.13487432097580243, 0.13387884478511136, 0.13397325077018007, 0.11389807839527544, 0.14175853556242946, 0.10220054352353014, 0.1624392626409843, 0.12962514998314223, 0.10872357331367388, 0.10210787198083415, 0.12693938919862935, 0.10931392496982184, 0.10504089156023533, 0.11210421147920135, 0.1118711147437913, 0.11386869311844927, 0.09681846166146901, 0.962880582038972, 0.9792556541363173, 0.9768940560501955, 0.9545396613164941, 0.9538312018674439, 0.9780539560990662, 0.9668082569140574, 0.9550863363970652, 0.9741431700680333, 0.40558975117436125, 0.3925570179325909, 0.37783767924833944, 0.37691778053296743, 0.36945089025530975, 0.37180310414519735, 0.3693397432647626, 0.3903545637006549, 0.3796398680419437, 0.6687140704390377, 0.6930473978553238, 0.6488570459189045, 0.8478492635710633, 0.6505975901715284, 0.7289735805641498, 0.5586935708355358, 0.665464635972711, 0.6525645272167846, 0.33495287084548575, 0.2549723534592664, 0.29351480519874573, 0.2500514853783916, 0.2664761382267865, 0.31275248664451893, 0.27995618855573634, 0.3482166199407457, 0.27337392213120837, 0.29067109442760053, 0.14985756928289917, 0.21650936436125945, 0.3214789659083278, 0.2435066800832747, 0.2877556190434488, 0.27042503709584875, 0.2528524640795423, 0.12630075523922502, 0.14933864980034672, 0.12382213506089279, 0.13737737621554458, 0.16732214604486506, 0.16857618951200604, 0.1631677071088523, 0.17272796171047589, 0.14259393195324843, 0.1671020718212083, 0.23042536026299842, 0.22403313235126698, 0.2872300117038695, 0.26567719790859423, 0.21471296614510116, 0.2665840968863945, 0.2559795412343032, 0.2790892966649777, 0.3116562698195817, 0.06066309718940688, 0.04114842786166262, 0.04446302136766411, 0.04727375310367732, 0.10574542427476552, 0.050493117260269726, 0.02755838015469958, 0.05710042638436352, 0.09554492625924171, 0.18660208876353568, 0.18914225181785027, 0.17742687534881352, 0.18688153830450105, 0.18672172208438842, 0.2053660632726394, 0.1770126666184868, 0.18683731454553187, 0.17016640745774148, 0.5473693285406608, 0.5875838492720575, 0.5684216528746402, 0.5375245405492965, 0.5509118851672268, 0.5670470317635098, 0.5660422344938225, 0.5261473139425121, 0.5477314974434695, 0.10755638482586805, 0.116269031546125, 0.11981190137149389, 0.10498566420841049, 0.1171832752739207, 0.10793686143084302, 0.11681204130370082, 0.1032142518350544, 0.09124506060283932, 0.3673046981788577, 0.3716100843635257, 0.19324504381657825, 0.24594894479337637, 0.3712780487204098, 0.29829179576119225, 0.43359884718074226, 0.3756376713107731, 0.250026943976848, 0.29489837321499046, 0.32416039952680953, 0.33831618843387745, 0.35332515493631467, 0.22469672073162206, 0.3240952286846791, 0.31591287866042783, 0.3399809147429864, 0.3408832305013261, 0.23914448095416618, 0.2830337083383958, 0.264105055999155, 0.25051913968379436, 0.2620024070006701, 0.28029825768571126, 0.2583270484334591, 0.2788470702569049, 0.2859663956811377, 0.22454401062360452, 0.1923407837106803, 0.20489538329801027, 0.19523109765062507, 0.19386990287881367, 0.20595239314655955, 0.21974207639412457, 0.24066045419211946, 0.21566303148634602, 0.3161106784466339, 0.20590726755278088, 0.3165338708511821, 0.20997597911866217, 0.2258989871127577, 0.21999738603384789, 0.234007435282511, 0.23436274664601442, 0.22633860063331745, 0.8429774464209596, 0.1729730209872261, 0.15480550568769214, 0.12705921980902335, 0.20130568821258799, 0.2009087660388078, 0.14341977721844434, 0.1706802332106616, 0.8911174762362375, 0.8127234757257812, 0.21441020221425466, 0.07355991619212487, 0.7807937528341219, 0.1697911786830587, 0.1548673717448621, 0.10539526644937636, 0.11300794545182757, 0.7394347252034116, 0.1834426843191742, 0.17735942754224288, 0.17677668813352743, 0.17867879306624979, 0.1808380448378084, 0.18923846445117964, 0.19508966799916905, 0.1722446814113997, 0.1847846788346995, 0.09281186466439817, 0.0836119484109491, 0.07843300880442616, 0.12167933525713193, 0.08663552080571646, 0.08219414508740996, 0.08897682097715043, 0.09250135298535156, 0.09486835680977057]}, "mutation_prompt": null}
{"id": "5d2ebae3-1554-4b4a-8e76-879d77df3a9d", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolutionCompetitive:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 10 * dim  # Slightly increased population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.5 + np.random.rand() * 0.5):  # Slightly adjusted adaptive F factor\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def gaussian_mutation(self, target, sigma=0.1):  # New Gaussian mutation\n        mutation = np.random.normal(0, sigma, self.dim)\n        return np.clip(target + mutation, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant, CR=0.9):  # Further adjusted CR\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search(self):\n        perturbation = np.random.uniform(-0.3, 0.3, self.dim)  # Adjusted perturbation range\n        candidate = np.clip(self.population[self.global_best] + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.3:  # Increased chance to use local search\n                    trial = self.local_search()\n                elif np.random.rand() < 0.2:  # Chance to use Gaussian mutation\n                    trial = self.gaussian_mutation(self.population[i])\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "EnhancedDifferentialEvolutionCompetitive", "description": "Hybrid Differential Evolution with Adaptive Gaussian Mutation and Local Search for enhanced convergence speed and accuracy.", "configspace": "", "generation": 35, "fitness": 0.26387040149490437, "feedback": "The algorithm EnhancedDifferentialEvolutionCompetitive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.21.", "error": "", "parent_id": "9a450dd5-8755-4b03-823a-45a4c1005982", "metadata": {"aucs": [0.5586110048856385, 0.5598818015016931, 0.5251056403581364, 0.5431167222363893, 0.5377884429588913, 0.5550770926483264, 0.5725744705213778, 0.5557290126445302, 0.5412747643280741, 0.13762779740728548, 0.16170670902588613, 0.16025428582751755, 0.15424508677060367, 0.17364657100496583, 0.1278338878106251, 0.14432070740558123, 0.15595280006990064, 0.15071513987857266, 0.10696051217467772, 0.11904868262120849, 0.1462147868836533, 0.1331430625726756, 0.14208943563633492, 0.10724098595595188, 0.1298365717114739, 0.1470294358591685, 0.1273827174187374, 0.11357185735651798, 0.11617119275363708, 0.10748470221181539, 0.1269926109905355, 0.10698447707781611, 0.11085706677342366, 0.11214744843569424, 0.09405432468935326, 0.12128541912776114, 0.9791591442168572, 0.993973027143187, 0.9776770354886525, 0.9661797303314493, 0.965995539567771, 0.970910915938703, 0.965056815100733, 0.9642774988551929, 0.9834480013459134, 0.32433634366611774, 0.32158014810553137, 0.2859150947985045, 0.3118256351964571, 0.34474331060733043, 0.31234790915405897, 0.33038141765006657, 0.31006496677454387, 0.33585010853102926, 0.5473793522802578, 0.5248784557927266, 0.6119882098020619, 0.4960417698274019, 0.2592639264261488, 0.6877551558256083, 0.44115065445838475, 0.5850650093622635, 0.6682057174175169, 0.22480890056008218, 0.18795194356207878, 0.23049022816153097, 0.13387538174080238, 0.23255033638828537, 0.21709358929226807, 0.19976590914677417, 0.2559877133864087, 0.1639236373764439, 0.2286746456690344, 0.2824724587400036, 0.21167040959831485, 0.1641086341957152, 0.22549206342266603, 0.190561116883176, 0.1800482421344194, 0.21920700867724896, 0.11925702961797946, 0.09510511588937975, 0.07394779534377738, 0.10633330394309237, 0.10362916128910382, 0.06454264410245358, 0.10705054587464058, 0.08150393764469699, 0.0683216580289292, 0.052273491280490414, 0.24907274933148482, 0.19094868273487187, 0.21157681979035947, 0.18591718122895695, 0.22378904940796196, 0.17417228861598377, 0.214808249941827, 0.21491145419945046, 0.2229525922609661, 0.0007265691119626716, 0.0053385714416026575, 0.008526608673579683, 0.018525109370012394, 0.0035706305572071884, 0.0094763572399863, 0.029504777713208696, 0.011430606192676218, 0.015979328880135868, 0.1434305010880529, 0.13230160132996172, 0.14419340700772154, 0.1503577444374603, 0.13463241132949821, 0.14841734418624197, 0.1472245197784483, 0.13792597355946223, 0.13747985291532383, 0.4543042580419576, 0.49396361914044395, 0.4672207311287788, 0.4489755960420678, 0.4613963558337457, 0.46260265588150173, 0.45589876667275664, 0.4704984878830164, 0.47773048212634817, 0.11723255339584282, 0.13918503994708376, 0.11206558613866946, 0.13582202911594543, 0.09779798281564367, 0.09595830763343038, 0.09972352389275474, 0.1281010492572432, 0.12096598138785297, 0.27558557561335095, 0.297820764104594, 0.1901698533074192, 0.2766944036355602, 0.27726823373245657, 0.2936305896977657, 0.33869046506332157, 0.2751396486165769, 0.3215068743443691, 0.29160037835040853, 0.2954246515447919, 0.294607948455202, 0.2974471350095257, 0.21254052454086936, 0.3196717306459095, 0.3146220085259055, 0.31215988121109306, 0.30718972571122205, 0.2280374256627138, 0.19269504328800646, 0.23558509130627192, 0.25272748291562575, 0.2310651176960108, 0.2442633092735862, 0.24406787308413946, 0.2428509843485157, 0.23871443603468168, 0.1907758747514775, 0.2259774575884066, 0.21207330067764074, 0.2108534215238448, 0.19313591311335154, 0.1820108136612758, 0.2102729864095596, 0.2148450751953772, 0.21001117828684523, 0.28725280300566836, 0.19802523562050833, 0.23632506984197388, 0.3400335671193959, 0.2317258122637157, 0.23969460880681281, 0.24500329447762492, 0.22634001868768805, 0.2206737580431909, 0.16363272561946118, 0.12736673494780804, 0.15487268992314873, 0.7975260543778476, 0.20218933200571798, 0.20137962769603124, 0.1736446467421452, 0.16475686074261253, 0.2121399167978527, 0.7209076839787589, 0.21399331285762435, 0.07361081669002723, 0.16839322527928868, 0.6939561929081515, 0.1567422922658911, 0.2139705907109195, 0.10514227869551851, 0.7012593157078002, 0.17964508344048058, 0.18590623484211932, 0.1885527840745128, 0.17359586726948129, 0.20614672824175218, 0.1932221825795174, 0.17647735863259473, 0.18081079467018657, 0.19783302895111976, 0.08852677195380476, 0.09174903703004855, 0.09520152787318525, 0.07892365881573138, 0.09464941891034506, 0.08770246750658184, 0.08683273015255144, 0.09958726729561462, 0.09166312611067684]}, "mutation_prompt": null}
{"id": "db5181d3-fa14-4b2d-ade2-c8a1f4ecb6cc", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolutionCompetitive:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.4 + np.random.rand() * 0.6):  # Adaptive F factor for mutation\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.85):  # Slightly adjusted CR for better diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def adaptive_random_search(self):\n        perturbation = np.random.uniform(-0.4, 0.4, self.dim)  # Adjusted perturbation range\n        candidate = np.clip(self.population[self.global_best] + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.2:  # Adjusted chance to use adaptive random search\n                    trial = self.adaptive_random_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "EnhancedDifferentialEvolutionCompetitive", "description": "Enhanced Differential Evolution with Competitive Selection and Adaptive Parameter Tuning for improved exploitation and exploration balance.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9a450dd5-8755-4b03-823a-45a4c1005982", "metadata": {"aucs": [0.8495133406356231, 0.8466855067780171, 0.8513946570963247, 0.8556915906664728, 0.8508747765242319, 0.8313256708718615, 0.8588043967919298, 0.8558207819599282, 0.8402031023808564, 0.5937843203816686, 0.6206567150332712, 0.6566303118640022, 0.6429896478072117, 0.647561150095118, 0.6573618112310825, 0.6061636411460535, 0.681440254822538, 0.641483380720212, 0.12760909738244552, 0.14345946555952027, 0.21072612745566188, 0.15514896939455136, 0.13972684978093652, 0.11722127765687618, 0.1428735724982647, 0.5119195969265863, 0.1335196676432472, 0.1232043609205622, 0.12382214736356578, 0.12295404957714984, 0.1087966889999088, 0.13572913014562982, 0.1511738120581524, 0.1278881243949903, 0.11353815401379275, 0.1372419546110918, 0.9573142676820708, 0.9530001663972596, 0.9536849873471137, 0.9691416565251385, 0.9774221972800406, 0.9261215900578411, 0.9727345851412048, 0.9843542343393133, 0.9489600307846774, 0.5706473931003133, 0.5263466035348068, 0.5486952593813329, 0.5438335673087453, 0.5238917881866674, 0.5266731432733429, 0.5373338317665586, 0.5249167052308581, 0.5212305310157028, 0.6363248777089893, 0.7556220807077074, 0.22846412946655392, 0.830966751876892, 0.8435046327610771, 0.8088943926043503, 0.6428874948401168, 0.709281712838237, 0.6712664145495992, 0.52613887871172, 0.30604795298135046, 0.23986665994618983, 0.38141742087630637, 0.3267988104599897, 0.36383112666414885, 0.21388423291778547, 0.2106062929075877, 0.24799229104644216, 0.4362299618551474, 0.2480627320318901, 0.12938015146471316, 0.26246219177609664, 0.4159805863978878, 0.2048411749278436, 0.2644894007697426, 0.12129483581760647, 0.12672075684367268, 0.24305770642396474, 0.1924226399964486, 0.2923065930912927, 0.3205285508381919, 0.265864355153162, 0.13340776356457695, 0.34166341456197646, 0.20995361398640633, 0.2486738108371871, 0.47017389707433344, 0.4497762172373859, 0.44002080755220097, 0.368302638841984, 0.4085800807276453, 0.42932539302838035, 0.2695744228279866, 0.46894362265196865, 0.3266525961754392, 0.15332551835117325, 0.06330057551466473, 0.07864125582119919, 0.22109822106370958, 0.1623769432120844, 0.16412516768248642, 0.17337662737260018, 0.14645624223801246, 0.1367405475258482, 0.28178980831639966, 0.26351170610225727, 0.26336837614265174, 0.27372314010532917, 0.2712512744176909, 0.30504947940898264, 0.2822387068458595, 0.29196226772613676, 0.301156860031248, 0.6927570639471088, 0.6591172428269773, 0.6712536747642046, 0.6575510269241709, 0.6620173596840281, 0.6699359091675814, 0.655432007833028, 0.7220484320291843, 0.6790841374712753, 0.11934311323232905, 0.10142751386477555, 0.11715017690154272, 0.1121174016414872, 0.10969688469405414, 0.08796417776700183, 0.11881052099974132, 0.13618160185717443, 0.10202402783296205, 0.2707626687766582, 0.6022559453942372, 0.20831219444508464, 0.5092939168504723, 0.5964002503067694, 0.17651308315311398, 0.6201134962320644, 0.5100796048030397, 0.2623727986610591, 0.21231643067606998, 0.3772631662676055, 0.42468665750268586, 0.412567973177397, 0.4396799682178214, 0.23296224378829034, 0.46395125462648934, 0.4601853873909838, 0.4445041737141784, 0.2855967022955713, 0.24640596819318195, 0.29902517148118746, 0.264560743189969, 0.3271074453272367, 0.3412476068095335, 0.30773549548754275, 0.36637565293486674, 0.3323262625570056, 0.207838815229747, 0.21789308446664468, 0.21510383984593395, 0.22373675148021954, 0.20619641917398868, 0.20185197076238048, 0.2033250519412939, 0.2187049970219398, 0.20312226592432625, 0.535813488203994, 0.6741017459650877, 0.4554443268979236, 0.2467120148565527, 0.20923214475991403, 0.2337314258843275, 0.2530497786572433, 0.2511496973412298, 0.45453617798987567, 0.9136786457395403, 0.12725250276643219, 0.1548554778780613, 0.17355038433038683, 0.2018361053814146, 0.2009988335238726, 0.14297374742891167, 0.17042246595233534, 0.8927019435806154, 0.8713215836241923, 0.21342799392025302, 0.2094505201516419, 0.8209662230556729, 0.21139898162437798, 0.1688870937588257, 0.10534430330520461, 0.10480700262022369, 0.1679727434399425, 0.1833499815402414, 0.19515675001660315, 0.18460727008919675, 0.1859262605963654, 0.17936468176314102, 0.17905755814289293, 0.17593546244017455, 0.1937008247805394, 0.1944227514908241, 0.0911110980351667, 0.09373372619096498, 0.0802896952008525, 0.07900822268337071, 0.0937695611684849, 0.08696590780633029, 0.0883770580070865, 0.09478804872920932, 0.08764660011957659]}, "mutation_prompt": null}
{"id": "8f957e05-17de-42de-8dbf-6743436e1f69", "solution": "import numpy as np\n\nclass ImprovedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = pop_size if pop_size is not None else 8 * dim\n        self.max_pop_size = int(self.initial_pop_size * 1.2)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_pop_size, dim))\n        self.fitness = np.full(self.initial_pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.population.shape[0]):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.population.shape[0], 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.5 + np.random.rand() * 0.5):  # Adjusted F factor for enhanced exploration\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):  # Slightly increased CR for enhanced diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def adaptive_random_search(self):\n        perturbation = np.random.uniform(-0.3, 0.3, self.dim)  # Adjusted perturbation range\n        candidate = np.clip(self.population[self.global_best] + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def dynamic_population_size(self):\n        new_size = min(self.max_pop_size, self.population.shape[0] + 1)\n        if new_size > self.population.shape[0]:\n            new_individual = np.random.uniform(self.lower_bound, self.upper_bound, (1, self.dim))\n            self.population = np.vstack([self.population, new_individual])\n            self.fitness = np.append(self.fitness, np.inf)\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            self.dynamic_population_size()\n            for i in range(self.population.shape[0]):\n                if np.random.rand() < 0.25:  # Adjusted chance to use adaptive random search\n                    trial = self.adaptive_random_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n                \n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "ImprovedAdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution with Dynamic Population Sizing and Enhanced Mutation for better convergence speed.", "configspace": "", "generation": 37, "fitness": 0.3495153639100726, "feedback": "The algorithm ImprovedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.24.", "error": "", "parent_id": "9a450dd5-8755-4b03-823a-45a4c1005982", "metadata": {"aucs": [0.7907246656187679, 0.7736960594946412, 0.7838765113003714, 0.7787608020579888, 0.7878034631234814, 0.8051297303987596, 0.7648104270225528, 0.7794448863208409, 0.7847166231449232, 0.4413699244417105, 0.46060924521954316, 0.43518729212716367, 0.48963144582729556, 0.4671045546433267, 0.4734456817714501, 0.4394789296233391, 0.4519952572365584, 0.38095073229467047, 0.13582805150814947, 0.1677883016096956, 0.19285968787097674, 0.10083106300229205, 0.13655438190414537, 0.12526692695376862, 0.13016581857734344, 0.14083251738699165, 0.12082971163955025, 0.10118384051547458, 0.10050252255804448, 0.114080434240033, 0.1093450682834246, 0.10400298715964273, 0.09579067627759819, 0.0674935872444119, 0.11460835034571537, 0.1136330465751273, 0.9797492541637939, 0.9855601082755981, 0.9891467262589881, 0.9807960689732698, 0.9743009886089771, 0.973266722188401, 0.9819490705916125, 0.968927906598175, 0.9727796571273196, 0.479763315363403, 0.44219748393060987, 0.4344899834418847, 0.4467340009630222, 0.4442448007942228, 0.43060300000452556, 0.4627732478673786, 0.4326382044226492, 0.44070892055672906, 0.8287112537135863, 0.7009020555317195, 0.7885992778789913, 0.7010162393140913, 0.7512133283405038, 0.7866919543629539, 0.7765345240157155, 0.6636415533973996, 0.8387093753871581, 0.47347141145063043, 0.24667270782656547, 0.41139377994031656, 0.4299256703824321, 0.45392134470900825, 0.3760257616625299, 0.3709853382075564, 0.36188375982708276, 0.30816351428758015, 0.4122585956695596, 0.2806811709620177, 0.28299537548379494, 0.3218416182520569, 0.35837086287099995, 0.2844729197698591, 0.25669162087198394, 0.22769707586353405, 0.12917866004305434, 0.2710787387428636, 0.23685006282805976, 0.20109597816868385, 0.29710217605380906, 0.26149286400767346, 0.2670377772986462, 0.22842530508372882, 0.23964913329411897, 0.2718927186729433, 0.36491714564337485, 0.33456548944934084, 0.4092857212339923, 0.40616391835822563, 0.32845458896014257, 0.2772524620402578, 0.3951516596440555, 0.38367291662548675, 0.4464189859688368, 0.0928484612712468, 0.09149658348542233, 0.07255287527405052, 0.1669541229994307, 0.15617770457929714, 0.14337585676711373, 0.10128465456374158, 0.08594915195166364, 0.16177531239494425, 0.2421107237494562, 0.23971225613629255, 0.2573195519910322, 0.253469873487312, 0.26542672980947424, 0.24733478132474362, 0.2573605074390617, 0.22282089603026123, 0.24265285605509745, 0.6418124904525262, 0.6225322228047179, 0.6181264875289079, 0.6427075905257478, 0.6302999457463463, 0.6043304314638138, 0.6362645507808535, 0.6556649611384973, 0.6332474920244779, 0.09779924369721926, 0.08295069060369564, 0.1071678948555389, 0.12011971211843397, 0.10676819961650785, 0.3001493017408313, 0.14181515706101255, 0.12198140829628734, 0.11694430101757025, 0.26913456956311177, 0.4321921626346762, 0.22130818601786728, 0.4412520481023685, 0.42772265882103944, 0.3550853957193566, 0.5607844999070095, 0.1739227921200398, 0.17694210136878374, 0.35840499214584665, 0.33490889399422885, 0.366821933741753, 0.37780171571216237, 0.3523830955256252, 0.36436733001209465, 0.36504194724124583, 0.39548015697502203, 0.40102598455031035, 0.26707579116091806, 0.27233398066839065, 0.27904565549913674, 0.2833722539380926, 0.2671884819572964, 0.2846683813432064, 0.27903083238975546, 0.3126319987070879, 0.2897611202124588, 0.21956512955030905, 0.21917729812915543, 0.202118638020915, 0.20117060948487653, 0.20246930422071197, 0.22392652756488984, 0.24313025067258554, 0.1995921194254302, 0.24469098026287583, 0.5293264771373287, 0.5384944504842791, 0.1965501304062871, 0.42701113397175394, 0.22141178898861957, 0.4404943644854772, 0.22278113328124893, 0.23822157161242408, 0.23559292766889794, 0.1733607509635371, 0.1271693931979817, 0.15452144378070576, 0.1735645986765525, 0.20186520786425477, 0.20081423631051531, 0.1433952013489901, 0.1706326357264647, 0.21248205620904848, 0.844197906763499, 0.2143769999188183, 0.21110877790614024, 0.10508327694395625, 0.16930069632692724, 0.21405307327898426, 0.10542990028785804, 0.17023120751064102, 0.8022230883471722, 0.17687171187374529, 0.18889958410421692, 0.17971956222536356, 0.18929377475035103, 0.20661012564812542, 0.18503118745969327, 0.19884607301457202, 0.18704891421012337, 0.18701386260003194, 0.08388641372376571, 0.09087577364685984, 0.06857315348340276, 0.09118167665356958, 0.09267446102255594, 0.10127255459957507, 0.082431041599761, 0.08919100577769679, 0.0812474430934077]}, "mutation_prompt": null}
{"id": "ae2fce93-6d36-4c40-9db6-35825b214ad3", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolutionCompetitive:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.4 + np.random.rand() * 0.6):  # Adaptive F factor for mutation\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.85):  # Slightly adjusted CR for better diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def adaptive_random_search(self):\n        perturbation = np.random.uniform(-0.4, 0.4, self.dim)  # Adjusted perturbation range\n        candidate = np.clip(self.population[self.global_best] + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.2:  # Adjusted chance to use adaptive random search\n                    trial = self.adaptive_random_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "EnhancedDifferentialEvolutionCompetitive", "description": "Enhanced Differential Evolution with Competitive Selection and Adaptive Parameter Tuning for improved exploitation and exploration balance.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9a450dd5-8755-4b03-823a-45a4c1005982", "metadata": {"aucs": [0.8495133406356231, 0.8466855067780171, 0.8513946570963247, 0.8556915906664728, 0.8508747765242319, 0.8313256708718615, 0.8588043967919298, 0.8558207819599282, 0.8402031023808564, 0.5937843203816686, 0.6206567150332712, 0.6566303118640022, 0.6429896478072117, 0.647561150095118, 0.6573618112310825, 0.6061636411460535, 0.681440254822538, 0.641483380720212, 0.12760909738244552, 0.14345946555952027, 0.21072612745566188, 0.15514896939455136, 0.13972684978093652, 0.11722127765687618, 0.1428735724982647, 0.5119195969265863, 0.1335196676432472, 0.1232043609205622, 0.12382214736356578, 0.12295404957714984, 0.1087966889999088, 0.13572913014562982, 0.1511738120581524, 0.1278881243949903, 0.11353815401379275, 0.1372419546110918, 0.9573142676820708, 0.9530001663972596, 0.9536849873471137, 0.9691416565251385, 0.9774221972800406, 0.9261215900578411, 0.9727345851412048, 0.9843542343393133, 0.9489600307846774, 0.5706473931003133, 0.5263466035348068, 0.5486952593813329, 0.5438335673087453, 0.5238917881866674, 0.5266731432733429, 0.5373338317665586, 0.5249167052308581, 0.5212305310157028, 0.6363248777089893, 0.7556220807077074, 0.22846412946655392, 0.830966751876892, 0.8435046327610771, 0.8088943926043503, 0.6428874948401168, 0.709281712838237, 0.6712664145495992, 0.52613887871172, 0.30604795298135046, 0.23986665994618983, 0.38141742087630637, 0.3267988104599897, 0.36383112666414885, 0.21388423291778547, 0.2106062929075877, 0.24799229104644216, 0.4362299618551474, 0.2480627320318901, 0.12938015146471316, 0.26246219177609664, 0.4159805863978878, 0.2048411749278436, 0.2644894007697426, 0.12129483581760647, 0.12672075684367268, 0.24305770642396474, 0.1924226399964486, 0.2923065930912927, 0.3205285508381919, 0.265864355153162, 0.13340776356457695, 0.34166341456197646, 0.20995361398640633, 0.2486738108371871, 0.47017389707433344, 0.4497762172373859, 0.44002080755220097, 0.368302638841984, 0.4085800807276453, 0.42932539302838035, 0.2695744228279866, 0.46894362265196865, 0.3266525961754392, 0.15332551835117325, 0.06330057551466473, 0.07864125582119919, 0.22109822106370958, 0.1623769432120844, 0.16412516768248642, 0.17337662737260018, 0.14645624223801246, 0.1367405475258482, 0.28178980831639966, 0.26351170610225727, 0.26336837614265174, 0.27372314010532917, 0.2712512744176909, 0.30504947940898264, 0.2822387068458595, 0.29196226772613676, 0.301156860031248, 0.6927570639471088, 0.6591172428269773, 0.6712536747642046, 0.6575510269241709, 0.6620173596840281, 0.6699359091675814, 0.655432007833028, 0.7220484320291843, 0.6790841374712753, 0.11934311323232905, 0.10142751386477555, 0.11715017690154272, 0.1121174016414872, 0.10969688469405414, 0.08796417776700183, 0.11881052099974132, 0.13618160185717443, 0.10202402783296205, 0.2707626687766582, 0.6022559453942372, 0.20831219444508464, 0.5092939168504723, 0.5964002503067694, 0.17651308315311398, 0.6201134962320644, 0.5100796048030397, 0.2623727986610591, 0.21231643067606998, 0.3772631662676055, 0.42468665750268586, 0.412567973177397, 0.4396799682178214, 0.23296224378829034, 0.46395125462648934, 0.4601853873909838, 0.4445041737141784, 0.2855967022955713, 0.24640596819318195, 0.29902517148118746, 0.264560743189969, 0.3271074453272367, 0.3412476068095335, 0.30773549548754275, 0.36637565293486674, 0.3323262625570056, 0.207838815229747, 0.21789308446664468, 0.21510383984593395, 0.22373675148021954, 0.20619641917398868, 0.20185197076238048, 0.2033250519412939, 0.2187049970219398, 0.20312226592432625, 0.535813488203994, 0.6741017459650877, 0.4554443268979236, 0.2467120148565527, 0.20923214475991403, 0.2337314258843275, 0.2530497786572433, 0.2511496973412298, 0.45453617798987567, 0.9136786457395403, 0.12725250276643219, 0.1548554778780613, 0.17355038433038683, 0.2018361053814146, 0.2009988335238726, 0.14297374742891167, 0.17042246595233534, 0.8927019435806154, 0.8713215836241923, 0.21342799392025302, 0.2094505201516419, 0.8209662230556729, 0.21139898162437798, 0.1688870937588257, 0.10534430330520461, 0.10480700262022369, 0.1679727434399425, 0.1833499815402414, 0.19515675001660315, 0.18460727008919675, 0.1859262605963654, 0.17936468176314102, 0.17905755814289293, 0.17593546244017455, 0.1937008247805394, 0.1944227514908241, 0.0911110980351667, 0.09373372619096498, 0.0802896952008525, 0.07900822268337071, 0.0937695611684849, 0.08696590780633029, 0.0883770580070865, 0.09478804872920932, 0.08764660011957659]}, "mutation_prompt": null}
{"id": "24d8e621-e41f-48a4-8a00-4a593872e4cb", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolutionCompetitive:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.4 + np.random.rand() * 0.6):  # Adaptive F factor for mutation\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.85):  # Slightly adjusted CR for better diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def adaptive_random_search(self):\n        perturbation = np.random.uniform(-0.4, 0.4, self.dim)  # Adjusted perturbation range\n        candidate = np.clip(self.population[self.global_best] + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.2:  # Adjusted chance to use adaptive random search\n                    trial = self.adaptive_random_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "EnhancedDifferentialEvolutionCompetitive", "description": "Enhanced Differential Evolution with Competitive Selection and Adaptive Parameter Tuning for improved exploitation and exploration balance.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9a450dd5-8755-4b03-823a-45a4c1005982", "metadata": {"aucs": [0.8495133406356231, 0.8466855067780171, 0.8513946570963247, 0.8556915906664728, 0.8508747765242319, 0.8313256708718615, 0.8588043967919298, 0.8558207819599282, 0.8402031023808564, 0.5937843203816686, 0.6206567150332712, 0.6566303118640022, 0.6429896478072117, 0.647561150095118, 0.6573618112310825, 0.6061636411460535, 0.681440254822538, 0.641483380720212, 0.12760909738244552, 0.14345946555952027, 0.21072612745566188, 0.15514896939455136, 0.13972684978093652, 0.11722127765687618, 0.1428735724982647, 0.5119195969265863, 0.1335196676432472, 0.1232043609205622, 0.12382214736356578, 0.12295404957714984, 0.1087966889999088, 0.13572913014562982, 0.1511738120581524, 0.1278881243949903, 0.11353815401379275, 0.1372419546110918, 0.9573142676820708, 0.9530001663972596, 0.9536849873471137, 0.9691416565251385, 0.9774221972800406, 0.9261215900578411, 0.9727345851412048, 0.9843542343393133, 0.9489600307846774, 0.5706473931003133, 0.5263466035348068, 0.5486952593813329, 0.5438335673087453, 0.5238917881866674, 0.5266731432733429, 0.5373338317665586, 0.5249167052308581, 0.5212305310157028, 0.6363248777089893, 0.7556220807077074, 0.22846412946655392, 0.830966751876892, 0.8435046327610771, 0.8088943926043503, 0.6428874948401168, 0.709281712838237, 0.6712664145495992, 0.52613887871172, 0.30604795298135046, 0.23986665994618983, 0.38141742087630637, 0.3267988104599897, 0.36383112666414885, 0.21388423291778547, 0.2106062929075877, 0.24799229104644216, 0.4362299618551474, 0.2480627320318901, 0.12938015146471316, 0.26246219177609664, 0.4159805863978878, 0.2048411749278436, 0.2644894007697426, 0.12129483581760647, 0.12672075684367268, 0.24305770642396474, 0.1924226399964486, 0.2923065930912927, 0.3205285508381919, 0.265864355153162, 0.13340776356457695, 0.34166341456197646, 0.20995361398640633, 0.2486738108371871, 0.47017389707433344, 0.4497762172373859, 0.44002080755220097, 0.368302638841984, 0.4085800807276453, 0.42932539302838035, 0.2695744228279866, 0.46894362265196865, 0.3266525961754392, 0.15332551835117325, 0.06330057551466473, 0.07864125582119919, 0.22109822106370958, 0.1623769432120844, 0.16412516768248642, 0.17337662737260018, 0.14645624223801246, 0.1367405475258482, 0.28178980831639966, 0.26351170610225727, 0.26336837614265174, 0.27372314010532917, 0.2712512744176909, 0.30504947940898264, 0.2822387068458595, 0.29196226772613676, 0.301156860031248, 0.6927570639471088, 0.6591172428269773, 0.6712536747642046, 0.6575510269241709, 0.6620173596840281, 0.6699359091675814, 0.655432007833028, 0.7220484320291843, 0.6790841374712753, 0.11934311323232905, 0.10142751386477555, 0.11715017690154272, 0.1121174016414872, 0.10969688469405414, 0.08796417776700183, 0.11881052099974132, 0.13618160185717443, 0.10202402783296205, 0.2707626687766582, 0.6022559453942372, 0.20831219444508464, 0.5092939168504723, 0.5964002503067694, 0.17651308315311398, 0.6201134962320644, 0.5100796048030397, 0.2623727986610591, 0.21231643067606998, 0.3772631662676055, 0.42468665750268586, 0.412567973177397, 0.4396799682178214, 0.23296224378829034, 0.46395125462648934, 0.4601853873909838, 0.4445041737141784, 0.2855967022955713, 0.24640596819318195, 0.29902517148118746, 0.264560743189969, 0.3271074453272367, 0.3412476068095335, 0.30773549548754275, 0.36637565293486674, 0.3323262625570056, 0.207838815229747, 0.21789308446664468, 0.21510383984593395, 0.22373675148021954, 0.20619641917398868, 0.20185197076238048, 0.2033250519412939, 0.2187049970219398, 0.20312226592432625, 0.535813488203994, 0.6741017459650877, 0.4554443268979236, 0.2467120148565527, 0.20923214475991403, 0.2337314258843275, 0.2530497786572433, 0.2511496973412298, 0.45453617798987567, 0.9136786457395403, 0.12725250276643219, 0.1548554778780613, 0.17355038433038683, 0.2018361053814146, 0.2009988335238726, 0.14297374742891167, 0.17042246595233534, 0.8927019435806154, 0.8713215836241923, 0.21342799392025302, 0.2094505201516419, 0.8209662230556729, 0.21139898162437798, 0.1688870937588257, 0.10534430330520461, 0.10480700262022369, 0.1679727434399425, 0.1833499815402414, 0.19515675001660315, 0.18460727008919675, 0.1859262605963654, 0.17936468176314102, 0.17905755814289293, 0.17593546244017455, 0.1937008247805394, 0.1944227514908241, 0.0911110980351667, 0.09373372619096498, 0.0802896952008525, 0.07900822268337071, 0.0937695611684849, 0.08696590780633029, 0.0883770580070865, 0.09478804872920932, 0.08764660011957659]}, "mutation_prompt": null}
{"id": "489a54cb-34e5-4416-8537-703b766bd9db", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolutionCompetitive:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.4 + np.random.rand() * 0.6):  # Adaptive F factor for mutation\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.85):  # Slightly adjusted CR for better diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def adaptive_random_search(self):\n        perturbation = np.random.uniform(-0.4, 0.4, self.dim)  # Adjusted perturbation range\n        candidate = np.clip(self.population[self.global_best] + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.2:  # Adjusted chance to use adaptive random search\n                    trial = self.adaptive_random_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "EnhancedDifferentialEvolutionCompetitive", "description": "Enhanced Differential Evolution with Competitive Selection and Adaptive Parameter Tuning for improved exploitation and exploration balance.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9a450dd5-8755-4b03-823a-45a4c1005982", "metadata": {"aucs": [0.8495133406356231, 0.8466855067780171, 0.8513946570963247, 0.8556915906664728, 0.8508747765242319, 0.8313256708718615, 0.8588043967919298, 0.8558207819599282, 0.8402031023808564, 0.5937843203816686, 0.6206567150332712, 0.6566303118640022, 0.6429896478072117, 0.647561150095118, 0.6573618112310825, 0.6061636411460535, 0.681440254822538, 0.641483380720212, 0.12760909738244552, 0.14345946555952027, 0.21072612745566188, 0.15514896939455136, 0.13972684978093652, 0.11722127765687618, 0.1428735724982647, 0.5119195969265863, 0.1335196676432472, 0.1232043609205622, 0.12382214736356578, 0.12295404957714984, 0.1087966889999088, 0.13572913014562982, 0.1511738120581524, 0.1278881243949903, 0.11353815401379275, 0.1372419546110918, 0.9573142676820708, 0.9530001663972596, 0.9536849873471137, 0.9691416565251385, 0.9774221972800406, 0.9261215900578411, 0.9727345851412048, 0.9843542343393133, 0.9489600307846774, 0.5706473931003133, 0.5263466035348068, 0.5486952593813329, 0.5438335673087453, 0.5238917881866674, 0.5266731432733429, 0.5373338317665586, 0.5249167052308581, 0.5212305310157028, 0.6363248777089893, 0.7556220807077074, 0.22846412946655392, 0.830966751876892, 0.8435046327610771, 0.8088943926043503, 0.6428874948401168, 0.709281712838237, 0.6712664145495992, 0.52613887871172, 0.30604795298135046, 0.23986665994618983, 0.38141742087630637, 0.3267988104599897, 0.36383112666414885, 0.21388423291778547, 0.2106062929075877, 0.24799229104644216, 0.4362299618551474, 0.2480627320318901, 0.12938015146471316, 0.26246219177609664, 0.4159805863978878, 0.2048411749278436, 0.2644894007697426, 0.12129483581760647, 0.12672075684367268, 0.24305770642396474, 0.1924226399964486, 0.2923065930912927, 0.3205285508381919, 0.265864355153162, 0.13340776356457695, 0.34166341456197646, 0.20995361398640633, 0.2486738108371871, 0.47017389707433344, 0.4497762172373859, 0.44002080755220097, 0.368302638841984, 0.4085800807276453, 0.42932539302838035, 0.2695744228279866, 0.46894362265196865, 0.3266525961754392, 0.15332551835117325, 0.06330057551466473, 0.07864125582119919, 0.22109822106370958, 0.1623769432120844, 0.16412516768248642, 0.17337662737260018, 0.14645624223801246, 0.1367405475258482, 0.28178980831639966, 0.26351170610225727, 0.26336837614265174, 0.27372314010532917, 0.2712512744176909, 0.30504947940898264, 0.2822387068458595, 0.29196226772613676, 0.301156860031248, 0.6927570639471088, 0.6591172428269773, 0.6712536747642046, 0.6575510269241709, 0.6620173596840281, 0.6699359091675814, 0.655432007833028, 0.7220484320291843, 0.6790841374712753, 0.11934311323232905, 0.10142751386477555, 0.11715017690154272, 0.1121174016414872, 0.10969688469405414, 0.08796417776700183, 0.11881052099974132, 0.13618160185717443, 0.10202402783296205, 0.2707626687766582, 0.6022559453942372, 0.20831219444508464, 0.5092939168504723, 0.5964002503067694, 0.17651308315311398, 0.6201134962320644, 0.5100796048030397, 0.2623727986610591, 0.21231643067606998, 0.3772631662676055, 0.42468665750268586, 0.412567973177397, 0.4396799682178214, 0.23296224378829034, 0.46395125462648934, 0.4601853873909838, 0.4445041737141784, 0.2855967022955713, 0.24640596819318195, 0.29902517148118746, 0.264560743189969, 0.3271074453272367, 0.3412476068095335, 0.30773549548754275, 0.36637565293486674, 0.3323262625570056, 0.207838815229747, 0.21789308446664468, 0.21510383984593395, 0.22373675148021954, 0.20619641917398868, 0.20185197076238048, 0.2033250519412939, 0.2187049970219398, 0.20312226592432625, 0.535813488203994, 0.6741017459650877, 0.4554443268979236, 0.2467120148565527, 0.20923214475991403, 0.2337314258843275, 0.2530497786572433, 0.2511496973412298, 0.45453617798987567, 0.9136786457395403, 0.12725250276643219, 0.1548554778780613, 0.17355038433038683, 0.2018361053814146, 0.2009988335238726, 0.14297374742891167, 0.17042246595233534, 0.8927019435806154, 0.8713215836241923, 0.21342799392025302, 0.2094505201516419, 0.8209662230556729, 0.21139898162437798, 0.1688870937588257, 0.10534430330520461, 0.10480700262022369, 0.1679727434399425, 0.1833499815402414, 0.19515675001660315, 0.18460727008919675, 0.1859262605963654, 0.17936468176314102, 0.17905755814289293, 0.17593546244017455, 0.1937008247805394, 0.1944227514908241, 0.0911110980351667, 0.09373372619096498, 0.0802896952008525, 0.07900822268337071, 0.0937695611684849, 0.08696590780633029, 0.0883770580070865, 0.09478804872920932, 0.08764660011957659]}, "mutation_prompt": null}
{"id": "0c0af4ef-4dc6-43fc-a809-97c5b3345381", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolutionCompetitive:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.4 + np.random.rand() * 0.6):  # Adaptive F factor for mutation\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.85):  # Slightly adjusted CR for better diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def adaptive_random_search(self):\n        perturbation = np.random.uniform(-0.4, 0.4, self.dim)  # Adjusted perturbation range\n        candidate = np.clip(self.population[self.global_best] + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.2:  # Adjusted chance to use adaptive random search\n                    trial = self.adaptive_random_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "EnhancedDifferentialEvolutionCompetitive", "description": "Enhanced Differential Evolution with Competitive Selection and Adaptive Parameter Tuning for improved exploitation and exploration balance.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9a450dd5-8755-4b03-823a-45a4c1005982", "metadata": {"aucs": [0.8495133406356231, 0.8466855067780171, 0.8513946570963247, 0.8556915906664728, 0.8508747765242319, 0.8313256708718615, 0.8588043967919298, 0.8558207819599282, 0.8402031023808564, 0.5937843203816686, 0.6206567150332712, 0.6566303118640022, 0.6429896478072117, 0.647561150095118, 0.6573618112310825, 0.6061636411460535, 0.681440254822538, 0.641483380720212, 0.12760909738244552, 0.14345946555952027, 0.21072612745566188, 0.15514896939455136, 0.13972684978093652, 0.11722127765687618, 0.1428735724982647, 0.5119195969265863, 0.1335196676432472, 0.1232043609205622, 0.12382214736356578, 0.12295404957714984, 0.1087966889999088, 0.13572913014562982, 0.1511738120581524, 0.1278881243949903, 0.11353815401379275, 0.1372419546110918, 0.9573142676820708, 0.9530001663972596, 0.9536849873471137, 0.9691416565251385, 0.9774221972800406, 0.9261215900578411, 0.9727345851412048, 0.9843542343393133, 0.9489600307846774, 0.5706473931003133, 0.5263466035348068, 0.5486952593813329, 0.5438335673087453, 0.5238917881866674, 0.5266731432733429, 0.5373338317665586, 0.5249167052308581, 0.5212305310157028, 0.6363248777089893, 0.7556220807077074, 0.22846412946655392, 0.830966751876892, 0.8435046327610771, 0.8088943926043503, 0.6428874948401168, 0.709281712838237, 0.6712664145495992, 0.52613887871172, 0.30604795298135046, 0.23986665994618983, 0.38141742087630637, 0.3267988104599897, 0.36383112666414885, 0.21388423291778547, 0.2106062929075877, 0.24799229104644216, 0.4362299618551474, 0.2480627320318901, 0.12938015146471316, 0.26246219177609664, 0.4159805863978878, 0.2048411749278436, 0.2644894007697426, 0.12129483581760647, 0.12672075684367268, 0.24305770642396474, 0.1924226399964486, 0.2923065930912927, 0.3205285508381919, 0.265864355153162, 0.13340776356457695, 0.34166341456197646, 0.20995361398640633, 0.2486738108371871, 0.47017389707433344, 0.4497762172373859, 0.44002080755220097, 0.368302638841984, 0.4085800807276453, 0.42932539302838035, 0.2695744228279866, 0.46894362265196865, 0.3266525961754392, 0.15332551835117325, 0.06330057551466473, 0.07864125582119919, 0.22109822106370958, 0.1623769432120844, 0.16412516768248642, 0.17337662737260018, 0.14645624223801246, 0.1367405475258482, 0.28178980831639966, 0.26351170610225727, 0.26336837614265174, 0.27372314010532917, 0.2712512744176909, 0.30504947940898264, 0.2822387068458595, 0.29196226772613676, 0.301156860031248, 0.6927570639471088, 0.6591172428269773, 0.6712536747642046, 0.6575510269241709, 0.6620173596840281, 0.6699359091675814, 0.655432007833028, 0.7220484320291843, 0.6790841374712753, 0.11934311323232905, 0.10142751386477555, 0.11715017690154272, 0.1121174016414872, 0.10969688469405414, 0.08796417776700183, 0.11881052099974132, 0.13618160185717443, 0.10202402783296205, 0.2707626687766582, 0.6022559453942372, 0.20831219444508464, 0.5092939168504723, 0.5964002503067694, 0.17651308315311398, 0.6201134962320644, 0.5100796048030397, 0.2623727986610591, 0.21231643067606998, 0.3772631662676055, 0.42468665750268586, 0.412567973177397, 0.4396799682178214, 0.23296224378829034, 0.46395125462648934, 0.4601853873909838, 0.4445041737141784, 0.2855967022955713, 0.24640596819318195, 0.29902517148118746, 0.264560743189969, 0.3271074453272367, 0.3412476068095335, 0.30773549548754275, 0.36637565293486674, 0.3323262625570056, 0.207838815229747, 0.21789308446664468, 0.21510383984593395, 0.22373675148021954, 0.20619641917398868, 0.20185197076238048, 0.2033250519412939, 0.2187049970219398, 0.20312226592432625, 0.535813488203994, 0.6741017459650877, 0.4554443268979236, 0.2467120148565527, 0.20923214475991403, 0.2337314258843275, 0.2530497786572433, 0.2511496973412298, 0.45453617798987567, 0.9136786457395403, 0.12725250276643219, 0.1548554778780613, 0.17355038433038683, 0.2018361053814146, 0.2009988335238726, 0.14297374742891167, 0.17042246595233534, 0.8927019435806154, 0.8713215836241923, 0.21342799392025302, 0.2094505201516419, 0.8209662230556729, 0.21139898162437798, 0.1688870937588257, 0.10534430330520461, 0.10480700262022369, 0.1679727434399425, 0.1833499815402414, 0.19515675001660315, 0.18460727008919675, 0.1859262605963654, 0.17936468176314102, 0.17905755814289293, 0.17593546244017455, 0.1937008247805394, 0.1944227514908241, 0.0911110980351667, 0.09373372619096498, 0.0802896952008525, 0.07900822268337071, 0.0937695611684849, 0.08696590780633029, 0.0883770580070865, 0.09478804872920932, 0.08764660011957659]}, "mutation_prompt": null}
{"id": "01047d4b-66cf-45e5-926f-929cf34f973f", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolutionCompetitive:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self, num_parents=4):\n        indices = np.random.choice(self.pop_size, num_parents, replace=False)\n        return self.population[indices]\n\n    def mutate(self, parents, F=0.5 + np.random.rand() * 0.5):  # Adjusted F factor\n        base = parents[0]\n        diff = np.sum(parents[1:] - base, axis=0)\n        mutant = np.clip(base + F * diff, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.75):  # Adjusted CR for better balance\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def adaptive_random_search(self):\n        perturbation = np.random.uniform(-0.3, 0.3, self.dim)  # Adjusted perturbation range\n        candidate = np.clip(self.population[self.global_best] + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def competitive_selection(self, trial, trial_fitness, target_idx, threshold=0.05):\n        if trial_fitness < self.fitness[target_idx] * (1.0 - threshold):  # Dynamic threshold\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.25:  # Adjusted chance for adaptive random search\n                    trial = self.adaptive_random_search()\n                else:\n                    target = self.population[i]\n                    parents = self.select_parents()\n                    mutant = self.mutate(parents)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "EnhancedDifferentialEvolutionCompetitive", "description": "Enhanced Differential Evolution with Multi-Parent Mutation and Dynamic Fitness Threshold for improved convergence and exploration-exploitation balance.", "configspace": "", "generation": 42, "fitness": 0.2090036574618049, "feedback": "The algorithm EnhancedDifferentialEvolutionCompetitive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": "9a450dd5-8755-4b03-823a-45a4c1005982", "metadata": {"aucs": [0.38736247314773986, 0.38600523381129437, 0.38847000145625665, 0.25737957475593165, 0.2557814785094813, 0.3205780202562887, 0.3654281844632209, 0.38109717578118596, 0.37401999841881206, 0.14376595645702583, 0.13655551992888848, 0.1677988949454826, 0.1302304706530396, 0.144747331695811, 0.15780653259639843, 0.1633141808183689, 0.14476651969432042, 0.17260713591789822, 0.09625468086640865, 0.10102422551687817, 0.1035491902236001, 0.10843041278470722, 0.1055566057800763, 0.11597829194829323, 0.09936056674938032, 0.13590318346577146, 0.14162401824590398, 0.08893673556758763, 0.08565300644237284, 0.09233181693308234, 0.10456828868564993, 0.11378530206857773, 0.08731481518815531, 0.078395820790651, 0.08720444091345292, 0.09322164200207683, 0.982289579180705, 0.9780592205492925, 0.9531805154616155, 0.9823198575774835, 0.8491927137146762, 0.9894239774249859, 0.9784076978265486, 0.9634271351186933, 0.9858189048321249, 0.2886084650736005, 0.2688818472332135, 0.25867962483429974, 0.2600372670462501, 0.26251197324885867, 0.28025122596836605, 0.2446974922086319, 0.2523992712538897, 0.2755379911637136, 0.23321955158954177, 0.21473687144071596, 0.2699172778690073, 0.3382638358763468, 0.23189514699171676, 0.21751815220338555, 0.333445074059728, 0.30640038667692826, 0.382578340024614, 0.19788356799501416, 0.16293937420771176, 0.15141191075201332, 0.14686230108152754, 0.17175399757151755, 0.15274993449393237, 0.14434759670624608, 0.11925923991738419, 0.1471987451816411, 0.11768012735919786, 0.16636955560181488, 0.18435487871836898, 0.14229268439988352, 0.16669237027897432, 0.15427863005132825, 0.13725394661108348, 0.10299295565995381, 0.14224601326502706, 0.06251535837876288, 0.036403411077906456, 0.03704330035256753, 0.03871115521633839, 0.026794432428436488, 0.019119375287057316, 0.045921670748202414, 0.05714334590492176, 0.04673155439001808, 0.13369958396446235, 0.10055376663436832, 0.1459842855886958, 0.15460754424267276, 0.11021995056675038, 0.12519956675467292, 0.13622146256078171, 0.09551341726989626, 0.13606140685108858, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007135223741439378, 9.999999999998899e-05, 9.999999999998899e-05, 0.12235704052249219, 0.1117587162066519, 0.10032128013901132, 0.1036658396860839, 0.11793845921782264, 0.13206207671699632, 0.09543486794483191, 0.09203967015378967, 0.09265725904102107, 0.36306683703361753, 0.3572753163996766, 0.3956365625103795, 0.3573617685541608, 0.3721454566058857, 0.37898709154176635, 0.3469457042361015, 0.29388892381777554, 0.3506439549711654, 0.07257959115326407, 0.06917807728805014, 0.0780587145004904, 0.11968013002310907, 0.08297033206406179, 0.08383927659573787, 0.10778613987140084, 0.11116677120387664, 0.11128328999929327, 0.2242417867314268, 0.23086433318354083, 0.24639655939722838, 0.22018692700338882, 0.23386905224731236, 0.17940838657811342, 0.259161845124649, 0.22168436542892012, 0.14602378519795134, 0.266485933659551, 0.27757445315771045, 0.27479207441852804, 0.307870213303041, 0.2614731356371639, 0.18173390644034437, 0.19760861892846004, 0.2697982881684873, 0.19813680491038166, 0.20761126782610628, 0.21603850886646947, 0.20028459435573276, 0.2261150151868947, 0.16379352553653537, 0.2253678899442696, 0.1640425468344643, 0.20849048452628127, 0.1922012711045077, 0.20122499496859947, 0.19513158166519795, 0.21470720586619207, 0.19781496904130813, 0.19078453370776582, 0.20869891570219756, 0.21907928688740674, 0.19648932110082173, 0.2030967746831921, 0.1950813541177977, 0.18603527240083995, 0.18300465129420773, 0.20809994942583832, 0.1889852184686095, 0.18408265045842231, 0.19462393866328997, 0.1938595654448262, 0.18518466129402, 0.1484536408969983, 0.1271041981150447, 0.15429098630336557, 0.18916124051393646, 0.20122473625407866, 0.2012363898316294, 0.1425916181471759, 0.17032947888395233, 0.5815928620285344, 0.5197199131606852, 0.21254474295139536, 0.4441707069344596, 0.1267322923158266, 0.1675194073826577, 0.11490310767858591, 0.2121860112843731, 0.1281189133774413, 0.1278115004081617, 0.17496019869000723, 0.2047159747790317, 0.19227862901109916, 0.190826907897517, 0.17958251047277352, 0.18286687189153128, 0.18871871145692354, 0.1879592684946777, 0.18871267472382125, 0.08136080091680109, 0.08425034670019815, 0.12449259660540102, 0.09258432623717161, 0.07645620358277705, 0.0818107784254345, 0.09502155094697351, 0.0810249715797714, 0.07605061024247972]}, "mutation_prompt": null}
{"id": "024032bb-edc4-49f4-9ac4-905f5a8bbf7b", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolutionCompetitive:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.4 + np.random.rand() * 0.6):  # Adaptive F factor for mutation\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.85):  # Slightly adjusted CR for better diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def adaptive_random_search(self):\n        perturbation = np.random.uniform(-0.4, 0.4, self.dim)  # Adjusted perturbation range\n        candidate = np.clip(self.population[self.global_best] + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.2:  # Adjusted chance to use adaptive random search\n                    trial = self.adaptive_random_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "EnhancedDifferentialEvolutionCompetitive", "description": "Enhanced Differential Evolution with Competitive Selection and Adaptive Parameter Tuning for improved exploitation and exploration balance.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9a450dd5-8755-4b03-823a-45a4c1005982", "metadata": {"aucs": [0.8495133406356231, 0.8466855067780171, 0.8513946570963247, 0.8556915906664728, 0.8508747765242319, 0.8313256708718615, 0.8588043967919298, 0.8558207819599282, 0.8402031023808564, 0.5937843203816686, 0.6206567150332712, 0.6566303118640022, 0.6429896478072117, 0.647561150095118, 0.6573618112310825, 0.6061636411460535, 0.681440254822538, 0.641483380720212, 0.12760909738244552, 0.14345946555952027, 0.21072612745566188, 0.15514896939455136, 0.13972684978093652, 0.11722127765687618, 0.1428735724982647, 0.5119195969265863, 0.1335196676432472, 0.1232043609205622, 0.12382214736356578, 0.12295404957714984, 0.1087966889999088, 0.13572913014562982, 0.1511738120581524, 0.1278881243949903, 0.11353815401379275, 0.1372419546110918, 0.9573142676820708, 0.9530001663972596, 0.9536849873471137, 0.9691416565251385, 0.9774221972800406, 0.9261215900578411, 0.9727345851412048, 0.9843542343393133, 0.9489600307846774, 0.5706473931003133, 0.5263466035348068, 0.5486952593813329, 0.5438335673087453, 0.5238917881866674, 0.5266731432733429, 0.5373338317665586, 0.5249167052308581, 0.5212305310157028, 0.6363248777089893, 0.7556220807077074, 0.22846412946655392, 0.830966751876892, 0.8435046327610771, 0.8088943926043503, 0.6428874948401168, 0.709281712838237, 0.6712664145495992, 0.52613887871172, 0.30604795298135046, 0.23986665994618983, 0.38141742087630637, 0.3267988104599897, 0.36383112666414885, 0.21388423291778547, 0.2106062929075877, 0.24799229104644216, 0.4362299618551474, 0.2480627320318901, 0.12938015146471316, 0.26246219177609664, 0.4159805863978878, 0.2048411749278436, 0.2644894007697426, 0.12129483581760647, 0.12672075684367268, 0.24305770642396474, 0.1924226399964486, 0.2923065930912927, 0.3205285508381919, 0.265864355153162, 0.13340776356457695, 0.34166341456197646, 0.20995361398640633, 0.2486738108371871, 0.47017389707433344, 0.4497762172373859, 0.44002080755220097, 0.368302638841984, 0.4085800807276453, 0.42932539302838035, 0.2695744228279866, 0.46894362265196865, 0.3266525961754392, 0.15332551835117325, 0.06330057551466473, 0.07864125582119919, 0.22109822106370958, 0.1623769432120844, 0.16412516768248642, 0.17337662737260018, 0.14645624223801246, 0.1367405475258482, 0.28178980831639966, 0.26351170610225727, 0.26336837614265174, 0.27372314010532917, 0.2712512744176909, 0.30504947940898264, 0.2822387068458595, 0.29196226772613676, 0.301156860031248, 0.6927570639471088, 0.6591172428269773, 0.6712536747642046, 0.6575510269241709, 0.6620173596840281, 0.6699359091675814, 0.655432007833028, 0.7220484320291843, 0.6790841374712753, 0.11934311323232905, 0.10142751386477555, 0.11715017690154272, 0.1121174016414872, 0.10969688469405414, 0.08796417776700183, 0.11881052099974132, 0.13618160185717443, 0.10202402783296205, 0.2707626687766582, 0.6022559453942372, 0.20831219444508464, 0.5092939168504723, 0.5964002503067694, 0.17651308315311398, 0.6201134962320644, 0.5100796048030397, 0.2623727986610591, 0.21231643067606998, 0.3772631662676055, 0.42468665750268586, 0.412567973177397, 0.4396799682178214, 0.23296224378829034, 0.46395125462648934, 0.4601853873909838, 0.4445041737141784, 0.2855967022955713, 0.24640596819318195, 0.29902517148118746, 0.264560743189969, 0.3271074453272367, 0.3412476068095335, 0.30773549548754275, 0.36637565293486674, 0.3323262625570056, 0.207838815229747, 0.21789308446664468, 0.21510383984593395, 0.22373675148021954, 0.20619641917398868, 0.20185197076238048, 0.2033250519412939, 0.2187049970219398, 0.20312226592432625, 0.535813488203994, 0.6741017459650877, 0.4554443268979236, 0.2467120148565527, 0.20923214475991403, 0.2337314258843275, 0.2530497786572433, 0.2511496973412298, 0.45453617798987567, 0.9136786457395403, 0.12725250276643219, 0.1548554778780613, 0.17355038433038683, 0.2018361053814146, 0.2009988335238726, 0.14297374742891167, 0.17042246595233534, 0.8927019435806154, 0.8713215836241923, 0.21342799392025302, 0.2094505201516419, 0.8209662230556729, 0.21139898162437798, 0.1688870937588257, 0.10534430330520461, 0.10480700262022369, 0.1679727434399425, 0.1833499815402414, 0.19515675001660315, 0.18460727008919675, 0.1859262605963654, 0.17936468176314102, 0.17905755814289293, 0.17593546244017455, 0.1937008247805394, 0.1944227514908241, 0.0911110980351667, 0.09373372619096498, 0.0802896952008525, 0.07900822268337071, 0.0937695611684849, 0.08696590780633029, 0.0883770580070865, 0.09478804872920932, 0.08764660011957659]}, "mutation_prompt": null}
{"id": "795945f1-2749-4958-942d-3bb76b69ddb9", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolutionCompetitive:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.4 + np.random.rand() * 0.6):  # Adaptive F factor for mutation\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.85):  # Slightly adjusted CR for better diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def adaptive_random_search(self):\n        perturbation = np.random.uniform(-0.4, 0.4, self.dim)  # Adjusted perturbation range\n        candidate = np.clip(self.population[self.global_best] + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.2:  # Adjusted chance to use adaptive random search\n                    trial = self.adaptive_random_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "EnhancedDifferentialEvolutionCompetitive", "description": "Enhanced Differential Evolution with Competitive Selection and Adaptive Parameter Tuning for improved exploitation and exploration balance.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9a450dd5-8755-4b03-823a-45a4c1005982", "metadata": {"aucs": [0.8495133406356231, 0.8466855067780171, 0.8513946570963247, 0.8556915906664728, 0.8508747765242319, 0.8313256708718615, 0.8588043967919298, 0.8558207819599282, 0.8402031023808564, 0.5937843203816686, 0.6206567150332712, 0.6566303118640022, 0.6429896478072117, 0.647561150095118, 0.6573618112310825, 0.6061636411460535, 0.681440254822538, 0.641483380720212, 0.12760909738244552, 0.14345946555952027, 0.21072612745566188, 0.15514896939455136, 0.13972684978093652, 0.11722127765687618, 0.1428735724982647, 0.5119195969265863, 0.1335196676432472, 0.1232043609205622, 0.12382214736356578, 0.12295404957714984, 0.1087966889999088, 0.13572913014562982, 0.1511738120581524, 0.1278881243949903, 0.11353815401379275, 0.1372419546110918, 0.9573142676820708, 0.9530001663972596, 0.9536849873471137, 0.9691416565251385, 0.9774221972800406, 0.9261215900578411, 0.9727345851412048, 0.9843542343393133, 0.9489600307846774, 0.5706473931003133, 0.5263466035348068, 0.5486952593813329, 0.5438335673087453, 0.5238917881866674, 0.5266731432733429, 0.5373338317665586, 0.5249167052308581, 0.5212305310157028, 0.6363248777089893, 0.7556220807077074, 0.22846412946655392, 0.830966751876892, 0.8435046327610771, 0.8088943926043503, 0.6428874948401168, 0.709281712838237, 0.6712664145495992, 0.52613887871172, 0.30604795298135046, 0.23986665994618983, 0.38141742087630637, 0.3267988104599897, 0.36383112666414885, 0.21388423291778547, 0.2106062929075877, 0.24799229104644216, 0.4362299618551474, 0.2480627320318901, 0.12938015146471316, 0.26246219177609664, 0.4159805863978878, 0.2048411749278436, 0.2644894007697426, 0.12129483581760647, 0.12672075684367268, 0.24305770642396474, 0.1924226399964486, 0.2923065930912927, 0.3205285508381919, 0.265864355153162, 0.13340776356457695, 0.34166341456197646, 0.20995361398640633, 0.2486738108371871, 0.47017389707433344, 0.4497762172373859, 0.44002080755220097, 0.368302638841984, 0.4085800807276453, 0.42932539302838035, 0.2695744228279866, 0.46894362265196865, 0.3266525961754392, 0.15332551835117325, 0.06330057551466473, 0.07864125582119919, 0.22109822106370958, 0.1623769432120844, 0.16412516768248642, 0.17337662737260018, 0.14645624223801246, 0.1367405475258482, 0.28178980831639966, 0.26351170610225727, 0.26336837614265174, 0.27372314010532917, 0.2712512744176909, 0.30504947940898264, 0.2822387068458595, 0.29196226772613676, 0.301156860031248, 0.6927570639471088, 0.6591172428269773, 0.6712536747642046, 0.6575510269241709, 0.6620173596840281, 0.6699359091675814, 0.655432007833028, 0.7220484320291843, 0.6790841374712753, 0.11934311323232905, 0.10142751386477555, 0.11715017690154272, 0.1121174016414872, 0.10969688469405414, 0.08796417776700183, 0.11881052099974132, 0.13618160185717443, 0.10202402783296205, 0.2707626687766582, 0.6022559453942372, 0.20831219444508464, 0.5092939168504723, 0.5964002503067694, 0.17651308315311398, 0.6201134962320644, 0.5100796048030397, 0.2623727986610591, 0.21231643067606998, 0.3772631662676055, 0.42468665750268586, 0.412567973177397, 0.4396799682178214, 0.23296224378829034, 0.46395125462648934, 0.4601853873909838, 0.4445041737141784, 0.2855967022955713, 0.24640596819318195, 0.29902517148118746, 0.264560743189969, 0.3271074453272367, 0.3412476068095335, 0.30773549548754275, 0.36637565293486674, 0.3323262625570056, 0.207838815229747, 0.21789308446664468, 0.21510383984593395, 0.22373675148021954, 0.20619641917398868, 0.20185197076238048, 0.2033250519412939, 0.2187049970219398, 0.20312226592432625, 0.535813488203994, 0.6741017459650877, 0.4554443268979236, 0.2467120148565527, 0.20923214475991403, 0.2337314258843275, 0.2530497786572433, 0.2511496973412298, 0.45453617798987567, 0.9136786457395403, 0.12725250276643219, 0.1548554778780613, 0.17355038433038683, 0.2018361053814146, 0.2009988335238726, 0.14297374742891167, 0.17042246595233534, 0.8927019435806154, 0.8713215836241923, 0.21342799392025302, 0.2094505201516419, 0.8209662230556729, 0.21139898162437798, 0.1688870937588257, 0.10534430330520461, 0.10480700262022369, 0.1679727434399425, 0.1833499815402414, 0.19515675001660315, 0.18460727008919675, 0.1859262605963654, 0.17936468176314102, 0.17905755814289293, 0.17593546244017455, 0.1937008247805394, 0.1944227514908241, 0.0911110980351667, 0.09373372619096498, 0.0802896952008525, 0.07900822268337071, 0.0937695611684849, 0.08696590780633029, 0.0883770580070865, 0.09478804872920932, 0.08764660011957659]}, "mutation_prompt": null}
{"id": "596d31a2-79ac-4f65-96f1-5b3a76785b33", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolutionCompetitive:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.4 + np.random.rand() * 0.6):  # Adaptive F factor for mutation\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.85):  # Slightly adjusted CR for better diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def adaptive_random_search(self):\n        perturbation = np.random.uniform(-0.4, 0.4, self.dim)  # Adjusted perturbation range\n        candidate = np.clip(self.population[self.global_best] + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.2:  # Adjusted chance to use adaptive random search\n                    trial = self.adaptive_random_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "EnhancedDifferentialEvolutionCompetitive", "description": "Enhanced Differential Evolution with Competitive Selection and Adaptive Parameter Tuning for improved exploitation and exploration balance.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9a450dd5-8755-4b03-823a-45a4c1005982", "metadata": {"aucs": [0.8495133406356231, 0.8466855067780171, 0.8513946570963247, 0.8556915906664728, 0.8508747765242319, 0.8313256708718615, 0.8588043967919298, 0.8558207819599282, 0.8402031023808564, 0.5937843203816686, 0.6206567150332712, 0.6566303118640022, 0.6429896478072117, 0.647561150095118, 0.6573618112310825, 0.6061636411460535, 0.681440254822538, 0.641483380720212, 0.12760909738244552, 0.14345946555952027, 0.21072612745566188, 0.15514896939455136, 0.13972684978093652, 0.11722127765687618, 0.1428735724982647, 0.5119195969265863, 0.1335196676432472, 0.1232043609205622, 0.12382214736356578, 0.12295404957714984, 0.1087966889999088, 0.13572913014562982, 0.1511738120581524, 0.1278881243949903, 0.11353815401379275, 0.1372419546110918, 0.9573142676820708, 0.9530001663972596, 0.9536849873471137, 0.9691416565251385, 0.9774221972800406, 0.9261215900578411, 0.9727345851412048, 0.9843542343393133, 0.9489600307846774, 0.5706473931003133, 0.5263466035348068, 0.5486952593813329, 0.5438335673087453, 0.5238917881866674, 0.5266731432733429, 0.5373338317665586, 0.5249167052308581, 0.5212305310157028, 0.6363248777089893, 0.7556220807077074, 0.22846412946655392, 0.830966751876892, 0.8435046327610771, 0.8088943926043503, 0.6428874948401168, 0.709281712838237, 0.6712664145495992, 0.52613887871172, 0.30604795298135046, 0.23986665994618983, 0.38141742087630637, 0.3267988104599897, 0.36383112666414885, 0.21388423291778547, 0.2106062929075877, 0.24799229104644216, 0.4362299618551474, 0.2480627320318901, 0.12938015146471316, 0.26246219177609664, 0.4159805863978878, 0.2048411749278436, 0.2644894007697426, 0.12129483581760647, 0.12672075684367268, 0.24305770642396474, 0.1924226399964486, 0.2923065930912927, 0.3205285508381919, 0.265864355153162, 0.13340776356457695, 0.34166341456197646, 0.20995361398640633, 0.2486738108371871, 0.47017389707433344, 0.4497762172373859, 0.44002080755220097, 0.368302638841984, 0.4085800807276453, 0.42932539302838035, 0.2695744228279866, 0.46894362265196865, 0.3266525961754392, 0.15332551835117325, 0.06330057551466473, 0.07864125582119919, 0.22109822106370958, 0.1623769432120844, 0.16412516768248642, 0.17337662737260018, 0.14645624223801246, 0.1367405475258482, 0.28178980831639966, 0.26351170610225727, 0.26336837614265174, 0.27372314010532917, 0.2712512744176909, 0.30504947940898264, 0.2822387068458595, 0.29196226772613676, 0.301156860031248, 0.6927570639471088, 0.6591172428269773, 0.6712536747642046, 0.6575510269241709, 0.6620173596840281, 0.6699359091675814, 0.655432007833028, 0.7220484320291843, 0.6790841374712753, 0.11934311323232905, 0.10142751386477555, 0.11715017690154272, 0.1121174016414872, 0.10969688469405414, 0.08796417776700183, 0.11881052099974132, 0.13618160185717443, 0.10202402783296205, 0.2707626687766582, 0.6022559453942372, 0.20831219444508464, 0.5092939168504723, 0.5964002503067694, 0.17651308315311398, 0.6201134962320644, 0.5100796048030397, 0.2623727986610591, 0.21231643067606998, 0.3772631662676055, 0.42468665750268586, 0.412567973177397, 0.4396799682178214, 0.23296224378829034, 0.46395125462648934, 0.4601853873909838, 0.4445041737141784, 0.2855967022955713, 0.24640596819318195, 0.29902517148118746, 0.264560743189969, 0.3271074453272367, 0.3412476068095335, 0.30773549548754275, 0.36637565293486674, 0.3323262625570056, 0.207838815229747, 0.21789308446664468, 0.21510383984593395, 0.22373675148021954, 0.20619641917398868, 0.20185197076238048, 0.2033250519412939, 0.2187049970219398, 0.20312226592432625, 0.535813488203994, 0.6741017459650877, 0.4554443268979236, 0.2467120148565527, 0.20923214475991403, 0.2337314258843275, 0.2530497786572433, 0.2511496973412298, 0.45453617798987567, 0.9136786457395403, 0.12725250276643219, 0.1548554778780613, 0.17355038433038683, 0.2018361053814146, 0.2009988335238726, 0.14297374742891167, 0.17042246595233534, 0.8927019435806154, 0.8713215836241923, 0.21342799392025302, 0.2094505201516419, 0.8209662230556729, 0.21139898162437798, 0.1688870937588257, 0.10534430330520461, 0.10480700262022369, 0.1679727434399425, 0.1833499815402414, 0.19515675001660315, 0.18460727008919675, 0.1859262605963654, 0.17936468176314102, 0.17905755814289293, 0.17593546244017455, 0.1937008247805394, 0.1944227514908241, 0.0911110980351667, 0.09373372619096498, 0.0802896952008525, 0.07900822268337071, 0.0937695611684849, 0.08696590780633029, 0.0883770580070865, 0.09478804872920932, 0.08764660011957659]}, "mutation_prompt": null}
{"id": "c05af671-ec61-42a6-840b-450fadf4e8ed", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolutionCompetitive:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.4 + np.random.rand() * 0.6):\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.7 + 0.2 * np.random.rand()):  # Adapted CR for dynamic adjustment\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def local_search_exploitation(self):  # New local search strategy for enhanced exploitation\n        best_candidate = self.population[self.global_best]\n        perturbation = np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(best_candidate + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.3:  # Increased chance to use local search\n                    trial = self.local_search_exploitation()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "EnhancedDifferentialEvolutionCompetitive", "description": "A modified Differential Evolution algorithm with enhanced crossover probability adaptation and local search exploitation.", "configspace": "", "generation": 46, "fitness": 0.3254159905664809, "feedback": "The algorithm EnhancedDifferentialEvolutionCompetitive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.", "error": "", "parent_id": "9a450dd5-8755-4b03-823a-45a4c1005982", "metadata": {"aucs": [0.8201978678510009, 0.8263702148464198, 0.8080804812121651, 0.805088888484705, 0.820084243465903, 0.8157233554086039, 0.8030138665548361, 0.8111050958974759, 0.8081914384243195, 0.4744877458650857, 0.4890400146991344, 0.4411718160563778, 0.44385192169336674, 0.5033855550013128, 0.44000173062859305, 0.45894199222352183, 0.49694277854146973, 0.4771523802644029, 0.1059682800553392, 0.055866331988240536, 0.17218821824555341, 0.024886586229445284, 0.1144574135639308, 0.16097758216606395, 0.082174247526699, 0.13549652273741009, 0.1343113586900463, 0.07911910371641917, 0.06498044918784474, 0.08296174886609586, 0.1121811877274278, 0.10755512291148639, 0.06957084690381143, 0.0728735008800897, 0.12358491293319163, 0.08440870852349003, 0.974037921317353, 0.9799814420473244, 0.976587281896853, 0.9705722677320412, 0.9749707244896835, 0.9870137353239051, 0.976615533990873, 0.9884805408081633, 0.9614127462728637, 0.43924965576946096, 0.4952828207434, 0.4827076640850736, 0.47193685564951127, 0.48169883725120943, 0.46617296978730194, 0.4663104263028487, 0.4871873304601546, 0.47111984762160797, 0.8232892191964256, 0.15717286961016308, 0.8237256917562674, 0.8914203701643748, 0.21257433919643198, 0.267853145198228, 0.5484499041959439, 0.1286792179929156, 0.14632327894372044, 0.4487151345898981, 0.3097420643689426, 0.28758105639956133, 0.13253001399456932, 0.28336575254785834, 0.3406611751166583, 0.3406573648383918, 0.13753974406588454, 0.3686097039670805, 0.13782611651618282, 0.47143355429354106, 0.2992954716308409, 0.350570037170144, 0.3302151406626115, 0.43205920829216116, 0.392589845656228, 0.32099840751267406, 0.12883173245637813, 0.1990627575379852, 0.18664155858827847, 0.2102211049963617, 0.2439603214808953, 0.20264820514936033, 0.1678279149141988, 0.21962645447418838, 0.20447266696929456, 0.22755590294149008, 0.20776569263596822, 0.2478968968867593, 0.2932693055971918, 0.34242574770672407, 0.2511793928328997, 0.3593057759934333, 0.34191760562608897, 0.32814780886085504, 0.3094137965231294, 0.05744991614710415, 0.04573542104294992, 0.08868944738805407, 0.12607401384214467, 0.0968255950277438, 0.14725164107336874, 0.10788400426856137, 0.12615826640253458, 0.0977964400399165, 0.20868734471188732, 0.1893415078248044, 0.24397323672525095, 0.2458557897748237, 0.233733647889532, 0.23544880228817366, 0.2117777402759602, 0.2320342908633869, 0.2103597354310799, 0.6386263813029291, 0.6125152619133528, 0.6072459374907664, 0.6320361887876225, 0.5953009577624462, 0.5835704548441284, 0.6180256073187518, 0.6231445084012858, 0.6187355931892684, 0.08816620523815999, 0.03824604709486834, 0.14785083429083, 0.06711909830263008, 0.09700408307697528, 0.10176232244668504, 0.054102642541802415, 0.11631611856096857, 0.07307037244520165, 0.2558166238314312, 0.4716336818715474, 0.2248177704048685, 0.4177259228124779, 0.4913872738554713, 0.22572341379854366, 0.5171641630073254, 0.38309086173624396, 0.17418471549222814, 0.34855256853163064, 0.2175472033528082, 0.17683708826597244, 0.372089880677406, 0.30666109834428, 0.22533715758023054, 0.21180903056767397, 0.3702458596819479, 0.4088853825542783, 0.21453567134954032, 0.09453762222329987, 0.25127272205420015, 0.3167247843322263, 0.21359687983209297, 0.3176479827563442, 0.2831205743246278, 0.3275222190147834, 0.2528759556287029, 0.23084846563687078, 0.19453228689140556, 0.21992091525378554, 0.2699803782182856, 0.1684579708695153, 0.21879567012523415, 0.20929218241736625, 0.19347810829017298, 0.23536537404970648, 0.5621978541958219, 0.22669522008629084, 0.1784008365893922, 0.21319551500380718, 0.20735968578454134, 0.18317975059701186, 0.21246995169016125, 0.2319761866560267, 0.17920730855809563, 0.18764115060493014, 0.15965117671230178, 0.15463265398416148, 0.1731855187014646, 0.20205298361363988, 0.14883060911497814, 0.14354751226844997, 0.17039244322831126, 0.9136639028744553, 0.8723867720330465, 0.21367537209469123, 0.8781214233405701, 0.10523710916432916, 0.16842545535967635, 0.15596040091021746, 0.2142745865920297, 0.16917963518619417, 0.8449510803480851, 0.18549244424334477, 0.1933205296354945, 0.19405794721296854, 0.17912989248254996, 0.18492527578200357, 0.1781128508829808, 0.2360338089749382, 0.1907675643816139, 0.1933565239653905, 0.10826293870267234, 0.09379298066028618, 0.09837479978177432, 0.07922104181216694, 0.08342719689082023, 0.09666517393995022, 0.09215688003239897, 0.06518364397500809, 0.10336887648026694]}, "mutation_prompt": null}
{"id": "c6fdf51b-d6f2-4486-9c87-2d0523c95b7f", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolutionCompetitive:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.4 + np.random.rand() * 0.6):  # Adaptive F factor for mutation\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.85):  # Slightly adjusted CR for better diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def adaptive_random_search(self):\n        perturbation = np.random.uniform(-0.4, 0.4, self.dim)  # Adjusted perturbation range\n        candidate = np.clip(self.population[self.global_best] + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.2:  # Adjusted chance to use adaptive random search\n                    trial = self.adaptive_random_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "EnhancedDifferentialEvolutionCompetitive", "description": "Enhanced Differential Evolution with Competitive Selection and Adaptive Parameter Tuning for improved exploitation and exploration balance.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9a450dd5-8755-4b03-823a-45a4c1005982", "metadata": {"aucs": [0.8495133406356231, 0.8466855067780171, 0.8513946570963247, 0.8556915906664728, 0.8508747765242319, 0.8313256708718615, 0.8588043967919298, 0.8558207819599282, 0.8402031023808564, 0.5937843203816686, 0.6206567150332712, 0.6566303118640022, 0.6429896478072117, 0.647561150095118, 0.6573618112310825, 0.6061636411460535, 0.681440254822538, 0.641483380720212, 0.12760909738244552, 0.14345946555952027, 0.21072612745566188, 0.15514896939455136, 0.13972684978093652, 0.11722127765687618, 0.1428735724982647, 0.5119195969265863, 0.1335196676432472, 0.1232043609205622, 0.12382214736356578, 0.12295404957714984, 0.1087966889999088, 0.13572913014562982, 0.1511738120581524, 0.1278881243949903, 0.11353815401379275, 0.1372419546110918, 0.9573142676820708, 0.9530001663972596, 0.9536849873471137, 0.9691416565251385, 0.9774221972800406, 0.9261215900578411, 0.9727345851412048, 0.9843542343393133, 0.9489600307846774, 0.5706473931003133, 0.5263466035348068, 0.5486952593813329, 0.5438335673087453, 0.5238917881866674, 0.5266731432733429, 0.5373338317665586, 0.5249167052308581, 0.5212305310157028, 0.6363248777089893, 0.7556220807077074, 0.22846412946655392, 0.830966751876892, 0.8435046327610771, 0.8088943926043503, 0.6428874948401168, 0.709281712838237, 0.6712664145495992, 0.52613887871172, 0.30604795298135046, 0.23986665994618983, 0.38141742087630637, 0.3267988104599897, 0.36383112666414885, 0.21388423291778547, 0.2106062929075877, 0.24799229104644216, 0.4362299618551474, 0.2480627320318901, 0.12938015146471316, 0.26246219177609664, 0.4159805863978878, 0.2048411749278436, 0.2644894007697426, 0.12129483581760647, 0.12672075684367268, 0.24305770642396474, 0.1924226399964486, 0.2923065930912927, 0.3205285508381919, 0.265864355153162, 0.13340776356457695, 0.34166341456197646, 0.20995361398640633, 0.2486738108371871, 0.47017389707433344, 0.4497762172373859, 0.44002080755220097, 0.368302638841984, 0.4085800807276453, 0.42932539302838035, 0.2695744228279866, 0.46894362265196865, 0.3266525961754392, 0.15332551835117325, 0.06330057551466473, 0.07864125582119919, 0.22109822106370958, 0.1623769432120844, 0.16412516768248642, 0.17337662737260018, 0.14645624223801246, 0.1367405475258482, 0.28178980831639966, 0.26351170610225727, 0.26336837614265174, 0.27372314010532917, 0.2712512744176909, 0.30504947940898264, 0.2822387068458595, 0.29196226772613676, 0.301156860031248, 0.6927570639471088, 0.6591172428269773, 0.6712536747642046, 0.6575510269241709, 0.6620173596840281, 0.6699359091675814, 0.655432007833028, 0.7220484320291843, 0.6790841374712753, 0.11934311323232905, 0.10142751386477555, 0.11715017690154272, 0.1121174016414872, 0.10969688469405414, 0.08796417776700183, 0.11881052099974132, 0.13618160185717443, 0.10202402783296205, 0.2707626687766582, 0.6022559453942372, 0.20831219444508464, 0.5092939168504723, 0.5964002503067694, 0.17651308315311398, 0.6201134962320644, 0.5100796048030397, 0.2623727986610591, 0.21231643067606998, 0.3772631662676055, 0.42468665750268586, 0.412567973177397, 0.4396799682178214, 0.23296224378829034, 0.46395125462648934, 0.4601853873909838, 0.4445041737141784, 0.2855967022955713, 0.24640596819318195, 0.29902517148118746, 0.264560743189969, 0.3271074453272367, 0.3412476068095335, 0.30773549548754275, 0.36637565293486674, 0.3323262625570056, 0.207838815229747, 0.21789308446664468, 0.21510383984593395, 0.22373675148021954, 0.20619641917398868, 0.20185197076238048, 0.2033250519412939, 0.2187049970219398, 0.20312226592432625, 0.535813488203994, 0.6741017459650877, 0.4554443268979236, 0.2467120148565527, 0.20923214475991403, 0.2337314258843275, 0.2530497786572433, 0.2511496973412298, 0.45453617798987567, 0.9136786457395403, 0.12725250276643219, 0.1548554778780613, 0.17355038433038683, 0.2018361053814146, 0.2009988335238726, 0.14297374742891167, 0.17042246595233534, 0.8927019435806154, 0.8713215836241923, 0.21342799392025302, 0.2094505201516419, 0.8209662230556729, 0.21139898162437798, 0.1688870937588257, 0.10534430330520461, 0.10480700262022369, 0.1679727434399425, 0.1833499815402414, 0.19515675001660315, 0.18460727008919675, 0.1859262605963654, 0.17936468176314102, 0.17905755814289293, 0.17593546244017455, 0.1937008247805394, 0.1944227514908241, 0.0911110980351667, 0.09373372619096498, 0.0802896952008525, 0.07900822268337071, 0.0937695611684849, 0.08696590780633029, 0.0883770580070865, 0.09478804872920932, 0.08764660011957659]}, "mutation_prompt": null}
{"id": "9c37124d-55b8-4122-b178-cabad49b4c4e", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolutionCompetitive:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n        self.dynamic_cr = 0.9\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.5 + np.random.rand() * 0.5):  # Increased base F factor\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        self.dynamic_cr = 0.8 + 0.1 * np.random.rand()  # Dynamic CR for enhanced diversity\n        crossover_mask = np.random.rand(self.dim) < self.dynamic_cr\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def adaptive_gaussian_search(self):\n        perturbation = np.random.normal(0, 0.3, self.dim)  # Gaussian perturbation for better exploration\n        candidate = np.clip(self.population[self.global_best] + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.25:  # Adjusted chance to use adaptive gaussian search\n                    trial = self.adaptive_gaussian_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "EnhancedDifferentialEvolutionCompetitive", "description": "A hybrid of Differential Evolution with Competitive Selection and Adaptive Exploration using Dynamic Probability and Gaussian Perturbation for enhanced convergence speed.", "configspace": "", "generation": 48, "fitness": 0.3265702354311777, "feedback": "The algorithm EnhancedDifferentialEvolutionCompetitive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.24.", "error": "", "parent_id": "9a450dd5-8755-4b03-823a-45a4c1005982", "metadata": {"aucs": [0.7560320533009947, 0.7789994925003791, 0.7681175546099506, 0.7905221932369915, 0.7352347165914177, 0.7893705047579399, 0.7579612509482487, 0.7675584148000443, 0.7523569465348645, 0.5072061219620407, 0.46462483016149003, 0.44705294788922634, 0.47122841561082185, 0.4348435480650402, 0.4413355172560459, 0.46860184084112855, 0.44011601986056437, 0.4538801974853156, 0.3363581467192013, 0.14930266206554355, 0.13430276487306514, 0.16582564730143057, 0.1295396514866607, 0.12445400160417097, 0.14724465264897368, 0.12194116065654126, 0.13485199557130378, 0.11026676507085575, 0.10693761199839624, 0.11319396015032923, 0.13793943454073943, 0.12320841433184848, 0.10447260460957952, 0.11461393489829008, 0.11833676702684492, 0.1185188267568108, 0.9879735341429615, 0.9592571806497437, 0.9787545242157468, 0.9807474668476717, 0.9516667633502864, 0.9845238155359638, 0.9764471490094928, 0.9636958447683528, 0.9906681527882283, 0.4028807308220843, 0.4017401767330855, 0.4024029389451127, 0.4081898149201656, 0.4299999131899189, 0.4017981863905291, 0.3976538926868025, 0.4302552312354534, 0.42767673092042846, 0.7791780457173901, 0.7549463551538428, 0.7530186463632241, 0.6768332938907966, 0.677682597515056, 0.7617691731515079, 0.624622568080874, 0.7048279721592152, 0.6610468806389265, 0.40353208212604663, 0.16968721647789808, 0.29247301492768796, 0.2812756908644124, 0.32238049563819837, 0.24901748603959173, 0.21728132943968126, 0.20671018922850604, 0.2859675768755937, 0.29662429116064426, 0.14939880327414334, 0.1320811809953235, 0.2890494623727493, 0.24930456416376245, 0.3689988612304447, 0.13121715040381843, 0.12338755263272816, 0.26740421793681646, 0.18542568759664368, 0.17395349156595097, 0.1546008929697531, 0.17708173869156996, 0.12627855251626863, 0.16995495959075946, 0.17741002326889665, 0.15753680920970659, 0.18140541279443878, 0.28389236261397144, 0.2711534863167372, 0.2921273801591584, 0.29443396472369365, 0.23637204257925748, 0.2971262101776021, 0.3174863134217737, 0.3010129868710605, 0.2971139861739911, 0.042798114086893824, 0.05203171123991002, 0.0740160846762914, 0.08107292635805208, 0.11019010389923045, 0.12865473661558569, 0.08882061505349681, 0.06402870353910983, 0.08383321762373075, 0.20688108025215923, 0.2085091720569674, 0.1901847103340769, 0.2213690501948542, 0.21930397939144386, 0.20971735478117504, 0.20796873702266827, 0.20303354504110138, 0.18653706039238627, 0.5759244309027598, 0.5855841641605117, 0.5790308227582042, 0.5613064136561667, 0.5507351456912033, 0.5652305816852302, 0.5733879838374613, 0.6140316349119126, 0.594581071905832, 0.13940912792073612, 0.10558375381336227, 0.08932011755378755, 0.11383980181702014, 0.1381515354288897, 0.10982041041471113, 0.10695019126521588, 0.107892902964142, 0.100857495173996, 0.2554301006727552, 0.45155148495456787, 0.19173333596478448, 0.3901898219595482, 0.2759341583891951, 0.3658651526830603, 0.4250217226902394, 0.1976596151382145, 0.3423965086286279, 0.3556109692102145, 0.35201240297995806, 0.3359279797736163, 0.3437039214604296, 0.2383079669235444, 0.3426256157651558, 0.3545118009312207, 0.3545810137369927, 0.3385635591675584, 0.2506036129249799, 0.27164196593150713, 0.26577524550791354, 0.25573175433521633, 0.2785077835204144, 0.26962017482105116, 0.2653107139034805, 0.2851548447240563, 0.2629081401411446, 0.21711025027106856, 0.20896695200322224, 0.2010103310289062, 0.18801833672085044, 0.2008777053840176, 0.1954287421948795, 0.21633288369807935, 0.1915290595568776, 0.19206020884975628, 0.46853332413360427, 0.22121963203035522, 0.21283266362382247, 0.5802742693406306, 0.24867753697130346, 0.21400656269650964, 0.23986365014550426, 0.23670411690713233, 0.22925990326672607, 0.10538983362574694, 0.20123484971915517, 0.15493021339737445, 0.17316240919421966, 0.2014766086965074, 0.15363282377034304, 0.14331527655702136, 0.169941824030022, 0.8691045934113915, 0.8238136507083142, 0.21347555572760457, 0.21262169744412418, 0.7730879643080253, 0.11287169787271756, 0.10557334703221677, 0.212327886348742, 0.2141230749116808, 0.775804155441483, 0.19005521948894843, 0.1796072571977364, 0.2031325138123542, 0.18327011329314535, 0.18373125720243233, 0.19105870768805422, 0.17920006997532567, 0.1821863501591291, 0.19264314781856207, 0.08280662552239171, 0.08886420376628845, 0.07836209067456057, 0.08591741598118752, 0.08778467711030202, 0.0846732553372791, 0.0703597243951557, 0.09207880864800733, 0.08060935320862828]}, "mutation_prompt": null}
{"id": "8cd0a2c6-35b4-47d8-bfc2-f530afccdff7", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolutionDynamic:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 4, replace=False)  # Using 4 parents for enhanced mutation\n        return self.population[indices]\n\n    def mutate(self, a, b, c, d, F=0.5):  # Simplified constant F factor\n        mutant = np.clip(a + F * (b - c + d - a), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):  # Increased CR for enhanced exploration\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def adaptive_random_search(self):\n        perturbation = np.random.uniform(-0.3, 0.3, self.dim)  # Slightly adjusted perturbation range\n        candidate = np.clip(self.population[self.global_best] + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.3:  # Increased chance to use adaptive random search\n                    trial = self.adaptive_random_search()\n                else:\n                    target = self.population[i]\n                    a, b, c, d = self.select_parents()\n                    mutant = self.mutate(a, b, c, d)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n            # Dynamically adjust population size based on eval_count\n            if self.eval_count < self.budget * 0.5:\n                self.pop_size = min(self.pop_size * 2, 20 * self.dim)  # Increase population size in early stages\n                self.population = np.vstack((self.population, np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size - len(self.population), self.dim))))\n                self.fitness = np.hstack((self.fitness, np.full(self.pop_size - len(self.fitness), np.inf)))\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "EnhancedDifferentialEvolutionDynamic", "description": "Adaptive Differential Evolution with Dynamic Population Size and Enhanced Mutation for accelerated convergence.", "configspace": "", "generation": 49, "fitness": 0.30637121385774857, "feedback": "The algorithm EnhancedDifferentialEvolutionDynamic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.26.", "error": "", "parent_id": "9a450dd5-8755-4b03-823a-45a4c1005982", "metadata": {"aucs": [0.8234728112747198, 0.8136139741151709, 0.8222532098968763, 0.8159075604197167, 0.8208830349257319, 0.8084268458880214, 0.8163168186762446, 0.8043495202098415, 0.8108785594490322, 0.08810515060636104, 0.5032224080789508, 9.999999999998899e-05, 0.5263809029626461, 0.051744227587605884, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0009167040479405308, 0.11364503048121499, 0.12647275619730902, 0.12323335910067612, 0.12167314786740502, 0.1313265690889701, 0.1427530450786113, 0.11733659584718714, 0.13275706158788103, 0.10771548602692127, 0.1067216249638886, 0.10452573222178763, 0.11009387465610343, 0.10808255281315271, 0.10592029832106942, 0.08089521889845996, 0.09640444755246769, 0.10770070082611327, 0.08383148370406557, 0.9333997008176022, 0.9250442991562527, 0.9651918516445539, 0.9103984060570771, 0.9724113931926248, 0.9776366969287331, 0.9470455777843514, 0.9726718773160805, 0.9783395387075929, 0.3731417593859637, 0.3590611028336531, 0.39018468881139023, 0.37042269017258145, 0.34022161382173643, 0.37221867663620956, 0.3573092446671695, 0.35218808970108517, 0.3697747642637139, 0.8315760064987466, 0.8771274388798381, 0.8111456633291642, 0.21625070374212196, 0.840288558893336, 0.2786471267749916, 0.7422481825109813, 0.13196215189577565, 0.8504128267177682, 0.2568432746486383, 0.25022696651706355, 0.1799087889661205, 0.17705919861487696, 0.17103388918800078, 0.15545926191069903, 0.19176798743676404, 0.12469900342952112, 0.19357109510377868, 0.44262919167304204, 0.21152064713322438, 0.13861858735840238, 0.16645024396928998, 0.14653746041401716, 0.1536941699124369, 0.18095735155622217, 0.14140520560985226, 0.14286590651051478, 0.19613244423944953, 0.002501190015297805, 0.007484037698273438, 0.013727456439650454, 0.04148739429730852, 9.999999999998899e-05, 0.006762281596734976, 0.05274936835981192, 0.14231667858165398, 0.1872739051488992, 0.14597201978410923, 0.27238700477869693, 0.09901488001467329, 0.1490138768122411, 0.18068720089883483, 0.4525965181734004, 0.1332825829300779, 0.3891576442695601, 0.14131515066610212, 0.15660286505905663, 0.11822790675650363, 0.1383592365852273, 0.21857352504486338, 0.21795695573710883, 0.24187442600286213, 0.073361528369557, 0.22187100964504491, 0.23382889227364256, 0.3021099624301904, 0.13395209267389818, 0.17019065511184672, 0.3141502502031128, 0.1615207862306608, 0.18345697023169116, 0.24866553216443743, 0.1140685720191068, 0.6890139002491289, 0.6959815685945758, 0.7112666065612334, 0.6949312892040442, 0.7005070659972794, 0.6839749569371416, 0.6997604595882922, 0.6907992107066473, 0.6981703846925913, 0.12526394215032577, 0.11433792302863677, 0.08515310262844067, 0.1167304296379954, 0.13616867331787885, 0.11787952251358369, 0.11448133412638506, 0.12984202905700937, 0.15035363635746923, 0.2607025876670488, 0.4989524201309299, 0.2291109217043068, 0.6066386846604457, 0.5528357572833426, 0.24374883320394714, 0.5531716474016088, 0.21828904167708785, 0.20629295893432964, 0.4255774227206217, 0.380503474770184, 0.42208306560968123, 0.37333387985601973, 0.43507908316400323, 0.4283880664524986, 0.20763486016304367, 0.444027891878349, 0.4354514672048545, 0.2276873744564356, 0.3319792366328125, 0.3543689865793854, 0.31486280927360344, 0.3254076680058444, 0.3263785977727883, 0.22081612013138718, 0.36050434887710314, 0.3411059324264364, 0.2520093649347468, 0.2441207234105366, 0.21990410298434115, 0.22069722935643699, 0.21561638730548183, 0.22539914264759664, 0.2158850996992393, 0.20055444492657593, 0.21300703238240704, 0.1770392426126478, 0.20083076599302785, 0.19623224222981017, 0.21090582550188397, 0.19925009204148447, 0.2022030444712809, 0.19878850388117442, 0.22478369959243338, 0.17562673114122496, 0.17806123111924332, 0.18804601511189056, 0.15487504566884747, 0.17269156053849255, 0.2020076091149181, 0.8932293028261715, 0.14332344329567825, 0.17050933546347447, 0.16915204772239611, 0.8888189929659014, 0.21420527022964786, 0.15572896455657503, 0.8386282939366152, 0.5939087980650397, 0.16977392343000497, 0.10517024277535025, 0.10529492416451902, 0.12848317703934586, 0.19043328235877033, 0.18827026293611482, 0.20133341494630563, 0.20770285856622295, 0.17899859392325956, 0.19464659624711256, 0.1880289776813452, 0.18875966058699045, 0.18382358072101568, 0.09549859536876393, 0.11592335832766276, 0.09084383294939413, 0.08964759511944487, 0.08280795186766021, 0.09189322448037951, 0.094638119584732, 0.09057663421919826, 0.0957822505568291]}, "mutation_prompt": null}
{"id": "dd741dd4-62a5-4de8-8e36-2f5ad41a69ba", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolutionCompetitive:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = pop_size if pop_size is not None else 8 * dim\n        self.pop_size = self.initial_pop_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.3 + np.random.rand() * 0.7):  # Adjusted adaptive F factor\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):  # Slightly increased CR for exploration\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def adaptive_random_search(self):\n        perturbation = np.random.uniform(-0.5, 0.5, self.dim)  # Expanded perturbation range\n        candidate = np.clip(self.population[self.global_best] + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            if self.eval_count % (self.budget // 10) == 0:  # Adaptive population size reduction\n                self.pop_size = max(4, int(self.initial_pop_size * (1 - self.eval_count / self.budget)))\n                self.population = self.population[:self.pop_size]\n                self.fitness = self.fitness[:self.pop_size]\n\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.25:  # Increased chance to use adaptive random search\n                    trial = self.adaptive_random_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "EnhancedDifferentialEvolutionCompetitive", "description": "Introduce adaptive population size reduction and dynamic mutation strategy to enhance convergence speed with a hybrid exploitation-exploration balance.", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 39 is out of bounds for axis 0 with size 36').", "error": "IndexError('index 39 is out of bounds for axis 0 with size 36')", "parent_id": "9a450dd5-8755-4b03-823a-45a4c1005982", "metadata": {}, "mutation_prompt": null}
{"id": "923db53e-fa81-4947-93e0-3cc3d341853d", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolutionCompetitive:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.4 + np.random.rand() * 0.6):  # Adaptive F factor for mutation\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.85):  # Slightly adjusted CR for better diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def adaptive_random_search(self):\n        perturbation = np.random.uniform(-0.4, 0.4, self.dim)  # Adjusted perturbation range\n        candidate = np.clip(self.population[self.global_best] + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.2:  # Adjusted chance to use adaptive random search\n                    trial = self.adaptive_random_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "EnhancedDifferentialEvolutionCompetitive", "description": "Enhanced Differential Evolution with Competitive Selection and Adaptive Parameter Tuning for improved exploitation and exploration balance.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9a450dd5-8755-4b03-823a-45a4c1005982", "metadata": {"aucs": [0.8495133406356231, 0.8466855067780171, 0.8513946570963247, 0.8556915906664728, 0.8508747765242319, 0.8313256708718615, 0.8588043967919298, 0.8558207819599282, 0.8402031023808564, 0.5937843203816686, 0.6206567150332712, 0.6566303118640022, 0.6429896478072117, 0.647561150095118, 0.6573618112310825, 0.6061636411460535, 0.681440254822538, 0.641483380720212, 0.12760909738244552, 0.14345946555952027, 0.21072612745566188, 0.15514896939455136, 0.13972684978093652, 0.11722127765687618, 0.1428735724982647, 0.5119195969265863, 0.1335196676432472, 0.1232043609205622, 0.12382214736356578, 0.12295404957714984, 0.1087966889999088, 0.13572913014562982, 0.1511738120581524, 0.1278881243949903, 0.11353815401379275, 0.1372419546110918, 0.9573142676820708, 0.9530001663972596, 0.9536849873471137, 0.9691416565251385, 0.9774221972800406, 0.9261215900578411, 0.9727345851412048, 0.9843542343393133, 0.9489600307846774, 0.5706473931003133, 0.5263466035348068, 0.5486952593813329, 0.5438335673087453, 0.5238917881866674, 0.5266731432733429, 0.5373338317665586, 0.5249167052308581, 0.5212305310157028, 0.6363248777089893, 0.7556220807077074, 0.22846412946655392, 0.830966751876892, 0.8435046327610771, 0.8088943926043503, 0.6428874948401168, 0.709281712838237, 0.6712664145495992, 0.52613887871172, 0.30604795298135046, 0.23986665994618983, 0.38141742087630637, 0.3267988104599897, 0.36383112666414885, 0.21388423291778547, 0.2106062929075877, 0.24799229104644216, 0.4362299618551474, 0.2480627320318901, 0.12938015146471316, 0.26246219177609664, 0.4159805863978878, 0.2048411749278436, 0.2644894007697426, 0.12129483581760647, 0.12672075684367268, 0.24305770642396474, 0.1924226399964486, 0.2923065930912927, 0.3205285508381919, 0.265864355153162, 0.13340776356457695, 0.34166341456197646, 0.20995361398640633, 0.2486738108371871, 0.47017389707433344, 0.4497762172373859, 0.44002080755220097, 0.368302638841984, 0.4085800807276453, 0.42932539302838035, 0.2695744228279866, 0.46894362265196865, 0.3266525961754392, 0.15332551835117325, 0.06330057551466473, 0.07864125582119919, 0.22109822106370958, 0.1623769432120844, 0.16412516768248642, 0.17337662737260018, 0.14645624223801246, 0.1367405475258482, 0.28178980831639966, 0.26351170610225727, 0.26336837614265174, 0.27372314010532917, 0.2712512744176909, 0.30504947940898264, 0.2822387068458595, 0.29196226772613676, 0.301156860031248, 0.6927570639471088, 0.6591172428269773, 0.6712536747642046, 0.6575510269241709, 0.6620173596840281, 0.6699359091675814, 0.655432007833028, 0.7220484320291843, 0.6790841374712753, 0.11934311323232905, 0.10142751386477555, 0.11715017690154272, 0.1121174016414872, 0.10969688469405414, 0.08796417776700183, 0.11881052099974132, 0.13618160185717443, 0.10202402783296205, 0.2707626687766582, 0.6022559453942372, 0.20831219444508464, 0.5092939168504723, 0.5964002503067694, 0.17651308315311398, 0.6201134962320644, 0.5100796048030397, 0.2623727986610591, 0.21231643067606998, 0.3772631662676055, 0.42468665750268586, 0.412567973177397, 0.4396799682178214, 0.23296224378829034, 0.46395125462648934, 0.4601853873909838, 0.4445041737141784, 0.2855967022955713, 0.24640596819318195, 0.29902517148118746, 0.264560743189969, 0.3271074453272367, 0.3412476068095335, 0.30773549548754275, 0.36637565293486674, 0.3323262625570056, 0.207838815229747, 0.21789308446664468, 0.21510383984593395, 0.22373675148021954, 0.20619641917398868, 0.20185197076238048, 0.2033250519412939, 0.2187049970219398, 0.20312226592432625, 0.535813488203994, 0.6741017459650877, 0.4554443268979236, 0.2467120148565527, 0.20923214475991403, 0.2337314258843275, 0.2530497786572433, 0.2511496973412298, 0.45453617798987567, 0.9136786457395403, 0.12725250276643219, 0.1548554778780613, 0.17355038433038683, 0.2018361053814146, 0.2009988335238726, 0.14297374742891167, 0.17042246595233534, 0.8927019435806154, 0.8713215836241923, 0.21342799392025302, 0.2094505201516419, 0.8209662230556729, 0.21139898162437798, 0.1688870937588257, 0.10534430330520461, 0.10480700262022369, 0.1679727434399425, 0.1833499815402414, 0.19515675001660315, 0.18460727008919675, 0.1859262605963654, 0.17936468176314102, 0.17905755814289293, 0.17593546244017455, 0.1937008247805394, 0.1944227514908241, 0.0911110980351667, 0.09373372619096498, 0.0802896952008525, 0.07900822268337071, 0.0937695611684849, 0.08696590780633029, 0.0883770580070865, 0.09478804872920932, 0.08764660011957659]}, "mutation_prompt": null}
{"id": "9655da0a-df9f-4cb6-9ad2-1078ef1b36bd", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolutionCompetitive:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.4 + np.random.rand() * 0.6):  # Adaptive F factor for mutation\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.85):  # Slightly adjusted CR for better diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def adaptive_random_search(self):\n        perturbation = np.random.uniform(-0.4, 0.4, self.dim)  # Adjusted perturbation range\n        candidate = np.clip(self.population[self.global_best] + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.2:  # Adjusted chance to use adaptive random search\n                    trial = self.adaptive_random_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "EnhancedDifferentialEvolutionCompetitive", "description": "Enhanced Differential Evolution with Competitive Selection and Adaptive Parameter Tuning for improved exploitation and exploration balance.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9a450dd5-8755-4b03-823a-45a4c1005982", "metadata": {"aucs": [0.8495133406356231, 0.8466855067780171, 0.8513946570963247, 0.8556915906664728, 0.8508747765242319, 0.8313256708718615, 0.8588043967919298, 0.8558207819599282, 0.8402031023808564, 0.5937843203816686, 0.6206567150332712, 0.6566303118640022, 0.6429896478072117, 0.647561150095118, 0.6573618112310825, 0.6061636411460535, 0.681440254822538, 0.641483380720212, 0.12760909738244552, 0.14345946555952027, 0.21072612745566188, 0.15514896939455136, 0.13972684978093652, 0.11722127765687618, 0.1428735724982647, 0.5119195969265863, 0.1335196676432472, 0.1232043609205622, 0.12382214736356578, 0.12295404957714984, 0.1087966889999088, 0.13572913014562982, 0.1511738120581524, 0.1278881243949903, 0.11353815401379275, 0.1372419546110918, 0.9573142676820708, 0.9530001663972596, 0.9536849873471137, 0.9691416565251385, 0.9774221972800406, 0.9261215900578411, 0.9727345851412048, 0.9843542343393133, 0.9489600307846774, 0.5706473931003133, 0.5263466035348068, 0.5486952593813329, 0.5438335673087453, 0.5238917881866674, 0.5266731432733429, 0.5373338317665586, 0.5249167052308581, 0.5212305310157028, 0.6363248777089893, 0.7556220807077074, 0.22846412946655392, 0.830966751876892, 0.8435046327610771, 0.8088943926043503, 0.6428874948401168, 0.709281712838237, 0.6712664145495992, 0.52613887871172, 0.30604795298135046, 0.23986665994618983, 0.38141742087630637, 0.3267988104599897, 0.36383112666414885, 0.21388423291778547, 0.2106062929075877, 0.24799229104644216, 0.4362299618551474, 0.2480627320318901, 0.12938015146471316, 0.26246219177609664, 0.4159805863978878, 0.2048411749278436, 0.2644894007697426, 0.12129483581760647, 0.12672075684367268, 0.24305770642396474, 0.1924226399964486, 0.2923065930912927, 0.3205285508381919, 0.265864355153162, 0.13340776356457695, 0.34166341456197646, 0.20995361398640633, 0.2486738108371871, 0.47017389707433344, 0.4497762172373859, 0.44002080755220097, 0.368302638841984, 0.4085800807276453, 0.42932539302838035, 0.2695744228279866, 0.46894362265196865, 0.3266525961754392, 0.15332551835117325, 0.06330057551466473, 0.07864125582119919, 0.22109822106370958, 0.1623769432120844, 0.16412516768248642, 0.17337662737260018, 0.14645624223801246, 0.1367405475258482, 0.28178980831639966, 0.26351170610225727, 0.26336837614265174, 0.27372314010532917, 0.2712512744176909, 0.30504947940898264, 0.2822387068458595, 0.29196226772613676, 0.301156860031248, 0.6927570639471088, 0.6591172428269773, 0.6712536747642046, 0.6575510269241709, 0.6620173596840281, 0.6699359091675814, 0.655432007833028, 0.7220484320291843, 0.6790841374712753, 0.11934311323232905, 0.10142751386477555, 0.11715017690154272, 0.1121174016414872, 0.10969688469405414, 0.08796417776700183, 0.11881052099974132, 0.13618160185717443, 0.10202402783296205, 0.2707626687766582, 0.6022559453942372, 0.20831219444508464, 0.5092939168504723, 0.5964002503067694, 0.17651308315311398, 0.6201134962320644, 0.5100796048030397, 0.2623727986610591, 0.21231643067606998, 0.3772631662676055, 0.42468665750268586, 0.412567973177397, 0.4396799682178214, 0.23296224378829034, 0.46395125462648934, 0.4601853873909838, 0.4445041737141784, 0.2855967022955713, 0.24640596819318195, 0.29902517148118746, 0.264560743189969, 0.3271074453272367, 0.3412476068095335, 0.30773549548754275, 0.36637565293486674, 0.3323262625570056, 0.207838815229747, 0.21789308446664468, 0.21510383984593395, 0.22373675148021954, 0.20619641917398868, 0.20185197076238048, 0.2033250519412939, 0.2187049970219398, 0.20312226592432625, 0.535813488203994, 0.6741017459650877, 0.4554443268979236, 0.2467120148565527, 0.20923214475991403, 0.2337314258843275, 0.2530497786572433, 0.2511496973412298, 0.45453617798987567, 0.9136786457395403, 0.12725250276643219, 0.1548554778780613, 0.17355038433038683, 0.2018361053814146, 0.2009988335238726, 0.14297374742891167, 0.17042246595233534, 0.8927019435806154, 0.8713215836241923, 0.21342799392025302, 0.2094505201516419, 0.8209662230556729, 0.21139898162437798, 0.1688870937588257, 0.10534430330520461, 0.10480700262022369, 0.1679727434399425, 0.1833499815402414, 0.19515675001660315, 0.18460727008919675, 0.1859262605963654, 0.17936468176314102, 0.17905755814289293, 0.17593546244017455, 0.1937008247805394, 0.1944227514908241, 0.0911110980351667, 0.09373372619096498, 0.0802896952008525, 0.07900822268337071, 0.0937695611684849, 0.08696590780633029, 0.0883770580070865, 0.09478804872920932, 0.08764660011957659]}, "mutation_prompt": null}
{"id": "bafd40c2-112a-4377-86c7-9198ef2f17d4", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolutionCompetitive:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.4 + np.random.rand() * 0.6):  # Adaptive F factor for mutation\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.85):  # Slightly adjusted CR for better diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def adaptive_random_search(self):\n        perturbation = np.random.uniform(-0.4, 0.4, self.dim)  # Adjusted perturbation range\n        candidate = np.clip(self.population[self.global_best] + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.2:  # Adjusted chance to use adaptive random search\n                    trial = self.adaptive_random_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "EnhancedDifferentialEvolutionCompetitive", "description": "Enhanced Differential Evolution with Competitive Selection and Adaptive Parameter Tuning for improved exploitation and exploration balance.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9a450dd5-8755-4b03-823a-45a4c1005982", "metadata": {"aucs": [0.8495133406356231, 0.8466855067780171, 0.8513946570963247, 0.8556915906664728, 0.8508747765242319, 0.8313256708718615, 0.8588043967919298, 0.8558207819599282, 0.8402031023808564, 0.5937843203816686, 0.6206567150332712, 0.6566303118640022, 0.6429896478072117, 0.647561150095118, 0.6573618112310825, 0.6061636411460535, 0.681440254822538, 0.641483380720212, 0.12760909738244552, 0.14345946555952027, 0.21072612745566188, 0.15514896939455136, 0.13972684978093652, 0.11722127765687618, 0.1428735724982647, 0.5119195969265863, 0.1335196676432472, 0.1232043609205622, 0.12382214736356578, 0.12295404957714984, 0.1087966889999088, 0.13572913014562982, 0.1511738120581524, 0.1278881243949903, 0.11353815401379275, 0.1372419546110918, 0.9573142676820708, 0.9530001663972596, 0.9536849873471137, 0.9691416565251385, 0.9774221972800406, 0.9261215900578411, 0.9727345851412048, 0.9843542343393133, 0.9489600307846774, 0.5706473931003133, 0.5263466035348068, 0.5486952593813329, 0.5438335673087453, 0.5238917881866674, 0.5266731432733429, 0.5373338317665586, 0.5249167052308581, 0.5212305310157028, 0.6363248777089893, 0.7556220807077074, 0.22846412946655392, 0.830966751876892, 0.8435046327610771, 0.8088943926043503, 0.6428874948401168, 0.709281712838237, 0.6712664145495992, 0.52613887871172, 0.30604795298135046, 0.23986665994618983, 0.38141742087630637, 0.3267988104599897, 0.36383112666414885, 0.21388423291778547, 0.2106062929075877, 0.24799229104644216, 0.4362299618551474, 0.2480627320318901, 0.12938015146471316, 0.26246219177609664, 0.4159805863978878, 0.2048411749278436, 0.2644894007697426, 0.12129483581760647, 0.12672075684367268, 0.24305770642396474, 0.1924226399964486, 0.2923065930912927, 0.3205285508381919, 0.265864355153162, 0.13340776356457695, 0.34166341456197646, 0.20995361398640633, 0.2486738108371871, 0.47017389707433344, 0.4497762172373859, 0.44002080755220097, 0.368302638841984, 0.4085800807276453, 0.42932539302838035, 0.2695744228279866, 0.46894362265196865, 0.3266525961754392, 0.15332551835117325, 0.06330057551466473, 0.07864125582119919, 0.22109822106370958, 0.1623769432120844, 0.16412516768248642, 0.17337662737260018, 0.14645624223801246, 0.1367405475258482, 0.28178980831639966, 0.26351170610225727, 0.26336837614265174, 0.27372314010532917, 0.2712512744176909, 0.30504947940898264, 0.2822387068458595, 0.29196226772613676, 0.301156860031248, 0.6927570639471088, 0.6591172428269773, 0.6712536747642046, 0.6575510269241709, 0.6620173596840281, 0.6699359091675814, 0.655432007833028, 0.7220484320291843, 0.6790841374712753, 0.11934311323232905, 0.10142751386477555, 0.11715017690154272, 0.1121174016414872, 0.10969688469405414, 0.08796417776700183, 0.11881052099974132, 0.13618160185717443, 0.10202402783296205, 0.2707626687766582, 0.6022559453942372, 0.20831219444508464, 0.5092939168504723, 0.5964002503067694, 0.17651308315311398, 0.6201134962320644, 0.5100796048030397, 0.2623727986610591, 0.21231643067606998, 0.3772631662676055, 0.42468665750268586, 0.412567973177397, 0.4396799682178214, 0.23296224378829034, 0.46395125462648934, 0.4601853873909838, 0.4445041737141784, 0.2855967022955713, 0.24640596819318195, 0.29902517148118746, 0.264560743189969, 0.3271074453272367, 0.3412476068095335, 0.30773549548754275, 0.36637565293486674, 0.3323262625570056, 0.207838815229747, 0.21789308446664468, 0.21510383984593395, 0.22373675148021954, 0.20619641917398868, 0.20185197076238048, 0.2033250519412939, 0.2187049970219398, 0.20312226592432625, 0.535813488203994, 0.6741017459650877, 0.4554443268979236, 0.2467120148565527, 0.20923214475991403, 0.2337314258843275, 0.2530497786572433, 0.2511496973412298, 0.45453617798987567, 0.9136786457395403, 0.12725250276643219, 0.1548554778780613, 0.17355038433038683, 0.2018361053814146, 0.2009988335238726, 0.14297374742891167, 0.17042246595233534, 0.8927019435806154, 0.8713215836241923, 0.21342799392025302, 0.2094505201516419, 0.8209662230556729, 0.21139898162437798, 0.1688870937588257, 0.10534430330520461, 0.10480700262022369, 0.1679727434399425, 0.1833499815402414, 0.19515675001660315, 0.18460727008919675, 0.1859262605963654, 0.17936468176314102, 0.17905755814289293, 0.17593546244017455, 0.1937008247805394, 0.1944227514908241, 0.0911110980351667, 0.09373372619096498, 0.0802896952008525, 0.07900822268337071, 0.0937695611684849, 0.08696590780633029, 0.0883770580070865, 0.09478804872920932, 0.08764660011957659]}, "mutation_prompt": null}
{"id": "2a9a20e9-791f-491d-8b67-8847850d9f55", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolutionCompetitive:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.4 + np.random.rand() * 0.6):  # Adaptive F factor for mutation\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.85):  # Slightly adjusted CR for better diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def adaptive_random_search(self):\n        perturbation = np.random.uniform(-0.4, 0.4, self.dim)  # Adjusted perturbation range\n        candidate = np.clip(self.population[self.global_best] + perturbation, self.lower_bound, self.upper_bound)\n        return candidate\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.2:  # Adjusted chance to use adaptive random search\n                    trial = self.adaptive_random_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "EnhancedDifferentialEvolutionCompetitive", "description": "Enhanced Differential Evolution with Competitive Selection and Adaptive Parameter Tuning for improved exploitation and exploration balance.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9a450dd5-8755-4b03-823a-45a4c1005982", "metadata": {"aucs": [0.8495133406356231, 0.8466855067780171, 0.8513946570963247, 0.8556915906664728, 0.8508747765242319, 0.8313256708718615, 0.8588043967919298, 0.8558207819599282, 0.8402031023808564, 0.5937843203816686, 0.6206567150332712, 0.6566303118640022, 0.6429896478072117, 0.647561150095118, 0.6573618112310825, 0.6061636411460535, 0.681440254822538, 0.641483380720212, 0.12760909738244552, 0.14345946555952027, 0.21072612745566188, 0.15514896939455136, 0.13972684978093652, 0.11722127765687618, 0.1428735724982647, 0.5119195969265863, 0.1335196676432472, 0.1232043609205622, 0.12382214736356578, 0.12295404957714984, 0.1087966889999088, 0.13572913014562982, 0.1511738120581524, 0.1278881243949903, 0.11353815401379275, 0.1372419546110918, 0.9573142676820708, 0.9530001663972596, 0.9536849873471137, 0.9691416565251385, 0.9774221972800406, 0.9261215900578411, 0.9727345851412048, 0.9843542343393133, 0.9489600307846774, 0.5706473931003133, 0.5263466035348068, 0.5486952593813329, 0.5438335673087453, 0.5238917881866674, 0.5266731432733429, 0.5373338317665586, 0.5249167052308581, 0.5212305310157028, 0.6363248777089893, 0.7556220807077074, 0.22846412946655392, 0.830966751876892, 0.8435046327610771, 0.8088943926043503, 0.6428874948401168, 0.709281712838237, 0.6712664145495992, 0.52613887871172, 0.30604795298135046, 0.23986665994618983, 0.38141742087630637, 0.3267988104599897, 0.36383112666414885, 0.21388423291778547, 0.2106062929075877, 0.24799229104644216, 0.4362299618551474, 0.2480627320318901, 0.12938015146471316, 0.26246219177609664, 0.4159805863978878, 0.2048411749278436, 0.2644894007697426, 0.12129483581760647, 0.12672075684367268, 0.24305770642396474, 0.1924226399964486, 0.2923065930912927, 0.3205285508381919, 0.265864355153162, 0.13340776356457695, 0.34166341456197646, 0.20995361398640633, 0.2486738108371871, 0.47017389707433344, 0.4497762172373859, 0.44002080755220097, 0.368302638841984, 0.4085800807276453, 0.42932539302838035, 0.2695744228279866, 0.46894362265196865, 0.3266525961754392, 0.15332551835117325, 0.06330057551466473, 0.07864125582119919, 0.22109822106370958, 0.1623769432120844, 0.16412516768248642, 0.17337662737260018, 0.14645624223801246, 0.1367405475258482, 0.28178980831639966, 0.26351170610225727, 0.26336837614265174, 0.27372314010532917, 0.2712512744176909, 0.30504947940898264, 0.2822387068458595, 0.29196226772613676, 0.301156860031248, 0.6927570639471088, 0.6591172428269773, 0.6712536747642046, 0.6575510269241709, 0.6620173596840281, 0.6699359091675814, 0.655432007833028, 0.7220484320291843, 0.6790841374712753, 0.11934311323232905, 0.10142751386477555, 0.11715017690154272, 0.1121174016414872, 0.10969688469405414, 0.08796417776700183, 0.11881052099974132, 0.13618160185717443, 0.10202402783296205, 0.2707626687766582, 0.6022559453942372, 0.20831219444508464, 0.5092939168504723, 0.5964002503067694, 0.17651308315311398, 0.6201134962320644, 0.5100796048030397, 0.2623727986610591, 0.21231643067606998, 0.3772631662676055, 0.42468665750268586, 0.412567973177397, 0.4396799682178214, 0.23296224378829034, 0.46395125462648934, 0.4601853873909838, 0.4445041737141784, 0.2855967022955713, 0.24640596819318195, 0.29902517148118746, 0.264560743189969, 0.3271074453272367, 0.3412476068095335, 0.30773549548754275, 0.36637565293486674, 0.3323262625570056, 0.207838815229747, 0.21789308446664468, 0.21510383984593395, 0.22373675148021954, 0.20619641917398868, 0.20185197076238048, 0.2033250519412939, 0.2187049970219398, 0.20312226592432625, 0.535813488203994, 0.6741017459650877, 0.4554443268979236, 0.2467120148565527, 0.20923214475991403, 0.2337314258843275, 0.2530497786572433, 0.2511496973412298, 0.45453617798987567, 0.9136786457395403, 0.12725250276643219, 0.1548554778780613, 0.17355038433038683, 0.2018361053814146, 0.2009988335238726, 0.14297374742891167, 0.17042246595233534, 0.8927019435806154, 0.8713215836241923, 0.21342799392025302, 0.2094505201516419, 0.8209662230556729, 0.21139898162437798, 0.1688870937588257, 0.10534430330520461, 0.10480700262022369, 0.1679727434399425, 0.1833499815402414, 0.19515675001660315, 0.18460727008919675, 0.1859262605963654, 0.17936468176314102, 0.17905755814289293, 0.17593546244017455, 0.1937008247805394, 0.1944227514908241, 0.0911110980351667, 0.09373372619096498, 0.0802896952008525, 0.07900822268337071, 0.0937695611684849, 0.08696590780633029, 0.0883770580070865, 0.09478804872920932, 0.08764660011957659]}, "mutation_prompt": null}
{"id": "6905ab66-7276-4172-aaad-3b408416ed77", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.5 + np.random.rand() * 0.5):  # Slightly adjusted adaptive F factor\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):  # Fine-tuned crossover rate for diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def guided_search(self):\n        direction = np.random.uniform(-1.0, 1.0, self.dim)\n        guide = np.clip(self.population[self.global_best] + 0.2 * direction, self.lower_bound, self.upper_bound)\n        return guide\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.25:  # Increased chance to use guided search\n                    trial = self.guided_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridAdaptiveDifferentialEvolution", "description": "Hybrid Adaptive Differential Evolution with Guided Search for Enhanced Convergence.", "configspace": "", "generation": 55, "fitness": 0.38268753436300385, "feedback": "The algorithm HybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.28.", "error": "", "parent_id": "9a450dd5-8755-4b03-823a-45a4c1005982", "metadata": {"aucs": [0.8701120635139404, 0.8677838411045177, 0.8553302640436486, 0.8733341512636563, 0.8779275801594602, 0.8631257866302713, 0.8768535626281874, 0.8677920876265968, 0.8745723664812668, 0.6595920228782264, 0.6835244373074782, 0.6771432469747519, 0.5885939892527814, 0.6500063246291172, 0.637541438764744, 0.5355020431785278, 0.6576012898629728, 0.4739339404799814, 0.1766257854104939, 0.10028573675548524, 0.12157331102853719, 0.08382027605649434, 0.08736015662264851, 0.09727617971343483, 0.14699846353833035, 0.17395620930083477, 0.15869527710112963, 0.11573224286924433, 0.06609510172629618, 0.06211531884926591, 0.1151007098130673, 0.05081337059789859, 0.06961335752171705, 0.1454000247934888, 0.05913495880103237, 0.09910510946658446, 0.9762664461035179, 0.9456784922827046, 0.9793781979481453, 0.9737302682524571, 0.9743730062816319, 0.8956591209749616, 0.9560751543888608, 0.9837523071675339, 0.9381568826315719, 0.6343903767325434, 0.6652541313116588, 0.5815541914700436, 0.5915947257897334, 0.6207550141118101, 0.6010284333792573, 0.6501852663388421, 0.6350573970945292, 0.61735095354645, 0.23113109568059176, 0.13666395020588606, 0.17235615181934993, 0.8909442839484986, 0.1932229192154643, 0.28145953684729574, 0.8896776323368549, 0.13195658238297525, 0.8851251132279552, 0.4373355360636696, 0.246670377557622, 0.16342113675888026, 0.24713264139351754, 0.333201950342789, 0.3554319358683201, 0.3789192466040944, 0.13396501965669627, 0.2506594487593681, 0.6372645569296719, 0.2500535182452711, 0.22587939895638864, 0.2886155752921583, 0.3697927368948857, 0.3345062485472007, 0.2231327605997271, 0.1867546245242776, 0.20128331562067292, 0.09223080293511887, 0.40145076181582817, 0.4340203378458417, 0.04112565784914202, 0.14413113519443432, 0.33415690103013407, 0.28404754681104893, 0.1061064923952697, 0.44569726681161914, 0.6448790344246242, 0.21207275021879246, 0.39312612218022736, 0.555865775219667, 0.5740633845944019, 0.3776663937812458, 0.37130742319742693, 0.3473503525461963, 0.4696775215665582, 0.10439943868874746, 0.19687228204100038, 0.13502214820522151, 0.4100004206015776, 0.30863199698441846, 0.38069126538467757, 0.09880809622958131, 0.17524945942708803, 0.3291931622366149, 0.35283391007612097, 0.3656723136185146, 0.3202237806761682, 0.3807632054166503, 0.39634346457131975, 0.3274224563710523, 0.3320481684075276, 0.3400113473820877, 0.30362557895604847, 0.7966505104010551, 0.7833815565390648, 0.7659486387412797, 0.7915048952663282, 0.7759103364949282, 0.7642355845615405, 0.7950657862143864, 0.7646844850765779, 0.7716234504827703, 0.11070055559590619, 0.03235280942984298, 0.11318312575853817, 0.06307174289090256, 0.08683993244120392, 0.0888833841262473, 0.1476179481028077, 0.11045803313967573, 0.0876487268157593, 0.7145016840737239, 0.668679375544815, 0.23931408049921687, 0.6759353362736633, 0.6991011433132335, 0.6878359708507803, 0.6529416975550209, 0.3425192162463705, 0.28943843876440156, 0.13755514311225947, 0.4776164605080053, 0.47873669098326677, 0.26829649936740896, 0.22897523881996285, 0.4933833615037666, 0.2595755483114631, 0.5063242498344667, 0.5023299144358919, 0.35124946002079693, 0.41208479426050637, 0.3273184912328032, 0.18271188552281648, 0.22315355245922186, 0.2531297204559564, 0.41479987855001665, 0.4257431029140837, 0.43500043657189336, 0.2144204750634603, 0.22322588838869528, 0.2054721836566108, 0.29542659872444577, 0.23351960470971223, 0.21547015926491864, 0.2174750077990768, 0.19755524027722626, 0.20492120446023177, 0.20665755372682415, 0.19415217985118216, 0.1977675933555555, 0.22621327331595376, 0.7663038669571772, 0.21067334801237148, 0.18919674573262923, 0.22524859550613296, 0.1976550946667266, 0.1489058033199765, 0.12744266758109934, 0.15489775725077493, 0.952895986727425, 0.2021347793261229, 0.20162982595770318, 0.9299467173578883, 0.1705555319760741, 0.15461874087948602, 0.9231883531430638, 0.21458593496014966, 0.15547715846481547, 0.10495735851719312, 0.8553265601044483, 0.15322300668595268, 0.10524334936645396, 0.10513119764023071, 0.8112679329762931, 0.18162439927446716, 0.17874172357951779, 0.17864688368682857, 0.18546069789458697, 0.1885834418915815, 0.1888070244557758, 0.19358441257526082, 0.18294376031376125, 0.19278293622534415, 0.08640863447931735, 0.08223537952501592, 0.08924267659980212, 0.08681471855377565, 0.07111902872067344, 0.106209568221868, 0.0853346261487371, 0.08175374900890098, 0.1058597689604569]}, "mutation_prompt": null}
{"id": "44b9b74f-60c0-403d-b65e-a83530a540c2", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.5 + np.random.rand() * 0.5):  # Slightly adjusted adaptive F factor\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):  # Fine-tuned crossover rate for diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def guided_search(self):\n        direction = np.random.uniform(-1.0, 1.0, self.dim)\n        guide = np.clip(self.population[self.global_best] + 0.2 * direction, self.lower_bound, self.upper_bound)\n        return guide\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.25:  # Increased chance to use guided search\n                    trial = self.guided_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridAdaptiveDifferentialEvolution", "description": "Hybrid Adaptive Differential Evolution with Guided Search for Enhanced Convergence.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6905ab66-7276-4172-aaad-3b408416ed77", "metadata": {"aucs": [0.8701120635139404, 0.8677838411045177, 0.8553302640436486, 0.8733341512636563, 0.8779275801594602, 0.8631257866302713, 0.8768535626281874, 0.8677920876265968, 0.8745723664812668, 0.6595920228782264, 0.6835244373074782, 0.6771432469747519, 0.5885939892527814, 0.6500063246291172, 0.637541438764744, 0.5355020431785278, 0.6576012898629728, 0.4739339404799814, 0.1766257854104939, 0.10028573675548524, 0.12157331102853719, 0.08382027605649434, 0.08736015662264851, 0.09727617971343483, 0.14699846353833035, 0.17395620930083477, 0.15869527710112963, 0.11573224286924433, 0.06609510172629618, 0.06211531884926591, 0.1151007098130673, 0.05081337059789859, 0.06961335752171705, 0.1454000247934888, 0.05913495880103237, 0.09910510946658446, 0.9762664461035179, 0.9456784922827046, 0.9793781979481453, 0.9737302682524571, 0.9743730062816319, 0.8956591209749616, 0.9560751543888608, 0.9837523071675339, 0.9381568826315719, 0.6343903767325434, 0.6652541313116588, 0.5815541914700436, 0.5915947257897334, 0.6207550141118101, 0.6010284333792573, 0.6501852663388421, 0.6350573970945292, 0.61735095354645, 0.23113109568059176, 0.13666395020588606, 0.17235615181934993, 0.8909442839484986, 0.1932229192154643, 0.28145953684729574, 0.8896776323368549, 0.13195658238297525, 0.8851251132279552, 0.4373355360636696, 0.246670377557622, 0.16342113675888026, 0.24713264139351754, 0.333201950342789, 0.3554319358683201, 0.3789192466040944, 0.13396501965669627, 0.2506594487593681, 0.6372645569296719, 0.2500535182452711, 0.22587939895638864, 0.2886155752921583, 0.3697927368948857, 0.3345062485472007, 0.2231327605997271, 0.1867546245242776, 0.20128331562067292, 0.09223080293511887, 0.40145076181582817, 0.4340203378458417, 0.04112565784914202, 0.14413113519443432, 0.33415690103013407, 0.28404754681104893, 0.1061064923952697, 0.44569726681161914, 0.6448790344246242, 0.21207275021879246, 0.39312612218022736, 0.555865775219667, 0.5740633845944019, 0.3776663937812458, 0.37130742319742693, 0.3473503525461963, 0.4696775215665582, 0.10439943868874746, 0.19687228204100038, 0.13502214820522151, 0.4100004206015776, 0.30863199698441846, 0.38069126538467757, 0.09880809622958131, 0.17524945942708803, 0.3291931622366149, 0.35283391007612097, 0.3656723136185146, 0.3202237806761682, 0.3807632054166503, 0.39634346457131975, 0.3274224563710523, 0.3320481684075276, 0.3400113473820877, 0.30362557895604847, 0.7966505104010551, 0.7833815565390648, 0.7659486387412797, 0.7915048952663282, 0.7759103364949282, 0.7642355845615405, 0.7950657862143864, 0.7646844850765779, 0.7716234504827703, 0.11070055559590619, 0.03235280942984298, 0.11318312575853817, 0.06307174289090256, 0.08683993244120392, 0.0888833841262473, 0.1476179481028077, 0.11045803313967573, 0.0876487268157593, 0.7145016840737239, 0.668679375544815, 0.23931408049921687, 0.6759353362736633, 0.6991011433132335, 0.6878359708507803, 0.6529416975550209, 0.3425192162463705, 0.28943843876440156, 0.13755514311225947, 0.4776164605080053, 0.47873669098326677, 0.26829649936740896, 0.22897523881996285, 0.4933833615037666, 0.2595755483114631, 0.5063242498344667, 0.5023299144358919, 0.35124946002079693, 0.41208479426050637, 0.3273184912328032, 0.18271188552281648, 0.22315355245922186, 0.2531297204559564, 0.41479987855001665, 0.4257431029140837, 0.43500043657189336, 0.2144204750634603, 0.22322588838869528, 0.2054721836566108, 0.29542659872444577, 0.23351960470971223, 0.21547015926491864, 0.2174750077990768, 0.19755524027722626, 0.20492120446023177, 0.20665755372682415, 0.19415217985118216, 0.1977675933555555, 0.22621327331595376, 0.7663038669571772, 0.21067334801237148, 0.18919674573262923, 0.22524859550613296, 0.1976550946667266, 0.1489058033199765, 0.12744266758109934, 0.15489775725077493, 0.952895986727425, 0.2021347793261229, 0.20162982595770318, 0.9299467173578883, 0.1705555319760741, 0.15461874087948602, 0.9231883531430638, 0.21458593496014966, 0.15547715846481547, 0.10495735851719312, 0.8553265601044483, 0.15322300668595268, 0.10524334936645396, 0.10513119764023071, 0.8112679329762931, 0.18162439927446716, 0.17874172357951779, 0.17864688368682857, 0.18546069789458697, 0.1885834418915815, 0.1888070244557758, 0.19358441257526082, 0.18294376031376125, 0.19278293622534415, 0.08640863447931735, 0.08223537952501592, 0.08924267659980212, 0.08681471855377565, 0.07111902872067344, 0.106209568221868, 0.0853346261487371, 0.08175374900890098, 0.1058597689604569]}, "mutation_prompt": null}
{"id": "1b6a0572-f5ea-456c-9f87-f67c62134de1", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.5 + np.random.rand() * 0.5):  # Slightly adjusted adaptive F factor\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):  # Fine-tuned crossover rate for diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def guided_search(self):\n        direction = np.random.uniform(-1.0, 1.0, self.dim)\n        guide = np.clip(self.population[self.global_best] + 0.2 * direction, self.lower_bound, self.upper_bound)\n        return guide\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.25:  # Increased chance to use guided search\n                    trial = self.guided_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridAdaptiveDifferentialEvolution", "description": "Hybrid Adaptive Differential Evolution with Guided Search for Enhanced Convergence.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6905ab66-7276-4172-aaad-3b408416ed77", "metadata": {"aucs": [0.8701120635139404, 0.8677838411045177, 0.8553302640436486, 0.8733341512636563, 0.8779275801594602, 0.8631257866302713, 0.8768535626281874, 0.8677920876265968, 0.8745723664812668, 0.6595920228782264, 0.6835244373074782, 0.6771432469747519, 0.5885939892527814, 0.6500063246291172, 0.637541438764744, 0.5355020431785278, 0.6576012898629728, 0.4739339404799814, 0.1766257854104939, 0.10028573675548524, 0.12157331102853719, 0.08382027605649434, 0.08736015662264851, 0.09727617971343483, 0.14699846353833035, 0.17395620930083477, 0.15869527710112963, 0.11573224286924433, 0.06609510172629618, 0.06211531884926591, 0.1151007098130673, 0.05081337059789859, 0.06961335752171705, 0.1454000247934888, 0.05913495880103237, 0.09910510946658446, 0.9762664461035179, 0.9456784922827046, 0.9793781979481453, 0.9737302682524571, 0.9743730062816319, 0.8956591209749616, 0.9560751543888608, 0.9837523071675339, 0.9381568826315719, 0.6343903767325434, 0.6652541313116588, 0.5815541914700436, 0.5915947257897334, 0.6207550141118101, 0.6010284333792573, 0.6501852663388421, 0.6350573970945292, 0.61735095354645, 0.23113109568059176, 0.13666395020588606, 0.17235615181934993, 0.8909442839484986, 0.1932229192154643, 0.28145953684729574, 0.8896776323368549, 0.13195658238297525, 0.8851251132279552, 0.4373355360636696, 0.246670377557622, 0.16342113675888026, 0.24713264139351754, 0.333201950342789, 0.3554319358683201, 0.3789192466040944, 0.13396501965669627, 0.2506594487593681, 0.6372645569296719, 0.2500535182452711, 0.22587939895638864, 0.2886155752921583, 0.3697927368948857, 0.3345062485472007, 0.2231327605997271, 0.1867546245242776, 0.20128331562067292, 0.09223080293511887, 0.40145076181582817, 0.4340203378458417, 0.04112565784914202, 0.14413113519443432, 0.33415690103013407, 0.28404754681104893, 0.1061064923952697, 0.44569726681161914, 0.6448790344246242, 0.21207275021879246, 0.39312612218022736, 0.555865775219667, 0.5740633845944019, 0.3776663937812458, 0.37130742319742693, 0.3473503525461963, 0.4696775215665582, 0.10439943868874746, 0.19687228204100038, 0.13502214820522151, 0.4100004206015776, 0.30863199698441846, 0.38069126538467757, 0.09880809622958131, 0.17524945942708803, 0.3291931622366149, 0.35283391007612097, 0.3656723136185146, 0.3202237806761682, 0.3807632054166503, 0.39634346457131975, 0.3274224563710523, 0.3320481684075276, 0.3400113473820877, 0.30362557895604847, 0.7966505104010551, 0.7833815565390648, 0.7659486387412797, 0.7915048952663282, 0.7759103364949282, 0.7642355845615405, 0.7950657862143864, 0.7646844850765779, 0.7716234504827703, 0.11070055559590619, 0.03235280942984298, 0.11318312575853817, 0.06307174289090256, 0.08683993244120392, 0.0888833841262473, 0.1476179481028077, 0.11045803313967573, 0.0876487268157593, 0.7145016840737239, 0.668679375544815, 0.23931408049921687, 0.6759353362736633, 0.6991011433132335, 0.6878359708507803, 0.6529416975550209, 0.3425192162463705, 0.28943843876440156, 0.13755514311225947, 0.4776164605080053, 0.47873669098326677, 0.26829649936740896, 0.22897523881996285, 0.4933833615037666, 0.2595755483114631, 0.5063242498344667, 0.5023299144358919, 0.35124946002079693, 0.41208479426050637, 0.3273184912328032, 0.18271188552281648, 0.22315355245922186, 0.2531297204559564, 0.41479987855001665, 0.4257431029140837, 0.43500043657189336, 0.2144204750634603, 0.22322588838869528, 0.2054721836566108, 0.29542659872444577, 0.23351960470971223, 0.21547015926491864, 0.2174750077990768, 0.19755524027722626, 0.20492120446023177, 0.20665755372682415, 0.19415217985118216, 0.1977675933555555, 0.22621327331595376, 0.7663038669571772, 0.21067334801237148, 0.18919674573262923, 0.22524859550613296, 0.1976550946667266, 0.1489058033199765, 0.12744266758109934, 0.15489775725077493, 0.952895986727425, 0.2021347793261229, 0.20162982595770318, 0.9299467173578883, 0.1705555319760741, 0.15461874087948602, 0.9231883531430638, 0.21458593496014966, 0.15547715846481547, 0.10495735851719312, 0.8553265601044483, 0.15322300668595268, 0.10524334936645396, 0.10513119764023071, 0.8112679329762931, 0.18162439927446716, 0.17874172357951779, 0.17864688368682857, 0.18546069789458697, 0.1885834418915815, 0.1888070244557758, 0.19358441257526082, 0.18294376031376125, 0.19278293622534415, 0.08640863447931735, 0.08223537952501592, 0.08924267659980212, 0.08681471855377565, 0.07111902872067344, 0.106209568221868, 0.0853346261487371, 0.08175374900890098, 0.1058597689604569]}, "mutation_prompt": null}
{"id": "c360e5de-4271-40f5-8ce9-5fad333fe804", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.permutation(self.pop_size)[:3]  # Randomized parent selection\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.5 + np.random.rand() * 0.5):\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=None):\n        CR = CR or (0.7 + np.random.rand() * 0.2)  # Adaptive crossover rate\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def guided_search(self):\n        direction = np.random.uniform(-1.0, 1.0, self.dim)\n        guide = np.clip(self.population[self.global_best] + 0.2 * direction, self.lower_bound, self.upper_bound)\n        return guide\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.3:  # Slightly increased chance to use guided search\n                    trial = self.guided_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "EnhancedHybridAdaptiveDifferentialEvolution", "description": "Enhanced Hybrid Adaptive Differential Evolution with Randomized Parent Selection and Adaptive Crossover for Faster Convergence.", "configspace": "", "generation": 58, "fitness": 0.3150320010530064, "feedback": "The algorithm EnhancedHybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.", "error": "", "parent_id": "6905ab66-7276-4172-aaad-3b408416ed77", "metadata": {"aucs": [0.8036316652036799, 0.7671677713740883, 0.7959466666538122, 0.7978346301585778, 0.7694521056751009, 0.8062154637451481, 0.760103820901571, 0.8011971929520156, 0.7983657775945848, 0.4327432753463206, 0.46651642293940543, 0.34675809655294654, 0.4644519036391228, 0.42191065375103776, 0.3740021690597055, 0.43847387158774165, 0.4770809891444705, 0.4610707438661408, 0.15727768491327043, 0.1336518999780315, 0.3051993407239877, 0.11278007039741611, 0.12283196236973748, 0.12956579644278376, 0.12149870518998429, 0.12036158913739126, 0.13753169853554448, 0.08441684934093441, 0.07032095467165833, 0.14449197956171977, 0.0988816113394172, 0.15246190996675268, 0.11425953009616874, 0.11532539115588247, 0.13110144596926498, 0.08945687643321198, 0.9709626881902345, 0.9634908806400775, 0.9693295652664888, 0.9807361795277038, 0.9645665070331737, 0.9740474892763709, 0.9837296905428314, 0.9658314343108825, 0.9895974975705719, 0.43859699262697704, 0.44837955099211213, 0.4339630729236129, 0.44226266855240237, 0.4203922248343023, 0.44814163823013264, 0.453773754466535, 0.44731605143535913, 0.42218618368036454, 0.8087717997499246, 0.6885291377263345, 0.668844288706463, 0.7847910092060071, 0.6082476878889066, 0.8134283443369991, 0.12023696169424058, 0.149818185878706, 0.66309148240428, 0.3835794020723168, 0.134663470035995, 0.23576208769825857, 0.2712956058738185, 0.24585804952216306, 0.21070046152611155, 0.2887229869067951, 0.24522041848055065, 0.22529126889811335, 0.30397192572698273, 0.2568225834148431, 0.26320434842155094, 0.287078916588155, 0.2295925499352207, 0.24837432455324193, 0.11945285182500753, 0.2752224876034326, 0.1281817086094048, 0.10392899135274203, 0.13750867414752554, 0.17699282967715046, 0.19398473835115515, 0.14064584730098217, 0.13407413353502562, 0.12699059450088002, 0.1831094440720088, 0.19290529517284172, 0.2428407211925624, 0.23104862970911189, 0.31475370027969607, 0.29241423920214615, 0.2572797977806547, 0.2043951654298125, 0.3229356096906646, 0.24609203200341012, 0.2898556222859906, 0.05895043526463617, 0.05134607266694435, 0.05108856696294439, 0.05347465584951039, 0.07908930884394683, 0.06918746094309847, 0.0848339007364366, 0.09545262372015806, 0.053155587227204926, 0.17421117892904225, 0.181507434835797, 0.17792144430436252, 0.18596564278424943, 0.21028229647833496, 0.20264291172466053, 0.19144104255014305, 0.1931994600043465, 0.18455744473566005, 0.5646504805076131, 0.5681233293701168, 0.543366928522879, 0.5653931061454909, 0.5437898847656962, 0.5523230091293665, 0.5844521434417957, 0.5509450746591393, 0.5494124921665289, 0.11380123154698263, 0.1245306592521912, 0.07025580813987786, 0.06574323888913225, 0.07891780245409752, 0.10943574218329866, 0.049197278247385845, 0.10951446988171953, 0.08300472904847234, 0.2601324338029194, 0.41271452377156026, 0.22181720489016132, 0.222915248809325, 0.42155829009560264, 0.26406016152544876, 0.4674169009640966, 0.16407450132864054, 0.254513548200196, 0.36053350022682984, 0.34801649226665876, 0.3119204727478977, 0.2202047693404927, 0.3763873352624184, 0.21141726591956334, 0.37899582486995875, 0.3724985167287125, 0.37277929118259734, 0.25279983205714607, 0.2358616146993725, 0.23207373814940557, 0.20236518411023552, 0.18805469137607633, 0.19508578387363418, 0.17474095901943087, 0.30248430447345376, 0.24422869547910786, 0.2051563640806594, 0.18037267654627775, 0.21621103050387247, 0.19758743528088585, 0.2485003223842812, 0.18942541203228414, 0.22660898633316395, 0.21854006637293255, 0.20646958319897524, 0.22606297821696664, 0.2142820808428999, 0.19726579492454155, 0.5499018833020806, 0.20205933746851756, 0.206428643425989, 0.19581081612656437, 0.22236171767207014, 0.24916468548246418, 0.1054749285458303, 0.16967931845052953, 0.15491272571065962, 0.17322620590986093, 0.20178222898706555, 0.15459477638252606, 0.14344766949371857, 0.18937579339342914, 0.9235612300348836, 0.8222978048831588, 0.21457377725847282, 0.8010601323582852, 0.8070289434504981, 0.21344883916831758, 0.10550717123901088, 0.10528163613289654, 0.16754904825682082, 0.7284632783614258, 0.18633275999424248, 0.1877911413066623, 0.1771009417473366, 0.18093124676332006, 0.20928785402413463, 0.18374584863369026, 0.1977734887446877, 0.18217301283990794, 0.19284301036589369, 0.08304862270773139, 0.08981212470872812, 0.07566157792573358, 0.08056745604378812, 0.07676705149985552, 0.07463952326762535, 0.09891544146539288, 0.07579575838320685, 0.07328108529347666]}, "mutation_prompt": null}
{"id": "c0e60859-5544-4522-a442-d0cba113554c", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.5 + np.random.rand() * 0.5):  # Slightly adjusted adaptive F factor\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):  # Fine-tuned crossover rate for diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def guided_search(self):\n        direction = np.random.uniform(-1.0, 1.0, self.dim)\n        guide = np.clip(self.population[self.global_best] + 0.2 * direction, self.lower_bound, self.upper_bound)\n        return guide\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.25:  # Increased chance to use guided search\n                    trial = self.guided_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridAdaptiveDifferentialEvolution", "description": "Hybrid Adaptive Differential Evolution with Guided Search for Enhanced Convergence.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6905ab66-7276-4172-aaad-3b408416ed77", "metadata": {"aucs": [0.8701120635139404, 0.8677838411045177, 0.8553302640436486, 0.8733341512636563, 0.8779275801594602, 0.8631257866302713, 0.8768535626281874, 0.8677920876265968, 0.8745723664812668, 0.6595920228782264, 0.6835244373074782, 0.6771432469747519, 0.5885939892527814, 0.6500063246291172, 0.637541438764744, 0.5355020431785278, 0.6576012898629728, 0.4739339404799814, 0.1766257854104939, 0.10028573675548524, 0.12157331102853719, 0.08382027605649434, 0.08736015662264851, 0.09727617971343483, 0.14699846353833035, 0.17395620930083477, 0.15869527710112963, 0.11573224286924433, 0.06609510172629618, 0.06211531884926591, 0.1151007098130673, 0.05081337059789859, 0.06961335752171705, 0.1454000247934888, 0.05913495880103237, 0.09910510946658446, 0.9762664461035179, 0.9456784922827046, 0.9793781979481453, 0.9737302682524571, 0.9743730062816319, 0.8956591209749616, 0.9560751543888608, 0.9837523071675339, 0.9381568826315719, 0.6343903767325434, 0.6652541313116588, 0.5815541914700436, 0.5915947257897334, 0.6207550141118101, 0.6010284333792573, 0.6501852663388421, 0.6350573970945292, 0.61735095354645, 0.23113109568059176, 0.13666395020588606, 0.17235615181934993, 0.8909442839484986, 0.1932229192154643, 0.28145953684729574, 0.8896776323368549, 0.13195658238297525, 0.8851251132279552, 0.4373355360636696, 0.246670377557622, 0.16342113675888026, 0.24713264139351754, 0.333201950342789, 0.3554319358683201, 0.3789192466040944, 0.13396501965669627, 0.2506594487593681, 0.6372645569296719, 0.2500535182452711, 0.22587939895638864, 0.2886155752921583, 0.3697927368948857, 0.3345062485472007, 0.2231327605997271, 0.1867546245242776, 0.20128331562067292, 0.09223080293511887, 0.40145076181582817, 0.4340203378458417, 0.04112565784914202, 0.14413113519443432, 0.33415690103013407, 0.28404754681104893, 0.1061064923952697, 0.44569726681161914, 0.6448790344246242, 0.21207275021879246, 0.39312612218022736, 0.555865775219667, 0.5740633845944019, 0.3776663937812458, 0.37130742319742693, 0.3473503525461963, 0.4696775215665582, 0.10439943868874746, 0.19687228204100038, 0.13502214820522151, 0.4100004206015776, 0.30863199698441846, 0.38069126538467757, 0.09880809622958131, 0.17524945942708803, 0.3291931622366149, 0.35283391007612097, 0.3656723136185146, 0.3202237806761682, 0.3807632054166503, 0.39634346457131975, 0.3274224563710523, 0.3320481684075276, 0.3400113473820877, 0.30362557895604847, 0.7966505104010551, 0.7833815565390648, 0.7659486387412797, 0.7915048952663282, 0.7759103364949282, 0.7642355845615405, 0.7950657862143864, 0.7646844850765779, 0.7716234504827703, 0.11070055559590619, 0.03235280942984298, 0.11318312575853817, 0.06307174289090256, 0.08683993244120392, 0.0888833841262473, 0.1476179481028077, 0.11045803313967573, 0.0876487268157593, 0.7145016840737239, 0.668679375544815, 0.23931408049921687, 0.6759353362736633, 0.6991011433132335, 0.6878359708507803, 0.6529416975550209, 0.3425192162463705, 0.28943843876440156, 0.13755514311225947, 0.4776164605080053, 0.47873669098326677, 0.26829649936740896, 0.22897523881996285, 0.4933833615037666, 0.2595755483114631, 0.5063242498344667, 0.5023299144358919, 0.35124946002079693, 0.41208479426050637, 0.3273184912328032, 0.18271188552281648, 0.22315355245922186, 0.2531297204559564, 0.41479987855001665, 0.4257431029140837, 0.43500043657189336, 0.2144204750634603, 0.22322588838869528, 0.2054721836566108, 0.29542659872444577, 0.23351960470971223, 0.21547015926491864, 0.2174750077990768, 0.19755524027722626, 0.20492120446023177, 0.20665755372682415, 0.19415217985118216, 0.1977675933555555, 0.22621327331595376, 0.7663038669571772, 0.21067334801237148, 0.18919674573262923, 0.22524859550613296, 0.1976550946667266, 0.1489058033199765, 0.12744266758109934, 0.15489775725077493, 0.952895986727425, 0.2021347793261229, 0.20162982595770318, 0.9299467173578883, 0.1705555319760741, 0.15461874087948602, 0.9231883531430638, 0.21458593496014966, 0.15547715846481547, 0.10495735851719312, 0.8553265601044483, 0.15322300668595268, 0.10524334936645396, 0.10513119764023071, 0.8112679329762931, 0.18162439927446716, 0.17874172357951779, 0.17864688368682857, 0.18546069789458697, 0.1885834418915815, 0.1888070244557758, 0.19358441257526082, 0.18294376031376125, 0.19278293622534415, 0.08640863447931735, 0.08223537952501592, 0.08924267659980212, 0.08681471855377565, 0.07111902872067344, 0.106209568221868, 0.0853346261487371, 0.08175374900890098, 0.1058597689604569]}, "mutation_prompt": null}
{"id": "befaed6e-1302-4ba6-bdbf-8ed0f1d1f727", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.5 + np.random.rand() * 0.5):  # Slightly adjusted adaptive F factor\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):  # Fine-tuned crossover rate for diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def guided_search(self):\n        direction = np.random.uniform(-1.0, 1.0, self.dim)\n        guide = np.clip(self.population[self.global_best] + 0.2 * direction, self.lower_bound, self.upper_bound)\n        return guide\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.25:  # Increased chance to use guided search\n                    trial = self.guided_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridAdaptiveDifferentialEvolution", "description": "Hybrid Adaptive Differential Evolution with Guided Search for Enhanced Convergence.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6905ab66-7276-4172-aaad-3b408416ed77", "metadata": {"aucs": [0.8701120635139404, 0.8677838411045177, 0.8553302640436486, 0.8733341512636563, 0.8779275801594602, 0.8631257866302713, 0.8768535626281874, 0.8677920876265968, 0.8745723664812668, 0.6595920228782264, 0.6835244373074782, 0.6771432469747519, 0.5885939892527814, 0.6500063246291172, 0.637541438764744, 0.5355020431785278, 0.6576012898629728, 0.4739339404799814, 0.1766257854104939, 0.10028573675548524, 0.12157331102853719, 0.08382027605649434, 0.08736015662264851, 0.09727617971343483, 0.14699846353833035, 0.17395620930083477, 0.15869527710112963, 0.11573224286924433, 0.06609510172629618, 0.06211531884926591, 0.1151007098130673, 0.05081337059789859, 0.06961335752171705, 0.1454000247934888, 0.05913495880103237, 0.09910510946658446, 0.9762664461035179, 0.9456784922827046, 0.9793781979481453, 0.9737302682524571, 0.9743730062816319, 0.8956591209749616, 0.9560751543888608, 0.9837523071675339, 0.9381568826315719, 0.6343903767325434, 0.6652541313116588, 0.5815541914700436, 0.5915947257897334, 0.6207550141118101, 0.6010284333792573, 0.6501852663388421, 0.6350573970945292, 0.61735095354645, 0.23113109568059176, 0.13666395020588606, 0.17235615181934993, 0.8909442839484986, 0.1932229192154643, 0.28145953684729574, 0.8896776323368549, 0.13195658238297525, 0.8851251132279552, 0.4373355360636696, 0.246670377557622, 0.16342113675888026, 0.24713264139351754, 0.333201950342789, 0.3554319358683201, 0.3789192466040944, 0.13396501965669627, 0.2506594487593681, 0.6372645569296719, 0.2500535182452711, 0.22587939895638864, 0.2886155752921583, 0.3697927368948857, 0.3345062485472007, 0.2231327605997271, 0.1867546245242776, 0.20128331562067292, 0.09223080293511887, 0.40145076181582817, 0.4340203378458417, 0.04112565784914202, 0.14413113519443432, 0.33415690103013407, 0.28404754681104893, 0.1061064923952697, 0.44569726681161914, 0.6448790344246242, 0.21207275021879246, 0.39312612218022736, 0.555865775219667, 0.5740633845944019, 0.3776663937812458, 0.37130742319742693, 0.3473503525461963, 0.4696775215665582, 0.10439943868874746, 0.19687228204100038, 0.13502214820522151, 0.4100004206015776, 0.30863199698441846, 0.38069126538467757, 0.09880809622958131, 0.17524945942708803, 0.3291931622366149, 0.35283391007612097, 0.3656723136185146, 0.3202237806761682, 0.3807632054166503, 0.39634346457131975, 0.3274224563710523, 0.3320481684075276, 0.3400113473820877, 0.30362557895604847, 0.7966505104010551, 0.7833815565390648, 0.7659486387412797, 0.7915048952663282, 0.7759103364949282, 0.7642355845615405, 0.7950657862143864, 0.7646844850765779, 0.7716234504827703, 0.11070055559590619, 0.03235280942984298, 0.11318312575853817, 0.06307174289090256, 0.08683993244120392, 0.0888833841262473, 0.1476179481028077, 0.11045803313967573, 0.0876487268157593, 0.7145016840737239, 0.668679375544815, 0.23931408049921687, 0.6759353362736633, 0.6991011433132335, 0.6878359708507803, 0.6529416975550209, 0.3425192162463705, 0.28943843876440156, 0.13755514311225947, 0.4776164605080053, 0.47873669098326677, 0.26829649936740896, 0.22897523881996285, 0.4933833615037666, 0.2595755483114631, 0.5063242498344667, 0.5023299144358919, 0.35124946002079693, 0.41208479426050637, 0.3273184912328032, 0.18271188552281648, 0.22315355245922186, 0.2531297204559564, 0.41479987855001665, 0.4257431029140837, 0.43500043657189336, 0.2144204750634603, 0.22322588838869528, 0.2054721836566108, 0.29542659872444577, 0.23351960470971223, 0.21547015926491864, 0.2174750077990768, 0.19755524027722626, 0.20492120446023177, 0.20665755372682415, 0.19415217985118216, 0.1977675933555555, 0.22621327331595376, 0.7663038669571772, 0.21067334801237148, 0.18919674573262923, 0.22524859550613296, 0.1976550946667266, 0.1489058033199765, 0.12744266758109934, 0.15489775725077493, 0.952895986727425, 0.2021347793261229, 0.20162982595770318, 0.9299467173578883, 0.1705555319760741, 0.15461874087948602, 0.9231883531430638, 0.21458593496014966, 0.15547715846481547, 0.10495735851719312, 0.8553265601044483, 0.15322300668595268, 0.10524334936645396, 0.10513119764023071, 0.8112679329762931, 0.18162439927446716, 0.17874172357951779, 0.17864688368682857, 0.18546069789458697, 0.1885834418915815, 0.1888070244557758, 0.19358441257526082, 0.18294376031376125, 0.19278293622534415, 0.08640863447931735, 0.08223537952501592, 0.08924267659980212, 0.08681471855377565, 0.07111902872067344, 0.106209568221868, 0.0853346261487371, 0.08175374900890098, 0.1058597689604569]}, "mutation_prompt": null}
{"id": "acc41d70-fbc6-4a37-ac38-5fd283b02d88", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.5 + np.random.rand() * 0.5):  # Slightly adjusted adaptive F factor\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):  # Fine-tuned crossover rate for diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def guided_search(self):\n        direction = np.random.uniform(-1.0, 1.0, self.dim)\n        guide = np.clip(self.population[self.global_best] + 0.2 * direction, self.lower_bound, self.upper_bound)\n        return guide\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.25:  # Increased chance to use guided search\n                    trial = self.guided_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridAdaptiveDifferentialEvolution", "description": "Hybrid Adaptive Differential Evolution with Guided Search for Enhanced Convergence.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6905ab66-7276-4172-aaad-3b408416ed77", "metadata": {"aucs": [0.8701120635139404, 0.8677838411045177, 0.8553302640436486, 0.8733341512636563, 0.8779275801594602, 0.8631257866302713, 0.8768535626281874, 0.8677920876265968, 0.8745723664812668, 0.6595920228782264, 0.6835244373074782, 0.6771432469747519, 0.5885939892527814, 0.6500063246291172, 0.637541438764744, 0.5355020431785278, 0.6576012898629728, 0.4739339404799814, 0.1766257854104939, 0.10028573675548524, 0.12157331102853719, 0.08382027605649434, 0.08736015662264851, 0.09727617971343483, 0.14699846353833035, 0.17395620930083477, 0.15869527710112963, 0.11573224286924433, 0.06609510172629618, 0.06211531884926591, 0.1151007098130673, 0.05081337059789859, 0.06961335752171705, 0.1454000247934888, 0.05913495880103237, 0.09910510946658446, 0.9762664461035179, 0.9456784922827046, 0.9793781979481453, 0.9737302682524571, 0.9743730062816319, 0.8956591209749616, 0.9560751543888608, 0.9837523071675339, 0.9381568826315719, 0.6343903767325434, 0.6652541313116588, 0.5815541914700436, 0.5915947257897334, 0.6207550141118101, 0.6010284333792573, 0.6501852663388421, 0.6350573970945292, 0.61735095354645, 0.23113109568059176, 0.13666395020588606, 0.17235615181934993, 0.8909442839484986, 0.1932229192154643, 0.28145953684729574, 0.8896776323368549, 0.13195658238297525, 0.8851251132279552, 0.4373355360636696, 0.246670377557622, 0.16342113675888026, 0.24713264139351754, 0.333201950342789, 0.3554319358683201, 0.3789192466040944, 0.13396501965669627, 0.2506594487593681, 0.6372645569296719, 0.2500535182452711, 0.22587939895638864, 0.2886155752921583, 0.3697927368948857, 0.3345062485472007, 0.2231327605997271, 0.1867546245242776, 0.20128331562067292, 0.09223080293511887, 0.40145076181582817, 0.4340203378458417, 0.04112565784914202, 0.14413113519443432, 0.33415690103013407, 0.28404754681104893, 0.1061064923952697, 0.44569726681161914, 0.6448790344246242, 0.21207275021879246, 0.39312612218022736, 0.555865775219667, 0.5740633845944019, 0.3776663937812458, 0.37130742319742693, 0.3473503525461963, 0.4696775215665582, 0.10439943868874746, 0.19687228204100038, 0.13502214820522151, 0.4100004206015776, 0.30863199698441846, 0.38069126538467757, 0.09880809622958131, 0.17524945942708803, 0.3291931622366149, 0.35283391007612097, 0.3656723136185146, 0.3202237806761682, 0.3807632054166503, 0.39634346457131975, 0.3274224563710523, 0.3320481684075276, 0.3400113473820877, 0.30362557895604847, 0.7966505104010551, 0.7833815565390648, 0.7659486387412797, 0.7915048952663282, 0.7759103364949282, 0.7642355845615405, 0.7950657862143864, 0.7646844850765779, 0.7716234504827703, 0.11070055559590619, 0.03235280942984298, 0.11318312575853817, 0.06307174289090256, 0.08683993244120392, 0.0888833841262473, 0.1476179481028077, 0.11045803313967573, 0.0876487268157593, 0.7145016840737239, 0.668679375544815, 0.23931408049921687, 0.6759353362736633, 0.6991011433132335, 0.6878359708507803, 0.6529416975550209, 0.3425192162463705, 0.28943843876440156, 0.13755514311225947, 0.4776164605080053, 0.47873669098326677, 0.26829649936740896, 0.22897523881996285, 0.4933833615037666, 0.2595755483114631, 0.5063242498344667, 0.5023299144358919, 0.35124946002079693, 0.41208479426050637, 0.3273184912328032, 0.18271188552281648, 0.22315355245922186, 0.2531297204559564, 0.41479987855001665, 0.4257431029140837, 0.43500043657189336, 0.2144204750634603, 0.22322588838869528, 0.2054721836566108, 0.29542659872444577, 0.23351960470971223, 0.21547015926491864, 0.2174750077990768, 0.19755524027722626, 0.20492120446023177, 0.20665755372682415, 0.19415217985118216, 0.1977675933555555, 0.22621327331595376, 0.7663038669571772, 0.21067334801237148, 0.18919674573262923, 0.22524859550613296, 0.1976550946667266, 0.1489058033199765, 0.12744266758109934, 0.15489775725077493, 0.952895986727425, 0.2021347793261229, 0.20162982595770318, 0.9299467173578883, 0.1705555319760741, 0.15461874087948602, 0.9231883531430638, 0.21458593496014966, 0.15547715846481547, 0.10495735851719312, 0.8553265601044483, 0.15322300668595268, 0.10524334936645396, 0.10513119764023071, 0.8112679329762931, 0.18162439927446716, 0.17874172357951779, 0.17864688368682857, 0.18546069789458697, 0.1885834418915815, 0.1888070244557758, 0.19358441257526082, 0.18294376031376125, 0.19278293622534415, 0.08640863447931735, 0.08223537952501592, 0.08924267659980212, 0.08681471855377565, 0.07111902872067344, 0.106209568221868, 0.0853346261487371, 0.08175374900890098, 0.1058597689604569]}, "mutation_prompt": null}
{"id": "967f21bc-e239-4f6f-992f-1c3b69bd330a", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n        self.archive = []  # Initialize archive for storing fitness history\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.3 + np.random.rand() * 0.7):  # Further adaptive F factor\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.8):  # Adjusted crossover rate for balance\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def guided_search(self):\n        direction = np.random.uniform(-1.0, 1.0, self.dim)\n        guide = np.clip(self.population[self.global_best] + 0.2 * direction, self.lower_bound, self.upper_bound)\n        return guide\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def adjust_population(self):\n        if len(self.archive) > 5 and np.std(self.archive[-5:]) < 0.01:\n            new_pop_size = self.pop_size // 2  # Halve the population size for refined search\n            self.population = self.population[:new_pop_size]\n            self.fitness = self.fitness[:new_pop_size]\n            self.pop_size = new_pop_size\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.3:  # Modified chance to use guided search\n                    trial = self.guided_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n                self.archive.append(trial_fitness)  # Store fitness history\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n            self.adjust_population()  # Adjust population if convergence stalls\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "EnhancedHybridAdaptiveDifferentialEvolution", "description": "Enhanced Hybrid Adaptive Differential Evolution with Dynamic Population and Fitness Memory for Efficient Exploration and Exploitation.", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 14 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 14 is out of bounds for axis 0 with size 10')", "parent_id": "6905ab66-7276-4172-aaad-3b408416ed77", "metadata": {}, "mutation_prompt": null}
{"id": "0d115665-5116-4715-b842-e5862db6ea15", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.5 + np.random.rand() * 0.5):  # Slightly adjusted adaptive F factor\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):  # Fine-tuned crossover rate for diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def guided_search(self):\n        direction = np.random.uniform(-1.0, 1.0, self.dim)\n        guide = np.clip(self.population[self.global_best] + 0.2 * direction, self.lower_bound, self.upper_bound)\n        return guide\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.25:  # Increased chance to use guided search\n                    trial = self.guided_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridAdaptiveDifferentialEvolution", "description": "Hybrid Adaptive Differential Evolution with Guided Search for Enhanced Convergence.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6905ab66-7276-4172-aaad-3b408416ed77", "metadata": {"aucs": [0.8701120635139404, 0.8677838411045177, 0.8553302640436486, 0.8733341512636563, 0.8779275801594602, 0.8631257866302713, 0.8768535626281874, 0.8677920876265968, 0.8745723664812668, 0.6595920228782264, 0.6835244373074782, 0.6771432469747519, 0.5885939892527814, 0.6500063246291172, 0.637541438764744, 0.5355020431785278, 0.6576012898629728, 0.4739339404799814, 0.1766257854104939, 0.10028573675548524, 0.12157331102853719, 0.08382027605649434, 0.08736015662264851, 0.09727617971343483, 0.14699846353833035, 0.17395620930083477, 0.15869527710112963, 0.11573224286924433, 0.06609510172629618, 0.06211531884926591, 0.1151007098130673, 0.05081337059789859, 0.06961335752171705, 0.1454000247934888, 0.05913495880103237, 0.09910510946658446, 0.9762664461035179, 0.9456784922827046, 0.9793781979481453, 0.9737302682524571, 0.9743730062816319, 0.8956591209749616, 0.9560751543888608, 0.9837523071675339, 0.9381568826315719, 0.6343903767325434, 0.6652541313116588, 0.5815541914700436, 0.5915947257897334, 0.6207550141118101, 0.6010284333792573, 0.6501852663388421, 0.6350573970945292, 0.61735095354645, 0.23113109568059176, 0.13666395020588606, 0.17235615181934993, 0.8909442839484986, 0.1932229192154643, 0.28145953684729574, 0.8896776323368549, 0.13195658238297525, 0.8851251132279552, 0.4373355360636696, 0.246670377557622, 0.16342113675888026, 0.24713264139351754, 0.333201950342789, 0.3554319358683201, 0.3789192466040944, 0.13396501965669627, 0.2506594487593681, 0.6372645569296719, 0.2500535182452711, 0.22587939895638864, 0.2886155752921583, 0.3697927368948857, 0.3345062485472007, 0.2231327605997271, 0.1867546245242776, 0.20128331562067292, 0.09223080293511887, 0.40145076181582817, 0.4340203378458417, 0.04112565784914202, 0.14413113519443432, 0.33415690103013407, 0.28404754681104893, 0.1061064923952697, 0.44569726681161914, 0.6448790344246242, 0.21207275021879246, 0.39312612218022736, 0.555865775219667, 0.5740633845944019, 0.3776663937812458, 0.37130742319742693, 0.3473503525461963, 0.4696775215665582, 0.10439943868874746, 0.19687228204100038, 0.13502214820522151, 0.4100004206015776, 0.30863199698441846, 0.38069126538467757, 0.09880809622958131, 0.17524945942708803, 0.3291931622366149, 0.35283391007612097, 0.3656723136185146, 0.3202237806761682, 0.3807632054166503, 0.39634346457131975, 0.3274224563710523, 0.3320481684075276, 0.3400113473820877, 0.30362557895604847, 0.7966505104010551, 0.7833815565390648, 0.7659486387412797, 0.7915048952663282, 0.7759103364949282, 0.7642355845615405, 0.7950657862143864, 0.7646844850765779, 0.7716234504827703, 0.11070055559590619, 0.03235280942984298, 0.11318312575853817, 0.06307174289090256, 0.08683993244120392, 0.0888833841262473, 0.1476179481028077, 0.11045803313967573, 0.0876487268157593, 0.7145016840737239, 0.668679375544815, 0.23931408049921687, 0.6759353362736633, 0.6991011433132335, 0.6878359708507803, 0.6529416975550209, 0.3425192162463705, 0.28943843876440156, 0.13755514311225947, 0.4776164605080053, 0.47873669098326677, 0.26829649936740896, 0.22897523881996285, 0.4933833615037666, 0.2595755483114631, 0.5063242498344667, 0.5023299144358919, 0.35124946002079693, 0.41208479426050637, 0.3273184912328032, 0.18271188552281648, 0.22315355245922186, 0.2531297204559564, 0.41479987855001665, 0.4257431029140837, 0.43500043657189336, 0.2144204750634603, 0.22322588838869528, 0.2054721836566108, 0.29542659872444577, 0.23351960470971223, 0.21547015926491864, 0.2174750077990768, 0.19755524027722626, 0.20492120446023177, 0.20665755372682415, 0.19415217985118216, 0.1977675933555555, 0.22621327331595376, 0.7663038669571772, 0.21067334801237148, 0.18919674573262923, 0.22524859550613296, 0.1976550946667266, 0.1489058033199765, 0.12744266758109934, 0.15489775725077493, 0.952895986727425, 0.2021347793261229, 0.20162982595770318, 0.9299467173578883, 0.1705555319760741, 0.15461874087948602, 0.9231883531430638, 0.21458593496014966, 0.15547715846481547, 0.10495735851719312, 0.8553265601044483, 0.15322300668595268, 0.10524334936645396, 0.10513119764023071, 0.8112679329762931, 0.18162439927446716, 0.17874172357951779, 0.17864688368682857, 0.18546069789458697, 0.1885834418915815, 0.1888070244557758, 0.19358441257526082, 0.18294376031376125, 0.19278293622534415, 0.08640863447931735, 0.08223537952501592, 0.08924267659980212, 0.08681471855377565, 0.07111902872067344, 0.106209568221868, 0.0853346261487371, 0.08175374900890098, 0.1058597689604569]}, "mutation_prompt": null}
{"id": "f169d214-6ca7-4da5-8687-8a948946b7bb", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.5 + np.random.rand() * 0.5):  # Slightly adjusted adaptive F factor\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):  # Fine-tuned crossover rate for diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def guided_search(self):\n        direction = np.random.uniform(-1.0, 1.0, self.dim)\n        guide = np.clip(self.population[self.global_best] + 0.2 * direction, self.lower_bound, self.upper_bound)\n        return guide\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.25:  # Increased chance to use guided search\n                    trial = self.guided_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridAdaptiveDifferentialEvolution", "description": "Hybrid Adaptive Differential Evolution with Guided Search for Enhanced Convergence.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6905ab66-7276-4172-aaad-3b408416ed77", "metadata": {"aucs": [0.8701120635139404, 0.8677838411045177, 0.8553302640436486, 0.8733341512636563, 0.8779275801594602, 0.8631257866302713, 0.8768535626281874, 0.8677920876265968, 0.8745723664812668, 0.6595920228782264, 0.6835244373074782, 0.6771432469747519, 0.5885939892527814, 0.6500063246291172, 0.637541438764744, 0.5355020431785278, 0.6576012898629728, 0.4739339404799814, 0.1766257854104939, 0.10028573675548524, 0.12157331102853719, 0.08382027605649434, 0.08736015662264851, 0.09727617971343483, 0.14699846353833035, 0.17395620930083477, 0.15869527710112963, 0.11573224286924433, 0.06609510172629618, 0.06211531884926591, 0.1151007098130673, 0.05081337059789859, 0.06961335752171705, 0.1454000247934888, 0.05913495880103237, 0.09910510946658446, 0.9762664461035179, 0.9456784922827046, 0.9793781979481453, 0.9737302682524571, 0.9743730062816319, 0.8956591209749616, 0.9560751543888608, 0.9837523071675339, 0.9381568826315719, 0.6343903767325434, 0.6652541313116588, 0.5815541914700436, 0.5915947257897334, 0.6207550141118101, 0.6010284333792573, 0.6501852663388421, 0.6350573970945292, 0.61735095354645, 0.23113109568059176, 0.13666395020588606, 0.17235615181934993, 0.8909442839484986, 0.1932229192154643, 0.28145953684729574, 0.8896776323368549, 0.13195658238297525, 0.8851251132279552, 0.4373355360636696, 0.246670377557622, 0.16342113675888026, 0.24713264139351754, 0.333201950342789, 0.3554319358683201, 0.3789192466040944, 0.13396501965669627, 0.2506594487593681, 0.6372645569296719, 0.2500535182452711, 0.22587939895638864, 0.2886155752921583, 0.3697927368948857, 0.3345062485472007, 0.2231327605997271, 0.1867546245242776, 0.20128331562067292, 0.09223080293511887, 0.40145076181582817, 0.4340203378458417, 0.04112565784914202, 0.14413113519443432, 0.33415690103013407, 0.28404754681104893, 0.1061064923952697, 0.44569726681161914, 0.6448790344246242, 0.21207275021879246, 0.39312612218022736, 0.555865775219667, 0.5740633845944019, 0.3776663937812458, 0.37130742319742693, 0.3473503525461963, 0.4696775215665582, 0.10439943868874746, 0.19687228204100038, 0.13502214820522151, 0.4100004206015776, 0.30863199698441846, 0.38069126538467757, 0.09880809622958131, 0.17524945942708803, 0.3291931622366149, 0.35283391007612097, 0.3656723136185146, 0.3202237806761682, 0.3807632054166503, 0.39634346457131975, 0.3274224563710523, 0.3320481684075276, 0.3400113473820877, 0.30362557895604847, 0.7966505104010551, 0.7833815565390648, 0.7659486387412797, 0.7915048952663282, 0.7759103364949282, 0.7642355845615405, 0.7950657862143864, 0.7646844850765779, 0.7716234504827703, 0.11070055559590619, 0.03235280942984298, 0.11318312575853817, 0.06307174289090256, 0.08683993244120392, 0.0888833841262473, 0.1476179481028077, 0.11045803313967573, 0.0876487268157593, 0.7145016840737239, 0.668679375544815, 0.23931408049921687, 0.6759353362736633, 0.6991011433132335, 0.6878359708507803, 0.6529416975550209, 0.3425192162463705, 0.28943843876440156, 0.13755514311225947, 0.4776164605080053, 0.47873669098326677, 0.26829649936740896, 0.22897523881996285, 0.4933833615037666, 0.2595755483114631, 0.5063242498344667, 0.5023299144358919, 0.35124946002079693, 0.41208479426050637, 0.3273184912328032, 0.18271188552281648, 0.22315355245922186, 0.2531297204559564, 0.41479987855001665, 0.4257431029140837, 0.43500043657189336, 0.2144204750634603, 0.22322588838869528, 0.2054721836566108, 0.29542659872444577, 0.23351960470971223, 0.21547015926491864, 0.2174750077990768, 0.19755524027722626, 0.20492120446023177, 0.20665755372682415, 0.19415217985118216, 0.1977675933555555, 0.22621327331595376, 0.7663038669571772, 0.21067334801237148, 0.18919674573262923, 0.22524859550613296, 0.1976550946667266, 0.1489058033199765, 0.12744266758109934, 0.15489775725077493, 0.952895986727425, 0.2021347793261229, 0.20162982595770318, 0.9299467173578883, 0.1705555319760741, 0.15461874087948602, 0.9231883531430638, 0.21458593496014966, 0.15547715846481547, 0.10495735851719312, 0.8553265601044483, 0.15322300668595268, 0.10524334936645396, 0.10513119764023071, 0.8112679329762931, 0.18162439927446716, 0.17874172357951779, 0.17864688368682857, 0.18546069789458697, 0.1885834418915815, 0.1888070244557758, 0.19358441257526082, 0.18294376031376125, 0.19278293622534415, 0.08640863447931735, 0.08223537952501592, 0.08924267659980212, 0.08681471855377565, 0.07111902872067344, 0.106209568221868, 0.0853346261487371, 0.08175374900890098, 0.1058597689604569]}, "mutation_prompt": null}
{"id": "ce3b4fb3-2884-45c7-b96d-64d2c50bb7c0", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 10 * dim  # Increased population\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=None):  # Adaptive mutation factor\n        if F is None:\n            F = 0.4 + 0.3 * (self.eval_count / self.budget)  # Linearly decreasing mutation factor\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.85):  # Slightly decreased crossover rate\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def guided_search(self):\n        direction = np.random.uniform(-1.0, 1.0, self.dim)\n        guide = np.clip(self.population[self.global_best] + 0.15 * direction, self.lower_bound, self.upper_bound)\n        return guide\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.3:  # Adjusted chance to use guided search\n                    trial = self.guided_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Differential Evolution with Adaptive Mutation and Dynamic Population for Faster Convergence.", "configspace": "", "generation": 65, "fitness": 0.3162180827653823, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.25.", "error": "", "parent_id": "6905ab66-7276-4172-aaad-3b408416ed77", "metadata": {"aucs": [0.843523212924341, 0.8672885977055661, 0.8793767235014576, 0.8551261519351069, 0.8500086698545286, 0.8772369708866758, 0.8565346865304742, 0.8758486374178562, 0.8490969796915409, 0.6610550864945868, 0.43741279340951766, 0.6175568171036571, 0.48094074487433114, 0.49464207070285604, 0.5543625919142623, 0.3139418672566814, 0.5977567470745389, 0.37484910550921635, 0.10168114289664176, 0.10576227864333321, 0.11742160647376043, 0.12641529190889356, 0.11781417846228304, 0.08934601702116052, 0.1470804528687868, 0.16160185517779768, 0.1575599683021588, 0.09752293249949995, 0.09419317121695203, 0.029459002921857214, 0.10215371210290847, 0.023992553632969038, 0.055765994621653214, 0.11613041681918257, 0.07941022402249731, 0.06617548713957988, 0.9576983142409292, 0.8949387320500456, 0.9544945061441016, 0.9521574147131215, 0.9306754652368237, 0.9289940493279473, 0.9489341000121562, 0.9740235373708227, 0.9142213867082322, 0.5291902355689333, 0.5014553617945506, 0.4861099104048031, 0.5276609988387355, 0.5170581107019911, 0.5333557907615951, 0.5831565732692867, 0.5216511973893727, 0.5478364051626707, 0.21125778905139914, 0.18843805532860924, 0.22688105376720413, 0.22225233267906785, 0.2821583845973987, 0.2814724087408571, 0.17561135556867835, 0.23666041749925004, 0.08414042229561691, 0.4154067225470597, 0.17407963922180592, 0.24249421965407325, 0.2469017284998214, 0.22717366653722182, 0.29174360959903456, 0.21041393257732355, 0.13702949641086848, 0.2693860989103406, 0.23835673255519985, 0.1341986505657582, 0.22817807068492835, 0.3269520248196762, 0.3284770590548385, 0.23927486715455426, 0.25450470143086346, 0.2166116658030478, 0.134147333129234, 0.1885930102039851, 0.08299513869235053, 0.12067237484992022, 0.14485507725128555, 0.14665439612050724, 0.03760109510919629, 0.16692822963706333, 0.16373936708291026, 0.28741370546030265, 0.3698777604256568, 0.16786770514389882, 0.12830309616232538, 0.3699202176426425, 0.10138732753286772, 0.13177961877627709, 0.42247988784980617, 0.15776696165088255, 0.25964622104933277, 0.09725839450674334, 0.07522874100124133, 0.16847405779186408, 0.2077565554328057, 0.18554958368957575, 0.2455114923042725, 0.22643229875296833, 0.16033560231838218, 0.18105159248743907, 0.28144534655888853, 0.1681230043142552, 0.23173543771181382, 0.19429120584462867, 0.2996940532932051, 0.2575928560116537, 0.26572108552214013, 0.2626404342392922, 0.20744598246920665, 0.6693969233303945, 0.6901728486647736, 0.7046433109927013, 0.6607065929863674, 0.6736421061294302, 0.6588066292484704, 0.6736254914158311, 0.6633437007112475, 0.6609515866602642, 0.08589132700690294, 0.0836727220502862, 0.05576483368707286, 0.09192669217902916, 0.13457638286069773, 0.09021548428645842, 0.14707701337683943, 0.11725117128377316, 0.08150697038653887, 0.21940943783815836, 0.43714825398239165, 0.2380850348464565, 0.4947404606353717, 0.6296902821567636, 0.22569852948387625, 0.28283518410399, 0.21596646792243346, 0.2331024936213465, 0.4208818664219116, 0.18336648324220728, 0.4279673488052461, 0.44259432398159293, 0.3303322067504417, 0.19765494390490768, 0.21984618817101975, 0.455319900240723, 0.2719205894489558, 0.2567647498267782, 0.16440153411150915, 0.299502383066237, 0.1787106665544077, 0.11186163835086593, 0.2227904351163944, 0.13255110001744907, 0.3439613633094434, 0.3023084552255967, 0.22762766141237623, 0.20915335989220873, 0.2389729322303198, 0.24936757861878467, 0.19428790815847974, 0.23715907783470846, 0.2350571016028261, 0.24084367013274266, 0.28280033612797073, 0.20662364216659612, 0.25139375680133114, 0.1900828583136981, 0.19212097064251232, 0.23032294032570377, 0.19511127936415595, 0.18006665253362475, 0.7613944145381912, 0.1863896580957235, 0.1778634253288619, 0.17779059010742426, 0.1546571019132672, 0.18889842428683545, 0.20200834340410023, 0.2006582276235812, 0.1431864934632484, 0.16451198644314025, 0.934621196215366, 0.8641145033669154, 0.21428849710582376, 0.07364059513868815, 0.169235976830168, 0.15516072226283828, 0.15378239086534973, 0.15703817195648695, 0.8659043260181042, 0.7329531082749817, 0.1758486524865901, 0.18589726483923164, 0.20932617248641394, 0.18419231364197408, 0.18604367387607668, 0.19847381694530863, 0.21084379300682365, 0.19071135820372154, 0.17885561317297327, 0.08528631340002502, 0.08749447281247902, 0.08688072484915177, 0.09333433156021675, 0.07781045599166503, 0.09313559769006896, 0.08548578048261701, 0.0935115199405776, 0.08967184935542605]}, "mutation_prompt": null}
{"id": "1c937bde-de39-44be-95d8-9d66b509397f", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n        self.dynamic_pop_size = self.pop_size\n\n    def evaluate_population(self, func):\n        for i in range(self.dynamic_pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.dynamic_pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.6 + np.random.rand() * 0.4):  # Adjusted adaptive F factor\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.85):  # Adjusted crossover rate for diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def guided_search(self):\n        direction = np.random.uniform(-0.5, 0.5, self.dim)  # Reduced search range\n        guide = np.clip(self.population[self.global_best] + 0.3 * direction, self.lower_bound, self.upper_bound)\n        return guide\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.dynamic_pop_size):\n                if np.random.rand() < 0.3:  # Adjusted chance to use guided search\n                    trial = self.guided_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n            self.dynamic_pop_size = max(4, int(self.pop_size * (1 - self.eval_count / self.budget)))  # Dynamic population adjustment\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Dynamic Population Size for Improved Convergence.", "configspace": "", "generation": 66, "fitness": 0.3344578549388792, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.", "error": "", "parent_id": "6905ab66-7276-4172-aaad-3b408416ed77", "metadata": {"aucs": [0.783718185819533, 0.7962165651464357, 0.7989788807735023, 0.7872034797097339, 0.7781460557621611, 0.7884693125857052, 0.8159404782387577, 0.7862722626228674, 0.7468826511781971, 0.4826314363366817, 0.48094233094016736, 0.4772415294054352, 0.49519029008592774, 0.5132203477541732, 0.4925448964737882, 0.4895794961361236, 0.47486200971200465, 0.4917733849415704, 0.13094517879576906, 0.0679413468919764, 0.11269878877505746, 0.12363332653949632, 0.05154509137076324, 0.0661012120855512, 0.12778407799033553, 0.15724121019691917, 0.09242352191552106, 0.08626683200922092, 0.0582823546391803, 0.13460972015744666, 0.11525255373702925, 0.01795015292310198, 0.11394906028131879, 0.14039623804284296, 0.14192670953720465, 0.09366582173756544, 0.9600094918863137, 0.988509662325838, 0.9814488177059771, 0.9720567138073302, 0.9927592794513269, 0.9745920631735739, 0.9872107640937015, 0.9893583436036661, 0.9756066208458437, 0.48065821795850594, 0.5262671076545171, 0.48916733738347185, 0.5151040478790028, 0.4959823480272858, 0.5242520795058628, 0.5261146229805601, 0.4928881557278576, 0.5095777507310353, 0.8170187753862177, 0.7068648668750706, 0.811412783152252, 0.7557029974269641, 0.7941959451316198, 0.6538202057147298, 0.17217517492964596, 0.13990859768291153, 0.23239199352510354, 0.5002686192741189, 0.1349135850425326, 0.42873960549799883, 0.3530591334819272, 0.41703428661910835, 0.37600308908944435, 0.38921748712184423, 0.42129746037012306, 0.3863570269051988, 0.3688109927743547, 0.3301801770842785, 0.1315816384847518, 0.39060343549562326, 0.42146092657855194, 0.36307587466136915, 0.3283331025018723, 0.4057971258162357, 0.4038412884359268, 0.17494811586647196, 0.1728133821611424, 0.1803531853859115, 0.2075061403413454, 0.27765146300927546, 0.14209519282628646, 0.21410684692375492, 0.24951512620684657, 0.18293747151702155, 0.31377600825586294, 0.2944842671698873, 0.3563881731895243, 0.3158979358747921, 0.2805201009179481, 0.2651346032497144, 0.3259749133777674, 0.3283526374056057, 0.34166718662759765, 0.0739442463101121, 0.06032095669496773, 0.09147418371354821, 0.12275780192110375, 0.06776729172317997, 0.08403733320724782, 0.09544846800903706, 0.07390655473762686, 0.14084532253883175, 0.24907751741202733, 0.22042464070298862, 0.214086789774663, 0.2313999776411605, 0.22728167280330647, 0.2689264798120745, 0.23410112861882681, 0.21887909972251696, 0.21987922005677862, 0.6031327440660486, 0.6082622093613521, 0.5697205944140737, 0.6026942700207731, 0.5944131212693822, 0.6064331691903309, 0.583484114909572, 0.59749157665164, 0.6065425411554284, 0.06067110042259394, 0.11102404508390495, 0.09071739040066373, 0.07782370898745017, 0.03736579936137063, 0.09738039552347288, 0.09311210383996427, 0.07825554546946556, 0.07561713512322754, 0.27100901008190315, 0.46880263656418153, 0.22694468577006321, 0.4723644681665746, 0.4554558093030985, 0.3927907455681853, 0.5260806528206925, 0.21645662508777064, 0.22077240446589974, 0.3768941793178533, 0.36173858749293875, 0.18342944468009192, 0.2235502375659264, 0.3678961171349171, 0.37965063276861577, 0.24906917973512865, 0.4062167986140939, 0.42096504989461314, 0.2959242879454721, 0.2752871697080047, 0.26008466465425195, 0.22208151672554177, 0.30070108801471795, 0.166835169948924, 0.2872946024836771, 0.3294909943148395, 0.22059965459170494, 0.20077443450058852, 0.2149274227808342, 0.2071632929437136, 0.19799763341182797, 0.20208009298242458, 0.1738429337181242, 0.19199072448137744, 0.23259159869897328, 0.20764873093438008, 0.625496582110983, 0.1780859614789584, 0.19746280392004545, 0.25513921884207313, 0.2084268309997146, 0.22171611269040803, 0.2109021170379255, 0.20938628300650775, 0.2217075745241016, 0.15973594832621985, 0.16980075719990584, 0.1548004424645334, 0.1729690552977956, 0.20206797426741918, 0.20162194873953532, 0.14336790083627182, 0.17023273210071077, 0.1429968559921555, 0.8513426407040131, 0.21367882032527885, 0.1561444780676129, 0.8406107293823786, 0.12816941255970937, 0.15633981936787078, 0.10518406201600305, 0.10488321249955479, 0.8314533064256856, 0.19214925005942174, 0.19018318867459616, 0.18220427971149333, 0.273541333305899, 0.18370306770322464, 0.18938114510329218, 0.20835768365820717, 0.19443332422419102, 0.18573581286147178, 0.1071880213441353, 0.09757188121071159, 0.07928007830169082, 0.08988296543633856, 0.09054526868216584, 0.09929068812442476, 0.10523607005461721, 0.10527492224566226, 0.08693141503308544]}, "mutation_prompt": null}
{"id": "7f6565ab-589a-48cf-beb7-723ecc02d549", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.5 + np.random.rand() * 0.5):  # Slightly adjusted adaptive F factor\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):  # Fine-tuned crossover rate for diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def guided_search(self):\n        direction = np.random.uniform(-1.0, 1.0, self.dim)\n        guide = np.clip(self.population[self.global_best] + 0.2 * direction, self.lower_bound, self.upper_bound)\n        return guide\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.25:  # Increased chance to use guided search\n                    trial = self.guided_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridAdaptiveDifferentialEvolution", "description": "Hybrid Adaptive Differential Evolution with Guided Search for Enhanced Convergence.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6905ab66-7276-4172-aaad-3b408416ed77", "metadata": {"aucs": [0.8701120635139404, 0.8677838411045177, 0.8553302640436486, 0.8733341512636563, 0.8779275801594602, 0.8631257866302713, 0.8768535626281874, 0.8677920876265968, 0.8745723664812668, 0.6595920228782264, 0.6835244373074782, 0.6771432469747519, 0.5885939892527814, 0.6500063246291172, 0.637541438764744, 0.5355020431785278, 0.6576012898629728, 0.4739339404799814, 0.1766257854104939, 0.10028573675548524, 0.12157331102853719, 0.08382027605649434, 0.08736015662264851, 0.09727617971343483, 0.14699846353833035, 0.17395620930083477, 0.15869527710112963, 0.11573224286924433, 0.06609510172629618, 0.06211531884926591, 0.1151007098130673, 0.05081337059789859, 0.06961335752171705, 0.1454000247934888, 0.05913495880103237, 0.09910510946658446, 0.9762664461035179, 0.9456784922827046, 0.9793781979481453, 0.9737302682524571, 0.9743730062816319, 0.8956591209749616, 0.9560751543888608, 0.9837523071675339, 0.9381568826315719, 0.6343903767325434, 0.6652541313116588, 0.5815541914700436, 0.5915947257897334, 0.6207550141118101, 0.6010284333792573, 0.6501852663388421, 0.6350573970945292, 0.61735095354645, 0.23113109568059176, 0.13666395020588606, 0.17235615181934993, 0.8909442839484986, 0.1932229192154643, 0.28145953684729574, 0.8896776323368549, 0.13195658238297525, 0.8851251132279552, 0.4373355360636696, 0.246670377557622, 0.16342113675888026, 0.24713264139351754, 0.333201950342789, 0.3554319358683201, 0.3789192466040944, 0.13396501965669627, 0.2506594487593681, 0.6372645569296719, 0.2500535182452711, 0.22587939895638864, 0.2886155752921583, 0.3697927368948857, 0.3345062485472007, 0.2231327605997271, 0.1867546245242776, 0.20128331562067292, 0.09223080293511887, 0.40145076181582817, 0.4340203378458417, 0.04112565784914202, 0.14413113519443432, 0.33415690103013407, 0.28404754681104893, 0.1061064923952697, 0.44569726681161914, 0.6448790344246242, 0.21207275021879246, 0.39312612218022736, 0.555865775219667, 0.5740633845944019, 0.3776663937812458, 0.37130742319742693, 0.3473503525461963, 0.4696775215665582, 0.10439943868874746, 0.19687228204100038, 0.13502214820522151, 0.4100004206015776, 0.30863199698441846, 0.38069126538467757, 0.09880809622958131, 0.17524945942708803, 0.3291931622366149, 0.35283391007612097, 0.3656723136185146, 0.3202237806761682, 0.3807632054166503, 0.39634346457131975, 0.3274224563710523, 0.3320481684075276, 0.3400113473820877, 0.30362557895604847, 0.7966505104010551, 0.7833815565390648, 0.7659486387412797, 0.7915048952663282, 0.7759103364949282, 0.7642355845615405, 0.7950657862143864, 0.7646844850765779, 0.7716234504827703, 0.11070055559590619, 0.03235280942984298, 0.11318312575853817, 0.06307174289090256, 0.08683993244120392, 0.0888833841262473, 0.1476179481028077, 0.11045803313967573, 0.0876487268157593, 0.7145016840737239, 0.668679375544815, 0.23931408049921687, 0.6759353362736633, 0.6991011433132335, 0.6878359708507803, 0.6529416975550209, 0.3425192162463705, 0.28943843876440156, 0.13755514311225947, 0.4776164605080053, 0.47873669098326677, 0.26829649936740896, 0.22897523881996285, 0.4933833615037666, 0.2595755483114631, 0.5063242498344667, 0.5023299144358919, 0.35124946002079693, 0.41208479426050637, 0.3273184912328032, 0.18271188552281648, 0.22315355245922186, 0.2531297204559564, 0.41479987855001665, 0.4257431029140837, 0.43500043657189336, 0.2144204750634603, 0.22322588838869528, 0.2054721836566108, 0.29542659872444577, 0.23351960470971223, 0.21547015926491864, 0.2174750077990768, 0.19755524027722626, 0.20492120446023177, 0.20665755372682415, 0.19415217985118216, 0.1977675933555555, 0.22621327331595376, 0.7663038669571772, 0.21067334801237148, 0.18919674573262923, 0.22524859550613296, 0.1976550946667266, 0.1489058033199765, 0.12744266758109934, 0.15489775725077493, 0.952895986727425, 0.2021347793261229, 0.20162982595770318, 0.9299467173578883, 0.1705555319760741, 0.15461874087948602, 0.9231883531430638, 0.21458593496014966, 0.15547715846481547, 0.10495735851719312, 0.8553265601044483, 0.15322300668595268, 0.10524334936645396, 0.10513119764023071, 0.8112679329762931, 0.18162439927446716, 0.17874172357951779, 0.17864688368682857, 0.18546069789458697, 0.1885834418915815, 0.1888070244557758, 0.19358441257526082, 0.18294376031376125, 0.19278293622534415, 0.08640863447931735, 0.08223537952501592, 0.08924267659980212, 0.08681471855377565, 0.07111902872067344, 0.106209568221868, 0.0853346261487371, 0.08175374900890098, 0.1058597689604569]}, "mutation_prompt": null}
{"id": "2f23ce47-3fd3-414f-900d-989eb4a09712", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n        self.adaptive_CR = 0.9  # Added a self-adaptive crossover rate\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F_base=0.5):\n        F = F_base + np.random.rand() * (0.9 - F_base)  # More adaptive mutation factor\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.adaptive_CR\n        self.adaptive_CR = 0.8 + 0.2 * np.random.rand()  # Self-adaptive crossover rate\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def guided_search(self):\n        direction = np.random.uniform(-1.0, 1.0, self.dim)\n        guide = np.clip(self.population[self.global_best] + 0.2 * direction, self.lower_bound, self.upper_bound)\n        return guide\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.25:\n                    trial = self.guided_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Hybrid Adaptive Differential Evolution with Adaptive Mutation and Self-Adaptive Crossover.", "configspace": "", "generation": 68, "fitness": 0.3595831584099243, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.25.", "error": "", "parent_id": "6905ab66-7276-4172-aaad-3b408416ed77", "metadata": {"aucs": [0.8082750380488546, 0.820364110846747, 0.8270514153395374, 0.8273798782903904, 0.8077971207132142, 0.8098370714798695, 0.833234930363714, 0.8042330719356872, 0.835964447837747, 0.49003645204921376, 0.49849103415955065, 0.5352951500658159, 0.5333197709699171, 0.5786729765904781, 0.5297186398059917, 0.5219295167522573, 0.5509657726305611, 0.4722473765073141, 0.10978527118279202, 0.1669852301428273, 0.11973533019906957, 0.12265905051690229, 0.09961699496077059, 0.43576309955353854, 0.10250003353586945, 0.14437081997153778, 0.139036633573701, 0.07984643638944144, 0.1410631147483249, 0.11054472165801421, 0.0888851736959112, 0.15211931598015127, 0.11572408269183254, 0.097777736517769, 0.08205941876790535, 0.11933421124100496, 0.9799177325947216, 0.9540731502189126, 0.9660229512765749, 0.9298352093077324, 0.9718027780967862, 0.9654527543290992, 0.9889171896508373, 0.9857073887169517, 0.973633471534742, 0.5096385520154398, 0.5034080792303035, 0.47257685329160803, 0.46363655581616225, 0.5173903776989476, 0.5291722013056179, 0.5258168628594803, 0.5074459915870969, 0.49198597636990027, 0.22979627432329852, 0.848461637137057, 0.6643723470329241, 0.8518444206431243, 0.5909349288284831, 0.1522706426119359, 0.23069514659741786, 0.868281176013698, 0.4833964886075828, 0.52881003913405, 0.13299111742716652, 0.36531544799074966, 0.34374833953937933, 0.1344347603155457, 0.5573289355235905, 0.4478994716101147, 0.4636047065650689, 0.38862518881264974, 0.3880051508665404, 0.3238878178980793, 0.4501664774240903, 0.48716852582789916, 0.41991359828119534, 0.3041242556385354, 0.32329025374167475, 0.1342438411380914, 0.13150735193476337, 0.31628440519253964, 0.2842958119448805, 0.27761401548615483, 0.3265221401197561, 0.3136191743619252, 0.37047265377129046, 0.3347787089575942, 0.2666019150641896, 0.3493008555094458, 0.4832191644263548, 0.3807786713217799, 0.45400692981946567, 0.44234653001218227, 0.40359585710190704, 0.3681145188662628, 0.4101514237476793, 0.4390421818620509, 0.46062867836077503, 0.06845952333408245, 0.0884495306285984, 0.16963952642170765, 0.24063457328506377, 0.22432745836807721, 0.1772381616403712, 0.1695325357113272, 0.14238828790600022, 0.19291750983242717, 0.3007130245278494, 0.2868421734531268, 0.2870692941482963, 0.29264869980732755, 0.32313723999508237, 0.3214586920120889, 0.26796502649341647, 0.30224951041666626, 0.2930729678175569, 0.6557008313453812, 0.6578824355772913, 0.6877534022185157, 0.6664654718693361, 0.6461279421949324, 0.6796275415695896, 0.6964762981172046, 0.6879617755251852, 0.6750586986050777, 0.07576757893658892, 0.11411524422491126, 0.1230531161431836, 0.1258132392639162, 0.09832437501145286, 0.10959593965463532, 0.03327458292525265, 0.1218738771957012, 0.1233395956620158, 0.3926467276346022, 0.5263495314846485, 0.23042483449579698, 0.395287350565087, 0.5823320476746549, 0.18721522202151253, 0.591579710522763, 0.2238228542754448, 0.30619083473097874, 0.2069300321828239, 0.40015634162656355, 0.3723121479467827, 0.39604959820378594, 0.41054673573515166, 0.3844137730799363, 0.21464322282772053, 0.42431260219468925, 0.39254670253601653, 0.23170510454614024, 0.33971579546318875, 0.2912226760060085, 0.21377648508936065, 0.1527338727355645, 0.3190338046465101, 0.1784489384818133, 0.3038680150841244, 0.33462493706552776, 0.195051114840761, 0.21651315311232044, 0.19800205076144006, 0.2154097968884492, 0.20210507631005337, 0.17816424059448377, 0.20508666759496053, 0.21917126228788442, 0.19325171950267805, 0.2543183146989283, 0.20940342523675326, 0.24322459872862845, 0.25801307906267545, 0.22361839596583755, 0.20675428708416388, 0.21309712686952942, 0.18511089286833815, 0.6330344778336586, 0.14856518936039542, 0.17017952242275391, 0.16660955710239245, 0.1729422463371031, 0.20207405927218336, 0.2011112373205325, 0.14335230326013004, 0.16664916551094866, 0.9267913196196496, 0.8654166703317416, 0.21352073727467036, 0.07328769173515814, 0.10515098182111693, 0.16836524355677962, 0.16974239089358323, 0.2137190296152135, 0.1682219292123347, 0.853231814332728, 0.1760964466700662, 0.1910331224329056, 0.18909173922626088, 0.19050984957625483, 0.18798491225698977, 0.19036825067364493, 0.20372680319184, 0.20274803791432472, 0.18616282247937566, 0.08260092118570794, 0.09093693277392667, 0.0808027779497108, 0.08585905015461048, 0.07848889733183917, 0.09329298788155738, 0.07345018374516277, 0.091244791996552, 0.09191083617943074]}, "mutation_prompt": null}
{"id": "f9463aa1-173f-4fa8-8ce5-d5e1bbf8e79e", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.4 + np.random.rand() * 0.6):  # More adaptive F factor\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.85):  # Fine-tuned crossover rate for diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def guided_search(self):\n        direction = np.random.uniform(-1.0, 1.0, self.dim)\n        guide = np.clip(self.population[self.global_best] + 0.25 * direction, self.lower_bound, self.upper_bound)  # Improved exploration\n        return guide\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def rejuvenate_population(self, func):  # New strategy to occasionally rejuvenate the population\n        if self.eval_count < self.budget * 0.75 and np.random.rand() < 0.1:  # Opportunistic rejuvenation\n            new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size // 10, self.dim))\n            new_fitness = np.array([func(ind) for ind in new_individuals])\n            self.eval_count += len(new_fitness)\n            worst_indices = np.argsort(-self.fitness)[:len(new_fitness)]\n            self.population[worst_indices] = new_individuals\n            self.fitness[worst_indices] = new_fitness\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.3:  # Increased chance to use guided search\n                    trial = self.guided_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n            self.rejuvenate_population(func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with Adaptive Mutation and Population Rejuvenation.", "configspace": "", "generation": 69, "fitness": 0.35691096680751605, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.27.", "error": "", "parent_id": "6905ab66-7276-4172-aaad-3b408416ed77", "metadata": {"aucs": [0.8668920679683872, 0.8662167693169467, 0.8596239342765215, 0.8576758602641361, 0.8589236592699341, 0.8542849081854886, 0.8680891876141207, 0.8427118953500697, 0.8409492899478485, 0.6206401388457163, 0.6168107660956725, 0.643441503857296, 0.6009875592376371, 0.6024791607218585, 0.6296965116568152, 0.5308273536268966, 0.6339511634919485, 0.6748729076629645, 0.08196476724402124, 0.14605434487877322, 0.09462495003969629, 0.09712190789259023, 0.08598355603605345, 0.12351543562619938, 0.1510408051394625, 0.15986669255765829, 0.1584297032222728, 0.22979266871412174, 0.09930272928957384, 0.0951299904373536, 0.12402731718393423, 0.10950727673380556, 0.1482291616492032, 0.08965759460876122, 0.12213485333906027, 0.10666026062149736, 0.9518520280639782, 0.962710881257003, 0.9817617584853385, 0.9802123515217669, 0.9265625254878831, 0.9623026519793357, 0.9662097511083718, 0.9838401201412904, 0.9811306285219134, 0.5483654696863551, 0.5479387705543299, 0.5415621590162373, 0.6029798637487869, 0.5501949337616792, 0.5492821354722753, 0.578843040688862, 0.549761393991234, 0.5653177894107924, 0.22900448451973643, 0.6107276590456624, 0.8729445717520312, 0.6774175395874561, 0.1959103965600295, 0.7218443976326132, 0.15272229798136794, 0.22393158606311547, 0.2358975143265336, 0.4957297940954555, 0.13488602920679116, 0.2714886320688983, 0.253359859656501, 0.24097893727767794, 0.3603419059001848, 0.405339647979585, 0.40318781525635317, 0.26474556424883344, 0.3150505399289655, 0.2346198845493469, 0.13533467372783559, 0.3002344787921164, 0.2021760946378045, 0.30004532602409795, 0.12146626891734069, 0.4802203637628759, 0.20189356295502958, 0.19853964516634037, 0.30756054969115865, 0.11604499036788019, 0.2074791785180562, 0.18426409628757234, 0.20850665123856715, 0.2878276597205871, 0.029429483157924707, 0.06583142159187505, 0.40047710468912845, 0.20001308539881735, 0.4845797853667595, 0.33558733681958897, 0.34900950704664, 0.1651858226405145, 0.333416166965122, 0.3734946342379032, 0.16997920703057057, 0.1681888026401983, 0.14167051624176819, 0.09127744061167775, 0.21389947238439977, 0.23839083484969026, 0.22386643563080422, 0.09246107869974729, 0.1878585134883649, 0.08628669494120622, 0.26283184380803815, 0.3041752955055239, 0.2975423517732907, 0.23758144732935904, 0.28555532013608076, 0.33051689954863694, 0.2457799283676414, 0.282514770692881, 0.1868883940383107, 0.7089040723880236, 0.686964652797277, 0.7164595699078747, 0.6946743688591545, 0.674724650356105, 0.7062828165047955, 0.6812903477001324, 0.7006607284227115, 0.7113612082963462, 0.12273550917259868, 0.05030913082406463, 0.13443245914145396, 0.09543995121619608, 0.0541291553527532, 0.10133317304677691, 0.07972576738777515, 0.14379076943018954, 0.10593729539319452, 0.2698444113163806, 0.5943138604605551, 0.23254811076582504, 0.5416130229019942, 0.6018007122678923, 0.5749420100159782, 0.46361779819041227, 0.5274633233634545, 0.22902641746144103, 0.25081647108464933, 0.4041259430768882, 0.4252904457053349, 0.2313429333870285, 0.4271358821967478, 0.2565897314732468, 0.2098886672571051, 0.48558439264293585, 0.4597765719481477, 0.10272828576182569, 0.08998152412813654, 0.37180767097835954, 0.2652647069147047, 0.30649359684666866, 0.24780220664875585, 0.3524298218024451, 0.3654622565003799, 0.23963010384659977, 0.21248692916746725, 0.21527445405630352, 0.21141153350998565, 0.22522058432422387, 0.19428409734205243, 0.1979833301954299, 0.22621216211782824, 0.1957133722677461, 0.20736863968844466, 0.24898466750294956, 0.23682951489774595, 0.20566655682760204, 0.2240267187864512, 0.23073469759578336, 0.2089906331002267, 0.24471972113051943, 0.25617638940473086, 0.1868095020952254, 0.9342352504507851, 0.9270928886240989, 0.1548608819624251, 0.9392329324417814, 0.2020892683789276, 0.20159207462796958, 0.1433756587728824, 0.1705652432961171, 0.16789550116246388, 0.88986289257815, 0.21461657995186123, 0.15571984739560707, 0.1051373494854968, 0.16936107400898948, 0.1555055958537256, 0.9000036537146455, 0.21361238557981643, 0.7906787474205959, 0.20219844228189954, 0.19097210933837405, 0.17581758302953754, 0.1777361867314532, 0.18003130783129928, 0.1736663016211858, 0.18218198659018703, 0.19438604334964038, 0.19251603988607258, 0.08770658945130949, 0.08442636734586628, 0.09134269286785024, 0.08866070605776244, 0.08962612512416746, 0.0977349911582096, 0.07999978493227755, 0.08946511510222388, 0.09453352428718886]}, "mutation_prompt": null}
{"id": "4a82d2be-3ca6-4af9-9d8d-adff1759c39d", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 5, replace=False)\n        best_two = indices[np.argsort(self.fitness[indices])[:2]]\n        return self.population[best_two]\n\n    def mutate(self, a, b, F=0.6 + np.random.rand() * 0.4):  # Adjusted adaptive F factor and parent selection\n        mutant = np.clip(a + F * (b - a), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.8):  # Minor adjustment to crossover rate\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def guided_search(self):\n        direction = np.random.uniform(-1.0, 1.0, self.dim)\n        guide = np.clip(self.population[self.global_best] + 0.2 * direction, self.lower_bound, self.upper_bound)\n        return guide\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.3:  # Adjusted probability for guided search\n                    trial = self.guided_search()\n                else:\n                    target = self.population[i]\n                    a, b = self.select_parents()\n                    mutant = self.mutate(a, b)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "EnhancedHybridAdaptiveDifferentialEvolution", "description": "Enhanced Hybrid Adaptive Differential Evolution with Adaptive Mutation Strategy for Faster Convergence.", "configspace": "", "generation": 70, "fitness": 0.20009824516596808, "feedback": "The algorithm EnhancedHybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.19.", "error": "", "parent_id": "6905ab66-7276-4172-aaad-3b408416ed77", "metadata": {"aucs": [0.5138671352531208, 0.5597417741375026, 0.4705863709258822, 0.5557391771934415, 0.5731563872780925, 0.5504672085975253, 0.529015110572866, 0.5320388152730607, 0.6078987549167865, 9.999999999998899e-05, 0.001125940070688558, 0.032869775952623415, 9.999999999998899e-05, 0.05869659080818457, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11956582595227905, 0.11586193985970916, 0.08112432573749317, 0.11378339145563532, 0.08110714170724054, 0.08730032637948693, 0.12837976956165154, 0.11363789801056134, 0.08984655879488435, 0.055450639333220364, 0.04498566901811096, 0.058103139576264784, 0.07161904948763809, 0.04434240537463319, 0.08114306998103316, 0.04503995484836831, 0.03816548018150223, 0.04373079047783124, 0.8645190661020208, 0.9071808463614209, 0.8196306131704374, 0.6071783770676249, 0.7190173814956657, 0.6157666579719345, 0.8972377883816137, 0.7709361729606932, 0.8897702361814144, 0.3198225085309422, 0.3378232886258765, 0.29954394277367835, 0.30349850448929994, 0.3013301321642613, 0.33186081011695223, 0.37097255277782304, 0.29158096448721393, 0.29768820914158634, 0.22512126519461184, 0.13545599150874532, 0.36557640856184725, 0.2241064366730856, 0.09290244630370981, 0.03118720389298324, 0.10514340181353288, 0.1316912139113181, 0.11088952310758649, 0.1893465285352126, 0.14098442188562932, 0.16087831498209215, 0.18699017376534943, 0.19848611403784855, 0.15018974981684985, 0.23221127220925708, 0.13679451503298756, 0.15740252047435022, 0.17086087709489095, 0.2501029368790926, 0.1874993613261413, 0.15002889649289342, 0.12885654115807577, 0.15491103867641431, 0.1336423839259725, 0.13517900577537456, 0.13134136038612831, 9.999999999998899e-05, 0.007929506596328295, 0.03672670171827963, 0.011741403602487321, 0.0009805309062501655, 9.999999999998899e-05, 9.999999999998899e-05, 0.0012232840770931563, 0.039219579491469814, 0.0995801864578354, 0.036684743910280315, 0.07507903948001171, 0.06742301547049723, 0.012489714649259964, 0.010709374286291151, 0.045926743643603496, 0.05934873650357786, 0.04429539277339045, 9.999999999998899e-05, 9.999999999998899e-05, 0.0014243859983745777, 0.06669586626179302, 0.005033285224052442, 9.999999999998899e-05, 0.06688497589941567, 0.06554351554993232, 0.038096130623549995, 0.10440141312217144, 0.2071539602525947, 0.025283961089617724, 0.11275663135556258, 0.10004929490034498, 0.10850997584590127, 0.12387308692290078, 0.2385008897243358, 0.08096170585772577, 0.42932875525276937, 0.45278255734025274, 0.44286330537591634, 0.43405804125328906, 0.4254260242964095, 0.4265360311608333, 0.422607085692815, 0.4420439048746657, 0.42859448430147906, 0.04970762141471319, 0.019029757311745943, 0.08812864593525283, 0.0705766676312709, 0.046612648437690085, 0.06377206333326468, 0.08182698844456826, 0.11007665059966587, 0.11249022639219253, 0.2015175675070694, 0.23535332106727846, 0.1703599370616916, 0.25932792325955223, 0.2609703463229046, 0.13427707754233686, 0.3605997072068029, 0.12186987449765407, 0.11316645984076545, 0.17535711208291926, 0.21251661413106515, 0.2283810087707896, 0.2897233549151762, 0.2249887066536197, 0.1461246360769255, 0.21007869253944678, 0.23665676920468504, 0.152334249804843, 0.10472994155028514, 0.22102520710845752, 0.12252573578868542, 0.1248542675456421, 0.1705108196724643, 0.16907789397729978, 0.1786990566602411, 0.24583365841634486, 0.21144749949796715, 0.2196138046798929, 0.21171482606943393, 0.21458327410278288, 0.21840464954040562, 0.22969070746779774, 0.24233237557591325, 0.1897533671205246, 0.2100009982690968, 0.2003349291538945, 0.18502216101389113, 0.2278632912006131, 0.1606379611890285, 0.19180494431338813, 0.16285989416861324, 0.16548677188257588, 0.1869608314627561, 0.18678476709577296, 0.16559469286571316, 0.18892837639090299, 0.1895954972111309, 0.1548624122780322, 0.7716533932495644, 0.20219288279901448, 0.2012816220961744, 0.14338676438212838, 0.15490963988895567, 0.16873463723295512, 0.45613526912273783, 0.21454801924425082, 0.6216405257771322, 0.10470068619279771, 0.16997438345199356, 0.15074108977108114, 0.10537131850041515, 0.10508995194058479, 0.3805248637885278, 0.18327925918297594, 0.2182325754365062, 0.21037173693432132, 0.204922539012932, 0.23229106881300876, 0.20002756324196158, 0.20469135560060236, 0.22268728830675277, 0.19638965729338997, 0.08630799090235364, 0.0760499685636461, 0.078242731217678, 0.11657169702174819, 0.08313002865439323, 0.08206968666066983, 0.10363745729770357, 0.09573134292785512, 0.0868471254037424]}, "mutation_prompt": null}
{"id": "64b13bca-0b9e-4532-8efd-2655498702b7", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.5 + np.random.rand() * 0.5):  # Slightly adjusted adaptive F factor\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):  # Fine-tuned crossover rate for diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def guided_search(self):\n        direction = np.random.uniform(-1.0, 1.0, self.dim)\n        guide = np.clip(self.population[self.global_best] + 0.2 * direction, self.lower_bound, self.upper_bound)\n        return guide\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.25:  # Increased chance to use guided search\n                    trial = self.guided_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridAdaptiveDifferentialEvolution", "description": "Hybrid Adaptive Differential Evolution with Guided Search for Enhanced Convergence.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6905ab66-7276-4172-aaad-3b408416ed77", "metadata": {"aucs": [0.8701120635139404, 0.8677838411045177, 0.8553302640436486, 0.8733341512636563, 0.8779275801594602, 0.8631257866302713, 0.8768535626281874, 0.8677920876265968, 0.8745723664812668, 0.6595920228782264, 0.6835244373074782, 0.6771432469747519, 0.5885939892527814, 0.6500063246291172, 0.637541438764744, 0.5355020431785278, 0.6576012898629728, 0.4739339404799814, 0.1766257854104939, 0.10028573675548524, 0.12157331102853719, 0.08382027605649434, 0.08736015662264851, 0.09727617971343483, 0.14699846353833035, 0.17395620930083477, 0.15869527710112963, 0.11573224286924433, 0.06609510172629618, 0.06211531884926591, 0.1151007098130673, 0.05081337059789859, 0.06961335752171705, 0.1454000247934888, 0.05913495880103237, 0.09910510946658446, 0.9762664461035179, 0.9456784922827046, 0.9793781979481453, 0.9737302682524571, 0.9743730062816319, 0.8956591209749616, 0.9560751543888608, 0.9837523071675339, 0.9381568826315719, 0.6343903767325434, 0.6652541313116588, 0.5815541914700436, 0.5915947257897334, 0.6207550141118101, 0.6010284333792573, 0.6501852663388421, 0.6350573970945292, 0.61735095354645, 0.23113109568059176, 0.13666395020588606, 0.17235615181934993, 0.8909442839484986, 0.1932229192154643, 0.28145953684729574, 0.8896776323368549, 0.13195658238297525, 0.8851251132279552, 0.4373355360636696, 0.246670377557622, 0.16342113675888026, 0.24713264139351754, 0.333201950342789, 0.3554319358683201, 0.3789192466040944, 0.13396501965669627, 0.2506594487593681, 0.6372645569296719, 0.2500535182452711, 0.22587939895638864, 0.2886155752921583, 0.3697927368948857, 0.3345062485472007, 0.2231327605997271, 0.1867546245242776, 0.20128331562067292, 0.09223080293511887, 0.40145076181582817, 0.4340203378458417, 0.04112565784914202, 0.14413113519443432, 0.33415690103013407, 0.28404754681104893, 0.1061064923952697, 0.44569726681161914, 0.6448790344246242, 0.21207275021879246, 0.39312612218022736, 0.555865775219667, 0.5740633845944019, 0.3776663937812458, 0.37130742319742693, 0.3473503525461963, 0.4696775215665582, 0.10439943868874746, 0.19687228204100038, 0.13502214820522151, 0.4100004206015776, 0.30863199698441846, 0.38069126538467757, 0.09880809622958131, 0.17524945942708803, 0.3291931622366149, 0.35283391007612097, 0.3656723136185146, 0.3202237806761682, 0.3807632054166503, 0.39634346457131975, 0.3274224563710523, 0.3320481684075276, 0.3400113473820877, 0.30362557895604847, 0.7966505104010551, 0.7833815565390648, 0.7659486387412797, 0.7915048952663282, 0.7759103364949282, 0.7642355845615405, 0.7950657862143864, 0.7646844850765779, 0.7716234504827703, 0.11070055559590619, 0.03235280942984298, 0.11318312575853817, 0.06307174289090256, 0.08683993244120392, 0.0888833841262473, 0.1476179481028077, 0.11045803313967573, 0.0876487268157593, 0.7145016840737239, 0.668679375544815, 0.23931408049921687, 0.6759353362736633, 0.6991011433132335, 0.6878359708507803, 0.6529416975550209, 0.3425192162463705, 0.28943843876440156, 0.13755514311225947, 0.4776164605080053, 0.47873669098326677, 0.26829649936740896, 0.22897523881996285, 0.4933833615037666, 0.2595755483114631, 0.5063242498344667, 0.5023299144358919, 0.35124946002079693, 0.41208479426050637, 0.3273184912328032, 0.18271188552281648, 0.22315355245922186, 0.2531297204559564, 0.41479987855001665, 0.4257431029140837, 0.43500043657189336, 0.2144204750634603, 0.22322588838869528, 0.2054721836566108, 0.29542659872444577, 0.23351960470971223, 0.21547015926491864, 0.2174750077990768, 0.19755524027722626, 0.20492120446023177, 0.20665755372682415, 0.19415217985118216, 0.1977675933555555, 0.22621327331595376, 0.7663038669571772, 0.21067334801237148, 0.18919674573262923, 0.22524859550613296, 0.1976550946667266, 0.1489058033199765, 0.12744266758109934, 0.15489775725077493, 0.952895986727425, 0.2021347793261229, 0.20162982595770318, 0.9299467173578883, 0.1705555319760741, 0.15461874087948602, 0.9231883531430638, 0.21458593496014966, 0.15547715846481547, 0.10495735851719312, 0.8553265601044483, 0.15322300668595268, 0.10524334936645396, 0.10513119764023071, 0.8112679329762931, 0.18162439927446716, 0.17874172357951779, 0.17864688368682857, 0.18546069789458697, 0.1885834418915815, 0.1888070244557758, 0.19358441257526082, 0.18294376031376125, 0.19278293622534415, 0.08640863447931735, 0.08223537952501592, 0.08924267659980212, 0.08681471855377565, 0.07111902872067344, 0.106209568221868, 0.0853346261487371, 0.08175374900890098, 0.1058597689604569]}, "mutation_prompt": null}
{"id": "fb03ccbc-018c-4cd7-834c-d374247e3538", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.5 + np.random.rand() * 0.5):  # Slightly adjusted adaptive F factor\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):  # Fine-tuned crossover rate for diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def guided_search(self):\n        direction = np.random.uniform(-1.0, 1.0, self.dim)\n        guide = np.clip(self.population[self.global_best] + 0.2 * direction, self.lower_bound, self.upper_bound)\n        return guide\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.25:  # Increased chance to use guided search\n                    trial = self.guided_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridAdaptiveDifferentialEvolution", "description": "Hybrid Adaptive Differential Evolution with Guided Search for Enhanced Convergence.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6905ab66-7276-4172-aaad-3b408416ed77", "metadata": {"aucs": [0.8701120635139404, 0.8677838411045177, 0.8553302640436486, 0.8733341512636563, 0.8779275801594602, 0.8631257866302713, 0.8768535626281874, 0.8677920876265968, 0.8745723664812668, 0.6595920228782264, 0.6835244373074782, 0.6771432469747519, 0.5885939892527814, 0.6500063246291172, 0.637541438764744, 0.5355020431785278, 0.6576012898629728, 0.4739339404799814, 0.1766257854104939, 0.10028573675548524, 0.12157331102853719, 0.08382027605649434, 0.08736015662264851, 0.09727617971343483, 0.14699846353833035, 0.17395620930083477, 0.15869527710112963, 0.11573224286924433, 0.06609510172629618, 0.06211531884926591, 0.1151007098130673, 0.05081337059789859, 0.06961335752171705, 0.1454000247934888, 0.05913495880103237, 0.09910510946658446, 0.9762664461035179, 0.9456784922827046, 0.9793781979481453, 0.9737302682524571, 0.9743730062816319, 0.8956591209749616, 0.9560751543888608, 0.9837523071675339, 0.9381568826315719, 0.6343903767325434, 0.6652541313116588, 0.5815541914700436, 0.5915947257897334, 0.6207550141118101, 0.6010284333792573, 0.6501852663388421, 0.6350573970945292, 0.61735095354645, 0.23113109568059176, 0.13666395020588606, 0.17235615181934993, 0.8909442839484986, 0.1932229192154643, 0.28145953684729574, 0.8896776323368549, 0.13195658238297525, 0.8851251132279552, 0.4373355360636696, 0.246670377557622, 0.16342113675888026, 0.24713264139351754, 0.333201950342789, 0.3554319358683201, 0.3789192466040944, 0.13396501965669627, 0.2506594487593681, 0.6372645569296719, 0.2500535182452711, 0.22587939895638864, 0.2886155752921583, 0.3697927368948857, 0.3345062485472007, 0.2231327605997271, 0.1867546245242776, 0.20128331562067292, 0.09223080293511887, 0.40145076181582817, 0.4340203378458417, 0.04112565784914202, 0.14413113519443432, 0.33415690103013407, 0.28404754681104893, 0.1061064923952697, 0.44569726681161914, 0.6448790344246242, 0.21207275021879246, 0.39312612218022736, 0.555865775219667, 0.5740633845944019, 0.3776663937812458, 0.37130742319742693, 0.3473503525461963, 0.4696775215665582, 0.10439943868874746, 0.19687228204100038, 0.13502214820522151, 0.4100004206015776, 0.30863199698441846, 0.38069126538467757, 0.09880809622958131, 0.17524945942708803, 0.3291931622366149, 0.35283391007612097, 0.3656723136185146, 0.3202237806761682, 0.3807632054166503, 0.39634346457131975, 0.3274224563710523, 0.3320481684075276, 0.3400113473820877, 0.30362557895604847, 0.7966505104010551, 0.7833815565390648, 0.7659486387412797, 0.7915048952663282, 0.7759103364949282, 0.7642355845615405, 0.7950657862143864, 0.7646844850765779, 0.7716234504827703, 0.11070055559590619, 0.03235280942984298, 0.11318312575853817, 0.06307174289090256, 0.08683993244120392, 0.0888833841262473, 0.1476179481028077, 0.11045803313967573, 0.0876487268157593, 0.7145016840737239, 0.668679375544815, 0.23931408049921687, 0.6759353362736633, 0.6991011433132335, 0.6878359708507803, 0.6529416975550209, 0.3425192162463705, 0.28943843876440156, 0.13755514311225947, 0.4776164605080053, 0.47873669098326677, 0.26829649936740896, 0.22897523881996285, 0.4933833615037666, 0.2595755483114631, 0.5063242498344667, 0.5023299144358919, 0.35124946002079693, 0.41208479426050637, 0.3273184912328032, 0.18271188552281648, 0.22315355245922186, 0.2531297204559564, 0.41479987855001665, 0.4257431029140837, 0.43500043657189336, 0.2144204750634603, 0.22322588838869528, 0.2054721836566108, 0.29542659872444577, 0.23351960470971223, 0.21547015926491864, 0.2174750077990768, 0.19755524027722626, 0.20492120446023177, 0.20665755372682415, 0.19415217985118216, 0.1977675933555555, 0.22621327331595376, 0.7663038669571772, 0.21067334801237148, 0.18919674573262923, 0.22524859550613296, 0.1976550946667266, 0.1489058033199765, 0.12744266758109934, 0.15489775725077493, 0.952895986727425, 0.2021347793261229, 0.20162982595770318, 0.9299467173578883, 0.1705555319760741, 0.15461874087948602, 0.9231883531430638, 0.21458593496014966, 0.15547715846481547, 0.10495735851719312, 0.8553265601044483, 0.15322300668595268, 0.10524334936645396, 0.10513119764023071, 0.8112679329762931, 0.18162439927446716, 0.17874172357951779, 0.17864688368682857, 0.18546069789458697, 0.1885834418915815, 0.1888070244557758, 0.19358441257526082, 0.18294376031376125, 0.19278293622534415, 0.08640863447931735, 0.08223537952501592, 0.08924267659980212, 0.08681471855377565, 0.07111902872067344, 0.106209568221868, 0.0853346261487371, 0.08175374900890098, 0.1058597689604569]}, "mutation_prompt": null}
{"id": "c8f2955d-21a2-471d-a113-16012a38249e", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.5 + np.random.rand() * 0.5):  # Slightly adjusted adaptive F factor\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):  # Fine-tuned crossover rate for diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def guided_search(self):\n        direction = np.random.uniform(-1.0, 1.0, self.dim)\n        guide = np.clip(self.population[self.global_best] + 0.2 * direction, self.lower_bound, self.upper_bound)\n        return guide\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.25:  # Increased chance to use guided search\n                    trial = self.guided_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridAdaptiveDifferentialEvolution", "description": "Hybrid Adaptive Differential Evolution with Guided Search for Enhanced Convergence.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6905ab66-7276-4172-aaad-3b408416ed77", "metadata": {"aucs": [0.8701120635139404, 0.8677838411045177, 0.8553302640436486, 0.8733341512636563, 0.8779275801594602, 0.8631257866302713, 0.8768535626281874, 0.8677920876265968, 0.8745723664812668, 0.6595920228782264, 0.6835244373074782, 0.6771432469747519, 0.5885939892527814, 0.6500063246291172, 0.637541438764744, 0.5355020431785278, 0.6576012898629728, 0.4739339404799814, 0.1766257854104939, 0.10028573675548524, 0.12157331102853719, 0.08382027605649434, 0.08736015662264851, 0.09727617971343483, 0.14699846353833035, 0.17395620930083477, 0.15869527710112963, 0.11573224286924433, 0.06609510172629618, 0.06211531884926591, 0.1151007098130673, 0.05081337059789859, 0.06961335752171705, 0.1454000247934888, 0.05913495880103237, 0.09910510946658446, 0.9762664461035179, 0.9456784922827046, 0.9793781979481453, 0.9737302682524571, 0.9743730062816319, 0.8956591209749616, 0.9560751543888608, 0.9837523071675339, 0.9381568826315719, 0.6343903767325434, 0.6652541313116588, 0.5815541914700436, 0.5915947257897334, 0.6207550141118101, 0.6010284333792573, 0.6501852663388421, 0.6350573970945292, 0.61735095354645, 0.23113109568059176, 0.13666395020588606, 0.17235615181934993, 0.8909442839484986, 0.1932229192154643, 0.28145953684729574, 0.8896776323368549, 0.13195658238297525, 0.8851251132279552, 0.4373355360636696, 0.246670377557622, 0.16342113675888026, 0.24713264139351754, 0.333201950342789, 0.3554319358683201, 0.3789192466040944, 0.13396501965669627, 0.2506594487593681, 0.6372645569296719, 0.2500535182452711, 0.22587939895638864, 0.2886155752921583, 0.3697927368948857, 0.3345062485472007, 0.2231327605997271, 0.1867546245242776, 0.20128331562067292, 0.09223080293511887, 0.40145076181582817, 0.4340203378458417, 0.04112565784914202, 0.14413113519443432, 0.33415690103013407, 0.28404754681104893, 0.1061064923952697, 0.44569726681161914, 0.6448790344246242, 0.21207275021879246, 0.39312612218022736, 0.555865775219667, 0.5740633845944019, 0.3776663937812458, 0.37130742319742693, 0.3473503525461963, 0.4696775215665582, 0.10439943868874746, 0.19687228204100038, 0.13502214820522151, 0.4100004206015776, 0.30863199698441846, 0.38069126538467757, 0.09880809622958131, 0.17524945942708803, 0.3291931622366149, 0.35283391007612097, 0.3656723136185146, 0.3202237806761682, 0.3807632054166503, 0.39634346457131975, 0.3274224563710523, 0.3320481684075276, 0.3400113473820877, 0.30362557895604847, 0.7966505104010551, 0.7833815565390648, 0.7659486387412797, 0.7915048952663282, 0.7759103364949282, 0.7642355845615405, 0.7950657862143864, 0.7646844850765779, 0.7716234504827703, 0.11070055559590619, 0.03235280942984298, 0.11318312575853817, 0.06307174289090256, 0.08683993244120392, 0.0888833841262473, 0.1476179481028077, 0.11045803313967573, 0.0876487268157593, 0.7145016840737239, 0.668679375544815, 0.23931408049921687, 0.6759353362736633, 0.6991011433132335, 0.6878359708507803, 0.6529416975550209, 0.3425192162463705, 0.28943843876440156, 0.13755514311225947, 0.4776164605080053, 0.47873669098326677, 0.26829649936740896, 0.22897523881996285, 0.4933833615037666, 0.2595755483114631, 0.5063242498344667, 0.5023299144358919, 0.35124946002079693, 0.41208479426050637, 0.3273184912328032, 0.18271188552281648, 0.22315355245922186, 0.2531297204559564, 0.41479987855001665, 0.4257431029140837, 0.43500043657189336, 0.2144204750634603, 0.22322588838869528, 0.2054721836566108, 0.29542659872444577, 0.23351960470971223, 0.21547015926491864, 0.2174750077990768, 0.19755524027722626, 0.20492120446023177, 0.20665755372682415, 0.19415217985118216, 0.1977675933555555, 0.22621327331595376, 0.7663038669571772, 0.21067334801237148, 0.18919674573262923, 0.22524859550613296, 0.1976550946667266, 0.1489058033199765, 0.12744266758109934, 0.15489775725077493, 0.952895986727425, 0.2021347793261229, 0.20162982595770318, 0.9299467173578883, 0.1705555319760741, 0.15461874087948602, 0.9231883531430638, 0.21458593496014966, 0.15547715846481547, 0.10495735851719312, 0.8553265601044483, 0.15322300668595268, 0.10524334936645396, 0.10513119764023071, 0.8112679329762931, 0.18162439927446716, 0.17874172357951779, 0.17864688368682857, 0.18546069789458697, 0.1885834418915815, 0.1888070244557758, 0.19358441257526082, 0.18294376031376125, 0.19278293622534415, 0.08640863447931735, 0.08223537952501592, 0.08924267659980212, 0.08681471855377565, 0.07111902872067344, 0.106209568221868, 0.0853346261487371, 0.08175374900890098, 0.1058597689604569]}, "mutation_prompt": null}
{"id": "e6cb62a4-a105-44a8-9212-8c524be9e1f1", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.5 + np.random.rand() * 0.5):  # Slightly adjusted adaptive F factor\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):  # Fine-tuned crossover rate for diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def guided_search(self):\n        direction = np.random.uniform(-1.0, 1.0, self.dim)\n        guide = np.clip(self.population[self.global_best] + 0.2 * direction, self.lower_bound, self.upper_bound)\n        return guide\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.25:  # Increased chance to use guided search\n                    trial = self.guided_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridAdaptiveDifferentialEvolution", "description": "Hybrid Adaptive Differential Evolution with Guided Search for Enhanced Convergence.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6905ab66-7276-4172-aaad-3b408416ed77", "metadata": {"aucs": [0.8701120635139404, 0.8677838411045177, 0.8553302640436486, 0.8733341512636563, 0.8779275801594602, 0.8631257866302713, 0.8768535626281874, 0.8677920876265968, 0.8745723664812668, 0.6595920228782264, 0.6835244373074782, 0.6771432469747519, 0.5885939892527814, 0.6500063246291172, 0.637541438764744, 0.5355020431785278, 0.6576012898629728, 0.4739339404799814, 0.1766257854104939, 0.10028573675548524, 0.12157331102853719, 0.08382027605649434, 0.08736015662264851, 0.09727617971343483, 0.14699846353833035, 0.17395620930083477, 0.15869527710112963, 0.11573224286924433, 0.06609510172629618, 0.06211531884926591, 0.1151007098130673, 0.05081337059789859, 0.06961335752171705, 0.1454000247934888, 0.05913495880103237, 0.09910510946658446, 0.9762664461035179, 0.9456784922827046, 0.9793781979481453, 0.9737302682524571, 0.9743730062816319, 0.8956591209749616, 0.9560751543888608, 0.9837523071675339, 0.9381568826315719, 0.6343903767325434, 0.6652541313116588, 0.5815541914700436, 0.5915947257897334, 0.6207550141118101, 0.6010284333792573, 0.6501852663388421, 0.6350573970945292, 0.61735095354645, 0.23113109568059176, 0.13666395020588606, 0.17235615181934993, 0.8909442839484986, 0.1932229192154643, 0.28145953684729574, 0.8896776323368549, 0.13195658238297525, 0.8851251132279552, 0.4373355360636696, 0.246670377557622, 0.16342113675888026, 0.24713264139351754, 0.333201950342789, 0.3554319358683201, 0.3789192466040944, 0.13396501965669627, 0.2506594487593681, 0.6372645569296719, 0.2500535182452711, 0.22587939895638864, 0.2886155752921583, 0.3697927368948857, 0.3345062485472007, 0.2231327605997271, 0.1867546245242776, 0.20128331562067292, 0.09223080293511887, 0.40145076181582817, 0.4340203378458417, 0.04112565784914202, 0.14413113519443432, 0.33415690103013407, 0.28404754681104893, 0.1061064923952697, 0.44569726681161914, 0.6448790344246242, 0.21207275021879246, 0.39312612218022736, 0.555865775219667, 0.5740633845944019, 0.3776663937812458, 0.37130742319742693, 0.3473503525461963, 0.4696775215665582, 0.10439943868874746, 0.19687228204100038, 0.13502214820522151, 0.4100004206015776, 0.30863199698441846, 0.38069126538467757, 0.09880809622958131, 0.17524945942708803, 0.3291931622366149, 0.35283391007612097, 0.3656723136185146, 0.3202237806761682, 0.3807632054166503, 0.39634346457131975, 0.3274224563710523, 0.3320481684075276, 0.3400113473820877, 0.30362557895604847, 0.7966505104010551, 0.7833815565390648, 0.7659486387412797, 0.7915048952663282, 0.7759103364949282, 0.7642355845615405, 0.7950657862143864, 0.7646844850765779, 0.7716234504827703, 0.11070055559590619, 0.03235280942984298, 0.11318312575853817, 0.06307174289090256, 0.08683993244120392, 0.0888833841262473, 0.1476179481028077, 0.11045803313967573, 0.0876487268157593, 0.7145016840737239, 0.668679375544815, 0.23931408049921687, 0.6759353362736633, 0.6991011433132335, 0.6878359708507803, 0.6529416975550209, 0.3425192162463705, 0.28943843876440156, 0.13755514311225947, 0.4776164605080053, 0.47873669098326677, 0.26829649936740896, 0.22897523881996285, 0.4933833615037666, 0.2595755483114631, 0.5063242498344667, 0.5023299144358919, 0.35124946002079693, 0.41208479426050637, 0.3273184912328032, 0.18271188552281648, 0.22315355245922186, 0.2531297204559564, 0.41479987855001665, 0.4257431029140837, 0.43500043657189336, 0.2144204750634603, 0.22322588838869528, 0.2054721836566108, 0.29542659872444577, 0.23351960470971223, 0.21547015926491864, 0.2174750077990768, 0.19755524027722626, 0.20492120446023177, 0.20665755372682415, 0.19415217985118216, 0.1977675933555555, 0.22621327331595376, 0.7663038669571772, 0.21067334801237148, 0.18919674573262923, 0.22524859550613296, 0.1976550946667266, 0.1489058033199765, 0.12744266758109934, 0.15489775725077493, 0.952895986727425, 0.2021347793261229, 0.20162982595770318, 0.9299467173578883, 0.1705555319760741, 0.15461874087948602, 0.9231883531430638, 0.21458593496014966, 0.15547715846481547, 0.10495735851719312, 0.8553265601044483, 0.15322300668595268, 0.10524334936645396, 0.10513119764023071, 0.8112679329762931, 0.18162439927446716, 0.17874172357951779, 0.17864688368682857, 0.18546069789458697, 0.1885834418915815, 0.1888070244557758, 0.19358441257526082, 0.18294376031376125, 0.19278293622534415, 0.08640863447931735, 0.08223537952501592, 0.08924267659980212, 0.08681471855377565, 0.07111902872067344, 0.106209568221868, 0.0853346261487371, 0.08175374900890098, 0.1058597689604569]}, "mutation_prompt": null}
{"id": "99257962-dfad-4cdc-a0f6-0f587a1695fd", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.5 + np.random.rand() * 0.5):  # Slightly adjusted adaptive F factor\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):  # Fine-tuned crossover rate for diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def guided_search(self):\n        direction = np.random.uniform(-1.0, 1.0, self.dim)\n        guide = np.clip(self.population[self.global_best] + 0.2 * direction, self.lower_bound, self.upper_bound)\n        return guide\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.25:  # Increased chance to use guided search\n                    trial = self.guided_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridAdaptiveDifferentialEvolution", "description": "Hybrid Adaptive Differential Evolution with Guided Search for Enhanced Convergence.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6905ab66-7276-4172-aaad-3b408416ed77", "metadata": {"aucs": [0.8701120635139404, 0.8677838411045177, 0.8553302640436486, 0.8733341512636563, 0.8779275801594602, 0.8631257866302713, 0.8768535626281874, 0.8677920876265968, 0.8745723664812668, 0.6595920228782264, 0.6835244373074782, 0.6771432469747519, 0.5885939892527814, 0.6500063246291172, 0.637541438764744, 0.5355020431785278, 0.6576012898629728, 0.4739339404799814, 0.1766257854104939, 0.10028573675548524, 0.12157331102853719, 0.08382027605649434, 0.08736015662264851, 0.09727617971343483, 0.14699846353833035, 0.17395620930083477, 0.15869527710112963, 0.11573224286924433, 0.06609510172629618, 0.06211531884926591, 0.1151007098130673, 0.05081337059789859, 0.06961335752171705, 0.1454000247934888, 0.05913495880103237, 0.09910510946658446, 0.9762664461035179, 0.9456784922827046, 0.9793781979481453, 0.9737302682524571, 0.9743730062816319, 0.8956591209749616, 0.9560751543888608, 0.9837523071675339, 0.9381568826315719, 0.6343903767325434, 0.6652541313116588, 0.5815541914700436, 0.5915947257897334, 0.6207550141118101, 0.6010284333792573, 0.6501852663388421, 0.6350573970945292, 0.61735095354645, 0.23113109568059176, 0.13666395020588606, 0.17235615181934993, 0.8909442839484986, 0.1932229192154643, 0.28145953684729574, 0.8896776323368549, 0.13195658238297525, 0.8851251132279552, 0.4373355360636696, 0.246670377557622, 0.16342113675888026, 0.24713264139351754, 0.333201950342789, 0.3554319358683201, 0.3789192466040944, 0.13396501965669627, 0.2506594487593681, 0.6372645569296719, 0.2500535182452711, 0.22587939895638864, 0.2886155752921583, 0.3697927368948857, 0.3345062485472007, 0.2231327605997271, 0.1867546245242776, 0.20128331562067292, 0.09223080293511887, 0.40145076181582817, 0.4340203378458417, 0.04112565784914202, 0.14413113519443432, 0.33415690103013407, 0.28404754681104893, 0.1061064923952697, 0.44569726681161914, 0.6448790344246242, 0.21207275021879246, 0.39312612218022736, 0.555865775219667, 0.5740633845944019, 0.3776663937812458, 0.37130742319742693, 0.3473503525461963, 0.4696775215665582, 0.10439943868874746, 0.19687228204100038, 0.13502214820522151, 0.4100004206015776, 0.30863199698441846, 0.38069126538467757, 0.09880809622958131, 0.17524945942708803, 0.3291931622366149, 0.35283391007612097, 0.3656723136185146, 0.3202237806761682, 0.3807632054166503, 0.39634346457131975, 0.3274224563710523, 0.3320481684075276, 0.3400113473820877, 0.30362557895604847, 0.7966505104010551, 0.7833815565390648, 0.7659486387412797, 0.7915048952663282, 0.7759103364949282, 0.7642355845615405, 0.7950657862143864, 0.7646844850765779, 0.7716234504827703, 0.11070055559590619, 0.03235280942984298, 0.11318312575853817, 0.06307174289090256, 0.08683993244120392, 0.0888833841262473, 0.1476179481028077, 0.11045803313967573, 0.0876487268157593, 0.7145016840737239, 0.668679375544815, 0.23931408049921687, 0.6759353362736633, 0.6991011433132335, 0.6878359708507803, 0.6529416975550209, 0.3425192162463705, 0.28943843876440156, 0.13755514311225947, 0.4776164605080053, 0.47873669098326677, 0.26829649936740896, 0.22897523881996285, 0.4933833615037666, 0.2595755483114631, 0.5063242498344667, 0.5023299144358919, 0.35124946002079693, 0.41208479426050637, 0.3273184912328032, 0.18271188552281648, 0.22315355245922186, 0.2531297204559564, 0.41479987855001665, 0.4257431029140837, 0.43500043657189336, 0.2144204750634603, 0.22322588838869528, 0.2054721836566108, 0.29542659872444577, 0.23351960470971223, 0.21547015926491864, 0.2174750077990768, 0.19755524027722626, 0.20492120446023177, 0.20665755372682415, 0.19415217985118216, 0.1977675933555555, 0.22621327331595376, 0.7663038669571772, 0.21067334801237148, 0.18919674573262923, 0.22524859550613296, 0.1976550946667266, 0.1489058033199765, 0.12744266758109934, 0.15489775725077493, 0.952895986727425, 0.2021347793261229, 0.20162982595770318, 0.9299467173578883, 0.1705555319760741, 0.15461874087948602, 0.9231883531430638, 0.21458593496014966, 0.15547715846481547, 0.10495735851719312, 0.8553265601044483, 0.15322300668595268, 0.10524334936645396, 0.10513119764023071, 0.8112679329762931, 0.18162439927446716, 0.17874172357951779, 0.17864688368682857, 0.18546069789458697, 0.1885834418915815, 0.1888070244557758, 0.19358441257526082, 0.18294376031376125, 0.19278293622534415, 0.08640863447931735, 0.08223537952501592, 0.08924267659980212, 0.08681471855377565, 0.07111902872067344, 0.106209568221868, 0.0853346261487371, 0.08175374900890098, 0.1058597689604569]}, "mutation_prompt": null}
{"id": "564cf29a-c225-466d-8809-86f3febdcc77", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.5 + np.random.rand() * 0.5):  # Slightly adjusted adaptive F factor\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):  # Fine-tuned crossover rate for diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def guided_search(self):\n        direction = np.random.uniform(-1.0, 1.0, self.dim)\n        guide = np.clip(self.population[self.global_best] + 0.2 * direction, self.lower_bound, self.upper_bound)\n        return guide\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.25:  # Increased chance to use guided search\n                    trial = self.guided_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridAdaptiveDifferentialEvolution", "description": "Hybrid Adaptive Differential Evolution with Guided Search for Enhanced Convergence.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6905ab66-7276-4172-aaad-3b408416ed77", "metadata": {"aucs": [0.8701120635139404, 0.8677838411045177, 0.8553302640436486, 0.8733341512636563, 0.8779275801594602, 0.8631257866302713, 0.8768535626281874, 0.8677920876265968, 0.8745723664812668, 0.6595920228782264, 0.6835244373074782, 0.6771432469747519, 0.5885939892527814, 0.6500063246291172, 0.637541438764744, 0.5355020431785278, 0.6576012898629728, 0.4739339404799814, 0.1766257854104939, 0.10028573675548524, 0.12157331102853719, 0.08382027605649434, 0.08736015662264851, 0.09727617971343483, 0.14699846353833035, 0.17395620930083477, 0.15869527710112963, 0.11573224286924433, 0.06609510172629618, 0.06211531884926591, 0.1151007098130673, 0.05081337059789859, 0.06961335752171705, 0.1454000247934888, 0.05913495880103237, 0.09910510946658446, 0.9762664461035179, 0.9456784922827046, 0.9793781979481453, 0.9737302682524571, 0.9743730062816319, 0.8956591209749616, 0.9560751543888608, 0.9837523071675339, 0.9381568826315719, 0.6343903767325434, 0.6652541313116588, 0.5815541914700436, 0.5915947257897334, 0.6207550141118101, 0.6010284333792573, 0.6501852663388421, 0.6350573970945292, 0.61735095354645, 0.23113109568059176, 0.13666395020588606, 0.17235615181934993, 0.8909442839484986, 0.1932229192154643, 0.28145953684729574, 0.8896776323368549, 0.13195658238297525, 0.8851251132279552, 0.4373355360636696, 0.246670377557622, 0.16342113675888026, 0.24713264139351754, 0.333201950342789, 0.3554319358683201, 0.3789192466040944, 0.13396501965669627, 0.2506594487593681, 0.6372645569296719, 0.2500535182452711, 0.22587939895638864, 0.2886155752921583, 0.3697927368948857, 0.3345062485472007, 0.2231327605997271, 0.1867546245242776, 0.20128331562067292, 0.09223080293511887, 0.40145076181582817, 0.4340203378458417, 0.04112565784914202, 0.14413113519443432, 0.33415690103013407, 0.28404754681104893, 0.1061064923952697, 0.44569726681161914, 0.6448790344246242, 0.21207275021879246, 0.39312612218022736, 0.555865775219667, 0.5740633845944019, 0.3776663937812458, 0.37130742319742693, 0.3473503525461963, 0.4696775215665582, 0.10439943868874746, 0.19687228204100038, 0.13502214820522151, 0.4100004206015776, 0.30863199698441846, 0.38069126538467757, 0.09880809622958131, 0.17524945942708803, 0.3291931622366149, 0.35283391007612097, 0.3656723136185146, 0.3202237806761682, 0.3807632054166503, 0.39634346457131975, 0.3274224563710523, 0.3320481684075276, 0.3400113473820877, 0.30362557895604847, 0.7966505104010551, 0.7833815565390648, 0.7659486387412797, 0.7915048952663282, 0.7759103364949282, 0.7642355845615405, 0.7950657862143864, 0.7646844850765779, 0.7716234504827703, 0.11070055559590619, 0.03235280942984298, 0.11318312575853817, 0.06307174289090256, 0.08683993244120392, 0.0888833841262473, 0.1476179481028077, 0.11045803313967573, 0.0876487268157593, 0.7145016840737239, 0.668679375544815, 0.23931408049921687, 0.6759353362736633, 0.6991011433132335, 0.6878359708507803, 0.6529416975550209, 0.3425192162463705, 0.28943843876440156, 0.13755514311225947, 0.4776164605080053, 0.47873669098326677, 0.26829649936740896, 0.22897523881996285, 0.4933833615037666, 0.2595755483114631, 0.5063242498344667, 0.5023299144358919, 0.35124946002079693, 0.41208479426050637, 0.3273184912328032, 0.18271188552281648, 0.22315355245922186, 0.2531297204559564, 0.41479987855001665, 0.4257431029140837, 0.43500043657189336, 0.2144204750634603, 0.22322588838869528, 0.2054721836566108, 0.29542659872444577, 0.23351960470971223, 0.21547015926491864, 0.2174750077990768, 0.19755524027722626, 0.20492120446023177, 0.20665755372682415, 0.19415217985118216, 0.1977675933555555, 0.22621327331595376, 0.7663038669571772, 0.21067334801237148, 0.18919674573262923, 0.22524859550613296, 0.1976550946667266, 0.1489058033199765, 0.12744266758109934, 0.15489775725077493, 0.952895986727425, 0.2021347793261229, 0.20162982595770318, 0.9299467173578883, 0.1705555319760741, 0.15461874087948602, 0.9231883531430638, 0.21458593496014966, 0.15547715846481547, 0.10495735851719312, 0.8553265601044483, 0.15322300668595268, 0.10524334936645396, 0.10513119764023071, 0.8112679329762931, 0.18162439927446716, 0.17874172357951779, 0.17864688368682857, 0.18546069789458697, 0.1885834418915815, 0.1888070244557758, 0.19358441257526082, 0.18294376031376125, 0.19278293622534415, 0.08640863447931735, 0.08223537952501592, 0.08924267659980212, 0.08681471855377565, 0.07111902872067344, 0.106209568221868, 0.0853346261487371, 0.08175374900890098, 0.1058597689604569]}, "mutation_prompt": null}
{"id": "fa1512e3-f2c2-4804-ad92-42808b5cf784", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.5 + np.random.rand() * 0.5):  # Slightly adjusted adaptive F factor\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):  # Fine-tuned crossover rate for diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def guided_search(self):\n        direction = np.random.uniform(-1.0, 1.0, self.dim)\n        guide = np.clip(self.population[self.global_best] + 0.2 * direction, self.lower_bound, self.upper_bound)\n        return guide\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.25:  # Increased chance to use guided search\n                    trial = self.guided_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridAdaptiveDifferentialEvolution", "description": "Hybrid Adaptive Differential Evolution with Guided Search for Enhanced Convergence.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6905ab66-7276-4172-aaad-3b408416ed77", "metadata": {"aucs": [0.8701120635139404, 0.8677838411045177, 0.8553302640436486, 0.8733341512636563, 0.8779275801594602, 0.8631257866302713, 0.8768535626281874, 0.8677920876265968, 0.8745723664812668, 0.6595920228782264, 0.6835244373074782, 0.6771432469747519, 0.5885939892527814, 0.6500063246291172, 0.637541438764744, 0.5355020431785278, 0.6576012898629728, 0.4739339404799814, 0.1766257854104939, 0.10028573675548524, 0.12157331102853719, 0.08382027605649434, 0.08736015662264851, 0.09727617971343483, 0.14699846353833035, 0.17395620930083477, 0.15869527710112963, 0.11573224286924433, 0.06609510172629618, 0.06211531884926591, 0.1151007098130673, 0.05081337059789859, 0.06961335752171705, 0.1454000247934888, 0.05913495880103237, 0.09910510946658446, 0.9762664461035179, 0.9456784922827046, 0.9793781979481453, 0.9737302682524571, 0.9743730062816319, 0.8956591209749616, 0.9560751543888608, 0.9837523071675339, 0.9381568826315719, 0.6343903767325434, 0.6652541313116588, 0.5815541914700436, 0.5915947257897334, 0.6207550141118101, 0.6010284333792573, 0.6501852663388421, 0.6350573970945292, 0.61735095354645, 0.23113109568059176, 0.13666395020588606, 0.17235615181934993, 0.8909442839484986, 0.1932229192154643, 0.28145953684729574, 0.8896776323368549, 0.13195658238297525, 0.8851251132279552, 0.4373355360636696, 0.246670377557622, 0.16342113675888026, 0.24713264139351754, 0.333201950342789, 0.3554319358683201, 0.3789192466040944, 0.13396501965669627, 0.2506594487593681, 0.6372645569296719, 0.2500535182452711, 0.22587939895638864, 0.2886155752921583, 0.3697927368948857, 0.3345062485472007, 0.2231327605997271, 0.1867546245242776, 0.20128331562067292, 0.09223080293511887, 0.40145076181582817, 0.4340203378458417, 0.04112565784914202, 0.14413113519443432, 0.33415690103013407, 0.28404754681104893, 0.1061064923952697, 0.44569726681161914, 0.6448790344246242, 0.21207275021879246, 0.39312612218022736, 0.555865775219667, 0.5740633845944019, 0.3776663937812458, 0.37130742319742693, 0.3473503525461963, 0.4696775215665582, 0.10439943868874746, 0.19687228204100038, 0.13502214820522151, 0.4100004206015776, 0.30863199698441846, 0.38069126538467757, 0.09880809622958131, 0.17524945942708803, 0.3291931622366149, 0.35283391007612097, 0.3656723136185146, 0.3202237806761682, 0.3807632054166503, 0.39634346457131975, 0.3274224563710523, 0.3320481684075276, 0.3400113473820877, 0.30362557895604847, 0.7966505104010551, 0.7833815565390648, 0.7659486387412797, 0.7915048952663282, 0.7759103364949282, 0.7642355845615405, 0.7950657862143864, 0.7646844850765779, 0.7716234504827703, 0.11070055559590619, 0.03235280942984298, 0.11318312575853817, 0.06307174289090256, 0.08683993244120392, 0.0888833841262473, 0.1476179481028077, 0.11045803313967573, 0.0876487268157593, 0.7145016840737239, 0.668679375544815, 0.23931408049921687, 0.6759353362736633, 0.6991011433132335, 0.6878359708507803, 0.6529416975550209, 0.3425192162463705, 0.28943843876440156, 0.13755514311225947, 0.4776164605080053, 0.47873669098326677, 0.26829649936740896, 0.22897523881996285, 0.4933833615037666, 0.2595755483114631, 0.5063242498344667, 0.5023299144358919, 0.35124946002079693, 0.41208479426050637, 0.3273184912328032, 0.18271188552281648, 0.22315355245922186, 0.2531297204559564, 0.41479987855001665, 0.4257431029140837, 0.43500043657189336, 0.2144204750634603, 0.22322588838869528, 0.2054721836566108, 0.29542659872444577, 0.23351960470971223, 0.21547015926491864, 0.2174750077990768, 0.19755524027722626, 0.20492120446023177, 0.20665755372682415, 0.19415217985118216, 0.1977675933555555, 0.22621327331595376, 0.7663038669571772, 0.21067334801237148, 0.18919674573262923, 0.22524859550613296, 0.1976550946667266, 0.1489058033199765, 0.12744266758109934, 0.15489775725077493, 0.952895986727425, 0.2021347793261229, 0.20162982595770318, 0.9299467173578883, 0.1705555319760741, 0.15461874087948602, 0.9231883531430638, 0.21458593496014966, 0.15547715846481547, 0.10495735851719312, 0.8553265601044483, 0.15322300668595268, 0.10524334936645396, 0.10513119764023071, 0.8112679329762931, 0.18162439927446716, 0.17874172357951779, 0.17864688368682857, 0.18546069789458697, 0.1885834418915815, 0.1888070244557758, 0.19358441257526082, 0.18294376031376125, 0.19278293622534415, 0.08640863447931735, 0.08223537952501592, 0.08924267659980212, 0.08681471855377565, 0.07111902872067344, 0.106209568221868, 0.0853346261487371, 0.08175374900890098, 0.1058597689604569]}, "mutation_prompt": null}
{"id": "3453dbcf-a38f-475b-b326-3095b7c0b8ad", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 10 * dim  # Slightly increased population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.6 * (1 + np.random.rand() * 0.4)):  # Dynamically adjusted factor\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.8):  # Adjusted crossover rate\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def guided_search(self):\n        direction = np.random.uniform(-1.0, 1.0, self.dim)\n        guide = np.clip(self.population[self.global_best] + 0.3 * direction, self.lower_bound, self.upper_bound)  # Enhanced search step\n        return guide\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.3:  # Enhanced guided search probability\n                    trial = self.guided_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "EnhancedHybridAdaptiveDifferentialEvolution", "description": "Enhanced Hybrid Adaptive Differential Evolution using Adaptive Rules and Dynamic Mutation for Improved Convergence.", "configspace": "", "generation": 78, "fitness": 0.3017766431375298, "feedback": "The algorithm EnhancedHybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "6905ab66-7276-4172-aaad-3b408416ed77", "metadata": {"aucs": [0.7532472396418681, 0.7231702444265204, 0.7279022832224877, 0.7455521783548991, 0.7547960475140254, 0.7586579779829086, 0.7243913482547911, 0.7459849239026617, 0.751723118485914, 0.37520133230729147, 0.41030681216499254, 0.3509292768440794, 0.36126772188761835, 0.3690272600635023, 0.36947425790063104, 0.3705553474791813, 0.3852139340787648, 0.3216127182723121, 0.1332962294289659, 0.11595728170635267, 0.14994722749095013, 0.141675760736235, 0.11897297120959538, 0.11290732427777217, 0.12294436842715206, 0.16484387243153087, 0.13668716046633123, 0.1330015183522193, 0.10676493259414022, 0.10332958293727312, 0.12897928057127828, 0.1198235483578175, 0.11492913760147949, 0.1462062830862495, 0.09437902686503752, 0.13115850852511524, 0.9739593821833042, 0.9767239009969431, 0.9862445266968821, 0.9695537420324556, 0.9629835880370998, 0.9669452742332754, 0.9725617321305124, 0.9773042344208146, 0.9889438848305506, 0.3949136837042382, 0.3956114381006328, 0.3696857311904833, 0.388959552454859, 0.40705128101100874, 0.36800318195024706, 0.38932518100322255, 0.4069500358146113, 0.3922600343764897, 0.7846813203771252, 0.6121382108813016, 0.6358585724810863, 0.8172033421452395, 0.5533913486253909, 0.6443406508473828, 0.6596115090230625, 0.7058150026396353, 0.6666499096011246, 0.32586351913259337, 0.19192951349629728, 0.24288549421339645, 0.2146123606279936, 0.23336969287911036, 0.18947010673472642, 0.22323181406295667, 0.27724047918344663, 0.2604843499601702, 0.22986032390884503, 0.30079279675371406, 0.28632760210293784, 0.2201989507357759, 0.22610433503761818, 0.24437253934779624, 0.26966970865380957, 0.1921050212337001, 0.1289015653580653, 0.08318979743536148, 0.09920552693937157, 0.10296841966324388, 0.13412932703814218, 0.12778845965349028, 0.06470978165968078, 0.13425178636797264, 0.11171294998410686, 0.10462943921273804, 0.2780709231180998, 0.1915971499629724, 0.24246943210893102, 0.23830813614204815, 0.1734091341561449, 0.18299301164586645, 0.24229666207255918, 0.22913341515223673, 0.17763376415992638, 0.025671725057643147, 0.022281324705618277, 0.03290314877069178, 0.07092455454407465, 0.055178750015524414, 0.06894791809408818, 0.06168158482504438, 0.0336099179719882, 0.06200130177891128, 0.17483121880815544, 0.18988918529261622, 0.1773151694517977, 0.18100786934687452, 0.18046171415782142, 0.16793009618553156, 0.18736499516771654, 0.1542957122845402, 0.15928157997507553, 0.5078510070990121, 0.5014242693509463, 0.540876146780588, 0.5420311255975592, 0.4954943826237199, 0.5362851973116078, 0.5552442583043053, 0.5327751138100563, 0.5047967762001093, 0.14198061513020788, 0.13872187719278606, 0.10423739621131811, 0.0995616204427846, 0.12189120384248908, 0.10519621282405, 0.08975759850034115, 0.09243617223776379, 0.10915375950364359, 0.23608715810286274, 0.3632662315258436, 0.34557829121616745, 0.287456198036786, 0.3686700181056749, 0.38553083038433855, 0.380838094272017, 0.2570516288146871, 0.15586498302559537, 0.3500967041090117, 0.14955896777060895, 0.3210650045314717, 0.21930853165603426, 0.18905183511822365, 0.3379138258540708, 0.3546309664510201, 0.3517701866134557, 0.31359173357835257, 0.21482098419322637, 0.19974180035765998, 0.2760840506128781, 0.25014315630883255, 0.22739279704821125, 0.26400163651190944, 0.2627202176086445, 0.2709270447159211, 0.2743270201416006, 0.2069181074361971, 0.19566956090879084, 0.2047111237329149, 0.2317117273327286, 0.20567216931042342, 0.21399753128317722, 0.2377565926863301, 0.2023282130951618, 0.20454586740323344, 0.21892017381786877, 0.21764329322506115, 0.24591741550473456, 0.24253571412984043, 0.21261666100536358, 0.2567596780949163, 0.24050297757405492, 0.3292424382095904, 0.2020375257988556, 0.1886207467700105, 0.12720483212954803, 0.1547292398952319, 0.17330412968248743, 0.20208452870996996, 0.2010608360960554, 0.8610255351440093, 0.16582377818207295, 0.8749450701960269, 0.7719112024897574, 0.2138424061702754, 0.0736197208621806, 0.10493949450428919, 0.16933033287913024, 0.15440806136829, 0.21318746121339216, 0.10520991922897394, 0.7478730952092233, 0.18107412988589555, 0.1823347000665826, 0.1865810842964707, 0.18684261569173044, 0.18487299847804028, 0.1883764173391428, 0.18081040499292655, 0.187868500173194, 0.18356932793020586, 0.0782300904202421, 0.09519912049414414, 0.09023911186970579, 0.0918254030264023, 0.07531038372708221, 0.07820494767599251, 0.10349819637452551, 0.09394894946851129, 0.09117339891859577]}, "mutation_prompt": null}
{"id": "d1aa0b1d-98d1-461f-9b0e-4f3f5f6643d9", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.5 + np.random.rand() * 0.5):  # Slightly adjusted adaptive F factor\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):  # Fine-tuned crossover rate for diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def guided_search(self):\n        direction = np.random.uniform(-1.0, 1.0, self.dim)\n        guide = np.clip(self.population[self.global_best] + 0.2 * direction, self.lower_bound, self.upper_bound)\n        return guide\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.25:  # Increased chance to use guided search\n                    trial = self.guided_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridAdaptiveDifferentialEvolution", "description": "Hybrid Adaptive Differential Evolution with Guided Search for Enhanced Convergence.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6905ab66-7276-4172-aaad-3b408416ed77", "metadata": {"aucs": [0.8701120635139404, 0.8677838411045177, 0.8553302640436486, 0.8733341512636563, 0.8779275801594602, 0.8631257866302713, 0.8768535626281874, 0.8677920876265968, 0.8745723664812668, 0.6595920228782264, 0.6835244373074782, 0.6771432469747519, 0.5885939892527814, 0.6500063246291172, 0.637541438764744, 0.5355020431785278, 0.6576012898629728, 0.4739339404799814, 0.1766257854104939, 0.10028573675548524, 0.12157331102853719, 0.08382027605649434, 0.08736015662264851, 0.09727617971343483, 0.14699846353833035, 0.17395620930083477, 0.15869527710112963, 0.11573224286924433, 0.06609510172629618, 0.06211531884926591, 0.1151007098130673, 0.05081337059789859, 0.06961335752171705, 0.1454000247934888, 0.05913495880103237, 0.09910510946658446, 0.9762664461035179, 0.9456784922827046, 0.9793781979481453, 0.9737302682524571, 0.9743730062816319, 0.8956591209749616, 0.9560751543888608, 0.9837523071675339, 0.9381568826315719, 0.6343903767325434, 0.6652541313116588, 0.5815541914700436, 0.5915947257897334, 0.6207550141118101, 0.6010284333792573, 0.6501852663388421, 0.6350573970945292, 0.61735095354645, 0.23113109568059176, 0.13666395020588606, 0.17235615181934993, 0.8909442839484986, 0.1932229192154643, 0.28145953684729574, 0.8896776323368549, 0.13195658238297525, 0.8851251132279552, 0.4373355360636696, 0.246670377557622, 0.16342113675888026, 0.24713264139351754, 0.333201950342789, 0.3554319358683201, 0.3789192466040944, 0.13396501965669627, 0.2506594487593681, 0.6372645569296719, 0.2500535182452711, 0.22587939895638864, 0.2886155752921583, 0.3697927368948857, 0.3345062485472007, 0.2231327605997271, 0.1867546245242776, 0.20128331562067292, 0.09223080293511887, 0.40145076181582817, 0.4340203378458417, 0.04112565784914202, 0.14413113519443432, 0.33415690103013407, 0.28404754681104893, 0.1061064923952697, 0.44569726681161914, 0.6448790344246242, 0.21207275021879246, 0.39312612218022736, 0.555865775219667, 0.5740633845944019, 0.3776663937812458, 0.37130742319742693, 0.3473503525461963, 0.4696775215665582, 0.10439943868874746, 0.19687228204100038, 0.13502214820522151, 0.4100004206015776, 0.30863199698441846, 0.38069126538467757, 0.09880809622958131, 0.17524945942708803, 0.3291931622366149, 0.35283391007612097, 0.3656723136185146, 0.3202237806761682, 0.3807632054166503, 0.39634346457131975, 0.3274224563710523, 0.3320481684075276, 0.3400113473820877, 0.30362557895604847, 0.7966505104010551, 0.7833815565390648, 0.7659486387412797, 0.7915048952663282, 0.7759103364949282, 0.7642355845615405, 0.7950657862143864, 0.7646844850765779, 0.7716234504827703, 0.11070055559590619, 0.03235280942984298, 0.11318312575853817, 0.06307174289090256, 0.08683993244120392, 0.0888833841262473, 0.1476179481028077, 0.11045803313967573, 0.0876487268157593, 0.7145016840737239, 0.668679375544815, 0.23931408049921687, 0.6759353362736633, 0.6991011433132335, 0.6878359708507803, 0.6529416975550209, 0.3425192162463705, 0.28943843876440156, 0.13755514311225947, 0.4776164605080053, 0.47873669098326677, 0.26829649936740896, 0.22897523881996285, 0.4933833615037666, 0.2595755483114631, 0.5063242498344667, 0.5023299144358919, 0.35124946002079693, 0.41208479426050637, 0.3273184912328032, 0.18271188552281648, 0.22315355245922186, 0.2531297204559564, 0.41479987855001665, 0.4257431029140837, 0.43500043657189336, 0.2144204750634603, 0.22322588838869528, 0.2054721836566108, 0.29542659872444577, 0.23351960470971223, 0.21547015926491864, 0.2174750077990768, 0.19755524027722626, 0.20492120446023177, 0.20665755372682415, 0.19415217985118216, 0.1977675933555555, 0.22621327331595376, 0.7663038669571772, 0.21067334801237148, 0.18919674573262923, 0.22524859550613296, 0.1976550946667266, 0.1489058033199765, 0.12744266758109934, 0.15489775725077493, 0.952895986727425, 0.2021347793261229, 0.20162982595770318, 0.9299467173578883, 0.1705555319760741, 0.15461874087948602, 0.9231883531430638, 0.21458593496014966, 0.15547715846481547, 0.10495735851719312, 0.8553265601044483, 0.15322300668595268, 0.10524334936645396, 0.10513119764023071, 0.8112679329762931, 0.18162439927446716, 0.17874172357951779, 0.17864688368682857, 0.18546069789458697, 0.1885834418915815, 0.1888070244557758, 0.19358441257526082, 0.18294376031376125, 0.19278293622534415, 0.08640863447931735, 0.08223537952501592, 0.08924267659980212, 0.08681471855377565, 0.07111902872067344, 0.106209568221868, 0.0853346261487371, 0.08175374900890098, 0.1058597689604569]}, "mutation_prompt": null}
{"id": "7af394f9-9b12-4d03-87af-0a280836d3b1", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n        self.CR = 0.9\n        self.F = 0.5\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c):\n        F = self.F + np.random.normal(0, 0.1)  # Self-adaptive F factor with normal distribution\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        CR = self.CR + np.random.normal(0, 0.1)  # Self-adaptive CR rate with normal distribution\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def guided_search(self):\n        direction = np.random.uniform(-1.0, 1.0, self.dim)\n        guide = np.clip(self.population[self.global_best] + 0.2 * direction, self.lower_bound, self.upper_bound)\n        return guide\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.3:  # Slightly adjusted chance to use guided search\n                    trial = self.guided_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "EnhancedHybridAdaptiveDifferentialEvolution", "description": "Enhanced Hybrid Adaptive Differential Evolution with Self-Adaptive Parameters for Improved Convergence.", "configspace": "", "generation": 80, "fitness": 0.3544039385327576, "feedback": "The algorithm EnhancedHybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.28.", "error": "", "parent_id": "6905ab66-7276-4172-aaad-3b408416ed77", "metadata": {"aucs": [0.8691287474165134, 0.8619387314250593, 0.8737902699481643, 0.8907390983815626, 0.8843987579984434, 0.8718028438044232, 0.8702283749006787, 0.8737935308859253, 0.8748124946057901, 0.6553189505110637, 0.21644796210344153, 0.49444719795634495, 0.578215377312316, 0.47545978714146153, 0.40665863731296537, 0.4410279431633477, 0.6125159838963887, 0.4786053267588408, 0.14481855245735475, 0.12325663053267999, 0.15924331998331565, 0.16368127975522562, 0.11288369927038477, 0.07505672350547721, 0.12357218994856445, 0.4882312588474771, 0.14476588838313165, 0.08745351258586542, 0.0968633695144534, 0.07126987340613355, 0.08685128269612363, 0.05271445925693008, 0.10933966126253358, 0.06010964969887678, 0.0702110133771714, 0.07182655990824227, 0.9585905757007515, 0.9898598788049872, 0.9385056684241411, 0.9291110887037229, 0.9483957158579859, 0.8874372264054324, 0.9538023693005232, 0.9636357900865247, 0.9533322116186114, 0.5619200505642119, 0.5978369247101784, 0.5599301746251868, 0.5741280407560884, 0.6081642769223423, 0.6599743683976981, 0.6353877394233354, 0.49209727853303264, 0.6179710976385775, 0.22791067409654875, 0.22145627116921318, 0.8528878968378761, 0.2826496255011862, 0.8550391690567464, 0.15367853460401604, 0.23819319405288364, 0.1511496508538357, 0.21440132054567707, 0.46929186242394894, 0.13631384862208418, 0.2897753220514574, 0.24939487493624424, 0.2147188700592585, 0.24441092244464413, 0.19416209194754064, 0.24263683472854536, 0.3171339669931613, 0.6466192812925198, 0.18723652687866177, 0.25594825741356464, 0.13639640770921702, 0.32982646161905727, 0.13735693393828075, 0.252964050042089, 0.2276164568426211, 0.2548385178851953, 0.11563856904289327, 0.5333016372140882, 0.3453087547178184, 0.12901263490036852, 0.3645998436846589, 0.21069871415781594, 0.17413909119289106, 0.1833038751080841, 0.43490183988438025, 0.23761324841608555, 0.08658725967301484, 0.31534795484302625, 0.13264465735163544, 0.07386864331925613, 0.21893786045360397, 0.405694610175401, 0.6046008894691239, 0.17573408539922097, 0.05473273116727484, 0.044701385199284016, 0.24363419046995693, 0.23145587010917468, 0.10569824520694837, 0.27667416750485607, 0.1840214667315303, 0.12110013656063656, 0.1062946261880916, 0.42066474902498185, 0.4272217157325595, 0.38329644964227516, 0.30930215248726056, 0.26081149799242975, 0.3723549809896999, 0.37550844543632733, 0.37979637590909565, 0.4065054905854074, 0.7846733222607911, 0.7645721731714324, 0.7689050090978413, 0.7931143887816923, 0.7921543109376478, 0.7696939297454479, 0.809663784213262, 0.7917181501820777, 0.7907639103889014, 0.11655878776189388, 0.08637592376703451, 0.05320162001865991, 0.0667118180895705, 0.07068081687623251, 0.13905872929773155, 0.08147895354846735, 0.08932430139012792, 0.0972052315323706, 0.22121396774708324, 0.6294642467984897, 0.24070702250227338, 0.24239039609259105, 0.7285616424582361, 0.2122515044159602, 0.28251413026875793, 0.21591909913418317, 0.6911234781103748, 0.4662401232710016, 0.2614000283529956, 0.22061225510163884, 0.20420483181712712, 0.43845728516486515, 0.39844041696296006, 0.216554748656699, 0.5054836372569248, 0.23933052218267747, 0.10417981745247218, 0.17518101563692035, 0.3934110133263734, 0.22223866954411076, 0.10640342344182407, 0.20438639390984592, 0.34581300690667705, 0.36343448557508073, 0.4259783977890321, 0.228708759699777, 0.20802046691755594, 0.19031215422107584, 0.22723379326257642, 0.1538958701186358, 0.15585608252327687, 0.19908824754234655, 0.21708205119701673, 0.2352188644228843, 0.20218062569438866, 0.21228533908961145, 0.2041738867756312, 0.21230420249758264, 0.20006734206739551, 0.1918628772256339, 0.21219826105765782, 0.2532480468314344, 0.18261559291877683, 0.12702615094689296, 0.12751306576300592, 0.2147518415243167, 0.9350766197017242, 0.20201924262605941, 0.20193734433855204, 0.9138355883088849, 0.17060322575224562, 0.9515363747533057, 0.8938100206885853, 0.21423453113926194, 0.8606635621672801, 0.21303558869542627, 0.8460904270630176, 0.15613595276841585, 0.10545266493115069, 0.10507312687435955, 0.831105406762162, 0.20186586149417152, 0.1814887017373611, 0.18085287414616302, 0.18382236400556007, 0.1781024333911071, 0.18305911401490116, 0.17808983104723397, 0.18565688601825436, 0.1816705677865318, 0.11393922776690868, 0.07364102677576811, 0.07249632781704718, 0.08178787203467641, 0.08712943840828535, 0.08768103435417307, 0.09657334667593309, 0.0852027459499608, 0.08891106297210594]}, "mutation_prompt": null}
{"id": "14d62ddb-18ce-4092-9f35-6838762a6474", "solution": "import numpy as np\n\nclass ImprovedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.6 + np.random.rand() * 0.4):  # Slightly modified adaptive F factor range\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.8):  # Adjusted crossover rate for diversity balancing\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def guided_search(self):\n        direction = np.random.uniform(-0.5, 0.5, self.dim)  # Narrower exploration direction range\n        guide = np.clip(self.population[self.global_best] + 0.3 * direction, self.lower_bound, self.upper_bound)\n        return guide\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.3:  # Increased chance to use guided search\n                    trial = self.guided_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "ImprovedHybridAdaptiveDifferentialEvolution", "description": "Improved Hybrid Differential Evolution with Stochastic Adaptive Parameters for Enhanced Convergence.", "configspace": "", "generation": 81, "fitness": 0.31913209882364346, "feedback": "The algorithm ImprovedHybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.25.", "error": "", "parent_id": "6905ab66-7276-4172-aaad-3b408416ed77", "metadata": {"aucs": [0.8525516733169594, 0.8524078749620227, 0.846314955285958, 0.856387718191309, 0.8591504301597728, 0.8515418159594511, 0.8496810958367675, 0.8440713763944369, 0.8615215028263152, 0.6084917832743935, 0.5426790031893839, 0.5775954406619174, 0.5637329026759792, 0.4576507669174893, 0.6052870655080504, 0.5492292650831903, 0.5602578721817649, 0.5993323991083537, 0.07754350062716608, 0.12985882635228663, 0.13298611114738856, 0.13200533735248754, 0.14704071256420115, 0.06616864271472755, 0.12439354746524856, 0.11307157803692758, 0.15807110184189155, 0.14578774364130875, 0.04404066298912057, 0.11050974235756361, 0.12325913536762056, 0.05678086167623242, 0.11034801007362438, 0.0914452643414625, 0.050624436792835015, 0.057047887300357814, 0.9756703246443835, 0.9494679770421174, 0.9823900378738892, 0.9603562517593672, 0.9659564113971734, 0.977306422446064, 0.9859318774519498, 0.9787180725167354, 0.9828584845677747, 0.5325378356019238, 0.5642723268643548, 0.5123202971933605, 0.5046318462694808, 0.5543993616441856, 0.540824230087526, 0.5344978566570437, 0.5292040674165772, 0.536078606189708, 0.6247790224729227, 0.11787552860708839, 0.2297603593928228, 0.2632368947119573, 0.2602703282226334, 0.193324319464941, 0.17713634260600997, 0.1526707427592563, 0.45695284132001013, 0.42700709247461355, 0.25901225223815383, 0.2044601941819879, 0.2242019259854755, 0.32544036386972963, 0.13213005288324553, 0.35339683263100874, 0.13364432711027707, 0.2531575790714242, 0.4298439899819777, 0.2405303579413426, 0.25260766327729467, 0.3124238032397936, 0.3905457974331328, 0.33488456493002305, 0.2190728399043428, 0.1329754027456298, 0.1671400713292096, 0.08082735672948116, 0.1583119628320372, 0.12949061130990247, 0.09744600869810294, 0.25678308009530326, 0.09117088064990386, 0.12890552667695043, 0.1724296431972383, 0.0711133472032659, 0.2882969832508424, 0.12398445030651273, 0.1941433734724335, 0.26383546722001217, 0.20985655565300243, 0.10842019557032923, 0.34680423943692085, 0.38278540271487227, 0.21423269880109141, 0.10028909563954258, 0.16257532406304598, 0.14742751647828467, 0.16923259357945808, 0.1517050957783196, 0.1003231855778185, 0.0831994446358818, 0.08273631756774935, 0.1331052274496627, 0.2430995263017518, 0.19757015731357563, 0.27716193693529, 0.24601521706281892, 0.22146056242403533, 0.2511380191933217, 0.2313167647475507, 0.20455227528143693, 0.2321369906039833, 0.6486376437315253, 0.6172010151273817, 0.6387799098033287, 0.6231961611673095, 0.62080636262528, 0.6158063878081743, 0.6215337731849855, 0.6212829271876784, 0.6430127549915914, 0.11968929204804568, 0.0639384537230111, 0.1262330593703176, 0.06690700097970914, 0.07875721571769556, 0.14627489245988545, 0.09719512767957272, 0.07807483088804712, 0.11215247922007043, 0.27377710291933444, 0.2255881117877142, 0.22391232039576225, 0.4765083617543201, 0.5413865464299115, 0.19503052474346638, 0.5322355376478396, 0.22147634147565332, 0.4959217044520956, 0.13991223583713164, 0.22875837300660062, 0.40640008752486745, 0.3813662630554321, 0.4170735001159124, 0.4174385690236784, 0.240930735846975, 0.4110722159308673, 0.2932788529243521, 0.2113019818339561, 0.17276816373058812, 0.2858923293185234, 0.2637756376795206, 0.17333052558330186, 0.30375682040222496, 0.19366556886703346, 0.2832406603533074, 0.23431365876166577, 0.20935864867626064, 0.21148028188018453, 0.40797103491558195, 0.20240033107016375, 0.28390425581123724, 0.23837270022595802, 0.24537108876245606, 0.2140830618317534, 0.26137170990967773, 0.7424267921873915, 0.19243411056667392, 0.2132213474726813, 0.2556342370493837, 0.18398766843202596, 0.18311116229444357, 0.2123226040306858, 0.21336652061337702, 0.2098607643425503, 0.16880381540225642, 0.17849894426798996, 0.15486946359733134, 0.17321054142807568, 0.20216827116267988, 0.20108013398244295, 0.14340196905901792, 0.1704481484822642, 0.16805546757813006, 0.867621486650573, 0.21466309185320487, 0.7995127334654614, 0.10514217672338222, 0.16875165649629964, 0.15574835382319052, 0.15707883468203476, 0.10500311977992882, 0.7976830389970757, 0.1902425629485699, 0.20088748829382252, 0.19879514623078653, 0.20043132564317434, 0.19251282158897443, 0.1797901825384015, 0.18076751949789271, 0.18821276525948416, 0.19099597133589807, 0.09427082680755994, 0.10439630057369143, 0.08112269144831585, 0.09095463024646289, 0.08598159099007008, 0.082385010485451, 0.10938156588220849, 0.0809098915985611, 0.08582861088057347]}, "mutation_prompt": null}
{"id": "327d8fc5-6f1e-409b-8285-e466044cad11", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.5 + np.random.rand() * 0.5):  # Slightly adjusted adaptive F factor\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):  # Fine-tuned crossover rate for diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def guided_search(self):\n        direction = np.random.uniform(-1.0, 1.0, self.dim)\n        guide = np.clip(self.population[self.global_best] + 0.2 * direction, self.lower_bound, self.upper_bound)\n        return guide\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.25:  # Increased chance to use guided search\n                    trial = self.guided_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridAdaptiveDifferentialEvolution", "description": "Hybrid Adaptive Differential Evolution with Guided Search for Enhanced Convergence.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6905ab66-7276-4172-aaad-3b408416ed77", "metadata": {"aucs": [0.8701120635139404, 0.8677838411045177, 0.8553302640436486, 0.8733341512636563, 0.8779275801594602, 0.8631257866302713, 0.8768535626281874, 0.8677920876265968, 0.8745723664812668, 0.6595920228782264, 0.6835244373074782, 0.6771432469747519, 0.5885939892527814, 0.6500063246291172, 0.637541438764744, 0.5355020431785278, 0.6576012898629728, 0.4739339404799814, 0.1766257854104939, 0.10028573675548524, 0.12157331102853719, 0.08382027605649434, 0.08736015662264851, 0.09727617971343483, 0.14699846353833035, 0.17395620930083477, 0.15869527710112963, 0.11573224286924433, 0.06609510172629618, 0.06211531884926591, 0.1151007098130673, 0.05081337059789859, 0.06961335752171705, 0.1454000247934888, 0.05913495880103237, 0.09910510946658446, 0.9762664461035179, 0.9456784922827046, 0.9793781979481453, 0.9737302682524571, 0.9743730062816319, 0.8956591209749616, 0.9560751543888608, 0.9837523071675339, 0.9381568826315719, 0.6343903767325434, 0.6652541313116588, 0.5815541914700436, 0.5915947257897334, 0.6207550141118101, 0.6010284333792573, 0.6501852663388421, 0.6350573970945292, 0.61735095354645, 0.23113109568059176, 0.13666395020588606, 0.17235615181934993, 0.8909442839484986, 0.1932229192154643, 0.28145953684729574, 0.8896776323368549, 0.13195658238297525, 0.8851251132279552, 0.4373355360636696, 0.246670377557622, 0.16342113675888026, 0.24713264139351754, 0.333201950342789, 0.3554319358683201, 0.3789192466040944, 0.13396501965669627, 0.2506594487593681, 0.6372645569296719, 0.2500535182452711, 0.22587939895638864, 0.2886155752921583, 0.3697927368948857, 0.3345062485472007, 0.2231327605997271, 0.1867546245242776, 0.20128331562067292, 0.09223080293511887, 0.40145076181582817, 0.4340203378458417, 0.04112565784914202, 0.14413113519443432, 0.33415690103013407, 0.28404754681104893, 0.1061064923952697, 0.44569726681161914, 0.6448790344246242, 0.21207275021879246, 0.39312612218022736, 0.555865775219667, 0.5740633845944019, 0.3776663937812458, 0.37130742319742693, 0.3473503525461963, 0.4696775215665582, 0.10439943868874746, 0.19687228204100038, 0.13502214820522151, 0.4100004206015776, 0.30863199698441846, 0.38069126538467757, 0.09880809622958131, 0.17524945942708803, 0.3291931622366149, 0.35283391007612097, 0.3656723136185146, 0.3202237806761682, 0.3807632054166503, 0.39634346457131975, 0.3274224563710523, 0.3320481684075276, 0.3400113473820877, 0.30362557895604847, 0.7966505104010551, 0.7833815565390648, 0.7659486387412797, 0.7915048952663282, 0.7759103364949282, 0.7642355845615405, 0.7950657862143864, 0.7646844850765779, 0.7716234504827703, 0.11070055559590619, 0.03235280942984298, 0.11318312575853817, 0.06307174289090256, 0.08683993244120392, 0.0888833841262473, 0.1476179481028077, 0.11045803313967573, 0.0876487268157593, 0.7145016840737239, 0.668679375544815, 0.23931408049921687, 0.6759353362736633, 0.6991011433132335, 0.6878359708507803, 0.6529416975550209, 0.3425192162463705, 0.28943843876440156, 0.13755514311225947, 0.4776164605080053, 0.47873669098326677, 0.26829649936740896, 0.22897523881996285, 0.4933833615037666, 0.2595755483114631, 0.5063242498344667, 0.5023299144358919, 0.35124946002079693, 0.41208479426050637, 0.3273184912328032, 0.18271188552281648, 0.22315355245922186, 0.2531297204559564, 0.41479987855001665, 0.4257431029140837, 0.43500043657189336, 0.2144204750634603, 0.22322588838869528, 0.2054721836566108, 0.29542659872444577, 0.23351960470971223, 0.21547015926491864, 0.2174750077990768, 0.19755524027722626, 0.20492120446023177, 0.20665755372682415, 0.19415217985118216, 0.1977675933555555, 0.22621327331595376, 0.7663038669571772, 0.21067334801237148, 0.18919674573262923, 0.22524859550613296, 0.1976550946667266, 0.1489058033199765, 0.12744266758109934, 0.15489775725077493, 0.952895986727425, 0.2021347793261229, 0.20162982595770318, 0.9299467173578883, 0.1705555319760741, 0.15461874087948602, 0.9231883531430638, 0.21458593496014966, 0.15547715846481547, 0.10495735851719312, 0.8553265601044483, 0.15322300668595268, 0.10524334936645396, 0.10513119764023071, 0.8112679329762931, 0.18162439927446716, 0.17874172357951779, 0.17864688368682857, 0.18546069789458697, 0.1885834418915815, 0.1888070244557758, 0.19358441257526082, 0.18294376031376125, 0.19278293622534415, 0.08640863447931735, 0.08223537952501592, 0.08924267659980212, 0.08681471855377565, 0.07111902872067344, 0.106209568221868, 0.0853346261487371, 0.08175374900890098, 0.1058597689604569]}, "mutation_prompt": null}
{"id": "db684ee6-5e78-48a0-8e74-26cc52ba0575", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.5 + np.random.rand() * 0.5):  # Slightly adjusted adaptive F factor\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):  # Fine-tuned crossover rate for diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def guided_search(self):\n        direction = np.random.uniform(-1.0, 1.0, self.dim)\n        guide = np.clip(self.population[self.global_best] + 0.2 * direction, self.lower_bound, self.upper_bound)\n        return guide\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.25:  # Increased chance to use guided search\n                    trial = self.guided_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridAdaptiveDifferentialEvolution", "description": "Hybrid Adaptive Differential Evolution with Guided Search for Enhanced Convergence.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6905ab66-7276-4172-aaad-3b408416ed77", "metadata": {"aucs": [0.8701120635139404, 0.8677838411045177, 0.8553302640436486, 0.8733341512636563, 0.8779275801594602, 0.8631257866302713, 0.8768535626281874, 0.8677920876265968, 0.8745723664812668, 0.6595920228782264, 0.6835244373074782, 0.6771432469747519, 0.5885939892527814, 0.6500063246291172, 0.637541438764744, 0.5355020431785278, 0.6576012898629728, 0.4739339404799814, 0.1766257854104939, 0.10028573675548524, 0.12157331102853719, 0.08382027605649434, 0.08736015662264851, 0.09727617971343483, 0.14699846353833035, 0.17395620930083477, 0.15869527710112963, 0.11573224286924433, 0.06609510172629618, 0.06211531884926591, 0.1151007098130673, 0.05081337059789859, 0.06961335752171705, 0.1454000247934888, 0.05913495880103237, 0.09910510946658446, 0.9762664461035179, 0.9456784922827046, 0.9793781979481453, 0.9737302682524571, 0.9743730062816319, 0.8956591209749616, 0.9560751543888608, 0.9837523071675339, 0.9381568826315719, 0.6343903767325434, 0.6652541313116588, 0.5815541914700436, 0.5915947257897334, 0.6207550141118101, 0.6010284333792573, 0.6501852663388421, 0.6350573970945292, 0.61735095354645, 0.23113109568059176, 0.13666395020588606, 0.17235615181934993, 0.8909442839484986, 0.1932229192154643, 0.28145953684729574, 0.8896776323368549, 0.13195658238297525, 0.8851251132279552, 0.4373355360636696, 0.246670377557622, 0.16342113675888026, 0.24713264139351754, 0.333201950342789, 0.3554319358683201, 0.3789192466040944, 0.13396501965669627, 0.2506594487593681, 0.6372645569296719, 0.2500535182452711, 0.22587939895638864, 0.2886155752921583, 0.3697927368948857, 0.3345062485472007, 0.2231327605997271, 0.1867546245242776, 0.20128331562067292, 0.09223080293511887, 0.40145076181582817, 0.4340203378458417, 0.04112565784914202, 0.14413113519443432, 0.33415690103013407, 0.28404754681104893, 0.1061064923952697, 0.44569726681161914, 0.6448790344246242, 0.21207275021879246, 0.39312612218022736, 0.555865775219667, 0.5740633845944019, 0.3776663937812458, 0.37130742319742693, 0.3473503525461963, 0.4696775215665582, 0.10439943868874746, 0.19687228204100038, 0.13502214820522151, 0.4100004206015776, 0.30863199698441846, 0.38069126538467757, 0.09880809622958131, 0.17524945942708803, 0.3291931622366149, 0.35283391007612097, 0.3656723136185146, 0.3202237806761682, 0.3807632054166503, 0.39634346457131975, 0.3274224563710523, 0.3320481684075276, 0.3400113473820877, 0.30362557895604847, 0.7966505104010551, 0.7833815565390648, 0.7659486387412797, 0.7915048952663282, 0.7759103364949282, 0.7642355845615405, 0.7950657862143864, 0.7646844850765779, 0.7716234504827703, 0.11070055559590619, 0.03235280942984298, 0.11318312575853817, 0.06307174289090256, 0.08683993244120392, 0.0888833841262473, 0.1476179481028077, 0.11045803313967573, 0.0876487268157593, 0.7145016840737239, 0.668679375544815, 0.23931408049921687, 0.6759353362736633, 0.6991011433132335, 0.6878359708507803, 0.6529416975550209, 0.3425192162463705, 0.28943843876440156, 0.13755514311225947, 0.4776164605080053, 0.47873669098326677, 0.26829649936740896, 0.22897523881996285, 0.4933833615037666, 0.2595755483114631, 0.5063242498344667, 0.5023299144358919, 0.35124946002079693, 0.41208479426050637, 0.3273184912328032, 0.18271188552281648, 0.22315355245922186, 0.2531297204559564, 0.41479987855001665, 0.4257431029140837, 0.43500043657189336, 0.2144204750634603, 0.22322588838869528, 0.2054721836566108, 0.29542659872444577, 0.23351960470971223, 0.21547015926491864, 0.2174750077990768, 0.19755524027722626, 0.20492120446023177, 0.20665755372682415, 0.19415217985118216, 0.1977675933555555, 0.22621327331595376, 0.7663038669571772, 0.21067334801237148, 0.18919674573262923, 0.22524859550613296, 0.1976550946667266, 0.1489058033199765, 0.12744266758109934, 0.15489775725077493, 0.952895986727425, 0.2021347793261229, 0.20162982595770318, 0.9299467173578883, 0.1705555319760741, 0.15461874087948602, 0.9231883531430638, 0.21458593496014966, 0.15547715846481547, 0.10495735851719312, 0.8553265601044483, 0.15322300668595268, 0.10524334936645396, 0.10513119764023071, 0.8112679329762931, 0.18162439927446716, 0.17874172357951779, 0.17864688368682857, 0.18546069789458697, 0.1885834418915815, 0.1888070244557758, 0.19358441257526082, 0.18294376031376125, 0.19278293622534415, 0.08640863447931735, 0.08223537952501592, 0.08924267659980212, 0.08681471855377565, 0.07111902872067344, 0.106209568221868, 0.0853346261487371, 0.08175374900890098, 0.1058597689604569]}, "mutation_prompt": null}
{"id": "37bdfb28-b061-4dc8-aec5-ccd3761779dd", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.5 + np.random.rand() * 0.5):  # Slightly adjusted adaptive F factor\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):  # Fine-tuned crossover rate for diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def guided_search(self):\n        direction = np.random.uniform(-1.0, 1.0, self.dim)\n        guide = np.clip(self.population[self.global_best] + 0.2 * direction, self.lower_bound, self.upper_bound)\n        return guide\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.25:  # Increased chance to use guided search\n                    trial = self.guided_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridAdaptiveDifferentialEvolution", "description": "Hybrid Adaptive Differential Evolution with Guided Search for Enhanced Convergence.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6905ab66-7276-4172-aaad-3b408416ed77", "metadata": {"aucs": [0.8701120635139404, 0.8677838411045177, 0.8553302640436486, 0.8733341512636563, 0.8779275801594602, 0.8631257866302713, 0.8768535626281874, 0.8677920876265968, 0.8745723664812668, 0.6595920228782264, 0.6835244373074782, 0.6771432469747519, 0.5885939892527814, 0.6500063246291172, 0.637541438764744, 0.5355020431785278, 0.6576012898629728, 0.4739339404799814, 0.1766257854104939, 0.10028573675548524, 0.12157331102853719, 0.08382027605649434, 0.08736015662264851, 0.09727617971343483, 0.14699846353833035, 0.17395620930083477, 0.15869527710112963, 0.11573224286924433, 0.06609510172629618, 0.06211531884926591, 0.1151007098130673, 0.05081337059789859, 0.06961335752171705, 0.1454000247934888, 0.05913495880103237, 0.09910510946658446, 0.9762664461035179, 0.9456784922827046, 0.9793781979481453, 0.9737302682524571, 0.9743730062816319, 0.8956591209749616, 0.9560751543888608, 0.9837523071675339, 0.9381568826315719, 0.6343903767325434, 0.6652541313116588, 0.5815541914700436, 0.5915947257897334, 0.6207550141118101, 0.6010284333792573, 0.6501852663388421, 0.6350573970945292, 0.61735095354645, 0.23113109568059176, 0.13666395020588606, 0.17235615181934993, 0.8909442839484986, 0.1932229192154643, 0.28145953684729574, 0.8896776323368549, 0.13195658238297525, 0.8851251132279552, 0.4373355360636696, 0.246670377557622, 0.16342113675888026, 0.24713264139351754, 0.333201950342789, 0.3554319358683201, 0.3789192466040944, 0.13396501965669627, 0.2506594487593681, 0.6372645569296719, 0.2500535182452711, 0.22587939895638864, 0.2886155752921583, 0.3697927368948857, 0.3345062485472007, 0.2231327605997271, 0.1867546245242776, 0.20128331562067292, 0.09223080293511887, 0.40145076181582817, 0.4340203378458417, 0.04112565784914202, 0.14413113519443432, 0.33415690103013407, 0.28404754681104893, 0.1061064923952697, 0.44569726681161914, 0.6448790344246242, 0.21207275021879246, 0.39312612218022736, 0.555865775219667, 0.5740633845944019, 0.3776663937812458, 0.37130742319742693, 0.3473503525461963, 0.4696775215665582, 0.10439943868874746, 0.19687228204100038, 0.13502214820522151, 0.4100004206015776, 0.30863199698441846, 0.38069126538467757, 0.09880809622958131, 0.17524945942708803, 0.3291931622366149, 0.35283391007612097, 0.3656723136185146, 0.3202237806761682, 0.3807632054166503, 0.39634346457131975, 0.3274224563710523, 0.3320481684075276, 0.3400113473820877, 0.30362557895604847, 0.7966505104010551, 0.7833815565390648, 0.7659486387412797, 0.7915048952663282, 0.7759103364949282, 0.7642355845615405, 0.7950657862143864, 0.7646844850765779, 0.7716234504827703, 0.11070055559590619, 0.03235280942984298, 0.11318312575853817, 0.06307174289090256, 0.08683993244120392, 0.0888833841262473, 0.1476179481028077, 0.11045803313967573, 0.0876487268157593, 0.7145016840737239, 0.668679375544815, 0.23931408049921687, 0.6759353362736633, 0.6991011433132335, 0.6878359708507803, 0.6529416975550209, 0.3425192162463705, 0.28943843876440156, 0.13755514311225947, 0.4776164605080053, 0.47873669098326677, 0.26829649936740896, 0.22897523881996285, 0.4933833615037666, 0.2595755483114631, 0.5063242498344667, 0.5023299144358919, 0.35124946002079693, 0.41208479426050637, 0.3273184912328032, 0.18271188552281648, 0.22315355245922186, 0.2531297204559564, 0.41479987855001665, 0.4257431029140837, 0.43500043657189336, 0.2144204750634603, 0.22322588838869528, 0.2054721836566108, 0.29542659872444577, 0.23351960470971223, 0.21547015926491864, 0.2174750077990768, 0.19755524027722626, 0.20492120446023177, 0.20665755372682415, 0.19415217985118216, 0.1977675933555555, 0.22621327331595376, 0.7663038669571772, 0.21067334801237148, 0.18919674573262923, 0.22524859550613296, 0.1976550946667266, 0.1489058033199765, 0.12744266758109934, 0.15489775725077493, 0.952895986727425, 0.2021347793261229, 0.20162982595770318, 0.9299467173578883, 0.1705555319760741, 0.15461874087948602, 0.9231883531430638, 0.21458593496014966, 0.15547715846481547, 0.10495735851719312, 0.8553265601044483, 0.15322300668595268, 0.10524334936645396, 0.10513119764023071, 0.8112679329762931, 0.18162439927446716, 0.17874172357951779, 0.17864688368682857, 0.18546069789458697, 0.1885834418915815, 0.1888070244557758, 0.19358441257526082, 0.18294376031376125, 0.19278293622534415, 0.08640863447931735, 0.08223537952501592, 0.08924267659980212, 0.08681471855377565, 0.07111902872067344, 0.106209568221868, 0.0853346261487371, 0.08175374900890098, 0.1058597689604569]}, "mutation_prompt": null}
{"id": "0237c66e-10d6-41b5-9476-a7b13527ed2b", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.5 + np.random.rand() * 0.5):  # Slightly adjusted adaptive F factor\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):  # Fine-tuned crossover rate for diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def guided_search(self):\n        direction = np.random.uniform(-1.0, 1.0, self.dim)\n        guide = np.clip(self.population[self.global_best] + 0.2 * direction, self.lower_bound, self.upper_bound)\n        return guide\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.25:  # Increased chance to use guided search\n                    trial = self.guided_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridAdaptiveDifferentialEvolution", "description": "Hybrid Adaptive Differential Evolution with Guided Search for Enhanced Convergence.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6905ab66-7276-4172-aaad-3b408416ed77", "metadata": {"aucs": [0.8701120635139404, 0.8677838411045177, 0.8553302640436486, 0.8733341512636563, 0.8779275801594602, 0.8631257866302713, 0.8768535626281874, 0.8677920876265968, 0.8745723664812668, 0.6595920228782264, 0.6835244373074782, 0.6771432469747519, 0.5885939892527814, 0.6500063246291172, 0.637541438764744, 0.5355020431785278, 0.6576012898629728, 0.4739339404799814, 0.1766257854104939, 0.10028573675548524, 0.12157331102853719, 0.08382027605649434, 0.08736015662264851, 0.09727617971343483, 0.14699846353833035, 0.17395620930083477, 0.15869527710112963, 0.11573224286924433, 0.06609510172629618, 0.06211531884926591, 0.1151007098130673, 0.05081337059789859, 0.06961335752171705, 0.1454000247934888, 0.05913495880103237, 0.09910510946658446, 0.9762664461035179, 0.9456784922827046, 0.9793781979481453, 0.9737302682524571, 0.9743730062816319, 0.8956591209749616, 0.9560751543888608, 0.9837523071675339, 0.9381568826315719, 0.6343903767325434, 0.6652541313116588, 0.5815541914700436, 0.5915947257897334, 0.6207550141118101, 0.6010284333792573, 0.6501852663388421, 0.6350573970945292, 0.61735095354645, 0.23113109568059176, 0.13666395020588606, 0.17235615181934993, 0.8909442839484986, 0.1932229192154643, 0.28145953684729574, 0.8896776323368549, 0.13195658238297525, 0.8851251132279552, 0.4373355360636696, 0.246670377557622, 0.16342113675888026, 0.24713264139351754, 0.333201950342789, 0.3554319358683201, 0.3789192466040944, 0.13396501965669627, 0.2506594487593681, 0.6372645569296719, 0.2500535182452711, 0.22587939895638864, 0.2886155752921583, 0.3697927368948857, 0.3345062485472007, 0.2231327605997271, 0.1867546245242776, 0.20128331562067292, 0.09223080293511887, 0.40145076181582817, 0.4340203378458417, 0.04112565784914202, 0.14413113519443432, 0.33415690103013407, 0.28404754681104893, 0.1061064923952697, 0.44569726681161914, 0.6448790344246242, 0.21207275021879246, 0.39312612218022736, 0.555865775219667, 0.5740633845944019, 0.3776663937812458, 0.37130742319742693, 0.3473503525461963, 0.4696775215665582, 0.10439943868874746, 0.19687228204100038, 0.13502214820522151, 0.4100004206015776, 0.30863199698441846, 0.38069126538467757, 0.09880809622958131, 0.17524945942708803, 0.3291931622366149, 0.35283391007612097, 0.3656723136185146, 0.3202237806761682, 0.3807632054166503, 0.39634346457131975, 0.3274224563710523, 0.3320481684075276, 0.3400113473820877, 0.30362557895604847, 0.7966505104010551, 0.7833815565390648, 0.7659486387412797, 0.7915048952663282, 0.7759103364949282, 0.7642355845615405, 0.7950657862143864, 0.7646844850765779, 0.7716234504827703, 0.11070055559590619, 0.03235280942984298, 0.11318312575853817, 0.06307174289090256, 0.08683993244120392, 0.0888833841262473, 0.1476179481028077, 0.11045803313967573, 0.0876487268157593, 0.7145016840737239, 0.668679375544815, 0.23931408049921687, 0.6759353362736633, 0.6991011433132335, 0.6878359708507803, 0.6529416975550209, 0.3425192162463705, 0.28943843876440156, 0.13755514311225947, 0.4776164605080053, 0.47873669098326677, 0.26829649936740896, 0.22897523881996285, 0.4933833615037666, 0.2595755483114631, 0.5063242498344667, 0.5023299144358919, 0.35124946002079693, 0.41208479426050637, 0.3273184912328032, 0.18271188552281648, 0.22315355245922186, 0.2531297204559564, 0.41479987855001665, 0.4257431029140837, 0.43500043657189336, 0.2144204750634603, 0.22322588838869528, 0.2054721836566108, 0.29542659872444577, 0.23351960470971223, 0.21547015926491864, 0.2174750077990768, 0.19755524027722626, 0.20492120446023177, 0.20665755372682415, 0.19415217985118216, 0.1977675933555555, 0.22621327331595376, 0.7663038669571772, 0.21067334801237148, 0.18919674573262923, 0.22524859550613296, 0.1976550946667266, 0.1489058033199765, 0.12744266758109934, 0.15489775725077493, 0.952895986727425, 0.2021347793261229, 0.20162982595770318, 0.9299467173578883, 0.1705555319760741, 0.15461874087948602, 0.9231883531430638, 0.21458593496014966, 0.15547715846481547, 0.10495735851719312, 0.8553265601044483, 0.15322300668595268, 0.10524334936645396, 0.10513119764023071, 0.8112679329762931, 0.18162439927446716, 0.17874172357951779, 0.17864688368682857, 0.18546069789458697, 0.1885834418915815, 0.1888070244557758, 0.19358441257526082, 0.18294376031376125, 0.19278293622534415, 0.08640863447931735, 0.08223537952501592, 0.08924267659980212, 0.08681471855377565, 0.07111902872067344, 0.106209568221868, 0.0853346261487371, 0.08175374900890098, 0.1058597689604569]}, "mutation_prompt": null}
{"id": "5bec3094-fe5b-4427-86f0-582587c9636f", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n        self.scaling_factor = 0.5 + np.random.rand() * 0.6  # Adaptive scaling factor\n        self.dynamic_pop_size = self.pop_size\n\n    def evaluate_population(self, func):\n        for i in range(self.dynamic_pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.dynamic_pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c):\n        mutant = np.clip(a + self.scaling_factor * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.8):  # Adjusted crossover rate\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def guided_search(self):\n        direction = np.random.uniform(-1.0, 1.0, self.dim)\n        guide = np.clip(self.population[self.global_best] + 0.15 * direction, self.lower_bound, self.upper_bound)\n        return guide\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.dynamic_pop_size):\n                if np.random.rand() < 0.3:  # Increased guided search probability\n                    trial = self.guided_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n            self.dynamic_pop_size = max(int(self.pop_size * (1.0 - 0.1 * (self.eval_count / self.budget))), 4)  # Dynamic population reduction\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "EnhancedHybridAdaptiveDifferentialEvolution", "description": "Enhanced Hybrid Adaptive Differential Evolution using Adaptive Scaling and Dynamic Population for Improved Convergence.", "configspace": "", "generation": 86, "fitness": 0.30003980912374756, "feedback": "The algorithm EnhancedHybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "6905ab66-7276-4172-aaad-3b408416ed77", "metadata": {"aucs": [0.8397786973052435, 0.6631801702223099, 0.8006172159319944, 0.84148639862412, 0.6382076180924494, 0.787058604046067, 0.8211984538360545, 0.6544726548159454, 0.7955342036857187, 0.6103881017521564, 0.25446049089667166, 0.3619734769817141, 0.5060819737995002, 0.20667877774821575, 0.4289846031645015, 0.5499836095872664, 0.28532329572119386, 0.4105759874873831, 0.10136727157269088, 0.15496646805407255, 0.05148959219903004, 0.1236021728012916, 0.05544799376622578, 0.06589443861872701, 0.09671548034572863, 0.14672936497429268, 0.06600787410383524, 0.07146210602027692, 0.07009099886726877, 0.05531066432739007, 0.08360478573391406, 0.10023096486927574, 0.09212761689710791, 0.11304564729683497, 0.08631248886213194, 0.09616072640761997, 0.9590740129106052, 0.9785540592541556, 0.9705328966498166, 0.9803483488093838, 0.9910985315417462, 0.9731303769896088, 0.9614355932702005, 0.9768100356867135, 0.9859978882613128, 0.49100547088960556, 0.38337846287771016, 0.41729190851731446, 0.48888126543093546, 0.3730888378306104, 0.44334734403152365, 0.47904929454454015, 0.3848810290143996, 0.47394123482100714, 0.8083191703679197, 0.7465363915792977, 0.21912320648489791, 0.22348089674258997, 0.45404442379314935, 0.4824317488391934, 0.17652536518486628, 0.16955836125994106, 0.1504552553060532, 0.47569007849002287, 0.12150904322664646, 0.27520959946994217, 0.12700925588348766, 0.2345110373223963, 0.2990484565093592, 0.30285631586545014, 0.2370108761312839, 0.28279179483923444, 0.25168927325298396, 0.17665770661129954, 0.12986565065915623, 0.3465218954142909, 0.24548470362327068, 0.2732803831204036, 0.38958475652376523, 0.21496155725927912, 0.21036008130081352, 0.1489719022736392, 0.08797408622940583, 0.15174894715116427, 0.1393525689499575, 0.1076490672169319, 0.13935218485652423, 0.24175445272071083, 0.09481611869632267, 0.14208789396005483, 0.32725603565916195, 0.1892578105992999, 0.2799598643698987, 0.31014497108859373, 0.246295439073969, 0.214849611593262, 0.26103872378496873, 0.2091645164073379, 0.27567555735141214, 0.13863071085080136, 0.021040408613232975, 0.06755371475377503, 0.11822397169859322, 0.03258757502993681, 0.07674780776036727, 0.07540851867350462, 0.019877944756849675, 0.07764945644262022, 0.2321566341168555, 0.1282375060698716, 0.166162206066366, 0.23402247660527686, 0.15764808745992143, 0.22729033757911288, 0.22237005366328244, 0.15969532646711704, 0.17467639965031556, 0.6258970618169221, 0.4958453987535897, 0.5651316282717618, 0.5796587922101554, 0.491704032018616, 0.5634846156879645, 0.6152494210841003, 0.5003006753758437, 0.548264053448829, 0.11837616545414498, 0.06359087527698504, 0.053043981520926486, 0.11111194221398868, 0.08052421486881955, 0.08778686151980963, 0.07232243194834609, 0.11535641796799789, 0.07606569457415757, 0.21222191303334725, 0.18817675792111355, 0.22167149357309623, 0.4736253500082027, 0.3546017367456291, 0.20972511445040842, 0.5065208428709991, 0.19023332945822435, 0.13923025883143803, 0.3730300576089769, 0.309451148062002, 0.204162300940669, 0.23138713981781234, 0.2085119946267503, 0.3021443320002358, 0.2794919799596446, 0.33714788011212105, 0.2161990524962767, 0.161397949226052, 0.16364087831335328, 0.2740159239478386, 0.30894768998973443, 0.19609379933635251, 0.2836296897194084, 0.29878547711638836, 0.27226213576749525, 0.29675157047362233, 0.1991437903181672, 0.16560470423094298, 0.19941061030281615, 0.22901602215437322, 0.20829060645016573, 0.1948204489138855, 0.19230785375583448, 0.20196337502138584, 0.2332263412666512, 0.20525497974465556, 0.19219576891731016, 0.20639685231505234, 0.2572444804999431, 0.2195988432873004, 0.19826187160591124, 0.22183752998411632, 0.2439627133345491, 0.2452602024877052, 0.18907949293150728, 0.12729599518548151, 0.15481117796818256, 0.9474887994447733, 0.2020574149150801, 0.12328405580271506, 0.14341299945067298, 0.17017394284089693, 0.14301415851853438, 0.8938269135443161, 0.21292349846435654, 0.15576391613451346, 0.8562408361217932, 0.6915440499816796, 0.15593442763241783, 0.10522916432381768, 0.7775774814975451, 0.809010981603288, 0.1848514124360362, 0.1864739558033347, 0.1915338431099718, 0.18243379638096224, 0.18017461849269545, 0.19602765299560354, 0.17107857624090905, 0.1913601875346177, 0.18599334330070438, 0.09268249239625526, 0.07896766843511072, 0.082417655204853, 0.08240028644192732, 0.07608636151386816, 0.08885543062416823, 0.10289900658102102, 0.07244919885606105, 0.0924311689600692]}, "mutation_prompt": null}
{"id": "163f8a8e-8ce7-49f5-934d-37e36385ae33", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = pop_size if pop_size is not None else 10 * dim\n        self.dynamic_pop_size = self.initial_pop_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.dynamic_pop_size, dim))\n        self.fitness = np.full(self.dynamic_pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.dynamic_pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.dynamic_pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.5 + np.random.rand() * 0.3):  # Slightly more adaptive F factor\n        noise = np.random.normal(0, 0.1, self.dim)  # Adding noise for robustness\n        mutant = np.clip(a + F * (b - c) + noise, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.85):  # Adjusted crossover rate\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def guided_search(self):\n        direction = np.random.uniform(-1.0, 1.0, self.dim)\n        guide = np.clip(self.population[self.global_best] + 0.15 * direction, self.lower_bound, self.upper_bound)\n        return guide\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.dynamic_pop_size):\n                if np.random.rand() < 0.3:  # Increased chance to use guided search\n                    trial = self.guided_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n            # Dynamic population adjustment\n            if self.eval_count % 50 == 0 and self.dynamic_pop_size > 20:\n                self.dynamic_pop_size = max(20, int(self.dynamic_pop_size * 0.95))\n                self.population = self.population[:self.dynamic_pop_size]\n                self.fitness = self.fitness[:self.dynamic_pop_size]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "EnhancedHybridAdaptiveDifferentialEvolution", "description": "Enhanced Hybrid Adaptive Differential Evolution with Noise-Resilient Mutation and Dynamic Population Sizing for Improved Convergence.", "configspace": "", "generation": 87, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 49 is out of bounds for axis 0 with size 47').", "error": "IndexError('index 49 is out of bounds for axis 0 with size 47')", "parent_id": "6905ab66-7276-4172-aaad-3b408416ed77", "metadata": {}, "mutation_prompt": null}
{"id": "fd27e7e6-c1c0-4018-963f-65a7ec26c4f4", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.5 + np.random.rand() * 0.5):  # Slightly adjusted adaptive F factor\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):  # Fine-tuned crossover rate for diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def guided_search(self):\n        direction = np.random.uniform(-1.0, 1.0, self.dim)\n        guide = np.clip(self.population[self.global_best] + 0.2 * direction, self.lower_bound, self.upper_bound)\n        return guide\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.25:  # Increased chance to use guided search\n                    trial = self.guided_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridAdaptiveDifferentialEvolution", "description": "Hybrid Adaptive Differential Evolution with Guided Search for Enhanced Convergence.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6905ab66-7276-4172-aaad-3b408416ed77", "metadata": {"aucs": [0.8701120635139404, 0.8677838411045177, 0.8553302640436486, 0.8733341512636563, 0.8779275801594602, 0.8631257866302713, 0.8768535626281874, 0.8677920876265968, 0.8745723664812668, 0.6595920228782264, 0.6835244373074782, 0.6771432469747519, 0.5885939892527814, 0.6500063246291172, 0.637541438764744, 0.5355020431785278, 0.6576012898629728, 0.4739339404799814, 0.1766257854104939, 0.10028573675548524, 0.12157331102853719, 0.08382027605649434, 0.08736015662264851, 0.09727617971343483, 0.14699846353833035, 0.17395620930083477, 0.15869527710112963, 0.11573224286924433, 0.06609510172629618, 0.06211531884926591, 0.1151007098130673, 0.05081337059789859, 0.06961335752171705, 0.1454000247934888, 0.05913495880103237, 0.09910510946658446, 0.9762664461035179, 0.9456784922827046, 0.9793781979481453, 0.9737302682524571, 0.9743730062816319, 0.8956591209749616, 0.9560751543888608, 0.9837523071675339, 0.9381568826315719, 0.6343903767325434, 0.6652541313116588, 0.5815541914700436, 0.5915947257897334, 0.6207550141118101, 0.6010284333792573, 0.6501852663388421, 0.6350573970945292, 0.61735095354645, 0.23113109568059176, 0.13666395020588606, 0.17235615181934993, 0.8909442839484986, 0.1932229192154643, 0.28145953684729574, 0.8896776323368549, 0.13195658238297525, 0.8851251132279552, 0.4373355360636696, 0.246670377557622, 0.16342113675888026, 0.24713264139351754, 0.333201950342789, 0.3554319358683201, 0.3789192466040944, 0.13396501965669627, 0.2506594487593681, 0.6372645569296719, 0.2500535182452711, 0.22587939895638864, 0.2886155752921583, 0.3697927368948857, 0.3345062485472007, 0.2231327605997271, 0.1867546245242776, 0.20128331562067292, 0.09223080293511887, 0.40145076181582817, 0.4340203378458417, 0.04112565784914202, 0.14413113519443432, 0.33415690103013407, 0.28404754681104893, 0.1061064923952697, 0.44569726681161914, 0.6448790344246242, 0.21207275021879246, 0.39312612218022736, 0.555865775219667, 0.5740633845944019, 0.3776663937812458, 0.37130742319742693, 0.3473503525461963, 0.4696775215665582, 0.10439943868874746, 0.19687228204100038, 0.13502214820522151, 0.4100004206015776, 0.30863199698441846, 0.38069126538467757, 0.09880809622958131, 0.17524945942708803, 0.3291931622366149, 0.35283391007612097, 0.3656723136185146, 0.3202237806761682, 0.3807632054166503, 0.39634346457131975, 0.3274224563710523, 0.3320481684075276, 0.3400113473820877, 0.30362557895604847, 0.7966505104010551, 0.7833815565390648, 0.7659486387412797, 0.7915048952663282, 0.7759103364949282, 0.7642355845615405, 0.7950657862143864, 0.7646844850765779, 0.7716234504827703, 0.11070055559590619, 0.03235280942984298, 0.11318312575853817, 0.06307174289090256, 0.08683993244120392, 0.0888833841262473, 0.1476179481028077, 0.11045803313967573, 0.0876487268157593, 0.7145016840737239, 0.668679375544815, 0.23931408049921687, 0.6759353362736633, 0.6991011433132335, 0.6878359708507803, 0.6529416975550209, 0.3425192162463705, 0.28943843876440156, 0.13755514311225947, 0.4776164605080053, 0.47873669098326677, 0.26829649936740896, 0.22897523881996285, 0.4933833615037666, 0.2595755483114631, 0.5063242498344667, 0.5023299144358919, 0.35124946002079693, 0.41208479426050637, 0.3273184912328032, 0.18271188552281648, 0.22315355245922186, 0.2531297204559564, 0.41479987855001665, 0.4257431029140837, 0.43500043657189336, 0.2144204750634603, 0.22322588838869528, 0.2054721836566108, 0.29542659872444577, 0.23351960470971223, 0.21547015926491864, 0.2174750077990768, 0.19755524027722626, 0.20492120446023177, 0.20665755372682415, 0.19415217985118216, 0.1977675933555555, 0.22621327331595376, 0.7663038669571772, 0.21067334801237148, 0.18919674573262923, 0.22524859550613296, 0.1976550946667266, 0.1489058033199765, 0.12744266758109934, 0.15489775725077493, 0.952895986727425, 0.2021347793261229, 0.20162982595770318, 0.9299467173578883, 0.1705555319760741, 0.15461874087948602, 0.9231883531430638, 0.21458593496014966, 0.15547715846481547, 0.10495735851719312, 0.8553265601044483, 0.15322300668595268, 0.10524334936645396, 0.10513119764023071, 0.8112679329762931, 0.18162439927446716, 0.17874172357951779, 0.17864688368682857, 0.18546069789458697, 0.1885834418915815, 0.1888070244557758, 0.19358441257526082, 0.18294376031376125, 0.19278293622534415, 0.08640863447931735, 0.08223537952501592, 0.08924267659980212, 0.08681471855377565, 0.07111902872067344, 0.106209568221868, 0.0853346261487371, 0.08175374900890098, 0.1058597689604569]}, "mutation_prompt": null}
{"id": "4a130a1e-7b7e-46a1-8e21-9a9ec1a50549", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.5 + np.random.rand() * 0.5):  # Slightly adjusted adaptive F factor\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):  # Fine-tuned crossover rate for diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def guided_search(self):\n        direction = np.random.uniform(-1.0, 1.0, self.dim)\n        guide = np.clip(self.population[self.global_best] + 0.2 * direction, self.lower_bound, self.upper_bound)\n        return guide\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.25:  # Increased chance to use guided search\n                    trial = self.guided_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridAdaptiveDifferentialEvolution", "description": "Hybrid Adaptive Differential Evolution with Guided Search for Enhanced Convergence.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6905ab66-7276-4172-aaad-3b408416ed77", "metadata": {"aucs": [0.8701120635139404, 0.8677838411045177, 0.8553302640436486, 0.8733341512636563, 0.8779275801594602, 0.8631257866302713, 0.8768535626281874, 0.8677920876265968, 0.8745723664812668, 0.6595920228782264, 0.6835244373074782, 0.6771432469747519, 0.5885939892527814, 0.6500063246291172, 0.637541438764744, 0.5355020431785278, 0.6576012898629728, 0.4739339404799814, 0.1766257854104939, 0.10028573675548524, 0.12157331102853719, 0.08382027605649434, 0.08736015662264851, 0.09727617971343483, 0.14699846353833035, 0.17395620930083477, 0.15869527710112963, 0.11573224286924433, 0.06609510172629618, 0.06211531884926591, 0.1151007098130673, 0.05081337059789859, 0.06961335752171705, 0.1454000247934888, 0.05913495880103237, 0.09910510946658446, 0.9762664461035179, 0.9456784922827046, 0.9793781979481453, 0.9737302682524571, 0.9743730062816319, 0.8956591209749616, 0.9560751543888608, 0.9837523071675339, 0.9381568826315719, 0.6343903767325434, 0.6652541313116588, 0.5815541914700436, 0.5915947257897334, 0.6207550141118101, 0.6010284333792573, 0.6501852663388421, 0.6350573970945292, 0.61735095354645, 0.23113109568059176, 0.13666395020588606, 0.17235615181934993, 0.8909442839484986, 0.1932229192154643, 0.28145953684729574, 0.8896776323368549, 0.13195658238297525, 0.8851251132279552, 0.4373355360636696, 0.246670377557622, 0.16342113675888026, 0.24713264139351754, 0.333201950342789, 0.3554319358683201, 0.3789192466040944, 0.13396501965669627, 0.2506594487593681, 0.6372645569296719, 0.2500535182452711, 0.22587939895638864, 0.2886155752921583, 0.3697927368948857, 0.3345062485472007, 0.2231327605997271, 0.1867546245242776, 0.20128331562067292, 0.09223080293511887, 0.40145076181582817, 0.4340203378458417, 0.04112565784914202, 0.14413113519443432, 0.33415690103013407, 0.28404754681104893, 0.1061064923952697, 0.44569726681161914, 0.6448790344246242, 0.21207275021879246, 0.39312612218022736, 0.555865775219667, 0.5740633845944019, 0.3776663937812458, 0.37130742319742693, 0.3473503525461963, 0.4696775215665582, 0.10439943868874746, 0.19687228204100038, 0.13502214820522151, 0.4100004206015776, 0.30863199698441846, 0.38069126538467757, 0.09880809622958131, 0.17524945942708803, 0.3291931622366149, 0.35283391007612097, 0.3656723136185146, 0.3202237806761682, 0.3807632054166503, 0.39634346457131975, 0.3274224563710523, 0.3320481684075276, 0.3400113473820877, 0.30362557895604847, 0.7966505104010551, 0.7833815565390648, 0.7659486387412797, 0.7915048952663282, 0.7759103364949282, 0.7642355845615405, 0.7950657862143864, 0.7646844850765779, 0.7716234504827703, 0.11070055559590619, 0.03235280942984298, 0.11318312575853817, 0.06307174289090256, 0.08683993244120392, 0.0888833841262473, 0.1476179481028077, 0.11045803313967573, 0.0876487268157593, 0.7145016840737239, 0.668679375544815, 0.23931408049921687, 0.6759353362736633, 0.6991011433132335, 0.6878359708507803, 0.6529416975550209, 0.3425192162463705, 0.28943843876440156, 0.13755514311225947, 0.4776164605080053, 0.47873669098326677, 0.26829649936740896, 0.22897523881996285, 0.4933833615037666, 0.2595755483114631, 0.5063242498344667, 0.5023299144358919, 0.35124946002079693, 0.41208479426050637, 0.3273184912328032, 0.18271188552281648, 0.22315355245922186, 0.2531297204559564, 0.41479987855001665, 0.4257431029140837, 0.43500043657189336, 0.2144204750634603, 0.22322588838869528, 0.2054721836566108, 0.29542659872444577, 0.23351960470971223, 0.21547015926491864, 0.2174750077990768, 0.19755524027722626, 0.20492120446023177, 0.20665755372682415, 0.19415217985118216, 0.1977675933555555, 0.22621327331595376, 0.7663038669571772, 0.21067334801237148, 0.18919674573262923, 0.22524859550613296, 0.1976550946667266, 0.1489058033199765, 0.12744266758109934, 0.15489775725077493, 0.952895986727425, 0.2021347793261229, 0.20162982595770318, 0.9299467173578883, 0.1705555319760741, 0.15461874087948602, 0.9231883531430638, 0.21458593496014966, 0.15547715846481547, 0.10495735851719312, 0.8553265601044483, 0.15322300668595268, 0.10524334936645396, 0.10513119764023071, 0.8112679329762931, 0.18162439927446716, 0.17874172357951779, 0.17864688368682857, 0.18546069789458697, 0.1885834418915815, 0.1888070244557758, 0.19358441257526082, 0.18294376031376125, 0.19278293622534415, 0.08640863447931735, 0.08223537952501592, 0.08924267659980212, 0.08681471855377565, 0.07111902872067344, 0.106209568221868, 0.0853346261487371, 0.08175374900890098, 0.1058597689604569]}, "mutation_prompt": null}
{"id": "84618017-9226-4b70-81ec-495d8a916cb7", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.5 + np.random.rand() * 0.5):  # Slightly adjusted adaptive F factor\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):  # Fine-tuned crossover rate for diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def guided_search(self):\n        direction = np.random.uniform(-1.0, 1.0, self.dim)\n        guide = np.clip(self.population[self.global_best] + 0.2 * direction, self.lower_bound, self.upper_bound)\n        return guide\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.25:  # Increased chance to use guided search\n                    trial = self.guided_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridAdaptiveDifferentialEvolution", "description": "Hybrid Adaptive Differential Evolution with Guided Search for Enhanced Convergence.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6905ab66-7276-4172-aaad-3b408416ed77", "metadata": {"aucs": [0.8701120635139404, 0.8677838411045177, 0.8553302640436486, 0.8733341512636563, 0.8779275801594602, 0.8631257866302713, 0.8768535626281874, 0.8677920876265968, 0.8745723664812668, 0.6595920228782264, 0.6835244373074782, 0.6771432469747519, 0.5885939892527814, 0.6500063246291172, 0.637541438764744, 0.5355020431785278, 0.6576012898629728, 0.4739339404799814, 0.1766257854104939, 0.10028573675548524, 0.12157331102853719, 0.08382027605649434, 0.08736015662264851, 0.09727617971343483, 0.14699846353833035, 0.17395620930083477, 0.15869527710112963, 0.11573224286924433, 0.06609510172629618, 0.06211531884926591, 0.1151007098130673, 0.05081337059789859, 0.06961335752171705, 0.1454000247934888, 0.05913495880103237, 0.09910510946658446, 0.9762664461035179, 0.9456784922827046, 0.9793781979481453, 0.9737302682524571, 0.9743730062816319, 0.8956591209749616, 0.9560751543888608, 0.9837523071675339, 0.9381568826315719, 0.6343903767325434, 0.6652541313116588, 0.5815541914700436, 0.5915947257897334, 0.6207550141118101, 0.6010284333792573, 0.6501852663388421, 0.6350573970945292, 0.61735095354645, 0.23113109568059176, 0.13666395020588606, 0.17235615181934993, 0.8909442839484986, 0.1932229192154643, 0.28145953684729574, 0.8896776323368549, 0.13195658238297525, 0.8851251132279552, 0.4373355360636696, 0.246670377557622, 0.16342113675888026, 0.24713264139351754, 0.333201950342789, 0.3554319358683201, 0.3789192466040944, 0.13396501965669627, 0.2506594487593681, 0.6372645569296719, 0.2500535182452711, 0.22587939895638864, 0.2886155752921583, 0.3697927368948857, 0.3345062485472007, 0.2231327605997271, 0.1867546245242776, 0.20128331562067292, 0.09223080293511887, 0.40145076181582817, 0.4340203378458417, 0.04112565784914202, 0.14413113519443432, 0.33415690103013407, 0.28404754681104893, 0.1061064923952697, 0.44569726681161914, 0.6448790344246242, 0.21207275021879246, 0.39312612218022736, 0.555865775219667, 0.5740633845944019, 0.3776663937812458, 0.37130742319742693, 0.3473503525461963, 0.4696775215665582, 0.10439943868874746, 0.19687228204100038, 0.13502214820522151, 0.4100004206015776, 0.30863199698441846, 0.38069126538467757, 0.09880809622958131, 0.17524945942708803, 0.3291931622366149, 0.35283391007612097, 0.3656723136185146, 0.3202237806761682, 0.3807632054166503, 0.39634346457131975, 0.3274224563710523, 0.3320481684075276, 0.3400113473820877, 0.30362557895604847, 0.7966505104010551, 0.7833815565390648, 0.7659486387412797, 0.7915048952663282, 0.7759103364949282, 0.7642355845615405, 0.7950657862143864, 0.7646844850765779, 0.7716234504827703, 0.11070055559590619, 0.03235280942984298, 0.11318312575853817, 0.06307174289090256, 0.08683993244120392, 0.0888833841262473, 0.1476179481028077, 0.11045803313967573, 0.0876487268157593, 0.7145016840737239, 0.668679375544815, 0.23931408049921687, 0.6759353362736633, 0.6991011433132335, 0.6878359708507803, 0.6529416975550209, 0.3425192162463705, 0.28943843876440156, 0.13755514311225947, 0.4776164605080053, 0.47873669098326677, 0.26829649936740896, 0.22897523881996285, 0.4933833615037666, 0.2595755483114631, 0.5063242498344667, 0.5023299144358919, 0.35124946002079693, 0.41208479426050637, 0.3273184912328032, 0.18271188552281648, 0.22315355245922186, 0.2531297204559564, 0.41479987855001665, 0.4257431029140837, 0.43500043657189336, 0.2144204750634603, 0.22322588838869528, 0.2054721836566108, 0.29542659872444577, 0.23351960470971223, 0.21547015926491864, 0.2174750077990768, 0.19755524027722626, 0.20492120446023177, 0.20665755372682415, 0.19415217985118216, 0.1977675933555555, 0.22621327331595376, 0.7663038669571772, 0.21067334801237148, 0.18919674573262923, 0.22524859550613296, 0.1976550946667266, 0.1489058033199765, 0.12744266758109934, 0.15489775725077493, 0.952895986727425, 0.2021347793261229, 0.20162982595770318, 0.9299467173578883, 0.1705555319760741, 0.15461874087948602, 0.9231883531430638, 0.21458593496014966, 0.15547715846481547, 0.10495735851719312, 0.8553265601044483, 0.15322300668595268, 0.10524334936645396, 0.10513119764023071, 0.8112679329762931, 0.18162439927446716, 0.17874172357951779, 0.17864688368682857, 0.18546069789458697, 0.1885834418915815, 0.1888070244557758, 0.19358441257526082, 0.18294376031376125, 0.19278293622534415, 0.08640863447931735, 0.08223537952501592, 0.08924267659980212, 0.08681471855377565, 0.07111902872067344, 0.106209568221868, 0.0853346261487371, 0.08175374900890098, 0.1058597689604569]}, "mutation_prompt": null}
{"id": "162d9e9d-3cae-4d6c-9134-821cd922ac71", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.5 + np.random.rand() * 0.5):  # Slightly adjusted adaptive F factor\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):  # Fine-tuned crossover rate for diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def guided_search(self):\n        direction = np.random.uniform(-1.0, 1.0, self.dim)\n        guide = np.clip(self.population[self.global_best] + 0.2 * direction, self.lower_bound, self.upper_bound)\n        return guide\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.25:  # Increased chance to use guided search\n                    trial = self.guided_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridAdaptiveDifferentialEvolution", "description": "Hybrid Adaptive Differential Evolution with Guided Search for Enhanced Convergence.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6905ab66-7276-4172-aaad-3b408416ed77", "metadata": {"aucs": [0.8701120635139404, 0.8677838411045177, 0.8553302640436486, 0.8733341512636563, 0.8779275801594602, 0.8631257866302713, 0.8768535626281874, 0.8677920876265968, 0.8745723664812668, 0.6595920228782264, 0.6835244373074782, 0.6771432469747519, 0.5885939892527814, 0.6500063246291172, 0.637541438764744, 0.5355020431785278, 0.6576012898629728, 0.4739339404799814, 0.1766257854104939, 0.10028573675548524, 0.12157331102853719, 0.08382027605649434, 0.08736015662264851, 0.09727617971343483, 0.14699846353833035, 0.17395620930083477, 0.15869527710112963, 0.11573224286924433, 0.06609510172629618, 0.06211531884926591, 0.1151007098130673, 0.05081337059789859, 0.06961335752171705, 0.1454000247934888, 0.05913495880103237, 0.09910510946658446, 0.9762664461035179, 0.9456784922827046, 0.9793781979481453, 0.9737302682524571, 0.9743730062816319, 0.8956591209749616, 0.9560751543888608, 0.9837523071675339, 0.9381568826315719, 0.6343903767325434, 0.6652541313116588, 0.5815541914700436, 0.5915947257897334, 0.6207550141118101, 0.6010284333792573, 0.6501852663388421, 0.6350573970945292, 0.61735095354645, 0.23113109568059176, 0.13666395020588606, 0.17235615181934993, 0.8909442839484986, 0.1932229192154643, 0.28145953684729574, 0.8896776323368549, 0.13195658238297525, 0.8851251132279552, 0.4373355360636696, 0.246670377557622, 0.16342113675888026, 0.24713264139351754, 0.333201950342789, 0.3554319358683201, 0.3789192466040944, 0.13396501965669627, 0.2506594487593681, 0.6372645569296719, 0.2500535182452711, 0.22587939895638864, 0.2886155752921583, 0.3697927368948857, 0.3345062485472007, 0.2231327605997271, 0.1867546245242776, 0.20128331562067292, 0.09223080293511887, 0.40145076181582817, 0.4340203378458417, 0.04112565784914202, 0.14413113519443432, 0.33415690103013407, 0.28404754681104893, 0.1061064923952697, 0.44569726681161914, 0.6448790344246242, 0.21207275021879246, 0.39312612218022736, 0.555865775219667, 0.5740633845944019, 0.3776663937812458, 0.37130742319742693, 0.3473503525461963, 0.4696775215665582, 0.10439943868874746, 0.19687228204100038, 0.13502214820522151, 0.4100004206015776, 0.30863199698441846, 0.38069126538467757, 0.09880809622958131, 0.17524945942708803, 0.3291931622366149, 0.35283391007612097, 0.3656723136185146, 0.3202237806761682, 0.3807632054166503, 0.39634346457131975, 0.3274224563710523, 0.3320481684075276, 0.3400113473820877, 0.30362557895604847, 0.7966505104010551, 0.7833815565390648, 0.7659486387412797, 0.7915048952663282, 0.7759103364949282, 0.7642355845615405, 0.7950657862143864, 0.7646844850765779, 0.7716234504827703, 0.11070055559590619, 0.03235280942984298, 0.11318312575853817, 0.06307174289090256, 0.08683993244120392, 0.0888833841262473, 0.1476179481028077, 0.11045803313967573, 0.0876487268157593, 0.7145016840737239, 0.668679375544815, 0.23931408049921687, 0.6759353362736633, 0.6991011433132335, 0.6878359708507803, 0.6529416975550209, 0.3425192162463705, 0.28943843876440156, 0.13755514311225947, 0.4776164605080053, 0.47873669098326677, 0.26829649936740896, 0.22897523881996285, 0.4933833615037666, 0.2595755483114631, 0.5063242498344667, 0.5023299144358919, 0.35124946002079693, 0.41208479426050637, 0.3273184912328032, 0.18271188552281648, 0.22315355245922186, 0.2531297204559564, 0.41479987855001665, 0.4257431029140837, 0.43500043657189336, 0.2144204750634603, 0.22322588838869528, 0.2054721836566108, 0.29542659872444577, 0.23351960470971223, 0.21547015926491864, 0.2174750077990768, 0.19755524027722626, 0.20492120446023177, 0.20665755372682415, 0.19415217985118216, 0.1977675933555555, 0.22621327331595376, 0.7663038669571772, 0.21067334801237148, 0.18919674573262923, 0.22524859550613296, 0.1976550946667266, 0.1489058033199765, 0.12744266758109934, 0.15489775725077493, 0.952895986727425, 0.2021347793261229, 0.20162982595770318, 0.9299467173578883, 0.1705555319760741, 0.15461874087948602, 0.9231883531430638, 0.21458593496014966, 0.15547715846481547, 0.10495735851719312, 0.8553265601044483, 0.15322300668595268, 0.10524334936645396, 0.10513119764023071, 0.8112679329762931, 0.18162439927446716, 0.17874172357951779, 0.17864688368682857, 0.18546069789458697, 0.1885834418915815, 0.1888070244557758, 0.19358441257526082, 0.18294376031376125, 0.19278293622534415, 0.08640863447931735, 0.08223537952501592, 0.08924267659980212, 0.08681471855377565, 0.07111902872067344, 0.106209568221868, 0.0853346261487371, 0.08175374900890098, 0.1058597689604569]}, "mutation_prompt": null}
{"id": "a03c41f5-501d-4e2f-9400-f2b80d330965", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.5 + np.random.rand() * 0.5):  # Slightly adjusted adaptive F factor\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):  # Fine-tuned crossover rate for diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def guided_search(self):\n        direction = np.random.uniform(-1.0, 1.0, self.dim)\n        guide = np.clip(self.population[self.global_best] + 0.2 * direction, self.lower_bound, self.upper_bound)\n        return guide\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.25:  # Increased chance to use guided search\n                    trial = self.guided_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridAdaptiveDifferentialEvolution", "description": "Hybrid Adaptive Differential Evolution with Guided Search for Enhanced Convergence.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6905ab66-7276-4172-aaad-3b408416ed77", "metadata": {"aucs": [0.8701120635139404, 0.8677838411045177, 0.8553302640436486, 0.8733341512636563, 0.8779275801594602, 0.8631257866302713, 0.8768535626281874, 0.8677920876265968, 0.8745723664812668, 0.6595920228782264, 0.6835244373074782, 0.6771432469747519, 0.5885939892527814, 0.6500063246291172, 0.637541438764744, 0.5355020431785278, 0.6576012898629728, 0.4739339404799814, 0.1766257854104939, 0.10028573675548524, 0.12157331102853719, 0.08382027605649434, 0.08736015662264851, 0.09727617971343483, 0.14699846353833035, 0.17395620930083477, 0.15869527710112963, 0.11573224286924433, 0.06609510172629618, 0.06211531884926591, 0.1151007098130673, 0.05081337059789859, 0.06961335752171705, 0.1454000247934888, 0.05913495880103237, 0.09910510946658446, 0.9762664461035179, 0.9456784922827046, 0.9793781979481453, 0.9737302682524571, 0.9743730062816319, 0.8956591209749616, 0.9560751543888608, 0.9837523071675339, 0.9381568826315719, 0.6343903767325434, 0.6652541313116588, 0.5815541914700436, 0.5915947257897334, 0.6207550141118101, 0.6010284333792573, 0.6501852663388421, 0.6350573970945292, 0.61735095354645, 0.23113109568059176, 0.13666395020588606, 0.17235615181934993, 0.8909442839484986, 0.1932229192154643, 0.28145953684729574, 0.8896776323368549, 0.13195658238297525, 0.8851251132279552, 0.4373355360636696, 0.246670377557622, 0.16342113675888026, 0.24713264139351754, 0.333201950342789, 0.3554319358683201, 0.3789192466040944, 0.13396501965669627, 0.2506594487593681, 0.6372645569296719, 0.2500535182452711, 0.22587939895638864, 0.2886155752921583, 0.3697927368948857, 0.3345062485472007, 0.2231327605997271, 0.1867546245242776, 0.20128331562067292, 0.09223080293511887, 0.40145076181582817, 0.4340203378458417, 0.04112565784914202, 0.14413113519443432, 0.33415690103013407, 0.28404754681104893, 0.1061064923952697, 0.44569726681161914, 0.6448790344246242, 0.21207275021879246, 0.39312612218022736, 0.555865775219667, 0.5740633845944019, 0.3776663937812458, 0.37130742319742693, 0.3473503525461963, 0.4696775215665582, 0.10439943868874746, 0.19687228204100038, 0.13502214820522151, 0.4100004206015776, 0.30863199698441846, 0.38069126538467757, 0.09880809622958131, 0.17524945942708803, 0.3291931622366149, 0.35283391007612097, 0.3656723136185146, 0.3202237806761682, 0.3807632054166503, 0.39634346457131975, 0.3274224563710523, 0.3320481684075276, 0.3400113473820877, 0.30362557895604847, 0.7966505104010551, 0.7833815565390648, 0.7659486387412797, 0.7915048952663282, 0.7759103364949282, 0.7642355845615405, 0.7950657862143864, 0.7646844850765779, 0.7716234504827703, 0.11070055559590619, 0.03235280942984298, 0.11318312575853817, 0.06307174289090256, 0.08683993244120392, 0.0888833841262473, 0.1476179481028077, 0.11045803313967573, 0.0876487268157593, 0.7145016840737239, 0.668679375544815, 0.23931408049921687, 0.6759353362736633, 0.6991011433132335, 0.6878359708507803, 0.6529416975550209, 0.3425192162463705, 0.28943843876440156, 0.13755514311225947, 0.4776164605080053, 0.47873669098326677, 0.26829649936740896, 0.22897523881996285, 0.4933833615037666, 0.2595755483114631, 0.5063242498344667, 0.5023299144358919, 0.35124946002079693, 0.41208479426050637, 0.3273184912328032, 0.18271188552281648, 0.22315355245922186, 0.2531297204559564, 0.41479987855001665, 0.4257431029140837, 0.43500043657189336, 0.2144204750634603, 0.22322588838869528, 0.2054721836566108, 0.29542659872444577, 0.23351960470971223, 0.21547015926491864, 0.2174750077990768, 0.19755524027722626, 0.20492120446023177, 0.20665755372682415, 0.19415217985118216, 0.1977675933555555, 0.22621327331595376, 0.7663038669571772, 0.21067334801237148, 0.18919674573262923, 0.22524859550613296, 0.1976550946667266, 0.1489058033199765, 0.12744266758109934, 0.15489775725077493, 0.952895986727425, 0.2021347793261229, 0.20162982595770318, 0.9299467173578883, 0.1705555319760741, 0.15461874087948602, 0.9231883531430638, 0.21458593496014966, 0.15547715846481547, 0.10495735851719312, 0.8553265601044483, 0.15322300668595268, 0.10524334936645396, 0.10513119764023071, 0.8112679329762931, 0.18162439927446716, 0.17874172357951779, 0.17864688368682857, 0.18546069789458697, 0.1885834418915815, 0.1888070244557758, 0.19358441257526082, 0.18294376031376125, 0.19278293622534415, 0.08640863447931735, 0.08223537952501592, 0.08924267659980212, 0.08681471855377565, 0.07111902872067344, 0.106209568221868, 0.0853346261487371, 0.08175374900890098, 0.1058597689604569]}, "mutation_prompt": null}
{"id": "1ca909a9-d03d-4dd7-99a4-f08102cd5d9e", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolutionV2:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = pop_size if pop_size is not None else 8 * dim\n        self.pop_size = self.initial_pop_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.4 + np.random.rand() * 0.6):  # Slightly more adaptive F factor\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.85):  # Adjusted crossover rate for balance\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def guided_search(self):\n        direction = np.random.uniform(-0.5, 0.5, self.dim)\n        guide = np.clip(self.population[self.global_best] + 0.3 * direction, self.lower_bound, self.upper_bound)\n        return guide\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def dynamic_population_control(self):\n        # Decrease population size dynamically for faster convergence\n        if self.eval_count * 2 >= self.budget:\n            new_pop_size = max(4, self.pop_size // 2)\n            if new_pop_size < self.pop_size:\n                self.population = self.population[:new_pop_size]\n                self.fitness = self.fitness[:new_pop_size]\n                self.pop_size = new_pop_size\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.3:  # Slightly increased chance to use guided search\n                    trial = self.guided_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n            self.dynamic_population_control()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridAdaptiveDifferentialEvolutionV2", "description": "Enhanced Hybrid Adaptive Differential Evolution with Dynamic Population Adjustment for Accelerated Convergence.", "configspace": "", "generation": 93, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 12 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 12 is out of bounds for axis 0 with size 10')", "parent_id": "6905ab66-7276-4172-aaad-3b408416ed77", "metadata": {}, "mutation_prompt": null}
{"id": "aa917f99-e128-499b-9594-c163ddb1566a", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.5 + np.random.rand() * 0.5):  # Slightly adjusted adaptive F factor\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):  # Fine-tuned crossover rate for diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def guided_search(self):\n        direction = np.random.uniform(-1.0, 1.0, self.dim)\n        guide = np.clip(self.population[self.global_best] + 0.2 * direction, self.lower_bound, self.upper_bound)\n        return guide\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.25:  # Increased chance to use guided search\n                    trial = self.guided_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridAdaptiveDifferentialEvolution", "description": "Hybrid Adaptive Differential Evolution with Guided Search for Enhanced Convergence.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6905ab66-7276-4172-aaad-3b408416ed77", "metadata": {"aucs": [0.8701120635139404, 0.8677838411045177, 0.8553302640436486, 0.8733341512636563, 0.8779275801594602, 0.8631257866302713, 0.8768535626281874, 0.8677920876265968, 0.8745723664812668, 0.6595920228782264, 0.6835244373074782, 0.6771432469747519, 0.5885939892527814, 0.6500063246291172, 0.637541438764744, 0.5355020431785278, 0.6576012898629728, 0.4739339404799814, 0.1766257854104939, 0.10028573675548524, 0.12157331102853719, 0.08382027605649434, 0.08736015662264851, 0.09727617971343483, 0.14699846353833035, 0.17395620930083477, 0.15869527710112963, 0.11573224286924433, 0.06609510172629618, 0.06211531884926591, 0.1151007098130673, 0.05081337059789859, 0.06961335752171705, 0.1454000247934888, 0.05913495880103237, 0.09910510946658446, 0.9762664461035179, 0.9456784922827046, 0.9793781979481453, 0.9737302682524571, 0.9743730062816319, 0.8956591209749616, 0.9560751543888608, 0.9837523071675339, 0.9381568826315719, 0.6343903767325434, 0.6652541313116588, 0.5815541914700436, 0.5915947257897334, 0.6207550141118101, 0.6010284333792573, 0.6501852663388421, 0.6350573970945292, 0.61735095354645, 0.23113109568059176, 0.13666395020588606, 0.17235615181934993, 0.8909442839484986, 0.1932229192154643, 0.28145953684729574, 0.8896776323368549, 0.13195658238297525, 0.8851251132279552, 0.4373355360636696, 0.246670377557622, 0.16342113675888026, 0.24713264139351754, 0.333201950342789, 0.3554319358683201, 0.3789192466040944, 0.13396501965669627, 0.2506594487593681, 0.6372645569296719, 0.2500535182452711, 0.22587939895638864, 0.2886155752921583, 0.3697927368948857, 0.3345062485472007, 0.2231327605997271, 0.1867546245242776, 0.20128331562067292, 0.09223080293511887, 0.40145076181582817, 0.4340203378458417, 0.04112565784914202, 0.14413113519443432, 0.33415690103013407, 0.28404754681104893, 0.1061064923952697, 0.44569726681161914, 0.6448790344246242, 0.21207275021879246, 0.39312612218022736, 0.555865775219667, 0.5740633845944019, 0.3776663937812458, 0.37130742319742693, 0.3473503525461963, 0.4696775215665582, 0.10439943868874746, 0.19687228204100038, 0.13502214820522151, 0.4100004206015776, 0.30863199698441846, 0.38069126538467757, 0.09880809622958131, 0.17524945942708803, 0.3291931622366149, 0.35283391007612097, 0.3656723136185146, 0.3202237806761682, 0.3807632054166503, 0.39634346457131975, 0.3274224563710523, 0.3320481684075276, 0.3400113473820877, 0.30362557895604847, 0.7966505104010551, 0.7833815565390648, 0.7659486387412797, 0.7915048952663282, 0.7759103364949282, 0.7642355845615405, 0.7950657862143864, 0.7646844850765779, 0.7716234504827703, 0.11070055559590619, 0.03235280942984298, 0.11318312575853817, 0.06307174289090256, 0.08683993244120392, 0.0888833841262473, 0.1476179481028077, 0.11045803313967573, 0.0876487268157593, 0.7145016840737239, 0.668679375544815, 0.23931408049921687, 0.6759353362736633, 0.6991011433132335, 0.6878359708507803, 0.6529416975550209, 0.3425192162463705, 0.28943843876440156, 0.13755514311225947, 0.4776164605080053, 0.47873669098326677, 0.26829649936740896, 0.22897523881996285, 0.4933833615037666, 0.2595755483114631, 0.5063242498344667, 0.5023299144358919, 0.35124946002079693, 0.41208479426050637, 0.3273184912328032, 0.18271188552281648, 0.22315355245922186, 0.2531297204559564, 0.41479987855001665, 0.4257431029140837, 0.43500043657189336, 0.2144204750634603, 0.22322588838869528, 0.2054721836566108, 0.29542659872444577, 0.23351960470971223, 0.21547015926491864, 0.2174750077990768, 0.19755524027722626, 0.20492120446023177, 0.20665755372682415, 0.19415217985118216, 0.1977675933555555, 0.22621327331595376, 0.7663038669571772, 0.21067334801237148, 0.18919674573262923, 0.22524859550613296, 0.1976550946667266, 0.1489058033199765, 0.12744266758109934, 0.15489775725077493, 0.952895986727425, 0.2021347793261229, 0.20162982595770318, 0.9299467173578883, 0.1705555319760741, 0.15461874087948602, 0.9231883531430638, 0.21458593496014966, 0.15547715846481547, 0.10495735851719312, 0.8553265601044483, 0.15322300668595268, 0.10524334936645396, 0.10513119764023071, 0.8112679329762931, 0.18162439927446716, 0.17874172357951779, 0.17864688368682857, 0.18546069789458697, 0.1885834418915815, 0.1888070244557758, 0.19358441257526082, 0.18294376031376125, 0.19278293622534415, 0.08640863447931735, 0.08223537952501592, 0.08924267659980212, 0.08681471855377565, 0.07111902872067344, 0.106209568221868, 0.0853346261487371, 0.08175374900890098, 0.1058597689604569]}, "mutation_prompt": null}
{"id": "98727a42-e9d6-47b5-b7a4-b326306d276f", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.5 + np.random.rand() * 0.5):  # Slightly adjusted adaptive F factor\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):  # Fine-tuned crossover rate for diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def guided_search(self):\n        direction = np.random.uniform(-1.0, 1.0, self.dim)\n        guide = np.clip(self.population[self.global_best] + 0.2 * direction, self.lower_bound, self.upper_bound)\n        return guide\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.25:  # Increased chance to use guided search\n                    trial = self.guided_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridAdaptiveDifferentialEvolution", "description": "Hybrid Adaptive Differential Evolution with Guided Search for Enhanced Convergence.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6905ab66-7276-4172-aaad-3b408416ed77", "metadata": {"aucs": [0.8701120635139404, 0.8677838411045177, 0.8553302640436486, 0.8733341512636563, 0.8779275801594602, 0.8631257866302713, 0.8768535626281874, 0.8677920876265968, 0.8745723664812668, 0.6595920228782264, 0.6835244373074782, 0.6771432469747519, 0.5885939892527814, 0.6500063246291172, 0.637541438764744, 0.5355020431785278, 0.6576012898629728, 0.4739339404799814, 0.1766257854104939, 0.10028573675548524, 0.12157331102853719, 0.08382027605649434, 0.08736015662264851, 0.09727617971343483, 0.14699846353833035, 0.17395620930083477, 0.15869527710112963, 0.11573224286924433, 0.06609510172629618, 0.06211531884926591, 0.1151007098130673, 0.05081337059789859, 0.06961335752171705, 0.1454000247934888, 0.05913495880103237, 0.09910510946658446, 0.9762664461035179, 0.9456784922827046, 0.9793781979481453, 0.9737302682524571, 0.9743730062816319, 0.8956591209749616, 0.9560751543888608, 0.9837523071675339, 0.9381568826315719, 0.6343903767325434, 0.6652541313116588, 0.5815541914700436, 0.5915947257897334, 0.6207550141118101, 0.6010284333792573, 0.6501852663388421, 0.6350573970945292, 0.61735095354645, 0.23113109568059176, 0.13666395020588606, 0.17235615181934993, 0.8909442839484986, 0.1932229192154643, 0.28145953684729574, 0.8896776323368549, 0.13195658238297525, 0.8851251132279552, 0.4373355360636696, 0.246670377557622, 0.16342113675888026, 0.24713264139351754, 0.333201950342789, 0.3554319358683201, 0.3789192466040944, 0.13396501965669627, 0.2506594487593681, 0.6372645569296719, 0.2500535182452711, 0.22587939895638864, 0.2886155752921583, 0.3697927368948857, 0.3345062485472007, 0.2231327605997271, 0.1867546245242776, 0.20128331562067292, 0.09223080293511887, 0.40145076181582817, 0.4340203378458417, 0.04112565784914202, 0.14413113519443432, 0.33415690103013407, 0.28404754681104893, 0.1061064923952697, 0.44569726681161914, 0.6448790344246242, 0.21207275021879246, 0.39312612218022736, 0.555865775219667, 0.5740633845944019, 0.3776663937812458, 0.37130742319742693, 0.3473503525461963, 0.4696775215665582, 0.10439943868874746, 0.19687228204100038, 0.13502214820522151, 0.4100004206015776, 0.30863199698441846, 0.38069126538467757, 0.09880809622958131, 0.17524945942708803, 0.3291931622366149, 0.35283391007612097, 0.3656723136185146, 0.3202237806761682, 0.3807632054166503, 0.39634346457131975, 0.3274224563710523, 0.3320481684075276, 0.3400113473820877, 0.30362557895604847, 0.7966505104010551, 0.7833815565390648, 0.7659486387412797, 0.7915048952663282, 0.7759103364949282, 0.7642355845615405, 0.7950657862143864, 0.7646844850765779, 0.7716234504827703, 0.11070055559590619, 0.03235280942984298, 0.11318312575853817, 0.06307174289090256, 0.08683993244120392, 0.0888833841262473, 0.1476179481028077, 0.11045803313967573, 0.0876487268157593, 0.7145016840737239, 0.668679375544815, 0.23931408049921687, 0.6759353362736633, 0.6991011433132335, 0.6878359708507803, 0.6529416975550209, 0.3425192162463705, 0.28943843876440156, 0.13755514311225947, 0.4776164605080053, 0.47873669098326677, 0.26829649936740896, 0.22897523881996285, 0.4933833615037666, 0.2595755483114631, 0.5063242498344667, 0.5023299144358919, 0.35124946002079693, 0.41208479426050637, 0.3273184912328032, 0.18271188552281648, 0.22315355245922186, 0.2531297204559564, 0.41479987855001665, 0.4257431029140837, 0.43500043657189336, 0.2144204750634603, 0.22322588838869528, 0.2054721836566108, 0.29542659872444577, 0.23351960470971223, 0.21547015926491864, 0.2174750077990768, 0.19755524027722626, 0.20492120446023177, 0.20665755372682415, 0.19415217985118216, 0.1977675933555555, 0.22621327331595376, 0.7663038669571772, 0.21067334801237148, 0.18919674573262923, 0.22524859550613296, 0.1976550946667266, 0.1489058033199765, 0.12744266758109934, 0.15489775725077493, 0.952895986727425, 0.2021347793261229, 0.20162982595770318, 0.9299467173578883, 0.1705555319760741, 0.15461874087948602, 0.9231883531430638, 0.21458593496014966, 0.15547715846481547, 0.10495735851719312, 0.8553265601044483, 0.15322300668595268, 0.10524334936645396, 0.10513119764023071, 0.8112679329762931, 0.18162439927446716, 0.17874172357951779, 0.17864688368682857, 0.18546069789458697, 0.1885834418915815, 0.1888070244557758, 0.19358441257526082, 0.18294376031376125, 0.19278293622534415, 0.08640863447931735, 0.08223537952501592, 0.08924267659980212, 0.08681471855377565, 0.07111902872067344, 0.106209568221868, 0.0853346261487371, 0.08175374900890098, 0.1058597689604569]}, "mutation_prompt": null}
{"id": "0833c916-0e53-4958-b2cd-f13dd2f33b45", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.5 + np.random.rand() * 0.5):  # Slightly adjusted adaptive F factor\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):  # Fine-tuned crossover rate for diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def guided_search(self):\n        direction = np.random.uniform(-1.0, 1.0, self.dim)\n        guide = np.clip(self.population[self.global_best] + 0.2 * direction, self.lower_bound, self.upper_bound)\n        return guide\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.25:  # Increased chance to use guided search\n                    trial = self.guided_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridAdaptiveDifferentialEvolution", "description": "Hybrid Adaptive Differential Evolution with Guided Search for Enhanced Convergence.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6905ab66-7276-4172-aaad-3b408416ed77", "metadata": {"aucs": [0.8701120635139404, 0.8677838411045177, 0.8553302640436486, 0.8733341512636563, 0.8779275801594602, 0.8631257866302713, 0.8768535626281874, 0.8677920876265968, 0.8745723664812668, 0.6595920228782264, 0.6835244373074782, 0.6771432469747519, 0.5885939892527814, 0.6500063246291172, 0.637541438764744, 0.5355020431785278, 0.6576012898629728, 0.4739339404799814, 0.1766257854104939, 0.10028573675548524, 0.12157331102853719, 0.08382027605649434, 0.08736015662264851, 0.09727617971343483, 0.14699846353833035, 0.17395620930083477, 0.15869527710112963, 0.11573224286924433, 0.06609510172629618, 0.06211531884926591, 0.1151007098130673, 0.05081337059789859, 0.06961335752171705, 0.1454000247934888, 0.05913495880103237, 0.09910510946658446, 0.9762664461035179, 0.9456784922827046, 0.9793781979481453, 0.9737302682524571, 0.9743730062816319, 0.8956591209749616, 0.9560751543888608, 0.9837523071675339, 0.9381568826315719, 0.6343903767325434, 0.6652541313116588, 0.5815541914700436, 0.5915947257897334, 0.6207550141118101, 0.6010284333792573, 0.6501852663388421, 0.6350573970945292, 0.61735095354645, 0.23113109568059176, 0.13666395020588606, 0.17235615181934993, 0.8909442839484986, 0.1932229192154643, 0.28145953684729574, 0.8896776323368549, 0.13195658238297525, 0.8851251132279552, 0.4373355360636696, 0.246670377557622, 0.16342113675888026, 0.24713264139351754, 0.333201950342789, 0.3554319358683201, 0.3789192466040944, 0.13396501965669627, 0.2506594487593681, 0.6372645569296719, 0.2500535182452711, 0.22587939895638864, 0.2886155752921583, 0.3697927368948857, 0.3345062485472007, 0.2231327605997271, 0.1867546245242776, 0.20128331562067292, 0.09223080293511887, 0.40145076181582817, 0.4340203378458417, 0.04112565784914202, 0.14413113519443432, 0.33415690103013407, 0.28404754681104893, 0.1061064923952697, 0.44569726681161914, 0.6448790344246242, 0.21207275021879246, 0.39312612218022736, 0.555865775219667, 0.5740633845944019, 0.3776663937812458, 0.37130742319742693, 0.3473503525461963, 0.4696775215665582, 0.10439943868874746, 0.19687228204100038, 0.13502214820522151, 0.4100004206015776, 0.30863199698441846, 0.38069126538467757, 0.09880809622958131, 0.17524945942708803, 0.3291931622366149, 0.35283391007612097, 0.3656723136185146, 0.3202237806761682, 0.3807632054166503, 0.39634346457131975, 0.3274224563710523, 0.3320481684075276, 0.3400113473820877, 0.30362557895604847, 0.7966505104010551, 0.7833815565390648, 0.7659486387412797, 0.7915048952663282, 0.7759103364949282, 0.7642355845615405, 0.7950657862143864, 0.7646844850765779, 0.7716234504827703, 0.11070055559590619, 0.03235280942984298, 0.11318312575853817, 0.06307174289090256, 0.08683993244120392, 0.0888833841262473, 0.1476179481028077, 0.11045803313967573, 0.0876487268157593, 0.7145016840737239, 0.668679375544815, 0.23931408049921687, 0.6759353362736633, 0.6991011433132335, 0.6878359708507803, 0.6529416975550209, 0.3425192162463705, 0.28943843876440156, 0.13755514311225947, 0.4776164605080053, 0.47873669098326677, 0.26829649936740896, 0.22897523881996285, 0.4933833615037666, 0.2595755483114631, 0.5063242498344667, 0.5023299144358919, 0.35124946002079693, 0.41208479426050637, 0.3273184912328032, 0.18271188552281648, 0.22315355245922186, 0.2531297204559564, 0.41479987855001665, 0.4257431029140837, 0.43500043657189336, 0.2144204750634603, 0.22322588838869528, 0.2054721836566108, 0.29542659872444577, 0.23351960470971223, 0.21547015926491864, 0.2174750077990768, 0.19755524027722626, 0.20492120446023177, 0.20665755372682415, 0.19415217985118216, 0.1977675933555555, 0.22621327331595376, 0.7663038669571772, 0.21067334801237148, 0.18919674573262923, 0.22524859550613296, 0.1976550946667266, 0.1489058033199765, 0.12744266758109934, 0.15489775725077493, 0.952895986727425, 0.2021347793261229, 0.20162982595770318, 0.9299467173578883, 0.1705555319760741, 0.15461874087948602, 0.9231883531430638, 0.21458593496014966, 0.15547715846481547, 0.10495735851719312, 0.8553265601044483, 0.15322300668595268, 0.10524334936645396, 0.10513119764023071, 0.8112679329762931, 0.18162439927446716, 0.17874172357951779, 0.17864688368682857, 0.18546069789458697, 0.1885834418915815, 0.1888070244557758, 0.19358441257526082, 0.18294376031376125, 0.19278293622534415, 0.08640863447931735, 0.08223537952501592, 0.08924267659980212, 0.08681471855377565, 0.07111902872067344, 0.106209568221868, 0.0853346261487371, 0.08175374900890098, 0.1058597689604569]}, "mutation_prompt": null}
{"id": "bdc63d63-33b2-422f-8e47-6656a0d2fe2a", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.5 + np.random.rand() * 0.5):  # Slightly adjusted adaptive F factor\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):  # Fine-tuned crossover rate for diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def guided_search(self):\n        direction = np.random.uniform(-1.0, 1.0, self.dim)\n        guide = np.clip(self.population[self.global_best] + 0.2 * direction, self.lower_bound, self.upper_bound)\n        return guide\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.25:  # Increased chance to use guided search\n                    trial = self.guided_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridAdaptiveDifferentialEvolution", "description": "Hybrid Adaptive Differential Evolution with Guided Search for Enhanced Convergence.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6905ab66-7276-4172-aaad-3b408416ed77", "metadata": {"aucs": [0.8701120635139404, 0.8677838411045177, 0.8553302640436486, 0.8733341512636563, 0.8779275801594602, 0.8631257866302713, 0.8768535626281874, 0.8677920876265968, 0.8745723664812668, 0.6595920228782264, 0.6835244373074782, 0.6771432469747519, 0.5885939892527814, 0.6500063246291172, 0.637541438764744, 0.5355020431785278, 0.6576012898629728, 0.4739339404799814, 0.1766257854104939, 0.10028573675548524, 0.12157331102853719, 0.08382027605649434, 0.08736015662264851, 0.09727617971343483, 0.14699846353833035, 0.17395620930083477, 0.15869527710112963, 0.11573224286924433, 0.06609510172629618, 0.06211531884926591, 0.1151007098130673, 0.05081337059789859, 0.06961335752171705, 0.1454000247934888, 0.05913495880103237, 0.09910510946658446, 0.9762664461035179, 0.9456784922827046, 0.9793781979481453, 0.9737302682524571, 0.9743730062816319, 0.8956591209749616, 0.9560751543888608, 0.9837523071675339, 0.9381568826315719, 0.6343903767325434, 0.6652541313116588, 0.5815541914700436, 0.5915947257897334, 0.6207550141118101, 0.6010284333792573, 0.6501852663388421, 0.6350573970945292, 0.61735095354645, 0.23113109568059176, 0.13666395020588606, 0.17235615181934993, 0.8909442839484986, 0.1932229192154643, 0.28145953684729574, 0.8896776323368549, 0.13195658238297525, 0.8851251132279552, 0.4373355360636696, 0.246670377557622, 0.16342113675888026, 0.24713264139351754, 0.333201950342789, 0.3554319358683201, 0.3789192466040944, 0.13396501965669627, 0.2506594487593681, 0.6372645569296719, 0.2500535182452711, 0.22587939895638864, 0.2886155752921583, 0.3697927368948857, 0.3345062485472007, 0.2231327605997271, 0.1867546245242776, 0.20128331562067292, 0.09223080293511887, 0.40145076181582817, 0.4340203378458417, 0.04112565784914202, 0.14413113519443432, 0.33415690103013407, 0.28404754681104893, 0.1061064923952697, 0.44569726681161914, 0.6448790344246242, 0.21207275021879246, 0.39312612218022736, 0.555865775219667, 0.5740633845944019, 0.3776663937812458, 0.37130742319742693, 0.3473503525461963, 0.4696775215665582, 0.10439943868874746, 0.19687228204100038, 0.13502214820522151, 0.4100004206015776, 0.30863199698441846, 0.38069126538467757, 0.09880809622958131, 0.17524945942708803, 0.3291931622366149, 0.35283391007612097, 0.3656723136185146, 0.3202237806761682, 0.3807632054166503, 0.39634346457131975, 0.3274224563710523, 0.3320481684075276, 0.3400113473820877, 0.30362557895604847, 0.7966505104010551, 0.7833815565390648, 0.7659486387412797, 0.7915048952663282, 0.7759103364949282, 0.7642355845615405, 0.7950657862143864, 0.7646844850765779, 0.7716234504827703, 0.11070055559590619, 0.03235280942984298, 0.11318312575853817, 0.06307174289090256, 0.08683993244120392, 0.0888833841262473, 0.1476179481028077, 0.11045803313967573, 0.0876487268157593, 0.7145016840737239, 0.668679375544815, 0.23931408049921687, 0.6759353362736633, 0.6991011433132335, 0.6878359708507803, 0.6529416975550209, 0.3425192162463705, 0.28943843876440156, 0.13755514311225947, 0.4776164605080053, 0.47873669098326677, 0.26829649936740896, 0.22897523881996285, 0.4933833615037666, 0.2595755483114631, 0.5063242498344667, 0.5023299144358919, 0.35124946002079693, 0.41208479426050637, 0.3273184912328032, 0.18271188552281648, 0.22315355245922186, 0.2531297204559564, 0.41479987855001665, 0.4257431029140837, 0.43500043657189336, 0.2144204750634603, 0.22322588838869528, 0.2054721836566108, 0.29542659872444577, 0.23351960470971223, 0.21547015926491864, 0.2174750077990768, 0.19755524027722626, 0.20492120446023177, 0.20665755372682415, 0.19415217985118216, 0.1977675933555555, 0.22621327331595376, 0.7663038669571772, 0.21067334801237148, 0.18919674573262923, 0.22524859550613296, 0.1976550946667266, 0.1489058033199765, 0.12744266758109934, 0.15489775725077493, 0.952895986727425, 0.2021347793261229, 0.20162982595770318, 0.9299467173578883, 0.1705555319760741, 0.15461874087948602, 0.9231883531430638, 0.21458593496014966, 0.15547715846481547, 0.10495735851719312, 0.8553265601044483, 0.15322300668595268, 0.10524334936645396, 0.10513119764023071, 0.8112679329762931, 0.18162439927446716, 0.17874172357951779, 0.17864688368682857, 0.18546069789458697, 0.1885834418915815, 0.1888070244557758, 0.19358441257526082, 0.18294376031376125, 0.19278293622534415, 0.08640863447931735, 0.08223537952501592, 0.08924267659980212, 0.08681471855377565, 0.07111902872067344, 0.106209568221868, 0.0853346261487371, 0.08175374900890098, 0.1058597689604569]}, "mutation_prompt": null}
{"id": "7e2a543f-8319-4f25-b4dd-febb18e3a984", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.5 + np.random.rand() * 0.5):  # Slightly adjusted adaptive F factor\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):  # Fine-tuned crossover rate for diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def guided_search(self):\n        direction = np.random.uniform(-1.0, 1.0, self.dim)\n        guide = np.clip(self.population[self.global_best] + 0.2 * direction, self.lower_bound, self.upper_bound)\n        return guide\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.25:  # Increased chance to use guided search\n                    trial = self.guided_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridAdaptiveDifferentialEvolution", "description": "Hybrid Adaptive Differential Evolution with Guided Search for Enhanced Convergence.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6905ab66-7276-4172-aaad-3b408416ed77", "metadata": {"aucs": [0.8701120635139404, 0.8677838411045177, 0.8553302640436486, 0.8733341512636563, 0.8779275801594602, 0.8631257866302713, 0.8768535626281874, 0.8677920876265968, 0.8745723664812668, 0.6595920228782264, 0.6835244373074782, 0.6771432469747519, 0.5885939892527814, 0.6500063246291172, 0.637541438764744, 0.5355020431785278, 0.6576012898629728, 0.4739339404799814, 0.1766257854104939, 0.10028573675548524, 0.12157331102853719, 0.08382027605649434, 0.08736015662264851, 0.09727617971343483, 0.14699846353833035, 0.17395620930083477, 0.15869527710112963, 0.11573224286924433, 0.06609510172629618, 0.06211531884926591, 0.1151007098130673, 0.05081337059789859, 0.06961335752171705, 0.1454000247934888, 0.05913495880103237, 0.09910510946658446, 0.9762664461035179, 0.9456784922827046, 0.9793781979481453, 0.9737302682524571, 0.9743730062816319, 0.8956591209749616, 0.9560751543888608, 0.9837523071675339, 0.9381568826315719, 0.6343903767325434, 0.6652541313116588, 0.5815541914700436, 0.5915947257897334, 0.6207550141118101, 0.6010284333792573, 0.6501852663388421, 0.6350573970945292, 0.61735095354645, 0.23113109568059176, 0.13666395020588606, 0.17235615181934993, 0.8909442839484986, 0.1932229192154643, 0.28145953684729574, 0.8896776323368549, 0.13195658238297525, 0.8851251132279552, 0.4373355360636696, 0.246670377557622, 0.16342113675888026, 0.24713264139351754, 0.333201950342789, 0.3554319358683201, 0.3789192466040944, 0.13396501965669627, 0.2506594487593681, 0.6372645569296719, 0.2500535182452711, 0.22587939895638864, 0.2886155752921583, 0.3697927368948857, 0.3345062485472007, 0.2231327605997271, 0.1867546245242776, 0.20128331562067292, 0.09223080293511887, 0.40145076181582817, 0.4340203378458417, 0.04112565784914202, 0.14413113519443432, 0.33415690103013407, 0.28404754681104893, 0.1061064923952697, 0.44569726681161914, 0.6448790344246242, 0.21207275021879246, 0.39312612218022736, 0.555865775219667, 0.5740633845944019, 0.3776663937812458, 0.37130742319742693, 0.3473503525461963, 0.4696775215665582, 0.10439943868874746, 0.19687228204100038, 0.13502214820522151, 0.4100004206015776, 0.30863199698441846, 0.38069126538467757, 0.09880809622958131, 0.17524945942708803, 0.3291931622366149, 0.35283391007612097, 0.3656723136185146, 0.3202237806761682, 0.3807632054166503, 0.39634346457131975, 0.3274224563710523, 0.3320481684075276, 0.3400113473820877, 0.30362557895604847, 0.7966505104010551, 0.7833815565390648, 0.7659486387412797, 0.7915048952663282, 0.7759103364949282, 0.7642355845615405, 0.7950657862143864, 0.7646844850765779, 0.7716234504827703, 0.11070055559590619, 0.03235280942984298, 0.11318312575853817, 0.06307174289090256, 0.08683993244120392, 0.0888833841262473, 0.1476179481028077, 0.11045803313967573, 0.0876487268157593, 0.7145016840737239, 0.668679375544815, 0.23931408049921687, 0.6759353362736633, 0.6991011433132335, 0.6878359708507803, 0.6529416975550209, 0.3425192162463705, 0.28943843876440156, 0.13755514311225947, 0.4776164605080053, 0.47873669098326677, 0.26829649936740896, 0.22897523881996285, 0.4933833615037666, 0.2595755483114631, 0.5063242498344667, 0.5023299144358919, 0.35124946002079693, 0.41208479426050637, 0.3273184912328032, 0.18271188552281648, 0.22315355245922186, 0.2531297204559564, 0.41479987855001665, 0.4257431029140837, 0.43500043657189336, 0.2144204750634603, 0.22322588838869528, 0.2054721836566108, 0.29542659872444577, 0.23351960470971223, 0.21547015926491864, 0.2174750077990768, 0.19755524027722626, 0.20492120446023177, 0.20665755372682415, 0.19415217985118216, 0.1977675933555555, 0.22621327331595376, 0.7663038669571772, 0.21067334801237148, 0.18919674573262923, 0.22524859550613296, 0.1976550946667266, 0.1489058033199765, 0.12744266758109934, 0.15489775725077493, 0.952895986727425, 0.2021347793261229, 0.20162982595770318, 0.9299467173578883, 0.1705555319760741, 0.15461874087948602, 0.9231883531430638, 0.21458593496014966, 0.15547715846481547, 0.10495735851719312, 0.8553265601044483, 0.15322300668595268, 0.10524334936645396, 0.10513119764023071, 0.8112679329762931, 0.18162439927446716, 0.17874172357951779, 0.17864688368682857, 0.18546069789458697, 0.1885834418915815, 0.1888070244557758, 0.19358441257526082, 0.18294376031376125, 0.19278293622534415, 0.08640863447931735, 0.08223537952501592, 0.08924267659980212, 0.08681471855377565, 0.07111902872067344, 0.106209568221868, 0.0853346261487371, 0.08175374900890098, 0.1058597689604569]}, "mutation_prompt": null}
{"id": "0c7b93bb-771f-43b2-a852-fe0d1b62e4d8", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = pop_size if pop_size is not None else 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_count = 0\n        self.global_best = None\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                self.eval_count += 1\n                if self.global_best is None or self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n    def select_parents(self):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        return self.population[indices]\n\n    def mutate(self, a, b, c, F=0.5 + np.random.rand() * 0.5):  # Slightly adjusted adaptive F factor\n        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, CR=0.9):  # Fine-tuned crossover rate for diversity\n        crossover_mask = np.random.rand(self.dim) < CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def guided_search(self):\n        direction = np.random.uniform(-1.0, 1.0, self.dim)\n        guide = np.clip(self.population[self.global_best] + 0.2 * direction, self.lower_bound, self.upper_bound)\n        return guide\n\n    def competitive_selection(self, trial, trial_fitness, target_idx):\n        if trial_fitness < self.fitness[target_idx]:\n            return trial, trial_fitness\n        else:\n            return self.population[target_idx], self.fitness[target_idx]\n\n    def optimize(self, func):\n        self.evaluate_population(func)\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.25:  # Increased chance to use guided search\n                    trial = self.guided_search()\n                else:\n                    target = self.population[i]\n                    a, b, c = self.select_parents()\n                    mutant = self.mutate(a, b, c)\n                    trial = self.crossover(target, mutant)\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                self.population[i], self.fitness[i] = self.competitive_selection(trial, trial_fitness, i)\n\n                if self.fitness[i] < self.fitness[self.global_best]:\n                    self.global_best = i\n\n                if self.eval_count >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def __call__(self, func):\n        best_solution, best_fitness = self.optimize(func)\n        return best_solution, best_fitness", "name": "HybridAdaptiveDifferentialEvolution", "description": "Hybrid Adaptive Differential Evolution with Guided Search for Enhanced Convergence.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6905ab66-7276-4172-aaad-3b408416ed77", "metadata": {"aucs": [0.8701120635139404, 0.8677838411045177, 0.8553302640436486, 0.8733341512636563, 0.8779275801594602, 0.8631257866302713, 0.8768535626281874, 0.8677920876265968, 0.8745723664812668, 0.6595920228782264, 0.6835244373074782, 0.6771432469747519, 0.5885939892527814, 0.6500063246291172, 0.637541438764744, 0.5355020431785278, 0.6576012898629728, 0.4739339404799814, 0.1766257854104939, 0.10028573675548524, 0.12157331102853719, 0.08382027605649434, 0.08736015662264851, 0.09727617971343483, 0.14699846353833035, 0.17395620930083477, 0.15869527710112963, 0.11573224286924433, 0.06609510172629618, 0.06211531884926591, 0.1151007098130673, 0.05081337059789859, 0.06961335752171705, 0.1454000247934888, 0.05913495880103237, 0.09910510946658446, 0.9762664461035179, 0.9456784922827046, 0.9793781979481453, 0.9737302682524571, 0.9743730062816319, 0.8956591209749616, 0.9560751543888608, 0.9837523071675339, 0.9381568826315719, 0.6343903767325434, 0.6652541313116588, 0.5815541914700436, 0.5915947257897334, 0.6207550141118101, 0.6010284333792573, 0.6501852663388421, 0.6350573970945292, 0.61735095354645, 0.23113109568059176, 0.13666395020588606, 0.17235615181934993, 0.8909442839484986, 0.1932229192154643, 0.28145953684729574, 0.8896776323368549, 0.13195658238297525, 0.8851251132279552, 0.4373355360636696, 0.246670377557622, 0.16342113675888026, 0.24713264139351754, 0.333201950342789, 0.3554319358683201, 0.3789192466040944, 0.13396501965669627, 0.2506594487593681, 0.6372645569296719, 0.2500535182452711, 0.22587939895638864, 0.2886155752921583, 0.3697927368948857, 0.3345062485472007, 0.2231327605997271, 0.1867546245242776, 0.20128331562067292, 0.09223080293511887, 0.40145076181582817, 0.4340203378458417, 0.04112565784914202, 0.14413113519443432, 0.33415690103013407, 0.28404754681104893, 0.1061064923952697, 0.44569726681161914, 0.6448790344246242, 0.21207275021879246, 0.39312612218022736, 0.555865775219667, 0.5740633845944019, 0.3776663937812458, 0.37130742319742693, 0.3473503525461963, 0.4696775215665582, 0.10439943868874746, 0.19687228204100038, 0.13502214820522151, 0.4100004206015776, 0.30863199698441846, 0.38069126538467757, 0.09880809622958131, 0.17524945942708803, 0.3291931622366149, 0.35283391007612097, 0.3656723136185146, 0.3202237806761682, 0.3807632054166503, 0.39634346457131975, 0.3274224563710523, 0.3320481684075276, 0.3400113473820877, 0.30362557895604847, 0.7966505104010551, 0.7833815565390648, 0.7659486387412797, 0.7915048952663282, 0.7759103364949282, 0.7642355845615405, 0.7950657862143864, 0.7646844850765779, 0.7716234504827703, 0.11070055559590619, 0.03235280942984298, 0.11318312575853817, 0.06307174289090256, 0.08683993244120392, 0.0888833841262473, 0.1476179481028077, 0.11045803313967573, 0.0876487268157593, 0.7145016840737239, 0.668679375544815, 0.23931408049921687, 0.6759353362736633, 0.6991011433132335, 0.6878359708507803, 0.6529416975550209, 0.3425192162463705, 0.28943843876440156, 0.13755514311225947, 0.4776164605080053, 0.47873669098326677, 0.26829649936740896, 0.22897523881996285, 0.4933833615037666, 0.2595755483114631, 0.5063242498344667, 0.5023299144358919, 0.35124946002079693, 0.41208479426050637, 0.3273184912328032, 0.18271188552281648, 0.22315355245922186, 0.2531297204559564, 0.41479987855001665, 0.4257431029140837, 0.43500043657189336, 0.2144204750634603, 0.22322588838869528, 0.2054721836566108, 0.29542659872444577, 0.23351960470971223, 0.21547015926491864, 0.2174750077990768, 0.19755524027722626, 0.20492120446023177, 0.20665755372682415, 0.19415217985118216, 0.1977675933555555, 0.22621327331595376, 0.7663038669571772, 0.21067334801237148, 0.18919674573262923, 0.22524859550613296, 0.1976550946667266, 0.1489058033199765, 0.12744266758109934, 0.15489775725077493, 0.952895986727425, 0.2021347793261229, 0.20162982595770318, 0.9299467173578883, 0.1705555319760741, 0.15461874087948602, 0.9231883531430638, 0.21458593496014966, 0.15547715846481547, 0.10495735851719312, 0.8553265601044483, 0.15322300668595268, 0.10524334936645396, 0.10513119764023071, 0.8112679329762931, 0.18162439927446716, 0.17874172357951779, 0.17864688368682857, 0.18546069789458697, 0.1885834418915815, 0.1888070244557758, 0.19358441257526082, 0.18294376031376125, 0.19278293622534415, 0.08640863447931735, 0.08223537952501592, 0.08924267659980212, 0.08681471855377565, 0.07111902872067344, 0.106209568221868, 0.0853346261487371, 0.08175374900890098, 0.1058597689604569]}, "mutation_prompt": null}
