{"id": "78ecbda6-c396-417c-85ec-421504ce0c7c", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.7\n        self.F = 0.8\n        self.CR = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize swarm\n        swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_values = np.array([func(ind) for ind in swarm])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Update velocities and positions using PSO\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - swarm[i]) +\n                                 self.c2 * r2 * (global_best - swarm[i]))\n                swarm[i] += velocities[i]\n                swarm[i] = np.clip(swarm[i], self.lower_bound, self.upper_bound)\n                \n                # Evaluate new position\n                f_val = func(swarm[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = swarm[i].copy()\n                    \n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Differential Evolution (DE) mutation and crossover\n            for i in range(self.pop_size):\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                x1, x2, x3 = swarm[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, swarm[i])\n                \n                f_trial = func(trial)\n                evaluations += 1\n                \n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n                    \n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n        \n        return global_best", "name": "HybridPSODE", "description": "A hybridized swarm intelligence algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to balance exploration and exploitation for efficient search across diverse problem landscapes.", "configspace": "", "generation": 0, "fitness": 0.2722911323169836, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.23.", "error": "", "parent_id": null, "metadata": {"aucs": [0.7194477849165144, 0.7145657320970451, 0.7075657132193152, 0.7171120847554294, 0.7246662197180733, 0.7523652392948732, 0.7136201413401304, 0.6951069595697995, 0.703289537806286, 0.13366331182213087, 0.13571561955896128, 0.028963824273489425, 0.2039419774157024, 0.10801579182120791, 0.04568291047554007, 0.03673468901990273, 0.14642284515247483, 0.039464166002201484, 0.13942416107575062, 0.13468091182848652, 0.12650520584324132, 0.08781714203777824, 0.1342984607912302, 0.12394202818821709, 0.13431918699386947, 0.15993173451800435, 0.09354380925940331, 0.14956128456171014, 0.11588726335140875, 0.07081497758201494, 0.11646980125755602, 0.09449479192884669, 0.1062183247370625, 0.09341654247908204, 0.1439778305775712, 0.09990949155481432, 0.993125016585559, 0.9828070521361066, 0.9940204739628151, 0.9560031933462941, 0.9844284993546313, 0.97400088784932, 0.9912492624563116, 0.9854089491235923, 0.98261286560144, 0.42689434742338483, 0.41757094964920916, 0.3664481370521512, 0.14743785439779222, 0.2197195083203154, 0.43156979720240574, 0.2826523284249213, 0.08729291256133742, 0.4658332055306692, 0.22808407378560658, 0.6832622792816971, 0.7934641258362725, 0.2174943165892924, 0.35894565097943254, 0.19005145063665052, 0.472609938714462, 0.7018075183103205, 0.6312262786201026, 0.12419355492107365, 0.2984637932939642, 0.3352662796399096, 0.35262818314589717, 0.4084684556600804, 0.2253109742051893, 0.296363051283678, 0.3924933496352483, 0.23774900011350686, 0.2886435433178487, 0.33364235458334957, 0.12381767799963583, 0.3110743888610821, 0.13085433414341463, 0.32869351897903754, 0.23896847697862977, 0.39105158591593436, 0.3061472687504784, 9.999999999998899e-05, 9.999999999998899e-05, 0.06447208889521061, 9.999999999998899e-05, 0.19074995741273548, 0.05889218631838755, 0.06806569496091619, 0.11416794011621989, 0.13742757223981716, 0.23726372916318883, 0.10015872205376486, 0.26961188433482863, 0.20107952278131702, 0.15233872090228828, 0.04039875053602959, 0.19312745661297326, 0.2355027334087254, 0.19139074522082478, 0.11048919856935735, 0.04617873737118805, 0.040022922649202486, 0.09294100032578045, 0.06192323185066617, 0.1564706029495625, 0.06867151884450362, 0.09763288744504517, 0.06391403433874199, 0.18159725001318427, 0.16113738944236156, 0.14539972973889304, 0.005981840541819272, 0.10869484828405096, 0.1223149520532466, 0.17980660920224067, 0.1367558193813656, 0.07622683586891721, 0.5652145028818469, 0.5408567252118415, 0.5333125884053959, 0.5457483017660599, 0.5180580473015038, 0.5503015825333843, 0.5128672664188192, 0.5152866880918916, 0.5333300568177861, 0.05573841638696009, 0.13121660573808636, 0.07809388374031734, 0.10935968000594043, 0.1516173378897514, 0.14211881466692744, 0.11649475305600276, 0.11043186940402105, 0.0933203337006362, 0.34827475756315585, 0.263811113384567, 0.20848074055037336, 0.20517593051796246, 0.2421714858355304, 0.27535509084031295, 0.3582390451725689, 0.22161661451803394, 0.202356795004907, 0.3115929983870782, 0.383585438963163, 0.3651432097763393, 0.34718987007944835, 0.4255690656793454, 0.27713480397541157, 0.2119852547512463, 0.31400834225090135, 0.3400192020111228, 0.21964521209636556, 0.24217982102582059, 0.21310685688615927, 0.27193066694017576, 0.18372656701820655, 0.21587096866006983, 0.22481993891985885, 0.29550125290647944, 0.24172929197655002, 0.2657463361695658, 0.2101148873405556, 0.20720798758856263, 0.1946674176709987, 0.1949303588069471, 0.2072909903611293, 0.23480054822538288, 0.2558640246876672, 0.213356111907129, 0.20439232745393876, 0.19429342540867633, 0.17989778094235576, 0.19606048981893343, 0.2032636115822879, 0.2206033615666152, 0.2181775761259639, 0.1959697375940993, 0.2022720757947699, 0.8249308167687927, 0.16809475109126248, 0.1851989924643207, 0.17123387649839772, 0.20009569638333202, 0.1996815342756696, 0.1421704592971822, 0.15967406166138476, 0.2068038789630947, 0.7902241832337069, 0.20942245487490307, 0.20035207887618978, 0.20478191342139984, 0.1681651645771146, 0.15166749048413786, 0.19000246218206085, 0.16809482973398515, 0.20325770644653718, 0.20158322786574379, 0.18306446367626295, 0.19886728625050032, 0.21384611531416953, 0.1818342652534335, 0.18823334107419998, 0.21251694636447704, 0.18056876505115926, 0.20195258140341155, 0.10794795125358014, 0.09190440069853323, 0.09520055127298532, 0.09796253804682542, 0.08797600521472504, 0.0912536920526833, 0.09733680995279703, 0.0940349030790889, 0.07993627084396504]}, "mutation_prompt": null}
{"id": "44d149a9-e09c-4591-bffc-1075fac447f3", "solution": "import numpy as np\n\nclass AdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_init = 0.9\n        self.w_final = 0.4\n        self.F = 0.8\n        self.CR = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.evaluations = 0\n\n    def chaotic_map(self, r=0.7):\n        return r * (1 - r)\n\n    def adaptive_weight(self):\n        t = self.evaluations / self.budget\n        return self.w_final + (self.w_init - self.w_final) * (1 - t)**2\n\n    def __call__(self, func):\n        # Initialize swarm\n        swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_values = np.array([func(ind) for ind in swarm])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        self.evaluations = self.pop_size\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                self.w = self.adaptive_weight()\n                r1, r2 = np.random.rand(), np.random.rand()\n                chaotic_factor = self.chaotic_map(np.random.rand())\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * chaotic_factor * (personal_best[i] - swarm[i]) +\n                                 self.c2 * r2 * chaotic_factor * (global_best - swarm[i]))\n                swarm[i] += velocities[i]\n                swarm[i] = np.clip(swarm[i], self.lower_bound, self.upper_bound)\n                \n                # Evaluate new position\n                f_val = func(swarm[i])\n                self.evaluations += 1\n                \n                # Update personal and global bests\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = swarm[i].copy()\n                    \n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if self.evaluations >= self.budget:\n                    break\n            \n            # Differential Evolution (DE) mutation and crossover\n            for i in range(self.pop_size):\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                x1, x2, x3 = swarm[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, swarm[i])\n                \n                f_trial = func(trial)\n                self.evaluations += 1\n                \n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n                    \n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if self.evaluations >= self.budget:\n                    break\n        \n        return global_best", "name": "AdaptiveHybridPSODE", "description": "An adaptive hybrid algorithm enhancing exploration and exploitation by integrating Chaotic Maps with PSO-DE for improved convergence.", "configspace": "", "generation": 1, "fitness": 0.260774038825586, "feedback": "The algorithm AdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.23.", "error": "", "parent_id": "78ecbda6-c396-417c-85ec-421504ce0c7c", "metadata": {"aucs": [0.7387651939926296, 0.734216875980577, 0.7459824972763476, 0.7278256028432297, 0.7439153801182297, 0.7390696595692332, 0.7354331945993602, 0.728053732907394, 0.722514257406352, 0.02276329394375587, 0.06361409643531446, 0.08900199873044734, 0.0037698030706185826, 0.056114063469763664, 0.003508843460349076, 0.0037180974665554922, 0.0978659512538752, 9.999999999998899e-05, 0.13265481948920588, 0.09871651671468318, 0.16226883009374837, 0.10087388541811537, 0.12604343315163913, 0.16254291221647477, 0.1640951598369722, 0.12467446522963588, 0.1317759620373723, 0.12478835239789332, 0.09585063955540041, 0.09957577552969399, 0.10181747699223576, 0.08266708189126437, 0.13508153794108346, 0.11184919172259578, 0.08989089312960863, 0.10410969630855849, 0.9588416871142671, 0.9548260022283148, 0.9588239104108313, 0.9335220736610664, 0.934110297020034, 0.9254562856666207, 0.9469745529983467, 0.9523619600026813, 0.9622647554369587, 0.4924726739925891, 0.43283168974036645, 0.5170836294761991, 0.4677477817316965, 0.48712644274829975, 0.14657212844694645, 0.4112344286653782, 0.47643802658893597, 0.5218333489509265, 0.3661972194132368, 0.7463849035339956, 0.3651000948428952, 0.19233350070368815, 0.35427491665256305, 0.18466621290268892, 0.17494025786670608, 0.17077344480312473, 0.3226930238070689, 0.11819806167635727, 0.14112977725885412, 0.1629587940344982, 0.10637123106669188, 0.11773115254990774, 0.13999496322934535, 0.266526945371066, 0.16800979591698473, 0.1628639567953334, 0.14182259762246108, 0.16583825560152343, 0.11633727929755, 0.15373503844009628, 0.14012501486825846, 0.17714182855092564, 0.11562513601403479, 0.19202982209416553, 0.12326536295495405, 0.0285886442550074, 0.03254647135903743, 9.999999999998899e-05, 0.061095712362386645, 0.034450657852681754, 9.999999999998899e-05, 0.007874110202383378, 0.0007725879970639227, 9.999999999998899e-05, 0.10406739694914102, 0.07660834837924324, 0.32385212390300644, 0.24574490126120696, 0.06046239720843716, 0.05844583558109373, 0.07420658853494844, 0.10528852725696503, 0.19164130495358989, 0.037171654854148084, 0.08314481603070067, 0.13877756734414703, 0.09717828400490125, 0.06986882287952556, 0.13666116327615785, 0.10013594808728377, 0.08508256121789604, 0.06885668796731048, 0.09869728876838835, 0.14022614745380668, 0.07046526120825114, 0.12946748379829875, 0.09388268550454837, 0.23387260207114702, 0.19245071770552735, 0.16902425761294182, 0.10406784547022196, 0.5080044589836358, 0.5349547439125673, 0.4929329545624105, 0.5691516930368503, 0.5093504022960926, 0.5393864258617422, 0.4848496594698175, 0.5037345894848636, 0.5145913064122678, 0.1269973688901902, 0.11117607913821448, 0.09569364625242249, 0.1040256125965281, 0.10930848045983987, 0.14650755883951916, 0.14624821248021125, 0.09928546963722307, 0.16029338767438528, 0.30469071604903, 0.20519306478775512, 0.17111668437791994, 0.2396742771852478, 0.2136679282456515, 0.21666323495567252, 0.1669717686178157, 0.16942825051784038, 0.21810868627882818, 0.4284035947388206, 0.36098848615394086, 0.3569197706564884, 0.4762154560604679, 0.2840853570779138, 0.4016757663363837, 0.4635397322342715, 0.42410878822285003, 0.46846042586359105, 0.21173765633910258, 0.25087247540877766, 0.24248557460504094, 0.2320160635082239, 0.22734063906166968, 0.3148109504978104, 0.26245159989795486, 0.2861828177375765, 0.2211434835644659, 0.20215421157664903, 0.20148071138912493, 0.2022074254143117, 0.23948378185478436, 0.2390092842097864, 0.2166360693216961, 0.24272274944179362, 0.23943727765547196, 0.24180366771036965, 0.239993122577576, 0.23800705899666075, 0.18357607969538103, 0.17871028053828308, 0.1883164518449173, 0.20380941276940323, 0.1769523663030137, 0.2195312382074026, 0.1823770707539064, 0.12885168827064286, 0.18408771473940233, 0.1830961873051571, 0.7903604223162465, 0.19747824169193284, 0.7835616287220493, 0.1395412587346071, 0.1714401588662937, 0.14278133429567208, 0.7962749544329745, 0.20671223845088793, 0.16497188854988143, 0.7768019748703847, 0.20424159161607158, 0.15179900389310985, 0.195093561096917, 0.3343749291167468, 0.11063566813028136, 0.20985344862832556, 0.19398094424674217, 0.21260506568387572, 0.19209121093705805, 0.21152498171107215, 0.18679839384079344, 0.18707841569169137, 0.2238972783183385, 0.1821323035608321, 0.08854509619742512, 0.07788653015590097, 0.09453236749803351, 0.0886097819114946, 0.09146101415932895, 0.08126814657518466, 0.10454557447103541, 0.08526243060625815, 0.11328455956245687]}, "mutation_prompt": null}
{"id": "72c64fe7-06c5-4c40-9c94-91e99bad0929", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.7\n        self.F = 0.8\n        self.CR = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize swarm\n        swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_values = np.array([func(ind) for ind in swarm])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Update velocities and positions using PSO\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - swarm[i]) +\n                                 self.c2 * r2 * (global_best - swarm[i]))\n                swarm[i] += velocities[i]\n                swarm[i] = np.clip(swarm[i], self.lower_bound, self.upper_bound)\n                \n                # Evaluate new position\n                f_val = func(swarm[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = swarm[i].copy()\n                    \n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Differential Evolution (DE) mutation and crossover\n            for i in range(self.pop_size):\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                x1, x2, x3 = swarm[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, swarm[i])\n                \n                f_trial = func(trial)\n                evaluations += 1\n                \n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n                    \n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n        \n        return global_best", "name": "HybridPSODE", "description": "A hybridized swarm intelligence algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to balance exploration and exploitation for efficient search across diverse problem landscapes.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "78ecbda6-c396-417c-85ec-421504ce0c7c", "metadata": {"aucs": [0.7194477849165144, 0.7145657320970451, 0.7075657132193152, 0.7171120847554294, 0.7246662197180733, 0.7523652392948732, 0.7136201413401304, 0.6951069595697995, 0.703289537806286, 0.13366331182213087, 0.13571561955896128, 0.028963824273489425, 0.2039419774157024, 0.10801579182120791, 0.04568291047554007, 0.03673468901990273, 0.14642284515247483, 0.039464166002201484, 0.13942416107575062, 0.13468091182848652, 0.12650520584324132, 0.08781714203777824, 0.1342984607912302, 0.12394202818821709, 0.13431918699386947, 0.15993173451800435, 0.09354380925940331, 0.14956128456171014, 0.11588726335140875, 0.07081497758201494, 0.11646980125755602, 0.09449479192884669, 0.1062183247370625, 0.09341654247908204, 0.1439778305775712, 0.09990949155481432, 0.993125016585559, 0.9828070521361066, 0.9940204739628151, 0.9560031933462941, 0.9844284993546313, 0.97400088784932, 0.9912492624563116, 0.9854089491235923, 0.98261286560144, 0.42689434742338483, 0.41757094964920916, 0.3664481370521512, 0.14743785439779222, 0.2197195083203154, 0.43156979720240574, 0.2826523284249213, 0.08729291256133742, 0.4658332055306692, 0.22808407378560658, 0.6832622792816971, 0.7934641258362725, 0.2174943165892924, 0.35894565097943254, 0.19005145063665052, 0.472609938714462, 0.7018075183103205, 0.6312262786201026, 0.12419355492107365, 0.2984637932939642, 0.3352662796399096, 0.35262818314589717, 0.4084684556600804, 0.2253109742051893, 0.296363051283678, 0.3924933496352483, 0.23774900011350686, 0.2886435433178487, 0.33364235458334957, 0.12381767799963583, 0.3110743888610821, 0.13085433414341463, 0.32869351897903754, 0.23896847697862977, 0.39105158591593436, 0.3061472687504784, 9.999999999998899e-05, 9.999999999998899e-05, 0.06447208889521061, 9.999999999998899e-05, 0.19074995741273548, 0.05889218631838755, 0.06806569496091619, 0.11416794011621989, 0.13742757223981716, 0.23726372916318883, 0.10015872205376486, 0.26961188433482863, 0.20107952278131702, 0.15233872090228828, 0.04039875053602959, 0.19312745661297326, 0.2355027334087254, 0.19139074522082478, 0.11048919856935735, 0.04617873737118805, 0.040022922649202486, 0.09294100032578045, 0.06192323185066617, 0.1564706029495625, 0.06867151884450362, 0.09763288744504517, 0.06391403433874199, 0.18159725001318427, 0.16113738944236156, 0.14539972973889304, 0.005981840541819272, 0.10869484828405096, 0.1223149520532466, 0.17980660920224067, 0.1367558193813656, 0.07622683586891721, 0.5652145028818469, 0.5408567252118415, 0.5333125884053959, 0.5457483017660599, 0.5180580473015038, 0.5503015825333843, 0.5128672664188192, 0.5152866880918916, 0.5333300568177861, 0.05573841638696009, 0.13121660573808636, 0.07809388374031734, 0.10935968000594043, 0.1516173378897514, 0.14211881466692744, 0.11649475305600276, 0.11043186940402105, 0.0933203337006362, 0.34827475756315585, 0.263811113384567, 0.20848074055037336, 0.20517593051796246, 0.2421714858355304, 0.27535509084031295, 0.3582390451725689, 0.22161661451803394, 0.202356795004907, 0.3115929983870782, 0.383585438963163, 0.3651432097763393, 0.34718987007944835, 0.4255690656793454, 0.27713480397541157, 0.2119852547512463, 0.31400834225090135, 0.3400192020111228, 0.21964521209636556, 0.24217982102582059, 0.21310685688615927, 0.27193066694017576, 0.18372656701820655, 0.21587096866006983, 0.22481993891985885, 0.29550125290647944, 0.24172929197655002, 0.2657463361695658, 0.2101148873405556, 0.20720798758856263, 0.1946674176709987, 0.1949303588069471, 0.2072909903611293, 0.23480054822538288, 0.2558640246876672, 0.213356111907129, 0.20439232745393876, 0.19429342540867633, 0.17989778094235576, 0.19606048981893343, 0.2032636115822879, 0.2206033615666152, 0.2181775761259639, 0.1959697375940993, 0.2022720757947699, 0.8249308167687927, 0.16809475109126248, 0.1851989924643207, 0.17123387649839772, 0.20009569638333202, 0.1996815342756696, 0.1421704592971822, 0.15967406166138476, 0.2068038789630947, 0.7902241832337069, 0.20942245487490307, 0.20035207887618978, 0.20478191342139984, 0.1681651645771146, 0.15166749048413786, 0.19000246218206085, 0.16809482973398515, 0.20325770644653718, 0.20158322786574379, 0.18306446367626295, 0.19886728625050032, 0.21384611531416953, 0.1818342652534335, 0.18823334107419998, 0.21251694636447704, 0.18056876505115926, 0.20195258140341155, 0.10794795125358014, 0.09190440069853323, 0.09520055127298532, 0.09796253804682542, 0.08797600521472504, 0.0912536920526833, 0.09733680995279703, 0.0940349030790889, 0.07993627084396504]}, "mutation_prompt": null}
{"id": "afafb179-1484-4eb5-b9a1-9014d9ac95a7", "solution": "import numpy as np\n\nclass EnhancedPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.7\n        self.F = 0.8\n        self.CR = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.elitism_rate = 0.1  # Proportion of elite individuals retained\n\n    def __call__(self, func):\n        # Initialize swarm\n        swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_values = np.array([func(ind) for ind in swarm])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = 0.9 - (0.5 * evaluations / self.budget)\n            \n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - swarm[i]) +\n                                 self.c2 * r2 * (global_best - swarm[i]))\n                swarm[i] += velocities[i]\n                swarm[i] = np.clip(swarm[i], self.lower_bound, self.upper_bound)\n                \n                f_val = func(swarm[i])\n                evaluations += 1\n                \n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = swarm[i].copy()\n                    \n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Apply elitism\n            elite_count = int(self.elitism_rate * self.pop_size)\n            elite_indices = personal_best_values.argsort()[:elite_count]\n            elites = personal_best[elite_indices]\n\n            # Differential Evolution (DE) mutation and crossover\n            for i in range(self.pop_size):\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                x1, x2, x3 = swarm[indices]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover_mask, mutant, swarm[i])\n                \n                f_trial = func(trial)\n                evaluations += 1\n                \n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n                    \n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Reinforce elite individuals back into the population\n            if evaluations < self.budget:\n                for j in range(elite_count):\n                    idx = np.random.randint(self.pop_size)\n                    swarm[idx] = elites[j]\n                    personal_best_values[idx] = func(swarm[idx])\n                    evaluations += 1\n                \n                    if personal_best_values[idx] < personal_best_values[global_best_idx]:\n                        global_best_idx = idx\n                        global_best = personal_best[global_best_idx]\n\n                    if evaluations >= self.budget:\n                        break\n        \n        return global_best", "name": "EnhancedPSODE", "description": "An enhanced hybrid optimizer combining PSO and DE with adaptive parameter tuning and elitism to improve convergence speed and solution quality.", "configspace": "", "generation": 3, "fitness": 0.22507901059739463, "feedback": "The algorithm EnhancedPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.21.", "error": "", "parent_id": "78ecbda6-c396-417c-85ec-421504ce0c7c", "metadata": {"aucs": [0.5077233720524374, 0.4248509734073309, 0.45744116821121883, 0.5974910094288836, 0.484997073236454, 0.5732692990687056, 0.49283216486741244, 0.512137318040008, 0.5160970909091871, 0.09975560775212866, 0.12027209344178269, 0.08106520513372528, 0.035061206296665315, 0.04714647330786048, 0.12052199612698677, 0.1353146048194529, 0.15894395477326784, 0.10293970603011493, 0.09744611346286403, 0.13230310596299366, 0.10578820485152352, 0.1084084092299118, 0.0805358293081534, 0.09680245089090111, 0.09972095618248167, 0.09010151633871988, 0.08555508421680025, 0.08597725446256077, 0.06358742321500599, 0.09238547869097269, 0.10520066953139373, 0.09768410331243782, 0.09485801788725312, 0.08815693318199336, 0.08299848906554164, 0.0919555673935809, 0.9923018177001056, 0.9857239456230509, 0.9936692634485823, 0.9603219563198897, 0.9840348433311723, 0.9624549066040889, 0.9911819824907466, 0.9851612555043949, 0.9831742349903907, 0.21750146393856562, 0.2629878660254531, 0.3566440356090267, 0.18773982086206997, 0.2253996706081769, 0.22657493044466648, 0.2518805780023047, 0.30559851320273446, 0.28446029544697893, 0.2121406553251548, 0.4980564499252781, 0.3831674292269136, 0.4769328797310436, 0.25364260485639334, 0.5714917679034363, 0.393971157469049, 0.621240945850073, 0.5335655952801898, 0.20526457416864297, 0.17779492504286099, 0.16507176224506437, 0.10473599555213042, 0.11152998677655213, 0.07879663955392446, 0.2556188077436701, 0.1787801069242816, 0.2052573471167446, 0.10580980515744742, 0.1586653601177268, 0.10688315132003134, 0.2989088749187486, 0.2671594707217083, 0.16421368439973427, 0.12879924837213852, 0.16343083831731287, 0.21544547213179344, 0.08415672217818537, 0.028722568625919154, 0.1245321417341183, 0.00019476434491028094, 0.04328156373620695, 9.999999999998899e-05, 0.09062019035357405, 0.06596439990334091, 0.011885263912744803, 0.1365180188487375, 0.05890351062000576, 0.10737943837183161, 0.15747259296106164, 0.02848550052382126, 0.0726893404071417, 0.06175473388729735, 0.06305440758683822, 0.04166176137396327, 0.048756782471889526, 0.051993775450415725, 0.019744592846770992, 0.025074515071520587, 0.04040239810723667, 0.03551919674906889, 0.04647812388812633, 0.026967913529245213, 0.022725868760395174, 0.09848138837574183, 0.13655561400027905, 0.13054684017266427, 0.004558635193642635, 0.1134751608603165, 0.16794540643826616, 0.04185449272744768, 0.12026663933835569, 0.06682779895474977, 0.42105799657705256, 0.36780028856668934, 0.4440476208604026, 0.4376535133999039, 0.4024723187691953, 0.42805708377404506, 0.3984825524140376, 0.43451893361706817, 0.42004425421043057, 0.10501322846016159, 0.0832335657665475, 0.08660847930357318, 0.08215541769195422, 0.09026297649889004, 0.11943642779436359, 0.08366817910932767, 0.08305219022655841, 0.13177843957103053, 0.19026849099130438, 0.20375479979251532, 0.16946890055784825, 0.16229333052563122, 0.15129259878050472, 0.17904976782898807, 0.17992499341924517, 0.13420019062215927, 0.18226901686677466, 0.28310206839487095, 0.2874889708378632, 0.2711129349275949, 0.2697187797218815, 0.24849958362330749, 0.30427996187565387, 0.3087590179729738, 0.24757727665013995, 0.28087498189611626, 0.2143467896259721, 0.24081247414501805, 0.19858885647544477, 0.24014429406523552, 0.16503983020981194, 0.22765860196504617, 0.2002126143006584, 0.2488641864647465, 0.19351160436718684, 0.21798279874137205, 0.19870492229832448, 0.18717038520467255, 0.17162030734751332, 0.17970918933440738, 0.23526594975360593, 0.20711154848556657, 0.19885705228623296, 0.20118289524226252, 0.19930466457537055, 0.17987600209206045, 0.18939677773525943, 0.1891946048583586, 0.200053081283722, 0.1902877260802497, 0.1779820874528616, 0.19693515679958007, 0.19860090324557345, 0.5717059445035034, 0.16910748471080683, 0.15157137009603172, 0.47129541773809036, 0.19429859538375427, 0.19272992488138374, 0.14141124072078803, 0.18277524243636967, 0.2051874588659406, 0.6226411003231302, 0.20779084790724867, 0.18127065085214022, 0.19678201431867015, 0.16814807189154968, 0.14672902161642198, 0.20393127585500248, 0.20385123829080176, 0.19631183839580313, 0.17411278536100616, 0.19320274280128247, 0.18898422918522573, 0.18449092289853697, 0.17534844771025204, 0.19170776731416095, 0.1825586070981563, 0.18962340685681522, 0.179446127237178, 0.07689148733568996, 0.08066527493401554, 0.07264474280418731, 0.07088848970708017, 0.07293897029713992, 0.07098454678804533, 0.09479609684947121, 0.07857171380106065, 0.07391185224279839]}, "mutation_prompt": null}
{"id": "66e2f758-2bbf-4427-9c12-c1e8ccb82c80", "solution": "import numpy as np\n\nclass AdaptiveHybridPSOCS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.c1 = 2.0  # Increased cognitive parameter for faster convergence\n        self.c2 = 2.0  # Increased social parameter for faster convergence\n        self.w = 0.5  # Reduced inertia weight for better fine-tuning\n        self.pa = 0.25  # Adding discovery rate of alien eggs/solutions in Cuckoo Search\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize swarm\n        swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_values = np.array([func(ind) for ind in swarm])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - swarm[i]) +\n                                 self.c2 * r2 * (global_best - swarm[i]))\n                swarm[i] += velocities[i]\n                swarm[i] = np.clip(swarm[i], self.lower_bound, self.upper_bound)\n                \n                # Evaluate new position\n                f_val = func(swarm[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = swarm[i].copy()\n                    \n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Cuckoo Search (CS) inspired update\n            for i in range(self.pop_size):\n                if np.random.rand() < self.pa:\n                    # Levy flight\n                    step_size = np.random.standard_cauchy(size=self.dim)\n                    new_solution = swarm[i] + step_size * (swarm[i] - global_best)\n                    new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n                    \n                    f_new = func(new_solution)\n                    evaluations += 1\n                    \n                    if f_new < personal_best_values[i]:\n                        personal_best_values[i] = f_new\n                        personal_best[i] = new_solution.copy()\n                        \n                        if f_new < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n        \n        return global_best", "name": "AdaptiveHybridPSOCS", "description": "An adaptive hybrid algorithm integrating Particle Swarm Optimization (PSO) with Cuckoo Search to enhance convergence by balancing exploration and exploitation dynamically.", "configspace": "", "generation": 4, "fitness": 0.3647034749132884, "feedback": "The algorithm AdaptiveHybridPSOCS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.", "error": "", "parent_id": "78ecbda6-c396-417c-85ec-421504ce0c7c", "metadata": {"aucs": [0.8802287967000919, 0.8790613909684096, 0.876167958913536, 0.8704845698420642, 0.8703058331292444, 0.8630964457973471, 0.8790181164551539, 0.8585749700694217, 0.860317742546428, 0.5698429743978022, 0.530857582361846, 0.470284058293128, 0.6522640244395719, 0.645886190532178, 0.6389480283705098, 0.6703583467728993, 0.05206221783371401, 0.6129481624811166, 0.13472725991423173, 0.17677966070879758, 0.09105560513188593, 0.09175701027290017, 0.14032746810214902, 0.14292660164005266, 0.10743112194641213, 0.14713800115820885, 0.12378355958012177, 0.07497971156841854, 0.09138379069388025, 0.09811089657393146, 0.08846149338569753, 0.10951900677214976, 0.13334997579799635, 0.10510985621353341, 0.14278934346102634, 0.13660947885007868, 0.9940073169609276, 0.9877508276747458, 0.9947455839417267, 0.9883424102871016, 0.9922797549635488, 0.9887745250961768, 0.9900886007603981, 0.9927406160251483, 0.993456594738186, 0.657887163303935, 0.673134934500668, 0.0585107969239983, 0.5958876406930873, 0.6656054466847252, 0.5084801927595524, 0.6003166818945223, 0.5905142592143116, 0.588244600614163, 0.8290942730819119, 0.22969119895471524, 0.8371212966333079, 0.19519196894030255, 0.2769178010807716, 0.2151585795495452, 0.12668087213719315, 0.18592308057209617, 0.23144187267978145, 0.6907745640147286, 0.5399238527653798, 0.7374583506677364, 0.09937084445211075, 0.135343448537254, 0.5833849875272199, 0.6367055410895733, 0.5570570598112723, 0.6315995505520924, 0.7086838779894125, 0.6981187799166132, 0.1342009717868632, 0.6428987352164661, 0.6751082927982426, 0.6077554281977358, 0.6938194415682335, 0.1314083285265054, 0.5144771494481537, 9.999999999998899e-05, 0.06147605681646806, 0.5564654951407437, 9.999999999998899e-05, 0.5348554753292387, 0.15140145209935252, 0.3609831721490955, 0.5390286392845989, 0.4934051114984569, 0.6003353745117013, 0.13310253983899334, 0.4290503943692421, 0.4137788154356603, 0.1757168233638957, 0.08456174215875545, 0.558221561086407, 0.45604034434396346, 0.10711225662247326, 0.0866572177688002, 0.10580180931424765, 0.20177942672773674, 0.2731342261865739, 0.07550282998213753, 0.07458066186593937, 0.0952490894603727, 0.14456057085012797, 0.07061314324970813, 0.23612506471389583, 0.36361479959979937, 0.04288496168477118, 0.006464721552709829, 0.4261487748615248, 0.4207026722765408, 0.2602860412540219, 0.08311327772993005, 0.08278613027330706, 0.7466495882291204, 0.7627133564510042, 0.7651782210935935, 0.7716192881621367, 0.8081651213960513, 0.7781985736115757, 0.7435938094573789, 0.7751750366307876, 0.7415387752977955, 0.14511945890757338, 0.1247307046785674, 0.07446151769380482, 0.10201575286122444, 0.15603205294124278, 0.09270479945558041, 0.10634660348886305, 0.1099711291617399, 0.1308902579238469, 0.14602545275820944, 0.26978648894328605, 0.2176428579467642, 0.2995065932817007, 0.3574746074159101, 0.2704476314131905, 0.5316086484853102, 0.180541834202692, 0.20649053513291626, 0.3897063009207078, 0.3976386425999844, 0.3375468290609448, 0.48419592180774873, 0.3408800563167602, 0.5457550057885706, 0.1969163677207867, 0.4460525290834424, 0.3809451986228787, 0.24342560754068399, 0.34565496492132475, 0.20404278576206158, 0.3300953307636709, 0.2591682358097136, 0.2636118259564283, 0.24370955563334873, 0.2599820937340114, 0.2973546592393851, 0.21609920310623887, 0.15603275421954876, 0.20952694856137055, 0.2540193926026313, 0.2215362491568318, 0.2467234435410871, 0.24100824190507442, 0.2262741854804381, 0.21027734703709466, 0.18176035118477463, 0.20693410757423514, 0.21800673531246384, 0.2160686761101488, 0.19281393564536953, 0.1849317925686218, 0.17217724978585758, 0.18301782003311662, 0.18411939202408, 0.16600553587094657, 0.168997937928126, 0.18848457454662604, 0.8944511793339018, 0.20216834256191618, 0.20071601034979203, 0.1429954110783478, 0.16523789738966044, 0.9296701194156133, 0.8859791003820047, 0.21232737412823632, 0.15494758092575667, 0.21060584340758992, 0.16966568340041233, 0.15431396581477042, 0.21132247779922098, 0.18901573476386013, 0.8260647506517949, 0.19338041214396695, 0.21158471438763493, 0.2050736330662175, 0.2020878151101484, 0.19622745019452525, 0.1970795804078268, 0.19485328201597374, 0.2262298571533956, 0.21955364246274645, 0.06888307639836455, 0.08071684185080974, 0.0865818430032197, 0.1427664835200212, 0.07856869675936373, 0.10355967667943655, 0.09896868599706543, 0.08183440749892357, 0.08362650810950978]}, "mutation_prompt": null}
{"id": "a3be978f-55d6-45c2-983a-f75e6536c6a6", "solution": "import numpy as np\n\nclass AdaptiveHybridPSOCS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.c1 = 2.0  # Increased cognitive parameter for faster convergence\n        self.c2 = 2.0  # Increased social parameter for faster convergence\n        self.w = 0.5  # Reduced inertia weight for better fine-tuning\n        self.pa = 0.25  # Adding discovery rate of alien eggs/solutions in Cuckoo Search\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize swarm\n        swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_values = np.array([func(ind) for ind in swarm])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - swarm[i]) +\n                                 self.c2 * r2 * (global_best - swarm[i]))\n                swarm[i] += velocities[i]\n                swarm[i] = np.clip(swarm[i], self.lower_bound, self.upper_bound)\n                \n                # Evaluate new position\n                f_val = func(swarm[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = swarm[i].copy()\n                    \n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Cuckoo Search (CS) inspired update\n            for i in range(self.pop_size):\n                if np.random.rand() < self.pa:\n                    # Levy flight\n                    step_size = np.random.standard_cauchy(size=self.dim)\n                    new_solution = swarm[i] + step_size * (swarm[i] - global_best)\n                    new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n                    \n                    f_new = func(new_solution)\n                    evaluations += 1\n                    \n                    if f_new < personal_best_values[i]:\n                        personal_best_values[i] = f_new\n                        personal_best[i] = new_solution.copy()\n                        \n                        if f_new < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n        \n        return global_best", "name": "AdaptiveHybridPSOCS", "description": "An adaptive hybrid algorithm integrating Particle Swarm Optimization (PSO) with Cuckoo Search to enhance convergence by balancing exploration and exploitation dynamically.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "66e2f758-2bbf-4427-9c12-c1e8ccb82c80", "metadata": {"aucs": [0.8802287967000919, 0.8790613909684096, 0.876167958913536, 0.8704845698420642, 0.8703058331292444, 0.8630964457973471, 0.8790181164551539, 0.8585749700694217, 0.860317742546428, 0.5698429743978022, 0.530857582361846, 0.470284058293128, 0.6522640244395719, 0.645886190532178, 0.6389480283705098, 0.6703583467728993, 0.05206221783371401, 0.6129481624811166, 0.13472725991423173, 0.17677966070879758, 0.09105560513188593, 0.09175701027290017, 0.14032746810214902, 0.14292660164005266, 0.10743112194641213, 0.14713800115820885, 0.12378355958012177, 0.07497971156841854, 0.09138379069388025, 0.09811089657393146, 0.08846149338569753, 0.10951900677214976, 0.13334997579799635, 0.10510985621353341, 0.14278934346102634, 0.13660947885007868, 0.9940073169609276, 0.9877508276747458, 0.9947455839417267, 0.9883424102871016, 0.9922797549635488, 0.9887745250961768, 0.9900886007603981, 0.9927406160251483, 0.993456594738186, 0.657887163303935, 0.673134934500668, 0.0585107969239983, 0.5958876406930873, 0.6656054466847252, 0.5084801927595524, 0.6003166818945223, 0.5905142592143116, 0.588244600614163, 0.8290942730819119, 0.22969119895471524, 0.8371212966333079, 0.19519196894030255, 0.2769178010807716, 0.2151585795495452, 0.12668087213719315, 0.18592308057209617, 0.23144187267978145, 0.6907745640147286, 0.5399238527653798, 0.7374583506677364, 0.09937084445211075, 0.135343448537254, 0.5833849875272199, 0.6367055410895733, 0.5570570598112723, 0.6315995505520924, 0.7086838779894125, 0.6981187799166132, 0.1342009717868632, 0.6428987352164661, 0.6751082927982426, 0.6077554281977358, 0.6938194415682335, 0.1314083285265054, 0.5144771494481537, 9.999999999998899e-05, 0.06147605681646806, 0.5564654951407437, 9.999999999998899e-05, 0.5348554753292387, 0.15140145209935252, 0.3609831721490955, 0.5390286392845989, 0.4934051114984569, 0.6003353745117013, 0.13310253983899334, 0.4290503943692421, 0.4137788154356603, 0.1757168233638957, 0.08456174215875545, 0.558221561086407, 0.45604034434396346, 0.10711225662247326, 0.0866572177688002, 0.10580180931424765, 0.20177942672773674, 0.2731342261865739, 0.07550282998213753, 0.07458066186593937, 0.0952490894603727, 0.14456057085012797, 0.07061314324970813, 0.23612506471389583, 0.36361479959979937, 0.04288496168477118, 0.006464721552709829, 0.4261487748615248, 0.4207026722765408, 0.2602860412540219, 0.08311327772993005, 0.08278613027330706, 0.7466495882291204, 0.7627133564510042, 0.7651782210935935, 0.7716192881621367, 0.8081651213960513, 0.7781985736115757, 0.7435938094573789, 0.7751750366307876, 0.7415387752977955, 0.14511945890757338, 0.1247307046785674, 0.07446151769380482, 0.10201575286122444, 0.15603205294124278, 0.09270479945558041, 0.10634660348886305, 0.1099711291617399, 0.1308902579238469, 0.14602545275820944, 0.26978648894328605, 0.2176428579467642, 0.2995065932817007, 0.3574746074159101, 0.2704476314131905, 0.5316086484853102, 0.180541834202692, 0.20649053513291626, 0.3897063009207078, 0.3976386425999844, 0.3375468290609448, 0.48419592180774873, 0.3408800563167602, 0.5457550057885706, 0.1969163677207867, 0.4460525290834424, 0.3809451986228787, 0.24342560754068399, 0.34565496492132475, 0.20404278576206158, 0.3300953307636709, 0.2591682358097136, 0.2636118259564283, 0.24370955563334873, 0.2599820937340114, 0.2973546592393851, 0.21609920310623887, 0.15603275421954876, 0.20952694856137055, 0.2540193926026313, 0.2215362491568318, 0.2467234435410871, 0.24100824190507442, 0.2262741854804381, 0.21027734703709466, 0.18176035118477463, 0.20693410757423514, 0.21800673531246384, 0.2160686761101488, 0.19281393564536953, 0.1849317925686218, 0.17217724978585758, 0.18301782003311662, 0.18411939202408, 0.16600553587094657, 0.168997937928126, 0.18848457454662604, 0.8944511793339018, 0.20216834256191618, 0.20071601034979203, 0.1429954110783478, 0.16523789738966044, 0.9296701194156133, 0.8859791003820047, 0.21232737412823632, 0.15494758092575667, 0.21060584340758992, 0.16966568340041233, 0.15431396581477042, 0.21132247779922098, 0.18901573476386013, 0.8260647506517949, 0.19338041214396695, 0.21158471438763493, 0.2050736330662175, 0.2020878151101484, 0.19622745019452525, 0.1970795804078268, 0.19485328201597374, 0.2262298571533956, 0.21955364246274645, 0.06888307639836455, 0.08071684185080974, 0.0865818430032197, 0.1427664835200212, 0.07856869675936373, 0.10355967667943655, 0.09896868599706543, 0.08183440749892357, 0.08362650810950978]}, "mutation_prompt": null}
{"id": "2b5f929e-85cb-4b42-b0c4-666072bcfaa8", "solution": "import numpy as np\n\nclass EnhancedHybridPSOCS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.c1 = 1.5  # Tuned cognitive parameter\n        self.c2 = 1.5  # Tuned social parameter\n        self.w_start = 0.9  # Starting inertia weight\n        self.w_end = 0.4    # Ending inertia weight\n        self.pa = 0.25\n        self.mutation_factor = 0.8  # Differential evolution mutation factor\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize swarm\n        swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_values = np.array([func(ind) for ind in swarm])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            # Dynamic inertia computation\n            w = self.w_end + (self.w_start - self.w_end) * ((self.budget - evaluations) / self.budget)\n            \n            # PSO Update with dynamic inertia\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - swarm[i]) +\n                                 self.c2 * r2 * (global_best - swarm[i]))\n                swarm[i] += velocities[i]\n                swarm[i] = np.clip(swarm[i], self.lower_bound, self.upper_bound)\n                \n                # Evaluate new position\n                f_val = func(swarm[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = swarm[i].copy()\n                    \n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Differential Evolution (DE) inspired mutation\n            for i in range(self.pop_size):\n                if np.random.rand() < self.pa:\n                    indices = np.random.choice(self.pop_size, 3, replace=False)\n                    a, b, c = swarm[indices[0]], swarm[indices[1]], swarm[indices[2]]\n                    mutant_vector = a + self.mutation_factor * (b - c)\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    \n                    f_new = func(mutant_vector)\n                    evaluations += 1\n                    \n                    if f_new < personal_best_values[i]:\n                        personal_best_values[i] = f_new\n                        personal_best[i] = mutant_vector.copy()\n                        \n                        if f_new < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n        \n        return global_best", "name": "EnhancedHybridPSOCS", "description": "An enhanced algorithm leveraging dynamic inertia and differential evolution-inspired mutation to accelerate convergence by adapting exploration strategies.", "configspace": "", "generation": 6, "fitness": 0.29270404689071444, "feedback": "The algorithm EnhancedHybridPSOCS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.24.", "error": "", "parent_id": "66e2f758-2bbf-4427-9c12-c1e8ccb82c80", "metadata": {"aucs": [0.7179844151107733, 0.7343594829780067, 0.7484770621194443, 0.738465142924073, 0.7352587290340326, 0.7571636867743402, 0.7049942462295249, 0.7308083858961544, 0.7334135011685866, 0.27383201396193, 0.039534751903053666, 0.3567431788405092, 0.039729689610170316, 0.3108677468907608, 0.04226655221361708, 0.32182122266471413, 0.3754983841064432, 0.3860847252639492, 0.12467840694852517, 0.08958509472298337, 0.1035737964551734, 0.12118625309291475, 0.10402179564522973, 0.1185358499286776, 0.06886850383374143, 0.11699816254498163, 0.12093712440714066, 0.08674420848454412, 0.12842939027330524, 0.08756714993645054, 0.14238879525481585, 0.10307247143793397, 0.09615707725868472, 0.12323180873982054, 0.13628374455735992, 0.09475571868557198, 0.9923018177001056, 0.9884612032795699, 0.9936692634485823, 0.9704691579770497, 0.9853349027158734, 0.9803549171834466, 0.9911819824907466, 0.988749681491896, 0.9873147567770233, 0.5109519249259664, 0.5083578989898223, 0.313452179210441, 0.14775810395057942, 0.14954932444606894, 0.5271097151427804, 0.12623725465619573, 0.08813406485802733, 0.5228182442096385, 0.21107273072630928, 0.6825343120971625, 0.21839714006470323, 0.20064120587069156, 0.3608820615420396, 0.2674411284485424, 0.21954116342471675, 0.7583693127202037, 0.22725504480289738, 0.38844732674207416, 0.4447005062553544, 0.3810099079721374, 0.09270054365870095, 0.12416531775472506, 0.2519131784830443, 0.4227854303331644, 0.4704099691775726, 0.4399769188520226, 0.41578706267457033, 0.13208392390066892, 0.4419999791427528, 0.4269356827089861, 0.46215752103319774, 0.4535676437774381, 0.4532564608686054, 0.459968322998486, 0.11163192736880079, 0.04124012119626519, 0.3386090464636018, 0.040955517815364884, 9.999999999998899e-05, 9.999999999998899e-05, 0.01338798109123962, 0.1721518301625249, 0.006310644238193497, 0.24172545690586744, 0.06061562945609167, 0.20712449582280335, 0.07274629233521224, 0.33997114888029556, 0.2738166831344835, 0.06226955534977008, 0.3135733767950798, 0.31681900977719335, 0.20340131055342858, 0.24675406154729074, 0.10460982844215938, 0.03883771817282522, 0.23673223940718147, 0.058483884105688944, 0.055579596465046066, 0.07305104447736643, 0.1621182573471066, 0.053365524129738495, 0.15398358788205047, 0.18077039510013004, 0.2938477863616413, 9.999999999998899e-05, 9.999999999998899e-05, 0.08235669676372148, 0.03909182502849018, 0.07685657741077812, 0.07702486252143403, 0.5876304134986612, 0.5879776008931845, 0.6188972024571882, 0.612317128693269, 0.5998784252356569, 0.5776995357133454, 0.5927777942544543, 0.625508582507939, 0.5998914731026677, 0.14135191012487847, 0.08832975102209717, 0.09238302842563861, 0.14064952232603423, 0.08446270889961438, 0.13967785786466647, 0.1317547980876621, 0.10146833597822902, 0.1089007028830854, 0.16702886398321648, 0.20337317383293607, 0.24977400089574964, 0.23997980002842045, 0.2938483999735657, 0.18315401891129246, 0.23754254997690682, 0.16942926836436634, 0.15747444627803542, 0.2974227610700151, 0.23232614386003303, 0.3718618683704107, 0.30465921010627417, 0.38076241950842926, 0.33601323247885106, 0.3494542261631689, 0.24232914843184306, 0.2191207312675577, 0.22240446850087348, 0.2239878436254501, 0.18001494887762348, 0.28478075295751015, 0.1963017022270952, 0.18664563984194382, 0.21452143006102653, 0.19038664411786466, 0.2052055125509361, 0.23705896658262915, 0.21219258783676342, 0.20027900145798805, 0.22151735062103872, 0.2865067980071785, 0.1843385356727626, 0.23053695679478936, 0.22958921361398565, 0.3128630913379764, 0.17584021616809664, 0.20687745557481108, 0.1795729545898601, 0.18466696575472363, 0.2470081704901167, 0.18096806781085395, 0.1905347649268786, 0.21998354858525238, 0.1752549445559347, 0.8345374490962951, 0.7648563829799322, 0.15358851083166047, 0.6963970364860177, 0.19760435093759965, 0.1990225851885521, 0.14207541361444165, 0.15876935026628158, 0.8306842662504597, 0.7440520852899577, 0.20967048274802214, 0.5181174312953298, 0.2015006938729762, 0.16944711722909067, 0.1546016070045929, 0.18541985491278257, 0.16855112587307064, 0.7382737368418137, 0.19948395614236258, 0.1960073218999785, 0.18471823279121125, 0.1958456089622368, 0.20371867696748436, 0.20754637118100516, 0.21453300742925607, 0.20675961376080554, 0.2251332170363164, 0.08624815497655691, 0.09865154411471666, 0.07994270857436636, 0.09175729166093938, 0.08384297002669705, 0.08421746307113898, 0.12629358698822957, 0.08647635405309428, 0.09404062753635756]}, "mutation_prompt": null}
{"id": "87618024-60cf-41f4-aa72-c3c4762a20ca", "solution": "import numpy as np\n\nclass AdaptiveHybridPSOCS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.c1 = 2.0  # Increased cognitive parameter for faster convergence\n        self.c2 = 2.0  # Increased social parameter for faster convergence\n        self.w = 0.5  # Reduced inertia weight for better fine-tuning\n        self.pa = 0.25  # Adding discovery rate of alien eggs/solutions in Cuckoo Search\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize swarm\n        swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_values = np.array([func(ind) for ind in swarm])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - swarm[i]) +\n                                 self.c2 * r2 * (global_best - swarm[i]))\n                swarm[i] += velocities[i]\n                swarm[i] = np.clip(swarm[i], self.lower_bound, self.upper_bound)\n                \n                # Evaluate new position\n                f_val = func(swarm[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = swarm[i].copy()\n                    \n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Cuckoo Search (CS) inspired update\n            for i in range(self.pop_size):\n                if np.random.rand() < self.pa:\n                    # Levy flight\n                    step_size = np.random.standard_cauchy(size=self.dim)\n                    new_solution = swarm[i] + step_size * (swarm[i] - global_best)\n                    new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n                    \n                    f_new = func(new_solution)\n                    evaluations += 1\n                    \n                    if f_new < personal_best_values[i]:\n                        personal_best_values[i] = f_new\n                        personal_best[i] = new_solution.copy()\n                        \n                        if f_new < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n        \n        return global_best", "name": "AdaptiveHybridPSOCS", "description": "An adaptive hybrid algorithm integrating Particle Swarm Optimization (PSO) with Cuckoo Search to enhance convergence by balancing exploration and exploitation dynamically.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "66e2f758-2bbf-4427-9c12-c1e8ccb82c80", "metadata": {"aucs": [0.8802287967000919, 0.8790613909684096, 0.876167958913536, 0.8704845698420642, 0.8703058331292444, 0.8630964457973471, 0.8790181164551539, 0.8585749700694217, 0.860317742546428, 0.5698429743978022, 0.530857582361846, 0.470284058293128, 0.6522640244395719, 0.645886190532178, 0.6389480283705098, 0.6703583467728993, 0.05206221783371401, 0.6129481624811166, 0.13472725991423173, 0.17677966070879758, 0.09105560513188593, 0.09175701027290017, 0.14032746810214902, 0.14292660164005266, 0.10743112194641213, 0.14713800115820885, 0.12378355958012177, 0.07497971156841854, 0.09138379069388025, 0.09811089657393146, 0.08846149338569753, 0.10951900677214976, 0.13334997579799635, 0.10510985621353341, 0.14278934346102634, 0.13660947885007868, 0.9940073169609276, 0.9877508276747458, 0.9947455839417267, 0.9883424102871016, 0.9922797549635488, 0.9887745250961768, 0.9900886007603981, 0.9927406160251483, 0.993456594738186, 0.657887163303935, 0.673134934500668, 0.0585107969239983, 0.5958876406930873, 0.6656054466847252, 0.5084801927595524, 0.6003166818945223, 0.5905142592143116, 0.588244600614163, 0.8290942730819119, 0.22969119895471524, 0.8371212966333079, 0.19519196894030255, 0.2769178010807716, 0.2151585795495452, 0.12668087213719315, 0.18592308057209617, 0.23144187267978145, 0.6907745640147286, 0.5399238527653798, 0.7374583506677364, 0.09937084445211075, 0.135343448537254, 0.5833849875272199, 0.6367055410895733, 0.5570570598112723, 0.6315995505520924, 0.7086838779894125, 0.6981187799166132, 0.1342009717868632, 0.6428987352164661, 0.6751082927982426, 0.6077554281977358, 0.6938194415682335, 0.1314083285265054, 0.5144771494481537, 9.999999999998899e-05, 0.06147605681646806, 0.5564654951407437, 9.999999999998899e-05, 0.5348554753292387, 0.15140145209935252, 0.3609831721490955, 0.5390286392845989, 0.4934051114984569, 0.6003353745117013, 0.13310253983899334, 0.4290503943692421, 0.4137788154356603, 0.1757168233638957, 0.08456174215875545, 0.558221561086407, 0.45604034434396346, 0.10711225662247326, 0.0866572177688002, 0.10580180931424765, 0.20177942672773674, 0.2731342261865739, 0.07550282998213753, 0.07458066186593937, 0.0952490894603727, 0.14456057085012797, 0.07061314324970813, 0.23612506471389583, 0.36361479959979937, 0.04288496168477118, 0.006464721552709829, 0.4261487748615248, 0.4207026722765408, 0.2602860412540219, 0.08311327772993005, 0.08278613027330706, 0.7466495882291204, 0.7627133564510042, 0.7651782210935935, 0.7716192881621367, 0.8081651213960513, 0.7781985736115757, 0.7435938094573789, 0.7751750366307876, 0.7415387752977955, 0.14511945890757338, 0.1247307046785674, 0.07446151769380482, 0.10201575286122444, 0.15603205294124278, 0.09270479945558041, 0.10634660348886305, 0.1099711291617399, 0.1308902579238469, 0.14602545275820944, 0.26978648894328605, 0.2176428579467642, 0.2995065932817007, 0.3574746074159101, 0.2704476314131905, 0.5316086484853102, 0.180541834202692, 0.20649053513291626, 0.3897063009207078, 0.3976386425999844, 0.3375468290609448, 0.48419592180774873, 0.3408800563167602, 0.5457550057885706, 0.1969163677207867, 0.4460525290834424, 0.3809451986228787, 0.24342560754068399, 0.34565496492132475, 0.20404278576206158, 0.3300953307636709, 0.2591682358097136, 0.2636118259564283, 0.24370955563334873, 0.2599820937340114, 0.2973546592393851, 0.21609920310623887, 0.15603275421954876, 0.20952694856137055, 0.2540193926026313, 0.2215362491568318, 0.2467234435410871, 0.24100824190507442, 0.2262741854804381, 0.21027734703709466, 0.18176035118477463, 0.20693410757423514, 0.21800673531246384, 0.2160686761101488, 0.19281393564536953, 0.1849317925686218, 0.17217724978585758, 0.18301782003311662, 0.18411939202408, 0.16600553587094657, 0.168997937928126, 0.18848457454662604, 0.8944511793339018, 0.20216834256191618, 0.20071601034979203, 0.1429954110783478, 0.16523789738966044, 0.9296701194156133, 0.8859791003820047, 0.21232737412823632, 0.15494758092575667, 0.21060584340758992, 0.16966568340041233, 0.15431396581477042, 0.21132247779922098, 0.18901573476386013, 0.8260647506517949, 0.19338041214396695, 0.21158471438763493, 0.2050736330662175, 0.2020878151101484, 0.19622745019452525, 0.1970795804078268, 0.19485328201597374, 0.2262298571533956, 0.21955364246274645, 0.06888307639836455, 0.08071684185080974, 0.0865818430032197, 0.1427664835200212, 0.07856869675936373, 0.10355967667943655, 0.09896868599706543, 0.08183440749892357, 0.08362650810950978]}, "mutation_prompt": null}
{"id": "43c9da6b-3f84-4a8a-a8f0-3126d4967d11", "solution": "import numpy as np\n\nclass AdaptiveHybridPSOCS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.pa = 0.3  # Probability of alien egg discovery in Cuckoo Search\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_sol = population[best_idx]\n        \n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            # Differential Evolution (DE) Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[idxs]\n                mutant = np.clip(x0 + self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluate trial vector\n                f_val = func(trial)\n                evaluations += 1\n                \n                # Selection\n                if f_val < fitness[i]:\n                    fitness[i] = f_val\n                    population[i] = trial\n                    \n                    # Update best solution\n                    if f_val < fitness[best_idx]:\n                        best_idx = i\n                        best_sol = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            # Cuckoo Search (CS) inspired update\n            for i in range(self.pop_size):\n                if np.random.rand() < self.pa:\n                    step_size = np.random.standard_cauchy(size=self.dim)\n                    new_solution = population[i] + step_size * (population[i] - best_sol)\n                    new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n                    \n                    f_new = func(new_solution)\n                    evaluations += 1\n                    \n                    if f_new < fitness[i]:\n                        fitness[i] = f_new\n                        population[i] = new_solution\n                        \n                        if f_new < fitness[best_idx]:\n                            best_idx = i\n                            best_sol = new_solution\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_sol", "name": "AdaptiveHybridPSOCS", "description": "Introducing Adaptive Differential Evolution with Cuckoo Search enhancements (ADE-CS) for improved convergence through dynamic parameter adaptation and hybridization.", "configspace": "", "generation": 8, "fitness": 0.23896833344876023, "feedback": "The algorithm AdaptiveHybridPSOCS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.20.", "error": "", "parent_id": "66e2f758-2bbf-4427-9c12-c1e8ccb82c80", "metadata": {"aucs": [0.5519870866710876, 0.6061562604793298, 0.5398457737565733, 0.6185450366845611, 0.5894317356346199, 0.6471363343897629, 0.5755537468393561, 0.5569076543018759, 0.6193937586174729, 0.35800315038180963, 0.3396827322456659, 0.35247602825209245, 0.33704507084792545, 0.3466384064715734, 0.3444579269508957, 0.37051951463691757, 0.31043612455074954, 0.35412160267165993, 0.10218157442388798, 0.09890308372253165, 0.10453933434641216, 0.09814931525008053, 0.10839654658176967, 0.08517930860361689, 0.0990529569023827, 0.08838544995716369, 0.087819133267802, 0.08971286119118926, 0.09089060121820369, 0.08711116894703064, 0.0901730867975199, 0.07462544973238039, 0.09017438616436646, 0.09712017644753101, 0.08340230033501717, 0.0791959030418744, 0.9779347114610625, 0.9618742526891091, 0.9711820590678293, 0.9736363082865142, 0.9682237139496769, 0.9566276218692786, 0.982933516814071, 0.9842090846019487, 0.971399940911527, 0.2540205277308113, 0.24635988722343816, 0.24875419766432683, 0.24360721326970813, 0.24157725521627604, 0.2424889081142947, 0.2688316475582463, 0.23739540525668779, 0.25710941403517173, 0.2652175498625804, 0.2900351761192457, 0.3013532167133812, 0.4286354815912852, 0.40231898486704876, 0.436468563350485, 0.34486695863120376, 0.4914610140180832, 0.3578020254016623, 0.1588615278936295, 0.15201803365975974, 0.17151658281185977, 0.1558743152321198, 0.1410468410808089, 0.14371066101819074, 0.17950704117110394, 0.14414600504549924, 0.16126542796556242, 0.061804237299436515, 0.09283200182966889, 0.04772045824798565, 0.15764711091430583, 0.15154959204557927, 0.13728720879511525, 0.1835104127999494, 0.14375096750662508, 0.1276823578739733, 0.09338920625401859, 0.07227183620894206, 0.06215461315511417, 0.08417247522338567, 0.08088878032180769, 0.08493169023993774, 0.0937191645588773, 0.04879676575308567, 0.09604971150351505, 0.18716187842933163, 0.190843944373014, 0.20703306512564246, 0.16375148157421626, 0.18306955461340235, 0.16256601618261524, 0.2298355663027899, 0.24380223209890095, 0.22582273628601213, 0.01623784857275934, 0.010056533541720314, 0.002600101464914739, 0.011703599008193843, 0.018639345730220525, 0.012029088205941618, 0.019486285900137568, 0.00723657988211257, 0.013621361056886827, 0.1155357907647735, 0.12481943864162404, 0.12090825034554875, 0.1266052770604339, 0.14198703930628176, 0.1557151177054742, 0.12347601978900224, 0.1256954387773288, 0.1355240383929146, 0.4490195428320307, 0.4658038563543281, 0.4478296656637143, 0.4607556466001784, 0.4296140900799834, 0.42665407431628155, 0.43586469452209964, 0.4413866733856082, 0.44460507434978613, 0.09482359379519989, 0.08344202256138633, 0.08679271644516562, 0.08625110832001937, 0.07775485911486268, 0.08219642292450136, 0.06855318230008667, 0.09509868770431718, 0.07491916450772784, 0.19589541566301716, 0.22041402691149437, 0.19085874290440075, 0.16289784270614382, 0.17943790187933772, 0.15638840255778597, 0.13945525156447658, 0.12644099105109563, 0.14713644956126593, 0.24991460592027226, 0.26791659533942747, 0.2530333743137956, 0.238996012468642, 0.236330783052498, 0.24655833008108086, 0.2536250262760007, 0.283951732797491, 0.27651769850695174, 0.19950041750843206, 0.2025571536553037, 0.1945441493728325, 0.18057426933990628, 0.18344646014999222, 0.19387228940568402, 0.20030773809600344, 0.19459656934866298, 0.20811671858231773, 0.17973291841167827, 0.20579057614597263, 0.18600767816376274, 0.18029275899990083, 0.17029651679450275, 0.17098042786226064, 0.19548606698586224, 0.1647533272937297, 0.16466767940989246, 0.16837780153041026, 0.16793053526434, 0.16998593693181574, 0.1728078637978422, 0.17391452435980614, 0.17486196611820737, 0.1739023894907179, 0.17234386812739833, 0.1765296606001453, 0.49145010596146443, 0.5018958044862751, 0.5651422422890201, 0.3293306718578176, 0.2513269668099004, 0.17468701295791522, 0.16740831275322743, 0.16095880561541565, 0.3347457400501658, 0.36557007676625397, 0.19343707666861099, 0.1938912137054315, 0.2990083157869493, 0.2754275105234738, 0.1874065224325463, 0.20293680470840547, 0.2684970614189438, 0.2003974575208637, 0.17758887483368746, 0.1871273985494495, 0.1796620363790189, 0.18187320393023132, 0.17046367380069438, 0.17777213338415765, 0.19850610775346944, 0.18930920608699475, 0.1917763577141096, 0.0725653215464872, 0.07234348272946667, 0.06324653633250932, 0.06748136881058908, 0.06710160162014878, 0.06381833671284953, 0.06944136743512719, 0.06875615335583318, 0.06795276743317791]}, "mutation_prompt": null}
{"id": "084696fa-ddb9-4dcf-ab13-f9a85bd8e384", "solution": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.c1 = 1.5  # Adaptive cognitive parameter\n        self.c2 = 1.5  # Adaptive social parameter\n        self.w = 0.6  # Adaptive inertia weight\n        self.mutation_factor = 0.8  # Differential Evolution mutation factor\n        self.crossover_prob = 0.9  # Differential Evolution crossover probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize swarm\n        swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.pop_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_values = np.array([func(ind) for ind in swarm])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            # Adaptive PSO Update\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - swarm[i]) +\n                                 self.c2 * r2 * (global_best - swarm[i]))\n                swarm[i] += velocities[i]\n                swarm[i] = np.clip(swarm[i], self.lower_bound, self.upper_bound)\n                \n                # Evaluate new position\n                f_val = func(swarm[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = swarm[i].copy()\n                    \n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Differential Evolution inspired update\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = swarm[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(swarm[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_prob:\n                        trial[j] = mutant[j]\n                f_trial = func(trial)\n                evaluations += 1\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial\n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n            # Adaptive parameter adjustment\n            self.w = 0.4 + 0.3 * np.random.rand()\n            self.c1 = 1.0 + np.random.rand()\n            self.c2 = 1.0 + np.random.rand()\n        \n        return global_best", "name": "EnhancedHybridPSODE", "description": "An enhanced hybrid algorithm combining PSO with Differential Evolution for improved exploration and exploitation balance, featuring adaptive parameter control based on convergence progress.", "configspace": "", "generation": 9, "fitness": 0.34284124403176847, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.26.", "error": "", "parent_id": "66e2f758-2bbf-4427-9c12-c1e8ccb82c80", "metadata": {"aucs": [0.815117767297256, 0.7929529419362665, 0.8164354244956322, 0.782209460725904, 0.8105954155382551, 0.7986415841666237, 0.8044768443938797, 0.8052376069759521, 0.8029664232357865, 0.5112825090788917, 0.2945046146199195, 0.3631733541572185, 0.402766892708175, 0.41118065686046035, 0.036488305455701586, 0.47106098810175423, 0.41755354572264325, 0.04257174410352815, 0.11073797024483811, 0.09344567381823765, 0.11371685005957477, 0.12632855471165805, 0.15229514368402974, 0.15449510410015643, 0.10746689641020313, 0.14008757392520688, 0.15201458727187, 0.09472385359865343, 0.08717496829264659, 0.10754418202469118, 0.09072853312264562, 0.10513085050972715, 0.09455862393958214, 0.12497039109697139, 0.14528219501273687, 0.13201971245689947, 0.9922018546433062, 0.9835766175612524, 0.9939214888424842, 0.9419090512984525, 0.9851160120449797, 0.9589140605064069, 0.985883690697343, 0.9855506148101171, 0.9848528067865063, 0.6036075593184971, 0.6114015477655622, 0.05862823735511502, 0.49296312187645863, 0.5801688860629793, 0.5889439632684312, 0.3009104898183187, 0.6052853957187377, 0.6059601124476202, 0.17238959942964394, 0.36805550719715197, 0.7576146052574687, 0.19354950441835927, 0.2753231637602799, 0.19034145919766265, 0.17619662098999744, 0.7879075314938062, 0.7374121678848132, 0.5662861719123252, 0.1274450781627664, 0.4314841292031313, 0.10050521765390152, 0.13320796343855146, 0.4332913689875304, 0.5215605037317923, 0.5557109797355908, 0.5925250518391034, 0.5268513803819921, 0.4808963361979034, 0.6465755597695515, 0.43084337742814804, 0.1286147229162209, 0.42777030173231345, 0.5989616818703329, 0.5242984307994831, 0.5574116558614995, 9.999999999998899e-05, 9.999999999998899e-05, 0.38174095520656093, 0.04030639829055871, 9.999999999998899e-05, 0.4861704557008424, 0.46053334441505744, 0.3761048398067114, 0.049705579775429, 0.3521080532868437, 0.38704360243056846, 0.4574586416099178, 0.5268495296074343, 0.0989175827534815, 0.38161786653946705, 0.473606219714123, 0.40105667808249523, 0.4069135250472825, 0.12230734262675413, 0.16177674836205624, 0.27668332733498135, 0.24497291656704934, 0.15254410341862168, 0.07014975188307249, 0.09025132444154282, 0.11864880199176664, 0.060940752936872955, 0.1353820436495996, 0.23065046592874527, 0.15430381479515287, 0.27509416406884446, 0.3114290643948132, 0.282839548295142, 0.07783701596440407, 0.2618832775318414, 0.081293117347639, 0.7008522634169061, 0.6178504666153839, 0.6973902860134233, 0.6410097155355577, 0.6452984432893396, 0.629565897542206, 0.6694536579556768, 0.6440796687377369, 0.6457203000059841, 0.16917300024808757, 0.1509095646095573, 0.11874782379260884, 0.08628534086446504, 0.12221160223480887, 0.12196829572996071, 0.12096140784277054, 0.10640276661918213, 0.1078683772976674, 0.17134721958591104, 0.1811294237282205, 0.17806782211602512, 0.1931235389409106, 0.6162068583334022, 0.14375213504784734, 0.20498735808050628, 0.16835746832931187, 0.23607812290895203, 0.2564195496634869, 0.3929894804164309, 0.3739059243811109, 0.47103308981191516, 0.48834023196986576, 0.2751016992731381, 0.2786364487228249, 0.2516950995910655, 0.45074604801001705, 0.28972378082193007, 0.38488823715620135, 0.2832793378834786, 0.32587063597819954, 0.1895781426305091, 0.3379030846612022, 0.25237810461293253, 0.34624534021841713, 0.2906733726211461, 0.22597015895593275, 0.19597334260555632, 0.22914610580422556, 0.2662590594816209, 0.21953815826103107, 0.2185703747412856, 0.2388944980075468, 0.2020973114929615, 0.20767606884073597, 0.22111593501513527, 0.19738251075988933, 0.18437593882712977, 0.20762551968687126, 0.23280676914317644, 0.23904184509595083, 0.20651180743982045, 0.20745855753451325, 0.17179961053176862, 0.8989957994605207, 0.1262076601841845, 0.1873589143804837, 0.17306175940317503, 0.20047925170967296, 0.19972224802252303, 0.14281356359346575, 0.16502822350780466, 0.20995937691997368, 0.8762944928846101, 0.21074257626704584, 0.7554262319805143, 0.20921601902847142, 0.2093181918999134, 0.15460732749068007, 0.7779894317196402, 0.7936748948057215, 0.8146958706572981, 0.21419266490258748, 0.18588579599823107, 0.21069261854622978, 0.18225353633502728, 0.19493453323528442, 0.20049616923102687, 0.20092146042265857, 0.19158707836393774, 0.22386409536877105, 0.10885717473149015, 0.10306052252940467, 0.09688999496944817, 0.08067259580604458, 0.09060739684764285, 0.0769399983335648, 0.09348561531157962, 0.09233239153050377, 0.09580904867768236]}, "mutation_prompt": null}
{"id": "7a5b4126-f521-4cbd-b54a-cac91b9515b6", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.c1 = 1.5  # Adjusted cognitive parameter\n        self.c2 = 1.5  # Adjusted social parameter\n        self.w = 0.7  # Increased inertia weight for broader exploration\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize swarm\n        swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_values = np.array([func(ind) for ind in swarm])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - swarm[i]) +\n                                 self.c2 * r2 * (global_best - swarm[i]))\n                swarm[i] += velocities[i]\n                swarm[i] = np.clip(swarm[i], self.lower_bound, self.upper_bound)\n                \n                # Evaluate new position\n                f_val = func(swarm[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = swarm[i].copy()\n                    \n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Differential Evolution (DE) inspired update\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, swarm[i])\n                \n                f_trial = func(trial)\n                evaluations += 1\n                \n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n                    \n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n        \n        return global_best", "name": "HybridPSODE", "description": "A hybrid approach blending Particle Swarm Optimization (PSO) with Differential Evolution (DE) for enhanced exploration and convergence optimization.", "configspace": "", "generation": 10, "fitness": 0.27701507009929877, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.23.", "error": "", "parent_id": "66e2f758-2bbf-4427-9c12-c1e8ccb82c80", "metadata": {"aucs": [0.6856436328600006, 0.6948666631744433, 0.7182413202490652, 0.6861069459522134, 0.7418032439524461, 0.7330212926805146, 0.6803711287450698, 0.704343992189818, 0.6939743544652295, 0.2042189586270442, 0.15352447960466575, 0.22556631684959405, 0.20265586402168, 0.20101946816365723, 0.22383996536629824, 0.23694037762168885, 0.2073021837812189, 0.033376593725712556, 0.13023908852768507, 0.1441135790391772, 0.10243337048734336, 0.18339551963707745, 0.1239757264003114, 0.1227388827590179, 0.10467169254110109, 0.12329465117623373, 0.1015564639814378, 0.09683145427558215, 0.09850730610500502, 0.08978225416055774, 0.0968384056080196, 0.09121651247538098, 0.0997193807468848, 0.13214944210685664, 0.13723025943364087, 0.07456834169425475, 0.993125016585559, 0.9828096291534151, 0.9940204739628151, 0.9410220555317502, 0.9835413475777359, 0.972712202359665, 0.9912492624563116, 0.9848116427260355, 0.9823511497439251, 0.46964527836903325, 0.4520698417542759, 0.3806117580701589, 0.1492211146145801, 0.2816471259787603, 0.23833141245101663, 0.17829968212076952, 0.08859377276357172, 0.49408680399230964, 0.21882529319947874, 0.22564308630809404, 0.22217793193200885, 0.7089800742670738, 0.2752900474687704, 0.26237204859571317, 0.22184655716152535, 0.2309933550939952, 0.6968860436858495, 0.32053499703806665, 0.2764927454104339, 0.1097976054922245, 0.10386947622056564, 0.1284636037948037, 0.17402321726272896, 0.3040909025492896, 0.3934131339372329, 0.34626424022502145, 0.36985359513222904, 0.28654015413160083, 0.34944714307805347, 0.3612252343029553, 0.3414140513419601, 0.12410628675335733, 0.27631694383181327, 0.3689172151055763, 0.36825010949914627, 9.999999999998899e-05, 0.03500496758181704, 9.999999999998899e-05, 0.024857684181456507, 0.15893621662587143, 0.12285997987286268, 0.1653409533565302, 0.16767935689450408, 0.062478873351199615, 0.23751871572847616, 0.22876688896520903, 0.26777381020462554, 0.14473905100979045, 0.12494050411054358, 0.24692695985654056, 0.2161106205199027, 0.24910012916188884, 0.18423022156389424, 0.03582618498602663, 0.05709404273772012, 0.03871138081938208, 0.10261831391310317, 0.059046306325326814, 0.06141970982574052, 0.07107901927151239, 0.19637451273690698, 0.14051731208094098, 0.15356456701863375, 0.23370402786599254, 0.15264176731292622, 0.005730721307749653, 0.14727183234967178, 0.14820370353020718, 0.1806570328648922, 0.19555361134345028, 0.07577400173362969, 0.5030286492203875, 0.518042801568849, 0.5438713829885395, 0.5496224670048558, 0.5369242585431007, 0.48948810492967343, 0.5266849567588018, 0.563711402991902, 0.5489765099908344, 0.1461877713702514, 0.10347799636615673, 0.09763189420277907, 0.08390047551263646, 0.10574763729748304, 0.11546349753156648, 0.11210265558461974, 0.13359021527044446, 0.12356467329416732, 0.44966644109710174, 0.2392403781851251, 0.21119898296545947, 0.21494787780206626, 0.28285113449989663, 0.18550084783569232, 0.406219644610717, 0.18484437430065948, 0.20167979738272857, 0.3647301793833302, 0.31249972152646077, 0.37930122538699396, 0.3107270188559249, 0.3555114562417774, 0.3470535822359072, 0.29197214248322734, 0.41985710235793827, 0.37100004470553727, 0.2002553393347376, 0.24729189124132567, 0.2062534336601901, 0.2428865031127312, 0.1720315632117898, 0.25225127234158595, 0.20549200617655838, 0.2368504611066634, 0.34666607985760356, 0.22248410599309076, 0.18988138887386907, 0.2431502885975867, 0.18603328740025926, 0.2320773506061602, 0.22289070873352546, 0.21662328682229537, 0.22428629222027008, 0.2249469150577259, 0.20550335541626408, 0.21535539482812371, 0.19126241059813098, 0.289807853079753, 0.1992875958726671, 0.1928594106798387, 0.27560710689541223, 0.1974252287803292, 0.1778124170070221, 0.8575635486241365, 0.16830825255781856, 0.18285335161722016, 0.17227747341715494, 0.19946070538310623, 0.19986519334136799, 0.1423581334181746, 0.16036268346246108, 0.2102360970644337, 0.7991100817410627, 0.21090705173816837, 0.07207777470180876, 0.7113192469645127, 0.16907793602850074, 0.15439455773135147, 0.1980025444843997, 0.1681122652857837, 0.7804665531140969, 0.17514643978562128, 0.19190707399171303, 0.19964785135679064, 0.2160208612312463, 0.18632142228236626, 0.1925009808824022, 0.19697593012416192, 0.18030005491996903, 0.2006258742724779, 0.08227529533821376, 0.09369659209539427, 0.08336923018257325, 0.09665108824994273, 0.08209806593082447, 0.08240872880683714, 0.09590809024989011, 0.08929233028745276, 0.08774677376988727]}, "mutation_prompt": null}
{"id": "6e3b3465-d9e4-4d35-8792-61a0d2bc9d3b", "solution": "import numpy as np\n\nclass EnhancedHybridPSODECS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Increased population size for better diversity\n        self.c1 = 1.5  # Adjusted cognitive parameter for balanced convergence\n        self.c2 = 1.5  # Adjusted social parameter for balanced convergence\n        self.w = 0.6   # Slightly increased inertia for better exploration\n        self.pa = 0.3  # Higher discovery rate for Cuckoo Search\n        self.f = 0.8   # Differential evolution mutation factor\n        self.cr = 0.9  # Crossover probability for differential evolution\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize swarm\n        swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_values = np.array([func(ind) for ind in swarm])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - swarm[i]) +\n                                 self.c2 * r2 * (global_best - swarm[i]))\n                swarm[i] += velocities[i]\n                swarm[i] = np.clip(swarm[i], self.lower_bound, self.upper_bound)\n\n                # Evaluate new position\n                f_val = func(swarm[i])\n                evaluations += 1\n\n                # Update personal and global bests\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = swarm[i].copy()\n\n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Differential Evolution inspired mutation and crossover\n            for i in range(self.pop_size):\n                if np.random.rand() < self.cr:\n                    idxs = np.random.choice(self.pop_size, 3, replace=False)\n                    x0, x1, x2 = swarm[idxs[0]], swarm[idxs[1]], swarm[idxs[2]]\n                    mutant_vector = x0 + self.f * (x1 - x2)\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    \n                    if func(mutant_vector) < personal_best_values[i]:\n                        personal_best[i] = mutant_vector.copy()\n                        personal_best_values[i] = func(mutant_vector)\n                        evaluations += 1\n\n                        if personal_best_values[i] < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Cuckoo Search (CS) inspired update\n            for i in range(self.pop_size):\n                if np.random.rand() < self.pa:\n                    step_size = np.random.standard_cauchy(size=self.dim)\n                    new_solution = swarm[i] + step_size * (swarm[i] - global_best)\n                    new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n\n                    f_new = func(new_solution)\n                    evaluations += 1\n\n                    if f_new < personal_best_values[i]:\n                        personal_best_values[i] = f_new\n                        personal_best[i] = new_solution.copy()\n\n                        if f_new < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "EnhancedHybridPSODECS", "description": "An enhanced adaptive algorithm combining PSO with differential evolution and Cuckoo Search to improve convergence speed through diverse exploration and refined exploitation.", "configspace": "", "generation": 11, "fitness": 0.2988227784723854, "feedback": "The algorithm EnhancedHybridPSODECS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "66e2f758-2bbf-4427-9c12-c1e8ccb82c80", "metadata": {"aucs": [0.7517883706406404, 0.7441520570145232, 0.7397439683255258, 0.756515946597244, 0.7099419077638491, 0.7163611514241002, 0.7407700928463561, 0.7190540226469304, 0.7251937091871427, 0.06488395538790281, 0.3146065924759478, 0.2923726668843608, 0.30350830529344897, 0.2508705535371252, 0.21861596701787822, 0.3471631907775671, 0.045540950552145465, 0.22672478654104566, 0.11190224161487239, 0.13651888045434402, 0.1347281219325791, 0.10370510332123828, 0.11106244005730481, 0.10561632023720469, 0.10589265739745246, 0.13161389749160413, 0.13088224357511502, 0.1354961921447443, 0.10116080512571168, 0.11338294202998478, 0.13946205930300526, 0.08630047338603652, 0.0964311929840489, 0.13393081262924422, 0.08838785341494781, 0.11726834143017573, 0.9926960970856441, 0.9649448979374669, 0.9889481073511216, 0.9752578159793505, 0.9795449744295867, 0.9669138305376026, 0.9804893478109362, 0.9936645552420237, 0.9785456987955247, 0.46205823213227837, 0.4608030156903482, 0.36549129762020627, 0.1462603644699495, 0.410874343790553, 0.4401386670504299, 0.5131116526938402, 0.3331232069682757, 0.4575236654135467, 0.3655626337621962, 0.17944095614712163, 0.680532117581542, 0.27303531738410236, 0.6970678212029588, 0.2137993718669544, 0.6626475471718904, 0.22714012482064894, 0.6416144589971036, 0.37702520508626247, 0.20855285714545868, 0.38336061977103986, 0.08471465636845366, 0.1294408221987906, 0.2458262782998506, 0.3905812766987754, 0.2797079748168094, 0.13249263495420238, 0.12508255241717292, 0.36301651724518724, 0.12038541905952771, 0.383485568337245, 0.351857676468208, 0.24675357530404285, 0.4291714284540138, 0.12895185245288865, 0.32260668047120145, 0.05289043828258577, 0.04850893731903083, 0.05063717123065248, 0.0005843883934252281, 9.999999999998899e-05, 0.01267236809276806, 0.2021801958626075, 0.16266522879315293, 0.0057307179323287105, 0.19456748590616346, 0.030978588353379966, 0.3130533358726776, 0.2529480992147489, 0.24646275856407396, 0.20254743366474337, 0.28972779307412166, 0.3014046605187134, 0.27899710697970936, 0.09328446152501313, 9.999999999998899e-05, 0.07420043435720913, 0.11482889793853246, 0.10154581606825963, 0.0772281745502893, 0.16435294511377974, 0.06540903346460636, 0.056349892681442415, 0.11129543527232966, 0.1632415352104184, 0.22044372268358425, 0.2913058258326686, 0.19599750885243916, 0.141057921233271, 0.05171068405119239, 0.046327497340994506, 0.07449809034443367, 0.5726962080540658, 0.5583745147640107, 0.5651051933209806, 0.5637894046174277, 0.5348278337562781, 0.5700608020908449, 0.5771972827472394, 0.5292697609538421, 0.5945343730245967, 0.10768306221913504, 0.08510732074389438, 0.10602270303208439, 0.11946951610211709, 0.1447695553615591, 0.13166225424675826, 0.13775321228936988, 0.11028440040104592, 0.11202708164733044, 0.15684938795629055, 0.166488276295491, 0.16266204255004235, 0.26799497525397387, 0.47192003266026405, 0.352748801260642, 0.14715060282408488, 0.22533714329521015, 0.24243094798072806, 0.27785031483164424, 0.3061453310025556, 0.39277419004613945, 0.3233753547883643, 0.3973486173815425, 0.26148152560818494, 0.3043711269855861, 0.42568165726586693, 0.2772648363038237, 0.2956877425304303, 0.13590702653804188, 0.3120349300588624, 0.3324503110898903, 0.32362632894297294, 0.288691757419852, 0.2977835585612558, 0.26315348880300793, 0.21189403054669365, 0.24694892146387315, 0.21728148469850517, 0.20872495224286858, 0.2484766074777337, 0.19279170120405775, 0.23026876187856937, 0.21706182073931246, 0.21862632133925397, 0.21985153555812387, 0.19418613271869, 0.20035434816682085, 0.19444262152491998, 0.19589683463934893, 0.1797817903723502, 0.22601748207453454, 0.20674619156827656, 0.1843970231449259, 0.19287152076265612, 0.8539734222303578, 0.18785290289220635, 0.18795151933516996, 0.8395621991818001, 0.19861693732623587, 0.20000278942347072, 0.14132783049954378, 0.16277185096053248, 0.8200093161857842, 0.8084069079402724, 0.20973206391376598, 0.07320016477281155, 0.7742901017045469, 0.7449238656621857, 0.6930537555334108, 0.1973061833798041, 0.10473856942605342, 0.7860800970561586, 0.18751394379231578, 0.19390221527615847, 0.1935654330415547, 0.20402227210858803, 0.19811540589167753, 0.18059121822790603, 0.2007800094522526, 0.20177547621524272, 0.18961002079061207, 0.10297164475485043, 0.09360682394491593, 0.085903868474005, 0.09348430058160628, 0.08122550064727196, 0.08796969839346747, 0.0783715804276851, 0.07979972918989009, 0.09661658817126739]}, "mutation_prompt": null}
{"id": "35de379b-b41f-41b6-a27d-049f628b3c90", "solution": "import numpy as np\n\nclass AdaptiveHybridPSOCS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.c1 = 2.0  # Increased cognitive parameter for faster convergence\n        self.c2 = 2.0  # Increased social parameter for faster convergence\n        self.w = 0.5  # Reduced inertia weight for better fine-tuning\n        self.pa = 0.25  # Adding discovery rate of alien eggs/solutions in Cuckoo Search\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize swarm\n        swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_values = np.array([func(ind) for ind in swarm])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - swarm[i]) +\n                                 self.c2 * r2 * (global_best - swarm[i]))\n                swarm[i] += velocities[i]\n                swarm[i] = np.clip(swarm[i], self.lower_bound, self.upper_bound)\n                \n                # Evaluate new position\n                f_val = func(swarm[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = swarm[i].copy()\n                    \n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Cuckoo Search (CS) inspired update\n            for i in range(self.pop_size):\n                if np.random.rand() < self.pa:\n                    # Levy flight\n                    step_size = np.random.standard_cauchy(size=self.dim)\n                    new_solution = swarm[i] + step_size * (swarm[i] - global_best)\n                    new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n                    \n                    f_new = func(new_solution)\n                    evaluations += 1\n                    \n                    if f_new < personal_best_values[i]:\n                        personal_best_values[i] = f_new\n                        personal_best[i] = new_solution.copy()\n                        \n                        if f_new < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n        \n        return global_best", "name": "AdaptiveHybridPSOCS", "description": "An adaptive hybrid algorithm integrating Particle Swarm Optimization (PSO) with Cuckoo Search to enhance convergence by balancing exploration and exploitation dynamically.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "66e2f758-2bbf-4427-9c12-c1e8ccb82c80", "metadata": {"aucs": [0.8802287967000919, 0.8790613909684096, 0.876167958913536, 0.8704845698420642, 0.8703058331292444, 0.8630964457973471, 0.8790181164551539, 0.8585749700694217, 0.860317742546428, 0.5698429743978022, 0.530857582361846, 0.470284058293128, 0.6522640244395719, 0.645886190532178, 0.6389480283705098, 0.6703583467728993, 0.05206221783371401, 0.6129481624811166, 0.13472725991423173, 0.17677966070879758, 0.09105560513188593, 0.09175701027290017, 0.14032746810214902, 0.14292660164005266, 0.10743112194641213, 0.14713800115820885, 0.12378355958012177, 0.07497971156841854, 0.09138379069388025, 0.09811089657393146, 0.08846149338569753, 0.10951900677214976, 0.13334997579799635, 0.10510985621353341, 0.14278934346102634, 0.13660947885007868, 0.9940073169609276, 0.9877508276747458, 0.9947455839417267, 0.9883424102871016, 0.9922797549635488, 0.9887745250961768, 0.9900886007603981, 0.9927406160251483, 0.993456594738186, 0.657887163303935, 0.673134934500668, 0.0585107969239983, 0.5958876406930873, 0.6656054466847252, 0.5084801927595524, 0.6003166818945223, 0.5905142592143116, 0.588244600614163, 0.8290942730819119, 0.22969119895471524, 0.8371212966333079, 0.19519196894030255, 0.2769178010807716, 0.2151585795495452, 0.12668087213719315, 0.18592308057209617, 0.23144187267978145, 0.6907745640147286, 0.5399238527653798, 0.7374583506677364, 0.09937084445211075, 0.135343448537254, 0.5833849875272199, 0.6367055410895733, 0.5570570598112723, 0.6315995505520924, 0.7086838779894125, 0.6981187799166132, 0.1342009717868632, 0.6428987352164661, 0.6751082927982426, 0.6077554281977358, 0.6938194415682335, 0.1314083285265054, 0.5144771494481537, 9.999999999998899e-05, 0.06147605681646806, 0.5564654951407437, 9.999999999998899e-05, 0.5348554753292387, 0.15140145209935252, 0.3609831721490955, 0.5390286392845989, 0.4934051114984569, 0.6003353745117013, 0.13310253983899334, 0.4290503943692421, 0.4137788154356603, 0.1757168233638957, 0.08456174215875545, 0.558221561086407, 0.45604034434396346, 0.10711225662247326, 0.0866572177688002, 0.10580180931424765, 0.20177942672773674, 0.2731342261865739, 0.07550282998213753, 0.07458066186593937, 0.0952490894603727, 0.14456057085012797, 0.07061314324970813, 0.23612506471389583, 0.36361479959979937, 0.04288496168477118, 0.006464721552709829, 0.4261487748615248, 0.4207026722765408, 0.2602860412540219, 0.08311327772993005, 0.08278613027330706, 0.7466495882291204, 0.7627133564510042, 0.7651782210935935, 0.7716192881621367, 0.8081651213960513, 0.7781985736115757, 0.7435938094573789, 0.7751750366307876, 0.7415387752977955, 0.14511945890757338, 0.1247307046785674, 0.07446151769380482, 0.10201575286122444, 0.15603205294124278, 0.09270479945558041, 0.10634660348886305, 0.1099711291617399, 0.1308902579238469, 0.14602545275820944, 0.26978648894328605, 0.2176428579467642, 0.2995065932817007, 0.3574746074159101, 0.2704476314131905, 0.5316086484853102, 0.180541834202692, 0.20649053513291626, 0.3897063009207078, 0.3976386425999844, 0.3375468290609448, 0.48419592180774873, 0.3408800563167602, 0.5457550057885706, 0.1969163677207867, 0.4460525290834424, 0.3809451986228787, 0.24342560754068399, 0.34565496492132475, 0.20404278576206158, 0.3300953307636709, 0.2591682358097136, 0.2636118259564283, 0.24370955563334873, 0.2599820937340114, 0.2973546592393851, 0.21609920310623887, 0.15603275421954876, 0.20952694856137055, 0.2540193926026313, 0.2215362491568318, 0.2467234435410871, 0.24100824190507442, 0.2262741854804381, 0.21027734703709466, 0.18176035118477463, 0.20693410757423514, 0.21800673531246384, 0.2160686761101488, 0.19281393564536953, 0.1849317925686218, 0.17217724978585758, 0.18301782003311662, 0.18411939202408, 0.16600553587094657, 0.168997937928126, 0.18848457454662604, 0.8944511793339018, 0.20216834256191618, 0.20071601034979203, 0.1429954110783478, 0.16523789738966044, 0.9296701194156133, 0.8859791003820047, 0.21232737412823632, 0.15494758092575667, 0.21060584340758992, 0.16966568340041233, 0.15431396581477042, 0.21132247779922098, 0.18901573476386013, 0.8260647506517949, 0.19338041214396695, 0.21158471438763493, 0.2050736330662175, 0.2020878151101484, 0.19622745019452525, 0.1970795804078268, 0.19485328201597374, 0.2262298571533956, 0.21955364246274645, 0.06888307639836455, 0.08071684185080974, 0.0865818430032197, 0.1427664835200212, 0.07856869675936373, 0.10355967667943655, 0.09896868599706543, 0.08183440749892357, 0.08362650810950978]}, "mutation_prompt": null}
{"id": "d0bbef38-b2de-48cb-9886-b8565f879a48", "solution": "import numpy as np\n\nclass EnhancedHybridPSOCS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w = 0.5\n        self.pa = 0.25\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.temperature = 1.0  # Initial temperature for simulated annealing effect\n\n    def __call__(self, func):\n        swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_values = np.array([func(ind) for ind in swarm])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            # Simulated Annealing-inspired cooling\n            self.temperature *= 0.99\n            \n            # PSO Update with adaptive parameters\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.c1 = 1.5 + 1.5 * self.temperature  # Dynamic adjustment\n                self.c2 = 1.5 + 1.5 * self.temperature\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - swarm[i]) +\n                                 self.c2 * r2 * (global_best - swarm[i]))\n                swarm[i] += velocities[i]\n                swarm[i] = np.clip(swarm[i], self.lower_bound, self.upper_bound)\n                \n                f_val = func(swarm[i])\n                evaluations += 1\n                \n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = swarm[i].copy()\n                    \n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Modified Cuckoo Search inspired update\n            for i in range(self.pop_size):\n                if np.random.rand() < self.pa * self.temperature:\n                    step_size = np.random.standard_cauchy(size=self.dim)\n                    new_solution = swarm[i] + step_size * (swarm[i] - global_best)\n                    new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n                    \n                    f_new = func(new_solution)\n                    evaluations += 1\n                    \n                    if f_new < personal_best_values[i]:\n                        personal_best_values[i] = f_new\n                        personal_best[i] = new_solution.copy()\n                        \n                        if f_new < personal_best_values[global_best_idx]:\n                            global_best_idx = i\n                            global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n        \n        return global_best", "name": "EnhancedHybridPSOCS", "description": "Introducing a simulated annealing-inspired cooling mechanism and dynamic parameter adjustment to enhance AdaptiveHybridPSOCS's convergence speed.", "configspace": "", "generation": 13, "fitness": 0.26989326962835036, "feedback": "The algorithm EnhancedHybridPSOCS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.24.", "error": "", "parent_id": "66e2f758-2bbf-4427-9c12-c1e8ccb82c80", "metadata": {"aucs": [0.7108672261857105, 0.7042629440680752, 0.7061636238580272, 0.19064026267912937, 0.7410564623354241, 0.7254670869918629, 0.7122811810248394, 0.7155667497247673, 0.6865688332465623, 0.39943353840241935, 0.3561254908392958, 0.03371723751651645, 9.999999999998899e-05, 0.19170038444383675, 0.41005022934421953, 9.999999999998899e-05, 0.0444021471026117, 0.4054331826530603, 0.10871816166427473, 0.16044139906233834, 0.10316382599302265, 0.14937737921908534, 0.10842324590984698, 0.11891513355559291, 0.09185768626028346, 0.12366721454267904, 0.10581573432886415, 0.10313912006195203, 0.0899495013518341, 0.12367349233723601, 0.1319542350895897, 0.08307881485243873, 0.09307886023797995, 0.10187704151420751, 0.08680290329786855, 0.10530719465195837, 0.9939978524879192, 0.9898002591674646, 0.9947430205524077, 0.983104635276349, 0.9942867150378883, 0.9887862045654117, 0.9942685911298393, 0.9936785140246859, 0.9945207410244399, 0.41453379781260224, 0.3624953273952689, 9.999999999998899e-05, 0.4223171968571773, 0.29583177370146907, 0.2486255030192962, 0.2959927709395024, 0.4355216736125431, 0.4094795920071411, 0.1715278397065766, 0.7512338241710946, 0.2240278059080142, 0.1922242235081757, 0.19700151183343884, 0.19253082994619075, 0.0677421651373652, 0.5354529418812868, 0.5807386656707572, 0.12429411721646777, 0.37251453283162006, 0.3640233916331994, 0.09362960639794238, 0.4465355179022983, 0.3942373287921157, 0.3660137218403804, 0.4472173126616612, 0.4926876404090518, 0.4532452619409101, 0.4511871191232215, 0.12479901911583324, 0.42148180019156956, 0.13169502137406708, 0.13206573762439588, 0.38199345837436305, 0.11888841066837685, 0.0615731962990228, 9.999999999998899e-05, 0.023912359019196416, 0.058259798107178185, 9.999999999998899e-05, 9.999999999998899e-05, 0.03203857172729763, 0.24250222851352343, 0.06266299407827303, 0.22476471769879902, 0.0464240547008169, 0.17003787964435146, 0.29112419136447276, 0.20242980913498154, 0.07734506821280263, 0.10737773685785601, 0.08997343315286177, 0.0529049735757422, 0.20198744612536024, 0.035358328765848435, 9.999999999998899e-05, 0.18349393963546667, 0.16307945331522022, 0.12895275932067873, 0.054119052450990246, 9.999999999998899e-05, 0.22467066834667504, 0.06659352754929604, 0.17362437937637076, 0.13748275392429077, 0.10511401798310815, 0.005571875853974229, 0.16250958259553394, 0.11202162612223787, 0.07529870456750976, 0.046513732269452546, 0.07585032731063734, 0.6157026565717626, 0.5760899101939863, 0.5853013958833613, 0.613924319437368, 0.6039876573053844, 0.599990531473986, 0.6025866427565063, 0.5521554767396033, 0.5856048227627646, 0.051009722962198634, 0.050049214117147356, 0.0924799639388395, 0.09670809482464882, 0.0882458280160956, 0.10914500129530758, 0.1003004643584754, 0.11127674232532958, 0.1139497721061411, 0.16094766046618392, 0.20245356372823875, 0.1681372753313941, 0.22713445012516786, 0.2824498030297955, 0.1445318880014118, 0.18952874614928994, 0.17559752600935696, 0.2585884559218554, 0.2938361436529684, 0.24769897932507234, 0.3413279283804599, 0.292554667987621, 0.2729497531104048, 0.28785261488334657, 0.30505370039905233, 0.3167054437207898, 0.34526945591261493, 0.20338230275197944, 0.19398727471232702, 0.20678813697527376, 0.2719509931190368, 0.2568887478886671, 0.25887710062475067, 0.2478202796210327, 0.2567214933818427, 0.2552698651177009, 0.20502689362230475, 0.227160286552201, 0.2158776369488017, 0.2104217834897696, 0.23955659241284077, 0.19661836937453359, 0.21804362246518572, 0.2151649390459559, 0.23980514198198044, 0.2045813083192879, 0.20484826804323752, 0.18857743665617854, 0.22589016826252206, 0.18654170728338249, 0.23045770898381002, 0.20096880239257808, 0.21060911665453552, 0.1959358456576935, 0.7961852237069762, 0.17053297924132826, 0.1536722016335822, 0.7422123216646974, 0.19876776289638864, 0.1840211481871472, 0.14183653774580596, 0.17295908257604475, 0.7732894390635426, 0.837948691002141, 0.20699683492869103, 0.19911792965403996, 0.2016324148849632, 0.16859306995967105, 0.1543805025427344, 0.20500514052386098, 0.191267423245293, 0.17324162061947646, 0.18581642458406888, 0.20011014626981805, 0.1831508550892592, 0.19559450616084217, 0.1989256657233366, 0.1825192534631539, 0.19800099659668124, 0.21981622142967594, 0.18233082292578673, 0.09383788808269178, 0.0886441155450528, 0.0896188404927003, 0.08827921614753087, 0.07754949304095948, 0.08888041992014262, 0.09273105740193988, 0.08066645446725418, 0.08959175634405614]}, "mutation_prompt": null}
{"id": "e1d14c89-a674-40b8-a0b0-516b5cb6edfe", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.f = 0.8  # Differential weight\n        self.cr = 0.9  # Crossover probability\n        self.c1 = 1.5  # Cognitive parameter\n        self.c2 = 1.5  # Social parameter\n        self.w = 0.7  # Inertia weight\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            # Differential Evolution (DE) inspired update\n            for i in range(self.pop_size):\n                indices = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, population[i])\n                \n                f_val_trial = func(trial)\n                evaluations += 1\n                \n                if f_val_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_val_trial\n                    personal_best[i] = trial.copy()\n                    \n                    if f_val_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            # PSO Update\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n                \n                # Evaluate new position\n                f_val = func(population[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n                    \n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n        \n        return global_best", "name": "EnhancedHybridDEPSO", "description": "An enhanced adaptive hybrid algorithm integrating Differential Evolution with PSO to accelerate convergence via diversity maintenance and dynamic parameter adjustments.", "configspace": "", "generation": 14, "fitness": 0.26863498611985187, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.23.", "error": "", "parent_id": "66e2f758-2bbf-4427-9c12-c1e8ccb82c80", "metadata": {"aucs": [0.7011808519035534, 0.6817646074727315, 0.7110141373988569, 0.6852062618877031, 0.6985104726844109, 0.6943885460599053, 0.6730307605733448, 0.6910678910962683, 0.7295264954839523, 0.2319451528040567, 0.2369962657713489, 0.19549776807423447, 0.07484874585998491, 9.999999999998899e-05, 0.0340911725387858, 0.24739681879002717, 0.17913217330135067, 0.0401318541979756, 0.12768474594374823, 0.13168958943717624, 0.1275302736283822, 0.1654766420636975, 0.14588900942188798, 0.07513491494220326, 0.09363696821066847, 0.10398018784477447, 0.13462192097497505, 0.08621388714136335, 0.08454026153285832, 0.10056632386506026, 0.11287222078674508, 0.10292580760427117, 0.09204778033715377, 0.1297461995066136, 0.11698774940151668, 0.11807455564128722, 0.9890602659006915, 0.9900498830698867, 0.9880329355745323, 0.9810350113979556, 0.9863256366954464, 0.9615775301643066, 0.9795483822922898, 0.9890533864887938, 0.9872496478147091, 0.432674642792485, 0.4105718351340909, 0.43552563402207056, 0.38170931141166065, 0.3113741055437398, 0.14558571805083342, 0.40735329072700754, 0.3681281178450606, 0.3638798548908265, 0.7537760000275682, 0.22402119172572266, 0.5777586866428435, 0.20209967463486445, 0.7900787323943216, 0.214710729571448, 0.6123758146546981, 0.6569317706479444, 0.16901030018012897, 0.2471816469560698, 0.10320558499227006, 0.24766018489541908, 0.10371917551102217, 0.23295668915705303, 0.10077439790141085, 0.3167086530970805, 0.39770447034536205, 0.12782517650380631, 0.30160857870222424, 0.28217945551032175, 0.23207450916926675, 0.30346958959134385, 0.34701527388426057, 0.3491078897334976, 0.3307114985120646, 0.3591557970733644, 0.2744680269763682, 0.0944744714262955, 0.0019108177868781828, 0.060877654006099124, 0.06384956334929193, 0.03205448713490189, 0.14357489991199202, 0.1379973588753559, 0.1595179074343709, 0.13697196924021848, 0.10175701708384244, 0.0823086491469236, 0.08655475334136464, 0.05223507333662003, 0.21617745027930402, 0.0782416978328534, 0.18289686945016215, 0.23288903524040216, 0.02185128424499505, 0.14642999536238765, 0.02770976021185456, 0.09767914330959715, 0.05588462587865928, 0.0912609050173604, 0.058855082465078756, 0.08045729943239455, 0.15285673563365998, 0.05264702775941965, 0.16510101282741163, 0.11543223732557306, 0.1400461021456496, 0.005572039542682483, 0.12996688414450253, 0.13629786358113705, 0.07514766022690367, 0.19284609708921885, 0.07770777345087276, 0.49492610399647374, 0.4979236920277059, 0.5594991453648162, 0.5109837861436834, 0.5217641932353668, 0.5248831515122436, 0.5550157246143763, 0.5021016753921204, 0.49854970542437016, 0.07518352699016106, 0.11490000177459592, 0.07643453022585467, 0.10291873909078819, 0.10782413723265927, 0.1052806233707484, 0.10636482860934315, 0.13818542417219104, 0.08771012289602154, 0.29807020931877304, 0.1910460755239517, 0.1989318636935694, 0.23333843898926765, 0.23952142392157416, 0.18094351181236612, 0.16606667057194668, 0.21579554029582082, 0.2466773236059907, 0.3546768148080004, 0.29118895937736233, 0.3311922725203632, 0.359482232730438, 0.24513437757231915, 0.3102251628019147, 0.3629289694833565, 0.376792518782055, 0.2016815523758082, 0.21119312127352752, 0.26063645745626585, 0.21047414990846058, 0.2750690274966048, 0.2128670818459225, 0.2769246208862869, 0.28595192243891254, 0.27199688677798817, 0.2662496391539898, 0.2468050617494839, 0.20304774730900566, 0.19085023544628366, 0.2128096085238641, 0.20694790390962314, 0.30023640676010155, 0.19323580178307875, 0.21398029215968084, 0.21222794316752858, 0.19774799691211264, 0.19252539395576396, 0.18201424080855422, 0.2049144573329279, 0.19217071645166006, 0.21160428814733434, 0.18131853779215845, 0.19642195590258948, 0.18256691911258027, 0.1858640010222946, 0.16512463863722338, 0.20387919623928952, 0.1985708103849797, 0.19926272393912792, 0.2048196096854843, 0.7993525885001689, 0.14738053915023175, 0.16682564978504455, 0.7380677072853021, 0.21004226243228385, 0.2045919046222494, 0.7501684351095002, 0.1126799359901004, 0.1666451922115364, 0.2077483768010796, 0.1230929458546558, 0.08261959019015686, 0.18047338489889664, 0.20003342843598926, 0.22058638580744505, 0.1977356580572942, 0.2057105579937255, 0.1976422022389872, 0.1888698842030906, 0.18832057063735652, 0.21101957325682374, 0.08943052004470242, 0.07910436736724036, 0.09712827399269208, 0.0813974654971582, 0.07933660357051708, 0.07881312869839241, 0.0789890425152453, 0.09534906531219689, 0.10103642928161116]}, "mutation_prompt": null}
{"id": "6e78e5e1-cff4-4b46-88eb-3a56c47151a9", "solution": "import numpy as np\n\nclass AdaptiveHybridDECS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.F = 0.7  # Mutation factor for Differential Evolution\n        self.CR = 0.9  # Crossover probability for Differential Evolution\n        self.pa = 0.3  # Discovery rate of alien eggs/solutions in Cuckoo Search\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness_values = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness_values)\n        best_solution = population[best_idx]\n        \n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            # Differential Evolution (DE) Update\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                f_trial = func(trial)\n                evaluations += 1\n                \n                if f_trial < fitness_values[i]:\n                    fitness_values[i] = f_trial\n                    population[i] = trial\n                    \n                    if f_trial < fitness_values[best_idx]:\n                        best_idx = i\n                        best_solution = population[best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Enhanced Cuckoo Search (CS) inspired update\n            for i in range(self.pop_size):\n                if np.random.rand() < self.pa:\n                    step_size = np.random.standard_cauchy(size=self.dim)\n                    new_solution = population[i] + step_size * (population[i] - best_solution)\n                    new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n                    \n                    f_new = func(new_solution)\n                    evaluations += 1\n                    \n                    if f_new < fitness_values[i]:\n                        fitness_values[i] = f_new\n                        population[i] = new_solution\n                        \n                        if f_new < fitness_values[best_idx]:\n                            best_idx = i\n                            best_solution = population[best_idx]\n\n                if evaluations >= self.budget:\n                    break\n        \n        return best_solution", "name": "AdaptiveHybridDECS", "description": "A dynamically adaptive hybrid algorithm combining Differential Evolution with enhanced Cuckoo Search for improved exploration and convergence speed.", "configspace": "", "generation": 15, "fitness": 0.2816770963119251, "feedback": "The algorithm AdaptiveHybridDECS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "66e2f758-2bbf-4427-9c12-c1e8ccb82c80", "metadata": {"aucs": [0.6457142189527678, 0.6321856268659725, 0.6529703548581623, 0.6739382256236106, 0.6969046856938141, 0.6600750444177654, 0.7179532956905196, 0.6727981204659288, 0.6777335227638113, 0.4736706602836449, 0.42911319611627563, 0.44272382896211915, 0.4367583538636389, 0.4376052561508843, 0.43939308606551997, 0.444736655548714, 0.46026997581487583, 0.41940189410679773, 0.11967199917011928, 0.11037052911494427, 0.10718169137027489, 0.1014561174046632, 0.1017476821448261, 0.0869513271393263, 0.10316499728468076, 0.09859985997278531, 0.10051155533149303, 0.114141157074794, 0.10245639457185973, 0.08300507564727122, 0.09002271249115401, 0.08079850706308589, 0.0914808044632599, 0.08620144830701226, 0.09248721741626853, 0.08761726446609441, 0.9688768139126395, 0.984570700496051, 0.9666202935370323, 0.9552230349603379, 0.979902630895249, 0.967290529903088, 0.9500490544061595, 0.9621016476912959, 0.9555747307047336, 0.3167899282633644, 0.29207473266074424, 0.27737794368231783, 0.2991735604580903, 0.2945633965606006, 0.291047093699648, 0.3105556874293762, 0.3112676961733206, 0.3195913684021432, 0.610520051002489, 0.5675707069176991, 0.5584509006271592, 0.6250045403788168, 0.6128621446433279, 0.5720932620293819, 0.5445781269971977, 0.6671978125059905, 0.5828206080711615, 0.20680274941175325, 0.17223659806414748, 0.1878207833227291, 0.20233807794607084, 0.23654792202537622, 0.1681917790049996, 0.23677078730443912, 0.19762656165507952, 0.1989397820674691, 0.15797755486160936, 0.24764615815451785, 0.21115179531024586, 0.21908678978547225, 0.200271418917778, 0.16801964870827046, 0.1503701926419999, 0.19819216730820421, 0.23451237009152315, 0.14095627028309077, 0.1366711204872061, 0.11696016331371561, 0.14817634274325353, 0.12936315633310647, 0.13818420367006978, 0.1320161203260135, 0.12306661726424262, 0.15592808668006364, 0.2773667444274086, 0.25849338867131955, 0.23899612253035007, 0.24121052653357744, 0.2728788301936601, 0.2989145859954693, 0.2725962379522323, 0.2862543291188413, 0.2567546298540706, 0.03319516438700798, 0.02619770218208195, 0.017732261107113678, 0.03986219915454947, 0.05292523398260185, 0.04416075383709084, 0.04312665762262946, 0.0399782658170168, 0.03854464315218664, 0.15869487583024988, 0.15282950256444305, 0.17174005917730262, 0.15845306208081855, 0.19507237659707255, 0.18621150230946504, 0.14955395007590178, 0.17646428756621846, 0.1951044784680228, 0.4943484552206965, 0.5181260457533765, 0.4954384032269391, 0.4959831837406611, 0.5265201762865117, 0.5109659762065724, 0.5193746189589439, 0.4995954013831665, 0.4975198856360885, 0.08329269070512824, 0.09339610923466879, 0.10206263594562937, 0.10769155044089662, 0.09920633733157325, 0.07847210788572778, 0.08079246859497324, 0.09212942180553241, 0.08354713302796213, 0.16933982372373024, 0.1545125510531289, 0.13823708938625057, 0.12054878802149582, 0.20316677705976094, 0.18662630140097025, 0.15112115436336482, 0.1423523691818508, 0.1351021192964419, 0.3145132290275062, 0.3050041955169258, 0.2982752344533307, 0.2932418698141137, 0.25864881637163695, 0.2780926199450574, 0.28955756411994493, 0.309630335547158, 0.2874287056283985, 0.22180626169446338, 0.21467423432490673, 0.21812530128149465, 0.21415358731900935, 0.19956669120641302, 0.21171181273678863, 0.25048220936973, 0.22468089149750736, 0.23951828925683072, 0.18056805858073743, 0.19677046835892742, 0.17901627984856772, 0.18912719497870534, 0.21929415295212407, 0.19350597346147158, 0.17627074602557846, 0.18537030812535016, 0.19137998856706573, 0.24868517807382873, 0.187089796964093, 0.17203621663227664, 0.17668952830318363, 0.17442050769120654, 0.1751896990018571, 0.1790930638165228, 0.16597852058911633, 0.1920380978922953, 0.5972241542360324, 0.6142100438373176, 0.700577652408996, 0.4487867121172818, 0.17712297410949918, 0.16125098340711097, 0.3589483927339029, 0.30230689302581215, 0.24985064133334867, 0.45297373161291565, 0.20036258730167267, 0.16449045332803325, 0.1955700552711278, 0.33367092280027955, 0.17466378386320702, 0.20652847571128585, 0.5788736851513805, 0.20596301237828618, 0.18995159357608404, 0.17918686997630817, 0.18345247676512744, 0.18711503594799872, 0.179103199567322, 0.17719994026352814, 0.19496966884647116, 0.19222544800365415, 0.1897661539020491, 0.07287508651306251, 0.06845899384129484, 0.06621331717782764, 0.06929209885148935, 0.07212531224309482, 0.06898274316674502, 0.07352884123132952, 0.0786434093196583, 0.06998332714982347]}, "mutation_prompt": null}
{"id": "342ac622-d0e0-4b5f-8cf2-879860e882d4", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.c1 = 1.5  # Adjusted cognitive parameter for balanced exploration\n        self.c2 = 1.5  # Adjusted social parameter for balanced exploration\n        self.w = 0.7  # Increased inertia weight to maintain diversity\n        self.f = 0.5  # Mutation factor for differential evolution\n        self.cr = 0.9  # Crossover probability for differential evolution\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize swarm\n        swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_values = np.array([func(ind) for ind in swarm])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - swarm[i]) +\n                                 self.c2 * r2 * (global_best - swarm[i]))\n                swarm[i] += velocities[i]\n                swarm[i] = np.clip(swarm[i], self.lower_bound, self.upper_bound)\n                \n                # Evaluate new position\n                f_val = func(swarm[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = swarm[i].copy()\n                    \n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Differential Evolution inspired update\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, swarm[i])\n                \n                f_trial = func(trial)\n                evaluations += 1\n                \n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n                    \n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n        \n        return global_best", "name": "HybridPSODE", "description": "A hybrid algorithm that combines Particle Swarm Optimization with Differential Evolution to enhance global search capabilities and convergence speed through adaptive parameter control.", "configspace": "", "generation": 16, "fitness": 0.27701507009929877, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.23.", "error": "", "parent_id": "66e2f758-2bbf-4427-9c12-c1e8ccb82c80", "metadata": {"aucs": [0.6856436328600006, 0.6948666631744433, 0.7182413202490652, 0.6861069459522134, 0.7418032439524461, 0.7330212926805146, 0.6803711287450698, 0.704343992189818, 0.6939743544652295, 0.2042189586270442, 0.15352447960466575, 0.22556631684959405, 0.20265586402168, 0.20101946816365723, 0.22383996536629824, 0.23694037762168885, 0.2073021837812189, 0.033376593725712556, 0.13023908852768507, 0.1441135790391772, 0.10243337048734336, 0.18339551963707745, 0.1239757264003114, 0.1227388827590179, 0.10467169254110109, 0.12329465117623373, 0.1015564639814378, 0.09683145427558215, 0.09850730610500502, 0.08978225416055774, 0.0968384056080196, 0.09121651247538098, 0.0997193807468848, 0.13214944210685664, 0.13723025943364087, 0.07456834169425475, 0.993125016585559, 0.9828096291534151, 0.9940204739628151, 0.9410220555317502, 0.9835413475777359, 0.972712202359665, 0.9912492624563116, 0.9848116427260355, 0.9823511497439251, 0.46964527836903325, 0.4520698417542759, 0.3806117580701589, 0.1492211146145801, 0.2816471259787603, 0.23833141245101663, 0.17829968212076952, 0.08859377276357172, 0.49408680399230964, 0.21882529319947874, 0.22564308630809404, 0.22217793193200885, 0.7089800742670738, 0.2752900474687704, 0.26237204859571317, 0.22184655716152535, 0.2309933550939952, 0.6968860436858495, 0.32053499703806665, 0.2764927454104339, 0.1097976054922245, 0.10386947622056564, 0.1284636037948037, 0.17402321726272896, 0.3040909025492896, 0.3934131339372329, 0.34626424022502145, 0.36985359513222904, 0.28654015413160083, 0.34944714307805347, 0.3612252343029553, 0.3414140513419601, 0.12410628675335733, 0.27631694383181327, 0.3689172151055763, 0.36825010949914627, 9.999999999998899e-05, 0.03500496758181704, 9.999999999998899e-05, 0.024857684181456507, 0.15893621662587143, 0.12285997987286268, 0.1653409533565302, 0.16767935689450408, 0.062478873351199615, 0.23751871572847616, 0.22876688896520903, 0.26777381020462554, 0.14473905100979045, 0.12494050411054358, 0.24692695985654056, 0.2161106205199027, 0.24910012916188884, 0.18423022156389424, 0.03582618498602663, 0.05709404273772012, 0.03871138081938208, 0.10261831391310317, 0.059046306325326814, 0.06141970982574052, 0.07107901927151239, 0.19637451273690698, 0.14051731208094098, 0.15356456701863375, 0.23370402786599254, 0.15264176731292622, 0.005730721307749653, 0.14727183234967178, 0.14820370353020718, 0.1806570328648922, 0.19555361134345028, 0.07577400173362969, 0.5030286492203875, 0.518042801568849, 0.5438713829885395, 0.5496224670048558, 0.5369242585431007, 0.48948810492967343, 0.5266849567588018, 0.563711402991902, 0.5489765099908344, 0.1461877713702514, 0.10347799636615673, 0.09763189420277907, 0.08390047551263646, 0.10574763729748304, 0.11546349753156648, 0.11210265558461974, 0.13359021527044446, 0.12356467329416732, 0.44966644109710174, 0.2392403781851251, 0.21119898296545947, 0.21494787780206626, 0.28285113449989663, 0.18550084783569232, 0.406219644610717, 0.18484437430065948, 0.20167979738272857, 0.3647301793833302, 0.31249972152646077, 0.37930122538699396, 0.3107270188559249, 0.3555114562417774, 0.3470535822359072, 0.29197214248322734, 0.41985710235793827, 0.37100004470553727, 0.2002553393347376, 0.24729189124132567, 0.2062534336601901, 0.2428865031127312, 0.1720315632117898, 0.25225127234158595, 0.20549200617655838, 0.2368504611066634, 0.34666607985760356, 0.22248410599309076, 0.18988138887386907, 0.2431502885975867, 0.18603328740025926, 0.2320773506061602, 0.22289070873352546, 0.21662328682229537, 0.22428629222027008, 0.2249469150577259, 0.20550335541626408, 0.21535539482812371, 0.19126241059813098, 0.289807853079753, 0.1992875958726671, 0.1928594106798387, 0.27560710689541223, 0.1974252287803292, 0.1778124170070221, 0.8575635486241365, 0.16830825255781856, 0.18285335161722016, 0.17227747341715494, 0.19946070538310623, 0.19986519334136799, 0.1423581334181746, 0.16036268346246108, 0.2102360970644337, 0.7991100817410627, 0.21090705173816837, 0.07207777470180876, 0.7113192469645127, 0.16907793602850074, 0.15439455773135147, 0.1980025444843997, 0.1681122652857837, 0.7804665531140969, 0.17514643978562128, 0.19190707399171303, 0.19964785135679064, 0.2160208612312463, 0.18632142228236626, 0.1925009808824022, 0.19697593012416192, 0.18030005491996903, 0.2006258742724779, 0.08227529533821376, 0.09369659209539427, 0.08336923018257325, 0.09665108824994273, 0.08209806593082447, 0.08240872880683714, 0.09590809024989011, 0.08929233028745276, 0.08774677376988727]}, "mutation_prompt": null}
{"id": "369a72b8-dc86-445f-b9cf-e776ef4b9d9c", "solution": "import numpy as np\n\nclass AdaptiveHybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.c1 = 1.5  # Reduced cognitive parameter for better exploration\n        self.c2 = 2.5  # Increased social parameter for stronger convergence\n        self.w = 0.4  # Further reduced inertia weight for tighter convergence\n        self.pa = 0.25\n        self.pm = 0.1  # Probability of mutation\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n                \n                # Evaluate new position\n                f_val = func(population[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n                    \n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Genetic Algorithm-inspired crossover and mutation\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Crossover\n                mate_idx = np.random.randint(0, self.pop_size)\n                offspring = 0.5 * (population[i] + population[mate_idx])\n                offspring = np.clip(offspring, self.lower_bound, self.upper_bound)\n                \n                # Mutation\n                if np.random.rand() < self.pm:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    offspring += mutation_vector\n                    offspring = np.clip(offspring, self.lower_bound, self.upper_bound)\n                \n                f_offspring = func(offspring)\n                evaluations += 1\n                \n                if f_offspring < personal_best_values[i]:\n                    personal_best_values[i] = f_offspring\n                    personal_best[i] = offspring.copy()\n                    \n                    if f_offspring < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n        \n        return global_best", "name": "AdaptiveHybridPSOGA", "description": "A novel algorithm combining Adaptive Particle Swarm Optimization with Genetic Algorithm-inspired crossover and mutation strategies for enhanced exploration and exploitation.", "configspace": "", "generation": 17, "fitness": 0.36633529916621016, "feedback": "The algorithm AdaptiveHybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.27.", "error": "", "parent_id": "66e2f758-2bbf-4427-9c12-c1e8ccb82c80", "metadata": {"aucs": [0.8397418837153936, 0.8219077954867684, 0.8200851189796995, 0.8293540717051241, 0.8331136988801541, 0.8440936413417229, 0.7989270043590464, 0.8123815535954868, 0.811812511931884, 0.5024732682433466, 0.03881945868431069, 0.24909860747114354, 0.4960520662889487, 0.2684245064215868, 0.5313993619852697, 0.5147652733887206, 0.45913093233299385, 0.5211027404758446, 0.10451265112753227, 0.14553428912434696, 0.10907892605223457, 0.11459017474770539, 0.11402574511619279, 0.06706193752915257, 0.13268596727580895, 0.11274775029921946, 0.13523513603929604, 0.06188005882402281, 0.09080980964180985, 0.15636275281779421, 0.11795458553169158, 0.09698253175803162, 0.0700588479486316, 0.1061088958307349, 0.1265310774025975, 0.10829771195484605, 0.9939945487250831, 0.9837230391776156, 0.9948331320789607, 0.9655467965643901, 0.9941953665797865, 0.964754009927252, 0.9940812094921004, 0.9843462137853096, 0.9945141658321802, 0.6147558549153556, 0.6062143364621684, 0.3748568165271493, 0.5224244122150119, 0.5689045655286895, 0.5610481190473113, 0.580417888788195, 0.5787635028493059, 0.6044307006124278, 0.8319049116339204, 0.7805870705406932, 0.2151317862276657, 0.8542277259617908, 0.8667514906674918, 0.1830840423015453, 0.1503514385920771, 0.20875023508097668, 0.1765826241114108, 0.5674100641605998, 0.5922824805115328, 0.5856792740338312, 0.10748714589706265, 0.5918554409225637, 0.11294197962965113, 0.5765640532962303, 0.5657678116936362, 0.4576918790632144, 0.4659332140292237, 0.4374315860738013, 0.6989694172295622, 0.6065025072992156, 0.630221813832365, 0.5464111936028264, 0.4515390124539176, 0.5654391216522283, 0.1168271631918848, 0.1693209822191648, 0.05330977191094277, 0.06714359819152471, 0.04303324448738399, 0.2577098100408881, 0.3678815058120726, 0.32990166417968936, 0.22612563510664507, 0.48954970821892496, 0.5457981600359109, 0.49727278713908163, 0.36753483320672675, 0.37418184089217044, 0.3146330939447457, 0.5655936525302618, 0.3616032386905501, 0.5103267176518821, 0.4993551582383048, 0.11337958745811116, 0.10204991398087948, 0.04550902137402968, 0.30143139470353586, 0.18536269705608566, 0.4548443131510217, 0.09147703105449778, 0.16576568031106131, 0.268114654441972, 0.22805860879199613, 0.3385075505909002, 0.17421409496315698, 0.37423568201987245, 0.363104995930834, 0.2687696099964695, 0.3385514101016933, 0.36102644790232086, 0.08075315034224295, 0.6835610689842578, 0.6892886723542099, 0.7512625183304485, 0.7156083775439641, 0.6589488763734093, 0.7687968410988684, 0.6954265050464843, 0.6716929411758665, 0.7256082988792611, 0.0788497479608814, 0.12494888358382339, 0.1185174042534678, 0.13380456134290564, 0.10249108213700586, 0.10544929279851933, 0.09515466700604391, 0.1116028673538465, 0.10073354562322767, 0.19505295652955923, 0.22801902398276042, 0.17742304078849103, 0.4941923226354249, 0.5159147110871642, 0.2982222992478044, 0.2904889995572967, 0.2266071652425401, 0.26156429626300326, 0.35817139991342595, 0.40755755855107423, 0.4448688682145633, 0.34070371755316664, 0.42384010683302586, 0.398444995959531, 0.22227455131875262, 0.5196167001656375, 0.35520623324188005, 0.3816931885993744, 0.20848832665659078, 0.20036285552122401, 0.1511678098238204, 0.26722651294717625, 0.2601602906254623, 0.32442258312848815, 0.2688849020781233, 0.41018204302725003, 0.2596780407031909, 0.24828560270179267, 0.20250930709511772, 0.21332514558442528, 0.21582096982084864, 0.2214386548035221, 0.19453444989594737, 0.2346992918361429, 0.2334992759711637, 0.19720291045672678, 0.2002688315345389, 0.1815461263538225, 0.1826335866802704, 0.19176175639170778, 0.19125281315079068, 0.23759498658916622, 0.19853348270921722, 0.1968796316619139, 0.8932456109029548, 0.126974726940154, 0.18788648392139295, 0.17310241029945683, 0.2013879281481179, 0.1687499874294568, 0.14335896701901385, 0.16397535432930255, 0.21238396688451844, 0.891938887281665, 0.21275242717293286, 0.0735067277936996, 0.8161284069085742, 0.16928605270505304, 0.15583070787411912, 0.21266706400574198, 0.8769700832843115, 0.8713364772845286, 0.18526692715608828, 0.26122202866395583, 0.18206914197591662, 0.18230601079807873, 0.174392938163488, 0.21271354837490575, 0.20492399883958146, 0.21157652781176295, 0.21191721617318227, 0.1626095655469928, 0.08843616474944826, 0.09797373160035927, 0.08815331149357919, 0.0919603146155159, 0.10220645656472171, 0.08054001718211967, 0.09599229157780864, 0.09400892937363114]}, "mutation_prompt": null}
{"id": "8dba5e4b-2083-479d-9173-4122dfc1e948", "solution": "import numpy as np\n\nclass AdaptiveHybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.c1 = 1.5  # Reduced cognitive parameter for better exploration\n        self.c2 = 2.5  # Increased social parameter for stronger convergence\n        self.w = 0.4  # Further reduced inertia weight for tighter convergence\n        self.pa = 0.25\n        self.pm = 0.1  # Probability of mutation\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n                \n                # Evaluate new position\n                f_val = func(population[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n                    \n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Genetic Algorithm-inspired crossover and mutation\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Crossover\n                mate_idx = np.random.randint(0, self.pop_size)\n                offspring = 0.5 * (population[i] + population[mate_idx])\n                offspring = np.clip(offspring, self.lower_bound, self.upper_bound)\n                \n                # Mutation\n                if np.random.rand() < self.pm:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    offspring += mutation_vector\n                    offspring = np.clip(offspring, self.lower_bound, self.upper_bound)\n                \n                f_offspring = func(offspring)\n                evaluations += 1\n                \n                if f_offspring < personal_best_values[i]:\n                    personal_best_values[i] = f_offspring\n                    personal_best[i] = offspring.copy()\n                    \n                    if f_offspring < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n        \n        return global_best", "name": "AdaptiveHybridPSOGA", "description": "A novel algorithm combining Adaptive Particle Swarm Optimization with Genetic Algorithm-inspired crossover and mutation strategies for enhanced exploration and exploitation.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "369a72b8-dc86-445f-b9cf-e776ef4b9d9c", "metadata": {"aucs": [0.8397418837153936, 0.8219077954867684, 0.8200851189796995, 0.8293540717051241, 0.8331136988801541, 0.8440936413417229, 0.7989270043590464, 0.8123815535954868, 0.811812511931884, 0.5024732682433466, 0.03881945868431069, 0.24909860747114354, 0.4960520662889487, 0.2684245064215868, 0.5313993619852697, 0.5147652733887206, 0.45913093233299385, 0.5211027404758446, 0.10451265112753227, 0.14553428912434696, 0.10907892605223457, 0.11459017474770539, 0.11402574511619279, 0.06706193752915257, 0.13268596727580895, 0.11274775029921946, 0.13523513603929604, 0.06188005882402281, 0.09080980964180985, 0.15636275281779421, 0.11795458553169158, 0.09698253175803162, 0.0700588479486316, 0.1061088958307349, 0.1265310774025975, 0.10829771195484605, 0.9939945487250831, 0.9837230391776156, 0.9948331320789607, 0.9655467965643901, 0.9941953665797865, 0.964754009927252, 0.9940812094921004, 0.9843462137853096, 0.9945141658321802, 0.6147558549153556, 0.6062143364621684, 0.3748568165271493, 0.5224244122150119, 0.5689045655286895, 0.5610481190473113, 0.580417888788195, 0.5787635028493059, 0.6044307006124278, 0.8319049116339204, 0.7805870705406932, 0.2151317862276657, 0.8542277259617908, 0.8667514906674918, 0.1830840423015453, 0.1503514385920771, 0.20875023508097668, 0.1765826241114108, 0.5674100641605998, 0.5922824805115328, 0.5856792740338312, 0.10748714589706265, 0.5918554409225637, 0.11294197962965113, 0.5765640532962303, 0.5657678116936362, 0.4576918790632144, 0.4659332140292237, 0.4374315860738013, 0.6989694172295622, 0.6065025072992156, 0.630221813832365, 0.5464111936028264, 0.4515390124539176, 0.5654391216522283, 0.1168271631918848, 0.1693209822191648, 0.05330977191094277, 0.06714359819152471, 0.04303324448738399, 0.2577098100408881, 0.3678815058120726, 0.32990166417968936, 0.22612563510664507, 0.48954970821892496, 0.5457981600359109, 0.49727278713908163, 0.36753483320672675, 0.37418184089217044, 0.3146330939447457, 0.5655936525302618, 0.3616032386905501, 0.5103267176518821, 0.4993551582383048, 0.11337958745811116, 0.10204991398087948, 0.04550902137402968, 0.30143139470353586, 0.18536269705608566, 0.4548443131510217, 0.09147703105449778, 0.16576568031106131, 0.268114654441972, 0.22805860879199613, 0.3385075505909002, 0.17421409496315698, 0.37423568201987245, 0.363104995930834, 0.2687696099964695, 0.3385514101016933, 0.36102644790232086, 0.08075315034224295, 0.6835610689842578, 0.6892886723542099, 0.7512625183304485, 0.7156083775439641, 0.6589488763734093, 0.7687968410988684, 0.6954265050464843, 0.6716929411758665, 0.7256082988792611, 0.0788497479608814, 0.12494888358382339, 0.1185174042534678, 0.13380456134290564, 0.10249108213700586, 0.10544929279851933, 0.09515466700604391, 0.1116028673538465, 0.10073354562322767, 0.19505295652955923, 0.22801902398276042, 0.17742304078849103, 0.4941923226354249, 0.5159147110871642, 0.2982222992478044, 0.2904889995572967, 0.2266071652425401, 0.26156429626300326, 0.35817139991342595, 0.40755755855107423, 0.4448688682145633, 0.34070371755316664, 0.42384010683302586, 0.398444995959531, 0.22227455131875262, 0.5196167001656375, 0.35520623324188005, 0.3816931885993744, 0.20848832665659078, 0.20036285552122401, 0.1511678098238204, 0.26722651294717625, 0.2601602906254623, 0.32442258312848815, 0.2688849020781233, 0.41018204302725003, 0.2596780407031909, 0.24828560270179267, 0.20250930709511772, 0.21332514558442528, 0.21582096982084864, 0.2214386548035221, 0.19453444989594737, 0.2346992918361429, 0.2334992759711637, 0.19720291045672678, 0.2002688315345389, 0.1815461263538225, 0.1826335866802704, 0.19176175639170778, 0.19125281315079068, 0.23759498658916622, 0.19853348270921722, 0.1968796316619139, 0.8932456109029548, 0.126974726940154, 0.18788648392139295, 0.17310241029945683, 0.2013879281481179, 0.1687499874294568, 0.14335896701901385, 0.16397535432930255, 0.21238396688451844, 0.891938887281665, 0.21275242717293286, 0.0735067277936996, 0.8161284069085742, 0.16928605270505304, 0.15583070787411912, 0.21266706400574198, 0.8769700832843115, 0.8713364772845286, 0.18526692715608828, 0.26122202866395583, 0.18206914197591662, 0.18230601079807873, 0.174392938163488, 0.21271354837490575, 0.20492399883958146, 0.21157652781176295, 0.21191721617318227, 0.1626095655469928, 0.08843616474944826, 0.09797373160035927, 0.08815331149357919, 0.0919603146155159, 0.10220645656472171, 0.08054001718211967, 0.09599229157780864, 0.09400892937363114]}, "mutation_prompt": null}
{"id": "5e400bbe-e651-4d73-87e7-535adcd47582", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.c1 = 1.4  # Slightly adjusted cognitive parameter for exploration\n        self.c2 = 2.6  # Slightly adjusted social parameter for stronger convergence\n        self.w = 0.5  # Adaptive inertia weight for dynamic balance\n        self.pa = 0.25\n        self.pm = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pheromone_decay = 0.9  # New parameter for pheromone decay\n        self.pheromones = np.ones((self.pop_size, self.dim))  # Initialize pheromones\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            # PSO Update with pheromone influence\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]) +\n                                 0.1 * self.pheromones[i])  # Pheromone influence\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n                # Evaluate new position\n                f_val = func(population[i])\n                evaluations += 1\n\n                # Update personal and global bests\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n\n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                self.pheromones[i] = self.pheromone_decay * self.pheromones[i]  # Decay pheromones\n\n                if evaluations >= self.budget:\n                    break\n\n            # Genetic Algorithm-inspired crossover and mutation\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Crossover\n                mate_idx = np.random.randint(0, self.pop_size)\n                offspring = 0.5 * (population[i] + population[mate_idx])\n                offspring = np.clip(offspring, self.lower_bound, self.upper_bound)\n\n                # Mutation\n                if np.random.rand() < self.pm:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    offspring += mutation_vector\n                    offspring = np.clip(offspring, self.lower_bound, self.upper_bound)\n\n                f_offspring = func(offspring)\n                evaluations += 1\n\n                if f_offspring < personal_best_values[i]:\n                    personal_best_values[i] = f_offspring\n                    personal_best[i] = offspring.copy()\n\n                    if f_offspring < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                self.pheromones[i] = (1 - self.pheromone_decay) + self.pheromone_decay * self.pheromones[i]  # Update pheromones\n\n        return global_best", "name": "EnhancedAdaptiveHybridPSOGA", "description": "An enhanced Adaptive Hybrid PSOGA integrating ACO-inspired pheromone updates for improved convergence efficiency.", "configspace": "", "generation": 19, "fitness": 0.253367506372699, "feedback": "The algorithm EnhancedAdaptiveHybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.23.", "error": "", "parent_id": "369a72b8-dc86-445f-b9cf-e776ef4b9d9c", "metadata": {"aucs": [0.5659684676728483, 0.5737670117156201, 0.5592515980278023, 0.58599233324757, 0.5652488511191367, 0.5521234639176542, 0.5866947796392095, 0.557228125233661, 0.5607314816490363, 0.026962547974228257, 9.999999999998899e-05, 9.999999999998899e-05, 0.07615846060438525, 0.08320201694568674, 0.026061417769590256, 0.06706699815794381, 0.07489875111890487, 0.09601909048989632, 0.13525252421069067, 0.14457204451169603, 0.11313281039735923, 0.11457906522818029, 0.09735081277826652, 0.06844898909577257, 0.08697652279949775, 0.09967614597670749, 0.08495095524304141, 0.09528633787658436, 0.09455078407531414, 0.10451605301645228, 0.1121549772924949, 0.10423174740642949, 0.08066005116474773, 0.12596350778035503, 0.13198097694560162, 0.10630431614985081, 0.9939957482163775, 0.9912314240925055, 0.9948341710654197, 0.9656138039144487, 0.9941965180454388, 0.9666590188868628, 0.9940777105777698, 0.9826118634544978, 0.9943436127799098, 0.36186356964084576, 0.348370889552333, 0.33445992145227765, 0.33902734528090106, 0.3780154280959297, 0.3208084732353079, 0.3373477498603612, 0.33304934345342563, 0.28686538188888866, 0.6832036073815129, 0.8182341214357265, 0.3667205521286969, 0.21507115486953277, 0.1877030629078249, 0.19244806573296425, 0.22839437423032793, 0.17246674570407816, 0.6085736687497306, 0.28975923215044463, 0.23454283037447066, 0.12228993641555008, 0.0926970811013822, 0.12421092258610134, 0.1284197741159565, 0.2775455414014836, 0.22330380257265126, 0.3287521630436179, 0.3060669822966493, 0.13026156331474104, 0.20328915100509226, 0.1954419570741357, 0.21526519825587165, 0.16642841892711746, 0.1516484179649089, 0.23189243356075273, 0.12041501280965927, 0.04525920619114554, 0.04357051893631492, 9.999999999998899e-05, 0.0693989708253363, 9.999999999998899e-05, 0.014349096704032505, 0.0055983061371555065, 0.11685222192606559, 0.1167543266294857, 0.0919532161865163, 0.04467718689726641, 0.10178757714426845, 0.21302433200051696, 0.08367360932526369, 0.12774516876760977, 0.07648292499283837, 0.11078999770951448, 0.13250423524021626, 0.06119254522342232, 0.01893018801952806, 0.053978290746735325, 0.10035787524766893, 0.08768965647035476, 0.07854281780520433, 0.0752917588121893, 0.0713415460220127, 0.04681616638907449, 0.1894574595323485, 0.18265078568437854, 0.18461772439664725, 0.1530223296508657, 0.03575151771700569, 0.15941702205363328, 0.1604711815550518, 0.09787164638503987, 0.09102182418173921, 0.4776834517897761, 0.4879463783971535, 0.4685921067537624, 0.44832031509854164, 0.4639837701224657, 0.4699300309836124, 0.4728421886912263, 0.4325843029034, 0.47001462210922407, 0.09893363293462665, 0.06362856605227918, 0.10697727535485357, 0.13275822353888778, 0.16684265979595492, 0.14279785332344275, 0.1110301406611689, 0.12495389879922092, 0.10373412552867411, 0.13591285902709538, 0.2272438114481521, 0.2054736593224319, 0.33839946788423503, 0.28727464562424543, 0.3201526650792451, 0.3388955023267659, 0.21730992364651647, 0.20063054406730496, 0.2331448187892945, 0.34935119996864883, 0.3690521186748573, 0.31135983200516837, 0.3011754093519826, 0.2863067280609588, 0.2645692402570611, 0.35843009155548333, 0.2890395424434429, 0.2339962624823433, 0.23616189978333657, 0.19597838627543518, 0.20139595380106956, 0.18472377090610548, 0.2752098445831237, 0.20764293644591658, 0.20860386779577178, 0.22596799530153366, 0.21492198017194164, 0.19447662837316704, 0.19421886406384425, 0.20128203528208355, 0.2006133340095022, 0.22799872353010775, 0.22973797373620675, 0.23668180753838008, 0.23560957721581588, 0.20998666044226144, 0.1969004275393279, 0.2359717049911535, 0.19841594777516924, 0.20953062976414039, 0.1930334169310558, 0.18333380892438522, 0.2223354902896132, 0.17175015075834488, 0.8116812704561311, 0.12623095902839754, 0.18581935283080953, 0.7963859551969033, 0.20081483250871557, 0.11657548987352617, 0.14242002082438043, 0.16266978136981725, 0.816479722652961, 0.7918864419933216, 0.2130945778857707, 0.07343948905091569, 0.2080863698633827, 0.7229491274323849, 0.15447533569479055, 0.21245102663307536, 0.10445752528745766, 0.7266578841916465, 0.20366110167193596, 0.18984808235267692, 0.1818676462440354, 0.18468542221021766, 0.18870120893115072, 0.20549941211320955, 0.2015570862371372, 0.21027252355494863, 0.19210655581611202, 0.08987329973412106, 0.08973876040143858, 0.10079034745112858, 0.09217083753088395, 0.07714887421200833, 0.07108165281574452, 0.08072280050432912, 0.08665183531840048, 0.07704809120367895]}, "mutation_prompt": null}
{"id": "9c3a346b-1236-4ad7-9198-1d29ea318d4b", "solution": "import numpy as np\n\nclass LevyAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.cr = 0.9  # Crossover probability for DE\n        self.f = 0.8   # Differential weight for DE\n        self.pm = 0.1  # Probability of mutation\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.alpha = 1.5  # Parameter for Levy flight\n\n    def levy_flight(self):\n        sigma = (np.math.gamma(1 + self.alpha) * np.sin(np.pi * self.alpha / 2) /\n                 (np.math.gamma((1 + self.alpha) / 2) * self.alpha *\n                 2**((self.alpha - 1) / 2)))**(1 / self.alpha)\n        u = np.random.normal(0, sigma, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / abs(v)**(1 / self.alpha)\n        return step\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            # DE Update\n            for i in range(self.pop_size):\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                \n                # Evaluate trial\n                f_val = func(trial)\n                evaluations += 1\n                \n                # Update personal and global bests\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = trial.copy()\n                    \n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Levy flight for exploration\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                step = self.levy_flight()\n                new_pos = population[i] + step\n                new_pos = np.clip(new_pos, self.lower_bound, self.upper_bound)\n                \n                f_new_pos = func(new_pos)\n                evaluations += 1\n                \n                if f_new_pos < personal_best_values[i]:\n                    personal_best_values[i] = f_new_pos\n                    personal_best[i] = new_pos.copy()\n                    \n                    if f_new_pos < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n        \n        return global_best", "name": "LevyAdaptiveDE", "description": "A novel algorithm integrating Levy flight-based exploration and adaptive differential evolution to enhance convergence speed and exploration.", "configspace": "", "generation": 20, "fitness": 0.08914897594024268, "feedback": "The algorithm LevyAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.08.", "error": "", "parent_id": "369a72b8-dc86-445f-b9cf-e776ef4b9d9c", "metadata": {"aucs": [0.1725811370631547, 0.1421740615991528, 0.16644801475510707, 0.1831405941313342, 0.16546462595043554, 0.16524049786703887, 0.19144146055781297, 0.1391253261942902, 0.14531366632311715, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.039654481315390844, 0.04060342932452854, 0.03794207477593481, 0.03818693267987838, 0.03149616496413021, 0.03880318416855966, 0.03405232657909196, 0.03603736838775007, 0.06318332211881095, 0.023440213039933377, 0.02596358829755918, 0.026417303249429258, 0.04807398514445871, 0.02726628899324912, 0.027536805817853782, 0.03923231152138873, 0.02183934749365468, 0.04798873906965706, 0.1303791434492323, 0.6140165154960822, 0.14749189068379087, 0.11258825372551762, 0.10425282700277583, 0.1253833129002795, 0.10835786852358165, 0.14462986430598979, 0.12726657954301812, 0.07808734119928318, 0.07071190019324236, 0.05134459336328001, 0.10745432534081045, 0.04861911431831467, 0.06448143942386886, 0.06392741934534518, 0.04889160468113041, 0.06030206747425759, 0.11093345750271655, 0.136494167435957, 0.11447099279834161, 0.13713633345453524, 0.2030655104658965, 0.0809812033664683, 0.09512418927062138, 0.11396252074634161, 0.12368746670361963, 0.003270800079160141, 9.999999999998899e-05, 0.000220234929057872, 0.002716965435676122, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0020226035305237478, 0.028837365002829962, 9.999999999998899e-05, 0.07194427848666352, 0.0020924188605078164, 9.999999999998899e-05, 0.008574494120409337, 0.011965850673971157, 9.999999999998899e-05, 0.0003798636777136988, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06847217968650698, 0.04206472078042822, 0.08879845068847025, 0.018150221841358838, 0.008222900119958299, 0.05918485479037794, 0.12036965281002066, 0.031082272454111992, 0.05889134661901385, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006144400937183714, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1929094203041254, 0.19398579224147772, 0.20586089396058938, 0.1788256021565423, 0.17366249079751328, 0.1611324449203938, 0.2016160303253648, 0.1733617014071197, 0.1871746899672746, 0.033993192207198986, 0.036525558591837926, 0.04231758804401087, 0.044506879825247925, 0.03051540960218735, 0.05048727598879488, 0.04844732595552337, 0.03580081827811521, 0.04948572984792077, 0.15878214312172545, 0.12874948783787732, 0.12783854927237936, 0.146523474897029, 0.1277007545053993, 0.13850153440582413, 0.13615715386568883, 0.1346770058012351, 0.1264189643517155, 0.15947240320958211, 0.16119387149664888, 0.18984144687515214, 0.15876960414504993, 0.17670339977006766, 0.16465954332387867, 0.15393209587611, 0.17377774300845283, 0.15971836234365933, 0.10047820015964748, 0.10922902595870332, 0.12877712732298296, 0.10224057093415795, 0.10998316192965918, 0.10814519140477497, 0.09777363831089914, 0.11731169810131326, 0.10523266618709837, 0.15379377523729276, 0.14642808764309845, 0.15402699538905695, 0.1587631387012428, 0.1346950847535845, 0.14811375840391394, 0.15519955685184417, 0.15727393055533978, 0.13960357807247492, 0.13295536722591783, 0.12150888409490812, 0.13502749046919138, 0.1148732206524572, 0.14554953678450677, 0.14134237343834588, 0.12169353832317342, 0.15311476925451684, 0.12581388163498375, 0.1390052252858861, 0.19920311310852512, 0.2076951225530108, 0.16152831244520172, 0.14164077878982717, 0.1644205028166318, 0.16964694536480185, 0.14865963124860915, 0.1594163874124781, 0.1546558134868785, 0.14679603476944614, 0.10201295265166954, 0.14943600053725237, 0.11913825062330341, 0.1328075692585604, 0.14069269737194423, 0.1587721939878607, 0.13235361785237643, 0.1902238429682065, 0.17698682115944953, 0.1913634803151637, 0.18877383719993213, 0.201566036094466, 0.18216256922855123, 0.220373969145357, 0.1895841743480441, 0.19871863640156762, 0.0434738214153485, 0.04336849469672377, 0.04885536007902447, 0.05564968944157278, 0.04645529441416807, 0.04594639260247091, 0.05889923366106664, 0.04743059462130916, 0.03509574579099006]}, "mutation_prompt": null}
{"id": "29c7abc2-294c-42bd-98ca-64798592dd9b", "solution": "import numpy as np\n\nclass AdaptiveHybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.c1 = 1.5  # Reduced cognitive parameter for better exploration\n        self.c2 = 2.5  # Increased social parameter for stronger convergence\n        self.w = 0.4  # Further reduced inertia weight for tighter convergence\n        self.pa = 0.25\n        self.pm = 0.1  # Probability of mutation\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - population[i]) +\n                                 self.c2 * r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n                \n                # Evaluate new position\n                f_val = func(population[i])\n                evaluations += 1\n                \n                # Update personal and global bests\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n                    \n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Genetic Algorithm-inspired crossover and mutation\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Crossover\n                mate_idx = np.random.randint(0, self.pop_size)\n                offspring = 0.5 * (population[i] + population[mate_idx])\n                offspring = np.clip(offspring, self.lower_bound, self.upper_bound)\n                \n                # Mutation\n                if np.random.rand() < self.pm:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    offspring += mutation_vector\n                    offspring = np.clip(offspring, self.lower_bound, self.upper_bound)\n                \n                f_offspring = func(offspring)\n                evaluations += 1\n                \n                if f_offspring < personal_best_values[i]:\n                    personal_best_values[i] = f_offspring\n                    personal_best[i] = offspring.copy()\n                    \n                    if f_offspring < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n        \n        return global_best", "name": "AdaptiveHybridPSOGA", "description": "A novel algorithm combining Adaptive Particle Swarm Optimization with Genetic Algorithm-inspired crossover and mutation strategies for enhanced exploration and exploitation.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "369a72b8-dc86-445f-b9cf-e776ef4b9d9c", "metadata": {"aucs": [0.8397418837153936, 0.8219077954867684, 0.8200851189796995, 0.8293540717051241, 0.8331136988801541, 0.8440936413417229, 0.7989270043590464, 0.8123815535954868, 0.811812511931884, 0.5024732682433466, 0.03881945868431069, 0.24909860747114354, 0.4960520662889487, 0.2684245064215868, 0.5313993619852697, 0.5147652733887206, 0.45913093233299385, 0.5211027404758446, 0.10451265112753227, 0.14553428912434696, 0.10907892605223457, 0.11459017474770539, 0.11402574511619279, 0.06706193752915257, 0.13268596727580895, 0.11274775029921946, 0.13523513603929604, 0.06188005882402281, 0.09080980964180985, 0.15636275281779421, 0.11795458553169158, 0.09698253175803162, 0.0700588479486316, 0.1061088958307349, 0.1265310774025975, 0.10829771195484605, 0.9939945487250831, 0.9837230391776156, 0.9948331320789607, 0.9655467965643901, 0.9941953665797865, 0.964754009927252, 0.9940812094921004, 0.9843462137853096, 0.9945141658321802, 0.6147558549153556, 0.6062143364621684, 0.3748568165271493, 0.5224244122150119, 0.5689045655286895, 0.5610481190473113, 0.580417888788195, 0.5787635028493059, 0.6044307006124278, 0.8319049116339204, 0.7805870705406932, 0.2151317862276657, 0.8542277259617908, 0.8667514906674918, 0.1830840423015453, 0.1503514385920771, 0.20875023508097668, 0.1765826241114108, 0.5674100641605998, 0.5922824805115328, 0.5856792740338312, 0.10748714589706265, 0.5918554409225637, 0.11294197962965113, 0.5765640532962303, 0.5657678116936362, 0.4576918790632144, 0.4659332140292237, 0.4374315860738013, 0.6989694172295622, 0.6065025072992156, 0.630221813832365, 0.5464111936028264, 0.4515390124539176, 0.5654391216522283, 0.1168271631918848, 0.1693209822191648, 0.05330977191094277, 0.06714359819152471, 0.04303324448738399, 0.2577098100408881, 0.3678815058120726, 0.32990166417968936, 0.22612563510664507, 0.48954970821892496, 0.5457981600359109, 0.49727278713908163, 0.36753483320672675, 0.37418184089217044, 0.3146330939447457, 0.5655936525302618, 0.3616032386905501, 0.5103267176518821, 0.4993551582383048, 0.11337958745811116, 0.10204991398087948, 0.04550902137402968, 0.30143139470353586, 0.18536269705608566, 0.4548443131510217, 0.09147703105449778, 0.16576568031106131, 0.268114654441972, 0.22805860879199613, 0.3385075505909002, 0.17421409496315698, 0.37423568201987245, 0.363104995930834, 0.2687696099964695, 0.3385514101016933, 0.36102644790232086, 0.08075315034224295, 0.6835610689842578, 0.6892886723542099, 0.7512625183304485, 0.7156083775439641, 0.6589488763734093, 0.7687968410988684, 0.6954265050464843, 0.6716929411758665, 0.7256082988792611, 0.0788497479608814, 0.12494888358382339, 0.1185174042534678, 0.13380456134290564, 0.10249108213700586, 0.10544929279851933, 0.09515466700604391, 0.1116028673538465, 0.10073354562322767, 0.19505295652955923, 0.22801902398276042, 0.17742304078849103, 0.4941923226354249, 0.5159147110871642, 0.2982222992478044, 0.2904889995572967, 0.2266071652425401, 0.26156429626300326, 0.35817139991342595, 0.40755755855107423, 0.4448688682145633, 0.34070371755316664, 0.42384010683302586, 0.398444995959531, 0.22227455131875262, 0.5196167001656375, 0.35520623324188005, 0.3816931885993744, 0.20848832665659078, 0.20036285552122401, 0.1511678098238204, 0.26722651294717625, 0.2601602906254623, 0.32442258312848815, 0.2688849020781233, 0.41018204302725003, 0.2596780407031909, 0.24828560270179267, 0.20250930709511772, 0.21332514558442528, 0.21582096982084864, 0.2214386548035221, 0.19453444989594737, 0.2346992918361429, 0.2334992759711637, 0.19720291045672678, 0.2002688315345389, 0.1815461263538225, 0.1826335866802704, 0.19176175639170778, 0.19125281315079068, 0.23759498658916622, 0.19853348270921722, 0.1968796316619139, 0.8932456109029548, 0.126974726940154, 0.18788648392139295, 0.17310241029945683, 0.2013879281481179, 0.1687499874294568, 0.14335896701901385, 0.16397535432930255, 0.21238396688451844, 0.891938887281665, 0.21275242717293286, 0.0735067277936996, 0.8161284069085742, 0.16928605270505304, 0.15583070787411912, 0.21266706400574198, 0.8769700832843115, 0.8713364772845286, 0.18526692715608828, 0.26122202866395583, 0.18206914197591662, 0.18230601079807873, 0.174392938163488, 0.21271354837490575, 0.20492399883958146, 0.21157652781176295, 0.21191721617318227, 0.1626095655469928, 0.08843616474944826, 0.09797373160035927, 0.08815331149357919, 0.0919603146155159, 0.10220645656472171, 0.08054001718211967, 0.09599229157780864, 0.09400892937363114]}, "mutation_prompt": null}
{"id": "71ae4301-cfc1-4a9a-ba75-22d35672b290", "solution": "import numpy as np\n\nclass SwarmGuidedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Adjust population size for better diversity\n        self.w = 0.5  # Adaptive inertia weight\n        self.cr = 0.9  # Crossover probability for DE\n        self.f = 0.8  # Mutation factor for DE\n        self.pm = 0.15  # Probability of mutation\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                # DE Mutation and Crossover\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = x0 + self.f * (x1 - x2)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n                    \n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n            \n            # PSO Update with adaptive inertia weight\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n                \n                # Evaluate new position\n                f_val = func(population[i])\n                evaluations += 1\n                \n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n                    \n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n        \n        return global_best", "name": "SwarmGuidedAdaptiveDE", "description": "A novel Swarm-Guided Adaptive Differential Evolution (SGADE) with hybrid strategies for enhanced convergence and solution quality.", "configspace": "", "generation": 22, "fitness": 0.3671576347147045, "feedback": "The algorithm SwarmGuidedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.27.", "error": "", "parent_id": "369a72b8-dc86-445f-b9cf-e776ef4b9d9c", "metadata": {"aucs": [0.849999833927963, 0.847222775276772, 0.8466056180018291, 0.8359883830139342, 0.8340028459533573, 0.8294247220119073, 0.8449733043080867, 0.8269498242774447, 0.8331768402051951, 0.4905401082854476, 0.033467450629592665, 0.5300224862665605, 0.5623975858611892, 0.49369796269724087, 0.4552201062275798, 0.42866085115333086, 0.5008388407397655, 0.5398245667267991, 0.08898929284737223, 0.15488230995731578, 0.08513088703870375, 0.09026259708706785, 0.12086783533253331, 0.11664357891790278, 0.09339659822005142, 0.11573561515513542, 0.11820834739010055, 0.09878133278580081, 0.13388444511490905, 0.12179890945376814, 0.09089015912246845, 0.11203205212345269, 0.10599760756652776, 0.121116402132176, 0.10334410532534144, 0.10574666249010134, 0.9768966161755606, 0.9678626360327746, 0.9761725948964179, 0.9761159817471667, 0.96308528429793, 0.9749887307458343, 0.987977751669457, 0.974469817389934, 0.9672534789932661, 0.6856492264549694, 0.6837144975093086, 0.6955566593411486, 0.7305163425057388, 0.6782317285232602, 0.6769030828150115, 0.7011939145550186, 0.6005407981081831, 0.6512127320574109, 0.8062387412490709, 0.2413141257585466, 0.22699117815889502, 0.19315263460281074, 0.8170691941453969, 0.2708506449733563, 0.8597846683813647, 0.23014270842174678, 0.2340846315060976, 0.5931317390197971, 0.12711771391777116, 0.12354888981298717, 0.6402094532471425, 0.583660168626918, 0.44610853666688877, 0.6457569356021508, 0.12960096281506306, 0.13280785567625886, 0.5948961689861463, 0.6206363101617767, 0.5884578224233326, 0.6016086294602588, 0.6363649687244286, 0.571886342390191, 0.6562721108038241, 0.511968358695188, 0.5349270504405093, 0.19384914930337904, 0.4578595601674228, 0.374679576971248, 0.43900942669723464, 0.47170165468192327, 0.3536388620243174, 0.46720190682516305, 0.28216694723668834, 0.495880586191203, 0.5887749486396735, 0.5802113687071702, 0.4855166726849044, 0.3582277167364649, 0.35642927667924196, 0.5142990680494778, 0.4811294665610091, 0.5393599370711751, 0.5397600232560236, 0.2266264918203783, 0.4008799085402085, 0.12958081480739292, 0.11512639369130051, 0.21177376032871287, 0.18698006370368658, 0.10732113681661415, 0.06731333493320812, 0.11261473994659632, 0.1891041386721386, 0.1802616940416929, 0.1869386738871215, 0.17618438765778244, 0.3509960276983647, 0.3156260292087888, 0.053625902211997034, 0.0541284649063144, 0.0797565500308276, 0.7184050303810707, 0.6753475020926827, 0.6977061768786457, 0.7086639224263254, 0.7002969463665121, 0.701196210679264, 0.6670880241173072, 0.6896119452247431, 0.6712265806308747, 0.11872226748036407, 0.09268819311145093, 0.06967738615306296, 0.15284468616417834, 0.07600444864935285, 0.10386312070247117, 0.10145009734807231, 0.11033724095533404, 0.10848201953291847, 0.26443636111850743, 0.16335050970631892, 0.18351642789058353, 0.2048474948224508, 0.2571051559286157, 0.20047658685270042, 0.22212420568698177, 0.20728973391191574, 0.27921457453589205, 0.31334622928860933, 0.36033053381767377, 0.306898571741296, 0.40236281534699336, 0.3963351985684175, 0.31751444720184774, 0.5345585647839819, 0.3584558391762702, 0.44253760925002017, 0.20000388740542008, 0.27884833060476544, 0.34474107878736093, 0.3213965056167808, 0.3117073574712709, 0.21962594679494263, 0.21007956776531544, 0.1999078679201769, 0.1756035282432742, 0.2555449909142137, 0.20337966655056716, 0.20685928481768479, 0.21326898034600417, 0.2584397675418302, 0.2561899015442517, 0.24806276602097865, 0.21762629920990018, 0.2624591706860647, 0.17692514856192898, 0.18384965142531728, 0.1987661703835768, 0.2248645760980279, 0.1916117933088094, 0.18096571550066687, 0.17829972549507378, 0.19446057172096776, 0.17777671625349833, 0.18749135035080267, 0.18821088430265065, 0.1685845313401858, 0.1871802839822564, 0.20062658283448676, 0.8452652717127092, 0.1420625615935034, 0.16945543937908625, 0.17180526868000157, 0.17001993735982246, 0.21192230868360495, 0.8564030384760074, 0.12720449461575267, 0.16747417863690317, 0.8519713397402819, 0.15440485230846956, 0.8146906806173685, 0.16685864948284157, 0.1950599494379659, 0.19193745800483197, 0.2000287860842419, 0.19742099304715732, 0.1955068514738426, 0.19340114345700732, 0.22191196631089682, 0.21113559897241163, 0.2082623365071148, 0.09171631424818916, 0.11034358650298148, 0.08128824473986884, 0.0922878722916396, 0.09997990046419869, 0.10415892338753452, 0.09170777924917528, 0.09888668048937577, 0.09761751060074442]}, "mutation_prompt": null}
{"id": "5b8b007a-3cd6-4b59-99cd-af39c8171d4d", "solution": "import numpy as np\n\nclass AdaptiveHybridEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Modified population size for efficiency\n        self.w = 0.7  # Dynamic inertia weight for better exploration\n        self.cr = 0.85  # Crossover probability adjusted for balance\n        self.f = 0.6  # Tuned mutation factor for controlled diversity\n        self.pm = 0.2  # Increased mutation probability for exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.3, 0.3, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Hybrid DE and PSO Mutation\n                if evaluations < self.budget // 2:\n                    indices = np.random.choice(self.pop_size, 3, replace=False)\n                    x0, x1, x2 = population[indices]\n                    mutant = x0 + self.f * (x1 - x2)\n                else:\n                    mutant = personal_best[i] + self.f * (global_best - personal_best[i])\n                    \n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n                    \n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n            \n            # PSO Update with dynamic inertia weight\n            self.w = 0.4 + 0.3 * (evaluations / self.budget)  # Adaptive inertia\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n                \n                # Evaluate new position\n                f_val = func(population[i])\n                evaluations += 1\n                \n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n                    \n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n        \n        return global_best", "name": "AdaptiveHybridEA", "description": "A novel Adaptive Hybrid Evolutionary Algorithm combining exploratory and exploitative strategies to balance exploration and convergence speed.", "configspace": "", "generation": 23, "fitness": 0.3767199890793655, "feedback": "The algorithm AdaptiveHybridEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.29.", "error": "", "parent_id": "71ae4301-cfc1-4a9a-ba75-22d35672b290", "metadata": {"aucs": [0.8871826822908224, 0.8711148637881581, 0.8900291041130235, 0.8628368413957237, 0.8738819632321351, 0.8685709209937958, 0.8790834633499045, 0.8815821150451915, 0.8691979250913316, 0.6745682896195839, 0.6497727795444479, 0.6535111661640098, 0.61430553306501, 0.5993027436486895, 0.6904930928099209, 0.08815916252972134, 0.609746502312775, 0.5723425198024741, 0.18057536308494837, 0.14061710775580305, 0.0876930074630965, 0.1307679203985186, 0.10623345200438705, 0.11923907409012358, 0.11013936873072583, 0.10444962213872877, 0.11250150847723506, 0.0885385403196125, 0.08606608605302868, 0.06454608623234603, 0.11272783231638661, 0.11567160374602248, 0.10795369690719725, 0.10438840546659689, 0.11254159325265467, 0.08994284175248157, 0.9714650440728757, 0.9643907801948479, 0.9696635986458755, 0.9712349850032499, 0.9690040821929, 0.9548066838502615, 0.9637411448251363, 0.9765915817241605, 0.9733781222676917, 0.7793985549618262, 0.7549110028449186, 0.7114722368869126, 0.7415753158569725, 0.7677624818906092, 0.7711871443122863, 0.7497121758602364, 0.7790931284561528, 0.7650917966883054, 0.8706667607121773, 0.8747753844500974, 0.8712004480241841, 0.2791320528135913, 0.27909140051728254, 0.1911862526831858, 0.13815062601740047, 0.23333450121167187, 0.2405183002806447, 0.6337961206658999, 0.5746272598735032, 0.6897260431435153, 0.3730875786577842, 0.6417524870774309, 0.13211899505545877, 0.6500645830469493, 0.6962820217538823, 0.7180159692263058, 0.6043751718452135, 0.7327950775506178, 0.6366286604472307, 0.1324942169302451, 0.6732757983144831, 0.13179730619848085, 0.7110431555927736, 0.13238690620581506, 0.5848320257412571, 0.5073520735209601, 0.4307014717562302, 0.09072150721509153, 0.04172432636729606, 0.27047948964185453, 0.028428734603196393, 0.23420701301605118, 0.07031841134560524, 0.3700982018166826, 0.13387734476806012, 0.2080227888962184, 0.2902850105526533, 0.32542154576412774, 0.5845996803524591, 0.26152944822535595, 0.610434405007612, 0.6033832152408869, 0.5101125086285687, 0.034485008551899954, 0.08023984124751549, 0.12161820637798704, 0.19489448535791176, 0.24104525904494445, 0.21098618295738836, 0.09784638120450129, 0.17395211230213858, 0.2911883234749124, 0.13028441596139306, 0.19130915755294453, 0.17348159082630443, 0.09807844052665038, 0.4305554884280769, 0.14317246827879393, 0.13363362557726455, 0.22080962370739876, 0.08398982053884596, 0.7762764780456178, 0.671698768438392, 0.7719732555941774, 0.7237756778173619, 0.7356057362057925, 0.757019070242464, 0.7646337086769299, 0.7064259495544636, 0.718076057523494, 0.14151808448559444, 0.18090758218923875, 0.12090242318252309, 0.10471127133620661, 0.1570622800246898, 0.14801595501022402, 0.06431198586880205, 0.10121908323922779, 0.14508653563691265, 0.1562362703040553, 0.3812126514345603, 0.17679578908107196, 0.22082173159101826, 0.26149877289625634, 0.2636895229053955, 0.47603561922641, 0.18894656867883342, 0.1890837330369266, 0.3567205821202809, 0.5058993549931575, 0.29634798996595724, 0.5577074289089985, 0.3116428147295257, 0.3400425031025244, 0.24966015485128557, 0.2958663926998971, 0.5103740265167868, 0.23986696780444983, 0.246484619819746, 0.3079542670864406, 0.3375485699425822, 0.3184157236071731, 0.23709242458789026, 0.23390513176627414, 0.26923332614020634, 0.2809083621234971, 0.24802194169810077, 0.2420945298248025, 0.19428903748228932, 0.22810448207992662, 0.23185270508255662, 0.22323536408431577, 0.23877846300022865, 0.23699163073073437, 0.22224697053922815, 0.19112149038145865, 0.2110324029592664, 0.19814132744573665, 0.18567213267394322, 0.22454691083231682, 0.20616286032352982, 0.18975543055884303, 0.21434944748462093, 0.2073368553394267, 0.9018931723263484, 0.17820931203384538, 0.15345948087581418, 0.15851774816452924, 0.2002759780334522, 0.9200080674742466, 0.14214210928780324, 0.17509271132851278, 0.15309861504259703, 0.9230336635570204, 0.2120305511231576, 0.1671992577857898, 0.21077122242591173, 0.1686224042490796, 0.1546551915092872, 0.2116603712084364, 0.2107332150458754, 0.8884871739046369, 0.19960798281485825, 0.19752073390828018, 0.20332250853795486, 0.20771161292298668, 0.2008703208389765, 0.2126380915421271, 0.2185082934300041, 0.20771226243627972, 0.20063246340670515, 0.09572188254788472, 0.10813638928069735, 0.10605261642879726, 0.11079340429611018, 0.0882453949337596, 0.09320334440616151, 0.09545199416061956, 0.1035399222802893, 0.10383563988477729]}, "mutation_prompt": null}
{"id": "0d40454f-8fbb-4e69-bc81-111980f1bcd3", "solution": "import numpy as np\n\nclass ChaoticHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Adjusted population size for faster convergence\n        self.w_max = 0.9  # Maximum inertia weight\n        self.w_min = 0.4  # Minimum inertia weight\n        self.cr = 0.9  # Higher crossover probability\n        self.f = 0.5  # Mutation factor adjusted for balance\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.chaotic_map = self.logistic_map(self.pop_size)\n\n    def logistic_map(self, size):\n        x = np.empty(size)\n        x[0] = 0.5\n        r = 4.0  # Parameter for chaotic behavior\n        for i in range(1, size):\n            x[i] = r * x[i - 1] * (1 - x[i - 1])\n        return x\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.3, 0.3, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            # Update inertia weight\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)\n            \n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                \n                # Update velocity using PSO rule\n                velocities[i] = (w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                # Update position\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n                \n                # Chaotic DE mutation\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = x0 + self.chaotic_map[i] * self.f * (x1 - x2)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                f_trial = func(trial)\n                evaluations += 1\n                \n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n                    \n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "ChaoticHybridPSO_DE", "description": "A hybrid Particle Swarm Optimization algorithm augmented with Differential Evolution, leveraging chaotic maps for enhanced exploration and global convergence.", "configspace": "", "generation": 24, "fitness": 0.361063117022749, "feedback": "The algorithm ChaoticHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.26.", "error": "", "parent_id": "5b8b007a-3cd6-4b59-99cd-af39c8171d4d", "metadata": {"aucs": [0.7528049001965108, 0.7438322083591218, 0.7712293145474021, 0.7745466276502266, 0.7408875733257887, 0.7587646808515723, 0.7541666953756224, 0.7618703104374774, 0.7357174820753083, 0.5387661919649931, 0.5043317920908308, 0.14441147736796411, 0.49583831230683095, 0.46355778478610454, 0.5003471328814836, 0.5364181206481856, 0.5284482389625179, 0.04136300124102832, 0.12913426127896632, 0.12870476476684412, 0.13760886779101733, 0.148896969392744, 0.13833446772974034, 0.10252760370735436, 0.10876086912427618, 0.10751252669152145, 0.130691650368578, 0.11176748881851728, 0.10714182404452555, 0.1085428128638749, 0.09177312269331872, 0.08573615985202576, 0.08617706981951523, 0.10604630074893939, 0.10422666356202226, 0.12615509879678588, 0.9827969903727043, 0.9900618056384081, 0.9855942611595798, 0.9753564220879489, 0.9840918634656798, 0.982694971635453, 0.986343490309705, 0.9802652315271668, 0.9842496620990955, 0.6284783959176643, 0.5956851815715951, 0.6151848909935155, 0.6340800767366779, 0.6088675096159686, 0.6197784245936826, 0.6106123877046443, 0.08771510476446054, 0.612999497052513, 0.7815025651711789, 0.7121745583783362, 0.7766515579805046, 0.2734230565092066, 0.18802610827683308, 0.7351862112277272, 0.1248449700075831, 0.7249223831770063, 0.7669407463971875, 0.5144968252957312, 0.4133197642383425, 0.45637331574737505, 0.12551088323110893, 0.5204126433082483, 0.5049059282594817, 0.4555997867295656, 0.4466449308311564, 0.5094385326319344, 0.5558488831463502, 0.4777700109699472, 0.47919111373665146, 0.541960254317716, 0.442077171921617, 0.4828940341530713, 0.4514000206994082, 0.3254314828411985, 0.5275590985780101, 0.047280083515270466, 0.24397143488299422, 0.04733710982895989, 0.08351678012008856, 9.999999999998899e-05, 0.014917106639691702, 0.368254609524044, 0.3272642463595007, 0.3864819515362671, 0.1551166750546834, 0.10380914010160835, 0.3389304229154937, 0.17058079593768105, 0.16070320568293806, 0.4907602692014037, 0.4995126940105944, 0.4356396831147221, 0.047741705614088636, 0.027543043285322533, 0.1120100574695383, 0.27916240623739474, 0.18219625042043686, 0.21979556957355872, 0.14067757889202004, 0.07844902470227921, 0.08001860886587331, 0.0921042232324617, 0.328983475266714, 0.2707252214685475, 0.3053356023314383, 0.35101624580362767, 0.33839292060069914, 0.20462407816886952, 0.2675191212868223, 0.3172935496294752, 0.07808740495240984, 0.6714227158723666, 0.6564505939845847, 0.688127136440414, 0.6867955406164978, 0.6733510132156802, 0.20747949873295768, 0.6731462263615986, 0.6464462662119996, 0.6674895537976484, 0.06502000360985916, 0.11467758342238044, 0.1734310110397329, 0.13363768289104194, 0.10249862169264101, 0.13692067452388113, 0.107238552437531, 0.10835445208329908, 0.08397889319916663, 0.30634150565495855, 0.6314993891645544, 0.22158853554174018, 0.28556628014466856, 0.3123441698629541, 0.4473922637937656, 0.267163873535879, 0.3207449352899351, 0.30405899734829755, 0.41953246193093696, 0.37666967804151275, 0.3922861310169521, 0.4606417565560065, 0.47889525867298965, 0.5205415453091733, 0.4672199125634394, 0.56201623865664, 0.5019744435477382, 0.22967954340488406, 0.40719660906415867, 0.28136763558903854, 0.2950743403132333, 0.35037947434473304, 0.20998262638577303, 0.2382556559034842, 0.3131285160623747, 0.32570191027695305, 0.22171504998705294, 0.21489999327318943, 0.21060128308076587, 0.21858154272544061, 0.22589857479698516, 0.19837446667273984, 0.2399733912068024, 0.20999662914588924, 0.22652828263541425, 0.1945850626390676, 0.2322435418536245, 0.20616003719144071, 0.19867968756860555, 0.23007770982614806, 0.19516880453108942, 0.24206299572512957, 0.22672709155055915, 0.215338466680289, 0.16898389541565373, 0.1829501263539931, 0.15389129171897276, 0.8426012955625389, 0.1999430103148937, 0.1979949033364592, 0.1417891047908797, 0.16874335034126287, 0.8569557825426235, 0.7847945929326563, 0.20800334364395523, 0.802483089518517, 0.759153315860152, 0.7156379225244047, 0.09355560174492039, 0.20037512425094084, 0.20599465529225736, 0.784655997808277, 0.18482143751045532, 0.19629051731181246, 0.1812747604203393, 0.19882261757759478, 0.19410831182405586, 0.179143214990225, 0.2737466082235579, 0.1911246247047964, 0.2744245816638109, 0.08904607468280124, 0.09896632344581668, 0.10740438565074151, 0.08971004260142545, 0.08923823703648981, 0.0792926435400092, 0.09119049419689562, 0.09681350426148527, 0.09213050576183923]}, "mutation_prompt": null}
{"id": "2d44aaaf-dda6-4615-9652-0d5ba11da797", "solution": "import numpy as np\n\nclass AdaptiveHybridEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Modified population size for efficiency\n        self.w = 0.7  # Dynamic inertia weight for better exploration\n        self.cr = 0.85  # Crossover probability adjusted for balance\n        self.f = 0.6  # Tuned mutation factor for controlled diversity\n        self.pm = 0.2  # Increased mutation probability for exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.3, 0.3, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Hybrid DE and PSO Mutation\n                if evaluations < self.budget // 2:\n                    indices = np.random.choice(self.pop_size, 3, replace=False)\n                    x0, x1, x2 = population[indices]\n                    mutant = x0 + self.f * (x1 - x2)\n                else:\n                    mutant = personal_best[i] + self.f * (global_best - personal_best[i])\n                    \n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n                    \n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n            \n            # PSO Update with dynamic inertia weight\n            self.w = 0.4 + 0.3 * (evaluations / self.budget)  # Adaptive inertia\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n                \n                # Evaluate new position\n                f_val = func(population[i])\n                evaluations += 1\n                \n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n                    \n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n        \n        return global_best", "name": "AdaptiveHybridEA", "description": "A novel Adaptive Hybrid Evolutionary Algorithm combining exploratory and exploitative strategies to balance exploration and convergence speed.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5b8b007a-3cd6-4b59-99cd-af39c8171d4d", "metadata": {"aucs": [0.8871826822908224, 0.8711148637881581, 0.8900291041130235, 0.8628368413957237, 0.8738819632321351, 0.8685709209937958, 0.8790834633499045, 0.8815821150451915, 0.8691979250913316, 0.6745682896195839, 0.6497727795444479, 0.6535111661640098, 0.61430553306501, 0.5993027436486895, 0.6904930928099209, 0.08815916252972134, 0.609746502312775, 0.5723425198024741, 0.18057536308494837, 0.14061710775580305, 0.0876930074630965, 0.1307679203985186, 0.10623345200438705, 0.11923907409012358, 0.11013936873072583, 0.10444962213872877, 0.11250150847723506, 0.0885385403196125, 0.08606608605302868, 0.06454608623234603, 0.11272783231638661, 0.11567160374602248, 0.10795369690719725, 0.10438840546659689, 0.11254159325265467, 0.08994284175248157, 0.9714650440728757, 0.9643907801948479, 0.9696635986458755, 0.9712349850032499, 0.9690040821929, 0.9548066838502615, 0.9637411448251363, 0.9765915817241605, 0.9733781222676917, 0.7793985549618262, 0.7549110028449186, 0.7114722368869126, 0.7415753158569725, 0.7677624818906092, 0.7711871443122863, 0.7497121758602364, 0.7790931284561528, 0.7650917966883054, 0.8706667607121773, 0.8747753844500974, 0.8712004480241841, 0.2791320528135913, 0.27909140051728254, 0.1911862526831858, 0.13815062601740047, 0.23333450121167187, 0.2405183002806447, 0.6337961206658999, 0.5746272598735032, 0.6897260431435153, 0.3730875786577842, 0.6417524870774309, 0.13211899505545877, 0.6500645830469493, 0.6962820217538823, 0.7180159692263058, 0.6043751718452135, 0.7327950775506178, 0.6366286604472307, 0.1324942169302451, 0.6732757983144831, 0.13179730619848085, 0.7110431555927736, 0.13238690620581506, 0.5848320257412571, 0.5073520735209601, 0.4307014717562302, 0.09072150721509153, 0.04172432636729606, 0.27047948964185453, 0.028428734603196393, 0.23420701301605118, 0.07031841134560524, 0.3700982018166826, 0.13387734476806012, 0.2080227888962184, 0.2902850105526533, 0.32542154576412774, 0.5845996803524591, 0.26152944822535595, 0.610434405007612, 0.6033832152408869, 0.5101125086285687, 0.034485008551899954, 0.08023984124751549, 0.12161820637798704, 0.19489448535791176, 0.24104525904494445, 0.21098618295738836, 0.09784638120450129, 0.17395211230213858, 0.2911883234749124, 0.13028441596139306, 0.19130915755294453, 0.17348159082630443, 0.09807844052665038, 0.4305554884280769, 0.14317246827879393, 0.13363362557726455, 0.22080962370739876, 0.08398982053884596, 0.7762764780456178, 0.671698768438392, 0.7719732555941774, 0.7237756778173619, 0.7356057362057925, 0.757019070242464, 0.7646337086769299, 0.7064259495544636, 0.718076057523494, 0.14151808448559444, 0.18090758218923875, 0.12090242318252309, 0.10471127133620661, 0.1570622800246898, 0.14801595501022402, 0.06431198586880205, 0.10121908323922779, 0.14508653563691265, 0.1562362703040553, 0.3812126514345603, 0.17679578908107196, 0.22082173159101826, 0.26149877289625634, 0.2636895229053955, 0.47603561922641, 0.18894656867883342, 0.1890837330369266, 0.3567205821202809, 0.5058993549931575, 0.29634798996595724, 0.5577074289089985, 0.3116428147295257, 0.3400425031025244, 0.24966015485128557, 0.2958663926998971, 0.5103740265167868, 0.23986696780444983, 0.246484619819746, 0.3079542670864406, 0.3375485699425822, 0.3184157236071731, 0.23709242458789026, 0.23390513176627414, 0.26923332614020634, 0.2809083621234971, 0.24802194169810077, 0.2420945298248025, 0.19428903748228932, 0.22810448207992662, 0.23185270508255662, 0.22323536408431577, 0.23877846300022865, 0.23699163073073437, 0.22224697053922815, 0.19112149038145865, 0.2110324029592664, 0.19814132744573665, 0.18567213267394322, 0.22454691083231682, 0.20616286032352982, 0.18975543055884303, 0.21434944748462093, 0.2073368553394267, 0.9018931723263484, 0.17820931203384538, 0.15345948087581418, 0.15851774816452924, 0.2002759780334522, 0.9200080674742466, 0.14214210928780324, 0.17509271132851278, 0.15309861504259703, 0.9230336635570204, 0.2120305511231576, 0.1671992577857898, 0.21077122242591173, 0.1686224042490796, 0.1546551915092872, 0.2116603712084364, 0.2107332150458754, 0.8884871739046369, 0.19960798281485825, 0.19752073390828018, 0.20332250853795486, 0.20771161292298668, 0.2008703208389765, 0.2126380915421271, 0.2185082934300041, 0.20771226243627972, 0.20063246340670515, 0.09572188254788472, 0.10813638928069735, 0.10605261642879726, 0.11079340429611018, 0.0882453949337596, 0.09320334440616151, 0.09545199416061956, 0.1035399222802893, 0.10383563988477729]}, "mutation_prompt": null}
{"id": "dbb46396-4ef1-462b-a033-8d947248d68c", "solution": "import numpy as np\n\nclass AdaptiveHybridEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Modified population size for efficiency\n        self.w = 0.7  # Dynamic inertia weight for better exploration\n        self.cr = 0.85  # Crossover probability adjusted for balance\n        self.f = 0.6  # Tuned mutation factor for controlled diversity\n        self.pm = 0.2  # Increased mutation probability for exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.3, 0.3, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Hybrid DE and PSO Mutation\n                if evaluations < self.budget // 2:\n                    indices = np.random.choice(self.pop_size, 3, replace=False)\n                    x0, x1, x2 = population[indices]\n                    mutant = x0 + self.f * (x1 - x2)\n                else:\n                    mutant = personal_best[i] + self.f * (global_best - personal_best[i])\n                    \n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n                    \n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n            \n            # PSO Update with dynamic inertia weight\n            self.w = 0.4 + 0.3 * (evaluations / self.budget)  # Adaptive inertia\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n                \n                # Evaluate new position\n                f_val = func(population[i])\n                evaluations += 1\n                \n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n                    \n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n        \n        return global_best", "name": "AdaptiveHybridEA", "description": "A novel Adaptive Hybrid Evolutionary Algorithm combining exploratory and exploitative strategies to balance exploration and convergence speed.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5b8b007a-3cd6-4b59-99cd-af39c8171d4d", "metadata": {"aucs": [0.8871826822908224, 0.8711148637881581, 0.8900291041130235, 0.8628368413957237, 0.8738819632321351, 0.8685709209937958, 0.8790834633499045, 0.8815821150451915, 0.8691979250913316, 0.6745682896195839, 0.6497727795444479, 0.6535111661640098, 0.61430553306501, 0.5993027436486895, 0.6904930928099209, 0.08815916252972134, 0.609746502312775, 0.5723425198024741, 0.18057536308494837, 0.14061710775580305, 0.0876930074630965, 0.1307679203985186, 0.10623345200438705, 0.11923907409012358, 0.11013936873072583, 0.10444962213872877, 0.11250150847723506, 0.0885385403196125, 0.08606608605302868, 0.06454608623234603, 0.11272783231638661, 0.11567160374602248, 0.10795369690719725, 0.10438840546659689, 0.11254159325265467, 0.08994284175248157, 0.9714650440728757, 0.9643907801948479, 0.9696635986458755, 0.9712349850032499, 0.9690040821929, 0.9548066838502615, 0.9637411448251363, 0.9765915817241605, 0.9733781222676917, 0.7793985549618262, 0.7549110028449186, 0.7114722368869126, 0.7415753158569725, 0.7677624818906092, 0.7711871443122863, 0.7497121758602364, 0.7790931284561528, 0.7650917966883054, 0.8706667607121773, 0.8747753844500974, 0.8712004480241841, 0.2791320528135913, 0.27909140051728254, 0.1911862526831858, 0.13815062601740047, 0.23333450121167187, 0.2405183002806447, 0.6337961206658999, 0.5746272598735032, 0.6897260431435153, 0.3730875786577842, 0.6417524870774309, 0.13211899505545877, 0.6500645830469493, 0.6962820217538823, 0.7180159692263058, 0.6043751718452135, 0.7327950775506178, 0.6366286604472307, 0.1324942169302451, 0.6732757983144831, 0.13179730619848085, 0.7110431555927736, 0.13238690620581506, 0.5848320257412571, 0.5073520735209601, 0.4307014717562302, 0.09072150721509153, 0.04172432636729606, 0.27047948964185453, 0.028428734603196393, 0.23420701301605118, 0.07031841134560524, 0.3700982018166826, 0.13387734476806012, 0.2080227888962184, 0.2902850105526533, 0.32542154576412774, 0.5845996803524591, 0.26152944822535595, 0.610434405007612, 0.6033832152408869, 0.5101125086285687, 0.034485008551899954, 0.08023984124751549, 0.12161820637798704, 0.19489448535791176, 0.24104525904494445, 0.21098618295738836, 0.09784638120450129, 0.17395211230213858, 0.2911883234749124, 0.13028441596139306, 0.19130915755294453, 0.17348159082630443, 0.09807844052665038, 0.4305554884280769, 0.14317246827879393, 0.13363362557726455, 0.22080962370739876, 0.08398982053884596, 0.7762764780456178, 0.671698768438392, 0.7719732555941774, 0.7237756778173619, 0.7356057362057925, 0.757019070242464, 0.7646337086769299, 0.7064259495544636, 0.718076057523494, 0.14151808448559444, 0.18090758218923875, 0.12090242318252309, 0.10471127133620661, 0.1570622800246898, 0.14801595501022402, 0.06431198586880205, 0.10121908323922779, 0.14508653563691265, 0.1562362703040553, 0.3812126514345603, 0.17679578908107196, 0.22082173159101826, 0.26149877289625634, 0.2636895229053955, 0.47603561922641, 0.18894656867883342, 0.1890837330369266, 0.3567205821202809, 0.5058993549931575, 0.29634798996595724, 0.5577074289089985, 0.3116428147295257, 0.3400425031025244, 0.24966015485128557, 0.2958663926998971, 0.5103740265167868, 0.23986696780444983, 0.246484619819746, 0.3079542670864406, 0.3375485699425822, 0.3184157236071731, 0.23709242458789026, 0.23390513176627414, 0.26923332614020634, 0.2809083621234971, 0.24802194169810077, 0.2420945298248025, 0.19428903748228932, 0.22810448207992662, 0.23185270508255662, 0.22323536408431577, 0.23877846300022865, 0.23699163073073437, 0.22224697053922815, 0.19112149038145865, 0.2110324029592664, 0.19814132744573665, 0.18567213267394322, 0.22454691083231682, 0.20616286032352982, 0.18975543055884303, 0.21434944748462093, 0.2073368553394267, 0.9018931723263484, 0.17820931203384538, 0.15345948087581418, 0.15851774816452924, 0.2002759780334522, 0.9200080674742466, 0.14214210928780324, 0.17509271132851278, 0.15309861504259703, 0.9230336635570204, 0.2120305511231576, 0.1671992577857898, 0.21077122242591173, 0.1686224042490796, 0.1546551915092872, 0.2116603712084364, 0.2107332150458754, 0.8884871739046369, 0.19960798281485825, 0.19752073390828018, 0.20332250853795486, 0.20771161292298668, 0.2008703208389765, 0.2126380915421271, 0.2185082934300041, 0.20771226243627972, 0.20063246340670515, 0.09572188254788472, 0.10813638928069735, 0.10605261642879726, 0.11079340429611018, 0.0882453949337596, 0.09320334440616151, 0.09545199416061956, 0.1035399222802893, 0.10383563988477729]}, "mutation_prompt": null}
{"id": "c1fcae6d-d344-4a2a-a7f6-229b5b7a5ed0", "solution": "import numpy as np\n\nclass AdaptiveHybridEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Modified population size for efficiency\n        self.w = 0.7  # Dynamic inertia weight for better exploration\n        self.cr = 0.85  # Crossover probability adjusted for balance\n        self.f = 0.6  # Tuned mutation factor for controlled diversity\n        self.pm = 0.2  # Increased mutation probability for exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.3, 0.3, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Hybrid DE and PSO Mutation\n                if evaluations < self.budget // 2:\n                    indices = np.random.choice(self.pop_size, 3, replace=False)\n                    x0, x1, x2 = population[indices]\n                    mutant = x0 + self.f * (x1 - x2)\n                else:\n                    mutant = personal_best[i] + self.f * (global_best - personal_best[i])\n                    \n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n                    \n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n            \n            # PSO Update with dynamic inertia weight\n            self.w = 0.4 + 0.3 * (evaluations / self.budget)  # Adaptive inertia\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n                \n                # Evaluate new position\n                f_val = func(population[i])\n                evaluations += 1\n                \n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n                    \n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n        \n        return global_best", "name": "AdaptiveHybridEA", "description": "A novel Adaptive Hybrid Evolutionary Algorithm combining exploratory and exploitative strategies to balance exploration and convergence speed.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5b8b007a-3cd6-4b59-99cd-af39c8171d4d", "metadata": {"aucs": [0.8871826822908224, 0.8711148637881581, 0.8900291041130235, 0.8628368413957237, 0.8738819632321351, 0.8685709209937958, 0.8790834633499045, 0.8815821150451915, 0.8691979250913316, 0.6745682896195839, 0.6497727795444479, 0.6535111661640098, 0.61430553306501, 0.5993027436486895, 0.6904930928099209, 0.08815916252972134, 0.609746502312775, 0.5723425198024741, 0.18057536308494837, 0.14061710775580305, 0.0876930074630965, 0.1307679203985186, 0.10623345200438705, 0.11923907409012358, 0.11013936873072583, 0.10444962213872877, 0.11250150847723506, 0.0885385403196125, 0.08606608605302868, 0.06454608623234603, 0.11272783231638661, 0.11567160374602248, 0.10795369690719725, 0.10438840546659689, 0.11254159325265467, 0.08994284175248157, 0.9714650440728757, 0.9643907801948479, 0.9696635986458755, 0.9712349850032499, 0.9690040821929, 0.9548066838502615, 0.9637411448251363, 0.9765915817241605, 0.9733781222676917, 0.7793985549618262, 0.7549110028449186, 0.7114722368869126, 0.7415753158569725, 0.7677624818906092, 0.7711871443122863, 0.7497121758602364, 0.7790931284561528, 0.7650917966883054, 0.8706667607121773, 0.8747753844500974, 0.8712004480241841, 0.2791320528135913, 0.27909140051728254, 0.1911862526831858, 0.13815062601740047, 0.23333450121167187, 0.2405183002806447, 0.6337961206658999, 0.5746272598735032, 0.6897260431435153, 0.3730875786577842, 0.6417524870774309, 0.13211899505545877, 0.6500645830469493, 0.6962820217538823, 0.7180159692263058, 0.6043751718452135, 0.7327950775506178, 0.6366286604472307, 0.1324942169302451, 0.6732757983144831, 0.13179730619848085, 0.7110431555927736, 0.13238690620581506, 0.5848320257412571, 0.5073520735209601, 0.4307014717562302, 0.09072150721509153, 0.04172432636729606, 0.27047948964185453, 0.028428734603196393, 0.23420701301605118, 0.07031841134560524, 0.3700982018166826, 0.13387734476806012, 0.2080227888962184, 0.2902850105526533, 0.32542154576412774, 0.5845996803524591, 0.26152944822535595, 0.610434405007612, 0.6033832152408869, 0.5101125086285687, 0.034485008551899954, 0.08023984124751549, 0.12161820637798704, 0.19489448535791176, 0.24104525904494445, 0.21098618295738836, 0.09784638120450129, 0.17395211230213858, 0.2911883234749124, 0.13028441596139306, 0.19130915755294453, 0.17348159082630443, 0.09807844052665038, 0.4305554884280769, 0.14317246827879393, 0.13363362557726455, 0.22080962370739876, 0.08398982053884596, 0.7762764780456178, 0.671698768438392, 0.7719732555941774, 0.7237756778173619, 0.7356057362057925, 0.757019070242464, 0.7646337086769299, 0.7064259495544636, 0.718076057523494, 0.14151808448559444, 0.18090758218923875, 0.12090242318252309, 0.10471127133620661, 0.1570622800246898, 0.14801595501022402, 0.06431198586880205, 0.10121908323922779, 0.14508653563691265, 0.1562362703040553, 0.3812126514345603, 0.17679578908107196, 0.22082173159101826, 0.26149877289625634, 0.2636895229053955, 0.47603561922641, 0.18894656867883342, 0.1890837330369266, 0.3567205821202809, 0.5058993549931575, 0.29634798996595724, 0.5577074289089985, 0.3116428147295257, 0.3400425031025244, 0.24966015485128557, 0.2958663926998971, 0.5103740265167868, 0.23986696780444983, 0.246484619819746, 0.3079542670864406, 0.3375485699425822, 0.3184157236071731, 0.23709242458789026, 0.23390513176627414, 0.26923332614020634, 0.2809083621234971, 0.24802194169810077, 0.2420945298248025, 0.19428903748228932, 0.22810448207992662, 0.23185270508255662, 0.22323536408431577, 0.23877846300022865, 0.23699163073073437, 0.22224697053922815, 0.19112149038145865, 0.2110324029592664, 0.19814132744573665, 0.18567213267394322, 0.22454691083231682, 0.20616286032352982, 0.18975543055884303, 0.21434944748462093, 0.2073368553394267, 0.9018931723263484, 0.17820931203384538, 0.15345948087581418, 0.15851774816452924, 0.2002759780334522, 0.9200080674742466, 0.14214210928780324, 0.17509271132851278, 0.15309861504259703, 0.9230336635570204, 0.2120305511231576, 0.1671992577857898, 0.21077122242591173, 0.1686224042490796, 0.1546551915092872, 0.2116603712084364, 0.2107332150458754, 0.8884871739046369, 0.19960798281485825, 0.19752073390828018, 0.20332250853795486, 0.20771161292298668, 0.2008703208389765, 0.2126380915421271, 0.2185082934300041, 0.20771226243627972, 0.20063246340670515, 0.09572188254788472, 0.10813638928069735, 0.10605261642879726, 0.11079340429611018, 0.0882453949337596, 0.09320334440616151, 0.09545199416061956, 0.1035399222802893, 0.10383563988477729]}, "mutation_prompt": null}
{"id": "ca5bf888-5bd1-438d-a29b-00bee4004ac9", "solution": "import numpy as np\n\nclass EnhancedHybridEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Increased population size for diversity\n        self.w = 0.5  # Adaptive inertia weight for balanced exploration\n        self.cr = 0.9  # Higher crossover probability for diversity\n        self.f = 0.5  # Reduced mutation factor for stability\n        self.pm = 0.25  # Further increased mutation probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.pop_size\n        \n        # Adaptive DE and PSO loop\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                \n                # Adaptive DE Mutation\n                if evaluations < 0.3 * self.budget:\n                    indices = np.random.choice(self.pop_size, 4, replace=False)\n                    x0, x1, x2, x3 = population[indices]\n                    mutant = x0 + self.f * (x1 - x2) + self.f * (x3 - global_best)\n                else:\n                    r = np.random.rand()\n                    if r < 0.7:  # More exploration in early stages\n                        indices = np.random.choice(self.pop_size, 2, replace=False)\n                        x0, x1 = population[indices]\n                        mutant = x0 + self.f * (x1 - personal_best[i])\n                    else:\n                        mutant = personal_best[i] + self.f * (global_best - personal_best[i])\n                \n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n                    \n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n            # PSO Update with adaptive inertia weight\n            self.w = 0.5 + 0.2 * (1 - evaluations / self.budget)  # More inertia at start, less towards end\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n                \n                # Evaluate new position\n                f_val = func(population[i])\n                evaluations += 1\n                \n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n                    \n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n        \n        return global_best", "name": "EnhancedHybridEA", "description": "An Enhanced Hybrid Evolutionary Algorithm integrating Adaptive Differential Evolution and Particle Swarm Optimization for improved exploration-exploitation balance and faster convergence.", "configspace": "", "generation": 28, "fitness": 0.32694302314853063, "feedback": "The algorithm EnhancedHybridEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.", "error": "", "parent_id": "5b8b007a-3cd6-4b59-99cd-af39c8171d4d", "metadata": {"aucs": [0.7752627864559238, 0.7836468942164598, 0.7622268659167994, 0.7742530341879503, 0.7932524035311843, 0.775958123665996, 0.7827422435576943, 0.7576983555632038, 0.7750442164684892, 0.28727735592782233, 0.3911429775289489, 0.30423172525616726, 0.37034707433291136, 0.3348278224266722, 0.3496065354207142, 0.43210635468509206, 0.40895581068632436, 0.45297183970037513, 0.08041210188225356, 0.08841069422319037, 0.10381154549528959, 0.14400166791628832, 0.11055224819606824, 0.08649354204707616, 0.1347882445185029, 0.12721817443961825, 0.12128200662890554, 0.13628346070431818, 0.08797641773850906, 0.12860669928348634, 0.10312367243286358, 0.1015173909610323, 0.06259742847685812, 0.10046963766575334, 0.12311381493084206, 0.10308833312888133, 0.9639438019502803, 0.9727688664399083, 0.9651727426226072, 0.9407266361036482, 0.9657066182690974, 0.9651006920068909, 0.9773639448058556, 0.9731045133001992, 0.9646853033088286, 0.6288078334772588, 0.592264314755216, 0.5672819908096267, 0.5606363055109205, 0.5816716921299344, 0.1511525430868309, 0.5888165763657205, 0.5801741407201483, 0.5957004733967521, 0.7610964248337924, 0.7568783040449525, 0.7677561946856727, 0.2178971969871032, 0.21172218238305862, 0.2684768928671739, 0.7830629395890671, 0.2274291163737615, 0.23258098440159902, 0.3797149758912026, 0.45762526301044404, 0.42122925445638426, 0.12274034028240732, 0.12492667426178883, 0.12494263190283394, 0.45801687367021604, 0.12744852784455374, 0.5338264523206675, 0.4884590293928397, 0.5069048232195588, 0.5288927751957859, 0.5273647220195482, 0.4369274300026015, 0.37273948691015757, 0.5080153310804738, 0.5222139123850125, 0.4439727926770102, 0.026402939711528406, 0.20287785649659262, 0.1518349867148887, 0.23290458602144015, 0.05824431950059439, 0.01334179545019909, 0.11154144892455642, 0.17035928687681112, 0.26062543385845116, 0.38350157583491706, 0.44381466529409075, 0.3518823059059747, 0.28068492367147524, 0.17505980132262267, 0.33321631006915364, 0.4233358029391274, 0.35475548561335024, 0.36162923630365806, 0.3052947233434189, 0.10189244957713839, 0.1149937801785732, 0.07415274245991954, 0.13902420619321165, 0.12113804723955057, 0.10866747983678049, 0.12245247588428865, 0.07889423487792868, 0.10385418214004571, 0.14094419126741997, 0.25319390125621244, 0.30993511897911585, 0.08006186447139152, 0.11450542947540776, 0.1335902454364024, 0.07787888669301302, 0.08497215918463263, 0.6022146996480962, 0.5662870393627331, 0.5741099758293374, 0.5574310275793157, 0.6660478459352898, 0.6295262364654179, 0.6181604850822164, 0.5833884496945293, 0.6012317794756029, 0.07534203156049402, 0.13833275382850296, 0.06539457804189075, 0.11556462463564587, 0.14375268717516887, 0.13145298062729383, 0.10902343727234898, 0.14951260486541018, 0.07436874944380778, 0.20515569381009324, 0.1599729216133624, 0.21085061178833642, 0.18994771199404714, 0.20734628077637185, 0.2417583783209185, 0.26302333963008273, 0.22928793432107253, 0.258596931777732, 0.2749743096772673, 0.23769341197832905, 0.41087687820554, 0.24494488566673467, 0.42114040202084, 0.4114671698159842, 0.3855099084045466, 0.4589108151722755, 0.4551603170241014, 0.221387178793083, 0.31546753204667377, 0.22090311295274123, 0.23565637103364712, 0.2846581607856101, 0.27421058457980285, 0.2362806499057658, 0.3089453076114701, 0.259384614152842, 0.2077009196888202, 0.22184407680128293, 0.22583316052005153, 0.26190561430536696, 0.2280811918883452, 0.22973238537354235, 0.23067794772233408, 0.22773690527424584, 0.2344465269533298, 0.18386587424881473, 0.20632014259756992, 0.19693238135795776, 0.19464706755607908, 0.1713683724020384, 0.18361887987679915, 0.17966601627056789, 0.1856114714834478, 0.1773629862596834, 0.7934932150802287, 0.18757922795174242, 0.19703359116017916, 0.8411182632348142, 0.19959878385344076, 0.14792907581271242, 0.14250062179649015, 0.158715599459745, 0.8535792201405767, 0.83192330752128, 0.1698277422640032, 0.1555595346458123, 0.20672279788877612, 0.6678825423493349, 0.1534498594117073, 0.10462656300771855, 0.16546878128945341, 0.16763487438113533, 0.2001742538008049, 0.19657872786001773, 0.21864964394533826, 0.2188569721208593, 0.20027354056511637, 0.21311684969971234, 0.20350982621235614, 0.2219971891282918, 0.20281781082609762, 0.09297881965901655, 0.15327983161386216, 0.086328356632006, 0.08489990058074925, 0.0823783751506566, 0.09717450322127585, 0.12296544001662568, 0.07790536243046375, 0.12445977345582593]}, "mutation_prompt": null}
{"id": "d775fa98-b55e-4c7a-b5c5-24db9d7f2ab3", "solution": "import numpy as np\n\nclass AdaptiveHybridEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Modified population size for efficiency\n        self.w = 0.7  # Dynamic inertia weight for better exploration\n        self.cr = 0.85  # Crossover probability adjusted for balance\n        self.f = 0.6  # Tuned mutation factor for controlled diversity\n        self.pm = 0.2  # Increased mutation probability for exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.3, 0.3, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Hybrid DE and PSO Mutation\n                if evaluations < self.budget // 2:\n                    indices = np.random.choice(self.pop_size, 3, replace=False)\n                    x0, x1, x2 = population[indices]\n                    mutant = x0 + self.f * (x1 - x2)\n                else:\n                    mutant = personal_best[i] + self.f * (global_best - personal_best[i])\n                    \n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n                    \n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n            \n            # PSO Update with dynamic inertia weight\n            self.w = 0.4 + 0.3 * (evaluations / self.budget)  # Adaptive inertia\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n                \n                # Evaluate new position\n                f_val = func(population[i])\n                evaluations += 1\n                \n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n                    \n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n        \n        return global_best", "name": "AdaptiveHybridEA", "description": "A novel Adaptive Hybrid Evolutionary Algorithm combining exploratory and exploitative strategies to balance exploration and convergence speed.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5b8b007a-3cd6-4b59-99cd-af39c8171d4d", "metadata": {"aucs": [0.8871826822908224, 0.8711148637881581, 0.8900291041130235, 0.8628368413957237, 0.8738819632321351, 0.8685709209937958, 0.8790834633499045, 0.8815821150451915, 0.8691979250913316, 0.6745682896195839, 0.6497727795444479, 0.6535111661640098, 0.61430553306501, 0.5993027436486895, 0.6904930928099209, 0.08815916252972134, 0.609746502312775, 0.5723425198024741, 0.18057536308494837, 0.14061710775580305, 0.0876930074630965, 0.1307679203985186, 0.10623345200438705, 0.11923907409012358, 0.11013936873072583, 0.10444962213872877, 0.11250150847723506, 0.0885385403196125, 0.08606608605302868, 0.06454608623234603, 0.11272783231638661, 0.11567160374602248, 0.10795369690719725, 0.10438840546659689, 0.11254159325265467, 0.08994284175248157, 0.9714650440728757, 0.9643907801948479, 0.9696635986458755, 0.9712349850032499, 0.9690040821929, 0.9548066838502615, 0.9637411448251363, 0.9765915817241605, 0.9733781222676917, 0.7793985549618262, 0.7549110028449186, 0.7114722368869126, 0.7415753158569725, 0.7677624818906092, 0.7711871443122863, 0.7497121758602364, 0.7790931284561528, 0.7650917966883054, 0.8706667607121773, 0.8747753844500974, 0.8712004480241841, 0.2791320528135913, 0.27909140051728254, 0.1911862526831858, 0.13815062601740047, 0.23333450121167187, 0.2405183002806447, 0.6337961206658999, 0.5746272598735032, 0.6897260431435153, 0.3730875786577842, 0.6417524870774309, 0.13211899505545877, 0.6500645830469493, 0.6962820217538823, 0.7180159692263058, 0.6043751718452135, 0.7327950775506178, 0.6366286604472307, 0.1324942169302451, 0.6732757983144831, 0.13179730619848085, 0.7110431555927736, 0.13238690620581506, 0.5848320257412571, 0.5073520735209601, 0.4307014717562302, 0.09072150721509153, 0.04172432636729606, 0.27047948964185453, 0.028428734603196393, 0.23420701301605118, 0.07031841134560524, 0.3700982018166826, 0.13387734476806012, 0.2080227888962184, 0.2902850105526533, 0.32542154576412774, 0.5845996803524591, 0.26152944822535595, 0.610434405007612, 0.6033832152408869, 0.5101125086285687, 0.034485008551899954, 0.08023984124751549, 0.12161820637798704, 0.19489448535791176, 0.24104525904494445, 0.21098618295738836, 0.09784638120450129, 0.17395211230213858, 0.2911883234749124, 0.13028441596139306, 0.19130915755294453, 0.17348159082630443, 0.09807844052665038, 0.4305554884280769, 0.14317246827879393, 0.13363362557726455, 0.22080962370739876, 0.08398982053884596, 0.7762764780456178, 0.671698768438392, 0.7719732555941774, 0.7237756778173619, 0.7356057362057925, 0.757019070242464, 0.7646337086769299, 0.7064259495544636, 0.718076057523494, 0.14151808448559444, 0.18090758218923875, 0.12090242318252309, 0.10471127133620661, 0.1570622800246898, 0.14801595501022402, 0.06431198586880205, 0.10121908323922779, 0.14508653563691265, 0.1562362703040553, 0.3812126514345603, 0.17679578908107196, 0.22082173159101826, 0.26149877289625634, 0.2636895229053955, 0.47603561922641, 0.18894656867883342, 0.1890837330369266, 0.3567205821202809, 0.5058993549931575, 0.29634798996595724, 0.5577074289089985, 0.3116428147295257, 0.3400425031025244, 0.24966015485128557, 0.2958663926998971, 0.5103740265167868, 0.23986696780444983, 0.246484619819746, 0.3079542670864406, 0.3375485699425822, 0.3184157236071731, 0.23709242458789026, 0.23390513176627414, 0.26923332614020634, 0.2809083621234971, 0.24802194169810077, 0.2420945298248025, 0.19428903748228932, 0.22810448207992662, 0.23185270508255662, 0.22323536408431577, 0.23877846300022865, 0.23699163073073437, 0.22224697053922815, 0.19112149038145865, 0.2110324029592664, 0.19814132744573665, 0.18567213267394322, 0.22454691083231682, 0.20616286032352982, 0.18975543055884303, 0.21434944748462093, 0.2073368553394267, 0.9018931723263484, 0.17820931203384538, 0.15345948087581418, 0.15851774816452924, 0.2002759780334522, 0.9200080674742466, 0.14214210928780324, 0.17509271132851278, 0.15309861504259703, 0.9230336635570204, 0.2120305511231576, 0.1671992577857898, 0.21077122242591173, 0.1686224042490796, 0.1546551915092872, 0.2116603712084364, 0.2107332150458754, 0.8884871739046369, 0.19960798281485825, 0.19752073390828018, 0.20332250853795486, 0.20771161292298668, 0.2008703208389765, 0.2126380915421271, 0.2185082934300041, 0.20771226243627972, 0.20063246340670515, 0.09572188254788472, 0.10813638928069735, 0.10605261642879726, 0.11079340429611018, 0.0882453949337596, 0.09320334440616151, 0.09545199416061956, 0.1035399222802893, 0.10383563988477729]}, "mutation_prompt": null}
{"id": "fa8c23e0-e207-4528-8c67-577d116b4f2a", "solution": "import numpy as np\n\nclass AdaptiveHybridEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Modified population size for efficiency\n        self.w = 0.7  # Dynamic inertia weight for better exploration\n        self.cr = 0.85  # Crossover probability adjusted for balance\n        self.f = 0.6  # Tuned mutation factor for controlled diversity\n        self.pm = 0.2  # Increased mutation probability for exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.3, 0.3, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Hybrid DE and PSO Mutation\n                if evaluations < self.budget // 2:\n                    indices = np.random.choice(self.pop_size, 3, replace=False)\n                    x0, x1, x2 = population[indices]\n                    mutant = x0 + self.f * (x1 - x2)\n                else:\n                    mutant = personal_best[i] + self.f * (global_best - personal_best[i])\n                    \n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n                    \n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n            \n            # PSO Update with dynamic inertia weight\n            self.w = 0.4 + 0.3 * (evaluations / self.budget)  # Adaptive inertia\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n                \n                # Evaluate new position\n                f_val = func(population[i])\n                evaluations += 1\n                \n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n                    \n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n        \n        return global_best", "name": "AdaptiveHybridEA", "description": "A novel Adaptive Hybrid Evolutionary Algorithm combining exploratory and exploitative strategies to balance exploration and convergence speed.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5b8b007a-3cd6-4b59-99cd-af39c8171d4d", "metadata": {"aucs": [0.8871826822908224, 0.8711148637881581, 0.8900291041130235, 0.8628368413957237, 0.8738819632321351, 0.8685709209937958, 0.8790834633499045, 0.8815821150451915, 0.8691979250913316, 0.6745682896195839, 0.6497727795444479, 0.6535111661640098, 0.61430553306501, 0.5993027436486895, 0.6904930928099209, 0.08815916252972134, 0.609746502312775, 0.5723425198024741, 0.18057536308494837, 0.14061710775580305, 0.0876930074630965, 0.1307679203985186, 0.10623345200438705, 0.11923907409012358, 0.11013936873072583, 0.10444962213872877, 0.11250150847723506, 0.0885385403196125, 0.08606608605302868, 0.06454608623234603, 0.11272783231638661, 0.11567160374602248, 0.10795369690719725, 0.10438840546659689, 0.11254159325265467, 0.08994284175248157, 0.9714650440728757, 0.9643907801948479, 0.9696635986458755, 0.9712349850032499, 0.9690040821929, 0.9548066838502615, 0.9637411448251363, 0.9765915817241605, 0.9733781222676917, 0.7793985549618262, 0.7549110028449186, 0.7114722368869126, 0.7415753158569725, 0.7677624818906092, 0.7711871443122863, 0.7497121758602364, 0.7790931284561528, 0.7650917966883054, 0.8706667607121773, 0.8747753844500974, 0.8712004480241841, 0.2791320528135913, 0.27909140051728254, 0.1911862526831858, 0.13815062601740047, 0.23333450121167187, 0.2405183002806447, 0.6337961206658999, 0.5746272598735032, 0.6897260431435153, 0.3730875786577842, 0.6417524870774309, 0.13211899505545877, 0.6500645830469493, 0.6962820217538823, 0.7180159692263058, 0.6043751718452135, 0.7327950775506178, 0.6366286604472307, 0.1324942169302451, 0.6732757983144831, 0.13179730619848085, 0.7110431555927736, 0.13238690620581506, 0.5848320257412571, 0.5073520735209601, 0.4307014717562302, 0.09072150721509153, 0.04172432636729606, 0.27047948964185453, 0.028428734603196393, 0.23420701301605118, 0.07031841134560524, 0.3700982018166826, 0.13387734476806012, 0.2080227888962184, 0.2902850105526533, 0.32542154576412774, 0.5845996803524591, 0.26152944822535595, 0.610434405007612, 0.6033832152408869, 0.5101125086285687, 0.034485008551899954, 0.08023984124751549, 0.12161820637798704, 0.19489448535791176, 0.24104525904494445, 0.21098618295738836, 0.09784638120450129, 0.17395211230213858, 0.2911883234749124, 0.13028441596139306, 0.19130915755294453, 0.17348159082630443, 0.09807844052665038, 0.4305554884280769, 0.14317246827879393, 0.13363362557726455, 0.22080962370739876, 0.08398982053884596, 0.7762764780456178, 0.671698768438392, 0.7719732555941774, 0.7237756778173619, 0.7356057362057925, 0.757019070242464, 0.7646337086769299, 0.7064259495544636, 0.718076057523494, 0.14151808448559444, 0.18090758218923875, 0.12090242318252309, 0.10471127133620661, 0.1570622800246898, 0.14801595501022402, 0.06431198586880205, 0.10121908323922779, 0.14508653563691265, 0.1562362703040553, 0.3812126514345603, 0.17679578908107196, 0.22082173159101826, 0.26149877289625634, 0.2636895229053955, 0.47603561922641, 0.18894656867883342, 0.1890837330369266, 0.3567205821202809, 0.5058993549931575, 0.29634798996595724, 0.5577074289089985, 0.3116428147295257, 0.3400425031025244, 0.24966015485128557, 0.2958663926998971, 0.5103740265167868, 0.23986696780444983, 0.246484619819746, 0.3079542670864406, 0.3375485699425822, 0.3184157236071731, 0.23709242458789026, 0.23390513176627414, 0.26923332614020634, 0.2809083621234971, 0.24802194169810077, 0.2420945298248025, 0.19428903748228932, 0.22810448207992662, 0.23185270508255662, 0.22323536408431577, 0.23877846300022865, 0.23699163073073437, 0.22224697053922815, 0.19112149038145865, 0.2110324029592664, 0.19814132744573665, 0.18567213267394322, 0.22454691083231682, 0.20616286032352982, 0.18975543055884303, 0.21434944748462093, 0.2073368553394267, 0.9018931723263484, 0.17820931203384538, 0.15345948087581418, 0.15851774816452924, 0.2002759780334522, 0.9200080674742466, 0.14214210928780324, 0.17509271132851278, 0.15309861504259703, 0.9230336635570204, 0.2120305511231576, 0.1671992577857898, 0.21077122242591173, 0.1686224042490796, 0.1546551915092872, 0.2116603712084364, 0.2107332150458754, 0.8884871739046369, 0.19960798281485825, 0.19752073390828018, 0.20332250853795486, 0.20771161292298668, 0.2008703208389765, 0.2126380915421271, 0.2185082934300041, 0.20771226243627972, 0.20063246340670515, 0.09572188254788472, 0.10813638928069735, 0.10605261642879726, 0.11079340429611018, 0.0882453949337596, 0.09320334440616151, 0.09545199416061956, 0.1035399222802893, 0.10383563988477729]}, "mutation_prompt": null}
{"id": "624a26c1-c24b-4c8f-bb01-26da4e05129e", "solution": "import numpy as np\n\nclass CooperativeDualSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 50  # Adjusted swarm size for effectiveness\n        self.inertia = 0.5  # Balanced inertia for convergence and exploration\n        self.cognitive = 1.5  # Enhanced cognitive component\n        self.social = 2.0  # Enhanced social component\n        self.global_learning = 0.1  # Add global learning rate\n        self.local_learning = 0.3  # Add local learning rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize swarms\n        swarm1 = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        swarm2 = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities1 = np.zeros((self.swarm_size, self.dim))\n        velocities2 = np.zeros((self.swarm_size, self.dim))\n        personal_best1 = swarm1.copy()\n        personal_best2 = swarm2.copy()\n        personal_best_values1 = np.array([func(ind) for ind in swarm1])\n        personal_best_values2 = np.array([func(ind) for ind in swarm2])\n        global_best_idx1 = np.argmin(personal_best_values1)\n        global_best_idx2 = np.argmin(personal_best_values2)\n        global_best1 = personal_best1[global_best_idx1]\n        global_best2 = personal_best2[global_best_idx2]\n\n        evaluations = 2 * self.swarm_size\n\n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocities with cooperative learning\n                r1, r2, r3, r4 = np.random.rand(), np.random.rand(), np.random.rand(), np.random.rand()\n                velocities1[i] = (self.inertia * velocities1[i] +\n                                  self.cognitive * r1 * (personal_best1[i] - swarm1[i]) +\n                                  self.social * r2 * (global_best2 - swarm1[i]) +\n                                  self.global_learning * r3 * (global_best1 - swarm1[i]))\n                velocities2[i] = (self.inertia * velocities2[i] +\n                                  self.cognitive * r1 * (personal_best2[i] - swarm2[i]) +\n                                  self.social * r4 * (global_best1 - swarm2[i]) +\n                                  self.local_learning * r2 * (global_best2 - swarm2[i]))\n\n                # Update positions\n                swarm1[i] += velocities1[i]\n                swarm2[i] += velocities2[i]\n                swarm1[i] = np.clip(swarm1[i], self.lower_bound, self.upper_bound)\n                swarm2[i] = np.clip(swarm2[i], self.lower_bound, self.upper_bound)\n\n                # Evaluate new positions\n                f_val1 = func(swarm1[i])\n                f_val2 = func(swarm2[i])\n                evaluations += 2\n\n                # Update personal bests\n                if f_val1 < personal_best_values1[i]:\n                    personal_best_values1[i] = f_val1\n                    personal_best1[i] = swarm1[i].copy()\n                    if f_val1 < personal_best_values1[global_best_idx1]:\n                        global_best_idx1 = i\n                        global_best1 = personal_best1[global_best_idx1]\n                \n                if f_val2 < personal_best_values2[i]:\n                    personal_best_values2[i] = f_val2\n                    personal_best2[i] = swarm2[i].copy()\n                    if f_val2 < personal_best_values2[global_best_idx2]:\n                        global_best_idx2 = i\n                        global_best2 = personal_best2[global_best_idx2]\n\n        combined_best = global_best1 if func(global_best1) < func(global_best2) else global_best2\n        return combined_best", "name": "CooperativeDualSwarm", "description": "A novel Cooperative Dual-Swarm Algorithm that dynamically combines social and cognitive components for enhanced convergence.", "configspace": "", "generation": 31, "fitness": 0.36432315067460025, "feedback": "The algorithm CooperativeDualSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.27.", "error": "", "parent_id": "5b8b007a-3cd6-4b59-99cd-af39c8171d4d", "metadata": {"aucs": [0.8130527118163228, 0.8157239193847112, 0.8173225485564629, 0.8234815326349225, 0.8359577044188876, 0.8293578887976127, 0.8360470888579674, 0.8341354195011802, 0.838872870462298, 0.4500765823881864, 0.5211936432725404, 0.5146028295730898, 0.4731209963268369, 0.5017268895509077, 0.5106142036868152, 0.4331985889735166, 0.35645056724803725, 0.5353352200330683, 0.1187352179374811, 0.10699985762529485, 0.08524045107441014, 0.09966517828290522, 0.13740550196151957, 0.09314615632935497, 0.12996997263694443, 0.11645874476551854, 0.11416744439296345, 0.07684598954069921, 0.09630642593238059, 0.07584615476394119, 0.09272808534560206, 0.1430092734277154, 0.0809885088817367, 0.0904315718944998, 0.08721649520756602, 0.10246041469901246, 0.9874638924511321, 0.9772449690580804, 0.9900626211228024, 0.09955688475393909, 0.9872153482504845, 0.9879876805801149, 0.989048455868772, 0.987654445812559, 0.9674928573337394, 0.6438448895613987, 0.6310844874590971, 0.6619106241038335, 0.6185110498331311, 0.6344714730872119, 0.5744555595398015, 0.6064345759037122, 0.6367977816880279, 0.5671324696717353, 0.2245277389774205, 0.22690321670199198, 0.8388753521178239, 0.21712825310548456, 0.8952306023568302, 0.1169294901100939, 0.7902859970276759, 0.17807225120708625, 0.833426925459359, 0.13123027237304374, 0.6312016239369012, 0.5841262039851488, 0.502630940844549, 0.1311142008184697, 0.5466545159857243, 0.5137036299200222, 0.5445939158230579, 0.6349325368089691, 0.5269432222308992, 0.433255869378841, 0.5323450976802035, 0.6175087031766819, 0.603452886523388, 0.13417304957912202, 0.1296494269636147, 0.5947643936069885, 0.6366675177265069, 0.4422746772533016, 0.4608175105890525, 0.4266221231995063, 0.003910456545207497, 9.999999999998899e-05, 0.016224557160746333, 0.39577672732746627, 0.42361027084712277, 0.0032166713708047245, 0.41985247441793094, 0.44700082662998997, 0.4565643759137007, 0.42336418609098336, 0.43732153954957964, 0.15238077420373686, 0.4856153912598089, 0.2872408372843871, 0.296677418090159, 0.31768752258545396, 0.2683964222259394, 0.11901119309390595, 0.3336389006589213, 0.2889568447244455, 0.38863398654559556, 0.22727235489304665, 0.06678413103447822, 0.06925201924979318, 0.3080200636291862, 0.35294857515245537, 0.2861435392692536, 0.3513835259758945, 0.33241318867812975, 0.3535796458425936, 0.29886117212607166, 0.35618880236851225, 0.18259537075099996, 0.6941974787251667, 0.6986904555421459, 0.7061119864715492, 0.7068946665360798, 0.7011389975507332, 0.7131619289501794, 0.7143033445771017, 0.6949489225229433, 0.7404653837828157, 0.06935551081544966, 0.1255558005763665, 0.07387755478407776, 0.10879147477646833, 0.09204275309950294, 0.09714777609172798, 0.10792061633136074, 0.1323388137169209, 0.09921310152975116, 0.18451153367964457, 0.2529858646402603, 0.17225142850729314, 0.24736998656010356, 0.2283803557271762, 0.1997661164264567, 0.16041373207484688, 0.20267994968756653, 0.1882089574940593, 0.47090523709919707, 0.2355129612073551, 0.4603078875950508, 0.4765866005135746, 0.5057259111948222, 0.44734327631470927, 0.3230365344706574, 0.33116523018450583, 0.4227757365290611, 0.21074613369268702, 0.09641126995995142, 0.23840727364967274, 0.31267996545452736, 0.35698301669590204, 0.3081882929243147, 0.2602069063205582, 0.23044976471021883, 0.20299035154490774, 0.2172624985296865, 0.21262609711513447, 0.22677483803369247, 0.22331785464110576, 0.23855404510351708, 0.24970698148878723, 0.1959422517408379, 0.2514259358595997, 0.2243134238109189, 0.17110859415007962, 0.17311715138422967, 0.1932122821172032, 0.20664239879509028, 0.18216006005516006, 0.18354888889738086, 0.19053676245622897, 0.19208423059931745, 0.18491399068879932, 0.1302502761080464, 0.18854864589839648, 0.15406105117528934, 0.8483164214262984, 0.19950082242351797, 0.19983685555581765, 0.12306368882568763, 0.1634150052133837, 0.901802712692413, 0.8745032608106765, 0.16921638030129904, 0.7113336771240869, 0.8427166290891024, 0.12768156758509341, 0.1691168767473522, 0.16863428442278638, 0.10492175375563662, 0.8648719607221566, 0.21210392627636931, 0.19132244468629522, 0.23898391831220045, 0.1818544301895929, 0.1920098804404442, 0.2109240872320809, 0.1791251833885693, 0.178626004418022, 0.18392624118132128, 0.09863286963889528, 0.09221267556817747, 0.09497834447790665, 0.0950699167876311, 0.10661218548189422, 0.10804866910344246, 0.09584611741428395, 0.10592885131643948, 0.09847917599032385]}, "mutation_prompt": null}
{"id": "8a862268-b21e-4323-9796-463fc9c402bb", "solution": "import numpy as np\n\nclass ModifiedHybridEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Increased population size for better diversity\n        self.alpha = 0.5  # Learning rate for adaptive step size\n        self.beta = 0.3  # Secondary learning rate for diversity control\n        self.pm = 0.25  # Mutation probability enhanced for exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations < self.budget // 3:\n                    indices = np.random.choice(self.pop_size, 3, replace=False)\n                    x0, x1, x2 = population[indices]\n                    mutant = x0 + self.alpha * (x1 - x2)\n                elif evaluations < (2 * self.budget) // 3:\n                    mutant = personal_best[i] + self.beta * (global_best - personal_best[i])\n                else:\n                    mutant = global_best + self.alpha * np.random.uniform(-1, 1, self.dim)\n                    \n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])  # Improved crossover strategy\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n                    \n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n            \n            # PSO Update with adaptive learning rate\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.alpha * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n                \n                # Evaluate new position\n                f_val = func(population[i])\n                evaluations += 1\n                \n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n                    \n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n        \n        return global_best", "name": "ModifiedHybridEA", "description": "A Modified Hybrid Evolutionary Algorithm integrating Particle Swarm Optimization with Diversity Control and Adaptive Learning Rate.", "configspace": "", "generation": 32, "fitness": 0.35853279291228335, "feedback": "The algorithm ModifiedHybridEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.27.", "error": "", "parent_id": "5b8b007a-3cd6-4b59-99cd-af39c8171d4d", "metadata": {"aucs": [0.8443985708378615, 0.832288243580656, 0.8322125645976729, 0.8392874528375167, 0.8401682833373828, 0.8462673265881256, 0.8297042338315216, 0.8331837888763876, 0.8329762286952735, 0.5439826589834049, 0.47534068684750985, 0.19582196489132553, 0.4524636888755358, 0.5177982681201272, 0.4448132685781282, 0.5920258736695925, 0.41945584226084875, 0.37286875969245237, 0.0897437324825574, 0.10262252358985902, 0.09256218410169004, 0.13585548022841654, 0.11721970256614389, 0.13469529360518062, 0.151711541696381, 0.15226855732069766, 0.12432859419630293, 0.09154471851302937, 0.12235925388116498, 0.10588850586948595, 0.1077201792711745, 0.06625568446559715, 0.1055894765001516, 0.13628844663833228, 0.11006108325351838, 0.09441294352052099, 0.9766228990521549, 0.9566632817927696, 0.9757899864955298, 0.9665619054599399, 0.9609183468884734, 0.9711020636319956, 0.9778076835465923, 0.9737907947629424, 0.9678207937770973, 0.7188157585392122, 0.696898119887974, 0.7216315923867741, 0.7104548220611897, 0.6935790779576355, 0.6902103710422381, 0.7050105541592928, 0.7180739321754609, 0.695860899573117, 0.38644942168999064, 0.904945882919081, 0.3632058350795604, 0.20711938289558252, 0.8664752852497712, 0.18813951462005074, 0.8480285728335677, 0.2445958347584668, 0.7946887510029993, 0.13205717587938326, 0.5838665856954427, 0.5461675129770658, 0.12952592261777396, 0.6412513706936929, 0.12326292824685825, 0.6757739852489729, 0.5540630404311092, 0.6078903181535449, 0.5113217519908275, 0.5315257786940906, 0.5201196921690621, 0.1308053771548503, 0.6118392097373364, 0.6586870692341811, 0.4526932463618516, 0.12861203022814338, 0.12855534412200964, 0.07678411684903663, 0.06038093830768099, 0.09180867757404654, 0.24950515347751945, 0.03773280947061575, 0.09328713032384695, 0.10932461552930473, 0.08736794333983255, 0.18910841009403956, 0.32341451410794375, 0.15677851220260053, 0.4927733900714575, 0.6233441795902449, 0.27021695762386966, 0.5117680371513591, 0.32194644235608705, 0.5137122377341358, 0.4365140335223483, 0.25395355972508726, 0.2238923004211687, 0.23845513548813246, 0.07049743558245358, 0.18491465717341538, 0.16590567511673904, 0.09210478932032162, 0.18633558920000337, 0.1106586316342687, 0.1472637805540168, 0.08824384368372051, 0.15881268097008028, 0.2169395360541344, 0.17382898518229473, 0.300271867688093, 0.3465066094057824, 0.0553511135238095, 0.08038809803772162, 0.6808032052428415, 0.7116901088042817, 0.6830524788041377, 0.637564120534457, 0.6363405494724619, 0.6573719731262098, 0.6075024943468436, 0.6548400179949342, 0.6293140795415184, 0.14065196024908577, 0.09129769599184234, 0.11482521400490697, 0.1164637587890891, 0.09389066527105572, 0.11471893628719898, 0.10824913267706737, 0.10324214067065873, 0.07881626647824103, 0.3650020840357018, 0.2164404508954353, 0.17115084524802082, 0.21292680003456177, 0.1954202240899484, 0.16877610548802136, 0.2742973165143894, 0.23471525781096747, 0.247401712025062, 0.37719721705178777, 0.4305823034222498, 0.4506431253214902, 0.2447049964723168, 0.4285075887129587, 0.27035931546578496, 0.49291520784907905, 0.26436619472037626, 0.27266803482439683, 0.2160380354761473, 0.3282741329770744, 0.3335885417740989, 0.3457425940110497, 0.22939046825474851, 0.3161032956316421, 0.18627340604591414, 0.2633204371331692, 0.199873051319146, 0.2202461176984759, 0.2253246304144142, 0.22621746057443226, 0.20183017826084793, 0.23833577396420402, 0.2542874755392678, 0.19514061057755605, 0.2769309445152419, 0.24938315595686078, 0.18580715099184986, 0.19261937686459896, 0.22218932225070498, 0.2224467727993329, 0.20909414941328774, 0.1830548584246403, 0.18715542927991713, 0.1870911842061681, 0.20527775197832254, 0.9053093726260789, 0.18795970557007946, 0.16279021272285554, 0.9121781643284693, 0.20058497532229236, 0.14819547575556302, 0.8856265881647654, 0.1614035888341535, 0.17261390638521734, 0.8733433151514679, 0.21238542954060058, 0.8239174384814669, 0.20748447524483737, 0.15466870466073046, 0.16656416426703213, 0.10501150415983196, 0.8429293730456041, 0.11321656914110623, 0.19890796610280304, 0.1998160621127839, 0.19852410329814862, 0.19953459691253317, 0.22230308295955714, 0.18866002292112816, 0.23203733627246925, 0.19274546595711073, 0.21428222199739588, 0.13316433730157806, 0.15064432661188842, 0.10416143270282863, 0.10388043330080676, 0.10477318968390026, 0.08144128751906443, 0.1047818259097878, 0.1071729715883486, 0.11476605913203197]}, "mutation_prompt": null}
{"id": "115a58ce-fa7e-405f-930b-57577ed4a3a9", "solution": "import numpy as np\n\nclass EnhancedAdaptiveEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.w = 0.5  # Adjusted for faster convergence\n        self.cr = 0.9  # Higher crossover probability\n        self.f = 0.5  # Reduced mutation factor for stability\n        self.pm = 0.3  # Further increased mutation probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def levy_flight(self, mu=1.5, scale=0.1):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.abs(v)**(1/mu)\n        return step\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.3, 0.3, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations < self.budget // 2:\n                    indices = np.random.choice(self.pop_size, 2, replace=False)\n                    x1, x2 = population[indices]\n                    mutant = population[i] + self.f * (x1 - x2) + self.levy_flight()\n                else:\n                    mutant = personal_best[i] + self.f * (global_best - personal_best[i])\n                \n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n            \n            self.w = 0.3 + 0.4 * (1 - evaluations / self.budget)\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n                \n                f_val = func(population[i])\n                evaluations += 1\n                \n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n        \n        return global_best", "name": "EnhancedAdaptiveEA", "description": "An Enhanced Adaptive Algorithm that integrates Lévy Flights and Adaptive Parameter Control to improve convergence and exploration.", "configspace": "", "generation": 33, "fitness": 0.34161408981279245, "feedback": "The algorithm EnhancedAdaptiveEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.26.", "error": "", "parent_id": "5b8b007a-3cd6-4b59-99cd-af39c8171d4d", "metadata": {"aucs": [0.8213292010776496, 0.8185293655206061, 0.8171402006907139, 0.8107819043149059, 0.8138738523530149, 0.8130237633879689, 0.8138686233957125, 0.8242547524447341, 0.8124038318849962, 0.36743872572253944, 0.5338816746894067, 0.5039915397841257, 0.4929358705477822, 0.3966710088670261, 0.41046349079906985, 0.4279481789389803, 0.20736942100744427, 0.42028208335352024, 0.13052335051363462, 0.08471853740254809, 0.13773917670814684, 0.11233649956774627, 0.17051042885573586, 0.09690425317904505, 0.12816171199342685, 0.1025420573098691, 0.1385471899522681, 0.0923551323603693, 0.07687895373686204, 0.11069181912115778, 0.07177725411960545, 0.11229536525622663, 0.1081699558645276, 0.1045833004695369, 0.11559037816097695, 0.08722900386503585, 0.9691215387243446, 0.9723247088979511, 0.9718134893402455, 0.9692489532389009, 0.9709911884083163, 0.9723138699582803, 0.9722367684573832, 0.9638235053345307, 0.944653220942, 0.6792209551449249, 0.6849551755410397, 0.6040329175708172, 0.49019268287191153, 0.6657802732033437, 0.6519004185473171, 0.6614185303827724, 0.6498241490783806, 0.6162842844036774, 0.8281317608546969, 0.7851062014783221, 0.22038133011133443, 0.2766923404902848, 0.36495816456181307, 0.27451824564182425, 0.8091647883325148, 0.7793867300858248, 0.23330602510509935, 0.18183946634731207, 0.4114115082455686, 0.15352758899738694, 0.13142868130821095, 0.5997245955352664, 0.12601598810620385, 0.5654044803744787, 0.4323489992493085, 0.306590227082154, 0.38198095382950326, 0.5357279384131854, 0.5171646701526083, 0.3290261190188326, 0.37303472414532035, 0.3328183856940693, 0.5093591868502314, 0.15434717182507351, 0.3145900839712541, 0.206382922342216, 0.011819100604151367, 0.06333820887063557, 0.23518901599165698, 0.06334860109181684, 0.13811991650270106, 0.387740583114775, 0.046474827334832325, 0.005504148178225088, 0.1703677405198314, 0.15891551723426456, 0.20509833508788977, 0.27924619939869966, 0.1696259183882638, 0.21629859246050032, 0.2091999578444541, 0.18974607582413205, 0.43552258224834417, 0.07691750262665376, 0.1036691036664712, 0.11089820609426315, 0.15614837240521406, 0.06590034608771511, 0.08372979708702966, 0.07684209532771125, 0.12702954667335598, 0.11575814812308416, 0.1211692127121472, 0.10007867287624594, 0.25059590784249053, 0.13926670307608036, 0.3395673284179277, 0.3171017202276697, 0.19738988181795103, 0.07851644465177798, 0.08987651296582011, 0.560735340681471, 0.5979443946147515, 0.5573992870065143, 0.6467711920032307, 0.5456637369977498, 0.6256253650095507, 0.6198180950673333, 0.5588729612110874, 0.6242813643242007, 0.08770232264519529, 0.14887573666946008, 0.125253851078154, 0.15689884176161717, 0.6825763009760102, 0.10607776081451081, 0.6426840205397694, 0.11114062403401515, 0.11264790249210477, 0.1843687264532744, 0.22805498883500763, 0.18205722330002794, 0.18890958373407218, 0.21248569673382023, 0.1535817937398255, 0.4198248438031136, 0.2076025768313391, 0.4107480188088731, 0.26360295731468675, 0.3464405125395503, 0.35590047417774406, 0.3051595722562571, 0.3227523103822463, 0.34111462171137186, 0.2632130628755446, 0.45469145486031326, 0.3442259976601252, 0.24013083268371038, 0.24750550401373195, 0.22626515107377898, 0.30328971479545985, 0.21738515191946017, 0.34356082037872826, 0.19616217076698927, 0.25631980996237147, 0.33768741244732037, 0.24129563574516688, 0.19916704823649356, 0.22832686890917997, 0.305294210402576, 0.23316828846634907, 0.21251815524705486, 0.2627204581075926, 0.2694765248797102, 0.20424556446089004, 0.19687533989063888, 0.19403415522299106, 0.19477629522578643, 0.20135556333846516, 0.18579632122769751, 0.19521275128611937, 0.23079816731640512, 0.1948318348031447, 0.19236880451628913, 0.8810340651216727, 0.18741907863880225, 0.15372530426357411, 0.8840619651337146, 0.19992409611552098, 0.19808906683836658, 0.14198984691977634, 0.8696826943269396, 0.15216864860023216, 0.8482095145180779, 0.21056439556132744, 0.8541313945108351, 0.15371784390278476, 0.12716598812677982, 0.15338624873506268, 0.7952692444961446, 0.1544750664152218, 0.8491100846781687, 0.21153103709864274, 0.21391955746144553, 0.2007894529532911, 0.19859206458623702, 0.1986316696321696, 0.21767390004332543, 0.24045914341818087, 0.18244615494167615, 0.19424977404616495, 0.09293211491027253, 0.0921665134611801, 0.10250864446185315, 0.0941397235109318, 0.09561707943781383, 0.14752069692608638, 0.11506036608402026, 0.10104702198495774, 0.10070327964615766]}, "mutation_prompt": null}
{"id": "0d876fb5-4a79-4b01-b16e-d67c37eb33c0", "solution": "import numpy as np\n\nclass AdaptiveHybridEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Modified population size for efficiency\n        self.w = 0.7  # Dynamic inertia weight for better exploration\n        self.cr = 0.85  # Crossover probability adjusted for balance\n        self.f = 0.6  # Tuned mutation factor for controlled diversity\n        self.pm = 0.2  # Increased mutation probability for exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.3, 0.3, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Hybrid DE and PSO Mutation\n                if evaluations < self.budget // 2:\n                    indices = np.random.choice(self.pop_size, 3, replace=False)\n                    x0, x1, x2 = population[indices]\n                    mutant = x0 + self.f * (x1 - x2)\n                else:\n                    mutant = personal_best[i] + self.f * (global_best - personal_best[i])\n                    \n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n                    \n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n            \n            # PSO Update with dynamic inertia weight\n            self.w = 0.4 + 0.3 * (evaluations / self.budget)  # Adaptive inertia\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n                \n                # Evaluate new position\n                f_val = func(population[i])\n                evaluations += 1\n                \n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n                    \n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n        \n        return global_best", "name": "AdaptiveHybridEA", "description": "A novel Adaptive Hybrid Evolutionary Algorithm combining exploratory and exploitative strategies to balance exploration and convergence speed.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5b8b007a-3cd6-4b59-99cd-af39c8171d4d", "metadata": {"aucs": [0.8871826822908224, 0.8711148637881581, 0.8900291041130235, 0.8628368413957237, 0.8738819632321351, 0.8685709209937958, 0.8790834633499045, 0.8815821150451915, 0.8691979250913316, 0.6745682896195839, 0.6497727795444479, 0.6535111661640098, 0.61430553306501, 0.5993027436486895, 0.6904930928099209, 0.08815916252972134, 0.609746502312775, 0.5723425198024741, 0.18057536308494837, 0.14061710775580305, 0.0876930074630965, 0.1307679203985186, 0.10623345200438705, 0.11923907409012358, 0.11013936873072583, 0.10444962213872877, 0.11250150847723506, 0.0885385403196125, 0.08606608605302868, 0.06454608623234603, 0.11272783231638661, 0.11567160374602248, 0.10795369690719725, 0.10438840546659689, 0.11254159325265467, 0.08994284175248157, 0.9714650440728757, 0.9643907801948479, 0.9696635986458755, 0.9712349850032499, 0.9690040821929, 0.9548066838502615, 0.9637411448251363, 0.9765915817241605, 0.9733781222676917, 0.7793985549618262, 0.7549110028449186, 0.7114722368869126, 0.7415753158569725, 0.7677624818906092, 0.7711871443122863, 0.7497121758602364, 0.7790931284561528, 0.7650917966883054, 0.8706667607121773, 0.8747753844500974, 0.8712004480241841, 0.2791320528135913, 0.27909140051728254, 0.1911862526831858, 0.13815062601740047, 0.23333450121167187, 0.2405183002806447, 0.6337961206658999, 0.5746272598735032, 0.6897260431435153, 0.3730875786577842, 0.6417524870774309, 0.13211899505545877, 0.6500645830469493, 0.6962820217538823, 0.7180159692263058, 0.6043751718452135, 0.7327950775506178, 0.6366286604472307, 0.1324942169302451, 0.6732757983144831, 0.13179730619848085, 0.7110431555927736, 0.13238690620581506, 0.5848320257412571, 0.5073520735209601, 0.4307014717562302, 0.09072150721509153, 0.04172432636729606, 0.27047948964185453, 0.028428734603196393, 0.23420701301605118, 0.07031841134560524, 0.3700982018166826, 0.13387734476806012, 0.2080227888962184, 0.2902850105526533, 0.32542154576412774, 0.5845996803524591, 0.26152944822535595, 0.610434405007612, 0.6033832152408869, 0.5101125086285687, 0.034485008551899954, 0.08023984124751549, 0.12161820637798704, 0.19489448535791176, 0.24104525904494445, 0.21098618295738836, 0.09784638120450129, 0.17395211230213858, 0.2911883234749124, 0.13028441596139306, 0.19130915755294453, 0.17348159082630443, 0.09807844052665038, 0.4305554884280769, 0.14317246827879393, 0.13363362557726455, 0.22080962370739876, 0.08398982053884596, 0.7762764780456178, 0.671698768438392, 0.7719732555941774, 0.7237756778173619, 0.7356057362057925, 0.757019070242464, 0.7646337086769299, 0.7064259495544636, 0.718076057523494, 0.14151808448559444, 0.18090758218923875, 0.12090242318252309, 0.10471127133620661, 0.1570622800246898, 0.14801595501022402, 0.06431198586880205, 0.10121908323922779, 0.14508653563691265, 0.1562362703040553, 0.3812126514345603, 0.17679578908107196, 0.22082173159101826, 0.26149877289625634, 0.2636895229053955, 0.47603561922641, 0.18894656867883342, 0.1890837330369266, 0.3567205821202809, 0.5058993549931575, 0.29634798996595724, 0.5577074289089985, 0.3116428147295257, 0.3400425031025244, 0.24966015485128557, 0.2958663926998971, 0.5103740265167868, 0.23986696780444983, 0.246484619819746, 0.3079542670864406, 0.3375485699425822, 0.3184157236071731, 0.23709242458789026, 0.23390513176627414, 0.26923332614020634, 0.2809083621234971, 0.24802194169810077, 0.2420945298248025, 0.19428903748228932, 0.22810448207992662, 0.23185270508255662, 0.22323536408431577, 0.23877846300022865, 0.23699163073073437, 0.22224697053922815, 0.19112149038145865, 0.2110324029592664, 0.19814132744573665, 0.18567213267394322, 0.22454691083231682, 0.20616286032352982, 0.18975543055884303, 0.21434944748462093, 0.2073368553394267, 0.9018931723263484, 0.17820931203384538, 0.15345948087581418, 0.15851774816452924, 0.2002759780334522, 0.9200080674742466, 0.14214210928780324, 0.17509271132851278, 0.15309861504259703, 0.9230336635570204, 0.2120305511231576, 0.1671992577857898, 0.21077122242591173, 0.1686224042490796, 0.1546551915092872, 0.2116603712084364, 0.2107332150458754, 0.8884871739046369, 0.19960798281485825, 0.19752073390828018, 0.20332250853795486, 0.20771161292298668, 0.2008703208389765, 0.2126380915421271, 0.2185082934300041, 0.20771226243627972, 0.20063246340670515, 0.09572188254788472, 0.10813638928069735, 0.10605261642879726, 0.11079340429611018, 0.0882453949337596, 0.09320334440616151, 0.09545199416061956, 0.1035399222802893, 0.10383563988477729]}, "mutation_prompt": null}
{"id": "603d3c36-a77a-4b35-b087-72c881e49ce8", "solution": "import numpy as np\n\nclass AdaptiveHybridEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Modified population size for efficiency\n        self.w = 0.7  # Dynamic inertia weight for better exploration\n        self.cr = 0.85  # Crossover probability adjusted for balance\n        self.f = 0.6  # Tuned mutation factor for controlled diversity\n        self.pm = 0.2  # Increased mutation probability for exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.3, 0.3, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Hybrid DE and PSO Mutation\n                if evaluations < self.budget // 2:\n                    indices = np.random.choice(self.pop_size, 3, replace=False)\n                    x0, x1, x2 = population[indices]\n                    mutant = x0 + self.f * (x1 - x2)\n                else:\n                    mutant = personal_best[i] + self.f * (global_best - personal_best[i])\n                    \n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n                    \n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n            \n            # PSO Update with dynamic inertia weight\n            self.w = 0.4 + 0.3 * (evaluations / self.budget)  # Adaptive inertia\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n                \n                # Evaluate new position\n                f_val = func(population[i])\n                evaluations += 1\n                \n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n                    \n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n        \n        return global_best", "name": "AdaptiveHybridEA", "description": "A novel Adaptive Hybrid Evolutionary Algorithm combining exploratory and exploitative strategies to balance exploration and convergence speed.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5b8b007a-3cd6-4b59-99cd-af39c8171d4d", "metadata": {"aucs": [0.8871826822908224, 0.8711148637881581, 0.8900291041130235, 0.8628368413957237, 0.8738819632321351, 0.8685709209937958, 0.8790834633499045, 0.8815821150451915, 0.8691979250913316, 0.6745682896195839, 0.6497727795444479, 0.6535111661640098, 0.61430553306501, 0.5993027436486895, 0.6904930928099209, 0.08815916252972134, 0.609746502312775, 0.5723425198024741, 0.18057536308494837, 0.14061710775580305, 0.0876930074630965, 0.1307679203985186, 0.10623345200438705, 0.11923907409012358, 0.11013936873072583, 0.10444962213872877, 0.11250150847723506, 0.0885385403196125, 0.08606608605302868, 0.06454608623234603, 0.11272783231638661, 0.11567160374602248, 0.10795369690719725, 0.10438840546659689, 0.11254159325265467, 0.08994284175248157, 0.9714650440728757, 0.9643907801948479, 0.9696635986458755, 0.9712349850032499, 0.9690040821929, 0.9548066838502615, 0.9637411448251363, 0.9765915817241605, 0.9733781222676917, 0.7793985549618262, 0.7549110028449186, 0.7114722368869126, 0.7415753158569725, 0.7677624818906092, 0.7711871443122863, 0.7497121758602364, 0.7790931284561528, 0.7650917966883054, 0.8706667607121773, 0.8747753844500974, 0.8712004480241841, 0.2791320528135913, 0.27909140051728254, 0.1911862526831858, 0.13815062601740047, 0.23333450121167187, 0.2405183002806447, 0.6337961206658999, 0.5746272598735032, 0.6897260431435153, 0.3730875786577842, 0.6417524870774309, 0.13211899505545877, 0.6500645830469493, 0.6962820217538823, 0.7180159692263058, 0.6043751718452135, 0.7327950775506178, 0.6366286604472307, 0.1324942169302451, 0.6732757983144831, 0.13179730619848085, 0.7110431555927736, 0.13238690620581506, 0.5848320257412571, 0.5073520735209601, 0.4307014717562302, 0.09072150721509153, 0.04172432636729606, 0.27047948964185453, 0.028428734603196393, 0.23420701301605118, 0.07031841134560524, 0.3700982018166826, 0.13387734476806012, 0.2080227888962184, 0.2902850105526533, 0.32542154576412774, 0.5845996803524591, 0.26152944822535595, 0.610434405007612, 0.6033832152408869, 0.5101125086285687, 0.034485008551899954, 0.08023984124751549, 0.12161820637798704, 0.19489448535791176, 0.24104525904494445, 0.21098618295738836, 0.09784638120450129, 0.17395211230213858, 0.2911883234749124, 0.13028441596139306, 0.19130915755294453, 0.17348159082630443, 0.09807844052665038, 0.4305554884280769, 0.14317246827879393, 0.13363362557726455, 0.22080962370739876, 0.08398982053884596, 0.7762764780456178, 0.671698768438392, 0.7719732555941774, 0.7237756778173619, 0.7356057362057925, 0.757019070242464, 0.7646337086769299, 0.7064259495544636, 0.718076057523494, 0.14151808448559444, 0.18090758218923875, 0.12090242318252309, 0.10471127133620661, 0.1570622800246898, 0.14801595501022402, 0.06431198586880205, 0.10121908323922779, 0.14508653563691265, 0.1562362703040553, 0.3812126514345603, 0.17679578908107196, 0.22082173159101826, 0.26149877289625634, 0.2636895229053955, 0.47603561922641, 0.18894656867883342, 0.1890837330369266, 0.3567205821202809, 0.5058993549931575, 0.29634798996595724, 0.5577074289089985, 0.3116428147295257, 0.3400425031025244, 0.24966015485128557, 0.2958663926998971, 0.5103740265167868, 0.23986696780444983, 0.246484619819746, 0.3079542670864406, 0.3375485699425822, 0.3184157236071731, 0.23709242458789026, 0.23390513176627414, 0.26923332614020634, 0.2809083621234971, 0.24802194169810077, 0.2420945298248025, 0.19428903748228932, 0.22810448207992662, 0.23185270508255662, 0.22323536408431577, 0.23877846300022865, 0.23699163073073437, 0.22224697053922815, 0.19112149038145865, 0.2110324029592664, 0.19814132744573665, 0.18567213267394322, 0.22454691083231682, 0.20616286032352982, 0.18975543055884303, 0.21434944748462093, 0.2073368553394267, 0.9018931723263484, 0.17820931203384538, 0.15345948087581418, 0.15851774816452924, 0.2002759780334522, 0.9200080674742466, 0.14214210928780324, 0.17509271132851278, 0.15309861504259703, 0.9230336635570204, 0.2120305511231576, 0.1671992577857898, 0.21077122242591173, 0.1686224042490796, 0.1546551915092872, 0.2116603712084364, 0.2107332150458754, 0.8884871739046369, 0.19960798281485825, 0.19752073390828018, 0.20332250853795486, 0.20771161292298668, 0.2008703208389765, 0.2126380915421271, 0.2185082934300041, 0.20771226243627972, 0.20063246340670515, 0.09572188254788472, 0.10813638928069735, 0.10605261642879726, 0.11079340429611018, 0.0882453949337596, 0.09320334440616151, 0.09545199416061956, 0.1035399222802893, 0.10383563988477729]}, "mutation_prompt": null}
{"id": "30ff50bc-53f4-4d24-b371-43d39128240e", "solution": "import numpy as np\n\nclass AdaptiveHybridEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Modified population size for efficiency\n        self.w = 0.7  # Dynamic inertia weight for better exploration\n        self.cr = 0.85  # Crossover probability adjusted for balance\n        self.f = 0.6  # Tuned mutation factor for controlled diversity\n        self.pm = 0.2  # Increased mutation probability for exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.3, 0.3, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Hybrid DE and PSO Mutation\n                if evaluations < self.budget // 2:\n                    indices = np.random.choice(self.pop_size, 3, replace=False)\n                    x0, x1, x2 = population[indices]\n                    mutant = x0 + self.f * (x1 - x2)\n                else:\n                    mutant = personal_best[i] + self.f * (global_best - personal_best[i])\n                    \n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n                    \n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n            \n            # PSO Update with dynamic inertia weight\n            self.w = 0.4 + 0.3 * (evaluations / self.budget)  # Adaptive inertia\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n                \n                # Evaluate new position\n                f_val = func(population[i])\n                evaluations += 1\n                \n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n                    \n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n        \n        return global_best", "name": "AdaptiveHybridEA", "description": "A novel Adaptive Hybrid Evolutionary Algorithm combining exploratory and exploitative strategies to balance exploration and convergence speed.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5b8b007a-3cd6-4b59-99cd-af39c8171d4d", "metadata": {"aucs": [0.8871826822908224, 0.8711148637881581, 0.8900291041130235, 0.8628368413957237, 0.8738819632321351, 0.8685709209937958, 0.8790834633499045, 0.8815821150451915, 0.8691979250913316, 0.6745682896195839, 0.6497727795444479, 0.6535111661640098, 0.61430553306501, 0.5993027436486895, 0.6904930928099209, 0.08815916252972134, 0.609746502312775, 0.5723425198024741, 0.18057536308494837, 0.14061710775580305, 0.0876930074630965, 0.1307679203985186, 0.10623345200438705, 0.11923907409012358, 0.11013936873072583, 0.10444962213872877, 0.11250150847723506, 0.0885385403196125, 0.08606608605302868, 0.06454608623234603, 0.11272783231638661, 0.11567160374602248, 0.10795369690719725, 0.10438840546659689, 0.11254159325265467, 0.08994284175248157, 0.9714650440728757, 0.9643907801948479, 0.9696635986458755, 0.9712349850032499, 0.9690040821929, 0.9548066838502615, 0.9637411448251363, 0.9765915817241605, 0.9733781222676917, 0.7793985549618262, 0.7549110028449186, 0.7114722368869126, 0.7415753158569725, 0.7677624818906092, 0.7711871443122863, 0.7497121758602364, 0.7790931284561528, 0.7650917966883054, 0.8706667607121773, 0.8747753844500974, 0.8712004480241841, 0.2791320528135913, 0.27909140051728254, 0.1911862526831858, 0.13815062601740047, 0.23333450121167187, 0.2405183002806447, 0.6337961206658999, 0.5746272598735032, 0.6897260431435153, 0.3730875786577842, 0.6417524870774309, 0.13211899505545877, 0.6500645830469493, 0.6962820217538823, 0.7180159692263058, 0.6043751718452135, 0.7327950775506178, 0.6366286604472307, 0.1324942169302451, 0.6732757983144831, 0.13179730619848085, 0.7110431555927736, 0.13238690620581506, 0.5848320257412571, 0.5073520735209601, 0.4307014717562302, 0.09072150721509153, 0.04172432636729606, 0.27047948964185453, 0.028428734603196393, 0.23420701301605118, 0.07031841134560524, 0.3700982018166826, 0.13387734476806012, 0.2080227888962184, 0.2902850105526533, 0.32542154576412774, 0.5845996803524591, 0.26152944822535595, 0.610434405007612, 0.6033832152408869, 0.5101125086285687, 0.034485008551899954, 0.08023984124751549, 0.12161820637798704, 0.19489448535791176, 0.24104525904494445, 0.21098618295738836, 0.09784638120450129, 0.17395211230213858, 0.2911883234749124, 0.13028441596139306, 0.19130915755294453, 0.17348159082630443, 0.09807844052665038, 0.4305554884280769, 0.14317246827879393, 0.13363362557726455, 0.22080962370739876, 0.08398982053884596, 0.7762764780456178, 0.671698768438392, 0.7719732555941774, 0.7237756778173619, 0.7356057362057925, 0.757019070242464, 0.7646337086769299, 0.7064259495544636, 0.718076057523494, 0.14151808448559444, 0.18090758218923875, 0.12090242318252309, 0.10471127133620661, 0.1570622800246898, 0.14801595501022402, 0.06431198586880205, 0.10121908323922779, 0.14508653563691265, 0.1562362703040553, 0.3812126514345603, 0.17679578908107196, 0.22082173159101826, 0.26149877289625634, 0.2636895229053955, 0.47603561922641, 0.18894656867883342, 0.1890837330369266, 0.3567205821202809, 0.5058993549931575, 0.29634798996595724, 0.5577074289089985, 0.3116428147295257, 0.3400425031025244, 0.24966015485128557, 0.2958663926998971, 0.5103740265167868, 0.23986696780444983, 0.246484619819746, 0.3079542670864406, 0.3375485699425822, 0.3184157236071731, 0.23709242458789026, 0.23390513176627414, 0.26923332614020634, 0.2809083621234971, 0.24802194169810077, 0.2420945298248025, 0.19428903748228932, 0.22810448207992662, 0.23185270508255662, 0.22323536408431577, 0.23877846300022865, 0.23699163073073437, 0.22224697053922815, 0.19112149038145865, 0.2110324029592664, 0.19814132744573665, 0.18567213267394322, 0.22454691083231682, 0.20616286032352982, 0.18975543055884303, 0.21434944748462093, 0.2073368553394267, 0.9018931723263484, 0.17820931203384538, 0.15345948087581418, 0.15851774816452924, 0.2002759780334522, 0.9200080674742466, 0.14214210928780324, 0.17509271132851278, 0.15309861504259703, 0.9230336635570204, 0.2120305511231576, 0.1671992577857898, 0.21077122242591173, 0.1686224042490796, 0.1546551915092872, 0.2116603712084364, 0.2107332150458754, 0.8884871739046369, 0.19960798281485825, 0.19752073390828018, 0.20332250853795486, 0.20771161292298668, 0.2008703208389765, 0.2126380915421271, 0.2185082934300041, 0.20771226243627972, 0.20063246340670515, 0.09572188254788472, 0.10813638928069735, 0.10605261642879726, 0.11079340429611018, 0.0882453949337596, 0.09320334440616151, 0.09545199416061956, 0.1035399222802893, 0.10383563988477729]}, "mutation_prompt": null}
{"id": "5a45296b-123b-47a9-9ebc-8de22b643ef2", "solution": "import numpy as np\n\nclass SynergisticDualPhaseOA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Increased population size for diversity\n        self.w = 0.5  # More stable inertia weight for phase 1\n        self.cr1 = 0.9  # Higher crossover probability for early phase\n        self.cr2 = 0.7  # Lower crossover probability for later phase\n        self.f1 = 0.4  # Smaller mutation factor initially\n        self.f2 = 0.8  # Larger mutation factor for late exploration\n        self.pm = 0.3  # Enhanced mutation probability for exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            phase_switch = self.budget // 3\n            for i in range(self.pop_size):\n                # Dual-Phase Mutation Strategy\n                if evaluations < phase_switch:\n                    indices = np.random.choice(self.pop_size, 3, replace=False)\n                    x0, x1, x2 = population[indices]\n                    mutant = x0 + self.f1 * (x1 - x2)\n                    trial = np.where(np.random.rand(self.dim) < self.cr1, mutant, population[i])\n                else:\n                    mutant = personal_best[i] + self.f2 * (global_best - personal_best[i])\n                    trial = np.where(np.random.rand(self.dim) < self.cr2, mutant, population[i])\n                    \n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n                    \n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Dynamic Learning Rate PSO Update\n            self.w = 0.6 + 0.3 * (1 - evaluations / self.budget)  # Decreasing inertia\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n                \n                # Evaluate new position\n                f_val = func(population[i])\n                evaluations += 1\n                \n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n                    \n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n        \n        return global_best", "name": "SynergisticDualPhaseOA", "description": "A Synergistic Dual-Phase Optimization Algorithm that leverages adaptive scaling and dynamic learning rates for enhanced convergence.", "configspace": "", "generation": 37, "fitness": 0.2647671659777889, "feedback": "The algorithm SynergisticDualPhaseOA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "5b8b007a-3cd6-4b59-99cd-af39c8171d4d", "metadata": {"aucs": [0.6831580978575782, 0.6483931060797576, 0.6723856818735561, 0.67692919433413, 0.6819216766622979, 0.7049274775412313, 0.6781373529651787, 0.693185905379158, 0.6773012087996084, 0.3371413611382189, 0.30847048746706585, 0.22328582592473756, 0.31962781042831234, 0.3252905126001969, 0.3088555380506367, 0.3108397968238339, 0.28959378293861815, 0.09313555013969088, 0.12421569617150252, 0.09299079865809634, 0.13123070492574462, 0.14296845198049046, 0.10467680284423164, 0.13473504352849142, 0.15439828312059822, 0.14451445608614488, 0.1453185660554669, 0.0967021108808036, 0.11235151013897737, 0.1481922917121361, 0.10698287378422178, 0.10582735994348258, 0.11819758074431064, 0.1348185246657797, 0.11771490151218933, 0.12873899378959863, 0.9765041025127916, 0.9617147351690961, 0.9765955073877526, 0.9672759189296627, 0.9657605576723888, 0.9768226676573744, 0.977871409757851, 0.9739269249927532, 0.9741400041810149, 0.4011534635254649, 0.3980991989202657, 0.414459856336146, 0.36656239485571285, 0.35291589809428325, 0.410777038262215, 0.3695746354926446, 0.3509340603524984, 0.41725314715684314, 0.3410443625904418, 0.3074333318342708, 0.21562612771257195, 0.41849209645959584, 0.6143239132448655, 0.17844688067450765, 0.12209885903454709, 0.2219596179349722, 0.2222379619743814, 0.2387661911148975, 0.26893864912445564, 0.2507264013198486, 0.13011234508964376, 0.2257698674461861, 0.09485410056662968, 0.22091249425817716, 0.22819981850269655, 0.26877325451945255, 0.23663698593358895, 0.12194917393349025, 0.12210452556369178, 0.4466387209229644, 0.2591771514267033, 0.2738390465176739, 0.24560816201068847, 0.11583810162501484, 0.11444323286673153, 0.027339078930992744, 0.07657048884006601, 0.048298767894623285, 0.07314695130517956, 0.0037789828544023685, 0.023065825966507858, 0.032157724136590016, 0.032566059721708895, 0.002457130529618934, 0.10398223878989066, 0.07895934042239772, 0.13379751855551092, 0.028314673717706462, 0.10834503258669215, 0.10965243266840974, 0.1549363528463562, 0.15649780202500552, 0.12707680076031924, 0.08195397756585521, 0.25280545532951826, 0.1065824938963984, 0.08395089024239988, 0.05898534593376903, 0.07284060975195839, 0.0850094460846883, 0.08453851785216926, 0.08101479106175558, 0.11994265333596921, 0.04063192175917263, 0.09479662876571404, 0.19043225720944068, 0.12970899118107082, 0.1939466364536745, 0.0851362209506038, 0.05088011970601669, 0.06810259163967114, 0.4485892606199702, 0.45108204273104446, 0.4612618701752119, 0.4915510925940071, 0.4721642420822615, 0.48743687063549246, 0.45483671511761126, 0.4734543912492505, 0.4929754409547702, 0.07408907727418124, 0.10065797764620565, 0.08815463886090003, 0.12219289006538148, 0.09058637584262563, 0.07880366331072852, 0.10765257650126947, 0.10467500245800743, 0.12646206875287458, 0.21654364047067187, 0.18101623998418415, 0.19791862512995362, 0.20988682286823013, 0.27856391116580737, 0.16504405728351013, 0.19906541272581557, 0.18010979484801248, 0.16755010594100328, 0.2083872382568709, 0.2793403521296065, 0.28929131880832293, 0.2940857842107558, 0.2518259545051005, 0.27738267822467333, 0.25530573409115664, 0.2818598467268203, 0.22226730985859566, 0.20166967769934563, 0.23440417323667262, 0.257274844688008, 0.2466958973931156, 0.1968359371835331, 0.23355470171689396, 0.2437965868960844, 0.18511589679939955, 0.1776526785188024, 0.22758355850348866, 0.2080237809110067, 0.201661021905163, 0.19993192838844676, 0.22849881126148253, 0.2241352209783265, 0.23036903196230607, 0.19160588519985566, 0.20577898181476628, 0.21099344853771385, 0.21014996877496017, 0.16906654516867714, 0.20884730779905059, 0.3855836612428998, 0.19475207770837366, 0.2009676077953899, 0.19146846266870432, 0.18250861989682976, 0.7464177734361643, 0.16601822817729484, 0.18740066610012007, 0.7287436455689276, 0.19917151318250137, 0.15342862664064927, 0.7994803957076999, 0.15622574125755384, 0.1724269115223095, 0.7303120792203528, 0.20774681812402074, 0.507172117593274, 0.6105028452087962, 0.15285545588862093, 0.16467571342776832, 0.20407720336156487, 0.6096605023153586, 0.11295355099451976, 0.20229975675980882, 0.18919786915979242, 0.19260375481092473, 0.1886967254064199, 0.21378152266301587, 0.2057479274216777, 0.17566481440296788, 0.2063454465280098, 0.20992320286551402, 0.09616951800563056, 0.12771373735753988, 0.08062216759913321, 0.08414280480970793, 0.08694489778550851, 0.11158553875276322, 0.08849129555766211, 0.07984086101828303, 0.09301791954300975]}, "mutation_prompt": null}
{"id": "442a617e-72cb-46e0-9928-42c8ab99baf2", "solution": "import numpy as np\n\nclass AdaptiveHybridEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Modified population size for efficiency\n        self.w = 0.7  # Dynamic inertia weight for better exploration\n        self.cr = 0.85  # Crossover probability adjusted for balance\n        self.f = 0.6  # Tuned mutation factor for controlled diversity\n        self.pm = 0.2  # Increased mutation probability for exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.3, 0.3, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Hybrid DE and PSO Mutation\n                if evaluations < self.budget // 2:\n                    indices = np.random.choice(self.pop_size, 3, replace=False)\n                    x0, x1, x2 = population[indices]\n                    mutant = x0 + self.f * (x1 - x2)\n                else:\n                    mutant = personal_best[i] + self.f * (global_best - personal_best[i])\n                    \n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n                    \n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n            \n            # PSO Update with dynamic inertia weight\n            self.w = 0.4 + 0.3 * (evaluations / self.budget)  # Adaptive inertia\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n                \n                # Evaluate new position\n                f_val = func(population[i])\n                evaluations += 1\n                \n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n                    \n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n        \n        return global_best", "name": "AdaptiveHybridEA", "description": "A novel Adaptive Hybrid Evolutionary Algorithm combining exploratory and exploitative strategies to balance exploration and convergence speed.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5b8b007a-3cd6-4b59-99cd-af39c8171d4d", "metadata": {"aucs": [0.8871826822908224, 0.8711148637881581, 0.8900291041130235, 0.8628368413957237, 0.8738819632321351, 0.8685709209937958, 0.8790834633499045, 0.8815821150451915, 0.8691979250913316, 0.6745682896195839, 0.6497727795444479, 0.6535111661640098, 0.61430553306501, 0.5993027436486895, 0.6904930928099209, 0.08815916252972134, 0.609746502312775, 0.5723425198024741, 0.18057536308494837, 0.14061710775580305, 0.0876930074630965, 0.1307679203985186, 0.10623345200438705, 0.11923907409012358, 0.11013936873072583, 0.10444962213872877, 0.11250150847723506, 0.0885385403196125, 0.08606608605302868, 0.06454608623234603, 0.11272783231638661, 0.11567160374602248, 0.10795369690719725, 0.10438840546659689, 0.11254159325265467, 0.08994284175248157, 0.9714650440728757, 0.9643907801948479, 0.9696635986458755, 0.9712349850032499, 0.9690040821929, 0.9548066838502615, 0.9637411448251363, 0.9765915817241605, 0.9733781222676917, 0.7793985549618262, 0.7549110028449186, 0.7114722368869126, 0.7415753158569725, 0.7677624818906092, 0.7711871443122863, 0.7497121758602364, 0.7790931284561528, 0.7650917966883054, 0.8706667607121773, 0.8747753844500974, 0.8712004480241841, 0.2791320528135913, 0.27909140051728254, 0.1911862526831858, 0.13815062601740047, 0.23333450121167187, 0.2405183002806447, 0.6337961206658999, 0.5746272598735032, 0.6897260431435153, 0.3730875786577842, 0.6417524870774309, 0.13211899505545877, 0.6500645830469493, 0.6962820217538823, 0.7180159692263058, 0.6043751718452135, 0.7327950775506178, 0.6366286604472307, 0.1324942169302451, 0.6732757983144831, 0.13179730619848085, 0.7110431555927736, 0.13238690620581506, 0.5848320257412571, 0.5073520735209601, 0.4307014717562302, 0.09072150721509153, 0.04172432636729606, 0.27047948964185453, 0.028428734603196393, 0.23420701301605118, 0.07031841134560524, 0.3700982018166826, 0.13387734476806012, 0.2080227888962184, 0.2902850105526533, 0.32542154576412774, 0.5845996803524591, 0.26152944822535595, 0.610434405007612, 0.6033832152408869, 0.5101125086285687, 0.034485008551899954, 0.08023984124751549, 0.12161820637798704, 0.19489448535791176, 0.24104525904494445, 0.21098618295738836, 0.09784638120450129, 0.17395211230213858, 0.2911883234749124, 0.13028441596139306, 0.19130915755294453, 0.17348159082630443, 0.09807844052665038, 0.4305554884280769, 0.14317246827879393, 0.13363362557726455, 0.22080962370739876, 0.08398982053884596, 0.7762764780456178, 0.671698768438392, 0.7719732555941774, 0.7237756778173619, 0.7356057362057925, 0.757019070242464, 0.7646337086769299, 0.7064259495544636, 0.718076057523494, 0.14151808448559444, 0.18090758218923875, 0.12090242318252309, 0.10471127133620661, 0.1570622800246898, 0.14801595501022402, 0.06431198586880205, 0.10121908323922779, 0.14508653563691265, 0.1562362703040553, 0.3812126514345603, 0.17679578908107196, 0.22082173159101826, 0.26149877289625634, 0.2636895229053955, 0.47603561922641, 0.18894656867883342, 0.1890837330369266, 0.3567205821202809, 0.5058993549931575, 0.29634798996595724, 0.5577074289089985, 0.3116428147295257, 0.3400425031025244, 0.24966015485128557, 0.2958663926998971, 0.5103740265167868, 0.23986696780444983, 0.246484619819746, 0.3079542670864406, 0.3375485699425822, 0.3184157236071731, 0.23709242458789026, 0.23390513176627414, 0.26923332614020634, 0.2809083621234971, 0.24802194169810077, 0.2420945298248025, 0.19428903748228932, 0.22810448207992662, 0.23185270508255662, 0.22323536408431577, 0.23877846300022865, 0.23699163073073437, 0.22224697053922815, 0.19112149038145865, 0.2110324029592664, 0.19814132744573665, 0.18567213267394322, 0.22454691083231682, 0.20616286032352982, 0.18975543055884303, 0.21434944748462093, 0.2073368553394267, 0.9018931723263484, 0.17820931203384538, 0.15345948087581418, 0.15851774816452924, 0.2002759780334522, 0.9200080674742466, 0.14214210928780324, 0.17509271132851278, 0.15309861504259703, 0.9230336635570204, 0.2120305511231576, 0.1671992577857898, 0.21077122242591173, 0.1686224042490796, 0.1546551915092872, 0.2116603712084364, 0.2107332150458754, 0.8884871739046369, 0.19960798281485825, 0.19752073390828018, 0.20332250853795486, 0.20771161292298668, 0.2008703208389765, 0.2126380915421271, 0.2185082934300041, 0.20771226243627972, 0.20063246340670515, 0.09572188254788472, 0.10813638928069735, 0.10605261642879726, 0.11079340429611018, 0.0882453949337596, 0.09320334440616151, 0.09545199416061956, 0.1035399222802893, 0.10383563988477729]}, "mutation_prompt": null}
{"id": "88ef3f49-9a41-4875-bc4a-4ef7b284c46c", "solution": "import numpy as np\n\nclass AdaptiveHybridEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Modified population size for efficiency\n        self.w = 0.7  # Dynamic inertia weight for better exploration\n        self.cr = 0.85  # Crossover probability adjusted for balance\n        self.f = 0.6  # Tuned mutation factor for controlled diversity\n        self.pm = 0.2  # Increased mutation probability for exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.3, 0.3, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Hybrid DE and PSO Mutation\n                if evaluations < self.budget // 2:\n                    indices = np.random.choice(self.pop_size, 3, replace=False)\n                    x0, x1, x2 = population[indices]\n                    mutant = x0 + self.f * (x1 - x2)\n                else:\n                    mutant = personal_best[i] + self.f * (global_best - personal_best[i])\n                    \n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n                    \n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n            \n            # PSO Update with dynamic inertia weight\n            self.w = 0.4 + 0.3 * (evaluations / self.budget)  # Adaptive inertia\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n                \n                # Evaluate new position\n                f_val = func(population[i])\n                evaluations += 1\n                \n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n                    \n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n        \n        return global_best", "name": "AdaptiveHybridEA", "description": "A novel Adaptive Hybrid Evolutionary Algorithm combining exploratory and exploitative strategies to balance exploration and convergence speed.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5b8b007a-3cd6-4b59-99cd-af39c8171d4d", "metadata": {"aucs": [0.8871826822908224, 0.8711148637881581, 0.8900291041130235, 0.8628368413957237, 0.8738819632321351, 0.8685709209937958, 0.8790834633499045, 0.8815821150451915, 0.8691979250913316, 0.6745682896195839, 0.6497727795444479, 0.6535111661640098, 0.61430553306501, 0.5993027436486895, 0.6904930928099209, 0.08815916252972134, 0.609746502312775, 0.5723425198024741, 0.18057536308494837, 0.14061710775580305, 0.0876930074630965, 0.1307679203985186, 0.10623345200438705, 0.11923907409012358, 0.11013936873072583, 0.10444962213872877, 0.11250150847723506, 0.0885385403196125, 0.08606608605302868, 0.06454608623234603, 0.11272783231638661, 0.11567160374602248, 0.10795369690719725, 0.10438840546659689, 0.11254159325265467, 0.08994284175248157, 0.9714650440728757, 0.9643907801948479, 0.9696635986458755, 0.9712349850032499, 0.9690040821929, 0.9548066838502615, 0.9637411448251363, 0.9765915817241605, 0.9733781222676917, 0.7793985549618262, 0.7549110028449186, 0.7114722368869126, 0.7415753158569725, 0.7677624818906092, 0.7711871443122863, 0.7497121758602364, 0.7790931284561528, 0.7650917966883054, 0.8706667607121773, 0.8747753844500974, 0.8712004480241841, 0.2791320528135913, 0.27909140051728254, 0.1911862526831858, 0.13815062601740047, 0.23333450121167187, 0.2405183002806447, 0.6337961206658999, 0.5746272598735032, 0.6897260431435153, 0.3730875786577842, 0.6417524870774309, 0.13211899505545877, 0.6500645830469493, 0.6962820217538823, 0.7180159692263058, 0.6043751718452135, 0.7327950775506178, 0.6366286604472307, 0.1324942169302451, 0.6732757983144831, 0.13179730619848085, 0.7110431555927736, 0.13238690620581506, 0.5848320257412571, 0.5073520735209601, 0.4307014717562302, 0.09072150721509153, 0.04172432636729606, 0.27047948964185453, 0.028428734603196393, 0.23420701301605118, 0.07031841134560524, 0.3700982018166826, 0.13387734476806012, 0.2080227888962184, 0.2902850105526533, 0.32542154576412774, 0.5845996803524591, 0.26152944822535595, 0.610434405007612, 0.6033832152408869, 0.5101125086285687, 0.034485008551899954, 0.08023984124751549, 0.12161820637798704, 0.19489448535791176, 0.24104525904494445, 0.21098618295738836, 0.09784638120450129, 0.17395211230213858, 0.2911883234749124, 0.13028441596139306, 0.19130915755294453, 0.17348159082630443, 0.09807844052665038, 0.4305554884280769, 0.14317246827879393, 0.13363362557726455, 0.22080962370739876, 0.08398982053884596, 0.7762764780456178, 0.671698768438392, 0.7719732555941774, 0.7237756778173619, 0.7356057362057925, 0.757019070242464, 0.7646337086769299, 0.7064259495544636, 0.718076057523494, 0.14151808448559444, 0.18090758218923875, 0.12090242318252309, 0.10471127133620661, 0.1570622800246898, 0.14801595501022402, 0.06431198586880205, 0.10121908323922779, 0.14508653563691265, 0.1562362703040553, 0.3812126514345603, 0.17679578908107196, 0.22082173159101826, 0.26149877289625634, 0.2636895229053955, 0.47603561922641, 0.18894656867883342, 0.1890837330369266, 0.3567205821202809, 0.5058993549931575, 0.29634798996595724, 0.5577074289089985, 0.3116428147295257, 0.3400425031025244, 0.24966015485128557, 0.2958663926998971, 0.5103740265167868, 0.23986696780444983, 0.246484619819746, 0.3079542670864406, 0.3375485699425822, 0.3184157236071731, 0.23709242458789026, 0.23390513176627414, 0.26923332614020634, 0.2809083621234971, 0.24802194169810077, 0.2420945298248025, 0.19428903748228932, 0.22810448207992662, 0.23185270508255662, 0.22323536408431577, 0.23877846300022865, 0.23699163073073437, 0.22224697053922815, 0.19112149038145865, 0.2110324029592664, 0.19814132744573665, 0.18567213267394322, 0.22454691083231682, 0.20616286032352982, 0.18975543055884303, 0.21434944748462093, 0.2073368553394267, 0.9018931723263484, 0.17820931203384538, 0.15345948087581418, 0.15851774816452924, 0.2002759780334522, 0.9200080674742466, 0.14214210928780324, 0.17509271132851278, 0.15309861504259703, 0.9230336635570204, 0.2120305511231576, 0.1671992577857898, 0.21077122242591173, 0.1686224042490796, 0.1546551915092872, 0.2116603712084364, 0.2107332150458754, 0.8884871739046369, 0.19960798281485825, 0.19752073390828018, 0.20332250853795486, 0.20771161292298668, 0.2008703208389765, 0.2126380915421271, 0.2185082934300041, 0.20771226243627972, 0.20063246340670515, 0.09572188254788472, 0.10813638928069735, 0.10605261642879726, 0.11079340429611018, 0.0882453949337596, 0.09320334440616151, 0.09545199416061956, 0.1035399222802893, 0.10383563988477729]}, "mutation_prompt": null}
{"id": "40a7b06d-40eb-4300-8ab9-2df7ab79c4eb", "solution": "import numpy as np\n\nclass AdaptiveHybridEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Modified population size for efficiency\n        self.w = 0.7  # Dynamic inertia weight for better exploration\n        self.cr = 0.85  # Crossover probability adjusted for balance\n        self.f = 0.6  # Tuned mutation factor for controlled diversity\n        self.pm = 0.2  # Increased mutation probability for exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.3, 0.3, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Hybrid DE and PSO Mutation\n                if evaluations < self.budget // 2:\n                    indices = np.random.choice(self.pop_size, 3, replace=False)\n                    x0, x1, x2 = population[indices]\n                    mutant = x0 + self.f * (x1 - x2)\n                else:\n                    mutant = personal_best[i] + self.f * (global_best - personal_best[i])\n                    \n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n                    \n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n            \n            # PSO Update with dynamic inertia weight\n            self.w = 0.4 + 0.3 * (evaluations / self.budget)  # Adaptive inertia\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n                \n                # Evaluate new position\n                f_val = func(population[i])\n                evaluations += 1\n                \n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n                    \n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n        \n        return global_best", "name": "AdaptiveHybridEA", "description": "A novel Adaptive Hybrid Evolutionary Algorithm combining exploratory and exploitative strategies to balance exploration and convergence speed.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5b8b007a-3cd6-4b59-99cd-af39c8171d4d", "metadata": {"aucs": [0.8871826822908224, 0.8711148637881581, 0.8900291041130235, 0.8628368413957237, 0.8738819632321351, 0.8685709209937958, 0.8790834633499045, 0.8815821150451915, 0.8691979250913316, 0.6745682896195839, 0.6497727795444479, 0.6535111661640098, 0.61430553306501, 0.5993027436486895, 0.6904930928099209, 0.08815916252972134, 0.609746502312775, 0.5723425198024741, 0.18057536308494837, 0.14061710775580305, 0.0876930074630965, 0.1307679203985186, 0.10623345200438705, 0.11923907409012358, 0.11013936873072583, 0.10444962213872877, 0.11250150847723506, 0.0885385403196125, 0.08606608605302868, 0.06454608623234603, 0.11272783231638661, 0.11567160374602248, 0.10795369690719725, 0.10438840546659689, 0.11254159325265467, 0.08994284175248157, 0.9714650440728757, 0.9643907801948479, 0.9696635986458755, 0.9712349850032499, 0.9690040821929, 0.9548066838502615, 0.9637411448251363, 0.9765915817241605, 0.9733781222676917, 0.7793985549618262, 0.7549110028449186, 0.7114722368869126, 0.7415753158569725, 0.7677624818906092, 0.7711871443122863, 0.7497121758602364, 0.7790931284561528, 0.7650917966883054, 0.8706667607121773, 0.8747753844500974, 0.8712004480241841, 0.2791320528135913, 0.27909140051728254, 0.1911862526831858, 0.13815062601740047, 0.23333450121167187, 0.2405183002806447, 0.6337961206658999, 0.5746272598735032, 0.6897260431435153, 0.3730875786577842, 0.6417524870774309, 0.13211899505545877, 0.6500645830469493, 0.6962820217538823, 0.7180159692263058, 0.6043751718452135, 0.7327950775506178, 0.6366286604472307, 0.1324942169302451, 0.6732757983144831, 0.13179730619848085, 0.7110431555927736, 0.13238690620581506, 0.5848320257412571, 0.5073520735209601, 0.4307014717562302, 0.09072150721509153, 0.04172432636729606, 0.27047948964185453, 0.028428734603196393, 0.23420701301605118, 0.07031841134560524, 0.3700982018166826, 0.13387734476806012, 0.2080227888962184, 0.2902850105526533, 0.32542154576412774, 0.5845996803524591, 0.26152944822535595, 0.610434405007612, 0.6033832152408869, 0.5101125086285687, 0.034485008551899954, 0.08023984124751549, 0.12161820637798704, 0.19489448535791176, 0.24104525904494445, 0.21098618295738836, 0.09784638120450129, 0.17395211230213858, 0.2911883234749124, 0.13028441596139306, 0.19130915755294453, 0.17348159082630443, 0.09807844052665038, 0.4305554884280769, 0.14317246827879393, 0.13363362557726455, 0.22080962370739876, 0.08398982053884596, 0.7762764780456178, 0.671698768438392, 0.7719732555941774, 0.7237756778173619, 0.7356057362057925, 0.757019070242464, 0.7646337086769299, 0.7064259495544636, 0.718076057523494, 0.14151808448559444, 0.18090758218923875, 0.12090242318252309, 0.10471127133620661, 0.1570622800246898, 0.14801595501022402, 0.06431198586880205, 0.10121908323922779, 0.14508653563691265, 0.1562362703040553, 0.3812126514345603, 0.17679578908107196, 0.22082173159101826, 0.26149877289625634, 0.2636895229053955, 0.47603561922641, 0.18894656867883342, 0.1890837330369266, 0.3567205821202809, 0.5058993549931575, 0.29634798996595724, 0.5577074289089985, 0.3116428147295257, 0.3400425031025244, 0.24966015485128557, 0.2958663926998971, 0.5103740265167868, 0.23986696780444983, 0.246484619819746, 0.3079542670864406, 0.3375485699425822, 0.3184157236071731, 0.23709242458789026, 0.23390513176627414, 0.26923332614020634, 0.2809083621234971, 0.24802194169810077, 0.2420945298248025, 0.19428903748228932, 0.22810448207992662, 0.23185270508255662, 0.22323536408431577, 0.23877846300022865, 0.23699163073073437, 0.22224697053922815, 0.19112149038145865, 0.2110324029592664, 0.19814132744573665, 0.18567213267394322, 0.22454691083231682, 0.20616286032352982, 0.18975543055884303, 0.21434944748462093, 0.2073368553394267, 0.9018931723263484, 0.17820931203384538, 0.15345948087581418, 0.15851774816452924, 0.2002759780334522, 0.9200080674742466, 0.14214210928780324, 0.17509271132851278, 0.15309861504259703, 0.9230336635570204, 0.2120305511231576, 0.1671992577857898, 0.21077122242591173, 0.1686224042490796, 0.1546551915092872, 0.2116603712084364, 0.2107332150458754, 0.8884871739046369, 0.19960798281485825, 0.19752073390828018, 0.20332250853795486, 0.20771161292298668, 0.2008703208389765, 0.2126380915421271, 0.2185082934300041, 0.20771226243627972, 0.20063246340670515, 0.09572188254788472, 0.10813638928069735, 0.10605261642879726, 0.11079340429611018, 0.0882453949337596, 0.09320334440616151, 0.09545199416061956, 0.1035399222802893, 0.10383563988477729]}, "mutation_prompt": null}
{"id": "d66ec981-cec1-461a-b5c5-e528d893c400", "solution": "import numpy as np\n\nclass AdaptiveHybridEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Modified population size for efficiency\n        self.w = 0.7  # Dynamic inertia weight for better exploration\n        self.cr = 0.85  # Crossover probability adjusted for balance\n        self.f = 0.6  # Tuned mutation factor for controlled diversity\n        self.pm = 0.2  # Increased mutation probability for exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.3, 0.3, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Hybrid DE and PSO Mutation\n                if evaluations < self.budget // 2:\n                    indices = np.random.choice(self.pop_size, 3, replace=False)\n                    x0, x1, x2 = population[indices]\n                    mutant = x0 + self.f * (x1 - x2)\n                else:\n                    mutant = personal_best[i] + self.f * (global_best - personal_best[i])\n                    \n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n                    \n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n            \n            # PSO Update with dynamic inertia weight\n            self.w = 0.4 + 0.3 * (evaluations / self.budget)  # Adaptive inertia\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n                \n                # Evaluate new position\n                f_val = func(population[i])\n                evaluations += 1\n                \n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n                    \n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n        \n        return global_best", "name": "AdaptiveHybridEA", "description": "A novel Adaptive Hybrid Evolutionary Algorithm combining exploratory and exploitative strategies to balance exploration and convergence speed.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5b8b007a-3cd6-4b59-99cd-af39c8171d4d", "metadata": {"aucs": [0.8871826822908224, 0.8711148637881581, 0.8900291041130235, 0.8628368413957237, 0.8738819632321351, 0.8685709209937958, 0.8790834633499045, 0.8815821150451915, 0.8691979250913316, 0.6745682896195839, 0.6497727795444479, 0.6535111661640098, 0.61430553306501, 0.5993027436486895, 0.6904930928099209, 0.08815916252972134, 0.609746502312775, 0.5723425198024741, 0.18057536308494837, 0.14061710775580305, 0.0876930074630965, 0.1307679203985186, 0.10623345200438705, 0.11923907409012358, 0.11013936873072583, 0.10444962213872877, 0.11250150847723506, 0.0885385403196125, 0.08606608605302868, 0.06454608623234603, 0.11272783231638661, 0.11567160374602248, 0.10795369690719725, 0.10438840546659689, 0.11254159325265467, 0.08994284175248157, 0.9714650440728757, 0.9643907801948479, 0.9696635986458755, 0.9712349850032499, 0.9690040821929, 0.9548066838502615, 0.9637411448251363, 0.9765915817241605, 0.9733781222676917, 0.7793985549618262, 0.7549110028449186, 0.7114722368869126, 0.7415753158569725, 0.7677624818906092, 0.7711871443122863, 0.7497121758602364, 0.7790931284561528, 0.7650917966883054, 0.8706667607121773, 0.8747753844500974, 0.8712004480241841, 0.2791320528135913, 0.27909140051728254, 0.1911862526831858, 0.13815062601740047, 0.23333450121167187, 0.2405183002806447, 0.6337961206658999, 0.5746272598735032, 0.6897260431435153, 0.3730875786577842, 0.6417524870774309, 0.13211899505545877, 0.6500645830469493, 0.6962820217538823, 0.7180159692263058, 0.6043751718452135, 0.7327950775506178, 0.6366286604472307, 0.1324942169302451, 0.6732757983144831, 0.13179730619848085, 0.7110431555927736, 0.13238690620581506, 0.5848320257412571, 0.5073520735209601, 0.4307014717562302, 0.09072150721509153, 0.04172432636729606, 0.27047948964185453, 0.028428734603196393, 0.23420701301605118, 0.07031841134560524, 0.3700982018166826, 0.13387734476806012, 0.2080227888962184, 0.2902850105526533, 0.32542154576412774, 0.5845996803524591, 0.26152944822535595, 0.610434405007612, 0.6033832152408869, 0.5101125086285687, 0.034485008551899954, 0.08023984124751549, 0.12161820637798704, 0.19489448535791176, 0.24104525904494445, 0.21098618295738836, 0.09784638120450129, 0.17395211230213858, 0.2911883234749124, 0.13028441596139306, 0.19130915755294453, 0.17348159082630443, 0.09807844052665038, 0.4305554884280769, 0.14317246827879393, 0.13363362557726455, 0.22080962370739876, 0.08398982053884596, 0.7762764780456178, 0.671698768438392, 0.7719732555941774, 0.7237756778173619, 0.7356057362057925, 0.757019070242464, 0.7646337086769299, 0.7064259495544636, 0.718076057523494, 0.14151808448559444, 0.18090758218923875, 0.12090242318252309, 0.10471127133620661, 0.1570622800246898, 0.14801595501022402, 0.06431198586880205, 0.10121908323922779, 0.14508653563691265, 0.1562362703040553, 0.3812126514345603, 0.17679578908107196, 0.22082173159101826, 0.26149877289625634, 0.2636895229053955, 0.47603561922641, 0.18894656867883342, 0.1890837330369266, 0.3567205821202809, 0.5058993549931575, 0.29634798996595724, 0.5577074289089985, 0.3116428147295257, 0.3400425031025244, 0.24966015485128557, 0.2958663926998971, 0.5103740265167868, 0.23986696780444983, 0.246484619819746, 0.3079542670864406, 0.3375485699425822, 0.3184157236071731, 0.23709242458789026, 0.23390513176627414, 0.26923332614020634, 0.2809083621234971, 0.24802194169810077, 0.2420945298248025, 0.19428903748228932, 0.22810448207992662, 0.23185270508255662, 0.22323536408431577, 0.23877846300022865, 0.23699163073073437, 0.22224697053922815, 0.19112149038145865, 0.2110324029592664, 0.19814132744573665, 0.18567213267394322, 0.22454691083231682, 0.20616286032352982, 0.18975543055884303, 0.21434944748462093, 0.2073368553394267, 0.9018931723263484, 0.17820931203384538, 0.15345948087581418, 0.15851774816452924, 0.2002759780334522, 0.9200080674742466, 0.14214210928780324, 0.17509271132851278, 0.15309861504259703, 0.9230336635570204, 0.2120305511231576, 0.1671992577857898, 0.21077122242591173, 0.1686224042490796, 0.1546551915092872, 0.2116603712084364, 0.2107332150458754, 0.8884871739046369, 0.19960798281485825, 0.19752073390828018, 0.20332250853795486, 0.20771161292298668, 0.2008703208389765, 0.2126380915421271, 0.2185082934300041, 0.20771226243627972, 0.20063246340670515, 0.09572188254788472, 0.10813638928069735, 0.10605261642879726, 0.11079340429611018, 0.0882453949337596, 0.09320334440616151, 0.09545199416061956, 0.1035399222802893, 0.10383563988477729]}, "mutation_prompt": null}
{"id": "6bf25984-34d4-4aaa-bf54-c71a94c74b6f", "solution": "import numpy as np\n\nclass DynamicSwarmEnsemble:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Adjusted population size for better sampling\n        self.w = 0.5  # Adaptive inertia weight for improved balance\n        self.cr = 0.9  # Higher crossover rate for diversity\n        self.f = 0.5  # Reduced mutation factor for stability\n        self.pm = 0.1  # Tuned mutation probability for refinement\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Multi-strategy DE Mutation\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                mutant = x0 + self.f * (x1 - x2) + self.f * (x3 - personal_best[i])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n                    \n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Adaptive PSO Update\n            self.w = 0.3 + 0.2 * (1 - evaluations / self.budget)  # Dynamic inertia\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n                \n                # Evaluate new position\n                f_val = func(population[i])\n                evaluations += 1\n                \n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n                    \n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n        \n        return global_best", "name": "DynamicSwarmEnsemble", "description": "A novel Dynamic Swarm Ensemble Algorithm integrating adaptive parameters and multi-strategy reinforcement to enhance convergence and robustness.", "configspace": "", "generation": 42, "fitness": 0.37880749901241045, "feedback": "The algorithm DynamicSwarmEnsemble got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.27.", "error": "", "parent_id": "5b8b007a-3cd6-4b59-99cd-af39c8171d4d", "metadata": {"aucs": [0.8610176580685336, 0.8429510547117746, 0.8441707373173608, 0.8383338639476395, 0.8415997716485245, 0.8562669295605425, 0.8475727681498716, 0.8477582442739064, 0.8401723238596119, 0.6011242634660201, 0.4984478381513553, 0.5634069422702649, 0.558043876576676, 0.5223926466928138, 0.5699198092526212, 0.5419651469397592, 0.5763395174716845, 0.043827753782448076, 0.12215239420548585, 0.07870657081763621, 0.1154338898157099, 0.13458847498434845, 0.13822435451965798, 0.12054469469075979, 0.15803714468615493, 0.1550099933507596, 0.13627895850911131, 0.10897468883058914, 0.1328699072852858, 0.09351269486502789, 0.07970546750117269, 0.08195894596046416, 0.17510411284844596, 0.0911741622888701, 0.13742926990139637, 0.10133592159061977, 0.9669270306112738, 0.9667072261531513, 0.9731951111826657, 0.9649016961962305, 0.9640356150675982, 0.9761034085024857, 0.9881531363008376, 0.9733950188080025, 0.9685627790523466, 0.6925386496625596, 0.7141526271204485, 0.7042564446697748, 0.7120781780698422, 0.7024905182100982, 0.6967606659516146, 0.6657533325173182, 0.688617574065995, 0.6893138864787259, 0.8476439556228765, 0.8925855919599447, 0.16946710833919065, 0.2783919924985716, 0.27768915651927684, 0.2680843470434916, 0.7885992173269092, 0.23081134742437504, 0.23026112878581373, 0.3462133813488927, 0.6174390227949587, 0.6988228685192329, 0.4424670231293131, 0.11786299709528414, 0.6520739369557373, 0.5744951761611164, 0.5574451528586133, 0.5988133473443354, 0.6781850128926137, 0.5278633784754105, 0.6421040435752594, 0.133977220574505, 0.13408026536174766, 0.134596304485876, 0.6634340632748498, 0.6626650052419584, 0.1285520624753702, 0.28942067692449913, 0.3162794021524712, 0.0663357194332379, 0.3077861052445795, 0.135254764812903, 0.1293506692379357, 0.3982133324029222, 0.44938813736611205, 0.19525179100794, 0.6180344334973382, 0.246496085413902, 0.6046964225412682, 0.6258058456158191, 0.6214483414573808, 0.3772490505741253, 0.43360715694533136, 0.6218983020818056, 0.6224838213824047, 0.13080017107845432, 0.10717752877302922, 0.20445303826543204, 0.13472361245926856, 0.29349404236313315, 0.2630701533999885, 0.087594700122675, 0.13797963957732629, 0.26178694866724395, 0.17439261807551343, 0.2979687345797343, 0.16678683377723225, 0.4465676308451306, 0.1810650120392061, 0.2596556017672307, 0.2772660478560257, 0.08062603182268613, 0.07826255197108989, 0.7189371009749476, 0.7316718241167037, 0.708082658466398, 0.741791223133677, 0.7233647336003373, 0.7532703673177674, 0.7132727579353295, 0.7238402277801717, 0.74143395286195, 0.11317775719064738, 0.07362489142949835, 0.09718908757163902, 0.11691873474537262, 0.08491997217369296, 0.11495113453693462, 0.1270523945863018, 0.12209841217891315, 0.15663166250767357, 0.2417963283213067, 0.17441047313641578, 0.16796813437687597, 0.2070913028869148, 0.36628293204434015, 0.17138916895243694, 0.39151634698325, 0.16560855559981702, 0.20207964597507788, 0.2755890115265477, 0.4297826646894508, 0.4362416760153178, 0.5521491998385618, 0.39060847798222165, 0.4190847775010249, 0.27293954202576265, 0.4006416313469845, 0.4125861122295712, 0.23324359329959032, 0.2539800109501379, 0.2745202406182683, 0.2933029936424171, 0.26536404868584895, 0.3143127252948621, 0.24061282430942532, 0.2856510683817389, 0.2930011090612348, 0.25986835180921997, 0.23373898889529943, 0.20633675015236708, 0.2719340643662903, 0.21883943256824845, 0.24811071822895925, 0.2567027068188342, 0.22243491895026268, 0.24985760813862212, 0.22628088035851746, 0.1834734132595378, 0.21617167695317352, 0.20485266400691238, 0.211739358720326, 0.1949440222256782, 0.18044557815824558, 0.18176459272553014, 0.19687885252840875, 0.1872378393280727, 0.1880636939411262, 0.18827245097521927, 0.18808428592319992, 0.2006991852164579, 0.8538203610011507, 0.14180203676297154, 0.17256583434232198, 0.16704992114686323, 0.8726340759870046, 0.20710895004204444, 0.91562240633362, 0.2117372647559701, 0.2086465447720819, 0.7482483369309854, 0.8344721416245962, 0.8069365032188163, 0.15401298143248754, 0.19198266069418035, 0.20677138876835477, 0.20287808132871554, 0.20158809752847806, 0.2087799082670786, 0.21187403317828202, 0.20620630754666058, 0.2005255237368624, 0.2234554822116397, 0.10575261740075148, 0.10064839928586133, 0.09937389122202989, 0.09203845817317191, 0.08949779109126232, 0.09708179332934541, 0.0888513506480012, 0.10542314904396355, 0.08272721681146955]}, "mutation_prompt": null}
{"id": "2b13c4e3-23d8-4186-a634-f91b1139f1d2", "solution": "import numpy as np\n\nclass DynamicSwarmEnsemble:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Adjusted population size for better sampling\n        self.w = 0.5  # Adaptive inertia weight for improved balance\n        self.cr = 0.9  # Higher crossover rate for diversity\n        self.f = 0.5  # Reduced mutation factor for stability\n        self.pm = 0.1  # Tuned mutation probability for refinement\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Multi-strategy DE Mutation\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                mutant = x0 + self.f * (x1 - x2) + self.f * (x3 - personal_best[i])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n                    \n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Adaptive PSO Update\n            self.w = 0.3 + 0.2 * (1 - evaluations / self.budget)  # Dynamic inertia\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n                \n                # Evaluate new position\n                f_val = func(population[i])\n                evaluations += 1\n                \n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n                    \n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n        \n        return global_best", "name": "DynamicSwarmEnsemble", "description": "A novel Dynamic Swarm Ensemble Algorithm integrating adaptive parameters and multi-strategy reinforcement to enhance convergence and robustness.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6bf25984-34d4-4aaa-bf54-c71a94c74b6f", "metadata": {"aucs": [0.8610176580685336, 0.8429510547117746, 0.8441707373173608, 0.8383338639476395, 0.8415997716485245, 0.8562669295605425, 0.8475727681498716, 0.8477582442739064, 0.8401723238596119, 0.6011242634660201, 0.4984478381513553, 0.5634069422702649, 0.558043876576676, 0.5223926466928138, 0.5699198092526212, 0.5419651469397592, 0.5763395174716845, 0.043827753782448076, 0.12215239420548585, 0.07870657081763621, 0.1154338898157099, 0.13458847498434845, 0.13822435451965798, 0.12054469469075979, 0.15803714468615493, 0.1550099933507596, 0.13627895850911131, 0.10897468883058914, 0.1328699072852858, 0.09351269486502789, 0.07970546750117269, 0.08195894596046416, 0.17510411284844596, 0.0911741622888701, 0.13742926990139637, 0.10133592159061977, 0.9669270306112738, 0.9667072261531513, 0.9731951111826657, 0.9649016961962305, 0.9640356150675982, 0.9761034085024857, 0.9881531363008376, 0.9733950188080025, 0.9685627790523466, 0.6925386496625596, 0.7141526271204485, 0.7042564446697748, 0.7120781780698422, 0.7024905182100982, 0.6967606659516146, 0.6657533325173182, 0.688617574065995, 0.6893138864787259, 0.8476439556228765, 0.8925855919599447, 0.16946710833919065, 0.2783919924985716, 0.27768915651927684, 0.2680843470434916, 0.7885992173269092, 0.23081134742437504, 0.23026112878581373, 0.3462133813488927, 0.6174390227949587, 0.6988228685192329, 0.4424670231293131, 0.11786299709528414, 0.6520739369557373, 0.5744951761611164, 0.5574451528586133, 0.5988133473443354, 0.6781850128926137, 0.5278633784754105, 0.6421040435752594, 0.133977220574505, 0.13408026536174766, 0.134596304485876, 0.6634340632748498, 0.6626650052419584, 0.1285520624753702, 0.28942067692449913, 0.3162794021524712, 0.0663357194332379, 0.3077861052445795, 0.135254764812903, 0.1293506692379357, 0.3982133324029222, 0.44938813736611205, 0.19525179100794, 0.6180344334973382, 0.246496085413902, 0.6046964225412682, 0.6258058456158191, 0.6214483414573808, 0.3772490505741253, 0.43360715694533136, 0.6218983020818056, 0.6224838213824047, 0.13080017107845432, 0.10717752877302922, 0.20445303826543204, 0.13472361245926856, 0.29349404236313315, 0.2630701533999885, 0.087594700122675, 0.13797963957732629, 0.26178694866724395, 0.17439261807551343, 0.2979687345797343, 0.16678683377723225, 0.4465676308451306, 0.1810650120392061, 0.2596556017672307, 0.2772660478560257, 0.08062603182268613, 0.07826255197108989, 0.7189371009749476, 0.7316718241167037, 0.708082658466398, 0.741791223133677, 0.7233647336003373, 0.7532703673177674, 0.7132727579353295, 0.7238402277801717, 0.74143395286195, 0.11317775719064738, 0.07362489142949835, 0.09718908757163902, 0.11691873474537262, 0.08491997217369296, 0.11495113453693462, 0.1270523945863018, 0.12209841217891315, 0.15663166250767357, 0.2417963283213067, 0.17441047313641578, 0.16796813437687597, 0.2070913028869148, 0.36628293204434015, 0.17138916895243694, 0.39151634698325, 0.16560855559981702, 0.20207964597507788, 0.2755890115265477, 0.4297826646894508, 0.4362416760153178, 0.5521491998385618, 0.39060847798222165, 0.4190847775010249, 0.27293954202576265, 0.4006416313469845, 0.4125861122295712, 0.23324359329959032, 0.2539800109501379, 0.2745202406182683, 0.2933029936424171, 0.26536404868584895, 0.3143127252948621, 0.24061282430942532, 0.2856510683817389, 0.2930011090612348, 0.25986835180921997, 0.23373898889529943, 0.20633675015236708, 0.2719340643662903, 0.21883943256824845, 0.24811071822895925, 0.2567027068188342, 0.22243491895026268, 0.24985760813862212, 0.22628088035851746, 0.1834734132595378, 0.21617167695317352, 0.20485266400691238, 0.211739358720326, 0.1949440222256782, 0.18044557815824558, 0.18176459272553014, 0.19687885252840875, 0.1872378393280727, 0.1880636939411262, 0.18827245097521927, 0.18808428592319992, 0.2006991852164579, 0.8538203610011507, 0.14180203676297154, 0.17256583434232198, 0.16704992114686323, 0.8726340759870046, 0.20710895004204444, 0.91562240633362, 0.2117372647559701, 0.2086465447720819, 0.7482483369309854, 0.8344721416245962, 0.8069365032188163, 0.15401298143248754, 0.19198266069418035, 0.20677138876835477, 0.20287808132871554, 0.20158809752847806, 0.2087799082670786, 0.21187403317828202, 0.20620630754666058, 0.2005255237368624, 0.2234554822116397, 0.10575261740075148, 0.10064839928586133, 0.09937389122202989, 0.09203845817317191, 0.08949779109126232, 0.09708179332934541, 0.0888513506480012, 0.10542314904396355, 0.08272721681146955]}, "mutation_prompt": null}
{"id": "78930fba-f344-42b3-b0bf-20ba5a4022a8", "solution": "import numpy as np\n\nclass DynamicSwarmEnsemble:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Adjusted population size for better sampling\n        self.w = 0.5  # Adaptive inertia weight for improved balance\n        self.cr = 0.9  # Higher crossover rate for diversity\n        self.f = 0.5  # Reduced mutation factor for stability\n        self.pm = 0.1  # Tuned mutation probability for refinement\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Multi-strategy DE Mutation\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                mutant = x0 + self.f * (x1 - x2) + self.f * (x3 - personal_best[i])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n                    \n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Adaptive PSO Update\n            self.w = 0.3 + 0.2 * (1 - evaluations / self.budget)  # Dynamic inertia\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n                \n                # Evaluate new position\n                f_val = func(population[i])\n                evaluations += 1\n                \n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n                    \n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n        \n        return global_best", "name": "DynamicSwarmEnsemble", "description": "A novel Dynamic Swarm Ensemble Algorithm integrating adaptive parameters and multi-strategy reinforcement to enhance convergence and robustness.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6bf25984-34d4-4aaa-bf54-c71a94c74b6f", "metadata": {"aucs": [0.8610176580685336, 0.8429510547117746, 0.8441707373173608, 0.8383338639476395, 0.8415997716485245, 0.8562669295605425, 0.8475727681498716, 0.8477582442739064, 0.8401723238596119, 0.6011242634660201, 0.4984478381513553, 0.5634069422702649, 0.558043876576676, 0.5223926466928138, 0.5699198092526212, 0.5419651469397592, 0.5763395174716845, 0.043827753782448076, 0.12215239420548585, 0.07870657081763621, 0.1154338898157099, 0.13458847498434845, 0.13822435451965798, 0.12054469469075979, 0.15803714468615493, 0.1550099933507596, 0.13627895850911131, 0.10897468883058914, 0.1328699072852858, 0.09351269486502789, 0.07970546750117269, 0.08195894596046416, 0.17510411284844596, 0.0911741622888701, 0.13742926990139637, 0.10133592159061977, 0.9669270306112738, 0.9667072261531513, 0.9731951111826657, 0.9649016961962305, 0.9640356150675982, 0.9761034085024857, 0.9881531363008376, 0.9733950188080025, 0.9685627790523466, 0.6925386496625596, 0.7141526271204485, 0.7042564446697748, 0.7120781780698422, 0.7024905182100982, 0.6967606659516146, 0.6657533325173182, 0.688617574065995, 0.6893138864787259, 0.8476439556228765, 0.8925855919599447, 0.16946710833919065, 0.2783919924985716, 0.27768915651927684, 0.2680843470434916, 0.7885992173269092, 0.23081134742437504, 0.23026112878581373, 0.3462133813488927, 0.6174390227949587, 0.6988228685192329, 0.4424670231293131, 0.11786299709528414, 0.6520739369557373, 0.5744951761611164, 0.5574451528586133, 0.5988133473443354, 0.6781850128926137, 0.5278633784754105, 0.6421040435752594, 0.133977220574505, 0.13408026536174766, 0.134596304485876, 0.6634340632748498, 0.6626650052419584, 0.1285520624753702, 0.28942067692449913, 0.3162794021524712, 0.0663357194332379, 0.3077861052445795, 0.135254764812903, 0.1293506692379357, 0.3982133324029222, 0.44938813736611205, 0.19525179100794, 0.6180344334973382, 0.246496085413902, 0.6046964225412682, 0.6258058456158191, 0.6214483414573808, 0.3772490505741253, 0.43360715694533136, 0.6218983020818056, 0.6224838213824047, 0.13080017107845432, 0.10717752877302922, 0.20445303826543204, 0.13472361245926856, 0.29349404236313315, 0.2630701533999885, 0.087594700122675, 0.13797963957732629, 0.26178694866724395, 0.17439261807551343, 0.2979687345797343, 0.16678683377723225, 0.4465676308451306, 0.1810650120392061, 0.2596556017672307, 0.2772660478560257, 0.08062603182268613, 0.07826255197108989, 0.7189371009749476, 0.7316718241167037, 0.708082658466398, 0.741791223133677, 0.7233647336003373, 0.7532703673177674, 0.7132727579353295, 0.7238402277801717, 0.74143395286195, 0.11317775719064738, 0.07362489142949835, 0.09718908757163902, 0.11691873474537262, 0.08491997217369296, 0.11495113453693462, 0.1270523945863018, 0.12209841217891315, 0.15663166250767357, 0.2417963283213067, 0.17441047313641578, 0.16796813437687597, 0.2070913028869148, 0.36628293204434015, 0.17138916895243694, 0.39151634698325, 0.16560855559981702, 0.20207964597507788, 0.2755890115265477, 0.4297826646894508, 0.4362416760153178, 0.5521491998385618, 0.39060847798222165, 0.4190847775010249, 0.27293954202576265, 0.4006416313469845, 0.4125861122295712, 0.23324359329959032, 0.2539800109501379, 0.2745202406182683, 0.2933029936424171, 0.26536404868584895, 0.3143127252948621, 0.24061282430942532, 0.2856510683817389, 0.2930011090612348, 0.25986835180921997, 0.23373898889529943, 0.20633675015236708, 0.2719340643662903, 0.21883943256824845, 0.24811071822895925, 0.2567027068188342, 0.22243491895026268, 0.24985760813862212, 0.22628088035851746, 0.1834734132595378, 0.21617167695317352, 0.20485266400691238, 0.211739358720326, 0.1949440222256782, 0.18044557815824558, 0.18176459272553014, 0.19687885252840875, 0.1872378393280727, 0.1880636939411262, 0.18827245097521927, 0.18808428592319992, 0.2006991852164579, 0.8538203610011507, 0.14180203676297154, 0.17256583434232198, 0.16704992114686323, 0.8726340759870046, 0.20710895004204444, 0.91562240633362, 0.2117372647559701, 0.2086465447720819, 0.7482483369309854, 0.8344721416245962, 0.8069365032188163, 0.15401298143248754, 0.19198266069418035, 0.20677138876835477, 0.20287808132871554, 0.20158809752847806, 0.2087799082670786, 0.21187403317828202, 0.20620630754666058, 0.2005255237368624, 0.2234554822116397, 0.10575261740075148, 0.10064839928586133, 0.09937389122202989, 0.09203845817317191, 0.08949779109126232, 0.09708179332934541, 0.0888513506480012, 0.10542314904396355, 0.08272721681146955]}, "mutation_prompt": null}
{"id": "1112e2bf-5e6b-475d-a7e0-397b36c74c30", "solution": "import numpy as np\n\nclass DynamicSwarmEnsemble:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Adjusted population size for better sampling\n        self.w = 0.5  # Adaptive inertia weight for improved balance\n        self.cr = 0.9  # Higher crossover rate for diversity\n        self.f = 0.5  # Reduced mutation factor for stability\n        self.pm = 0.1  # Tuned mutation probability for refinement\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Multi-strategy DE Mutation\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                mutant = x0 + self.f * (x1 - x2) + self.f * (x3 - personal_best[i])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n                    \n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Adaptive PSO Update\n            self.w = 0.3 + 0.2 * (1 - evaluations / self.budget)  # Dynamic inertia\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n                \n                # Evaluate new position\n                f_val = func(population[i])\n                evaluations += 1\n                \n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n                    \n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n        \n        return global_best", "name": "DynamicSwarmEnsemble", "description": "A novel Dynamic Swarm Ensemble Algorithm integrating adaptive parameters and multi-strategy reinforcement to enhance convergence and robustness.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6bf25984-34d4-4aaa-bf54-c71a94c74b6f", "metadata": {"aucs": [0.8610176580685336, 0.8429510547117746, 0.8441707373173608, 0.8383338639476395, 0.8415997716485245, 0.8562669295605425, 0.8475727681498716, 0.8477582442739064, 0.8401723238596119, 0.6011242634660201, 0.4984478381513553, 0.5634069422702649, 0.558043876576676, 0.5223926466928138, 0.5699198092526212, 0.5419651469397592, 0.5763395174716845, 0.043827753782448076, 0.12215239420548585, 0.07870657081763621, 0.1154338898157099, 0.13458847498434845, 0.13822435451965798, 0.12054469469075979, 0.15803714468615493, 0.1550099933507596, 0.13627895850911131, 0.10897468883058914, 0.1328699072852858, 0.09351269486502789, 0.07970546750117269, 0.08195894596046416, 0.17510411284844596, 0.0911741622888701, 0.13742926990139637, 0.10133592159061977, 0.9669270306112738, 0.9667072261531513, 0.9731951111826657, 0.9649016961962305, 0.9640356150675982, 0.9761034085024857, 0.9881531363008376, 0.9733950188080025, 0.9685627790523466, 0.6925386496625596, 0.7141526271204485, 0.7042564446697748, 0.7120781780698422, 0.7024905182100982, 0.6967606659516146, 0.6657533325173182, 0.688617574065995, 0.6893138864787259, 0.8476439556228765, 0.8925855919599447, 0.16946710833919065, 0.2783919924985716, 0.27768915651927684, 0.2680843470434916, 0.7885992173269092, 0.23081134742437504, 0.23026112878581373, 0.3462133813488927, 0.6174390227949587, 0.6988228685192329, 0.4424670231293131, 0.11786299709528414, 0.6520739369557373, 0.5744951761611164, 0.5574451528586133, 0.5988133473443354, 0.6781850128926137, 0.5278633784754105, 0.6421040435752594, 0.133977220574505, 0.13408026536174766, 0.134596304485876, 0.6634340632748498, 0.6626650052419584, 0.1285520624753702, 0.28942067692449913, 0.3162794021524712, 0.0663357194332379, 0.3077861052445795, 0.135254764812903, 0.1293506692379357, 0.3982133324029222, 0.44938813736611205, 0.19525179100794, 0.6180344334973382, 0.246496085413902, 0.6046964225412682, 0.6258058456158191, 0.6214483414573808, 0.3772490505741253, 0.43360715694533136, 0.6218983020818056, 0.6224838213824047, 0.13080017107845432, 0.10717752877302922, 0.20445303826543204, 0.13472361245926856, 0.29349404236313315, 0.2630701533999885, 0.087594700122675, 0.13797963957732629, 0.26178694866724395, 0.17439261807551343, 0.2979687345797343, 0.16678683377723225, 0.4465676308451306, 0.1810650120392061, 0.2596556017672307, 0.2772660478560257, 0.08062603182268613, 0.07826255197108989, 0.7189371009749476, 0.7316718241167037, 0.708082658466398, 0.741791223133677, 0.7233647336003373, 0.7532703673177674, 0.7132727579353295, 0.7238402277801717, 0.74143395286195, 0.11317775719064738, 0.07362489142949835, 0.09718908757163902, 0.11691873474537262, 0.08491997217369296, 0.11495113453693462, 0.1270523945863018, 0.12209841217891315, 0.15663166250767357, 0.2417963283213067, 0.17441047313641578, 0.16796813437687597, 0.2070913028869148, 0.36628293204434015, 0.17138916895243694, 0.39151634698325, 0.16560855559981702, 0.20207964597507788, 0.2755890115265477, 0.4297826646894508, 0.4362416760153178, 0.5521491998385618, 0.39060847798222165, 0.4190847775010249, 0.27293954202576265, 0.4006416313469845, 0.4125861122295712, 0.23324359329959032, 0.2539800109501379, 0.2745202406182683, 0.2933029936424171, 0.26536404868584895, 0.3143127252948621, 0.24061282430942532, 0.2856510683817389, 0.2930011090612348, 0.25986835180921997, 0.23373898889529943, 0.20633675015236708, 0.2719340643662903, 0.21883943256824845, 0.24811071822895925, 0.2567027068188342, 0.22243491895026268, 0.24985760813862212, 0.22628088035851746, 0.1834734132595378, 0.21617167695317352, 0.20485266400691238, 0.211739358720326, 0.1949440222256782, 0.18044557815824558, 0.18176459272553014, 0.19687885252840875, 0.1872378393280727, 0.1880636939411262, 0.18827245097521927, 0.18808428592319992, 0.2006991852164579, 0.8538203610011507, 0.14180203676297154, 0.17256583434232198, 0.16704992114686323, 0.8726340759870046, 0.20710895004204444, 0.91562240633362, 0.2117372647559701, 0.2086465447720819, 0.7482483369309854, 0.8344721416245962, 0.8069365032188163, 0.15401298143248754, 0.19198266069418035, 0.20677138876835477, 0.20287808132871554, 0.20158809752847806, 0.2087799082670786, 0.21187403317828202, 0.20620630754666058, 0.2005255237368624, 0.2234554822116397, 0.10575261740075148, 0.10064839928586133, 0.09937389122202989, 0.09203845817317191, 0.08949779109126232, 0.09708179332934541, 0.0888513506480012, 0.10542314904396355, 0.08272721681146955]}, "mutation_prompt": null}
{"id": "045a011a-6f08-4bb9-a69b-9048849bd4fe", "solution": "import numpy as np\n\nclass EnhancedDynamicSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Reduced population size for focused exploration\n        self.w = 0.7  # Adjusted inertia weight for improved exploration\n        self.cr = 0.85  # Slightly reduced crossover to maintain necessary diversity\n        self.f = 0.6  # Increased mutation factor for broader search space exploration\n        self.pm = 0.15  # Increased mutation probability for more frequent updates\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.3, 0.3, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Enhanced Mutation Strategies\n                indices = np.random.choice(self.pop_size, 5, replace=False)\n                x0, x1, x2, x3, x4 = population[indices]\n                mutant = x0 + self.f * (x1 - x2) + self.f * (x3 - x4)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n                    \n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Adaptive PSO Update with Learning Factor\n            self.w = 0.4 + 0.3 * np.exp(-evaluations / (self.budget / 10))  # Exponential decay of inertia\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n                \n                # Evaluate new position\n                f_val = func(population[i])\n                evaluations += 1\n                \n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n                    \n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n        \n        return global_best", "name": "EnhancedDynamicSwarm", "description": "Enhanced Dynamic Swarm Algorithm utilizing adaptive hybrid mutation strategies and a dynamic learning factor for accelerated convergence.", "configspace": "", "generation": 46, "fitness": 0.36777491508384824, "feedback": "The algorithm EnhancedDynamicSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.27.", "error": "", "parent_id": "6bf25984-34d4-4aaa-bf54-c71a94c74b6f", "metadata": {"aucs": [0.8661770462715196, 0.8533658683533394, 0.8748168789919879, 0.8479576775838925, 0.8619294523234338, 0.8481032388694874, 0.8545843505996102, 0.8506130091170299, 0.8514218461767789, 0.5841215551218306, 0.5566798193017393, 0.5038218679262396, 0.5715058106598907, 0.5846815082737928, 0.5751831509555265, 0.5570316440320326, 0.5971503238875412, 0.3033054098846033, 0.0912504498945731, 0.14232876973494712, 0.09186677112356834, 0.14325537029866775, 0.13515149815116634, 0.11000994957154564, 0.08919985690963261, 0.0957174887347697, 0.12858301987027276, 0.10669875354549807, 0.11873057971464918, 0.10260472058968684, 0.11036777197473657, 0.09211312968801921, 0.06873684466222696, 0.10864051361116456, 0.09110091605603521, 0.07695847343243734, 0.97089573151135, 0.9519060470526722, 0.9742399306499329, 0.9499540381814636, 0.9723285244118253, 0.9747527189264217, 0.9733191419936255, 0.9799094783828957, 0.9746046735932662, 0.7536120439791287, 0.7286671376429104, 0.7508410260024907, 0.6703150455670062, 0.7240282884689826, 0.743014631170392, 0.7201911297511088, 0.726589931013128, 0.6953011010883863, 0.873681107427706, 0.2291072902697986, 0.22563922239450973, 0.20743573183079111, 0.370208033834846, 0.7989960782134384, 0.8584457951593084, 0.2317549436113615, 0.38565098327430025, 0.6983403719401788, 0.4593175794940928, 0.5226253837589581, 0.13204168932304106, 0.13123794176508508, 0.6041188826693126, 0.66638393835081, 0.7159500014002091, 0.49504681304726506, 0.6393273722950316, 0.5317199804044543, 0.6747424084519493, 0.5476945562460063, 0.6216532534371288, 0.596283261503091, 0.6409177422265598, 0.4224114038249964, 0.6117011758836983, 0.3301155968795241, 0.053691713789477014, 0.3408297626768301, 0.19091645976538374, 0.24731160539288388, 0.03399084808241293, 0.15274544589416306, 0.06826523467760748, 0.06977250235615207, 0.6367163572915283, 0.5994984786500948, 0.21000653457041296, 0.21932242025252224, 0.21226644153200847, 0.28846835000861115, 0.22887485516777162, 0.6629432784359105, 0.657803152379125, 0.15157778587955417, 0.13007505254684493, 0.27820370136969597, 0.2421821834468998, 0.07326523259838291, 0.2558137632362305, 0.1116280094602089, 0.3472119871615963, 0.16297591597643912, 0.23789666100325957, 0.13328172553237672, 0.3158704241287501, 0.4849443460665892, 0.21392783601454768, 0.36558124130832526, 0.04795576964557735, 0.05524840123444741, 0.08089551052177635, 0.6657085528853518, 0.6900927596698372, 0.7412231204130264, 0.6909652732536664, 0.7331677845991726, 0.6608973410222878, 0.6971513065734936, 0.7038745618031178, 0.6811404918964865, 0.13668662126297826, 0.10574645407347838, 0.11265594526297285, 0.11917688893825418, 0.1270244589369649, 0.16016476695653126, 0.11045602584560799, 0.1819162606753313, 0.12722945621791337, 0.16650504550332734, 0.3242404940593845, 0.2020141733029196, 0.1928522260824188, 0.27829263010925, 0.1612249591391719, 0.2833982933572421, 0.24583379647323822, 0.2532338993451366, 0.37626552736454444, 0.2740734903358293, 0.3553682000486408, 0.33843278620428596, 0.2736610424829098, 0.24007289982667313, 0.26549015997166814, 0.25962326380138834, 0.32091937277931015, 0.2879620529963157, 0.2747615384815639, 0.22084717427224343, 0.2017838741060718, 0.18497532936622807, 0.24112538008763473, 0.31712518718580684, 0.3006427470409052, 0.21971339999221207, 0.2345157486876286, 0.20941297253272695, 0.2168715947861385, 0.2687483549510239, 0.21984511692712827, 0.22844798929510735, 0.24178041023141184, 0.26295739115868544, 0.23385596597619907, 0.19714162332826068, 0.20843102576941508, 0.20550293205163384, 0.2424009530463338, 0.17535610985997319, 0.17888913468736534, 0.17163088856623854, 0.22531149116664806, 0.1856885786304734, 0.18696584888077428, 0.1678763001885778, 0.14746353429600623, 0.20078471079804616, 0.20083906660328843, 0.8669983824449207, 0.8617052978071478, 0.16278263317555175, 0.18688965042752725, 0.861962366283084, 0.2115135754374362, 0.07360413626605988, 0.20939502891445738, 0.1688413872116471, 0.1534035068583275, 0.21151208752299955, 0.2101515360941566, 0.8462104242239498, 0.20506992731866813, 0.1842352585350976, 0.19901229305278778, 0.187641071903492, 0.19415604402641506, 0.18235578575815747, 0.22401844380710523, 0.20658084807520294, 0.19369822704877326, 0.09041177675614576, 0.10087107447795529, 0.09623362701375604, 0.09627835665884499, 0.10019869318700281, 0.1062034027727985, 0.08185255271303793, 0.09156944513635468, 0.09284657852775435]}, "mutation_prompt": null}
{"id": "88e583bc-b20a-4b53-aaa5-3e53d357b5e9", "solution": "import numpy as np\n\nclass DynamicSwarmEnsemble:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Adjusted population size for better sampling\n        self.w = 0.5  # Adaptive inertia weight for improved balance\n        self.cr = 0.9  # Higher crossover rate for diversity\n        self.f = 0.5  # Reduced mutation factor for stability\n        self.pm = 0.1  # Tuned mutation probability for refinement\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Multi-strategy DE Mutation\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                mutant = x0 + self.f * (x1 - x2) + self.f * (x3 - personal_best[i])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n                    \n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Adaptive PSO Update\n            self.w = 0.3 + 0.2 * (1 - evaluations / self.budget)  # Dynamic inertia\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n                \n                # Evaluate new position\n                f_val = func(population[i])\n                evaluations += 1\n                \n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n                    \n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n        \n        return global_best", "name": "DynamicSwarmEnsemble", "description": "A novel Dynamic Swarm Ensemble Algorithm integrating adaptive parameters and multi-strategy reinforcement to enhance convergence and robustness.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6bf25984-34d4-4aaa-bf54-c71a94c74b6f", "metadata": {"aucs": [0.8610176580685336, 0.8429510547117746, 0.8441707373173608, 0.8383338639476395, 0.8415997716485245, 0.8562669295605425, 0.8475727681498716, 0.8477582442739064, 0.8401723238596119, 0.6011242634660201, 0.4984478381513553, 0.5634069422702649, 0.558043876576676, 0.5223926466928138, 0.5699198092526212, 0.5419651469397592, 0.5763395174716845, 0.043827753782448076, 0.12215239420548585, 0.07870657081763621, 0.1154338898157099, 0.13458847498434845, 0.13822435451965798, 0.12054469469075979, 0.15803714468615493, 0.1550099933507596, 0.13627895850911131, 0.10897468883058914, 0.1328699072852858, 0.09351269486502789, 0.07970546750117269, 0.08195894596046416, 0.17510411284844596, 0.0911741622888701, 0.13742926990139637, 0.10133592159061977, 0.9669270306112738, 0.9667072261531513, 0.9731951111826657, 0.9649016961962305, 0.9640356150675982, 0.9761034085024857, 0.9881531363008376, 0.9733950188080025, 0.9685627790523466, 0.6925386496625596, 0.7141526271204485, 0.7042564446697748, 0.7120781780698422, 0.7024905182100982, 0.6967606659516146, 0.6657533325173182, 0.688617574065995, 0.6893138864787259, 0.8476439556228765, 0.8925855919599447, 0.16946710833919065, 0.2783919924985716, 0.27768915651927684, 0.2680843470434916, 0.7885992173269092, 0.23081134742437504, 0.23026112878581373, 0.3462133813488927, 0.6174390227949587, 0.6988228685192329, 0.4424670231293131, 0.11786299709528414, 0.6520739369557373, 0.5744951761611164, 0.5574451528586133, 0.5988133473443354, 0.6781850128926137, 0.5278633784754105, 0.6421040435752594, 0.133977220574505, 0.13408026536174766, 0.134596304485876, 0.6634340632748498, 0.6626650052419584, 0.1285520624753702, 0.28942067692449913, 0.3162794021524712, 0.0663357194332379, 0.3077861052445795, 0.135254764812903, 0.1293506692379357, 0.3982133324029222, 0.44938813736611205, 0.19525179100794, 0.6180344334973382, 0.246496085413902, 0.6046964225412682, 0.6258058456158191, 0.6214483414573808, 0.3772490505741253, 0.43360715694533136, 0.6218983020818056, 0.6224838213824047, 0.13080017107845432, 0.10717752877302922, 0.20445303826543204, 0.13472361245926856, 0.29349404236313315, 0.2630701533999885, 0.087594700122675, 0.13797963957732629, 0.26178694866724395, 0.17439261807551343, 0.2979687345797343, 0.16678683377723225, 0.4465676308451306, 0.1810650120392061, 0.2596556017672307, 0.2772660478560257, 0.08062603182268613, 0.07826255197108989, 0.7189371009749476, 0.7316718241167037, 0.708082658466398, 0.741791223133677, 0.7233647336003373, 0.7532703673177674, 0.7132727579353295, 0.7238402277801717, 0.74143395286195, 0.11317775719064738, 0.07362489142949835, 0.09718908757163902, 0.11691873474537262, 0.08491997217369296, 0.11495113453693462, 0.1270523945863018, 0.12209841217891315, 0.15663166250767357, 0.2417963283213067, 0.17441047313641578, 0.16796813437687597, 0.2070913028869148, 0.36628293204434015, 0.17138916895243694, 0.39151634698325, 0.16560855559981702, 0.20207964597507788, 0.2755890115265477, 0.4297826646894508, 0.4362416760153178, 0.5521491998385618, 0.39060847798222165, 0.4190847775010249, 0.27293954202576265, 0.4006416313469845, 0.4125861122295712, 0.23324359329959032, 0.2539800109501379, 0.2745202406182683, 0.2933029936424171, 0.26536404868584895, 0.3143127252948621, 0.24061282430942532, 0.2856510683817389, 0.2930011090612348, 0.25986835180921997, 0.23373898889529943, 0.20633675015236708, 0.2719340643662903, 0.21883943256824845, 0.24811071822895925, 0.2567027068188342, 0.22243491895026268, 0.24985760813862212, 0.22628088035851746, 0.1834734132595378, 0.21617167695317352, 0.20485266400691238, 0.211739358720326, 0.1949440222256782, 0.18044557815824558, 0.18176459272553014, 0.19687885252840875, 0.1872378393280727, 0.1880636939411262, 0.18827245097521927, 0.18808428592319992, 0.2006991852164579, 0.8538203610011507, 0.14180203676297154, 0.17256583434232198, 0.16704992114686323, 0.8726340759870046, 0.20710895004204444, 0.91562240633362, 0.2117372647559701, 0.2086465447720819, 0.7482483369309854, 0.8344721416245962, 0.8069365032188163, 0.15401298143248754, 0.19198266069418035, 0.20677138876835477, 0.20287808132871554, 0.20158809752847806, 0.2087799082670786, 0.21187403317828202, 0.20620630754666058, 0.2005255237368624, 0.2234554822116397, 0.10575261740075148, 0.10064839928586133, 0.09937389122202989, 0.09203845817317191, 0.08949779109126232, 0.09708179332934541, 0.0888513506480012, 0.10542314904396355, 0.08272721681146955]}, "mutation_prompt": null}
{"id": "075eefd4-68dd-41be-b30e-dfe9dfb0d9b0", "solution": "import numpy as np\n\nclass DynamicSwarmEnsemble:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Adjusted population size for better sampling\n        self.w = 0.5  # Adaptive inertia weight for improved balance\n        self.cr = 0.9  # Higher crossover rate for diversity\n        self.f = 0.5  # Reduced mutation factor for stability\n        self.pm = 0.1  # Tuned mutation probability for refinement\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Multi-strategy DE Mutation\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                mutant = x0 + self.f * (x1 - x2) + self.f * (x3 - personal_best[i])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n                    \n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Adaptive PSO Update\n            self.w = 0.3 + 0.2 * (1 - evaluations / self.budget)  # Dynamic inertia\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n                \n                # Evaluate new position\n                f_val = func(population[i])\n                evaluations += 1\n                \n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n                    \n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n        \n        return global_best", "name": "DynamicSwarmEnsemble", "description": "A novel Dynamic Swarm Ensemble Algorithm integrating adaptive parameters and multi-strategy reinforcement to enhance convergence and robustness.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6bf25984-34d4-4aaa-bf54-c71a94c74b6f", "metadata": {"aucs": [0.8610176580685336, 0.8429510547117746, 0.8441707373173608, 0.8383338639476395, 0.8415997716485245, 0.8562669295605425, 0.8475727681498716, 0.8477582442739064, 0.8401723238596119, 0.6011242634660201, 0.4984478381513553, 0.5634069422702649, 0.558043876576676, 0.5223926466928138, 0.5699198092526212, 0.5419651469397592, 0.5763395174716845, 0.043827753782448076, 0.12215239420548585, 0.07870657081763621, 0.1154338898157099, 0.13458847498434845, 0.13822435451965798, 0.12054469469075979, 0.15803714468615493, 0.1550099933507596, 0.13627895850911131, 0.10897468883058914, 0.1328699072852858, 0.09351269486502789, 0.07970546750117269, 0.08195894596046416, 0.17510411284844596, 0.0911741622888701, 0.13742926990139637, 0.10133592159061977, 0.9669270306112738, 0.9667072261531513, 0.9731951111826657, 0.9649016961962305, 0.9640356150675982, 0.9761034085024857, 0.9881531363008376, 0.9733950188080025, 0.9685627790523466, 0.6925386496625596, 0.7141526271204485, 0.7042564446697748, 0.7120781780698422, 0.7024905182100982, 0.6967606659516146, 0.6657533325173182, 0.688617574065995, 0.6893138864787259, 0.8476439556228765, 0.8925855919599447, 0.16946710833919065, 0.2783919924985716, 0.27768915651927684, 0.2680843470434916, 0.7885992173269092, 0.23081134742437504, 0.23026112878581373, 0.3462133813488927, 0.6174390227949587, 0.6988228685192329, 0.4424670231293131, 0.11786299709528414, 0.6520739369557373, 0.5744951761611164, 0.5574451528586133, 0.5988133473443354, 0.6781850128926137, 0.5278633784754105, 0.6421040435752594, 0.133977220574505, 0.13408026536174766, 0.134596304485876, 0.6634340632748498, 0.6626650052419584, 0.1285520624753702, 0.28942067692449913, 0.3162794021524712, 0.0663357194332379, 0.3077861052445795, 0.135254764812903, 0.1293506692379357, 0.3982133324029222, 0.44938813736611205, 0.19525179100794, 0.6180344334973382, 0.246496085413902, 0.6046964225412682, 0.6258058456158191, 0.6214483414573808, 0.3772490505741253, 0.43360715694533136, 0.6218983020818056, 0.6224838213824047, 0.13080017107845432, 0.10717752877302922, 0.20445303826543204, 0.13472361245926856, 0.29349404236313315, 0.2630701533999885, 0.087594700122675, 0.13797963957732629, 0.26178694866724395, 0.17439261807551343, 0.2979687345797343, 0.16678683377723225, 0.4465676308451306, 0.1810650120392061, 0.2596556017672307, 0.2772660478560257, 0.08062603182268613, 0.07826255197108989, 0.7189371009749476, 0.7316718241167037, 0.708082658466398, 0.741791223133677, 0.7233647336003373, 0.7532703673177674, 0.7132727579353295, 0.7238402277801717, 0.74143395286195, 0.11317775719064738, 0.07362489142949835, 0.09718908757163902, 0.11691873474537262, 0.08491997217369296, 0.11495113453693462, 0.1270523945863018, 0.12209841217891315, 0.15663166250767357, 0.2417963283213067, 0.17441047313641578, 0.16796813437687597, 0.2070913028869148, 0.36628293204434015, 0.17138916895243694, 0.39151634698325, 0.16560855559981702, 0.20207964597507788, 0.2755890115265477, 0.4297826646894508, 0.4362416760153178, 0.5521491998385618, 0.39060847798222165, 0.4190847775010249, 0.27293954202576265, 0.4006416313469845, 0.4125861122295712, 0.23324359329959032, 0.2539800109501379, 0.2745202406182683, 0.2933029936424171, 0.26536404868584895, 0.3143127252948621, 0.24061282430942532, 0.2856510683817389, 0.2930011090612348, 0.25986835180921997, 0.23373898889529943, 0.20633675015236708, 0.2719340643662903, 0.21883943256824845, 0.24811071822895925, 0.2567027068188342, 0.22243491895026268, 0.24985760813862212, 0.22628088035851746, 0.1834734132595378, 0.21617167695317352, 0.20485266400691238, 0.211739358720326, 0.1949440222256782, 0.18044557815824558, 0.18176459272553014, 0.19687885252840875, 0.1872378393280727, 0.1880636939411262, 0.18827245097521927, 0.18808428592319992, 0.2006991852164579, 0.8538203610011507, 0.14180203676297154, 0.17256583434232198, 0.16704992114686323, 0.8726340759870046, 0.20710895004204444, 0.91562240633362, 0.2117372647559701, 0.2086465447720819, 0.7482483369309854, 0.8344721416245962, 0.8069365032188163, 0.15401298143248754, 0.19198266069418035, 0.20677138876835477, 0.20287808132871554, 0.20158809752847806, 0.2087799082670786, 0.21187403317828202, 0.20620630754666058, 0.2005255237368624, 0.2234554822116397, 0.10575261740075148, 0.10064839928586133, 0.09937389122202989, 0.09203845817317191, 0.08949779109126232, 0.09708179332934541, 0.0888513506480012, 0.10542314904396355, 0.08272721681146955]}, "mutation_prompt": null}
{"id": "045774de-c234-4936-a5e9-7ea535f2d28a", "solution": "import numpy as np\n\nclass DynamicSwarmEnsemble:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Adjusted population size for better sampling\n        self.w = 0.5  # Adaptive inertia weight for improved balance\n        self.cr = 0.9  # Higher crossover rate for diversity\n        self.f = 0.5  # Reduced mutation factor for stability\n        self.pm = 0.1  # Tuned mutation probability for refinement\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Multi-strategy DE Mutation\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                mutant = x0 + self.f * (x1 - x2) + self.f * (x3 - personal_best[i])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n                    \n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Adaptive PSO Update\n            self.w = 0.3 + 0.2 * (1 - evaluations / self.budget)  # Dynamic inertia\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n                \n                # Evaluate new position\n                f_val = func(population[i])\n                evaluations += 1\n                \n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n                    \n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n        \n        return global_best", "name": "DynamicSwarmEnsemble", "description": "A novel Dynamic Swarm Ensemble Algorithm integrating adaptive parameters and multi-strategy reinforcement to enhance convergence and robustness.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6bf25984-34d4-4aaa-bf54-c71a94c74b6f", "metadata": {"aucs": [0.8610176580685336, 0.8429510547117746, 0.8441707373173608, 0.8383338639476395, 0.8415997716485245, 0.8562669295605425, 0.8475727681498716, 0.8477582442739064, 0.8401723238596119, 0.6011242634660201, 0.4984478381513553, 0.5634069422702649, 0.558043876576676, 0.5223926466928138, 0.5699198092526212, 0.5419651469397592, 0.5763395174716845, 0.043827753782448076, 0.12215239420548585, 0.07870657081763621, 0.1154338898157099, 0.13458847498434845, 0.13822435451965798, 0.12054469469075979, 0.15803714468615493, 0.1550099933507596, 0.13627895850911131, 0.10897468883058914, 0.1328699072852858, 0.09351269486502789, 0.07970546750117269, 0.08195894596046416, 0.17510411284844596, 0.0911741622888701, 0.13742926990139637, 0.10133592159061977, 0.9669270306112738, 0.9667072261531513, 0.9731951111826657, 0.9649016961962305, 0.9640356150675982, 0.9761034085024857, 0.9881531363008376, 0.9733950188080025, 0.9685627790523466, 0.6925386496625596, 0.7141526271204485, 0.7042564446697748, 0.7120781780698422, 0.7024905182100982, 0.6967606659516146, 0.6657533325173182, 0.688617574065995, 0.6893138864787259, 0.8476439556228765, 0.8925855919599447, 0.16946710833919065, 0.2783919924985716, 0.27768915651927684, 0.2680843470434916, 0.7885992173269092, 0.23081134742437504, 0.23026112878581373, 0.3462133813488927, 0.6174390227949587, 0.6988228685192329, 0.4424670231293131, 0.11786299709528414, 0.6520739369557373, 0.5744951761611164, 0.5574451528586133, 0.5988133473443354, 0.6781850128926137, 0.5278633784754105, 0.6421040435752594, 0.133977220574505, 0.13408026536174766, 0.134596304485876, 0.6634340632748498, 0.6626650052419584, 0.1285520624753702, 0.28942067692449913, 0.3162794021524712, 0.0663357194332379, 0.3077861052445795, 0.135254764812903, 0.1293506692379357, 0.3982133324029222, 0.44938813736611205, 0.19525179100794, 0.6180344334973382, 0.246496085413902, 0.6046964225412682, 0.6258058456158191, 0.6214483414573808, 0.3772490505741253, 0.43360715694533136, 0.6218983020818056, 0.6224838213824047, 0.13080017107845432, 0.10717752877302922, 0.20445303826543204, 0.13472361245926856, 0.29349404236313315, 0.2630701533999885, 0.087594700122675, 0.13797963957732629, 0.26178694866724395, 0.17439261807551343, 0.2979687345797343, 0.16678683377723225, 0.4465676308451306, 0.1810650120392061, 0.2596556017672307, 0.2772660478560257, 0.08062603182268613, 0.07826255197108989, 0.7189371009749476, 0.7316718241167037, 0.708082658466398, 0.741791223133677, 0.7233647336003373, 0.7532703673177674, 0.7132727579353295, 0.7238402277801717, 0.74143395286195, 0.11317775719064738, 0.07362489142949835, 0.09718908757163902, 0.11691873474537262, 0.08491997217369296, 0.11495113453693462, 0.1270523945863018, 0.12209841217891315, 0.15663166250767357, 0.2417963283213067, 0.17441047313641578, 0.16796813437687597, 0.2070913028869148, 0.36628293204434015, 0.17138916895243694, 0.39151634698325, 0.16560855559981702, 0.20207964597507788, 0.2755890115265477, 0.4297826646894508, 0.4362416760153178, 0.5521491998385618, 0.39060847798222165, 0.4190847775010249, 0.27293954202576265, 0.4006416313469845, 0.4125861122295712, 0.23324359329959032, 0.2539800109501379, 0.2745202406182683, 0.2933029936424171, 0.26536404868584895, 0.3143127252948621, 0.24061282430942532, 0.2856510683817389, 0.2930011090612348, 0.25986835180921997, 0.23373898889529943, 0.20633675015236708, 0.2719340643662903, 0.21883943256824845, 0.24811071822895925, 0.2567027068188342, 0.22243491895026268, 0.24985760813862212, 0.22628088035851746, 0.1834734132595378, 0.21617167695317352, 0.20485266400691238, 0.211739358720326, 0.1949440222256782, 0.18044557815824558, 0.18176459272553014, 0.19687885252840875, 0.1872378393280727, 0.1880636939411262, 0.18827245097521927, 0.18808428592319992, 0.2006991852164579, 0.8538203610011507, 0.14180203676297154, 0.17256583434232198, 0.16704992114686323, 0.8726340759870046, 0.20710895004204444, 0.91562240633362, 0.2117372647559701, 0.2086465447720819, 0.7482483369309854, 0.8344721416245962, 0.8069365032188163, 0.15401298143248754, 0.19198266069418035, 0.20677138876835477, 0.20287808132871554, 0.20158809752847806, 0.2087799082670786, 0.21187403317828202, 0.20620630754666058, 0.2005255237368624, 0.2234554822116397, 0.10575261740075148, 0.10064839928586133, 0.09937389122202989, 0.09203845817317191, 0.08949779109126232, 0.09708179332934541, 0.0888513506480012, 0.10542314904396355, 0.08272721681146955]}, "mutation_prompt": null}
{"id": "2b360dce-06d4-4eb5-a747-594356e2b3f5", "solution": "import numpy as np\n\nclass DynamicSwarmEnsemble:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Adjusted population size for better sampling\n        self.w = 0.5  # Adaptive inertia weight for improved balance\n        self.cr = 0.9  # Higher crossover rate for diversity\n        self.f = 0.5  # Reduced mutation factor for stability\n        self.pm = 0.1  # Tuned mutation probability for refinement\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Multi-strategy DE Mutation\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                mutant = x0 + self.f * (x1 - x2) + self.f * (x3 - personal_best[i])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n                    \n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Adaptive PSO Update\n            self.w = 0.3 + 0.2 * (1 - evaluations / self.budget)  # Dynamic inertia\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n                \n                # Evaluate new position\n                f_val = func(population[i])\n                evaluations += 1\n                \n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n                    \n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n        \n        return global_best", "name": "DynamicSwarmEnsemble", "description": "A novel Dynamic Swarm Ensemble Algorithm integrating adaptive parameters and multi-strategy reinforcement to enhance convergence and robustness.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6bf25984-34d4-4aaa-bf54-c71a94c74b6f", "metadata": {"aucs": [0.8610176580685336, 0.8429510547117746, 0.8441707373173608, 0.8383338639476395, 0.8415997716485245, 0.8562669295605425, 0.8475727681498716, 0.8477582442739064, 0.8401723238596119, 0.6011242634660201, 0.4984478381513553, 0.5634069422702649, 0.558043876576676, 0.5223926466928138, 0.5699198092526212, 0.5419651469397592, 0.5763395174716845, 0.043827753782448076, 0.12215239420548585, 0.07870657081763621, 0.1154338898157099, 0.13458847498434845, 0.13822435451965798, 0.12054469469075979, 0.15803714468615493, 0.1550099933507596, 0.13627895850911131, 0.10897468883058914, 0.1328699072852858, 0.09351269486502789, 0.07970546750117269, 0.08195894596046416, 0.17510411284844596, 0.0911741622888701, 0.13742926990139637, 0.10133592159061977, 0.9669270306112738, 0.9667072261531513, 0.9731951111826657, 0.9649016961962305, 0.9640356150675982, 0.9761034085024857, 0.9881531363008376, 0.9733950188080025, 0.9685627790523466, 0.6925386496625596, 0.7141526271204485, 0.7042564446697748, 0.7120781780698422, 0.7024905182100982, 0.6967606659516146, 0.6657533325173182, 0.688617574065995, 0.6893138864787259, 0.8476439556228765, 0.8925855919599447, 0.16946710833919065, 0.2783919924985716, 0.27768915651927684, 0.2680843470434916, 0.7885992173269092, 0.23081134742437504, 0.23026112878581373, 0.3462133813488927, 0.6174390227949587, 0.6988228685192329, 0.4424670231293131, 0.11786299709528414, 0.6520739369557373, 0.5744951761611164, 0.5574451528586133, 0.5988133473443354, 0.6781850128926137, 0.5278633784754105, 0.6421040435752594, 0.133977220574505, 0.13408026536174766, 0.134596304485876, 0.6634340632748498, 0.6626650052419584, 0.1285520624753702, 0.28942067692449913, 0.3162794021524712, 0.0663357194332379, 0.3077861052445795, 0.135254764812903, 0.1293506692379357, 0.3982133324029222, 0.44938813736611205, 0.19525179100794, 0.6180344334973382, 0.246496085413902, 0.6046964225412682, 0.6258058456158191, 0.6214483414573808, 0.3772490505741253, 0.43360715694533136, 0.6218983020818056, 0.6224838213824047, 0.13080017107845432, 0.10717752877302922, 0.20445303826543204, 0.13472361245926856, 0.29349404236313315, 0.2630701533999885, 0.087594700122675, 0.13797963957732629, 0.26178694866724395, 0.17439261807551343, 0.2979687345797343, 0.16678683377723225, 0.4465676308451306, 0.1810650120392061, 0.2596556017672307, 0.2772660478560257, 0.08062603182268613, 0.07826255197108989, 0.7189371009749476, 0.7316718241167037, 0.708082658466398, 0.741791223133677, 0.7233647336003373, 0.7532703673177674, 0.7132727579353295, 0.7238402277801717, 0.74143395286195, 0.11317775719064738, 0.07362489142949835, 0.09718908757163902, 0.11691873474537262, 0.08491997217369296, 0.11495113453693462, 0.1270523945863018, 0.12209841217891315, 0.15663166250767357, 0.2417963283213067, 0.17441047313641578, 0.16796813437687597, 0.2070913028869148, 0.36628293204434015, 0.17138916895243694, 0.39151634698325, 0.16560855559981702, 0.20207964597507788, 0.2755890115265477, 0.4297826646894508, 0.4362416760153178, 0.5521491998385618, 0.39060847798222165, 0.4190847775010249, 0.27293954202576265, 0.4006416313469845, 0.4125861122295712, 0.23324359329959032, 0.2539800109501379, 0.2745202406182683, 0.2933029936424171, 0.26536404868584895, 0.3143127252948621, 0.24061282430942532, 0.2856510683817389, 0.2930011090612348, 0.25986835180921997, 0.23373898889529943, 0.20633675015236708, 0.2719340643662903, 0.21883943256824845, 0.24811071822895925, 0.2567027068188342, 0.22243491895026268, 0.24985760813862212, 0.22628088035851746, 0.1834734132595378, 0.21617167695317352, 0.20485266400691238, 0.211739358720326, 0.1949440222256782, 0.18044557815824558, 0.18176459272553014, 0.19687885252840875, 0.1872378393280727, 0.1880636939411262, 0.18827245097521927, 0.18808428592319992, 0.2006991852164579, 0.8538203610011507, 0.14180203676297154, 0.17256583434232198, 0.16704992114686323, 0.8726340759870046, 0.20710895004204444, 0.91562240633362, 0.2117372647559701, 0.2086465447720819, 0.7482483369309854, 0.8344721416245962, 0.8069365032188163, 0.15401298143248754, 0.19198266069418035, 0.20677138876835477, 0.20287808132871554, 0.20158809752847806, 0.2087799082670786, 0.21187403317828202, 0.20620630754666058, 0.2005255237368624, 0.2234554822116397, 0.10575261740075148, 0.10064839928586133, 0.09937389122202989, 0.09203845817317191, 0.08949779109126232, 0.09708179332934541, 0.0888513506480012, 0.10542314904396355, 0.08272721681146955]}, "mutation_prompt": null}
{"id": "f6471955-077f-4290-84db-b974fd348f60", "solution": "import numpy as np\n\nclass AdaptiveMultiOperatorSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60\n        self.w = 0.7  # Increased initial inertia weight for exploration\n        self.cr = 0.85  # Adjusted crossover rate to balance exploration and exploitation\n        self.f = 0.5  \n        self.pm = 0.1\n        self.learning_rate = 0.2  # New learning factor for strategic learning\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.4, 0.4, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 5, replace=False)\n                x0, x1, x2, x3, x4 = population[indices]\n                mutant = x0 + self.f * (x1 - x2 + x3 - x4)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n                    \n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n            \n            self.w = 0.7 - 0.4 * (evaluations / self.budget)  # Adaptive inertia\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * self.learning_rate * (personal_best[i] - population[i]) +\n                                 r2 * self.learning_rate * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n                \n                f_val = func(population[i])\n                evaluations += 1\n                \n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n                    \n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n        \n        return global_best", "name": "AdaptiveMultiOperatorSwarm", "description": "An Adaptive Multi-Operator Swarm Algorithm leveraging dynamic mutation, velocity adaptation, and strategic learning to accelerate convergence speed.", "configspace": "", "generation": 51, "fitness": 0.2676509452868073, "feedback": "The algorithm AdaptiveMultiOperatorSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.24.", "error": "", "parent_id": "6bf25984-34d4-4aaa-bf54-c71a94c74b6f", "metadata": {"aucs": [0.7650977136040735, 0.7677528639109943, 0.7591875817754984, 0.7484610245610478, 0.7504160031636458, 0.7517306024694053, 0.7665588665192451, 0.7620283794463047, 0.754706260590855, 0.07310204502628426, 9.999999999998899e-05, 0.22772604810900077, 0.15741895459402422, 0.0003312008574150038, 0.003936149636368458, 9.999999999998899e-05, 0.11102253393185801, 9.999999999998899e-05, 0.16256813681137117, 0.12564805532988665, 0.1367063054962, 0.11495833362153829, 0.11045256159549555, 0.11673671763472449, 0.12857603448809019, 0.14798312513266088, 0.13382927059472383, 0.09929358286564238, 0.12318014843331127, 0.11925433271434505, 0.10457994927879533, 0.07713371807535363, 0.08841763947774184, 0.11004444214852815, 0.10796270995002655, 0.0961857832405707, 0.9032687733424956, 0.857589422721754, 0.9079211129205539, 0.9231184844667066, 0.7883289457516522, 0.9139705538664282, 0.8978295443940614, 0.9214274681316019, 0.8769750098475881, 0.390973762866866, 0.43888554246202727, 0.39811172889126856, 0.16553516338386776, 0.45023298224765473, 0.4097206733932738, 0.3586487369464788, 0.1635675934250732, 0.3900315206862077, 0.8308415824254682, 0.7854312299674345, 0.20951063648493395, 0.765414525181539, 0.2634630336216577, 0.20818422781747636, 0.7353831455679267, 0.76572612525114, 0.24231891143821738, 0.12605679077773835, 0.11477964850877853, 0.20003046894846177, 0.11842927555079552, 0.1329241545571178, 0.12704834174039936, 0.173204072643242, 0.3656265179896826, 0.1567477396805652, 0.22306316950996874, 0.12014506820367987, 0.14096569714507512, 0.12283369028648417, 0.1651144591585818, 0.15156903430432755, 0.21742502169299105, 0.0970673305096782, 0.12305498196812226, 0.0014479566313330139, 0.07706390106313177, 9.999999999998899e-05, 0.06019153669138755, 9.999999999998899e-05, 9.999999999998899e-05, 0.005014576863368703, 0.008846771709905665, 0.007387989215436264, 0.20102068897489722, 0.06624929880126651, 0.13561890996283998, 0.06974517333301977, 0.15627141333570926, 0.045706599816200066, 0.1338840167717299, 0.06928995674210414, 0.23765102497095336, 0.14675546381242055, 0.09217388676194949, 0.10614592766000097, 0.10189647320651962, 0.12851799223488702, 0.172424973361318, 0.10833271943306277, 0.1811373457620532, 0.1065553757193396, 0.11170415221923191, 0.16307952786893942, 0.2079004846625827, 0.05655484530574717, 0.15160014944990985, 0.09808666845847624, 0.1404634055440942, 0.152330633779991, 0.07934872310666141, 0.5245835092535225, 0.5086652057878203, 0.5566658949282619, 0.5163060203779171, 0.5127990993199756, 0.4981193892970851, 0.5798809651775585, 0.5378053017636779, 0.5341813063539862, 0.13656568065478003, 0.11277512850081517, 0.1115007510292606, 0.14457837888094383, 0.08663794423073412, 0.10463567711146537, 0.1603517361603235, 0.10052792805500088, 0.113692085264129, 0.22471445202879603, 0.19989711988828773, 0.17159556806274956, 0.16219440390964734, 0.23639100070241092, 0.19193447955047227, 0.24629817103691354, 0.22529692951017977, 0.17792734593280513, 0.43060474755096323, 0.39241533867911216, 0.38870320761885835, 0.30198679568295184, 0.2962531367485922, 0.3740591844412058, 0.26790339847961664, 0.4968400739962736, 0.3135015752571406, 0.23395392572858498, 0.2345812563245323, 0.273392599675355, 0.3345972610066036, 0.343293091965839, 0.2375838549565228, 0.20942734873486657, 0.19458588764701024, 0.2228582350615611, 0.21947506245290338, 0.20899547905340532, 0.2068223929587707, 0.24842171147260028, 0.21632093854233914, 0.2299952154420577, 0.29700183235560385, 0.2059651173725522, 0.23204729807252933, 0.18043375174442133, 0.1867903748455476, 0.19055400921624344, 0.18588438455222578, 0.20563664426398875, 0.17991070467639325, 0.2061412913846694, 0.2061714770325137, 0.18010455795169322, 0.16443692381551678, 0.1850831212922942, 0.19886164333967793, 0.8341116581621174, 0.19385338454224088, 0.18998133753746538, 0.16619829740279568, 0.169056238133505, 0.6312623043867371, 0.6778908588822609, 0.20841460050282068, 0.47647452059700235, 0.8348269633882507, 0.20431124692874514, 0.14870139504726865, 0.10370397941793841, 0.3116699030762965, 0.6235137862287128, 0.18928298838034774, 0.18106433918210785, 0.1903848419773383, 0.18363331272634964, 0.18172093240411913, 0.18677821063148026, 0.17791197413170234, 0.18360326971416152, 0.1842748617825617, 0.11082256460836726, 0.08764119362367584, 0.1197465600131985, 0.10827894161325968, 0.084593820274525, 0.09478203848793854, 0.09775218639337413, 0.09614075722057236, 0.09962305139554117]}, "mutation_prompt": null}
{"id": "c315b693-2a0d-4cd7-9e0f-fe666e48bf47", "solution": "import numpy as np\n\nclass DynamicSwarmEnsemble:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Adjusted population size for better sampling\n        self.w = 0.5  # Adaptive inertia weight for improved balance\n        self.cr = 0.9  # Higher crossover rate for diversity\n        self.f = 0.5  # Reduced mutation factor for stability\n        self.pm = 0.1  # Tuned mutation probability for refinement\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Multi-strategy DE Mutation\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                mutant = x0 + self.f * (x1 - x2) + self.f * (x3 - personal_best[i])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n                    \n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Adaptive PSO Update\n            self.w = 0.3 + 0.2 * (1 - evaluations / self.budget)  # Dynamic inertia\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n                \n                # Evaluate new position\n                f_val = func(population[i])\n                evaluations += 1\n                \n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n                    \n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n        \n        return global_best", "name": "DynamicSwarmEnsemble", "description": "A novel Dynamic Swarm Ensemble Algorithm integrating adaptive parameters and multi-strategy reinforcement to enhance convergence and robustness.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6bf25984-34d4-4aaa-bf54-c71a94c74b6f", "metadata": {"aucs": [0.8610176580685336, 0.8429510547117746, 0.8441707373173608, 0.8383338639476395, 0.8415997716485245, 0.8562669295605425, 0.8475727681498716, 0.8477582442739064, 0.8401723238596119, 0.6011242634660201, 0.4984478381513553, 0.5634069422702649, 0.558043876576676, 0.5223926466928138, 0.5699198092526212, 0.5419651469397592, 0.5763395174716845, 0.043827753782448076, 0.12215239420548585, 0.07870657081763621, 0.1154338898157099, 0.13458847498434845, 0.13822435451965798, 0.12054469469075979, 0.15803714468615493, 0.1550099933507596, 0.13627895850911131, 0.10897468883058914, 0.1328699072852858, 0.09351269486502789, 0.07970546750117269, 0.08195894596046416, 0.17510411284844596, 0.0911741622888701, 0.13742926990139637, 0.10133592159061977, 0.9669270306112738, 0.9667072261531513, 0.9731951111826657, 0.9649016961962305, 0.9640356150675982, 0.9761034085024857, 0.9881531363008376, 0.9733950188080025, 0.9685627790523466, 0.6925386496625596, 0.7141526271204485, 0.7042564446697748, 0.7120781780698422, 0.7024905182100982, 0.6967606659516146, 0.6657533325173182, 0.688617574065995, 0.6893138864787259, 0.8476439556228765, 0.8925855919599447, 0.16946710833919065, 0.2783919924985716, 0.27768915651927684, 0.2680843470434916, 0.7885992173269092, 0.23081134742437504, 0.23026112878581373, 0.3462133813488927, 0.6174390227949587, 0.6988228685192329, 0.4424670231293131, 0.11786299709528414, 0.6520739369557373, 0.5744951761611164, 0.5574451528586133, 0.5988133473443354, 0.6781850128926137, 0.5278633784754105, 0.6421040435752594, 0.133977220574505, 0.13408026536174766, 0.134596304485876, 0.6634340632748498, 0.6626650052419584, 0.1285520624753702, 0.28942067692449913, 0.3162794021524712, 0.0663357194332379, 0.3077861052445795, 0.135254764812903, 0.1293506692379357, 0.3982133324029222, 0.44938813736611205, 0.19525179100794, 0.6180344334973382, 0.246496085413902, 0.6046964225412682, 0.6258058456158191, 0.6214483414573808, 0.3772490505741253, 0.43360715694533136, 0.6218983020818056, 0.6224838213824047, 0.13080017107845432, 0.10717752877302922, 0.20445303826543204, 0.13472361245926856, 0.29349404236313315, 0.2630701533999885, 0.087594700122675, 0.13797963957732629, 0.26178694866724395, 0.17439261807551343, 0.2979687345797343, 0.16678683377723225, 0.4465676308451306, 0.1810650120392061, 0.2596556017672307, 0.2772660478560257, 0.08062603182268613, 0.07826255197108989, 0.7189371009749476, 0.7316718241167037, 0.708082658466398, 0.741791223133677, 0.7233647336003373, 0.7532703673177674, 0.7132727579353295, 0.7238402277801717, 0.74143395286195, 0.11317775719064738, 0.07362489142949835, 0.09718908757163902, 0.11691873474537262, 0.08491997217369296, 0.11495113453693462, 0.1270523945863018, 0.12209841217891315, 0.15663166250767357, 0.2417963283213067, 0.17441047313641578, 0.16796813437687597, 0.2070913028869148, 0.36628293204434015, 0.17138916895243694, 0.39151634698325, 0.16560855559981702, 0.20207964597507788, 0.2755890115265477, 0.4297826646894508, 0.4362416760153178, 0.5521491998385618, 0.39060847798222165, 0.4190847775010249, 0.27293954202576265, 0.4006416313469845, 0.4125861122295712, 0.23324359329959032, 0.2539800109501379, 0.2745202406182683, 0.2933029936424171, 0.26536404868584895, 0.3143127252948621, 0.24061282430942532, 0.2856510683817389, 0.2930011090612348, 0.25986835180921997, 0.23373898889529943, 0.20633675015236708, 0.2719340643662903, 0.21883943256824845, 0.24811071822895925, 0.2567027068188342, 0.22243491895026268, 0.24985760813862212, 0.22628088035851746, 0.1834734132595378, 0.21617167695317352, 0.20485266400691238, 0.211739358720326, 0.1949440222256782, 0.18044557815824558, 0.18176459272553014, 0.19687885252840875, 0.1872378393280727, 0.1880636939411262, 0.18827245097521927, 0.18808428592319992, 0.2006991852164579, 0.8538203610011507, 0.14180203676297154, 0.17256583434232198, 0.16704992114686323, 0.8726340759870046, 0.20710895004204444, 0.91562240633362, 0.2117372647559701, 0.2086465447720819, 0.7482483369309854, 0.8344721416245962, 0.8069365032188163, 0.15401298143248754, 0.19198266069418035, 0.20677138876835477, 0.20287808132871554, 0.20158809752847806, 0.2087799082670786, 0.21187403317828202, 0.20620630754666058, 0.2005255237368624, 0.2234554822116397, 0.10575261740075148, 0.10064839928586133, 0.09937389122202989, 0.09203845817317191, 0.08949779109126232, 0.09708179332934541, 0.0888513506480012, 0.10542314904396355, 0.08272721681146955]}, "mutation_prompt": null}
{"id": "252816ce-9d42-4773-9eaa-6f9bdd1eceb0", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Reduced population for faster convergence\n        self.w = 0.6  # More adaptive inertia weight for better exploration\n        self.cr = 0.85  # Slightly reduced crossover rate\n        self.f1 = 0.4  # New mutation factor for primary strategy\n        self.f2 = 0.7  # Additional mutation factor for secondary strategy\n        self.pm = 0.15  # Increased mutation probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n        \n        evaluations = self.pop_size\n        \n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 5, replace=False)\n                x0, x1, x2, x3, x4 = population[indices]\n                # Hybrid DE Mutations\n                if np.random.rand() < 0.5:\n                    mutant = x0 + self.f1 * (x1 - x2) + self.f1 * (x3 - x4)\n                else:\n                    mutant = x0 + self.f2 * (global_best - personal_best[i]) + self.f2 * (x1 - x2)\n                \n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n                    \n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Adaptive PSO Update\n            self.w = 0.4 + 0.2 * (1 - evaluations / self.budget)  # More dynamic inertia\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n                \n                f_val = func(population[i])\n                evaluations += 1\n                \n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n                    \n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n        \n        return global_best", "name": "HybridAdaptiveDifferentialSwarm", "description": "A Hybrid Adaptive Differential Swarm Algorithm utilizing adaptive differential strategies and dynamic velocity adaptation for improved convergence speed.", "configspace": "", "generation": 53, "fitness": 0.38591367666409987, "feedback": "The algorithm HybridAdaptiveDifferentialSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.27.", "error": "", "parent_id": "6bf25984-34d4-4aaa-bf54-c71a94c74b6f", "metadata": {"aucs": [0.8399847035150563, 0.8297347299188793, 0.8343935887309246, 0.8354691094916609, 0.8423785599077622, 0.8346747061316022, 0.828599408194562, 0.8253660000443837, 0.8481945442895926, 0.560586601793513, 0.509468442391389, 0.5514522423554671, 0.5349560568279199, 0.5229535672926364, 0.5575499150589995, 0.5899161588871488, 0.562010584760223, 0.5665792594735778, 0.08773357194157905, 0.11762283557082376, 0.11523116689143187, 0.08378477382418792, 0.14075534966641468, 0.11470853445428875, 0.08412764308966525, 0.13096016695662094, 0.120346556385449, 0.0857654426716341, 0.11676815232035476, 0.11658626339580858, 0.08503554303527783, 0.127295286097572, 0.1511813034895485, 0.09177741355774938, 0.10587432616527237, 0.08938811611452491, 0.9822444930546583, 0.9795697783123566, 0.9722470251135437, 0.9541958047434005, 0.9792220857910275, 0.988898624247711, 0.9740616174765091, 0.9776468762598887, 0.9806864673848774, 0.7250172119366884, 0.6800756468095122, 0.6701679915428258, 0.6747696978826692, 0.6562346617388781, 0.15086122361606036, 0.6633029144635232, 0.6928008940071828, 0.6773249019572963, 0.8316607014500013, 0.8559529501634606, 0.22711194315353522, 0.2742215102674922, 0.27992088591374986, 0.2708628592156871, 0.8113807554761165, 0.23722588181926707, 0.8292891764802756, 0.6614814599143011, 0.5895100749045215, 0.6426724758937667, 0.5735016035058441, 0.6482175336334325, 0.12355359255242149, 0.549743318862699, 0.6482968255483587, 0.6659933990390305, 0.6817578235694186, 0.6237630037020392, 0.6395433749614028, 0.47421110335812156, 0.6312753627007016, 0.60833656452674, 0.6754498181603489, 0.6492734449655446, 0.6229578598828613, 0.07032079289257576, 0.41615682201477366, 0.03004760863505873, 0.2994836936897398, 0.25764520760452625, 0.013650604378247388, 0.4978621876076307, 0.30593301419665564, 0.5015797028887279, 0.5300552668078029, 0.41888581661138047, 0.49519910950886503, 0.4927982489902353, 0.3481473772900705, 0.5157155727422496, 0.5979835328854721, 0.6068277868544802, 0.605484391686575, 0.12202788251928054, 0.28185842367012093, 0.3889748769794429, 0.14034325179993412, 0.23030467933447119, 0.15239946330073184, 0.09035365501522374, 0.13114630542616013, 0.11939314839609438, 0.26800141267813593, 0.3436551830783837, 0.3485232375631495, 0.15944690285886032, 0.41312244035636103, 0.18951939529335127, 0.04798817252863541, 0.1464436117456317, 0.07952468951834346, 0.7194822229797352, 0.6822106247033214, 0.7178276901133019, 0.7306446963269176, 0.7067063856927662, 0.7155027009155732, 0.7086810119256407, 0.6976884364523979, 0.7060802368473404, 0.09303918323277627, 0.12861494277302832, 0.1122473416086841, 0.07897219625187624, 0.12412455503222841, 0.0948468285639048, 0.07293573641330442, 0.13112036350164957, 0.10712089364263322, 0.16747461094756766, 0.3447401834418107, 0.17956044066178256, 0.23450884137543382, 0.2678867222075292, 0.2466616043580958, 0.38928612771689897, 0.2147184323122816, 0.20138810730895484, 0.33631021862136545, 0.5022932516774297, 0.36769053553367315, 0.31754570164924667, 0.32084496712397437, 0.46236006078146796, 0.5244066941694583, 0.3675473838327723, 0.4982875075469163, 0.3189971429438574, 0.2770447444040477, 0.29222502009902973, 0.2917606113144565, 0.3880927904261541, 0.19294815006616606, 0.20579277115877026, 0.26935545949016604, 0.23902607520985242, 0.2170749485028064, 0.23199914164816549, 0.21709920661842952, 0.23177685007436521, 0.2496052337684117, 0.22289385112725713, 0.20843171008348393, 0.205022811624629, 0.22154230365087546, 0.19597561460053203, 0.20560520018058615, 0.18212028493966292, 0.20580337433459261, 0.17025813166849169, 0.19295022322135336, 0.20912003407603685, 0.2036519880344213, 0.7549001322192992, 0.18612580154587355, 0.18498324116297715, 0.18793139511997037, 0.8951113887338211, 0.19964115936622018, 0.19836305238863705, 0.20070888032142986, 0.16165299145121503, 0.1657053737371551, 0.2092166291802683, 0.21004410535088613, 0.8192398460397772, 0.10390815125903552, 0.15541878731893444, 0.15417573054773692, 0.2103521790635524, 0.8630623411382657, 0.772284263716738, 0.2165336341233457, 0.1989215248432934, 0.1839787283695299, 0.19004494239577685, 0.21877697607156654, 0.1842247263308584, 0.19608824249692391, 0.1843747069784306, 0.1893945863661992, 0.08721057170500957, 0.08102545120487414, 0.0800124873099538, 0.07675947321303522, 0.0992437147429811, 0.13159291814150786, 0.09138894430274813, 0.09757216495648258, 0.09734649072029444]}, "mutation_prompt": null}
{"id": "75c77c35-a246-4a87-a69a-b2a131576f2e", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Slightly reduced population for efficiency\n        self.w = 0.5  # Adjusted inertia weight for better balance between exploration and exploitation\n        self.cr = 0.9  # Higher crossover rate to encourage exploration\n        self.f1 = 0.5  # Increased mutation factor for stronger primary exploration\n        self.f2 = 0.6  # Adjusted secondary mutation factor for balance\n        self.q_prob = 0.1  # New quantum probability factor for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                if np.random.rand() < self.q_prob:\n                    quantum_shift = np.random.uniform(-1, 1, self.dim)\n                    mutant = global_best + quantum_shift * (x1 - x2)\n                else:\n                    if np.random.rand() < 0.5:\n                        mutant = x0 + self.f1 * (x1 - x2) + self.f1 * (x2 - x3)\n                    else:\n                        mutant = x0 + self.f2 * (global_best - personal_best[i]) + self.f2 * (x1 - x2)\n\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n\n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.w = 0.3 + 0.3 * (1 - evaluations / self.budget)  # Dynamic inertia adjustment\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n                f_val = func(population[i])\n                evaluations += 1\n\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n\n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n        return global_best", "name": "AdaptiveQuantumHybridSwarm", "description": "An Adaptive Quantum-Inspired Hybrid Swarm Algorithm enhancing diversity and convergence through quantum mechanics concepts and adaptive dynamic techniques.", "configspace": "", "generation": 54, "fitness": 0.40684966097372494, "feedback": "The algorithm AdaptiveQuantumHybridSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.30.", "error": "", "parent_id": "252816ce-9d42-4773-9eaa-6f9bdd1eceb0", "metadata": {"aucs": [0.8732496514529094, 0.8573013930713151, 0.8744986549559657, 0.8537495192369189, 0.8604165374218101, 0.8715142837348789, 0.8704099284618737, 0.8739727116974925, 0.866791729775093, 0.6147791287774991, 0.5226600881736632, 0.6008666291934257, 0.6011496292940641, 0.5712684505558844, 0.6359510051857422, 0.045908637116616746, 0.01791592251565577, 0.624806402963642, 0.1413067638663884, 0.11049529921804513, 0.14184049273655452, 0.1027592472363914, 0.07083301263806674, 0.12002114502220551, 0.12881546204892624, 0.12197346576387535, 0.14062731601841005, 0.10096466446710328, 0.05413792712396226, 0.09114897185600312, 0.11617455852670533, 0.10909181187858685, 0.1132573468606426, 0.09365470587791058, 0.10954479806391282, 0.06924766798411386, 0.9775912343458948, 0.9856918600781291, 0.9862987405660498, 0.9770175651747988, 0.9778520464721582, 0.9781512659494478, 0.9875080020708764, 0.984098099287295, 0.9849954146772911, 0.7809659532660893, 0.7422826837075494, 0.7507287728082499, 0.7671760563977873, 0.7605455519964089, 0.7573331744633285, 0.7679600916906688, 0.747325999217636, 0.7792914648411364, 0.17111748920970027, 0.3776430589145463, 0.2148095429947724, 0.2812462563154454, 0.8986407239240541, 0.19204913894860254, 0.8747754320911039, 0.875000117318375, 0.868387248003844, 0.7632216912436319, 0.706558114179277, 0.6234648388250588, 0.13136984499800142, 0.7085088269387997, 0.6506806316873934, 0.6826924943191606, 0.6992691458062947, 0.6583057288686354, 0.734243198366002, 0.13115796893246556, 0.6705233511355073, 0.7082745516843774, 0.6388044637379255, 0.1341526369084951, 0.6743382872976676, 0.5567792737889925, 0.13081659118311728, 0.31827943748047594, 9.999999999998899e-05, 0.06633577084044773, 0.5390449000464439, 0.5270845928542385, 9.999999999998899e-05, 0.4392765556044851, 0.008076823072002082, 0.26222948519668543, 0.24804397985012738, 0.36024896744948254, 0.5288676387803491, 0.157319205348598, 0.17810397592288285, 0.6509838503096024, 0.6551795148357473, 0.6692466142047369, 0.6019556617371273, 0.06668243159341114, 0.26091536276258476, 0.22968957066875362, 0.30011996004245634, 0.09151287932329799, 0.3578498530294587, 0.2206967922068861, 0.3854711628213495, 0.20182060529747137, 0.17857461789159057, 0.19558219385245745, 0.3284205134415502, 0.006407430175517814, 0.36619250372402334, 0.2259926234100389, 0.08079187747567196, 0.3566449764797007, 0.08114697349173805, 0.7344845036158891, 0.7483427178164258, 0.7486489878661621, 0.7518594363355056, 0.7634733283067978, 0.802694999760851, 0.6843882425772356, 0.7299911756040789, 0.7593858556799229, 0.07580857596923452, 0.14444118890065638, 0.10268166408293322, 0.14555068634590862, 0.1133105093208967, 0.7033352848670488, 0.1039592203854578, 0.07995791523730145, 0.10458196920510487, 0.1700282082103276, 0.6464594007522839, 0.23788986441283433, 0.24848668452709644, 0.26787452178738946, 0.19298062414556083, 0.421872478808335, 0.19843099372711004, 0.26917347133106273, 0.5491013415157248, 0.33311292285246896, 0.47831967790630825, 0.2510770234307901, 0.24692705852935903, 0.48035384518917157, 0.23665669042404747, 0.42822797182165473, 0.30575513751038663, 0.1384240955857755, 0.21920609124034363, 0.2686337200810871, 0.3370099124725975, 0.27722345291883144, 0.2798287908940785, 0.15815476806470508, 0.3293521774471102, 0.31052351305580883, 0.21880804130783393, 0.23147323015166554, 0.21474406873959928, 0.20490956936190807, 0.23457103325372197, 0.2437305802702212, 0.2149709844811336, 0.2439850908753306, 0.23335761715769676, 0.22350210307888363, 0.18574197878039322, 0.17837020396905356, 0.2155230598069725, 0.19237625339917275, 0.19959724030473103, 0.17669365044360585, 0.21076136807788703, 0.20118337457794033, 0.9214437223791965, 0.1752419304252275, 0.14813261835915315, 0.9234731888523364, 0.1891957800520545, 0.20075856307887285, 0.14236009654782922, 0.16951293172035564, 0.9211706307592998, 0.8938069567687922, 0.21337860007900866, 0.8903324751288573, 0.8659545435144563, 0.8852123370256878, 0.15603433731549, 0.7809371264146462, 0.8691346964491866, 0.8944526734985341, 0.20381020220067825, 0.1898466526025595, 0.19237450905935372, 0.17981768391588937, 0.21853539690398427, 0.19684832418329457, 0.1848171428814328, 0.22912533053187922, 0.19210062702914676, 0.09359997277557464, 0.08913187308574833, 0.07349795134290049, 0.1072000129024635, 0.10987724557902478, 0.1309134338923733, 0.0948732229011211, 0.08903264488315288, 0.0935723001019283]}, "mutation_prompt": null}
{"id": "f84f247e-cadb-4b64-9a75-0f710de92a44", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Slightly reduced population for efficiency\n        self.w = 0.5  # Adjusted inertia weight for better balance between exploration and exploitation\n        self.cr = 0.9  # Higher crossover rate to encourage exploration\n        self.f1 = 0.5  # Increased mutation factor for stronger primary exploration\n        self.f2 = 0.6  # Adjusted secondary mutation factor for balance\n        self.q_prob = 0.1  # New quantum probability factor for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                if np.random.rand() < self.q_prob:\n                    quantum_shift = np.random.uniform(-1, 1, self.dim)\n                    mutant = global_best + quantum_shift * (x1 - x2)\n                else:\n                    if np.random.rand() < 0.5:\n                        mutant = x0 + self.f1 * (x1 - x2) + self.f1 * (x2 - x3)\n                    else:\n                        mutant = x0 + self.f2 * (global_best - personal_best[i]) + self.f2 * (x1 - x2)\n\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n\n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.w = 0.3 + 0.3 * (1 - evaluations / self.budget)  # Dynamic inertia adjustment\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n                f_val = func(population[i])\n                evaluations += 1\n\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n\n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n        return global_best", "name": "AdaptiveQuantumHybridSwarm", "description": "An Adaptive Quantum-Inspired Hybrid Swarm Algorithm enhancing diversity and convergence through quantum mechanics concepts and adaptive dynamic techniques.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75c77c35-a246-4a87-a69a-b2a131576f2e", "metadata": {"aucs": [0.8732496514529094, 0.8573013930713151, 0.8744986549559657, 0.8537495192369189, 0.8604165374218101, 0.8715142837348789, 0.8704099284618737, 0.8739727116974925, 0.866791729775093, 0.6147791287774991, 0.5226600881736632, 0.6008666291934257, 0.6011496292940641, 0.5712684505558844, 0.6359510051857422, 0.045908637116616746, 0.01791592251565577, 0.624806402963642, 0.1413067638663884, 0.11049529921804513, 0.14184049273655452, 0.1027592472363914, 0.07083301263806674, 0.12002114502220551, 0.12881546204892624, 0.12197346576387535, 0.14062731601841005, 0.10096466446710328, 0.05413792712396226, 0.09114897185600312, 0.11617455852670533, 0.10909181187858685, 0.1132573468606426, 0.09365470587791058, 0.10954479806391282, 0.06924766798411386, 0.9775912343458948, 0.9856918600781291, 0.9862987405660498, 0.9770175651747988, 0.9778520464721582, 0.9781512659494478, 0.9875080020708764, 0.984098099287295, 0.9849954146772911, 0.7809659532660893, 0.7422826837075494, 0.7507287728082499, 0.7671760563977873, 0.7605455519964089, 0.7573331744633285, 0.7679600916906688, 0.747325999217636, 0.7792914648411364, 0.17111748920970027, 0.3776430589145463, 0.2148095429947724, 0.2812462563154454, 0.8986407239240541, 0.19204913894860254, 0.8747754320911039, 0.875000117318375, 0.868387248003844, 0.7632216912436319, 0.706558114179277, 0.6234648388250588, 0.13136984499800142, 0.7085088269387997, 0.6506806316873934, 0.6826924943191606, 0.6992691458062947, 0.6583057288686354, 0.734243198366002, 0.13115796893246556, 0.6705233511355073, 0.7082745516843774, 0.6388044637379255, 0.1341526369084951, 0.6743382872976676, 0.5567792737889925, 0.13081659118311728, 0.31827943748047594, 9.999999999998899e-05, 0.06633577084044773, 0.5390449000464439, 0.5270845928542385, 9.999999999998899e-05, 0.4392765556044851, 0.008076823072002082, 0.26222948519668543, 0.24804397985012738, 0.36024896744948254, 0.5288676387803491, 0.157319205348598, 0.17810397592288285, 0.6509838503096024, 0.6551795148357473, 0.6692466142047369, 0.6019556617371273, 0.06668243159341114, 0.26091536276258476, 0.22968957066875362, 0.30011996004245634, 0.09151287932329799, 0.3578498530294587, 0.2206967922068861, 0.3854711628213495, 0.20182060529747137, 0.17857461789159057, 0.19558219385245745, 0.3284205134415502, 0.006407430175517814, 0.36619250372402334, 0.2259926234100389, 0.08079187747567196, 0.3566449764797007, 0.08114697349173805, 0.7344845036158891, 0.7483427178164258, 0.7486489878661621, 0.7518594363355056, 0.7634733283067978, 0.802694999760851, 0.6843882425772356, 0.7299911756040789, 0.7593858556799229, 0.07580857596923452, 0.14444118890065638, 0.10268166408293322, 0.14555068634590862, 0.1133105093208967, 0.7033352848670488, 0.1039592203854578, 0.07995791523730145, 0.10458196920510487, 0.1700282082103276, 0.6464594007522839, 0.23788986441283433, 0.24848668452709644, 0.26787452178738946, 0.19298062414556083, 0.421872478808335, 0.19843099372711004, 0.26917347133106273, 0.5491013415157248, 0.33311292285246896, 0.47831967790630825, 0.2510770234307901, 0.24692705852935903, 0.48035384518917157, 0.23665669042404747, 0.42822797182165473, 0.30575513751038663, 0.1384240955857755, 0.21920609124034363, 0.2686337200810871, 0.3370099124725975, 0.27722345291883144, 0.2798287908940785, 0.15815476806470508, 0.3293521774471102, 0.31052351305580883, 0.21880804130783393, 0.23147323015166554, 0.21474406873959928, 0.20490956936190807, 0.23457103325372197, 0.2437305802702212, 0.2149709844811336, 0.2439850908753306, 0.23335761715769676, 0.22350210307888363, 0.18574197878039322, 0.17837020396905356, 0.2155230598069725, 0.19237625339917275, 0.19959724030473103, 0.17669365044360585, 0.21076136807788703, 0.20118337457794033, 0.9214437223791965, 0.1752419304252275, 0.14813261835915315, 0.9234731888523364, 0.1891957800520545, 0.20075856307887285, 0.14236009654782922, 0.16951293172035564, 0.9211706307592998, 0.8938069567687922, 0.21337860007900866, 0.8903324751288573, 0.8659545435144563, 0.8852123370256878, 0.15603433731549, 0.7809371264146462, 0.8691346964491866, 0.8944526734985341, 0.20381020220067825, 0.1898466526025595, 0.19237450905935372, 0.17981768391588937, 0.21853539690398427, 0.19684832418329457, 0.1848171428814328, 0.22912533053187922, 0.19210062702914676, 0.09359997277557464, 0.08913187308574833, 0.07349795134290049, 0.1072000129024635, 0.10987724557902478, 0.1309134338923733, 0.0948732229011211, 0.08903264488315288, 0.0935723001019283]}, "mutation_prompt": null}
{"id": "259aeaaf-4375-41a8-a8cc-dbb5b9089e2e", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Slightly reduced population for efficiency\n        self.w = 0.5  # Adjusted inertia weight for better balance between exploration and exploitation\n        self.cr = 0.9  # Higher crossover rate to encourage exploration\n        self.f1 = 0.5  # Increased mutation factor for stronger primary exploration\n        self.f2 = 0.6  # Adjusted secondary mutation factor for balance\n        self.q_prob = 0.1  # New quantum probability factor for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                if np.random.rand() < self.q_prob:\n                    quantum_shift = np.random.uniform(-1, 1, self.dim)\n                    mutant = global_best + quantum_shift * (x1 - x2)\n                else:\n                    if np.random.rand() < 0.5:\n                        mutant = x0 + self.f1 * (x1 - x2) + self.f1 * (x2 - x3)\n                    else:\n                        mutant = x0 + self.f2 * (global_best - personal_best[i]) + self.f2 * (x1 - x2)\n\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n\n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.w = 0.3 + 0.3 * (1 - evaluations / self.budget)  # Dynamic inertia adjustment\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n                f_val = func(population[i])\n                evaluations += 1\n\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n\n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n        return global_best", "name": "AdaptiveQuantumHybridSwarm", "description": "An Adaptive Quantum-Inspired Hybrid Swarm Algorithm enhancing diversity and convergence through quantum mechanics concepts and adaptive dynamic techniques.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75c77c35-a246-4a87-a69a-b2a131576f2e", "metadata": {"aucs": [0.8732496514529094, 0.8573013930713151, 0.8744986549559657, 0.8537495192369189, 0.8604165374218101, 0.8715142837348789, 0.8704099284618737, 0.8739727116974925, 0.866791729775093, 0.6147791287774991, 0.5226600881736632, 0.6008666291934257, 0.6011496292940641, 0.5712684505558844, 0.6359510051857422, 0.045908637116616746, 0.01791592251565577, 0.624806402963642, 0.1413067638663884, 0.11049529921804513, 0.14184049273655452, 0.1027592472363914, 0.07083301263806674, 0.12002114502220551, 0.12881546204892624, 0.12197346576387535, 0.14062731601841005, 0.10096466446710328, 0.05413792712396226, 0.09114897185600312, 0.11617455852670533, 0.10909181187858685, 0.1132573468606426, 0.09365470587791058, 0.10954479806391282, 0.06924766798411386, 0.9775912343458948, 0.9856918600781291, 0.9862987405660498, 0.9770175651747988, 0.9778520464721582, 0.9781512659494478, 0.9875080020708764, 0.984098099287295, 0.9849954146772911, 0.7809659532660893, 0.7422826837075494, 0.7507287728082499, 0.7671760563977873, 0.7605455519964089, 0.7573331744633285, 0.7679600916906688, 0.747325999217636, 0.7792914648411364, 0.17111748920970027, 0.3776430589145463, 0.2148095429947724, 0.2812462563154454, 0.8986407239240541, 0.19204913894860254, 0.8747754320911039, 0.875000117318375, 0.868387248003844, 0.7632216912436319, 0.706558114179277, 0.6234648388250588, 0.13136984499800142, 0.7085088269387997, 0.6506806316873934, 0.6826924943191606, 0.6992691458062947, 0.6583057288686354, 0.734243198366002, 0.13115796893246556, 0.6705233511355073, 0.7082745516843774, 0.6388044637379255, 0.1341526369084951, 0.6743382872976676, 0.5567792737889925, 0.13081659118311728, 0.31827943748047594, 9.999999999998899e-05, 0.06633577084044773, 0.5390449000464439, 0.5270845928542385, 9.999999999998899e-05, 0.4392765556044851, 0.008076823072002082, 0.26222948519668543, 0.24804397985012738, 0.36024896744948254, 0.5288676387803491, 0.157319205348598, 0.17810397592288285, 0.6509838503096024, 0.6551795148357473, 0.6692466142047369, 0.6019556617371273, 0.06668243159341114, 0.26091536276258476, 0.22968957066875362, 0.30011996004245634, 0.09151287932329799, 0.3578498530294587, 0.2206967922068861, 0.3854711628213495, 0.20182060529747137, 0.17857461789159057, 0.19558219385245745, 0.3284205134415502, 0.006407430175517814, 0.36619250372402334, 0.2259926234100389, 0.08079187747567196, 0.3566449764797007, 0.08114697349173805, 0.7344845036158891, 0.7483427178164258, 0.7486489878661621, 0.7518594363355056, 0.7634733283067978, 0.802694999760851, 0.6843882425772356, 0.7299911756040789, 0.7593858556799229, 0.07580857596923452, 0.14444118890065638, 0.10268166408293322, 0.14555068634590862, 0.1133105093208967, 0.7033352848670488, 0.1039592203854578, 0.07995791523730145, 0.10458196920510487, 0.1700282082103276, 0.6464594007522839, 0.23788986441283433, 0.24848668452709644, 0.26787452178738946, 0.19298062414556083, 0.421872478808335, 0.19843099372711004, 0.26917347133106273, 0.5491013415157248, 0.33311292285246896, 0.47831967790630825, 0.2510770234307901, 0.24692705852935903, 0.48035384518917157, 0.23665669042404747, 0.42822797182165473, 0.30575513751038663, 0.1384240955857755, 0.21920609124034363, 0.2686337200810871, 0.3370099124725975, 0.27722345291883144, 0.2798287908940785, 0.15815476806470508, 0.3293521774471102, 0.31052351305580883, 0.21880804130783393, 0.23147323015166554, 0.21474406873959928, 0.20490956936190807, 0.23457103325372197, 0.2437305802702212, 0.2149709844811336, 0.2439850908753306, 0.23335761715769676, 0.22350210307888363, 0.18574197878039322, 0.17837020396905356, 0.2155230598069725, 0.19237625339917275, 0.19959724030473103, 0.17669365044360585, 0.21076136807788703, 0.20118337457794033, 0.9214437223791965, 0.1752419304252275, 0.14813261835915315, 0.9234731888523364, 0.1891957800520545, 0.20075856307887285, 0.14236009654782922, 0.16951293172035564, 0.9211706307592998, 0.8938069567687922, 0.21337860007900866, 0.8903324751288573, 0.8659545435144563, 0.8852123370256878, 0.15603433731549, 0.7809371264146462, 0.8691346964491866, 0.8944526734985341, 0.20381020220067825, 0.1898466526025595, 0.19237450905935372, 0.17981768391588937, 0.21853539690398427, 0.19684832418329457, 0.1848171428814328, 0.22912533053187922, 0.19210062702914676, 0.09359997277557464, 0.08913187308574833, 0.07349795134290049, 0.1072000129024635, 0.10987724557902478, 0.1309134338923733, 0.0948732229011211, 0.08903264488315288, 0.0935723001019283]}, "mutation_prompt": null}
{"id": "5cbc40a0-f5f9-44d4-983e-ad700e173629", "solution": "import numpy as np\n\nclass QuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40\n        self.cr = 0.9\n        self.f = 0.8\n        self.q_prob = 0.15\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                if np.random.rand() < self.q_prob:\n                    quantum_shift = np.random.uniform(-0.5, 0.5, self.dim)\n                    mutant = global_best + quantum_shift * (x1 - x2)\n                else:\n                    mutant = x0 + self.f * (x1 - x2)\n\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n\n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities = (r1 * (personal_best[i] - population[i]) +\n                              r2 * (global_best - population[i]))\n                population[i] += velocities\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n                f_val = func(population[i])\n                evaluations += 1\n\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n\n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n        return global_best", "name": "QuantumDifferentialEvolution", "description": "A Quantum-Inspired Differential Evolution with Adaptive Velocity Strategy, leveraging enhanced crossover and mutation dynamics for improved convergence.", "configspace": "", "generation": 57, "fitness": 0.3064316683750174, "feedback": "The algorithm QuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.27.", "error": "", "parent_id": "75c77c35-a246-4a87-a69a-b2a131576f2e", "metadata": {"aucs": [0.944398103875706, 0.9265770203035153, 0.944804739990672, 0.9350399608560991, 0.9513909333020251, 0.9312435610496066, 0.9258703779807456, 0.9395596116525547, 0.9280516528659932, 0.6065180186629286, 0.741353585339519, 0.5914341552714457, 0.782574780660749, 0.6133773959742236, 0.7104255233736181, 0.7885828507147941, 0.7745494026954332, 0.7367117969961858, 0.11668038862811159, 0.11954710544539526, 0.0978788167747876, 0.11881440170396707, 0.11158298364776853, 0.07206846427518465, 0.06797865961047789, 0.08695119185323164, 0.07606128514727084, 0.10038469117668392, 0.0705510082630666, 0.06841439015855888, 0.10280518460844634, 0.09403474156988867, 0.08659797974707129, 0.05933606277546655, 0.09783875495582106, 0.0932584214826806, 0.9858868163987577, 0.9679944843326462, 0.9796041512516477, 0.978643695485457, 0.9921788224483262, 0.962490464281454, 0.9542322457350839, 0.975620310940092, 0.9753313052668577, 0.7270771070983568, 0.3912295618835072, 0.46309244166028074, 0.29231089132514176, 0.376948002505225, 0.6074323987509693, 0.3896816453539951, 0.6192651690571185, 0.4659514118553407, 0.1975744003663087, 0.16257061282434027, 0.1862638140481706, 0.28307595228844307, 0.19743673195448785, 0.34617286868867425, 0.22686827330868276, 0.15277898117347377, 0.17535439269799513, 0.11739775351164061, 0.13451915130423353, 0.13667241426604337, 0.1297131021683091, 0.27383410295689536, 0.16378041922471243, 0.7643631823065293, 0.16876701248838344, 0.4933192618513218, 0.15751728838815293, 0.48789003163589284, 0.1783708910925048, 0.1515541143489234, 0.12169294460483793, 0.18695642692060332, 0.2106730984167542, 0.2518178550361191, 0.21299600591491563, 0.030599890665225726, 0.05066385110898319, 0.07248705198319239, 0.06199580854768805, 0.12573288123013393, 0.06831042487651517, 0.04450244944219617, 0.02943956919909163, 0.08471310051188208, 0.07148050627670233, 0.05108715974635958, 0.13981422099253737, 0.09375937002258439, 0.08134192797190631, 0.10234510559221777, 0.1423510584443376, 0.15268235614933323, 0.11313156878918984, 0.20690881192453348, 0.06532256576623185, 0.3669018695567181, 0.11942230163736678, 0.08683065521713784, 0.10383308557085524, 0.17452777143813658, 0.10091702908694966, 0.13815437492915084, 0.19736524115952814, 0.06195112611895326, 0.15975507543453404, 0.18595704911204625, 0.28134615078093883, 0.1601565026876266, 0.21477759978963618, 0.36647880752923634, 0.12629102975742756, 0.571202234417705, 0.5595960203271164, 0.6781278464973226, 0.5602887241179383, 0.5806725670758468, 0.6072307690853018, 0.5573900408713193, 0.4618824237914636, 0.5842724081542523, 0.11924773636573249, 0.08321910872375593, 0.08095627377860692, 0.14732608227666733, 0.08620281931070617, 0.12616205168554406, 0.14688407963136285, 0.05934506593446298, 0.0814660969122275, 0.1791675589422992, 0.19365754689956804, 0.16354903485226135, 0.21157107369560157, 0.2923310041775117, 0.17813199415118053, 0.24756747518997613, 0.20658339343834187, 0.2581170797029123, 0.2599255227614603, 0.292432008658139, 0.33486161179223495, 0.28164418860281215, 0.2201216755416956, 0.4065042382609281, 0.3550461997150858, 0.3308593815437414, 0.2689204115888236, 0.23202443678744533, 0.2607236042789246, 0.17328283345766815, 0.2637340859035887, 0.3590243205961603, 0.1734412771135183, 0.15850920446942363, 0.21091674413289385, 0.23596417056118058, 0.28467490686676034, 0.24035758794285167, 0.2705773361770205, 0.20364570662785986, 0.24249925951177875, 0.26678919593549466, 0.22645564481218294, 0.24398183033200904, 0.20832725891962345, 0.18693495908040347, 0.18214395353007917, 0.1701487225021152, 0.17198090612173944, 0.16306695683427663, 0.1672152821088665, 0.1813188779433923, 0.1855213351516759, 0.16345329114901308, 0.9524002384534841, 0.1269914791919602, 0.1889564604211772, 0.9400189090228047, 0.20132802272612071, 0.20074466833666005, 0.142935285333329, 0.16979200917975434, 0.1149865888984275, 0.8886887093246162, 0.21340538168892642, 0.21245539305607586, 0.6352106659729259, 0.2132845819952498, 0.15495542386814598, 0.6116307202547315, 0.21209400891099528, 0.2124642918395212, 0.19781869886094705, 0.23806732844020972, 0.19419324054100962, 0.22418919968254136, 0.20616129706882402, 0.1924310114852904, 0.2193648390212054, 0.21702890549126042, 0.21403114272570944, 0.10971700292950648, 0.08601063458695002, 0.0649084842494767, 0.0973241126897999, 0.09664634785162796, 0.1011463473785359, 0.09946753660729557, 0.10977818402278916, 0.10795041772161929]}, "mutation_prompt": null}
{"id": "4adcbfe8-075e-40a2-aec9-8669cee60c74", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Slightly reduced population for efficiency\n        self.w = 0.5  # Adjusted inertia weight for better balance between exploration and exploitation\n        self.cr = 0.9  # Higher crossover rate to encourage exploration\n        self.f1 = 0.5  # Increased mutation factor for stronger primary exploration\n        self.f2 = 0.6  # Adjusted secondary mutation factor for balance\n        self.q_prob = 0.1  # New quantum probability factor for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                if np.random.rand() < self.q_prob:\n                    quantum_shift = np.random.uniform(-1, 1, self.dim)\n                    mutant = global_best + quantum_shift * (x1 - x2)\n                else:\n                    if np.random.rand() < 0.5:\n                        mutant = x0 + self.f1 * (x1 - x2) + self.f1 * (x2 - x3)\n                    else:\n                        mutant = x0 + self.f2 * (global_best - personal_best[i]) + self.f2 * (x1 - x2)\n\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n\n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.w = 0.3 + 0.3 * (1 - evaluations / self.budget)  # Dynamic inertia adjustment\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n                f_val = func(population[i])\n                evaluations += 1\n\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n\n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n        return global_best", "name": "AdaptiveQuantumHybridSwarm", "description": "An Adaptive Quantum-Inspired Hybrid Swarm Algorithm enhancing diversity and convergence through quantum mechanics concepts and adaptive dynamic techniques.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75c77c35-a246-4a87-a69a-b2a131576f2e", "metadata": {"aucs": [0.8732496514529094, 0.8573013930713151, 0.8744986549559657, 0.8537495192369189, 0.8604165374218101, 0.8715142837348789, 0.8704099284618737, 0.8739727116974925, 0.866791729775093, 0.6147791287774991, 0.5226600881736632, 0.6008666291934257, 0.6011496292940641, 0.5712684505558844, 0.6359510051857422, 0.045908637116616746, 0.01791592251565577, 0.624806402963642, 0.1413067638663884, 0.11049529921804513, 0.14184049273655452, 0.1027592472363914, 0.07083301263806674, 0.12002114502220551, 0.12881546204892624, 0.12197346576387535, 0.14062731601841005, 0.10096466446710328, 0.05413792712396226, 0.09114897185600312, 0.11617455852670533, 0.10909181187858685, 0.1132573468606426, 0.09365470587791058, 0.10954479806391282, 0.06924766798411386, 0.9775912343458948, 0.9856918600781291, 0.9862987405660498, 0.9770175651747988, 0.9778520464721582, 0.9781512659494478, 0.9875080020708764, 0.984098099287295, 0.9849954146772911, 0.7809659532660893, 0.7422826837075494, 0.7507287728082499, 0.7671760563977873, 0.7605455519964089, 0.7573331744633285, 0.7679600916906688, 0.747325999217636, 0.7792914648411364, 0.17111748920970027, 0.3776430589145463, 0.2148095429947724, 0.2812462563154454, 0.8986407239240541, 0.19204913894860254, 0.8747754320911039, 0.875000117318375, 0.868387248003844, 0.7632216912436319, 0.706558114179277, 0.6234648388250588, 0.13136984499800142, 0.7085088269387997, 0.6506806316873934, 0.6826924943191606, 0.6992691458062947, 0.6583057288686354, 0.734243198366002, 0.13115796893246556, 0.6705233511355073, 0.7082745516843774, 0.6388044637379255, 0.1341526369084951, 0.6743382872976676, 0.5567792737889925, 0.13081659118311728, 0.31827943748047594, 9.999999999998899e-05, 0.06633577084044773, 0.5390449000464439, 0.5270845928542385, 9.999999999998899e-05, 0.4392765556044851, 0.008076823072002082, 0.26222948519668543, 0.24804397985012738, 0.36024896744948254, 0.5288676387803491, 0.157319205348598, 0.17810397592288285, 0.6509838503096024, 0.6551795148357473, 0.6692466142047369, 0.6019556617371273, 0.06668243159341114, 0.26091536276258476, 0.22968957066875362, 0.30011996004245634, 0.09151287932329799, 0.3578498530294587, 0.2206967922068861, 0.3854711628213495, 0.20182060529747137, 0.17857461789159057, 0.19558219385245745, 0.3284205134415502, 0.006407430175517814, 0.36619250372402334, 0.2259926234100389, 0.08079187747567196, 0.3566449764797007, 0.08114697349173805, 0.7344845036158891, 0.7483427178164258, 0.7486489878661621, 0.7518594363355056, 0.7634733283067978, 0.802694999760851, 0.6843882425772356, 0.7299911756040789, 0.7593858556799229, 0.07580857596923452, 0.14444118890065638, 0.10268166408293322, 0.14555068634590862, 0.1133105093208967, 0.7033352848670488, 0.1039592203854578, 0.07995791523730145, 0.10458196920510487, 0.1700282082103276, 0.6464594007522839, 0.23788986441283433, 0.24848668452709644, 0.26787452178738946, 0.19298062414556083, 0.421872478808335, 0.19843099372711004, 0.26917347133106273, 0.5491013415157248, 0.33311292285246896, 0.47831967790630825, 0.2510770234307901, 0.24692705852935903, 0.48035384518917157, 0.23665669042404747, 0.42822797182165473, 0.30575513751038663, 0.1384240955857755, 0.21920609124034363, 0.2686337200810871, 0.3370099124725975, 0.27722345291883144, 0.2798287908940785, 0.15815476806470508, 0.3293521774471102, 0.31052351305580883, 0.21880804130783393, 0.23147323015166554, 0.21474406873959928, 0.20490956936190807, 0.23457103325372197, 0.2437305802702212, 0.2149709844811336, 0.2439850908753306, 0.23335761715769676, 0.22350210307888363, 0.18574197878039322, 0.17837020396905356, 0.2155230598069725, 0.19237625339917275, 0.19959724030473103, 0.17669365044360585, 0.21076136807788703, 0.20118337457794033, 0.9214437223791965, 0.1752419304252275, 0.14813261835915315, 0.9234731888523364, 0.1891957800520545, 0.20075856307887285, 0.14236009654782922, 0.16951293172035564, 0.9211706307592998, 0.8938069567687922, 0.21337860007900866, 0.8903324751288573, 0.8659545435144563, 0.8852123370256878, 0.15603433731549, 0.7809371264146462, 0.8691346964491866, 0.8944526734985341, 0.20381020220067825, 0.1898466526025595, 0.19237450905935372, 0.17981768391588937, 0.21853539690398427, 0.19684832418329457, 0.1848171428814328, 0.22912533053187922, 0.19210062702914676, 0.09359997277557464, 0.08913187308574833, 0.07349795134290049, 0.1072000129024635, 0.10987724557902478, 0.1309134338923733, 0.0948732229011211, 0.08903264488315288, 0.0935723001019283]}, "mutation_prompt": null}
{"id": "2f4a165d-9985-4941-ae54-3a701e8988fd", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Slightly reduced population for efficiency\n        self.w = 0.5  # Adjusted inertia weight for better balance between exploration and exploitation\n        self.cr = 0.9  # Higher crossover rate to encourage exploration\n        self.f1 = 0.5  # Increased mutation factor for stronger primary exploration\n        self.f2 = 0.6  # Adjusted secondary mutation factor for balance\n        self.q_prob = 0.1  # New quantum probability factor for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                if np.random.rand() < self.q_prob:\n                    quantum_shift = np.random.uniform(-1, 1, self.dim)\n                    mutant = global_best + quantum_shift * (x1 - x2)\n                else:\n                    if np.random.rand() < 0.5:\n                        mutant = x0 + self.f1 * (x1 - x2) + self.f1 * (x2 - x3)\n                    else:\n                        mutant = x0 + self.f2 * (global_best - personal_best[i]) + self.f2 * (x1 - x2)\n\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n\n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.w = 0.3 + 0.3 * (1 - evaluations / self.budget)  # Dynamic inertia adjustment\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n                f_val = func(population[i])\n                evaluations += 1\n\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n\n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n        return global_best", "name": "AdaptiveQuantumHybridSwarm", "description": "An Adaptive Quantum-Inspired Hybrid Swarm Algorithm enhancing diversity and convergence through quantum mechanics concepts and adaptive dynamic techniques.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75c77c35-a246-4a87-a69a-b2a131576f2e", "metadata": {"aucs": [0.8732496514529094, 0.8573013930713151, 0.8744986549559657, 0.8537495192369189, 0.8604165374218101, 0.8715142837348789, 0.8704099284618737, 0.8739727116974925, 0.866791729775093, 0.6147791287774991, 0.5226600881736632, 0.6008666291934257, 0.6011496292940641, 0.5712684505558844, 0.6359510051857422, 0.045908637116616746, 0.01791592251565577, 0.624806402963642, 0.1413067638663884, 0.11049529921804513, 0.14184049273655452, 0.1027592472363914, 0.07083301263806674, 0.12002114502220551, 0.12881546204892624, 0.12197346576387535, 0.14062731601841005, 0.10096466446710328, 0.05413792712396226, 0.09114897185600312, 0.11617455852670533, 0.10909181187858685, 0.1132573468606426, 0.09365470587791058, 0.10954479806391282, 0.06924766798411386, 0.9775912343458948, 0.9856918600781291, 0.9862987405660498, 0.9770175651747988, 0.9778520464721582, 0.9781512659494478, 0.9875080020708764, 0.984098099287295, 0.9849954146772911, 0.7809659532660893, 0.7422826837075494, 0.7507287728082499, 0.7671760563977873, 0.7605455519964089, 0.7573331744633285, 0.7679600916906688, 0.747325999217636, 0.7792914648411364, 0.17111748920970027, 0.3776430589145463, 0.2148095429947724, 0.2812462563154454, 0.8986407239240541, 0.19204913894860254, 0.8747754320911039, 0.875000117318375, 0.868387248003844, 0.7632216912436319, 0.706558114179277, 0.6234648388250588, 0.13136984499800142, 0.7085088269387997, 0.6506806316873934, 0.6826924943191606, 0.6992691458062947, 0.6583057288686354, 0.734243198366002, 0.13115796893246556, 0.6705233511355073, 0.7082745516843774, 0.6388044637379255, 0.1341526369084951, 0.6743382872976676, 0.5567792737889925, 0.13081659118311728, 0.31827943748047594, 9.999999999998899e-05, 0.06633577084044773, 0.5390449000464439, 0.5270845928542385, 9.999999999998899e-05, 0.4392765556044851, 0.008076823072002082, 0.26222948519668543, 0.24804397985012738, 0.36024896744948254, 0.5288676387803491, 0.157319205348598, 0.17810397592288285, 0.6509838503096024, 0.6551795148357473, 0.6692466142047369, 0.6019556617371273, 0.06668243159341114, 0.26091536276258476, 0.22968957066875362, 0.30011996004245634, 0.09151287932329799, 0.3578498530294587, 0.2206967922068861, 0.3854711628213495, 0.20182060529747137, 0.17857461789159057, 0.19558219385245745, 0.3284205134415502, 0.006407430175517814, 0.36619250372402334, 0.2259926234100389, 0.08079187747567196, 0.3566449764797007, 0.08114697349173805, 0.7344845036158891, 0.7483427178164258, 0.7486489878661621, 0.7518594363355056, 0.7634733283067978, 0.802694999760851, 0.6843882425772356, 0.7299911756040789, 0.7593858556799229, 0.07580857596923452, 0.14444118890065638, 0.10268166408293322, 0.14555068634590862, 0.1133105093208967, 0.7033352848670488, 0.1039592203854578, 0.07995791523730145, 0.10458196920510487, 0.1700282082103276, 0.6464594007522839, 0.23788986441283433, 0.24848668452709644, 0.26787452178738946, 0.19298062414556083, 0.421872478808335, 0.19843099372711004, 0.26917347133106273, 0.5491013415157248, 0.33311292285246896, 0.47831967790630825, 0.2510770234307901, 0.24692705852935903, 0.48035384518917157, 0.23665669042404747, 0.42822797182165473, 0.30575513751038663, 0.1384240955857755, 0.21920609124034363, 0.2686337200810871, 0.3370099124725975, 0.27722345291883144, 0.2798287908940785, 0.15815476806470508, 0.3293521774471102, 0.31052351305580883, 0.21880804130783393, 0.23147323015166554, 0.21474406873959928, 0.20490956936190807, 0.23457103325372197, 0.2437305802702212, 0.2149709844811336, 0.2439850908753306, 0.23335761715769676, 0.22350210307888363, 0.18574197878039322, 0.17837020396905356, 0.2155230598069725, 0.19237625339917275, 0.19959724030473103, 0.17669365044360585, 0.21076136807788703, 0.20118337457794033, 0.9214437223791965, 0.1752419304252275, 0.14813261835915315, 0.9234731888523364, 0.1891957800520545, 0.20075856307887285, 0.14236009654782922, 0.16951293172035564, 0.9211706307592998, 0.8938069567687922, 0.21337860007900866, 0.8903324751288573, 0.8659545435144563, 0.8852123370256878, 0.15603433731549, 0.7809371264146462, 0.8691346964491866, 0.8944526734985341, 0.20381020220067825, 0.1898466526025595, 0.19237450905935372, 0.17981768391588937, 0.21853539690398427, 0.19684832418329457, 0.1848171428814328, 0.22912533053187922, 0.19210062702914676, 0.09359997277557464, 0.08913187308574833, 0.07349795134290049, 0.1072000129024635, 0.10987724557902478, 0.1309134338923733, 0.0948732229011211, 0.08903264488315288, 0.0935723001019283]}, "mutation_prompt": null}
{"id": "4e621c63-5d26-4f15-8ed6-f723a25de4fa", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Slightly reduced population for efficiency\n        self.w = 0.5  # Adjusted inertia weight for better balance between exploration and exploitation\n        self.cr = 0.9  # Higher crossover rate to encourage exploration\n        self.f1 = 0.5  # Increased mutation factor for stronger primary exploration\n        self.f2 = 0.6  # Adjusted secondary mutation factor for balance\n        self.q_prob = 0.1  # New quantum probability factor for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                if np.random.rand() < self.q_prob:\n                    quantum_shift = np.random.uniform(-1, 1, self.dim)\n                    mutant = global_best + quantum_shift * (x1 - x2)\n                else:\n                    if np.random.rand() < 0.5:\n                        mutant = x0 + self.f1 * (x1 - x2) + self.f1 * (x2 - x3)\n                    else:\n                        mutant = x0 + self.f2 * (global_best - personal_best[i]) + self.f2 * (x1 - x2)\n\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n\n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.w = 0.3 + 0.3 * (1 - evaluations / self.budget)  # Dynamic inertia adjustment\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n                f_val = func(population[i])\n                evaluations += 1\n\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n\n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n        return global_best", "name": "AdaptiveQuantumHybridSwarm", "description": "An Adaptive Quantum-Inspired Hybrid Swarm Algorithm enhancing diversity and convergence through quantum mechanics concepts and adaptive dynamic techniques.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75c77c35-a246-4a87-a69a-b2a131576f2e", "metadata": {"aucs": [0.8732496514529094, 0.8573013930713151, 0.8744986549559657, 0.8537495192369189, 0.8604165374218101, 0.8715142837348789, 0.8704099284618737, 0.8739727116974925, 0.866791729775093, 0.6147791287774991, 0.5226600881736632, 0.6008666291934257, 0.6011496292940641, 0.5712684505558844, 0.6359510051857422, 0.045908637116616746, 0.01791592251565577, 0.624806402963642, 0.1413067638663884, 0.11049529921804513, 0.14184049273655452, 0.1027592472363914, 0.07083301263806674, 0.12002114502220551, 0.12881546204892624, 0.12197346576387535, 0.14062731601841005, 0.10096466446710328, 0.05413792712396226, 0.09114897185600312, 0.11617455852670533, 0.10909181187858685, 0.1132573468606426, 0.09365470587791058, 0.10954479806391282, 0.06924766798411386, 0.9775912343458948, 0.9856918600781291, 0.9862987405660498, 0.9770175651747988, 0.9778520464721582, 0.9781512659494478, 0.9875080020708764, 0.984098099287295, 0.9849954146772911, 0.7809659532660893, 0.7422826837075494, 0.7507287728082499, 0.7671760563977873, 0.7605455519964089, 0.7573331744633285, 0.7679600916906688, 0.747325999217636, 0.7792914648411364, 0.17111748920970027, 0.3776430589145463, 0.2148095429947724, 0.2812462563154454, 0.8986407239240541, 0.19204913894860254, 0.8747754320911039, 0.875000117318375, 0.868387248003844, 0.7632216912436319, 0.706558114179277, 0.6234648388250588, 0.13136984499800142, 0.7085088269387997, 0.6506806316873934, 0.6826924943191606, 0.6992691458062947, 0.6583057288686354, 0.734243198366002, 0.13115796893246556, 0.6705233511355073, 0.7082745516843774, 0.6388044637379255, 0.1341526369084951, 0.6743382872976676, 0.5567792737889925, 0.13081659118311728, 0.31827943748047594, 9.999999999998899e-05, 0.06633577084044773, 0.5390449000464439, 0.5270845928542385, 9.999999999998899e-05, 0.4392765556044851, 0.008076823072002082, 0.26222948519668543, 0.24804397985012738, 0.36024896744948254, 0.5288676387803491, 0.157319205348598, 0.17810397592288285, 0.6509838503096024, 0.6551795148357473, 0.6692466142047369, 0.6019556617371273, 0.06668243159341114, 0.26091536276258476, 0.22968957066875362, 0.30011996004245634, 0.09151287932329799, 0.3578498530294587, 0.2206967922068861, 0.3854711628213495, 0.20182060529747137, 0.17857461789159057, 0.19558219385245745, 0.3284205134415502, 0.006407430175517814, 0.36619250372402334, 0.2259926234100389, 0.08079187747567196, 0.3566449764797007, 0.08114697349173805, 0.7344845036158891, 0.7483427178164258, 0.7486489878661621, 0.7518594363355056, 0.7634733283067978, 0.802694999760851, 0.6843882425772356, 0.7299911756040789, 0.7593858556799229, 0.07580857596923452, 0.14444118890065638, 0.10268166408293322, 0.14555068634590862, 0.1133105093208967, 0.7033352848670488, 0.1039592203854578, 0.07995791523730145, 0.10458196920510487, 0.1700282082103276, 0.6464594007522839, 0.23788986441283433, 0.24848668452709644, 0.26787452178738946, 0.19298062414556083, 0.421872478808335, 0.19843099372711004, 0.26917347133106273, 0.5491013415157248, 0.33311292285246896, 0.47831967790630825, 0.2510770234307901, 0.24692705852935903, 0.48035384518917157, 0.23665669042404747, 0.42822797182165473, 0.30575513751038663, 0.1384240955857755, 0.21920609124034363, 0.2686337200810871, 0.3370099124725975, 0.27722345291883144, 0.2798287908940785, 0.15815476806470508, 0.3293521774471102, 0.31052351305580883, 0.21880804130783393, 0.23147323015166554, 0.21474406873959928, 0.20490956936190807, 0.23457103325372197, 0.2437305802702212, 0.2149709844811336, 0.2439850908753306, 0.23335761715769676, 0.22350210307888363, 0.18574197878039322, 0.17837020396905356, 0.2155230598069725, 0.19237625339917275, 0.19959724030473103, 0.17669365044360585, 0.21076136807788703, 0.20118337457794033, 0.9214437223791965, 0.1752419304252275, 0.14813261835915315, 0.9234731888523364, 0.1891957800520545, 0.20075856307887285, 0.14236009654782922, 0.16951293172035564, 0.9211706307592998, 0.8938069567687922, 0.21337860007900866, 0.8903324751288573, 0.8659545435144563, 0.8852123370256878, 0.15603433731549, 0.7809371264146462, 0.8691346964491866, 0.8944526734985341, 0.20381020220067825, 0.1898466526025595, 0.19237450905935372, 0.17981768391588937, 0.21853539690398427, 0.19684832418329457, 0.1848171428814328, 0.22912533053187922, 0.19210062702914676, 0.09359997277557464, 0.08913187308574833, 0.07349795134290049, 0.1072000129024635, 0.10987724557902478, 0.1309134338923733, 0.0948732229011211, 0.08903264488315288, 0.0935723001019283]}, "mutation_prompt": null}
{"id": "3eb724c4-7cb3-4cbc-a1ea-ce35e83ddf55", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Slightly reduced population for efficiency\n        self.w = 0.5  # Adjusted inertia weight for better balance between exploration and exploitation\n        self.cr = 0.9  # Higher crossover rate to encourage exploration\n        self.f1 = 0.5  # Increased mutation factor for stronger primary exploration\n        self.f2 = 0.6  # Adjusted secondary mutation factor for balance\n        self.q_prob = 0.1  # New quantum probability factor for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                if np.random.rand() < self.q_prob:\n                    quantum_shift = np.random.uniform(-1, 1, self.dim)\n                    mutant = global_best + quantum_shift * (x1 - x2)\n                else:\n                    if np.random.rand() < 0.5:\n                        mutant = x0 + self.f1 * (x1 - x2) + self.f1 * (x2 - x3)\n                    else:\n                        mutant = x0 + self.f2 * (global_best - personal_best[i]) + self.f2 * (x1 - x2)\n\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n\n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.w = 0.3 + 0.3 * (1 - evaluations / self.budget)  # Dynamic inertia adjustment\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n                f_val = func(population[i])\n                evaluations += 1\n\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n\n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n        return global_best", "name": "AdaptiveQuantumHybridSwarm", "description": "An Adaptive Quantum-Inspired Hybrid Swarm Algorithm enhancing diversity and convergence through quantum mechanics concepts and adaptive dynamic techniques.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75c77c35-a246-4a87-a69a-b2a131576f2e", "metadata": {"aucs": [0.8732496514529094, 0.8573013930713151, 0.8744986549559657, 0.8537495192369189, 0.8604165374218101, 0.8715142837348789, 0.8704099284618737, 0.8739727116974925, 0.866791729775093, 0.6147791287774991, 0.5226600881736632, 0.6008666291934257, 0.6011496292940641, 0.5712684505558844, 0.6359510051857422, 0.045908637116616746, 0.01791592251565577, 0.624806402963642, 0.1413067638663884, 0.11049529921804513, 0.14184049273655452, 0.1027592472363914, 0.07083301263806674, 0.12002114502220551, 0.12881546204892624, 0.12197346576387535, 0.14062731601841005, 0.10096466446710328, 0.05413792712396226, 0.09114897185600312, 0.11617455852670533, 0.10909181187858685, 0.1132573468606426, 0.09365470587791058, 0.10954479806391282, 0.06924766798411386, 0.9775912343458948, 0.9856918600781291, 0.9862987405660498, 0.9770175651747988, 0.9778520464721582, 0.9781512659494478, 0.9875080020708764, 0.984098099287295, 0.9849954146772911, 0.7809659532660893, 0.7422826837075494, 0.7507287728082499, 0.7671760563977873, 0.7605455519964089, 0.7573331744633285, 0.7679600916906688, 0.747325999217636, 0.7792914648411364, 0.17111748920970027, 0.3776430589145463, 0.2148095429947724, 0.2812462563154454, 0.8986407239240541, 0.19204913894860254, 0.8747754320911039, 0.875000117318375, 0.868387248003844, 0.7632216912436319, 0.706558114179277, 0.6234648388250588, 0.13136984499800142, 0.7085088269387997, 0.6506806316873934, 0.6826924943191606, 0.6992691458062947, 0.6583057288686354, 0.734243198366002, 0.13115796893246556, 0.6705233511355073, 0.7082745516843774, 0.6388044637379255, 0.1341526369084951, 0.6743382872976676, 0.5567792737889925, 0.13081659118311728, 0.31827943748047594, 9.999999999998899e-05, 0.06633577084044773, 0.5390449000464439, 0.5270845928542385, 9.999999999998899e-05, 0.4392765556044851, 0.008076823072002082, 0.26222948519668543, 0.24804397985012738, 0.36024896744948254, 0.5288676387803491, 0.157319205348598, 0.17810397592288285, 0.6509838503096024, 0.6551795148357473, 0.6692466142047369, 0.6019556617371273, 0.06668243159341114, 0.26091536276258476, 0.22968957066875362, 0.30011996004245634, 0.09151287932329799, 0.3578498530294587, 0.2206967922068861, 0.3854711628213495, 0.20182060529747137, 0.17857461789159057, 0.19558219385245745, 0.3284205134415502, 0.006407430175517814, 0.36619250372402334, 0.2259926234100389, 0.08079187747567196, 0.3566449764797007, 0.08114697349173805, 0.7344845036158891, 0.7483427178164258, 0.7486489878661621, 0.7518594363355056, 0.7634733283067978, 0.802694999760851, 0.6843882425772356, 0.7299911756040789, 0.7593858556799229, 0.07580857596923452, 0.14444118890065638, 0.10268166408293322, 0.14555068634590862, 0.1133105093208967, 0.7033352848670488, 0.1039592203854578, 0.07995791523730145, 0.10458196920510487, 0.1700282082103276, 0.6464594007522839, 0.23788986441283433, 0.24848668452709644, 0.26787452178738946, 0.19298062414556083, 0.421872478808335, 0.19843099372711004, 0.26917347133106273, 0.5491013415157248, 0.33311292285246896, 0.47831967790630825, 0.2510770234307901, 0.24692705852935903, 0.48035384518917157, 0.23665669042404747, 0.42822797182165473, 0.30575513751038663, 0.1384240955857755, 0.21920609124034363, 0.2686337200810871, 0.3370099124725975, 0.27722345291883144, 0.2798287908940785, 0.15815476806470508, 0.3293521774471102, 0.31052351305580883, 0.21880804130783393, 0.23147323015166554, 0.21474406873959928, 0.20490956936190807, 0.23457103325372197, 0.2437305802702212, 0.2149709844811336, 0.2439850908753306, 0.23335761715769676, 0.22350210307888363, 0.18574197878039322, 0.17837020396905356, 0.2155230598069725, 0.19237625339917275, 0.19959724030473103, 0.17669365044360585, 0.21076136807788703, 0.20118337457794033, 0.9214437223791965, 0.1752419304252275, 0.14813261835915315, 0.9234731888523364, 0.1891957800520545, 0.20075856307887285, 0.14236009654782922, 0.16951293172035564, 0.9211706307592998, 0.8938069567687922, 0.21337860007900866, 0.8903324751288573, 0.8659545435144563, 0.8852123370256878, 0.15603433731549, 0.7809371264146462, 0.8691346964491866, 0.8944526734985341, 0.20381020220067825, 0.1898466526025595, 0.19237450905935372, 0.17981768391588937, 0.21853539690398427, 0.19684832418329457, 0.1848171428814328, 0.22912533053187922, 0.19210062702914676, 0.09359997277557464, 0.08913187308574833, 0.07349795134290049, 0.1072000129024635, 0.10987724557902478, 0.1309134338923733, 0.0948732229011211, 0.08903264488315288, 0.0935723001019283]}, "mutation_prompt": null}
{"id": "87dc07ee-58aa-4645-9f11-b1475cd7a77b", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Slightly reduced population for efficiency\n        self.w = 0.5  # Adjusted inertia weight for better balance between exploration and exploitation\n        self.cr = 0.9  # Higher crossover rate to encourage exploration\n        self.f1 = 0.5  # Increased mutation factor for stronger primary exploration\n        self.f2 = 0.6  # Adjusted secondary mutation factor for balance\n        self.q_prob = 0.1  # New quantum probability factor for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                if np.random.rand() < self.q_prob:\n                    quantum_shift = np.random.uniform(-1, 1, self.dim)\n                    mutant = global_best + quantum_shift * (x1 - x2)\n                else:\n                    if np.random.rand() < 0.5:\n                        mutant = x0 + self.f1 * (x1 - x2) + self.f1 * (x2 - x3)\n                    else:\n                        mutant = x0 + self.f2 * (global_best - personal_best[i]) + self.f2 * (x1 - x2)\n\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n\n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.w = 0.3 + 0.3 * (1 - evaluations / self.budget)  # Dynamic inertia adjustment\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n                f_val = func(population[i])\n                evaluations += 1\n\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n\n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n        return global_best", "name": "AdaptiveQuantumHybridSwarm", "description": "An Adaptive Quantum-Inspired Hybrid Swarm Algorithm enhancing diversity and convergence through quantum mechanics concepts and adaptive dynamic techniques.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75c77c35-a246-4a87-a69a-b2a131576f2e", "metadata": {"aucs": [0.8732496514529094, 0.8573013930713151, 0.8744986549559657, 0.8537495192369189, 0.8604165374218101, 0.8715142837348789, 0.8704099284618737, 0.8739727116974925, 0.866791729775093, 0.6147791287774991, 0.5226600881736632, 0.6008666291934257, 0.6011496292940641, 0.5712684505558844, 0.6359510051857422, 0.045908637116616746, 0.01791592251565577, 0.624806402963642, 0.1413067638663884, 0.11049529921804513, 0.14184049273655452, 0.1027592472363914, 0.07083301263806674, 0.12002114502220551, 0.12881546204892624, 0.12197346576387535, 0.14062731601841005, 0.10096466446710328, 0.05413792712396226, 0.09114897185600312, 0.11617455852670533, 0.10909181187858685, 0.1132573468606426, 0.09365470587791058, 0.10954479806391282, 0.06924766798411386, 0.9775912343458948, 0.9856918600781291, 0.9862987405660498, 0.9770175651747988, 0.9778520464721582, 0.9781512659494478, 0.9875080020708764, 0.984098099287295, 0.9849954146772911, 0.7809659532660893, 0.7422826837075494, 0.7507287728082499, 0.7671760563977873, 0.7605455519964089, 0.7573331744633285, 0.7679600916906688, 0.747325999217636, 0.7792914648411364, 0.17111748920970027, 0.3776430589145463, 0.2148095429947724, 0.2812462563154454, 0.8986407239240541, 0.19204913894860254, 0.8747754320911039, 0.875000117318375, 0.868387248003844, 0.7632216912436319, 0.706558114179277, 0.6234648388250588, 0.13136984499800142, 0.7085088269387997, 0.6506806316873934, 0.6826924943191606, 0.6992691458062947, 0.6583057288686354, 0.734243198366002, 0.13115796893246556, 0.6705233511355073, 0.7082745516843774, 0.6388044637379255, 0.1341526369084951, 0.6743382872976676, 0.5567792737889925, 0.13081659118311728, 0.31827943748047594, 9.999999999998899e-05, 0.06633577084044773, 0.5390449000464439, 0.5270845928542385, 9.999999999998899e-05, 0.4392765556044851, 0.008076823072002082, 0.26222948519668543, 0.24804397985012738, 0.36024896744948254, 0.5288676387803491, 0.157319205348598, 0.17810397592288285, 0.6509838503096024, 0.6551795148357473, 0.6692466142047369, 0.6019556617371273, 0.06668243159341114, 0.26091536276258476, 0.22968957066875362, 0.30011996004245634, 0.09151287932329799, 0.3578498530294587, 0.2206967922068861, 0.3854711628213495, 0.20182060529747137, 0.17857461789159057, 0.19558219385245745, 0.3284205134415502, 0.006407430175517814, 0.36619250372402334, 0.2259926234100389, 0.08079187747567196, 0.3566449764797007, 0.08114697349173805, 0.7344845036158891, 0.7483427178164258, 0.7486489878661621, 0.7518594363355056, 0.7634733283067978, 0.802694999760851, 0.6843882425772356, 0.7299911756040789, 0.7593858556799229, 0.07580857596923452, 0.14444118890065638, 0.10268166408293322, 0.14555068634590862, 0.1133105093208967, 0.7033352848670488, 0.1039592203854578, 0.07995791523730145, 0.10458196920510487, 0.1700282082103276, 0.6464594007522839, 0.23788986441283433, 0.24848668452709644, 0.26787452178738946, 0.19298062414556083, 0.421872478808335, 0.19843099372711004, 0.26917347133106273, 0.5491013415157248, 0.33311292285246896, 0.47831967790630825, 0.2510770234307901, 0.24692705852935903, 0.48035384518917157, 0.23665669042404747, 0.42822797182165473, 0.30575513751038663, 0.1384240955857755, 0.21920609124034363, 0.2686337200810871, 0.3370099124725975, 0.27722345291883144, 0.2798287908940785, 0.15815476806470508, 0.3293521774471102, 0.31052351305580883, 0.21880804130783393, 0.23147323015166554, 0.21474406873959928, 0.20490956936190807, 0.23457103325372197, 0.2437305802702212, 0.2149709844811336, 0.2439850908753306, 0.23335761715769676, 0.22350210307888363, 0.18574197878039322, 0.17837020396905356, 0.2155230598069725, 0.19237625339917275, 0.19959724030473103, 0.17669365044360585, 0.21076136807788703, 0.20118337457794033, 0.9214437223791965, 0.1752419304252275, 0.14813261835915315, 0.9234731888523364, 0.1891957800520545, 0.20075856307887285, 0.14236009654782922, 0.16951293172035564, 0.9211706307592998, 0.8938069567687922, 0.21337860007900866, 0.8903324751288573, 0.8659545435144563, 0.8852123370256878, 0.15603433731549, 0.7809371264146462, 0.8691346964491866, 0.8944526734985341, 0.20381020220067825, 0.1898466526025595, 0.19237450905935372, 0.17981768391588937, 0.21853539690398427, 0.19684832418329457, 0.1848171428814328, 0.22912533053187922, 0.19210062702914676, 0.09359997277557464, 0.08913187308574833, 0.07349795134290049, 0.1072000129024635, 0.10987724557902478, 0.1309134338923733, 0.0948732229011211, 0.08903264488315288, 0.0935723001019283]}, "mutation_prompt": null}
{"id": "b20900af-8c3c-4469-86c6-92e4bb6de16d", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Slightly reduced population for efficiency\n        self.w = 0.5  # Adjusted inertia weight for better balance between exploration and exploitation\n        self.cr = 0.9  # Higher crossover rate to encourage exploration\n        self.f1 = 0.5  # Increased mutation factor for stronger primary exploration\n        self.f2 = 0.6  # Adjusted secondary mutation factor for balance\n        self.q_prob = 0.1  # New quantum probability factor for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                if np.random.rand() < self.q_prob:\n                    quantum_shift = np.random.uniform(-1, 1, self.dim)\n                    mutant = global_best + quantum_shift * (x1 - x2)\n                else:\n                    if np.random.rand() < 0.5:\n                        mutant = x0 + self.f1 * (x1 - x2) + self.f1 * (x2 - x3)\n                    else:\n                        mutant = x0 + self.f2 * (global_best - personal_best[i]) + self.f2 * (x1 - x2)\n\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n\n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.w = 0.3 + 0.3 * (1 - evaluations / self.budget)  # Dynamic inertia adjustment\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n                f_val = func(population[i])\n                evaluations += 1\n\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n\n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n        return global_best", "name": "AdaptiveQuantumHybridSwarm", "description": "An Adaptive Quantum-Inspired Hybrid Swarm Algorithm enhancing diversity and convergence through quantum mechanics concepts and adaptive dynamic techniques.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75c77c35-a246-4a87-a69a-b2a131576f2e", "metadata": {"aucs": [0.8732496514529094, 0.8573013930713151, 0.8744986549559657, 0.8537495192369189, 0.8604165374218101, 0.8715142837348789, 0.8704099284618737, 0.8739727116974925, 0.866791729775093, 0.6147791287774991, 0.5226600881736632, 0.6008666291934257, 0.6011496292940641, 0.5712684505558844, 0.6359510051857422, 0.045908637116616746, 0.01791592251565577, 0.624806402963642, 0.1413067638663884, 0.11049529921804513, 0.14184049273655452, 0.1027592472363914, 0.07083301263806674, 0.12002114502220551, 0.12881546204892624, 0.12197346576387535, 0.14062731601841005, 0.10096466446710328, 0.05413792712396226, 0.09114897185600312, 0.11617455852670533, 0.10909181187858685, 0.1132573468606426, 0.09365470587791058, 0.10954479806391282, 0.06924766798411386, 0.9775912343458948, 0.9856918600781291, 0.9862987405660498, 0.9770175651747988, 0.9778520464721582, 0.9781512659494478, 0.9875080020708764, 0.984098099287295, 0.9849954146772911, 0.7809659532660893, 0.7422826837075494, 0.7507287728082499, 0.7671760563977873, 0.7605455519964089, 0.7573331744633285, 0.7679600916906688, 0.747325999217636, 0.7792914648411364, 0.17111748920970027, 0.3776430589145463, 0.2148095429947724, 0.2812462563154454, 0.8986407239240541, 0.19204913894860254, 0.8747754320911039, 0.875000117318375, 0.868387248003844, 0.7632216912436319, 0.706558114179277, 0.6234648388250588, 0.13136984499800142, 0.7085088269387997, 0.6506806316873934, 0.6826924943191606, 0.6992691458062947, 0.6583057288686354, 0.734243198366002, 0.13115796893246556, 0.6705233511355073, 0.7082745516843774, 0.6388044637379255, 0.1341526369084951, 0.6743382872976676, 0.5567792737889925, 0.13081659118311728, 0.31827943748047594, 9.999999999998899e-05, 0.06633577084044773, 0.5390449000464439, 0.5270845928542385, 9.999999999998899e-05, 0.4392765556044851, 0.008076823072002082, 0.26222948519668543, 0.24804397985012738, 0.36024896744948254, 0.5288676387803491, 0.157319205348598, 0.17810397592288285, 0.6509838503096024, 0.6551795148357473, 0.6692466142047369, 0.6019556617371273, 0.06668243159341114, 0.26091536276258476, 0.22968957066875362, 0.30011996004245634, 0.09151287932329799, 0.3578498530294587, 0.2206967922068861, 0.3854711628213495, 0.20182060529747137, 0.17857461789159057, 0.19558219385245745, 0.3284205134415502, 0.006407430175517814, 0.36619250372402334, 0.2259926234100389, 0.08079187747567196, 0.3566449764797007, 0.08114697349173805, 0.7344845036158891, 0.7483427178164258, 0.7486489878661621, 0.7518594363355056, 0.7634733283067978, 0.802694999760851, 0.6843882425772356, 0.7299911756040789, 0.7593858556799229, 0.07580857596923452, 0.14444118890065638, 0.10268166408293322, 0.14555068634590862, 0.1133105093208967, 0.7033352848670488, 0.1039592203854578, 0.07995791523730145, 0.10458196920510487, 0.1700282082103276, 0.6464594007522839, 0.23788986441283433, 0.24848668452709644, 0.26787452178738946, 0.19298062414556083, 0.421872478808335, 0.19843099372711004, 0.26917347133106273, 0.5491013415157248, 0.33311292285246896, 0.47831967790630825, 0.2510770234307901, 0.24692705852935903, 0.48035384518917157, 0.23665669042404747, 0.42822797182165473, 0.30575513751038663, 0.1384240955857755, 0.21920609124034363, 0.2686337200810871, 0.3370099124725975, 0.27722345291883144, 0.2798287908940785, 0.15815476806470508, 0.3293521774471102, 0.31052351305580883, 0.21880804130783393, 0.23147323015166554, 0.21474406873959928, 0.20490956936190807, 0.23457103325372197, 0.2437305802702212, 0.2149709844811336, 0.2439850908753306, 0.23335761715769676, 0.22350210307888363, 0.18574197878039322, 0.17837020396905356, 0.2155230598069725, 0.19237625339917275, 0.19959724030473103, 0.17669365044360585, 0.21076136807788703, 0.20118337457794033, 0.9214437223791965, 0.1752419304252275, 0.14813261835915315, 0.9234731888523364, 0.1891957800520545, 0.20075856307887285, 0.14236009654782922, 0.16951293172035564, 0.9211706307592998, 0.8938069567687922, 0.21337860007900866, 0.8903324751288573, 0.8659545435144563, 0.8852123370256878, 0.15603433731549, 0.7809371264146462, 0.8691346964491866, 0.8944526734985341, 0.20381020220067825, 0.1898466526025595, 0.19237450905935372, 0.17981768391588937, 0.21853539690398427, 0.19684832418329457, 0.1848171428814328, 0.22912533053187922, 0.19210062702914676, 0.09359997277557464, 0.08913187308574833, 0.07349795134290049, 0.1072000129024635, 0.10987724557902478, 0.1309134338923733, 0.0948732229011211, 0.08903264488315288, 0.0935723001019283]}, "mutation_prompt": null}
{"id": "69809602-7691-46fe-9b96-8a240e540841", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Slightly reduced population for efficiency\n        self.w = 0.5  # Adjusted inertia weight for better balance between exploration and exploitation\n        self.cr = 0.9  # Higher crossover rate to encourage exploration\n        self.f1 = 0.5  # Increased mutation factor for stronger primary exploration\n        self.f2 = 0.6  # Adjusted secondary mutation factor for balance\n        self.q_prob = 0.1  # New quantum probability factor for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                if np.random.rand() < self.q_prob:\n                    quantum_shift = np.random.uniform(-1, 1, self.dim)\n                    mutant = global_best + quantum_shift * (x1 - x2)\n                else:\n                    if np.random.rand() < 0.5:\n                        mutant = x0 + self.f1 * (x1 - x2) + self.f1 * (x2 - x3)\n                    else:\n                        mutant = x0 + self.f2 * (global_best - personal_best[i]) + self.f2 * (x1 - x2)\n\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n\n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.w = 0.3 + 0.3 * (1 - evaluations / self.budget)  # Dynamic inertia adjustment\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n                f_val = func(population[i])\n                evaluations += 1\n\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n\n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n        return global_best", "name": "AdaptiveQuantumHybridSwarm", "description": "An Adaptive Quantum-Inspired Hybrid Swarm Algorithm enhancing diversity and convergence through quantum mechanics concepts and adaptive dynamic techniques.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75c77c35-a246-4a87-a69a-b2a131576f2e", "metadata": {"aucs": [0.8732496514529094, 0.8573013930713151, 0.8744986549559657, 0.8537495192369189, 0.8604165374218101, 0.8715142837348789, 0.8704099284618737, 0.8739727116974925, 0.866791729775093, 0.6147791287774991, 0.5226600881736632, 0.6008666291934257, 0.6011496292940641, 0.5712684505558844, 0.6359510051857422, 0.045908637116616746, 0.01791592251565577, 0.624806402963642, 0.1413067638663884, 0.11049529921804513, 0.14184049273655452, 0.1027592472363914, 0.07083301263806674, 0.12002114502220551, 0.12881546204892624, 0.12197346576387535, 0.14062731601841005, 0.10096466446710328, 0.05413792712396226, 0.09114897185600312, 0.11617455852670533, 0.10909181187858685, 0.1132573468606426, 0.09365470587791058, 0.10954479806391282, 0.06924766798411386, 0.9775912343458948, 0.9856918600781291, 0.9862987405660498, 0.9770175651747988, 0.9778520464721582, 0.9781512659494478, 0.9875080020708764, 0.984098099287295, 0.9849954146772911, 0.7809659532660893, 0.7422826837075494, 0.7507287728082499, 0.7671760563977873, 0.7605455519964089, 0.7573331744633285, 0.7679600916906688, 0.747325999217636, 0.7792914648411364, 0.17111748920970027, 0.3776430589145463, 0.2148095429947724, 0.2812462563154454, 0.8986407239240541, 0.19204913894860254, 0.8747754320911039, 0.875000117318375, 0.868387248003844, 0.7632216912436319, 0.706558114179277, 0.6234648388250588, 0.13136984499800142, 0.7085088269387997, 0.6506806316873934, 0.6826924943191606, 0.6992691458062947, 0.6583057288686354, 0.734243198366002, 0.13115796893246556, 0.6705233511355073, 0.7082745516843774, 0.6388044637379255, 0.1341526369084951, 0.6743382872976676, 0.5567792737889925, 0.13081659118311728, 0.31827943748047594, 9.999999999998899e-05, 0.06633577084044773, 0.5390449000464439, 0.5270845928542385, 9.999999999998899e-05, 0.4392765556044851, 0.008076823072002082, 0.26222948519668543, 0.24804397985012738, 0.36024896744948254, 0.5288676387803491, 0.157319205348598, 0.17810397592288285, 0.6509838503096024, 0.6551795148357473, 0.6692466142047369, 0.6019556617371273, 0.06668243159341114, 0.26091536276258476, 0.22968957066875362, 0.30011996004245634, 0.09151287932329799, 0.3578498530294587, 0.2206967922068861, 0.3854711628213495, 0.20182060529747137, 0.17857461789159057, 0.19558219385245745, 0.3284205134415502, 0.006407430175517814, 0.36619250372402334, 0.2259926234100389, 0.08079187747567196, 0.3566449764797007, 0.08114697349173805, 0.7344845036158891, 0.7483427178164258, 0.7486489878661621, 0.7518594363355056, 0.7634733283067978, 0.802694999760851, 0.6843882425772356, 0.7299911756040789, 0.7593858556799229, 0.07580857596923452, 0.14444118890065638, 0.10268166408293322, 0.14555068634590862, 0.1133105093208967, 0.7033352848670488, 0.1039592203854578, 0.07995791523730145, 0.10458196920510487, 0.1700282082103276, 0.6464594007522839, 0.23788986441283433, 0.24848668452709644, 0.26787452178738946, 0.19298062414556083, 0.421872478808335, 0.19843099372711004, 0.26917347133106273, 0.5491013415157248, 0.33311292285246896, 0.47831967790630825, 0.2510770234307901, 0.24692705852935903, 0.48035384518917157, 0.23665669042404747, 0.42822797182165473, 0.30575513751038663, 0.1384240955857755, 0.21920609124034363, 0.2686337200810871, 0.3370099124725975, 0.27722345291883144, 0.2798287908940785, 0.15815476806470508, 0.3293521774471102, 0.31052351305580883, 0.21880804130783393, 0.23147323015166554, 0.21474406873959928, 0.20490956936190807, 0.23457103325372197, 0.2437305802702212, 0.2149709844811336, 0.2439850908753306, 0.23335761715769676, 0.22350210307888363, 0.18574197878039322, 0.17837020396905356, 0.2155230598069725, 0.19237625339917275, 0.19959724030473103, 0.17669365044360585, 0.21076136807788703, 0.20118337457794033, 0.9214437223791965, 0.1752419304252275, 0.14813261835915315, 0.9234731888523364, 0.1891957800520545, 0.20075856307887285, 0.14236009654782922, 0.16951293172035564, 0.9211706307592998, 0.8938069567687922, 0.21337860007900866, 0.8903324751288573, 0.8659545435144563, 0.8852123370256878, 0.15603433731549, 0.7809371264146462, 0.8691346964491866, 0.8944526734985341, 0.20381020220067825, 0.1898466526025595, 0.19237450905935372, 0.17981768391588937, 0.21853539690398427, 0.19684832418329457, 0.1848171428814328, 0.22912533053187922, 0.19210062702914676, 0.09359997277557464, 0.08913187308574833, 0.07349795134290049, 0.1072000129024635, 0.10987724557902478, 0.1309134338923733, 0.0948732229011211, 0.08903264488315288, 0.0935723001019283]}, "mutation_prompt": null}
{"id": "edcdc433-9f51-4d06-a5bc-5f138c431dfe", "solution": "import numpy as np\n\nclass EvolutionaryQuadraticSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 35  # Smaller population for faster convergence\n        self.w = 0.6  # Increased inertia for stable convergence\n        self.cr = 0.85  # Slightly reduced crossover rate\n        self.f1 = 0.4  # Reduced mutation factor for more controlled exploration\n        self.q_prob = 0.15  # Enhanced quantum factor for diversity boost\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                if np.random.rand() < self.q_prob:\n                    quantum_shift = np.random.uniform(-1, 1, self.dim)\n                    mutant = global_best + quantum_shift * (x1 - x2)\n                else:\n                    quadratic_component = self.f1 * (x0 - x1) * (x2 - x3)\n                    if np.random.rand() < 0.5:\n                        mutant = x0 + quadratic_component\n                    else:\n                        mutant = x0 + self.f1 * (global_best - personal_best[i]) + self.f1 * (x1 - x2)\n\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n\n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.w = 0.4 + 0.25 * (1 - evaluations / self.budget)  # Dynamic inertia adjustment\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n                f_val = func(population[i])\n                evaluations += 1\n\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n\n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n        return global_best", "name": "EvolutionaryQuadraticSwarm", "description": "Evolutionary Quadratic Swarm Optimization enhancing convergence with quadratic mutation and adaptive learning strategies.", "configspace": "", "generation": 65, "fitness": 0.37839395014481525, "feedback": "The algorithm EvolutionaryQuadraticSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.29.", "error": "", "parent_id": "75c77c35-a246-4a87-a69a-b2a131576f2e", "metadata": {"aucs": [0.8561112893321959, 0.8681064923558762, 0.8671020134274523, 0.8499585233694779, 0.854993618457839, 0.860096417641876, 0.8647598950713773, 0.8651532787362683, 0.859896515584656, 0.6715418892489845, 0.6190302852501202, 0.6426200373048312, 0.6612451952440845, 0.04529180105705777, 9.999999999998899e-05, 0.6603917534845163, 0.6677372584569387, 0.6608160962648637, 0.17815851354851275, 0.10451683297854975, 0.0864178835468743, 0.13173414676220963, 0.14124032959031052, 0.09167288745119473, 0.7395296978483383, 0.13263692779560987, 0.07065079961389509, 0.10649251103388702, 0.09471585582593567, 0.14113825365778665, 0.10806432442292657, 0.08989399573864298, 0.07127108283107952, 0.09260338651414646, 0.061525492996648445, 0.1436439220367236, 0.9797613432634404, 0.984906891364618, 0.9875362144013926, 0.987076180374299, 0.9918160582056921, 0.9867522449314549, 0.987814260428163, 0.9869805837517414, 0.9861873896316735, 0.7374852973965209, 0.7611407068357464, 0.7350871549307187, 0.7405069963559952, 0.6995584303375901, 0.7781497510413405, 0.7512704243105255, 0.7437926492534541, 0.7512009022556893, 0.8398757562426482, 0.8432138625128476, 0.3842732113667431, 0.20916785145474093, 0.35519726912228344, 0.2022669994482259, 0.12409130218876885, 0.8516099585727781, 0.3864128546076451, 0.6634244693088696, 0.12886914521146864, 0.6684678642226362, 0.12067291020297344, 0.6617639977986985, 0.12960488797063263, 0.68031451456094, 0.13179975307674086, 0.7120985063246501, 0.6539287201407789, 0.6325560166427959, 0.6869735714576095, 0.13406753684863193, 0.7238568348116772, 0.7483747135203076, 0.715411369462442, 0.7081535048478966, 0.6607541727874764, 9.999999999998899e-05, 0.1940552294824145, 0.5211516927245134, 0.2217471269723671, 0.18328997518662615, 0.4007746705992886, 0.21608748266482658, 0.3731989694350978, 0.4665836900693219, 0.5706338597566238, 0.18024601810375296, 0.6220693783859962, 0.5578213933881111, 0.2074200894687559, 0.2334114372299838, 0.2159895277971312, 0.6221501429915329, 0.4732205996604193, 0.20517364514008862, 0.15915983739851003, 0.2311738986484968, 0.34138125905185046, 0.09192634197840144, 0.07410166848293831, 0.18279575595554343, 0.12031740003534175, 0.07090189485240284, 0.04312535609770507, 0.3112109202689549, 0.34172018787274183, 0.21302019749497436, 0.24902094051390933, 0.21548452711633137, 0.08185199286622336, 0.09278970727561697, 0.08265070942735331, 0.6961710026492751, 0.6917468361482876, 0.7352217824784784, 0.701257685204298, 0.7153288603036764, 0.7530694307896457, 0.6342325294907611, 0.6702050397340236, 0.780882829657251, 0.0901650387668369, 0.07822777281317217, 0.09833984494573977, 0.05039805380473994, 0.7268274526658296, 0.09669494787653543, 0.07279914549710742, 0.15483636947269208, 0.0723786517349212, 0.21761135806570175, 0.26209029389314975, 0.20913025245183192, 0.2798086991224771, 0.36008407062175296, 0.2295754145712232, 0.1773784066256343, 0.17868717022799796, 0.4148233769147637, 0.272465091967673, 0.25351590693596315, 0.228967879533588, 0.3290778268392923, 0.23617957498505326, 0.33318095589784436, 0.26167788166674877, 0.5523859004359556, 0.37936286029145316, 0.19319238697542218, 0.28563891462627544, 0.23783029581239434, 0.1869158496224549, 0.32433935591064844, 0.403898748487585, 0.2699137731056451, 0.2721327481343542, 0.1713404743105772, 0.23587116502173155, 0.23106494490268947, 0.19466606388531904, 0.22986351495596558, 0.17688873641967606, 0.2441591496787353, 0.2174961630151614, 0.2542208472918751, 0.23335052971067993, 0.1813590938727344, 0.18608175195116428, 0.18876967801079592, 0.2035858331807907, 0.19474298825408842, 0.20644773686878115, 0.18652801779943107, 0.18696855801796342, 0.22541132628950655, 0.165981419023136, 0.1871142354929506, 0.15386134907888627, 0.9050858256641705, 0.20070476640554247, 0.1995834784938736, 0.14204128156245877, 0.17004225737286072, 0.18775738017636423, 0.9017520170367284, 0.21259676980567743, 0.8747052968806184, 0.15308190396420773, 0.20999580451619726, 0.20944601083028558, 0.2007434321577345, 0.20753414194387632, 0.8918317430827308, 0.22507504360554775, 0.2232294041569972, 0.2085713656636965, 0.22530113876876756, 0.18057600789165695, 0.23071695089450017, 0.19618667991918415, 0.2385291895687659, 0.20988895810659958, 0.07837139587342212, 0.09338497201800056, 0.09516356919437963, 0.07790447678539969, 0.1024743780334122, 0.10055879998430606, 0.0899358491382507, 0.10443255139236185, 0.09862678294292693]}, "mutation_prompt": null}
{"id": "8468757f-4996-4640-bdeb-f77063579fb5", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Slightly reduced population for efficiency\n        self.w = 0.5  # Adjusted inertia weight for better balance between exploration and exploitation\n        self.cr = 0.9  # Higher crossover rate to encourage exploration\n        self.f1 = 0.5  # Increased mutation factor for stronger primary exploration\n        self.f2 = 0.6  # Adjusted secondary mutation factor for balance\n        self.q_prob = 0.1  # New quantum probability factor for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                if np.random.rand() < self.q_prob:\n                    quantum_shift = np.random.uniform(-1, 1, self.dim)\n                    mutant = global_best + quantum_shift * (x1 - x2)\n                else:\n                    if np.random.rand() < 0.5:\n                        mutant = x0 + self.f1 * (x1 - x2) + self.f1 * (x2 - x3)\n                    else:\n                        mutant = x0 + self.f2 * (global_best - personal_best[i]) + self.f2 * (x1 - x2)\n\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n\n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.w = 0.3 + 0.3 * (1 - evaluations / self.budget)  # Dynamic inertia adjustment\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n                f_val = func(population[i])\n                evaluations += 1\n\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n\n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n        return global_best", "name": "AdaptiveQuantumHybridSwarm", "description": "An Adaptive Quantum-Inspired Hybrid Swarm Algorithm enhancing diversity and convergence through quantum mechanics concepts and adaptive dynamic techniques.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75c77c35-a246-4a87-a69a-b2a131576f2e", "metadata": {"aucs": [0.8732496514529094, 0.8573013930713151, 0.8744986549559657, 0.8537495192369189, 0.8604165374218101, 0.8715142837348789, 0.8704099284618737, 0.8739727116974925, 0.866791729775093, 0.6147791287774991, 0.5226600881736632, 0.6008666291934257, 0.6011496292940641, 0.5712684505558844, 0.6359510051857422, 0.045908637116616746, 0.01791592251565577, 0.624806402963642, 0.1413067638663884, 0.11049529921804513, 0.14184049273655452, 0.1027592472363914, 0.07083301263806674, 0.12002114502220551, 0.12881546204892624, 0.12197346576387535, 0.14062731601841005, 0.10096466446710328, 0.05413792712396226, 0.09114897185600312, 0.11617455852670533, 0.10909181187858685, 0.1132573468606426, 0.09365470587791058, 0.10954479806391282, 0.06924766798411386, 0.9775912343458948, 0.9856918600781291, 0.9862987405660498, 0.9770175651747988, 0.9778520464721582, 0.9781512659494478, 0.9875080020708764, 0.984098099287295, 0.9849954146772911, 0.7809659532660893, 0.7422826837075494, 0.7507287728082499, 0.7671760563977873, 0.7605455519964089, 0.7573331744633285, 0.7679600916906688, 0.747325999217636, 0.7792914648411364, 0.17111748920970027, 0.3776430589145463, 0.2148095429947724, 0.2812462563154454, 0.8986407239240541, 0.19204913894860254, 0.8747754320911039, 0.875000117318375, 0.868387248003844, 0.7632216912436319, 0.706558114179277, 0.6234648388250588, 0.13136984499800142, 0.7085088269387997, 0.6506806316873934, 0.6826924943191606, 0.6992691458062947, 0.6583057288686354, 0.734243198366002, 0.13115796893246556, 0.6705233511355073, 0.7082745516843774, 0.6388044637379255, 0.1341526369084951, 0.6743382872976676, 0.5567792737889925, 0.13081659118311728, 0.31827943748047594, 9.999999999998899e-05, 0.06633577084044773, 0.5390449000464439, 0.5270845928542385, 9.999999999998899e-05, 0.4392765556044851, 0.008076823072002082, 0.26222948519668543, 0.24804397985012738, 0.36024896744948254, 0.5288676387803491, 0.157319205348598, 0.17810397592288285, 0.6509838503096024, 0.6551795148357473, 0.6692466142047369, 0.6019556617371273, 0.06668243159341114, 0.26091536276258476, 0.22968957066875362, 0.30011996004245634, 0.09151287932329799, 0.3578498530294587, 0.2206967922068861, 0.3854711628213495, 0.20182060529747137, 0.17857461789159057, 0.19558219385245745, 0.3284205134415502, 0.006407430175517814, 0.36619250372402334, 0.2259926234100389, 0.08079187747567196, 0.3566449764797007, 0.08114697349173805, 0.7344845036158891, 0.7483427178164258, 0.7486489878661621, 0.7518594363355056, 0.7634733283067978, 0.802694999760851, 0.6843882425772356, 0.7299911756040789, 0.7593858556799229, 0.07580857596923452, 0.14444118890065638, 0.10268166408293322, 0.14555068634590862, 0.1133105093208967, 0.7033352848670488, 0.1039592203854578, 0.07995791523730145, 0.10458196920510487, 0.1700282082103276, 0.6464594007522839, 0.23788986441283433, 0.24848668452709644, 0.26787452178738946, 0.19298062414556083, 0.421872478808335, 0.19843099372711004, 0.26917347133106273, 0.5491013415157248, 0.33311292285246896, 0.47831967790630825, 0.2510770234307901, 0.24692705852935903, 0.48035384518917157, 0.23665669042404747, 0.42822797182165473, 0.30575513751038663, 0.1384240955857755, 0.21920609124034363, 0.2686337200810871, 0.3370099124725975, 0.27722345291883144, 0.2798287908940785, 0.15815476806470508, 0.3293521774471102, 0.31052351305580883, 0.21880804130783393, 0.23147323015166554, 0.21474406873959928, 0.20490956936190807, 0.23457103325372197, 0.2437305802702212, 0.2149709844811336, 0.2439850908753306, 0.23335761715769676, 0.22350210307888363, 0.18574197878039322, 0.17837020396905356, 0.2155230598069725, 0.19237625339917275, 0.19959724030473103, 0.17669365044360585, 0.21076136807788703, 0.20118337457794033, 0.9214437223791965, 0.1752419304252275, 0.14813261835915315, 0.9234731888523364, 0.1891957800520545, 0.20075856307887285, 0.14236009654782922, 0.16951293172035564, 0.9211706307592998, 0.8938069567687922, 0.21337860007900866, 0.8903324751288573, 0.8659545435144563, 0.8852123370256878, 0.15603433731549, 0.7809371264146462, 0.8691346964491866, 0.8944526734985341, 0.20381020220067825, 0.1898466526025595, 0.19237450905935372, 0.17981768391588937, 0.21853539690398427, 0.19684832418329457, 0.1848171428814328, 0.22912533053187922, 0.19210062702914676, 0.09359997277557464, 0.08913187308574833, 0.07349795134290049, 0.1072000129024635, 0.10987724557902478, 0.1309134338923733, 0.0948732229011211, 0.08903264488315288, 0.0935723001019283]}, "mutation_prompt": null}
{"id": "535c90f3-5ee3-4190-9c60-f450a3e8bdf5", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Slightly reduced population for efficiency\n        self.w = 0.5  # Adjusted inertia weight for better balance between exploration and exploitation\n        self.cr = 0.9  # Higher crossover rate to encourage exploration\n        self.f1 = 0.5  # Increased mutation factor for stronger primary exploration\n        self.f2 = 0.6  # Adjusted secondary mutation factor for balance\n        self.q_prob = 0.1  # New quantum probability factor for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                if np.random.rand() < self.q_prob:\n                    quantum_shift = np.random.uniform(-1, 1, self.dim)\n                    mutant = global_best + quantum_shift * (x1 - x2)\n                else:\n                    if np.random.rand() < 0.5:\n                        mutant = x0 + self.f1 * (x1 - x2) + self.f1 * (x2 - x3)\n                    else:\n                        mutant = x0 + self.f2 * (global_best - personal_best[i]) + self.f2 * (x1 - x2)\n\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n\n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.w = 0.3 + 0.3 * (1 - evaluations / self.budget)  # Dynamic inertia adjustment\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n                f_val = func(population[i])\n                evaluations += 1\n\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n\n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n        return global_best", "name": "AdaptiveQuantumHybridSwarm", "description": "An Adaptive Quantum-Inspired Hybrid Swarm Algorithm enhancing diversity and convergence through quantum mechanics concepts and adaptive dynamic techniques.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75c77c35-a246-4a87-a69a-b2a131576f2e", "metadata": {"aucs": [0.8732496514529094, 0.8573013930713151, 0.8744986549559657, 0.8537495192369189, 0.8604165374218101, 0.8715142837348789, 0.8704099284618737, 0.8739727116974925, 0.866791729775093, 0.6147791287774991, 0.5226600881736632, 0.6008666291934257, 0.6011496292940641, 0.5712684505558844, 0.6359510051857422, 0.045908637116616746, 0.01791592251565577, 0.624806402963642, 0.1413067638663884, 0.11049529921804513, 0.14184049273655452, 0.1027592472363914, 0.07083301263806674, 0.12002114502220551, 0.12881546204892624, 0.12197346576387535, 0.14062731601841005, 0.10096466446710328, 0.05413792712396226, 0.09114897185600312, 0.11617455852670533, 0.10909181187858685, 0.1132573468606426, 0.09365470587791058, 0.10954479806391282, 0.06924766798411386, 0.9775912343458948, 0.9856918600781291, 0.9862987405660498, 0.9770175651747988, 0.9778520464721582, 0.9781512659494478, 0.9875080020708764, 0.984098099287295, 0.9849954146772911, 0.7809659532660893, 0.7422826837075494, 0.7507287728082499, 0.7671760563977873, 0.7605455519964089, 0.7573331744633285, 0.7679600916906688, 0.747325999217636, 0.7792914648411364, 0.17111748920970027, 0.3776430589145463, 0.2148095429947724, 0.2812462563154454, 0.8986407239240541, 0.19204913894860254, 0.8747754320911039, 0.875000117318375, 0.868387248003844, 0.7632216912436319, 0.706558114179277, 0.6234648388250588, 0.13136984499800142, 0.7085088269387997, 0.6506806316873934, 0.6826924943191606, 0.6992691458062947, 0.6583057288686354, 0.734243198366002, 0.13115796893246556, 0.6705233511355073, 0.7082745516843774, 0.6388044637379255, 0.1341526369084951, 0.6743382872976676, 0.5567792737889925, 0.13081659118311728, 0.31827943748047594, 9.999999999998899e-05, 0.06633577084044773, 0.5390449000464439, 0.5270845928542385, 9.999999999998899e-05, 0.4392765556044851, 0.008076823072002082, 0.26222948519668543, 0.24804397985012738, 0.36024896744948254, 0.5288676387803491, 0.157319205348598, 0.17810397592288285, 0.6509838503096024, 0.6551795148357473, 0.6692466142047369, 0.6019556617371273, 0.06668243159341114, 0.26091536276258476, 0.22968957066875362, 0.30011996004245634, 0.09151287932329799, 0.3578498530294587, 0.2206967922068861, 0.3854711628213495, 0.20182060529747137, 0.17857461789159057, 0.19558219385245745, 0.3284205134415502, 0.006407430175517814, 0.36619250372402334, 0.2259926234100389, 0.08079187747567196, 0.3566449764797007, 0.08114697349173805, 0.7344845036158891, 0.7483427178164258, 0.7486489878661621, 0.7518594363355056, 0.7634733283067978, 0.802694999760851, 0.6843882425772356, 0.7299911756040789, 0.7593858556799229, 0.07580857596923452, 0.14444118890065638, 0.10268166408293322, 0.14555068634590862, 0.1133105093208967, 0.7033352848670488, 0.1039592203854578, 0.07995791523730145, 0.10458196920510487, 0.1700282082103276, 0.6464594007522839, 0.23788986441283433, 0.24848668452709644, 0.26787452178738946, 0.19298062414556083, 0.421872478808335, 0.19843099372711004, 0.26917347133106273, 0.5491013415157248, 0.33311292285246896, 0.47831967790630825, 0.2510770234307901, 0.24692705852935903, 0.48035384518917157, 0.23665669042404747, 0.42822797182165473, 0.30575513751038663, 0.1384240955857755, 0.21920609124034363, 0.2686337200810871, 0.3370099124725975, 0.27722345291883144, 0.2798287908940785, 0.15815476806470508, 0.3293521774471102, 0.31052351305580883, 0.21880804130783393, 0.23147323015166554, 0.21474406873959928, 0.20490956936190807, 0.23457103325372197, 0.2437305802702212, 0.2149709844811336, 0.2439850908753306, 0.23335761715769676, 0.22350210307888363, 0.18574197878039322, 0.17837020396905356, 0.2155230598069725, 0.19237625339917275, 0.19959724030473103, 0.17669365044360585, 0.21076136807788703, 0.20118337457794033, 0.9214437223791965, 0.1752419304252275, 0.14813261835915315, 0.9234731888523364, 0.1891957800520545, 0.20075856307887285, 0.14236009654782922, 0.16951293172035564, 0.9211706307592998, 0.8938069567687922, 0.21337860007900866, 0.8903324751288573, 0.8659545435144563, 0.8852123370256878, 0.15603433731549, 0.7809371264146462, 0.8691346964491866, 0.8944526734985341, 0.20381020220067825, 0.1898466526025595, 0.19237450905935372, 0.17981768391588937, 0.21853539690398427, 0.19684832418329457, 0.1848171428814328, 0.22912533053187922, 0.19210062702914676, 0.09359997277557464, 0.08913187308574833, 0.07349795134290049, 0.1072000129024635, 0.10987724557902478, 0.1309134338923733, 0.0948732229011211, 0.08903264488315288, 0.0935723001019283]}, "mutation_prompt": null}
{"id": "e3a6973c-2fbe-4d0b-9eff-48e94b4eb564", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Slightly reduced population for efficiency\n        self.w = 0.5  # Adjusted inertia weight for better balance between exploration and exploitation\n        self.cr = 0.9  # Higher crossover rate to encourage exploration\n        self.f1 = 0.5  # Increased mutation factor for stronger primary exploration\n        self.f2 = 0.6  # Adjusted secondary mutation factor for balance\n        self.q_prob = 0.1  # New quantum probability factor for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                if np.random.rand() < self.q_prob:\n                    quantum_shift = np.random.uniform(-1, 1, self.dim)\n                    mutant = global_best + quantum_shift * (x1 - x2)\n                else:\n                    if np.random.rand() < 0.5:\n                        mutant = x0 + self.f1 * (x1 - x2) + self.f1 * (x2 - x3)\n                    else:\n                        mutant = x0 + self.f2 * (global_best - personal_best[i]) + self.f2 * (x1 - x2)\n\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n\n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.w = 0.3 + 0.3 * (1 - evaluations / self.budget)  # Dynamic inertia adjustment\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n                f_val = func(population[i])\n                evaluations += 1\n\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n\n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n        return global_best", "name": "AdaptiveQuantumHybridSwarm", "description": "An Adaptive Quantum-Inspired Hybrid Swarm Algorithm enhancing diversity and convergence through quantum mechanics concepts and adaptive dynamic techniques.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75c77c35-a246-4a87-a69a-b2a131576f2e", "metadata": {"aucs": [0.8732496514529094, 0.8573013930713151, 0.8744986549559657, 0.8537495192369189, 0.8604165374218101, 0.8715142837348789, 0.8704099284618737, 0.8739727116974925, 0.866791729775093, 0.6147791287774991, 0.5226600881736632, 0.6008666291934257, 0.6011496292940641, 0.5712684505558844, 0.6359510051857422, 0.045908637116616746, 0.01791592251565577, 0.624806402963642, 0.1413067638663884, 0.11049529921804513, 0.14184049273655452, 0.1027592472363914, 0.07083301263806674, 0.12002114502220551, 0.12881546204892624, 0.12197346576387535, 0.14062731601841005, 0.10096466446710328, 0.05413792712396226, 0.09114897185600312, 0.11617455852670533, 0.10909181187858685, 0.1132573468606426, 0.09365470587791058, 0.10954479806391282, 0.06924766798411386, 0.9775912343458948, 0.9856918600781291, 0.9862987405660498, 0.9770175651747988, 0.9778520464721582, 0.9781512659494478, 0.9875080020708764, 0.984098099287295, 0.9849954146772911, 0.7809659532660893, 0.7422826837075494, 0.7507287728082499, 0.7671760563977873, 0.7605455519964089, 0.7573331744633285, 0.7679600916906688, 0.747325999217636, 0.7792914648411364, 0.17111748920970027, 0.3776430589145463, 0.2148095429947724, 0.2812462563154454, 0.8986407239240541, 0.19204913894860254, 0.8747754320911039, 0.875000117318375, 0.868387248003844, 0.7632216912436319, 0.706558114179277, 0.6234648388250588, 0.13136984499800142, 0.7085088269387997, 0.6506806316873934, 0.6826924943191606, 0.6992691458062947, 0.6583057288686354, 0.734243198366002, 0.13115796893246556, 0.6705233511355073, 0.7082745516843774, 0.6388044637379255, 0.1341526369084951, 0.6743382872976676, 0.5567792737889925, 0.13081659118311728, 0.31827943748047594, 9.999999999998899e-05, 0.06633577084044773, 0.5390449000464439, 0.5270845928542385, 9.999999999998899e-05, 0.4392765556044851, 0.008076823072002082, 0.26222948519668543, 0.24804397985012738, 0.36024896744948254, 0.5288676387803491, 0.157319205348598, 0.17810397592288285, 0.6509838503096024, 0.6551795148357473, 0.6692466142047369, 0.6019556617371273, 0.06668243159341114, 0.26091536276258476, 0.22968957066875362, 0.30011996004245634, 0.09151287932329799, 0.3578498530294587, 0.2206967922068861, 0.3854711628213495, 0.20182060529747137, 0.17857461789159057, 0.19558219385245745, 0.3284205134415502, 0.006407430175517814, 0.36619250372402334, 0.2259926234100389, 0.08079187747567196, 0.3566449764797007, 0.08114697349173805, 0.7344845036158891, 0.7483427178164258, 0.7486489878661621, 0.7518594363355056, 0.7634733283067978, 0.802694999760851, 0.6843882425772356, 0.7299911756040789, 0.7593858556799229, 0.07580857596923452, 0.14444118890065638, 0.10268166408293322, 0.14555068634590862, 0.1133105093208967, 0.7033352848670488, 0.1039592203854578, 0.07995791523730145, 0.10458196920510487, 0.1700282082103276, 0.6464594007522839, 0.23788986441283433, 0.24848668452709644, 0.26787452178738946, 0.19298062414556083, 0.421872478808335, 0.19843099372711004, 0.26917347133106273, 0.5491013415157248, 0.33311292285246896, 0.47831967790630825, 0.2510770234307901, 0.24692705852935903, 0.48035384518917157, 0.23665669042404747, 0.42822797182165473, 0.30575513751038663, 0.1384240955857755, 0.21920609124034363, 0.2686337200810871, 0.3370099124725975, 0.27722345291883144, 0.2798287908940785, 0.15815476806470508, 0.3293521774471102, 0.31052351305580883, 0.21880804130783393, 0.23147323015166554, 0.21474406873959928, 0.20490956936190807, 0.23457103325372197, 0.2437305802702212, 0.2149709844811336, 0.2439850908753306, 0.23335761715769676, 0.22350210307888363, 0.18574197878039322, 0.17837020396905356, 0.2155230598069725, 0.19237625339917275, 0.19959724030473103, 0.17669365044360585, 0.21076136807788703, 0.20118337457794033, 0.9214437223791965, 0.1752419304252275, 0.14813261835915315, 0.9234731888523364, 0.1891957800520545, 0.20075856307887285, 0.14236009654782922, 0.16951293172035564, 0.9211706307592998, 0.8938069567687922, 0.21337860007900866, 0.8903324751288573, 0.8659545435144563, 0.8852123370256878, 0.15603433731549, 0.7809371264146462, 0.8691346964491866, 0.8944526734985341, 0.20381020220067825, 0.1898466526025595, 0.19237450905935372, 0.17981768391588937, 0.21853539690398427, 0.19684832418329457, 0.1848171428814328, 0.22912533053187922, 0.19210062702914676, 0.09359997277557464, 0.08913187308574833, 0.07349795134290049, 0.1072000129024635, 0.10987724557902478, 0.1309134338923733, 0.0948732229011211, 0.08903264488315288, 0.0935723001019283]}, "mutation_prompt": null}
{"id": "ee6416f0-5081-4023-bc19-fccd28b553c3", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Slightly reduced population for efficiency\n        self.w = 0.5  # Adjusted inertia weight for better balance between exploration and exploitation\n        self.cr = 0.9  # Higher crossover rate to encourage exploration\n        self.f1 = 0.5  # Increased mutation factor for stronger primary exploration\n        self.f2 = 0.6  # Adjusted secondary mutation factor for balance\n        self.q_prob = 0.1  # New quantum probability factor for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                if np.random.rand() < self.q_prob:\n                    quantum_shift = np.random.uniform(-1, 1, self.dim)\n                    mutant = global_best + quantum_shift * (x1 - x2)\n                else:\n                    if np.random.rand() < 0.5:\n                        mutant = x0 + self.f1 * (x1 - x2) + self.f1 * (x2 - x3)\n                    else:\n                        mutant = x0 + self.f2 * (global_best - personal_best[i]) + self.f2 * (x1 - x2)\n\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n\n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.w = 0.3 + 0.3 * (1 - evaluations / self.budget)  # Dynamic inertia adjustment\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n                f_val = func(population[i])\n                evaluations += 1\n\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n\n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n        return global_best", "name": "AdaptiveQuantumHybridSwarm", "description": "An Adaptive Quantum-Inspired Hybrid Swarm Algorithm enhancing diversity and convergence through quantum mechanics concepts and adaptive dynamic techniques.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75c77c35-a246-4a87-a69a-b2a131576f2e", "metadata": {"aucs": [0.8732496514529094, 0.8573013930713151, 0.8744986549559657, 0.8537495192369189, 0.8604165374218101, 0.8715142837348789, 0.8704099284618737, 0.8739727116974925, 0.866791729775093, 0.6147791287774991, 0.5226600881736632, 0.6008666291934257, 0.6011496292940641, 0.5712684505558844, 0.6359510051857422, 0.045908637116616746, 0.01791592251565577, 0.624806402963642, 0.1413067638663884, 0.11049529921804513, 0.14184049273655452, 0.1027592472363914, 0.07083301263806674, 0.12002114502220551, 0.12881546204892624, 0.12197346576387535, 0.14062731601841005, 0.10096466446710328, 0.05413792712396226, 0.09114897185600312, 0.11617455852670533, 0.10909181187858685, 0.1132573468606426, 0.09365470587791058, 0.10954479806391282, 0.06924766798411386, 0.9775912343458948, 0.9856918600781291, 0.9862987405660498, 0.9770175651747988, 0.9778520464721582, 0.9781512659494478, 0.9875080020708764, 0.984098099287295, 0.9849954146772911, 0.7809659532660893, 0.7422826837075494, 0.7507287728082499, 0.7671760563977873, 0.7605455519964089, 0.7573331744633285, 0.7679600916906688, 0.747325999217636, 0.7792914648411364, 0.17111748920970027, 0.3776430589145463, 0.2148095429947724, 0.2812462563154454, 0.8986407239240541, 0.19204913894860254, 0.8747754320911039, 0.875000117318375, 0.868387248003844, 0.7632216912436319, 0.706558114179277, 0.6234648388250588, 0.13136984499800142, 0.7085088269387997, 0.6506806316873934, 0.6826924943191606, 0.6992691458062947, 0.6583057288686354, 0.734243198366002, 0.13115796893246556, 0.6705233511355073, 0.7082745516843774, 0.6388044637379255, 0.1341526369084951, 0.6743382872976676, 0.5567792737889925, 0.13081659118311728, 0.31827943748047594, 9.999999999998899e-05, 0.06633577084044773, 0.5390449000464439, 0.5270845928542385, 9.999999999998899e-05, 0.4392765556044851, 0.008076823072002082, 0.26222948519668543, 0.24804397985012738, 0.36024896744948254, 0.5288676387803491, 0.157319205348598, 0.17810397592288285, 0.6509838503096024, 0.6551795148357473, 0.6692466142047369, 0.6019556617371273, 0.06668243159341114, 0.26091536276258476, 0.22968957066875362, 0.30011996004245634, 0.09151287932329799, 0.3578498530294587, 0.2206967922068861, 0.3854711628213495, 0.20182060529747137, 0.17857461789159057, 0.19558219385245745, 0.3284205134415502, 0.006407430175517814, 0.36619250372402334, 0.2259926234100389, 0.08079187747567196, 0.3566449764797007, 0.08114697349173805, 0.7344845036158891, 0.7483427178164258, 0.7486489878661621, 0.7518594363355056, 0.7634733283067978, 0.802694999760851, 0.6843882425772356, 0.7299911756040789, 0.7593858556799229, 0.07580857596923452, 0.14444118890065638, 0.10268166408293322, 0.14555068634590862, 0.1133105093208967, 0.7033352848670488, 0.1039592203854578, 0.07995791523730145, 0.10458196920510487, 0.1700282082103276, 0.6464594007522839, 0.23788986441283433, 0.24848668452709644, 0.26787452178738946, 0.19298062414556083, 0.421872478808335, 0.19843099372711004, 0.26917347133106273, 0.5491013415157248, 0.33311292285246896, 0.47831967790630825, 0.2510770234307901, 0.24692705852935903, 0.48035384518917157, 0.23665669042404747, 0.42822797182165473, 0.30575513751038663, 0.1384240955857755, 0.21920609124034363, 0.2686337200810871, 0.3370099124725975, 0.27722345291883144, 0.2798287908940785, 0.15815476806470508, 0.3293521774471102, 0.31052351305580883, 0.21880804130783393, 0.23147323015166554, 0.21474406873959928, 0.20490956936190807, 0.23457103325372197, 0.2437305802702212, 0.2149709844811336, 0.2439850908753306, 0.23335761715769676, 0.22350210307888363, 0.18574197878039322, 0.17837020396905356, 0.2155230598069725, 0.19237625339917275, 0.19959724030473103, 0.17669365044360585, 0.21076136807788703, 0.20118337457794033, 0.9214437223791965, 0.1752419304252275, 0.14813261835915315, 0.9234731888523364, 0.1891957800520545, 0.20075856307887285, 0.14236009654782922, 0.16951293172035564, 0.9211706307592998, 0.8938069567687922, 0.21337860007900866, 0.8903324751288573, 0.8659545435144563, 0.8852123370256878, 0.15603433731549, 0.7809371264146462, 0.8691346964491866, 0.8944526734985341, 0.20381020220067825, 0.1898466526025595, 0.19237450905935372, 0.17981768391588937, 0.21853539690398427, 0.19684832418329457, 0.1848171428814328, 0.22912533053187922, 0.19210062702914676, 0.09359997277557464, 0.08913187308574833, 0.07349795134290049, 0.1072000129024635, 0.10987724557902478, 0.1309134338923733, 0.0948732229011211, 0.08903264488315288, 0.0935723001019283]}, "mutation_prompt": null}
{"id": "de698683-3048-46b3-880a-b2ab82fd8142", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Slightly reduced population for efficiency\n        self.w = 0.5  # Adjusted inertia weight for better balance between exploration and exploitation\n        self.cr = 0.9  # Higher crossover rate to encourage exploration\n        self.f1 = 0.5  # Increased mutation factor for stronger primary exploration\n        self.f2 = 0.6  # Adjusted secondary mutation factor for balance\n        self.q_prob = 0.1  # New quantum probability factor for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                if np.random.rand() < self.q_prob:\n                    quantum_shift = np.random.uniform(-1, 1, self.dim)\n                    mutant = global_best + quantum_shift * (x1 - x2)\n                else:\n                    if np.random.rand() < 0.5:\n                        mutant = x0 + self.f1 * (x1 - x2) + self.f1 * (x2 - x3)\n                    else:\n                        mutant = x0 + self.f2 * (global_best - personal_best[i]) + self.f2 * (x1 - x2)\n\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n\n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.w = 0.3 + 0.3 * (1 - evaluations / self.budget)  # Dynamic inertia adjustment\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n                f_val = func(population[i])\n                evaluations += 1\n\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n\n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n        return global_best", "name": "AdaptiveQuantumHybridSwarm", "description": "An Adaptive Quantum-Inspired Hybrid Swarm Algorithm enhancing diversity and convergence through quantum mechanics concepts and adaptive dynamic techniques.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75c77c35-a246-4a87-a69a-b2a131576f2e", "metadata": {"aucs": [0.8732496514529094, 0.8573013930713151, 0.8744986549559657, 0.8537495192369189, 0.8604165374218101, 0.8715142837348789, 0.8704099284618737, 0.8739727116974925, 0.866791729775093, 0.6147791287774991, 0.5226600881736632, 0.6008666291934257, 0.6011496292940641, 0.5712684505558844, 0.6359510051857422, 0.045908637116616746, 0.01791592251565577, 0.624806402963642, 0.1413067638663884, 0.11049529921804513, 0.14184049273655452, 0.1027592472363914, 0.07083301263806674, 0.12002114502220551, 0.12881546204892624, 0.12197346576387535, 0.14062731601841005, 0.10096466446710328, 0.05413792712396226, 0.09114897185600312, 0.11617455852670533, 0.10909181187858685, 0.1132573468606426, 0.09365470587791058, 0.10954479806391282, 0.06924766798411386, 0.9775912343458948, 0.9856918600781291, 0.9862987405660498, 0.9770175651747988, 0.9778520464721582, 0.9781512659494478, 0.9875080020708764, 0.984098099287295, 0.9849954146772911, 0.7809659532660893, 0.7422826837075494, 0.7507287728082499, 0.7671760563977873, 0.7605455519964089, 0.7573331744633285, 0.7679600916906688, 0.747325999217636, 0.7792914648411364, 0.17111748920970027, 0.3776430589145463, 0.2148095429947724, 0.2812462563154454, 0.8986407239240541, 0.19204913894860254, 0.8747754320911039, 0.875000117318375, 0.868387248003844, 0.7632216912436319, 0.706558114179277, 0.6234648388250588, 0.13136984499800142, 0.7085088269387997, 0.6506806316873934, 0.6826924943191606, 0.6992691458062947, 0.6583057288686354, 0.734243198366002, 0.13115796893246556, 0.6705233511355073, 0.7082745516843774, 0.6388044637379255, 0.1341526369084951, 0.6743382872976676, 0.5567792737889925, 0.13081659118311728, 0.31827943748047594, 9.999999999998899e-05, 0.06633577084044773, 0.5390449000464439, 0.5270845928542385, 9.999999999998899e-05, 0.4392765556044851, 0.008076823072002082, 0.26222948519668543, 0.24804397985012738, 0.36024896744948254, 0.5288676387803491, 0.157319205348598, 0.17810397592288285, 0.6509838503096024, 0.6551795148357473, 0.6692466142047369, 0.6019556617371273, 0.06668243159341114, 0.26091536276258476, 0.22968957066875362, 0.30011996004245634, 0.09151287932329799, 0.3578498530294587, 0.2206967922068861, 0.3854711628213495, 0.20182060529747137, 0.17857461789159057, 0.19558219385245745, 0.3284205134415502, 0.006407430175517814, 0.36619250372402334, 0.2259926234100389, 0.08079187747567196, 0.3566449764797007, 0.08114697349173805, 0.7344845036158891, 0.7483427178164258, 0.7486489878661621, 0.7518594363355056, 0.7634733283067978, 0.802694999760851, 0.6843882425772356, 0.7299911756040789, 0.7593858556799229, 0.07580857596923452, 0.14444118890065638, 0.10268166408293322, 0.14555068634590862, 0.1133105093208967, 0.7033352848670488, 0.1039592203854578, 0.07995791523730145, 0.10458196920510487, 0.1700282082103276, 0.6464594007522839, 0.23788986441283433, 0.24848668452709644, 0.26787452178738946, 0.19298062414556083, 0.421872478808335, 0.19843099372711004, 0.26917347133106273, 0.5491013415157248, 0.33311292285246896, 0.47831967790630825, 0.2510770234307901, 0.24692705852935903, 0.48035384518917157, 0.23665669042404747, 0.42822797182165473, 0.30575513751038663, 0.1384240955857755, 0.21920609124034363, 0.2686337200810871, 0.3370099124725975, 0.27722345291883144, 0.2798287908940785, 0.15815476806470508, 0.3293521774471102, 0.31052351305580883, 0.21880804130783393, 0.23147323015166554, 0.21474406873959928, 0.20490956936190807, 0.23457103325372197, 0.2437305802702212, 0.2149709844811336, 0.2439850908753306, 0.23335761715769676, 0.22350210307888363, 0.18574197878039322, 0.17837020396905356, 0.2155230598069725, 0.19237625339917275, 0.19959724030473103, 0.17669365044360585, 0.21076136807788703, 0.20118337457794033, 0.9214437223791965, 0.1752419304252275, 0.14813261835915315, 0.9234731888523364, 0.1891957800520545, 0.20075856307887285, 0.14236009654782922, 0.16951293172035564, 0.9211706307592998, 0.8938069567687922, 0.21337860007900866, 0.8903324751288573, 0.8659545435144563, 0.8852123370256878, 0.15603433731549, 0.7809371264146462, 0.8691346964491866, 0.8944526734985341, 0.20381020220067825, 0.1898466526025595, 0.19237450905935372, 0.17981768391588937, 0.21853539690398427, 0.19684832418329457, 0.1848171428814328, 0.22912533053187922, 0.19210062702914676, 0.09359997277557464, 0.08913187308574833, 0.07349795134290049, 0.1072000129024635, 0.10987724557902478, 0.1309134338923733, 0.0948732229011211, 0.08903264488315288, 0.0935723001019283]}, "mutation_prompt": null}
{"id": "7400ed91-7346-4a6e-be5f-a3b761855248", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Slightly reduced population for efficiency\n        self.w = 0.5  # Adjusted inertia weight for better balance between exploration and exploitation\n        self.cr = 0.9  # Higher crossover rate to encourage exploration\n        self.f1 = 0.5  # Increased mutation factor for stronger primary exploration\n        self.f2 = 0.6  # Adjusted secondary mutation factor for balance\n        self.q_prob = 0.1  # New quantum probability factor for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                if np.random.rand() < self.q_prob:\n                    quantum_shift = np.random.uniform(-1, 1, self.dim)\n                    mutant = global_best + quantum_shift * (x1 - x2)\n                else:\n                    if np.random.rand() < 0.5:\n                        mutant = x0 + self.f1 * (x1 - x2) + self.f1 * (x2 - x3)\n                    else:\n                        mutant = x0 + self.f2 * (global_best - personal_best[i]) + self.f2 * (x1 - x2)\n\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n\n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.w = 0.3 + 0.3 * (1 - evaluations / self.budget)  # Dynamic inertia adjustment\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n                f_val = func(population[i])\n                evaluations += 1\n\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n\n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n        return global_best", "name": "AdaptiveQuantumHybridSwarm", "description": "An Adaptive Quantum-Inspired Hybrid Swarm Algorithm enhancing diversity and convergence through quantum mechanics concepts and adaptive dynamic techniques.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75c77c35-a246-4a87-a69a-b2a131576f2e", "metadata": {"aucs": [0.8732496514529094, 0.8573013930713151, 0.8744986549559657, 0.8537495192369189, 0.8604165374218101, 0.8715142837348789, 0.8704099284618737, 0.8739727116974925, 0.866791729775093, 0.6147791287774991, 0.5226600881736632, 0.6008666291934257, 0.6011496292940641, 0.5712684505558844, 0.6359510051857422, 0.045908637116616746, 0.01791592251565577, 0.624806402963642, 0.1413067638663884, 0.11049529921804513, 0.14184049273655452, 0.1027592472363914, 0.07083301263806674, 0.12002114502220551, 0.12881546204892624, 0.12197346576387535, 0.14062731601841005, 0.10096466446710328, 0.05413792712396226, 0.09114897185600312, 0.11617455852670533, 0.10909181187858685, 0.1132573468606426, 0.09365470587791058, 0.10954479806391282, 0.06924766798411386, 0.9775912343458948, 0.9856918600781291, 0.9862987405660498, 0.9770175651747988, 0.9778520464721582, 0.9781512659494478, 0.9875080020708764, 0.984098099287295, 0.9849954146772911, 0.7809659532660893, 0.7422826837075494, 0.7507287728082499, 0.7671760563977873, 0.7605455519964089, 0.7573331744633285, 0.7679600916906688, 0.747325999217636, 0.7792914648411364, 0.17111748920970027, 0.3776430589145463, 0.2148095429947724, 0.2812462563154454, 0.8986407239240541, 0.19204913894860254, 0.8747754320911039, 0.875000117318375, 0.868387248003844, 0.7632216912436319, 0.706558114179277, 0.6234648388250588, 0.13136984499800142, 0.7085088269387997, 0.6506806316873934, 0.6826924943191606, 0.6992691458062947, 0.6583057288686354, 0.734243198366002, 0.13115796893246556, 0.6705233511355073, 0.7082745516843774, 0.6388044637379255, 0.1341526369084951, 0.6743382872976676, 0.5567792737889925, 0.13081659118311728, 0.31827943748047594, 9.999999999998899e-05, 0.06633577084044773, 0.5390449000464439, 0.5270845928542385, 9.999999999998899e-05, 0.4392765556044851, 0.008076823072002082, 0.26222948519668543, 0.24804397985012738, 0.36024896744948254, 0.5288676387803491, 0.157319205348598, 0.17810397592288285, 0.6509838503096024, 0.6551795148357473, 0.6692466142047369, 0.6019556617371273, 0.06668243159341114, 0.26091536276258476, 0.22968957066875362, 0.30011996004245634, 0.09151287932329799, 0.3578498530294587, 0.2206967922068861, 0.3854711628213495, 0.20182060529747137, 0.17857461789159057, 0.19558219385245745, 0.3284205134415502, 0.006407430175517814, 0.36619250372402334, 0.2259926234100389, 0.08079187747567196, 0.3566449764797007, 0.08114697349173805, 0.7344845036158891, 0.7483427178164258, 0.7486489878661621, 0.7518594363355056, 0.7634733283067978, 0.802694999760851, 0.6843882425772356, 0.7299911756040789, 0.7593858556799229, 0.07580857596923452, 0.14444118890065638, 0.10268166408293322, 0.14555068634590862, 0.1133105093208967, 0.7033352848670488, 0.1039592203854578, 0.07995791523730145, 0.10458196920510487, 0.1700282082103276, 0.6464594007522839, 0.23788986441283433, 0.24848668452709644, 0.26787452178738946, 0.19298062414556083, 0.421872478808335, 0.19843099372711004, 0.26917347133106273, 0.5491013415157248, 0.33311292285246896, 0.47831967790630825, 0.2510770234307901, 0.24692705852935903, 0.48035384518917157, 0.23665669042404747, 0.42822797182165473, 0.30575513751038663, 0.1384240955857755, 0.21920609124034363, 0.2686337200810871, 0.3370099124725975, 0.27722345291883144, 0.2798287908940785, 0.15815476806470508, 0.3293521774471102, 0.31052351305580883, 0.21880804130783393, 0.23147323015166554, 0.21474406873959928, 0.20490956936190807, 0.23457103325372197, 0.2437305802702212, 0.2149709844811336, 0.2439850908753306, 0.23335761715769676, 0.22350210307888363, 0.18574197878039322, 0.17837020396905356, 0.2155230598069725, 0.19237625339917275, 0.19959724030473103, 0.17669365044360585, 0.21076136807788703, 0.20118337457794033, 0.9214437223791965, 0.1752419304252275, 0.14813261835915315, 0.9234731888523364, 0.1891957800520545, 0.20075856307887285, 0.14236009654782922, 0.16951293172035564, 0.9211706307592998, 0.8938069567687922, 0.21337860007900866, 0.8903324751288573, 0.8659545435144563, 0.8852123370256878, 0.15603433731549, 0.7809371264146462, 0.8691346964491866, 0.8944526734985341, 0.20381020220067825, 0.1898466526025595, 0.19237450905935372, 0.17981768391588937, 0.21853539690398427, 0.19684832418329457, 0.1848171428814328, 0.22912533053187922, 0.19210062702914676, 0.09359997277557464, 0.08913187308574833, 0.07349795134290049, 0.1072000129024635, 0.10987724557902478, 0.1309134338923733, 0.0948732229011211, 0.08903264488315288, 0.0935723001019283]}, "mutation_prompt": null}
{"id": "b97426e8-78ba-47c6-8c97-d0ca57bc0416", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Slightly reduced population for efficiency\n        self.w = 0.5  # Adjusted inertia weight for better balance between exploration and exploitation\n        self.cr = 0.9  # Higher crossover rate to encourage exploration\n        self.f1 = 0.5  # Increased mutation factor for stronger primary exploration\n        self.f2 = 0.6  # Adjusted secondary mutation factor for balance\n        self.q_prob = 0.1  # New quantum probability factor for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                if np.random.rand() < self.q_prob:\n                    quantum_shift = np.random.uniform(-1, 1, self.dim)\n                    mutant = global_best + quantum_shift * (x1 - x2)\n                else:\n                    if np.random.rand() < 0.5:\n                        mutant = x0 + self.f1 * (x1 - x2) + self.f1 * (x2 - x3)\n                    else:\n                        mutant = x0 + self.f2 * (global_best - personal_best[i]) + self.f2 * (x1 - x2)\n\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n\n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.w = 0.3 + 0.3 * (1 - evaluations / self.budget)  # Dynamic inertia adjustment\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n                f_val = func(population[i])\n                evaluations += 1\n\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n\n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n        return global_best", "name": "AdaptiveQuantumHybridSwarm", "description": "An Adaptive Quantum-Inspired Hybrid Swarm Algorithm enhancing diversity and convergence through quantum mechanics concepts and adaptive dynamic techniques.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75c77c35-a246-4a87-a69a-b2a131576f2e", "metadata": {"aucs": [0.8732496514529094, 0.8573013930713151, 0.8744986549559657, 0.8537495192369189, 0.8604165374218101, 0.8715142837348789, 0.8704099284618737, 0.8739727116974925, 0.866791729775093, 0.6147791287774991, 0.5226600881736632, 0.6008666291934257, 0.6011496292940641, 0.5712684505558844, 0.6359510051857422, 0.045908637116616746, 0.01791592251565577, 0.624806402963642, 0.1413067638663884, 0.11049529921804513, 0.14184049273655452, 0.1027592472363914, 0.07083301263806674, 0.12002114502220551, 0.12881546204892624, 0.12197346576387535, 0.14062731601841005, 0.10096466446710328, 0.05413792712396226, 0.09114897185600312, 0.11617455852670533, 0.10909181187858685, 0.1132573468606426, 0.09365470587791058, 0.10954479806391282, 0.06924766798411386, 0.9775912343458948, 0.9856918600781291, 0.9862987405660498, 0.9770175651747988, 0.9778520464721582, 0.9781512659494478, 0.9875080020708764, 0.984098099287295, 0.9849954146772911, 0.7809659532660893, 0.7422826837075494, 0.7507287728082499, 0.7671760563977873, 0.7605455519964089, 0.7573331744633285, 0.7679600916906688, 0.747325999217636, 0.7792914648411364, 0.17111748920970027, 0.3776430589145463, 0.2148095429947724, 0.2812462563154454, 0.8986407239240541, 0.19204913894860254, 0.8747754320911039, 0.875000117318375, 0.868387248003844, 0.7632216912436319, 0.706558114179277, 0.6234648388250588, 0.13136984499800142, 0.7085088269387997, 0.6506806316873934, 0.6826924943191606, 0.6992691458062947, 0.6583057288686354, 0.734243198366002, 0.13115796893246556, 0.6705233511355073, 0.7082745516843774, 0.6388044637379255, 0.1341526369084951, 0.6743382872976676, 0.5567792737889925, 0.13081659118311728, 0.31827943748047594, 9.999999999998899e-05, 0.06633577084044773, 0.5390449000464439, 0.5270845928542385, 9.999999999998899e-05, 0.4392765556044851, 0.008076823072002082, 0.26222948519668543, 0.24804397985012738, 0.36024896744948254, 0.5288676387803491, 0.157319205348598, 0.17810397592288285, 0.6509838503096024, 0.6551795148357473, 0.6692466142047369, 0.6019556617371273, 0.06668243159341114, 0.26091536276258476, 0.22968957066875362, 0.30011996004245634, 0.09151287932329799, 0.3578498530294587, 0.2206967922068861, 0.3854711628213495, 0.20182060529747137, 0.17857461789159057, 0.19558219385245745, 0.3284205134415502, 0.006407430175517814, 0.36619250372402334, 0.2259926234100389, 0.08079187747567196, 0.3566449764797007, 0.08114697349173805, 0.7344845036158891, 0.7483427178164258, 0.7486489878661621, 0.7518594363355056, 0.7634733283067978, 0.802694999760851, 0.6843882425772356, 0.7299911756040789, 0.7593858556799229, 0.07580857596923452, 0.14444118890065638, 0.10268166408293322, 0.14555068634590862, 0.1133105093208967, 0.7033352848670488, 0.1039592203854578, 0.07995791523730145, 0.10458196920510487, 0.1700282082103276, 0.6464594007522839, 0.23788986441283433, 0.24848668452709644, 0.26787452178738946, 0.19298062414556083, 0.421872478808335, 0.19843099372711004, 0.26917347133106273, 0.5491013415157248, 0.33311292285246896, 0.47831967790630825, 0.2510770234307901, 0.24692705852935903, 0.48035384518917157, 0.23665669042404747, 0.42822797182165473, 0.30575513751038663, 0.1384240955857755, 0.21920609124034363, 0.2686337200810871, 0.3370099124725975, 0.27722345291883144, 0.2798287908940785, 0.15815476806470508, 0.3293521774471102, 0.31052351305580883, 0.21880804130783393, 0.23147323015166554, 0.21474406873959928, 0.20490956936190807, 0.23457103325372197, 0.2437305802702212, 0.2149709844811336, 0.2439850908753306, 0.23335761715769676, 0.22350210307888363, 0.18574197878039322, 0.17837020396905356, 0.2155230598069725, 0.19237625339917275, 0.19959724030473103, 0.17669365044360585, 0.21076136807788703, 0.20118337457794033, 0.9214437223791965, 0.1752419304252275, 0.14813261835915315, 0.9234731888523364, 0.1891957800520545, 0.20075856307887285, 0.14236009654782922, 0.16951293172035564, 0.9211706307592998, 0.8938069567687922, 0.21337860007900866, 0.8903324751288573, 0.8659545435144563, 0.8852123370256878, 0.15603433731549, 0.7809371264146462, 0.8691346964491866, 0.8944526734985341, 0.20381020220067825, 0.1898466526025595, 0.19237450905935372, 0.17981768391588937, 0.21853539690398427, 0.19684832418329457, 0.1848171428814328, 0.22912533053187922, 0.19210062702914676, 0.09359997277557464, 0.08913187308574833, 0.07349795134290049, 0.1072000129024635, 0.10987724557902478, 0.1309134338923733, 0.0948732229011211, 0.08903264488315288, 0.0935723001019283]}, "mutation_prompt": null}
{"id": "9d30f0ac-ce43-4ed5-909d-33ca73d0b10d", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Slightly reduced population for efficiency\n        self.w = 0.5  # Adjusted inertia weight for better balance between exploration and exploitation\n        self.cr = 0.9  # Higher crossover rate to encourage exploration\n        self.f1 = 0.5  # Increased mutation factor for stronger primary exploration\n        self.f2 = 0.6  # Adjusted secondary mutation factor for balance\n        self.q_prob = 0.1  # New quantum probability factor for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                if np.random.rand() < self.q_prob:\n                    quantum_shift = np.random.uniform(-1, 1, self.dim)\n                    mutant = global_best + quantum_shift * (x1 - x2)\n                else:\n                    if np.random.rand() < 0.5:\n                        mutant = x0 + self.f1 * (x1 - x2) + self.f1 * (x2 - x3)\n                    else:\n                        mutant = x0 + self.f2 * (global_best - personal_best[i]) + self.f2 * (x1 - x2)\n\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n\n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.w = 0.3 + 0.3 * (1 - evaluations / self.budget)  # Dynamic inertia adjustment\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n                f_val = func(population[i])\n                evaluations += 1\n\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n\n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n        return global_best", "name": "AdaptiveQuantumHybridSwarm", "description": "An Adaptive Quantum-Inspired Hybrid Swarm Algorithm enhancing diversity and convergence through quantum mechanics concepts and adaptive dynamic techniques.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75c77c35-a246-4a87-a69a-b2a131576f2e", "metadata": {"aucs": [0.8732496514529094, 0.8573013930713151, 0.8744986549559657, 0.8537495192369189, 0.8604165374218101, 0.8715142837348789, 0.8704099284618737, 0.8739727116974925, 0.866791729775093, 0.6147791287774991, 0.5226600881736632, 0.6008666291934257, 0.6011496292940641, 0.5712684505558844, 0.6359510051857422, 0.045908637116616746, 0.01791592251565577, 0.624806402963642, 0.1413067638663884, 0.11049529921804513, 0.14184049273655452, 0.1027592472363914, 0.07083301263806674, 0.12002114502220551, 0.12881546204892624, 0.12197346576387535, 0.14062731601841005, 0.10096466446710328, 0.05413792712396226, 0.09114897185600312, 0.11617455852670533, 0.10909181187858685, 0.1132573468606426, 0.09365470587791058, 0.10954479806391282, 0.06924766798411386, 0.9775912343458948, 0.9856918600781291, 0.9862987405660498, 0.9770175651747988, 0.9778520464721582, 0.9781512659494478, 0.9875080020708764, 0.984098099287295, 0.9849954146772911, 0.7809659532660893, 0.7422826837075494, 0.7507287728082499, 0.7671760563977873, 0.7605455519964089, 0.7573331744633285, 0.7679600916906688, 0.747325999217636, 0.7792914648411364, 0.17111748920970027, 0.3776430589145463, 0.2148095429947724, 0.2812462563154454, 0.8986407239240541, 0.19204913894860254, 0.8747754320911039, 0.875000117318375, 0.868387248003844, 0.7632216912436319, 0.706558114179277, 0.6234648388250588, 0.13136984499800142, 0.7085088269387997, 0.6506806316873934, 0.6826924943191606, 0.6992691458062947, 0.6583057288686354, 0.734243198366002, 0.13115796893246556, 0.6705233511355073, 0.7082745516843774, 0.6388044637379255, 0.1341526369084951, 0.6743382872976676, 0.5567792737889925, 0.13081659118311728, 0.31827943748047594, 9.999999999998899e-05, 0.06633577084044773, 0.5390449000464439, 0.5270845928542385, 9.999999999998899e-05, 0.4392765556044851, 0.008076823072002082, 0.26222948519668543, 0.24804397985012738, 0.36024896744948254, 0.5288676387803491, 0.157319205348598, 0.17810397592288285, 0.6509838503096024, 0.6551795148357473, 0.6692466142047369, 0.6019556617371273, 0.06668243159341114, 0.26091536276258476, 0.22968957066875362, 0.30011996004245634, 0.09151287932329799, 0.3578498530294587, 0.2206967922068861, 0.3854711628213495, 0.20182060529747137, 0.17857461789159057, 0.19558219385245745, 0.3284205134415502, 0.006407430175517814, 0.36619250372402334, 0.2259926234100389, 0.08079187747567196, 0.3566449764797007, 0.08114697349173805, 0.7344845036158891, 0.7483427178164258, 0.7486489878661621, 0.7518594363355056, 0.7634733283067978, 0.802694999760851, 0.6843882425772356, 0.7299911756040789, 0.7593858556799229, 0.07580857596923452, 0.14444118890065638, 0.10268166408293322, 0.14555068634590862, 0.1133105093208967, 0.7033352848670488, 0.1039592203854578, 0.07995791523730145, 0.10458196920510487, 0.1700282082103276, 0.6464594007522839, 0.23788986441283433, 0.24848668452709644, 0.26787452178738946, 0.19298062414556083, 0.421872478808335, 0.19843099372711004, 0.26917347133106273, 0.5491013415157248, 0.33311292285246896, 0.47831967790630825, 0.2510770234307901, 0.24692705852935903, 0.48035384518917157, 0.23665669042404747, 0.42822797182165473, 0.30575513751038663, 0.1384240955857755, 0.21920609124034363, 0.2686337200810871, 0.3370099124725975, 0.27722345291883144, 0.2798287908940785, 0.15815476806470508, 0.3293521774471102, 0.31052351305580883, 0.21880804130783393, 0.23147323015166554, 0.21474406873959928, 0.20490956936190807, 0.23457103325372197, 0.2437305802702212, 0.2149709844811336, 0.2439850908753306, 0.23335761715769676, 0.22350210307888363, 0.18574197878039322, 0.17837020396905356, 0.2155230598069725, 0.19237625339917275, 0.19959724030473103, 0.17669365044360585, 0.21076136807788703, 0.20118337457794033, 0.9214437223791965, 0.1752419304252275, 0.14813261835915315, 0.9234731888523364, 0.1891957800520545, 0.20075856307887285, 0.14236009654782922, 0.16951293172035564, 0.9211706307592998, 0.8938069567687922, 0.21337860007900866, 0.8903324751288573, 0.8659545435144563, 0.8852123370256878, 0.15603433731549, 0.7809371264146462, 0.8691346964491866, 0.8944526734985341, 0.20381020220067825, 0.1898466526025595, 0.19237450905935372, 0.17981768391588937, 0.21853539690398427, 0.19684832418329457, 0.1848171428814328, 0.22912533053187922, 0.19210062702914676, 0.09359997277557464, 0.08913187308574833, 0.07349795134290049, 0.1072000129024635, 0.10987724557902478, 0.1309134338923733, 0.0948732229011211, 0.08903264488315288, 0.0935723001019283]}, "mutation_prompt": null}
{"id": "66e2e1df-a091-4385-8e29-2041711f6196", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Slightly reduced population for efficiency\n        self.w = 0.5  # Adjusted inertia weight for better balance between exploration and exploitation\n        self.cr = 0.9  # Higher crossover rate to encourage exploration\n        self.f1 = 0.5  # Increased mutation factor for stronger primary exploration\n        self.f2 = 0.6  # Adjusted secondary mutation factor for balance\n        self.q_prob = 0.1  # New quantum probability factor for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                if np.random.rand() < self.q_prob:\n                    quantum_shift = np.random.uniform(-1, 1, self.dim)\n                    mutant = global_best + quantum_shift * (x1 - x2)\n                else:\n                    if np.random.rand() < 0.5:\n                        mutant = x0 + self.f1 * (x1 - x2) + self.f1 * (x2 - x3)\n                    else:\n                        mutant = x0 + self.f2 * (global_best - personal_best[i]) + self.f2 * (x1 - x2)\n\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n\n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.w = 0.3 + 0.3 * (1 - evaluations / self.budget)  # Dynamic inertia adjustment\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n                f_val = func(population[i])\n                evaluations += 1\n\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n\n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n        return global_best", "name": "AdaptiveQuantumHybridSwarm", "description": "An Adaptive Quantum-Inspired Hybrid Swarm Algorithm enhancing diversity and convergence through quantum mechanics concepts and adaptive dynamic techniques.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75c77c35-a246-4a87-a69a-b2a131576f2e", "metadata": {"aucs": [0.8732496514529094, 0.8573013930713151, 0.8744986549559657, 0.8537495192369189, 0.8604165374218101, 0.8715142837348789, 0.8704099284618737, 0.8739727116974925, 0.866791729775093, 0.6147791287774991, 0.5226600881736632, 0.6008666291934257, 0.6011496292940641, 0.5712684505558844, 0.6359510051857422, 0.045908637116616746, 0.01791592251565577, 0.624806402963642, 0.1413067638663884, 0.11049529921804513, 0.14184049273655452, 0.1027592472363914, 0.07083301263806674, 0.12002114502220551, 0.12881546204892624, 0.12197346576387535, 0.14062731601841005, 0.10096466446710328, 0.05413792712396226, 0.09114897185600312, 0.11617455852670533, 0.10909181187858685, 0.1132573468606426, 0.09365470587791058, 0.10954479806391282, 0.06924766798411386, 0.9775912343458948, 0.9856918600781291, 0.9862987405660498, 0.9770175651747988, 0.9778520464721582, 0.9781512659494478, 0.9875080020708764, 0.984098099287295, 0.9849954146772911, 0.7809659532660893, 0.7422826837075494, 0.7507287728082499, 0.7671760563977873, 0.7605455519964089, 0.7573331744633285, 0.7679600916906688, 0.747325999217636, 0.7792914648411364, 0.17111748920970027, 0.3776430589145463, 0.2148095429947724, 0.2812462563154454, 0.8986407239240541, 0.19204913894860254, 0.8747754320911039, 0.875000117318375, 0.868387248003844, 0.7632216912436319, 0.706558114179277, 0.6234648388250588, 0.13136984499800142, 0.7085088269387997, 0.6506806316873934, 0.6826924943191606, 0.6992691458062947, 0.6583057288686354, 0.734243198366002, 0.13115796893246556, 0.6705233511355073, 0.7082745516843774, 0.6388044637379255, 0.1341526369084951, 0.6743382872976676, 0.5567792737889925, 0.13081659118311728, 0.31827943748047594, 9.999999999998899e-05, 0.06633577084044773, 0.5390449000464439, 0.5270845928542385, 9.999999999998899e-05, 0.4392765556044851, 0.008076823072002082, 0.26222948519668543, 0.24804397985012738, 0.36024896744948254, 0.5288676387803491, 0.157319205348598, 0.17810397592288285, 0.6509838503096024, 0.6551795148357473, 0.6692466142047369, 0.6019556617371273, 0.06668243159341114, 0.26091536276258476, 0.22968957066875362, 0.30011996004245634, 0.09151287932329799, 0.3578498530294587, 0.2206967922068861, 0.3854711628213495, 0.20182060529747137, 0.17857461789159057, 0.19558219385245745, 0.3284205134415502, 0.006407430175517814, 0.36619250372402334, 0.2259926234100389, 0.08079187747567196, 0.3566449764797007, 0.08114697349173805, 0.7344845036158891, 0.7483427178164258, 0.7486489878661621, 0.7518594363355056, 0.7634733283067978, 0.802694999760851, 0.6843882425772356, 0.7299911756040789, 0.7593858556799229, 0.07580857596923452, 0.14444118890065638, 0.10268166408293322, 0.14555068634590862, 0.1133105093208967, 0.7033352848670488, 0.1039592203854578, 0.07995791523730145, 0.10458196920510487, 0.1700282082103276, 0.6464594007522839, 0.23788986441283433, 0.24848668452709644, 0.26787452178738946, 0.19298062414556083, 0.421872478808335, 0.19843099372711004, 0.26917347133106273, 0.5491013415157248, 0.33311292285246896, 0.47831967790630825, 0.2510770234307901, 0.24692705852935903, 0.48035384518917157, 0.23665669042404747, 0.42822797182165473, 0.30575513751038663, 0.1384240955857755, 0.21920609124034363, 0.2686337200810871, 0.3370099124725975, 0.27722345291883144, 0.2798287908940785, 0.15815476806470508, 0.3293521774471102, 0.31052351305580883, 0.21880804130783393, 0.23147323015166554, 0.21474406873959928, 0.20490956936190807, 0.23457103325372197, 0.2437305802702212, 0.2149709844811336, 0.2439850908753306, 0.23335761715769676, 0.22350210307888363, 0.18574197878039322, 0.17837020396905356, 0.2155230598069725, 0.19237625339917275, 0.19959724030473103, 0.17669365044360585, 0.21076136807788703, 0.20118337457794033, 0.9214437223791965, 0.1752419304252275, 0.14813261835915315, 0.9234731888523364, 0.1891957800520545, 0.20075856307887285, 0.14236009654782922, 0.16951293172035564, 0.9211706307592998, 0.8938069567687922, 0.21337860007900866, 0.8903324751288573, 0.8659545435144563, 0.8852123370256878, 0.15603433731549, 0.7809371264146462, 0.8691346964491866, 0.8944526734985341, 0.20381020220067825, 0.1898466526025595, 0.19237450905935372, 0.17981768391588937, 0.21853539690398427, 0.19684832418329457, 0.1848171428814328, 0.22912533053187922, 0.19210062702914676, 0.09359997277557464, 0.08913187308574833, 0.07349795134290049, 0.1072000129024635, 0.10987724557902478, 0.1309134338923733, 0.0948732229011211, 0.08903264488315288, 0.0935723001019283]}, "mutation_prompt": null}
{"id": "dfb11b0b-983d-4260-97c8-3152430aa7ad", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Slightly reduced population for efficiency\n        self.w = 0.5  # Adjusted inertia weight for better balance between exploration and exploitation\n        self.cr = 0.9  # Higher crossover rate to encourage exploration\n        self.f1 = 0.5  # Increased mutation factor for stronger primary exploration\n        self.f2 = 0.6  # Adjusted secondary mutation factor for balance\n        self.q_prob = 0.1  # New quantum probability factor for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                if np.random.rand() < self.q_prob:\n                    quantum_shift = np.random.uniform(-1, 1, self.dim)\n                    mutant = global_best + quantum_shift * (x1 - x2)\n                else:\n                    if np.random.rand() < 0.5:\n                        mutant = x0 + self.f1 * (x1 - x2) + self.f1 * (x2 - x3)\n                    else:\n                        mutant = x0 + self.f2 * (global_best - personal_best[i]) + self.f2 * (x1 - x2)\n\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n\n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.w = 0.3 + 0.3 * (1 - evaluations / self.budget)  # Dynamic inertia adjustment\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n                f_val = func(population[i])\n                evaluations += 1\n\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n\n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n        return global_best", "name": "AdaptiveQuantumHybridSwarm", "description": "An Adaptive Quantum-Inspired Hybrid Swarm Algorithm enhancing diversity and convergence through quantum mechanics concepts and adaptive dynamic techniques.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75c77c35-a246-4a87-a69a-b2a131576f2e", "metadata": {"aucs": [0.8732496514529094, 0.8573013930713151, 0.8744986549559657, 0.8537495192369189, 0.8604165374218101, 0.8715142837348789, 0.8704099284618737, 0.8739727116974925, 0.866791729775093, 0.6147791287774991, 0.5226600881736632, 0.6008666291934257, 0.6011496292940641, 0.5712684505558844, 0.6359510051857422, 0.045908637116616746, 0.01791592251565577, 0.624806402963642, 0.1413067638663884, 0.11049529921804513, 0.14184049273655452, 0.1027592472363914, 0.07083301263806674, 0.12002114502220551, 0.12881546204892624, 0.12197346576387535, 0.14062731601841005, 0.10096466446710328, 0.05413792712396226, 0.09114897185600312, 0.11617455852670533, 0.10909181187858685, 0.1132573468606426, 0.09365470587791058, 0.10954479806391282, 0.06924766798411386, 0.9775912343458948, 0.9856918600781291, 0.9862987405660498, 0.9770175651747988, 0.9778520464721582, 0.9781512659494478, 0.9875080020708764, 0.984098099287295, 0.9849954146772911, 0.7809659532660893, 0.7422826837075494, 0.7507287728082499, 0.7671760563977873, 0.7605455519964089, 0.7573331744633285, 0.7679600916906688, 0.747325999217636, 0.7792914648411364, 0.17111748920970027, 0.3776430589145463, 0.2148095429947724, 0.2812462563154454, 0.8986407239240541, 0.19204913894860254, 0.8747754320911039, 0.875000117318375, 0.868387248003844, 0.7632216912436319, 0.706558114179277, 0.6234648388250588, 0.13136984499800142, 0.7085088269387997, 0.6506806316873934, 0.6826924943191606, 0.6992691458062947, 0.6583057288686354, 0.734243198366002, 0.13115796893246556, 0.6705233511355073, 0.7082745516843774, 0.6388044637379255, 0.1341526369084951, 0.6743382872976676, 0.5567792737889925, 0.13081659118311728, 0.31827943748047594, 9.999999999998899e-05, 0.06633577084044773, 0.5390449000464439, 0.5270845928542385, 9.999999999998899e-05, 0.4392765556044851, 0.008076823072002082, 0.26222948519668543, 0.24804397985012738, 0.36024896744948254, 0.5288676387803491, 0.157319205348598, 0.17810397592288285, 0.6509838503096024, 0.6551795148357473, 0.6692466142047369, 0.6019556617371273, 0.06668243159341114, 0.26091536276258476, 0.22968957066875362, 0.30011996004245634, 0.09151287932329799, 0.3578498530294587, 0.2206967922068861, 0.3854711628213495, 0.20182060529747137, 0.17857461789159057, 0.19558219385245745, 0.3284205134415502, 0.006407430175517814, 0.36619250372402334, 0.2259926234100389, 0.08079187747567196, 0.3566449764797007, 0.08114697349173805, 0.7344845036158891, 0.7483427178164258, 0.7486489878661621, 0.7518594363355056, 0.7634733283067978, 0.802694999760851, 0.6843882425772356, 0.7299911756040789, 0.7593858556799229, 0.07580857596923452, 0.14444118890065638, 0.10268166408293322, 0.14555068634590862, 0.1133105093208967, 0.7033352848670488, 0.1039592203854578, 0.07995791523730145, 0.10458196920510487, 0.1700282082103276, 0.6464594007522839, 0.23788986441283433, 0.24848668452709644, 0.26787452178738946, 0.19298062414556083, 0.421872478808335, 0.19843099372711004, 0.26917347133106273, 0.5491013415157248, 0.33311292285246896, 0.47831967790630825, 0.2510770234307901, 0.24692705852935903, 0.48035384518917157, 0.23665669042404747, 0.42822797182165473, 0.30575513751038663, 0.1384240955857755, 0.21920609124034363, 0.2686337200810871, 0.3370099124725975, 0.27722345291883144, 0.2798287908940785, 0.15815476806470508, 0.3293521774471102, 0.31052351305580883, 0.21880804130783393, 0.23147323015166554, 0.21474406873959928, 0.20490956936190807, 0.23457103325372197, 0.2437305802702212, 0.2149709844811336, 0.2439850908753306, 0.23335761715769676, 0.22350210307888363, 0.18574197878039322, 0.17837020396905356, 0.2155230598069725, 0.19237625339917275, 0.19959724030473103, 0.17669365044360585, 0.21076136807788703, 0.20118337457794033, 0.9214437223791965, 0.1752419304252275, 0.14813261835915315, 0.9234731888523364, 0.1891957800520545, 0.20075856307887285, 0.14236009654782922, 0.16951293172035564, 0.9211706307592998, 0.8938069567687922, 0.21337860007900866, 0.8903324751288573, 0.8659545435144563, 0.8852123370256878, 0.15603433731549, 0.7809371264146462, 0.8691346964491866, 0.8944526734985341, 0.20381020220067825, 0.1898466526025595, 0.19237450905935372, 0.17981768391588937, 0.21853539690398427, 0.19684832418329457, 0.1848171428814328, 0.22912533053187922, 0.19210062702914676, 0.09359997277557464, 0.08913187308574833, 0.07349795134290049, 0.1072000129024635, 0.10987724557902478, 0.1309134338923733, 0.0948732229011211, 0.08903264488315288, 0.0935723001019283]}, "mutation_prompt": null}
{"id": "ab965524-ca63-4d7a-a5a3-37e915dfae6c", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Slightly reduced population for efficiency\n        self.w = 0.5  # Adjusted inertia weight for better balance between exploration and exploitation\n        self.cr = 0.9  # Higher crossover rate to encourage exploration\n        self.f1 = 0.5  # Increased mutation factor for stronger primary exploration\n        self.f2 = 0.6  # Adjusted secondary mutation factor for balance\n        self.q_prob = 0.1  # New quantum probability factor for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                if np.random.rand() < self.q_prob:\n                    quantum_shift = np.random.uniform(-1, 1, self.dim)\n                    mutant = global_best + quantum_shift * (x1 - x2)\n                else:\n                    if np.random.rand() < 0.5:\n                        mutant = x0 + self.f1 * (x1 - x2) + self.f1 * (x2 - x3)\n                    else:\n                        mutant = x0 + self.f2 * (global_best - personal_best[i]) + self.f2 * (x1 - x2)\n\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n\n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.w = 0.3 + 0.3 * (1 - evaluations / self.budget)  # Dynamic inertia adjustment\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n                f_val = func(population[i])\n                evaluations += 1\n\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n\n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n        return global_best", "name": "AdaptiveQuantumHybridSwarm", "description": "An Adaptive Quantum-Inspired Hybrid Swarm Algorithm enhancing diversity and convergence through quantum mechanics concepts and adaptive dynamic techniques.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75c77c35-a246-4a87-a69a-b2a131576f2e", "metadata": {"aucs": [0.8732496514529094, 0.8573013930713151, 0.8744986549559657, 0.8537495192369189, 0.8604165374218101, 0.8715142837348789, 0.8704099284618737, 0.8739727116974925, 0.866791729775093, 0.6147791287774991, 0.5226600881736632, 0.6008666291934257, 0.6011496292940641, 0.5712684505558844, 0.6359510051857422, 0.045908637116616746, 0.01791592251565577, 0.624806402963642, 0.1413067638663884, 0.11049529921804513, 0.14184049273655452, 0.1027592472363914, 0.07083301263806674, 0.12002114502220551, 0.12881546204892624, 0.12197346576387535, 0.14062731601841005, 0.10096466446710328, 0.05413792712396226, 0.09114897185600312, 0.11617455852670533, 0.10909181187858685, 0.1132573468606426, 0.09365470587791058, 0.10954479806391282, 0.06924766798411386, 0.9775912343458948, 0.9856918600781291, 0.9862987405660498, 0.9770175651747988, 0.9778520464721582, 0.9781512659494478, 0.9875080020708764, 0.984098099287295, 0.9849954146772911, 0.7809659532660893, 0.7422826837075494, 0.7507287728082499, 0.7671760563977873, 0.7605455519964089, 0.7573331744633285, 0.7679600916906688, 0.747325999217636, 0.7792914648411364, 0.17111748920970027, 0.3776430589145463, 0.2148095429947724, 0.2812462563154454, 0.8986407239240541, 0.19204913894860254, 0.8747754320911039, 0.875000117318375, 0.868387248003844, 0.7632216912436319, 0.706558114179277, 0.6234648388250588, 0.13136984499800142, 0.7085088269387997, 0.6506806316873934, 0.6826924943191606, 0.6992691458062947, 0.6583057288686354, 0.734243198366002, 0.13115796893246556, 0.6705233511355073, 0.7082745516843774, 0.6388044637379255, 0.1341526369084951, 0.6743382872976676, 0.5567792737889925, 0.13081659118311728, 0.31827943748047594, 9.999999999998899e-05, 0.06633577084044773, 0.5390449000464439, 0.5270845928542385, 9.999999999998899e-05, 0.4392765556044851, 0.008076823072002082, 0.26222948519668543, 0.24804397985012738, 0.36024896744948254, 0.5288676387803491, 0.157319205348598, 0.17810397592288285, 0.6509838503096024, 0.6551795148357473, 0.6692466142047369, 0.6019556617371273, 0.06668243159341114, 0.26091536276258476, 0.22968957066875362, 0.30011996004245634, 0.09151287932329799, 0.3578498530294587, 0.2206967922068861, 0.3854711628213495, 0.20182060529747137, 0.17857461789159057, 0.19558219385245745, 0.3284205134415502, 0.006407430175517814, 0.36619250372402334, 0.2259926234100389, 0.08079187747567196, 0.3566449764797007, 0.08114697349173805, 0.7344845036158891, 0.7483427178164258, 0.7486489878661621, 0.7518594363355056, 0.7634733283067978, 0.802694999760851, 0.6843882425772356, 0.7299911756040789, 0.7593858556799229, 0.07580857596923452, 0.14444118890065638, 0.10268166408293322, 0.14555068634590862, 0.1133105093208967, 0.7033352848670488, 0.1039592203854578, 0.07995791523730145, 0.10458196920510487, 0.1700282082103276, 0.6464594007522839, 0.23788986441283433, 0.24848668452709644, 0.26787452178738946, 0.19298062414556083, 0.421872478808335, 0.19843099372711004, 0.26917347133106273, 0.5491013415157248, 0.33311292285246896, 0.47831967790630825, 0.2510770234307901, 0.24692705852935903, 0.48035384518917157, 0.23665669042404747, 0.42822797182165473, 0.30575513751038663, 0.1384240955857755, 0.21920609124034363, 0.2686337200810871, 0.3370099124725975, 0.27722345291883144, 0.2798287908940785, 0.15815476806470508, 0.3293521774471102, 0.31052351305580883, 0.21880804130783393, 0.23147323015166554, 0.21474406873959928, 0.20490956936190807, 0.23457103325372197, 0.2437305802702212, 0.2149709844811336, 0.2439850908753306, 0.23335761715769676, 0.22350210307888363, 0.18574197878039322, 0.17837020396905356, 0.2155230598069725, 0.19237625339917275, 0.19959724030473103, 0.17669365044360585, 0.21076136807788703, 0.20118337457794033, 0.9214437223791965, 0.1752419304252275, 0.14813261835915315, 0.9234731888523364, 0.1891957800520545, 0.20075856307887285, 0.14236009654782922, 0.16951293172035564, 0.9211706307592998, 0.8938069567687922, 0.21337860007900866, 0.8903324751288573, 0.8659545435144563, 0.8852123370256878, 0.15603433731549, 0.7809371264146462, 0.8691346964491866, 0.8944526734985341, 0.20381020220067825, 0.1898466526025595, 0.19237450905935372, 0.17981768391588937, 0.21853539690398427, 0.19684832418329457, 0.1848171428814328, 0.22912533053187922, 0.19210062702914676, 0.09359997277557464, 0.08913187308574833, 0.07349795134290049, 0.1072000129024635, 0.10987724557902478, 0.1309134338923733, 0.0948732229011211, 0.08903264488315288, 0.0935723001019283]}, "mutation_prompt": null}
{"id": "e087c692-4919-4902-b787-a45b52f89e4b", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Slightly reduced population for efficiency\n        self.w = 0.5  # Adjusted inertia weight for better balance between exploration and exploitation\n        self.cr = 0.9  # Higher crossover rate to encourage exploration\n        self.f1 = 0.5  # Increased mutation factor for stronger primary exploration\n        self.f2 = 0.6  # Adjusted secondary mutation factor for balance\n        self.q_prob = 0.1  # New quantum probability factor for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                if np.random.rand() < self.q_prob:\n                    quantum_shift = np.random.uniform(-1, 1, self.dim)\n                    mutant = global_best + quantum_shift * (x1 - x2)\n                else:\n                    if np.random.rand() < 0.5:\n                        mutant = x0 + self.f1 * (x1 - x2) + self.f1 * (x2 - x3)\n                    else:\n                        mutant = x0 + self.f2 * (global_best - personal_best[i]) + self.f2 * (x1 - x2)\n\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n\n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.w = 0.3 + 0.3 * (1 - evaluations / self.budget)  # Dynamic inertia adjustment\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n                f_val = func(population[i])\n                evaluations += 1\n\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n\n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n        return global_best", "name": "AdaptiveQuantumHybridSwarm", "description": "An Adaptive Quantum-Inspired Hybrid Swarm Algorithm enhancing diversity and convergence through quantum mechanics concepts and adaptive dynamic techniques.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75c77c35-a246-4a87-a69a-b2a131576f2e", "metadata": {"aucs": [0.8732496514529094, 0.8573013930713151, 0.8744986549559657, 0.8537495192369189, 0.8604165374218101, 0.8715142837348789, 0.8704099284618737, 0.8739727116974925, 0.866791729775093, 0.6147791287774991, 0.5226600881736632, 0.6008666291934257, 0.6011496292940641, 0.5712684505558844, 0.6359510051857422, 0.045908637116616746, 0.01791592251565577, 0.624806402963642, 0.1413067638663884, 0.11049529921804513, 0.14184049273655452, 0.1027592472363914, 0.07083301263806674, 0.12002114502220551, 0.12881546204892624, 0.12197346576387535, 0.14062731601841005, 0.10096466446710328, 0.05413792712396226, 0.09114897185600312, 0.11617455852670533, 0.10909181187858685, 0.1132573468606426, 0.09365470587791058, 0.10954479806391282, 0.06924766798411386, 0.9775912343458948, 0.9856918600781291, 0.9862987405660498, 0.9770175651747988, 0.9778520464721582, 0.9781512659494478, 0.9875080020708764, 0.984098099287295, 0.9849954146772911, 0.7809659532660893, 0.7422826837075494, 0.7507287728082499, 0.7671760563977873, 0.7605455519964089, 0.7573331744633285, 0.7679600916906688, 0.747325999217636, 0.7792914648411364, 0.17111748920970027, 0.3776430589145463, 0.2148095429947724, 0.2812462563154454, 0.8986407239240541, 0.19204913894860254, 0.8747754320911039, 0.875000117318375, 0.868387248003844, 0.7632216912436319, 0.706558114179277, 0.6234648388250588, 0.13136984499800142, 0.7085088269387997, 0.6506806316873934, 0.6826924943191606, 0.6992691458062947, 0.6583057288686354, 0.734243198366002, 0.13115796893246556, 0.6705233511355073, 0.7082745516843774, 0.6388044637379255, 0.1341526369084951, 0.6743382872976676, 0.5567792737889925, 0.13081659118311728, 0.31827943748047594, 9.999999999998899e-05, 0.06633577084044773, 0.5390449000464439, 0.5270845928542385, 9.999999999998899e-05, 0.4392765556044851, 0.008076823072002082, 0.26222948519668543, 0.24804397985012738, 0.36024896744948254, 0.5288676387803491, 0.157319205348598, 0.17810397592288285, 0.6509838503096024, 0.6551795148357473, 0.6692466142047369, 0.6019556617371273, 0.06668243159341114, 0.26091536276258476, 0.22968957066875362, 0.30011996004245634, 0.09151287932329799, 0.3578498530294587, 0.2206967922068861, 0.3854711628213495, 0.20182060529747137, 0.17857461789159057, 0.19558219385245745, 0.3284205134415502, 0.006407430175517814, 0.36619250372402334, 0.2259926234100389, 0.08079187747567196, 0.3566449764797007, 0.08114697349173805, 0.7344845036158891, 0.7483427178164258, 0.7486489878661621, 0.7518594363355056, 0.7634733283067978, 0.802694999760851, 0.6843882425772356, 0.7299911756040789, 0.7593858556799229, 0.07580857596923452, 0.14444118890065638, 0.10268166408293322, 0.14555068634590862, 0.1133105093208967, 0.7033352848670488, 0.1039592203854578, 0.07995791523730145, 0.10458196920510487, 0.1700282082103276, 0.6464594007522839, 0.23788986441283433, 0.24848668452709644, 0.26787452178738946, 0.19298062414556083, 0.421872478808335, 0.19843099372711004, 0.26917347133106273, 0.5491013415157248, 0.33311292285246896, 0.47831967790630825, 0.2510770234307901, 0.24692705852935903, 0.48035384518917157, 0.23665669042404747, 0.42822797182165473, 0.30575513751038663, 0.1384240955857755, 0.21920609124034363, 0.2686337200810871, 0.3370099124725975, 0.27722345291883144, 0.2798287908940785, 0.15815476806470508, 0.3293521774471102, 0.31052351305580883, 0.21880804130783393, 0.23147323015166554, 0.21474406873959928, 0.20490956936190807, 0.23457103325372197, 0.2437305802702212, 0.2149709844811336, 0.2439850908753306, 0.23335761715769676, 0.22350210307888363, 0.18574197878039322, 0.17837020396905356, 0.2155230598069725, 0.19237625339917275, 0.19959724030473103, 0.17669365044360585, 0.21076136807788703, 0.20118337457794033, 0.9214437223791965, 0.1752419304252275, 0.14813261835915315, 0.9234731888523364, 0.1891957800520545, 0.20075856307887285, 0.14236009654782922, 0.16951293172035564, 0.9211706307592998, 0.8938069567687922, 0.21337860007900866, 0.8903324751288573, 0.8659545435144563, 0.8852123370256878, 0.15603433731549, 0.7809371264146462, 0.8691346964491866, 0.8944526734985341, 0.20381020220067825, 0.1898466526025595, 0.19237450905935372, 0.17981768391588937, 0.21853539690398427, 0.19684832418329457, 0.1848171428814328, 0.22912533053187922, 0.19210062702914676, 0.09359997277557464, 0.08913187308574833, 0.07349795134290049, 0.1072000129024635, 0.10987724557902478, 0.1309134338923733, 0.0948732229011211, 0.08903264488315288, 0.0935723001019283]}, "mutation_prompt": null}
{"id": "851a0ff6-9677-48e3-a565-1bc40ee7159b", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Slightly reduced population for efficiency\n        self.w = 0.5  # Adjusted inertia weight for better balance between exploration and exploitation\n        self.cr = 0.9  # Higher crossover rate to encourage exploration\n        self.f1 = 0.5  # Increased mutation factor for stronger primary exploration\n        self.f2 = 0.6  # Adjusted secondary mutation factor for balance\n        self.q_prob = 0.1  # New quantum probability factor for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                if np.random.rand() < self.q_prob:\n                    quantum_shift = np.random.uniform(-1, 1, self.dim)\n                    mutant = global_best + quantum_shift * (x1 - x2)\n                else:\n                    if np.random.rand() < 0.5:\n                        mutant = x0 + self.f1 * (x1 - x2) + self.f1 * (x2 - x3)\n                    else:\n                        mutant = x0 + self.f2 * (global_best - personal_best[i]) + self.f2 * (x1 - x2)\n\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n\n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.w = 0.3 + 0.3 * (1 - evaluations / self.budget)  # Dynamic inertia adjustment\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n                f_val = func(population[i])\n                evaluations += 1\n\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n\n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n        return global_best", "name": "AdaptiveQuantumHybridSwarm", "description": "An Adaptive Quantum-Inspired Hybrid Swarm Algorithm enhancing diversity and convergence through quantum mechanics concepts and adaptive dynamic techniques.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75c77c35-a246-4a87-a69a-b2a131576f2e", "metadata": {"aucs": [0.8732496514529094, 0.8573013930713151, 0.8744986549559657, 0.8537495192369189, 0.8604165374218101, 0.8715142837348789, 0.8704099284618737, 0.8739727116974925, 0.866791729775093, 0.6147791287774991, 0.5226600881736632, 0.6008666291934257, 0.6011496292940641, 0.5712684505558844, 0.6359510051857422, 0.045908637116616746, 0.01791592251565577, 0.624806402963642, 0.1413067638663884, 0.11049529921804513, 0.14184049273655452, 0.1027592472363914, 0.07083301263806674, 0.12002114502220551, 0.12881546204892624, 0.12197346576387535, 0.14062731601841005, 0.10096466446710328, 0.05413792712396226, 0.09114897185600312, 0.11617455852670533, 0.10909181187858685, 0.1132573468606426, 0.09365470587791058, 0.10954479806391282, 0.06924766798411386, 0.9775912343458948, 0.9856918600781291, 0.9862987405660498, 0.9770175651747988, 0.9778520464721582, 0.9781512659494478, 0.9875080020708764, 0.984098099287295, 0.9849954146772911, 0.7809659532660893, 0.7422826837075494, 0.7507287728082499, 0.7671760563977873, 0.7605455519964089, 0.7573331744633285, 0.7679600916906688, 0.747325999217636, 0.7792914648411364, 0.17111748920970027, 0.3776430589145463, 0.2148095429947724, 0.2812462563154454, 0.8986407239240541, 0.19204913894860254, 0.8747754320911039, 0.875000117318375, 0.868387248003844, 0.7632216912436319, 0.706558114179277, 0.6234648388250588, 0.13136984499800142, 0.7085088269387997, 0.6506806316873934, 0.6826924943191606, 0.6992691458062947, 0.6583057288686354, 0.734243198366002, 0.13115796893246556, 0.6705233511355073, 0.7082745516843774, 0.6388044637379255, 0.1341526369084951, 0.6743382872976676, 0.5567792737889925, 0.13081659118311728, 0.31827943748047594, 9.999999999998899e-05, 0.06633577084044773, 0.5390449000464439, 0.5270845928542385, 9.999999999998899e-05, 0.4392765556044851, 0.008076823072002082, 0.26222948519668543, 0.24804397985012738, 0.36024896744948254, 0.5288676387803491, 0.157319205348598, 0.17810397592288285, 0.6509838503096024, 0.6551795148357473, 0.6692466142047369, 0.6019556617371273, 0.06668243159341114, 0.26091536276258476, 0.22968957066875362, 0.30011996004245634, 0.09151287932329799, 0.3578498530294587, 0.2206967922068861, 0.3854711628213495, 0.20182060529747137, 0.17857461789159057, 0.19558219385245745, 0.3284205134415502, 0.006407430175517814, 0.36619250372402334, 0.2259926234100389, 0.08079187747567196, 0.3566449764797007, 0.08114697349173805, 0.7344845036158891, 0.7483427178164258, 0.7486489878661621, 0.7518594363355056, 0.7634733283067978, 0.802694999760851, 0.6843882425772356, 0.7299911756040789, 0.7593858556799229, 0.07580857596923452, 0.14444118890065638, 0.10268166408293322, 0.14555068634590862, 0.1133105093208967, 0.7033352848670488, 0.1039592203854578, 0.07995791523730145, 0.10458196920510487, 0.1700282082103276, 0.6464594007522839, 0.23788986441283433, 0.24848668452709644, 0.26787452178738946, 0.19298062414556083, 0.421872478808335, 0.19843099372711004, 0.26917347133106273, 0.5491013415157248, 0.33311292285246896, 0.47831967790630825, 0.2510770234307901, 0.24692705852935903, 0.48035384518917157, 0.23665669042404747, 0.42822797182165473, 0.30575513751038663, 0.1384240955857755, 0.21920609124034363, 0.2686337200810871, 0.3370099124725975, 0.27722345291883144, 0.2798287908940785, 0.15815476806470508, 0.3293521774471102, 0.31052351305580883, 0.21880804130783393, 0.23147323015166554, 0.21474406873959928, 0.20490956936190807, 0.23457103325372197, 0.2437305802702212, 0.2149709844811336, 0.2439850908753306, 0.23335761715769676, 0.22350210307888363, 0.18574197878039322, 0.17837020396905356, 0.2155230598069725, 0.19237625339917275, 0.19959724030473103, 0.17669365044360585, 0.21076136807788703, 0.20118337457794033, 0.9214437223791965, 0.1752419304252275, 0.14813261835915315, 0.9234731888523364, 0.1891957800520545, 0.20075856307887285, 0.14236009654782922, 0.16951293172035564, 0.9211706307592998, 0.8938069567687922, 0.21337860007900866, 0.8903324751288573, 0.8659545435144563, 0.8852123370256878, 0.15603433731549, 0.7809371264146462, 0.8691346964491866, 0.8944526734985341, 0.20381020220067825, 0.1898466526025595, 0.19237450905935372, 0.17981768391588937, 0.21853539690398427, 0.19684832418329457, 0.1848171428814328, 0.22912533053187922, 0.19210062702914676, 0.09359997277557464, 0.08913187308574833, 0.07349795134290049, 0.1072000129024635, 0.10987724557902478, 0.1309134338923733, 0.0948732229011211, 0.08903264488315288, 0.0935723001019283]}, "mutation_prompt": null}
{"id": "6d346302-083a-45b4-9457-0abc23abae0a", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Slightly reduced population for efficiency\n        self.w = 0.5  # Adjusted inertia weight for better balance between exploration and exploitation\n        self.cr = 0.9  # Higher crossover rate to encourage exploration\n        self.f1 = 0.5  # Increased mutation factor for stronger primary exploration\n        self.f2 = 0.6  # Adjusted secondary mutation factor for balance\n        self.q_prob = 0.1  # New quantum probability factor for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                if np.random.rand() < self.q_prob:\n                    quantum_shift = np.random.uniform(-1, 1, self.dim)\n                    mutant = global_best + quantum_shift * (x1 - x2)\n                else:\n                    if np.random.rand() < 0.5:\n                        mutant = x0 + self.f1 * (x1 - x2) + self.f1 * (x2 - x3)\n                    else:\n                        mutant = x0 + self.f2 * (global_best - personal_best[i]) + self.f2 * (x1 - x2)\n\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n\n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.w = 0.3 + 0.3 * (1 - evaluations / self.budget)  # Dynamic inertia adjustment\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n                f_val = func(population[i])\n                evaluations += 1\n\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n\n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n        return global_best", "name": "AdaptiveQuantumHybridSwarm", "description": "An Adaptive Quantum-Inspired Hybrid Swarm Algorithm enhancing diversity and convergence through quantum mechanics concepts and adaptive dynamic techniques.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75c77c35-a246-4a87-a69a-b2a131576f2e", "metadata": {"aucs": [0.8732496514529094, 0.8573013930713151, 0.8744986549559657, 0.8537495192369189, 0.8604165374218101, 0.8715142837348789, 0.8704099284618737, 0.8739727116974925, 0.866791729775093, 0.6147791287774991, 0.5226600881736632, 0.6008666291934257, 0.6011496292940641, 0.5712684505558844, 0.6359510051857422, 0.045908637116616746, 0.01791592251565577, 0.624806402963642, 0.1413067638663884, 0.11049529921804513, 0.14184049273655452, 0.1027592472363914, 0.07083301263806674, 0.12002114502220551, 0.12881546204892624, 0.12197346576387535, 0.14062731601841005, 0.10096466446710328, 0.05413792712396226, 0.09114897185600312, 0.11617455852670533, 0.10909181187858685, 0.1132573468606426, 0.09365470587791058, 0.10954479806391282, 0.06924766798411386, 0.9775912343458948, 0.9856918600781291, 0.9862987405660498, 0.9770175651747988, 0.9778520464721582, 0.9781512659494478, 0.9875080020708764, 0.984098099287295, 0.9849954146772911, 0.7809659532660893, 0.7422826837075494, 0.7507287728082499, 0.7671760563977873, 0.7605455519964089, 0.7573331744633285, 0.7679600916906688, 0.747325999217636, 0.7792914648411364, 0.17111748920970027, 0.3776430589145463, 0.2148095429947724, 0.2812462563154454, 0.8986407239240541, 0.19204913894860254, 0.8747754320911039, 0.875000117318375, 0.868387248003844, 0.7632216912436319, 0.706558114179277, 0.6234648388250588, 0.13136984499800142, 0.7085088269387997, 0.6506806316873934, 0.6826924943191606, 0.6992691458062947, 0.6583057288686354, 0.734243198366002, 0.13115796893246556, 0.6705233511355073, 0.7082745516843774, 0.6388044637379255, 0.1341526369084951, 0.6743382872976676, 0.5567792737889925, 0.13081659118311728, 0.31827943748047594, 9.999999999998899e-05, 0.06633577084044773, 0.5390449000464439, 0.5270845928542385, 9.999999999998899e-05, 0.4392765556044851, 0.008076823072002082, 0.26222948519668543, 0.24804397985012738, 0.36024896744948254, 0.5288676387803491, 0.157319205348598, 0.17810397592288285, 0.6509838503096024, 0.6551795148357473, 0.6692466142047369, 0.6019556617371273, 0.06668243159341114, 0.26091536276258476, 0.22968957066875362, 0.30011996004245634, 0.09151287932329799, 0.3578498530294587, 0.2206967922068861, 0.3854711628213495, 0.20182060529747137, 0.17857461789159057, 0.19558219385245745, 0.3284205134415502, 0.006407430175517814, 0.36619250372402334, 0.2259926234100389, 0.08079187747567196, 0.3566449764797007, 0.08114697349173805, 0.7344845036158891, 0.7483427178164258, 0.7486489878661621, 0.7518594363355056, 0.7634733283067978, 0.802694999760851, 0.6843882425772356, 0.7299911756040789, 0.7593858556799229, 0.07580857596923452, 0.14444118890065638, 0.10268166408293322, 0.14555068634590862, 0.1133105093208967, 0.7033352848670488, 0.1039592203854578, 0.07995791523730145, 0.10458196920510487, 0.1700282082103276, 0.6464594007522839, 0.23788986441283433, 0.24848668452709644, 0.26787452178738946, 0.19298062414556083, 0.421872478808335, 0.19843099372711004, 0.26917347133106273, 0.5491013415157248, 0.33311292285246896, 0.47831967790630825, 0.2510770234307901, 0.24692705852935903, 0.48035384518917157, 0.23665669042404747, 0.42822797182165473, 0.30575513751038663, 0.1384240955857755, 0.21920609124034363, 0.2686337200810871, 0.3370099124725975, 0.27722345291883144, 0.2798287908940785, 0.15815476806470508, 0.3293521774471102, 0.31052351305580883, 0.21880804130783393, 0.23147323015166554, 0.21474406873959928, 0.20490956936190807, 0.23457103325372197, 0.2437305802702212, 0.2149709844811336, 0.2439850908753306, 0.23335761715769676, 0.22350210307888363, 0.18574197878039322, 0.17837020396905356, 0.2155230598069725, 0.19237625339917275, 0.19959724030473103, 0.17669365044360585, 0.21076136807788703, 0.20118337457794033, 0.9214437223791965, 0.1752419304252275, 0.14813261835915315, 0.9234731888523364, 0.1891957800520545, 0.20075856307887285, 0.14236009654782922, 0.16951293172035564, 0.9211706307592998, 0.8938069567687922, 0.21337860007900866, 0.8903324751288573, 0.8659545435144563, 0.8852123370256878, 0.15603433731549, 0.7809371264146462, 0.8691346964491866, 0.8944526734985341, 0.20381020220067825, 0.1898466526025595, 0.19237450905935372, 0.17981768391588937, 0.21853539690398427, 0.19684832418329457, 0.1848171428814328, 0.22912533053187922, 0.19210062702914676, 0.09359997277557464, 0.08913187308574833, 0.07349795134290049, 0.1072000129024635, 0.10987724557902478, 0.1309134338923733, 0.0948732229011211, 0.08903264488315288, 0.0935723001019283]}, "mutation_prompt": null}
{"id": "29041bae-d90d-4837-8960-16d6da0589a3", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Slightly reduced population for efficiency\n        self.w = 0.5  # Adjusted inertia weight for better balance between exploration and exploitation\n        self.cr = 0.9  # Higher crossover rate to encourage exploration\n        self.f1 = 0.5  # Increased mutation factor for stronger primary exploration\n        self.f2 = 0.6  # Adjusted secondary mutation factor for balance\n        self.q_prob = 0.1  # New quantum probability factor for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                if np.random.rand() < self.q_prob:\n                    quantum_shift = np.random.uniform(-1, 1, self.dim)\n                    mutant = global_best + quantum_shift * (x1 - x2)\n                else:\n                    if np.random.rand() < 0.5:\n                        mutant = x0 + self.f1 * (x1 - x2) + self.f1 * (x2 - x3)\n                    else:\n                        mutant = x0 + self.f2 * (global_best - personal_best[i]) + self.f2 * (x1 - x2)\n\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n\n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.w = 0.3 + 0.3 * (1 - evaluations / self.budget)  # Dynamic inertia adjustment\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n                f_val = func(population[i])\n                evaluations += 1\n\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n\n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n        return global_best", "name": "AdaptiveQuantumHybridSwarm", "description": "An Adaptive Quantum-Inspired Hybrid Swarm Algorithm enhancing diversity and convergence through quantum mechanics concepts and adaptive dynamic techniques.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75c77c35-a246-4a87-a69a-b2a131576f2e", "metadata": {"aucs": [0.8732496514529094, 0.8573013930713151, 0.8744986549559657, 0.8537495192369189, 0.8604165374218101, 0.8715142837348789, 0.8704099284618737, 0.8739727116974925, 0.866791729775093, 0.6147791287774991, 0.5226600881736632, 0.6008666291934257, 0.6011496292940641, 0.5712684505558844, 0.6359510051857422, 0.045908637116616746, 0.01791592251565577, 0.624806402963642, 0.1413067638663884, 0.11049529921804513, 0.14184049273655452, 0.1027592472363914, 0.07083301263806674, 0.12002114502220551, 0.12881546204892624, 0.12197346576387535, 0.14062731601841005, 0.10096466446710328, 0.05413792712396226, 0.09114897185600312, 0.11617455852670533, 0.10909181187858685, 0.1132573468606426, 0.09365470587791058, 0.10954479806391282, 0.06924766798411386, 0.9775912343458948, 0.9856918600781291, 0.9862987405660498, 0.9770175651747988, 0.9778520464721582, 0.9781512659494478, 0.9875080020708764, 0.984098099287295, 0.9849954146772911, 0.7809659532660893, 0.7422826837075494, 0.7507287728082499, 0.7671760563977873, 0.7605455519964089, 0.7573331744633285, 0.7679600916906688, 0.747325999217636, 0.7792914648411364, 0.17111748920970027, 0.3776430589145463, 0.2148095429947724, 0.2812462563154454, 0.8986407239240541, 0.19204913894860254, 0.8747754320911039, 0.875000117318375, 0.868387248003844, 0.7632216912436319, 0.706558114179277, 0.6234648388250588, 0.13136984499800142, 0.7085088269387997, 0.6506806316873934, 0.6826924943191606, 0.6992691458062947, 0.6583057288686354, 0.734243198366002, 0.13115796893246556, 0.6705233511355073, 0.7082745516843774, 0.6388044637379255, 0.1341526369084951, 0.6743382872976676, 0.5567792737889925, 0.13081659118311728, 0.31827943748047594, 9.999999999998899e-05, 0.06633577084044773, 0.5390449000464439, 0.5270845928542385, 9.999999999998899e-05, 0.4392765556044851, 0.008076823072002082, 0.26222948519668543, 0.24804397985012738, 0.36024896744948254, 0.5288676387803491, 0.157319205348598, 0.17810397592288285, 0.6509838503096024, 0.6551795148357473, 0.6692466142047369, 0.6019556617371273, 0.06668243159341114, 0.26091536276258476, 0.22968957066875362, 0.30011996004245634, 0.09151287932329799, 0.3578498530294587, 0.2206967922068861, 0.3854711628213495, 0.20182060529747137, 0.17857461789159057, 0.19558219385245745, 0.3284205134415502, 0.006407430175517814, 0.36619250372402334, 0.2259926234100389, 0.08079187747567196, 0.3566449764797007, 0.08114697349173805, 0.7344845036158891, 0.7483427178164258, 0.7486489878661621, 0.7518594363355056, 0.7634733283067978, 0.802694999760851, 0.6843882425772356, 0.7299911756040789, 0.7593858556799229, 0.07580857596923452, 0.14444118890065638, 0.10268166408293322, 0.14555068634590862, 0.1133105093208967, 0.7033352848670488, 0.1039592203854578, 0.07995791523730145, 0.10458196920510487, 0.1700282082103276, 0.6464594007522839, 0.23788986441283433, 0.24848668452709644, 0.26787452178738946, 0.19298062414556083, 0.421872478808335, 0.19843099372711004, 0.26917347133106273, 0.5491013415157248, 0.33311292285246896, 0.47831967790630825, 0.2510770234307901, 0.24692705852935903, 0.48035384518917157, 0.23665669042404747, 0.42822797182165473, 0.30575513751038663, 0.1384240955857755, 0.21920609124034363, 0.2686337200810871, 0.3370099124725975, 0.27722345291883144, 0.2798287908940785, 0.15815476806470508, 0.3293521774471102, 0.31052351305580883, 0.21880804130783393, 0.23147323015166554, 0.21474406873959928, 0.20490956936190807, 0.23457103325372197, 0.2437305802702212, 0.2149709844811336, 0.2439850908753306, 0.23335761715769676, 0.22350210307888363, 0.18574197878039322, 0.17837020396905356, 0.2155230598069725, 0.19237625339917275, 0.19959724030473103, 0.17669365044360585, 0.21076136807788703, 0.20118337457794033, 0.9214437223791965, 0.1752419304252275, 0.14813261835915315, 0.9234731888523364, 0.1891957800520545, 0.20075856307887285, 0.14236009654782922, 0.16951293172035564, 0.9211706307592998, 0.8938069567687922, 0.21337860007900866, 0.8903324751288573, 0.8659545435144563, 0.8852123370256878, 0.15603433731549, 0.7809371264146462, 0.8691346964491866, 0.8944526734985341, 0.20381020220067825, 0.1898466526025595, 0.19237450905935372, 0.17981768391588937, 0.21853539690398427, 0.19684832418329457, 0.1848171428814328, 0.22912533053187922, 0.19210062702914676, 0.09359997277557464, 0.08913187308574833, 0.07349795134290049, 0.1072000129024635, 0.10987724557902478, 0.1309134338923733, 0.0948732229011211, 0.08903264488315288, 0.0935723001019283]}, "mutation_prompt": null}
{"id": "3634f09d-3846-45dd-bdc3-febb8a631b53", "solution": "import numpy as np\n\nclass EnhancedQuantumHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 30  # Reduced population for faster convergence\n        self.w = 0.7  # Increased inertia weight for exploration\n        self.cr = 0.85  # Adjusted crossover rate for better balance\n        self.f1 = 0.6  # Stronger mutation factor for exploration\n        self.f2 = 0.4  # Lower secondary mutation factor for stability\n        self.q_prob = 0.15  # Increased quantum probability for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def opposition_based_learning(self, population):\n        return self.lower_bound + self.upper_bound - population\n\n    def chaotic_local_search(self, agent):\n        chaotic_factor = 2 * np.sin(agent) + np.random.uniform(-0.1, 0.1, self.dim)\n        return np.clip(agent + chaotic_factor, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            opposition_pop = self.opposition_based_learning(population)\n            for opposite, original in zip(opposition_pop, population):\n                if func(opposite) < func(original):\n                    population[np.where(population == original)[0][0]] = opposite\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                if np.random.rand() < self.q_prob:\n                    quantum_shift = np.random.uniform(-1, 1, self.dim)\n                    mutant = global_best + quantum_shift * (x1 - x2)\n                else:\n                    mutant = x0 + self.f1 * (x1 - x2)\n\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n\n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.w = 0.5 + 0.2 * (1 - evaluations / self.budget)  # Dynamic inertia adjustment\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.2:  # 20% chance to perform chaotic local search\n                    population[i] = self.chaotic_local_search(population[i])\n\n                f_val = func(population[i])\n                evaluations += 1\n\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n\n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n        return global_best", "name": "EnhancedQuantumHybridSwarm", "description": "An Enhanced Quantum-Inspired Hybrid Swarm Algorithm integrating opposition-based learning and a chaotic local search for improved convergence speed.", "configspace": "", "generation": 81, "fitness": 0.183836123211767, "feedback": "The algorithm EnhancedQuantumHybridSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.19.", "error": "", "parent_id": "75c77c35-a246-4a87-a69a-b2a131576f2e", "metadata": {"aucs": [0.3953770499008791, 0.38631399632186647, 0.3907986303224531, 0.42479948432380166, 0.3971231239991132, 0.4083373662272348, 0.3875370503701506, 0.37931073618819455, 0.4128569195357852, 0.0010308320521593695, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009055654091762344, 0.030999244740100185, 0.03277500379269971, 9.999999999998899e-05, 0.013776708504458668, 0.09772695392335351, 0.09652676008358141, 0.12187471321797216, 0.10891180736727002, 0.10415024557062802, 0.08152158076199212, 0.10062965724643413, 0.10070326369911797, 0.10526267444125148, 0.06962209372166839, 0.0348300413150644, 0.0621444261500419, 0.03217465610254422, 0.04878792077535732, 0.10351977326768624, 0.0811747502485256, 0.06702037306731379, 0.08993491906237339, 0.9662829376358097, 0.9754363631190135, 0.9689209293482192, 0.9225508723091895, 0.9673353237410789, 0.9667421985757775, 0.9772684043917487, 0.9686357952258922, 0.9763296081080408, 0.2508093201786067, 0.18814424376261774, 0.2057152574539124, 0.20010325888569114, 0.1879657690313271, 0.13129546802661485, 0.21266580573341443, 0.2080017907502929, 0.20644335855412732, 0.16415308307334087, 0.1778200547462, 0.20168852286826833, 0.24625164589487636, 0.2071623065281456, 0.27053130442035156, 0.22656687874615844, 0.22385616581781087, 0.2883560270133487, 0.1313319628294881, 0.12075720403332546, 0.12029860257446612, 0.13317813491266317, 0.12490495580182637, 0.13081798099516195, 0.11848624373228667, 0.1038732284206435, 0.1270461039480557, 0.13806361271247947, 0.1015928964457995, 0.09024618038412213, 0.1273700906195009, 0.08516127394530226, 0.10795854198036614, 0.13056111817109706, 0.14009072762563102, 0.13707797482592088, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.059519181992532144, 0.03198151341816369, 0.04619138362441899, 0.06793117218039846, 0.08757965661333333, 0.0325272615041553, 0.08273126426018262, 0.06413109839845454, 0.061937242329849096, 9.999999999998899e-05, 0.008592676177758052, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10356435746827752, 0.06481986593797795, 0.08134987734251586, 0.10357206758104676, 0.10759106491152925, 0.08637715691019399, 0.06329640474717402, 0.07693887683392531, 0.10048814585551158, 0.3455908619369653, 0.33944113764212336, 0.37624458860006094, 0.4290916287595332, 0.3827542971063128, 0.3612000226565135, 0.3653570898739774, 0.31662534234360573, 0.3283370220566453, 0.1292375329676826, 0.13024136857980573, 0.11150870422408787, 0.09179123016129065, 0.11619193670055594, 0.1011724285805482, 0.10515689771531511, 0.0843406839236106, 0.0818025939232857, 0.1348863557384231, 0.11137060011713584, 0.1401903899401652, 0.16266539828636128, 0.17991372449213627, 0.15308637008106618, 0.14536504273895712, 0.16325378854599726, 0.12935465481038977, 0.23023064694336748, 0.2473294286986315, 0.21437480452751934, 0.2275481571861362, 0.2608941789851039, 0.2022140901019116, 0.2135283867880473, 0.247606717611641, 0.19471820618815372, 0.18363599111377604, 0.15813137165667612, 0.16672988839616443, 0.16212835611266907, 0.1664707882351093, 0.15008850621388026, 0.1798094184583897, 0.24263354153636518, 0.17587659578195802, 0.18914485858966923, 0.18919304653812696, 0.1742398597538618, 0.17559197881078326, 0.163887427676918, 0.20342083742657757, 0.1752825328442872, 0.17340818177502004, 0.21503069896004445, 0.16585563922621827, 0.22948738159201976, 0.19512665078357672, 0.17666998234804376, 0.27091879112452943, 0.19292191725023577, 0.16560226668845512, 0.18524097328007672, 0.21565649598804337, 0.17644738747949573, 0.42191456739859545, 0.15174903868126222, 0.16304644837981996, 0.19334520507281394, 0.1866787638431635, 0.16099400286894028, 0.14470165971116422, 0.18226729498387317, 0.34713317547198363, 0.1531964955123971, 0.2066952516033821, 0.1650388325945027, 0.16838710317558703, 0.20577669423262512, 0.10197142144774551, 0.3507846081361632, 0.19920782786455715, 0.18515582582212975, 0.18145780322825977, 0.17488957832034213, 0.18545346336375246, 0.17625988154532712, 0.17567992745300054, 0.20281304987528737, 0.17702353362874113, 0.17800169475308525, 0.07518580244932249, 0.06262414626285373, 0.06632619066720802, 0.06369264669613717, 0.0718420592807879, 0.06295185564499983, 0.07197665362422867, 0.073326750620064, 0.08212747797529352]}, "mutation_prompt": null}
{"id": "38e63943-06ce-48ea-b85d-c306f42825a8", "solution": "import numpy as np\n\nclass QuantumVariationalParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 60  # Increased population for better exploration\n        self.w = 0.7  # Increased inertia weight for stronger global search\n        self.cr = 0.85  # Adjusted crossover rate to balance exploration\n        self.f1 = 0.4  # Tuned mutation factor for stability\n        self.f2 = 0.7  # Enhanced secondary mutation factor for aggressive search\n        self.q_prob = 0.15  # Increased quantum probability for enhanced diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.3, 0.3, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 5, replace=False)\n                x0, x1, x2, x3, x4 = population[indices]\n                if np.random.rand() < self.q_prob:\n                    quantum_shift = np.random.uniform(-1, 1, self.dim)\n                    mutant = global_best + quantum_shift * (x1 - x2)\n                else:\n                    det_factor = np.random.rand() * self.f2\n                    if np.random.rand() < 0.6:\n                        mutant = x0 + self.f1 * (x1 - x2) + det_factor * (x2 - x3)\n                    else:\n                        mutant = x0 + self.f2 * (global_best - personal_best[i]) + det_factor * (x1 - x4)\n\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n\n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.w = 0.4 + 0.2 * (1 - evaluations / self.budget)  # Adjusted dynamic inertia\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n                f_val = func(population[i])\n                evaluations += 1\n\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n\n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n        return global_best", "name": "QuantumVariationalParticleSwarm", "description": "A Quantum Variational Particle Swarm Optimization (QVPSO) approach that integrates dynamic mutation strategies and diversity-enhancement techniques for improved convergence in high-dimensional spaces.", "configspace": "", "generation": 82, "fitness": 0.367810711954312, "feedback": "The algorithm QuantumVariationalParticleSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.26.", "error": "", "parent_id": "75c77c35-a246-4a87-a69a-b2a131576f2e", "metadata": {"aucs": [0.8134254907387884, 0.8022647606883951, 0.8320430796004962, 0.807164973683883, 0.8161094981751128, 0.8152997962335466, 0.8050102373317345, 0.8076437399261731, 0.8119014260751449, 0.46147539491536127, 0.48713759539181634, 0.5217993988192657, 0.44222235000864973, 0.5165803800144346, 0.5035573437235782, 0.5125092926329401, 0.522074097127996, 0.5160447805519178, 0.1264744453465937, 0.13895611493556137, 0.1791848830336239, 0.1476523423698518, 0.12349186534571488, 0.14925326852153697, 0.12299952823152349, 0.14576391151393542, 0.11670032633776029, 0.15170875233150838, 0.13476990765656716, 0.11173882700087956, 0.12141903823731592, 0.11699181221161747, 0.12215646498739097, 0.09088002713158116, 0.09614339299740204, 0.10404569654940699, 0.97724723323301, 0.9756902491193158, 0.9776525220289414, 0.956506424694334, 0.9765387111791078, 0.9781894750923515, 0.976421762417225, 0.9848295635678623, 0.9741641905973847, 0.6795483314581963, 0.6721170543935963, 0.6617308490679974, 0.643286637886932, 0.68164394624437, 0.5902983470354093, 0.6629704163241346, 0.6738100432264831, 0.631316351994431, 0.24576343989622806, 0.8409354837378882, 0.3809253844528393, 0.2725369328952809, 0.7907344433709589, 0.20740966430585006, 0.8013119683353498, 0.22045735683185463, 0.8178387890697583, 0.4791460328929861, 0.13023066481674217, 0.3665081998824994, 0.5588253898802176, 0.5625370947136608, 0.10269904108099981, 0.6617435187309169, 0.5203302324741215, 0.545971798369379, 0.5041118938230404, 0.5367126983445103, 0.6106440110535123, 0.5730747638542735, 0.49422694079416496, 0.5056763837620476, 0.5744510588203218, 0.5867307603920716, 0.5595051290157314, 0.4235143146839292, 0.35372182123328744, 0.0765934967831865, 0.32475506168803303, 0.45852571919033347, 9.999999999998899e-05, 0.19422179774321136, 0.38706106927001005, 0.10715088907824921, 0.23249788992012654, 0.5441543572016114, 0.2077832450249636, 0.5267611456560353, 0.42635506054001404, 0.49297176462364856, 0.4338665822326597, 0.5316333406857161, 0.335425290469722, 0.23186717029853843, 0.18029562994348614, 0.14235059609127276, 0.17506611327029986, 0.30731050060961784, 0.1390724408493501, 0.2815978797783373, 0.1256643262820809, 0.08854916953062653, 0.30434521701031403, 0.20853022349233608, 0.21816550157058923, 0.1287059624507636, 0.09556968474230121, 0.32212905458941, 0.05335931880564637, 0.18289025456693864, 0.16504088447558474, 0.7033684949710228, 0.7003832289861323, 0.6471132004601693, 0.6875881000226101, 0.6906268837740203, 0.6116589976698932, 0.661008405862175, 0.6632441690535187, 0.660632903309641, 0.13365497815395178, 0.09157107475387805, 0.07600801837747917, 0.1141334217027663, 0.1176200594540302, 0.09475772664330018, 0.08512616191160838, 0.09019514461570377, 0.12972311459903763, 0.2244494572062532, 0.18299979021298973, 0.2689301098696206, 0.19456241069472957, 0.40862263334502225, 0.17643112844643016, 0.27138833170644705, 0.3014346790217878, 0.3364567084360588, 0.30267446771828577, 0.3111225185650447, 0.2461635728956243, 0.5035595349459969, 0.5457084389408123, 0.38810711015272936, 0.2700892454243534, 0.4502824346349418, 0.38420577343964013, 0.27397943553585613, 0.29500092723511073, 0.2800614283843079, 0.3843762314419713, 0.22591513497515714, 0.3588562018294599, 0.2344828790852388, 0.2339610252125619, 0.22341831091955144, 0.24804997763593406, 0.23986491190631953, 0.24350750363336882, 0.23091357844364235, 0.21140825915567607, 0.22881561020344476, 0.2057827924962189, 0.21041984845366302, 0.26428287022899044, 0.20620466316642772, 0.19029397639203238, 0.20370175055925055, 0.18475198955672723, 0.18211003816063942, 0.17718065313648512, 0.19248253556778205, 0.1916552527126434, 0.1846202679812794, 0.19890347980681478, 0.18605980194001037, 0.20998823489220553, 0.16828051072600447, 0.20002430485824985, 0.20001723869442634, 0.14275208728449995, 0.8957648571643843, 0.8711161636755571, 0.8821014944327599, 0.2105848004073252, 0.8367102176593152, 0.208473339814912, 0.16856463299590263, 0.16863629649842826, 0.20112744732653243, 0.15583261758817446, 0.09415731401656735, 0.2077317878620506, 0.20544125525575763, 0.19774214654798272, 0.19990167648106572, 0.19651319554918767, 0.26584384484691337, 0.1954047776654897, 0.2095190884125967, 0.22774172395129977, 0.10319703464056151, 0.10011523483501528, 0.09718651016447843, 0.09824821139259088, 0.10750421907603891, 0.09800051077749194, 0.08840540871640423, 0.09056069351107965, 0.10006293875633332]}, "mutation_prompt": null}
{"id": "fced71ff-e70a-495b-8963-972fdc6785fd", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Slightly reduced population for efficiency\n        self.w = 0.5  # Adjusted inertia weight for better balance between exploration and exploitation\n        self.cr = 0.9  # Higher crossover rate to encourage exploration\n        self.f1 = 0.5  # Increased mutation factor for stronger primary exploration\n        self.f2 = 0.6  # Adjusted secondary mutation factor for balance\n        self.q_prob = 0.1  # New quantum probability factor for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                if np.random.rand() < self.q_prob:\n                    quantum_shift = np.random.uniform(-1, 1, self.dim)\n                    mutant = global_best + quantum_shift * (x1 - x2)\n                else:\n                    if np.random.rand() < 0.5:\n                        mutant = x0 + self.f1 * (x1 - x2) + self.f1 * (x2 - x3)\n                    else:\n                        mutant = x0 + self.f2 * (global_best - personal_best[i]) + self.f2 * (x1 - x2)\n\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n\n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.w = 0.3 + 0.3 * (1 - evaluations / self.budget)  # Dynamic inertia adjustment\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n                f_val = func(population[i])\n                evaluations += 1\n\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n\n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n        return global_best", "name": "AdaptiveQuantumHybridSwarm", "description": "An Adaptive Quantum-Inspired Hybrid Swarm Algorithm enhancing diversity and convergence through quantum mechanics concepts and adaptive dynamic techniques.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75c77c35-a246-4a87-a69a-b2a131576f2e", "metadata": {"aucs": [0.8732496514529094, 0.8573013930713151, 0.8744986549559657, 0.8537495192369189, 0.8604165374218101, 0.8715142837348789, 0.8704099284618737, 0.8739727116974925, 0.866791729775093, 0.6147791287774991, 0.5226600881736632, 0.6008666291934257, 0.6011496292940641, 0.5712684505558844, 0.6359510051857422, 0.045908637116616746, 0.01791592251565577, 0.624806402963642, 0.1413067638663884, 0.11049529921804513, 0.14184049273655452, 0.1027592472363914, 0.07083301263806674, 0.12002114502220551, 0.12881546204892624, 0.12197346576387535, 0.14062731601841005, 0.10096466446710328, 0.05413792712396226, 0.09114897185600312, 0.11617455852670533, 0.10909181187858685, 0.1132573468606426, 0.09365470587791058, 0.10954479806391282, 0.06924766798411386, 0.9775912343458948, 0.9856918600781291, 0.9862987405660498, 0.9770175651747988, 0.9778520464721582, 0.9781512659494478, 0.9875080020708764, 0.984098099287295, 0.9849954146772911, 0.7809659532660893, 0.7422826837075494, 0.7507287728082499, 0.7671760563977873, 0.7605455519964089, 0.7573331744633285, 0.7679600916906688, 0.747325999217636, 0.7792914648411364, 0.17111748920970027, 0.3776430589145463, 0.2148095429947724, 0.2812462563154454, 0.8986407239240541, 0.19204913894860254, 0.8747754320911039, 0.875000117318375, 0.868387248003844, 0.7632216912436319, 0.706558114179277, 0.6234648388250588, 0.13136984499800142, 0.7085088269387997, 0.6506806316873934, 0.6826924943191606, 0.6992691458062947, 0.6583057288686354, 0.734243198366002, 0.13115796893246556, 0.6705233511355073, 0.7082745516843774, 0.6388044637379255, 0.1341526369084951, 0.6743382872976676, 0.5567792737889925, 0.13081659118311728, 0.31827943748047594, 9.999999999998899e-05, 0.06633577084044773, 0.5390449000464439, 0.5270845928542385, 9.999999999998899e-05, 0.4392765556044851, 0.008076823072002082, 0.26222948519668543, 0.24804397985012738, 0.36024896744948254, 0.5288676387803491, 0.157319205348598, 0.17810397592288285, 0.6509838503096024, 0.6551795148357473, 0.6692466142047369, 0.6019556617371273, 0.06668243159341114, 0.26091536276258476, 0.22968957066875362, 0.30011996004245634, 0.09151287932329799, 0.3578498530294587, 0.2206967922068861, 0.3854711628213495, 0.20182060529747137, 0.17857461789159057, 0.19558219385245745, 0.3284205134415502, 0.006407430175517814, 0.36619250372402334, 0.2259926234100389, 0.08079187747567196, 0.3566449764797007, 0.08114697349173805, 0.7344845036158891, 0.7483427178164258, 0.7486489878661621, 0.7518594363355056, 0.7634733283067978, 0.802694999760851, 0.6843882425772356, 0.7299911756040789, 0.7593858556799229, 0.07580857596923452, 0.14444118890065638, 0.10268166408293322, 0.14555068634590862, 0.1133105093208967, 0.7033352848670488, 0.1039592203854578, 0.07995791523730145, 0.10458196920510487, 0.1700282082103276, 0.6464594007522839, 0.23788986441283433, 0.24848668452709644, 0.26787452178738946, 0.19298062414556083, 0.421872478808335, 0.19843099372711004, 0.26917347133106273, 0.5491013415157248, 0.33311292285246896, 0.47831967790630825, 0.2510770234307901, 0.24692705852935903, 0.48035384518917157, 0.23665669042404747, 0.42822797182165473, 0.30575513751038663, 0.1384240955857755, 0.21920609124034363, 0.2686337200810871, 0.3370099124725975, 0.27722345291883144, 0.2798287908940785, 0.15815476806470508, 0.3293521774471102, 0.31052351305580883, 0.21880804130783393, 0.23147323015166554, 0.21474406873959928, 0.20490956936190807, 0.23457103325372197, 0.2437305802702212, 0.2149709844811336, 0.2439850908753306, 0.23335761715769676, 0.22350210307888363, 0.18574197878039322, 0.17837020396905356, 0.2155230598069725, 0.19237625339917275, 0.19959724030473103, 0.17669365044360585, 0.21076136807788703, 0.20118337457794033, 0.9214437223791965, 0.1752419304252275, 0.14813261835915315, 0.9234731888523364, 0.1891957800520545, 0.20075856307887285, 0.14236009654782922, 0.16951293172035564, 0.9211706307592998, 0.8938069567687922, 0.21337860007900866, 0.8903324751288573, 0.8659545435144563, 0.8852123370256878, 0.15603433731549, 0.7809371264146462, 0.8691346964491866, 0.8944526734985341, 0.20381020220067825, 0.1898466526025595, 0.19237450905935372, 0.17981768391588937, 0.21853539690398427, 0.19684832418329457, 0.1848171428814328, 0.22912533053187922, 0.19210062702914676, 0.09359997277557464, 0.08913187308574833, 0.07349795134290049, 0.1072000129024635, 0.10987724557902478, 0.1309134338923733, 0.0948732229011211, 0.08903264488315288, 0.0935723001019283]}, "mutation_prompt": null}
{"id": "d9c759f5-3034-4a60-9bf3-504918640dc9", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Slightly reduced population for efficiency\n        self.w = 0.5  # Adjusted inertia weight for better balance between exploration and exploitation\n        self.cr = 0.9  # Higher crossover rate to encourage exploration\n        self.f1 = 0.5  # Increased mutation factor for stronger primary exploration\n        self.f2 = 0.6  # Adjusted secondary mutation factor for balance\n        self.q_prob = 0.1  # New quantum probability factor for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                if np.random.rand() < self.q_prob:\n                    quantum_shift = np.random.uniform(-1, 1, self.dim)\n                    mutant = global_best + quantum_shift * (x1 - x2)\n                else:\n                    if np.random.rand() < 0.5:\n                        mutant = x0 + self.f1 * (x1 - x2) + self.f1 * (x2 - x3)\n                    else:\n                        mutant = x0 + self.f2 * (global_best - personal_best[i]) + self.f2 * (x1 - x2)\n\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n\n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.w = 0.3 + 0.3 * (1 - evaluations / self.budget)  # Dynamic inertia adjustment\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n                f_val = func(population[i])\n                evaluations += 1\n\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n\n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n        return global_best", "name": "AdaptiveQuantumHybridSwarm", "description": "An Adaptive Quantum-Inspired Hybrid Swarm Algorithm enhancing diversity and convergence through quantum mechanics concepts and adaptive dynamic techniques.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75c77c35-a246-4a87-a69a-b2a131576f2e", "metadata": {"aucs": [0.8732496514529094, 0.8573013930713151, 0.8744986549559657, 0.8537495192369189, 0.8604165374218101, 0.8715142837348789, 0.8704099284618737, 0.8739727116974925, 0.866791729775093, 0.6147791287774991, 0.5226600881736632, 0.6008666291934257, 0.6011496292940641, 0.5712684505558844, 0.6359510051857422, 0.045908637116616746, 0.01791592251565577, 0.624806402963642, 0.1413067638663884, 0.11049529921804513, 0.14184049273655452, 0.1027592472363914, 0.07083301263806674, 0.12002114502220551, 0.12881546204892624, 0.12197346576387535, 0.14062731601841005, 0.10096466446710328, 0.05413792712396226, 0.09114897185600312, 0.11617455852670533, 0.10909181187858685, 0.1132573468606426, 0.09365470587791058, 0.10954479806391282, 0.06924766798411386, 0.9775912343458948, 0.9856918600781291, 0.9862987405660498, 0.9770175651747988, 0.9778520464721582, 0.9781512659494478, 0.9875080020708764, 0.984098099287295, 0.9849954146772911, 0.7809659532660893, 0.7422826837075494, 0.7507287728082499, 0.7671760563977873, 0.7605455519964089, 0.7573331744633285, 0.7679600916906688, 0.747325999217636, 0.7792914648411364, 0.17111748920970027, 0.3776430589145463, 0.2148095429947724, 0.2812462563154454, 0.8986407239240541, 0.19204913894860254, 0.8747754320911039, 0.875000117318375, 0.868387248003844, 0.7632216912436319, 0.706558114179277, 0.6234648388250588, 0.13136984499800142, 0.7085088269387997, 0.6506806316873934, 0.6826924943191606, 0.6992691458062947, 0.6583057288686354, 0.734243198366002, 0.13115796893246556, 0.6705233511355073, 0.7082745516843774, 0.6388044637379255, 0.1341526369084951, 0.6743382872976676, 0.5567792737889925, 0.13081659118311728, 0.31827943748047594, 9.999999999998899e-05, 0.06633577084044773, 0.5390449000464439, 0.5270845928542385, 9.999999999998899e-05, 0.4392765556044851, 0.008076823072002082, 0.26222948519668543, 0.24804397985012738, 0.36024896744948254, 0.5288676387803491, 0.157319205348598, 0.17810397592288285, 0.6509838503096024, 0.6551795148357473, 0.6692466142047369, 0.6019556617371273, 0.06668243159341114, 0.26091536276258476, 0.22968957066875362, 0.30011996004245634, 0.09151287932329799, 0.3578498530294587, 0.2206967922068861, 0.3854711628213495, 0.20182060529747137, 0.17857461789159057, 0.19558219385245745, 0.3284205134415502, 0.006407430175517814, 0.36619250372402334, 0.2259926234100389, 0.08079187747567196, 0.3566449764797007, 0.08114697349173805, 0.7344845036158891, 0.7483427178164258, 0.7486489878661621, 0.7518594363355056, 0.7634733283067978, 0.802694999760851, 0.6843882425772356, 0.7299911756040789, 0.7593858556799229, 0.07580857596923452, 0.14444118890065638, 0.10268166408293322, 0.14555068634590862, 0.1133105093208967, 0.7033352848670488, 0.1039592203854578, 0.07995791523730145, 0.10458196920510487, 0.1700282082103276, 0.6464594007522839, 0.23788986441283433, 0.24848668452709644, 0.26787452178738946, 0.19298062414556083, 0.421872478808335, 0.19843099372711004, 0.26917347133106273, 0.5491013415157248, 0.33311292285246896, 0.47831967790630825, 0.2510770234307901, 0.24692705852935903, 0.48035384518917157, 0.23665669042404747, 0.42822797182165473, 0.30575513751038663, 0.1384240955857755, 0.21920609124034363, 0.2686337200810871, 0.3370099124725975, 0.27722345291883144, 0.2798287908940785, 0.15815476806470508, 0.3293521774471102, 0.31052351305580883, 0.21880804130783393, 0.23147323015166554, 0.21474406873959928, 0.20490956936190807, 0.23457103325372197, 0.2437305802702212, 0.2149709844811336, 0.2439850908753306, 0.23335761715769676, 0.22350210307888363, 0.18574197878039322, 0.17837020396905356, 0.2155230598069725, 0.19237625339917275, 0.19959724030473103, 0.17669365044360585, 0.21076136807788703, 0.20118337457794033, 0.9214437223791965, 0.1752419304252275, 0.14813261835915315, 0.9234731888523364, 0.1891957800520545, 0.20075856307887285, 0.14236009654782922, 0.16951293172035564, 0.9211706307592998, 0.8938069567687922, 0.21337860007900866, 0.8903324751288573, 0.8659545435144563, 0.8852123370256878, 0.15603433731549, 0.7809371264146462, 0.8691346964491866, 0.8944526734985341, 0.20381020220067825, 0.1898466526025595, 0.19237450905935372, 0.17981768391588937, 0.21853539690398427, 0.19684832418329457, 0.1848171428814328, 0.22912533053187922, 0.19210062702914676, 0.09359997277557464, 0.08913187308574833, 0.07349795134290049, 0.1072000129024635, 0.10987724557902478, 0.1309134338923733, 0.0948732229011211, 0.08903264488315288, 0.0935723001019283]}, "mutation_prompt": null}
{"id": "6a16d946-3099-48d4-8108-d4df145ac737", "solution": "import numpy as np\n\nclass QuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Increased population size for diversity\n        self.f = 0.8  # Higher mutation factor for robust exploration\n        self.cr = 0.7  # Reduced crossover rate for better exploitation\n        self.q_prob = 0.2  # Increased quantum probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                if np.random.rand() < self.q_prob:\n                    quantum_shift = np.random.uniform(-1, 1, self.dim)\n                    mutant = global_best + quantum_shift * (x1 - x2)\n                else:\n                    mutant = x0 + self.f * (x1 - x2)\n\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n\n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "QuantumDifferentialEvolution", "description": "A Quantum-Inspired Differential Evolution Algorithm with Enhanced Diversity and Dynamic Adaptive Techniques for Rapid Convergence.", "configspace": "", "generation": 85, "fitness": 0.12874374048295045, "feedback": "The algorithm QuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.16.", "error": "", "parent_id": "75c77c35-a246-4a87-a69a-b2a131576f2e", "metadata": {"aucs": [0.20530730287386312, 0.23366356926684295, 0.20230618269960288, 0.20463246492462606, 0.20709687240893782, 0.2055443552819447, 0.23421387250460934, 0.19735835116582867, 0.2516343058134808, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04210713619175954, 0.051708872093647384, 0.05323187101669735, 0.061625999010671006, 0.048316985487622865, 0.06603099818177383, 0.04892603719856847, 0.04541323929691865, 0.05491903462438019, 0.02883027674881289, 0.06137899831749005, 0.043067722727697544, 0.046776274217770863, 0.047094419794095344, 0.052104862214231606, 0.042100725357570035, 0.032733863145282704, 0.040924386812138835, 0.6182036448855275, 0.64832226133071, 0.9510576595793229, 0.824168866796091, 0.7962240942910304, 0.7882359998877593, 0.7986893889809358, 0.9790229196896884, 0.7723836148672876, 0.08839370780253741, 0.08674958521556642, 0.10353962409972117, 0.10496623976634523, 0.10320871303689094, 0.11918511984924118, 0.12923905370254474, 0.09379856667975417, 0.12391755315273822, 0.14698076756306178, 0.1424521131393851, 0.18380980208786812, 0.14702186315719645, 0.16066769021189042, 0.16948411307714617, 0.1338726974895249, 0.1448155731565699, 0.11477099258237144, 0.020890770797731606, 0.00470727233061774, 0.029989841404453155, 0.08093594838412954, 0.018970035436723598, 0.017229836524822684, 0.019485228870456894, 0.06150079554280985, 0.06001758794727374, 0.023905196405828222, 0.007855429911627465, 0.03895071319153698, 0.0339007430975089, 0.020823211577629785, 0.0849481451311791, 0.051603859549354314, 9.999999999998899e-05, 0.06311920046634134, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05147810314783141, 0.047023941332009045, 0.04686957520495749, 0.03534240525553756, 0.030713995367223634, 0.0803794563313337, 0.027372604966708014, 0.032365683125301636, 0.0654908077291051, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026420958207370115, 0.010961349633138662, 0.002843333689058869, 9.999999999998899e-05, 0.00026227474264273187, 9.999999999998899e-05, 0.005714309214643443, 0.00020070763391744073, 0.015770215954564626, 0.19692460397836675, 0.2040433747017203, 0.23360002631502985, 0.21109803785181758, 0.23397343527856063, 0.24635052044132566, 0.2233049956621529, 0.2273287061765792, 0.21502573349243048, 0.04664715356874405, 0.05128561877509896, 0.047328907905957784, 0.0526959649571751, 0.06383241899859515, 0.05906782009240363, 0.05649701190556933, 0.047613837327288966, 0.05267637874484066, 0.15701674713005997, 0.12649786074094538, 0.15420133998082497, 0.138534967059028, 0.14133159396352313, 0.17314240293195926, 0.13125501365594316, 0.1366082479591363, 0.15382336609049274, 0.15628269584719978, 0.19913158486289217, 0.180576587577027, 0.15905565149312528, 0.1563411086232911, 0.16941674751234714, 0.18408019630871586, 0.1847424743403382, 0.1900555853018745, 0.12608524098932083, 0.12142357210304489, 0.11323754101479777, 0.1071325939201544, 0.10959152577990738, 0.10473445713315377, 0.1325507437822937, 0.1235630362025677, 0.12733984963290257, 0.17155494108453728, 0.15956763145772834, 0.15570815562821483, 0.1645787499757969, 0.18282696987277314, 0.15124236181339545, 0.168184552486077, 0.14547376553334668, 0.15977528509528693, 0.15841282333586637, 0.1403777177088461, 0.1760880392237988, 0.15624850389158762, 0.14599965743786614, 0.15690434922068397, 0.13133014002105903, 0.15787894900849897, 0.15115636517404296, 0.14251864792597368, 0.1622681875828672, 0.1695973657983848, 0.16027603654394496, 0.1714348290801534, 0.20335952390735768, 0.16363020535002049, 0.16396871272768854, 0.15599483821612414, 0.1585501502472474, 0.14935985826282105, 0.22548458905888025, 0.15411242253047963, 0.14967862534497267, 0.12802481270449118, 0.15986811200189477, 0.1788111139134977, 0.15652146568452385, 0.1791785655591337, 0.1968739372035213, 0.19246687321446143, 0.17444808927910804, 0.19084652601857677, 0.1842564064845147, 0.19213345878285104, 0.1763563950761562, 0.1869838742989235, 0.044488115862500344, 0.07405684917071609, 0.05252330519630599, 0.056268946486950466, 0.05523683876858454, 0.05695809939162866, 0.04907599104366056, 0.054604112241048997, 0.07480108371646743]}, "mutation_prompt": null}
{"id": "c6bc3370-76f1-4cbf-8bbb-d1d15bd1b087", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Slightly reduced population for efficiency\n        self.w = 0.5  # Adjusted inertia weight for better balance between exploration and exploitation\n        self.cr = 0.9  # Higher crossover rate to encourage exploration\n        self.f1 = 0.5  # Increased mutation factor for stronger primary exploration\n        self.f2 = 0.6  # Adjusted secondary mutation factor for balance\n        self.q_prob = 0.1  # New quantum probability factor for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                if np.random.rand() < self.q_prob:\n                    quantum_shift = np.random.uniform(-1, 1, self.dim)\n                    mutant = global_best + quantum_shift * (x1 - x2)\n                else:\n                    if np.random.rand() < 0.5:\n                        mutant = x0 + self.f1 * (x1 - x2) + self.f1 * (x2 - x3)\n                    else:\n                        mutant = x0 + self.f2 * (global_best - personal_best[i]) + self.f2 * (x1 - x2)\n\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n\n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.w = 0.3 + 0.3 * (1 - evaluations / self.budget)  # Dynamic inertia adjustment\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n                f_val = func(population[i])\n                evaluations += 1\n\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n\n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n        return global_best", "name": "AdaptiveQuantumHybridSwarm", "description": "An Adaptive Quantum-Inspired Hybrid Swarm Algorithm enhancing diversity and convergence through quantum mechanics concepts and adaptive dynamic techniques.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75c77c35-a246-4a87-a69a-b2a131576f2e", "metadata": {"aucs": [0.8732496514529094, 0.8573013930713151, 0.8744986549559657, 0.8537495192369189, 0.8604165374218101, 0.8715142837348789, 0.8704099284618737, 0.8739727116974925, 0.866791729775093, 0.6147791287774991, 0.5226600881736632, 0.6008666291934257, 0.6011496292940641, 0.5712684505558844, 0.6359510051857422, 0.045908637116616746, 0.01791592251565577, 0.624806402963642, 0.1413067638663884, 0.11049529921804513, 0.14184049273655452, 0.1027592472363914, 0.07083301263806674, 0.12002114502220551, 0.12881546204892624, 0.12197346576387535, 0.14062731601841005, 0.10096466446710328, 0.05413792712396226, 0.09114897185600312, 0.11617455852670533, 0.10909181187858685, 0.1132573468606426, 0.09365470587791058, 0.10954479806391282, 0.06924766798411386, 0.9775912343458948, 0.9856918600781291, 0.9862987405660498, 0.9770175651747988, 0.9778520464721582, 0.9781512659494478, 0.9875080020708764, 0.984098099287295, 0.9849954146772911, 0.7809659532660893, 0.7422826837075494, 0.7507287728082499, 0.7671760563977873, 0.7605455519964089, 0.7573331744633285, 0.7679600916906688, 0.747325999217636, 0.7792914648411364, 0.17111748920970027, 0.3776430589145463, 0.2148095429947724, 0.2812462563154454, 0.8986407239240541, 0.19204913894860254, 0.8747754320911039, 0.875000117318375, 0.868387248003844, 0.7632216912436319, 0.706558114179277, 0.6234648388250588, 0.13136984499800142, 0.7085088269387997, 0.6506806316873934, 0.6826924943191606, 0.6992691458062947, 0.6583057288686354, 0.734243198366002, 0.13115796893246556, 0.6705233511355073, 0.7082745516843774, 0.6388044637379255, 0.1341526369084951, 0.6743382872976676, 0.5567792737889925, 0.13081659118311728, 0.31827943748047594, 9.999999999998899e-05, 0.06633577084044773, 0.5390449000464439, 0.5270845928542385, 9.999999999998899e-05, 0.4392765556044851, 0.008076823072002082, 0.26222948519668543, 0.24804397985012738, 0.36024896744948254, 0.5288676387803491, 0.157319205348598, 0.17810397592288285, 0.6509838503096024, 0.6551795148357473, 0.6692466142047369, 0.6019556617371273, 0.06668243159341114, 0.26091536276258476, 0.22968957066875362, 0.30011996004245634, 0.09151287932329799, 0.3578498530294587, 0.2206967922068861, 0.3854711628213495, 0.20182060529747137, 0.17857461789159057, 0.19558219385245745, 0.3284205134415502, 0.006407430175517814, 0.36619250372402334, 0.2259926234100389, 0.08079187747567196, 0.3566449764797007, 0.08114697349173805, 0.7344845036158891, 0.7483427178164258, 0.7486489878661621, 0.7518594363355056, 0.7634733283067978, 0.802694999760851, 0.6843882425772356, 0.7299911756040789, 0.7593858556799229, 0.07580857596923452, 0.14444118890065638, 0.10268166408293322, 0.14555068634590862, 0.1133105093208967, 0.7033352848670488, 0.1039592203854578, 0.07995791523730145, 0.10458196920510487, 0.1700282082103276, 0.6464594007522839, 0.23788986441283433, 0.24848668452709644, 0.26787452178738946, 0.19298062414556083, 0.421872478808335, 0.19843099372711004, 0.26917347133106273, 0.5491013415157248, 0.33311292285246896, 0.47831967790630825, 0.2510770234307901, 0.24692705852935903, 0.48035384518917157, 0.23665669042404747, 0.42822797182165473, 0.30575513751038663, 0.1384240955857755, 0.21920609124034363, 0.2686337200810871, 0.3370099124725975, 0.27722345291883144, 0.2798287908940785, 0.15815476806470508, 0.3293521774471102, 0.31052351305580883, 0.21880804130783393, 0.23147323015166554, 0.21474406873959928, 0.20490956936190807, 0.23457103325372197, 0.2437305802702212, 0.2149709844811336, 0.2439850908753306, 0.23335761715769676, 0.22350210307888363, 0.18574197878039322, 0.17837020396905356, 0.2155230598069725, 0.19237625339917275, 0.19959724030473103, 0.17669365044360585, 0.21076136807788703, 0.20118337457794033, 0.9214437223791965, 0.1752419304252275, 0.14813261835915315, 0.9234731888523364, 0.1891957800520545, 0.20075856307887285, 0.14236009654782922, 0.16951293172035564, 0.9211706307592998, 0.8938069567687922, 0.21337860007900866, 0.8903324751288573, 0.8659545435144563, 0.8852123370256878, 0.15603433731549, 0.7809371264146462, 0.8691346964491866, 0.8944526734985341, 0.20381020220067825, 0.1898466526025595, 0.19237450905935372, 0.17981768391588937, 0.21853539690398427, 0.19684832418329457, 0.1848171428814328, 0.22912533053187922, 0.19210062702914676, 0.09359997277557464, 0.08913187308574833, 0.07349795134290049, 0.1072000129024635, 0.10987724557902478, 0.1309134338923733, 0.0948732229011211, 0.08903264488315288, 0.0935723001019283]}, "mutation_prompt": null}
{"id": "517fec2d-3277-4b1f-a7eb-bee1c2feb929", "solution": "import numpy as np\n\nclass SelfAdaptiveQuantumPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Increased population for better diversity\n        self.w = 0.7  # Higher inertia for initial exploration\n        self.cr = 0.85  # Adaptive crossover rate\n        self.f1 = 0.4  # Lower mutation factor for finer search\n        self.alpha = 0.5  # New gradient influence factor\n        self.q_prob = 0.15  # Increased quantum probability for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                if np.random.rand() < self.q_prob:\n                    quantum_shift = np.random.uniform(-1, 1, self.dim)\n                    mutant = global_best + quantum_shift * (x1 - x2)\n                else:\n                    mutant = x0 + self.f1 * (x1 - x2) + self.f1 * (x2 - x3)\n\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n\n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.w = 0.5 + 0.2 * (1 - evaluations / self.budget)  # Adaptive inertia adjustment\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                gradient = np.random.uniform(-0.1, 0.1, self.dim)\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]) +\n                                 self.alpha * gradient)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n                f_val = func(population[i])\n                evaluations += 1\n\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n\n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n        return global_best", "name": "SelfAdaptiveQuantumPSO", "description": "A Self-Adaptive Quantum-Inspired Particle Swarm Optimization with Gradient-Assisted Velocity and Adaptive Parameters for Improved Convergence.", "configspace": "", "generation": 87, "fitness": 0.25913457750834357, "feedback": "The algorithm SelfAdaptiveQuantumPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.23.", "error": "", "parent_id": "75c77c35-a246-4a87-a69a-b2a131576f2e", "metadata": {"aucs": [0.5159555290832554, 0.5137837515545385, 0.5330487256780068, 0.5101158440860256, 0.5224621300519022, 0.50561606902949, 0.5146423234343178, 0.5261644637245626, 0.49517446924921205, 0.09069625640139234, 0.06378620571801363, 0.09923139447992402, 0.022378619657229648, 0.059096266651713636, 0.09008433287332551, 0.04607375875519504, 0.13177758729514988, 0.09925565552545434, 0.14926977257860619, 0.15700012662226526, 0.0980566312821517, 0.10472563354148956, 0.15159111681993287, 0.10697467478589517, 0.15019278569531214, 0.10848558028321986, 0.1701426405557016, 0.11531546336377163, 0.1135769590502792, 0.0880451768935041, 0.11715384422184194, 0.13236118631981442, 0.0861534441699443, 0.11828282409440094, 0.10718494563657754, 0.096601618700908, 0.9800822477575183, 0.9784966619637812, 0.9802541207527048, 0.9730670225320353, 0.9816079330527749, 0.9651749457725588, 0.9815537443534311, 0.973360002950052, 0.9806636335736669, 0.35200086195531466, 0.3642226276731141, 0.34326087960460616, 0.36834773219544215, 0.35305970040957113, 0.37139951449393027, 0.3705931455449013, 0.3502213787893602, 0.33220367511855464, 0.22857837939645753, 0.2258666647873281, 0.7853846197498203, 0.726831556626359, 0.21573694814330524, 0.20526474469930045, 0.7996820107201282, 0.769260406193808, 0.7785452016895663, 0.2214920743409361, 0.12485817194543747, 0.1297581815728197, 0.18920360156077298, 0.13008689963085285, 0.1978209540199497, 0.2057488334772123, 0.1912149378785546, 0.18096703255368385, 0.2148240441958571, 0.21030561267587367, 0.1893936562498797, 0.20428141241392195, 0.1888925775625182, 0.2095797968689902, 0.2024410529458368, 0.20261367045947376, 0.22697667252426923, 0.03941983253257708, 0.06673343700119316, 0.027363626991097068, 0.02155828061084686, 0.01666236521230713, 9.999999999998899e-05, 0.027490912149750746, 9.999999999998899e-05, 0.07035200693602184, 0.12332059882905122, 0.06562049266551362, 0.13027276320737347, 0.11229747935293177, 0.0957844070480367, 0.08323837168707215, 0.12945923033495743, 0.07605246896790052, 0.11723407798330554, 9.999999999998899e-05, 0.023733495375806157, 0.017553652825920807, 0.043398672272128125, 0.022177581047169936, 0.0023166859592914646, 0.02849640908812867, 0.005144613336842685, 0.018799475186853543, 0.13994439018767768, 0.12474193674761469, 0.09325924123235896, 0.1364759040904726, 0.10133581289527793, 0.14558419135791723, 0.07665001349081813, 0.07984151500469705, 0.12409323135585293, 0.47321135494221955, 0.4647111245037783, 0.4625292214966563, 0.44271192204698495, 0.4426472548398215, 0.4723813041448576, 0.4985422994047324, 0.46451566360825547, 0.4781876175829717, 0.06436254658790441, 0.1332066696056794, 0.09660613648535732, 0.09271209271819025, 0.12576351587830759, 0.12135547971742688, 0.11008181010062057, 0.09425264549801016, 0.10232303995691472, 0.30576845990972656, 0.31081309600146856, 0.22761542668811352, 0.25773059286457534, 0.33525531457657654, 0.2899258584742318, 0.288585598118385, 0.30740171244830095, 0.3374782439650992, 0.32287666523336744, 0.32067791409241597, 0.3404998907458293, 0.32810611117030386, 0.3257869272082977, 0.3332047344800212, 0.32390860269480193, 0.33902759417741657, 0.3388406546309587, 0.23886773989459442, 0.21525869543331533, 0.22991098524083142, 0.27097991100775576, 0.21724940015985117, 0.22570023624407076, 0.214608703574946, 0.25966565595634117, 0.2173845619940623, 0.21408364315448047, 0.20244686970716985, 0.21601976446409366, 0.21959326516800337, 0.26009620639051934, 0.25168766842265633, 0.2012156187025177, 0.23102298512517017, 0.22989696440637297, 0.19552897917547418, 0.21502327953236888, 0.2013533296998532, 0.18945139495968555, 0.1821441676565999, 0.18032885179168112, 0.2439615129644811, 0.237752971558567, 0.200570838868386, 0.1846425399072651, 0.18750862880594366, 0.1982490675526073, 0.7923541606858729, 0.19991806347544394, 0.19525645324826613, 0.1766406813491267, 0.14222277748777667, 0.7783330950303647, 0.7598824726334271, 0.21030317634746265, 0.7061460399674868, 0.7525517848237556, 0.1667138794000641, 0.1691244841098416, 0.21101457142434232, 0.21083350377235766, 0.6936431242795952, 0.18139545854337236, 0.18550571761743562, 0.18899729006180233, 0.1838101943254049, 0.1924563824639497, 0.191974994406244, 0.18293011982354035, 0.1792192374152317, 0.18924697380904132, 0.09101468481681951, 0.08171719512006181, 0.08547948716136211, 0.08030745240797843, 0.08233569862334666, 0.09176721842683166, 0.07791893527108074, 0.09312835942548314, 0.09077101572447477]}, "mutation_prompt": null}
{"id": "798a7ce1-9d18-4a50-8a88-e7164ecc5a82", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Slightly reduced population for efficiency\n        self.w = 0.5  # Adjusted inertia weight for better balance between exploration and exploitation\n        self.cr = 0.9  # Higher crossover rate to encourage exploration\n        self.f1 = 0.5  # Increased mutation factor for stronger primary exploration\n        self.f2 = 0.6  # Adjusted secondary mutation factor for balance\n        self.q_prob = 0.1  # New quantum probability factor for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                if np.random.rand() < self.q_prob:\n                    quantum_shift = np.random.uniform(-1, 1, self.dim)\n                    mutant = global_best + quantum_shift * (x1 - x2)\n                else:\n                    if np.random.rand() < 0.5:\n                        mutant = x0 + self.f1 * (x1 - x2) + self.f1 * (x2 - x3)\n                    else:\n                        mutant = x0 + self.f2 * (global_best - personal_best[i]) + self.f2 * (x1 - x2)\n\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n\n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.w = 0.3 + 0.3 * (1 - evaluations / self.budget)  # Dynamic inertia adjustment\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n                f_val = func(population[i])\n                evaluations += 1\n\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n\n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n        return global_best", "name": "AdaptiveQuantumHybridSwarm", "description": "An Adaptive Quantum-Inspired Hybrid Swarm Algorithm enhancing diversity and convergence through quantum mechanics concepts and adaptive dynamic techniques.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75c77c35-a246-4a87-a69a-b2a131576f2e", "metadata": {"aucs": [0.8732496514529094, 0.8573013930713151, 0.8744986549559657, 0.8537495192369189, 0.8604165374218101, 0.8715142837348789, 0.8704099284618737, 0.8739727116974925, 0.866791729775093, 0.6147791287774991, 0.5226600881736632, 0.6008666291934257, 0.6011496292940641, 0.5712684505558844, 0.6359510051857422, 0.045908637116616746, 0.01791592251565577, 0.624806402963642, 0.1413067638663884, 0.11049529921804513, 0.14184049273655452, 0.1027592472363914, 0.07083301263806674, 0.12002114502220551, 0.12881546204892624, 0.12197346576387535, 0.14062731601841005, 0.10096466446710328, 0.05413792712396226, 0.09114897185600312, 0.11617455852670533, 0.10909181187858685, 0.1132573468606426, 0.09365470587791058, 0.10954479806391282, 0.06924766798411386, 0.9775912343458948, 0.9856918600781291, 0.9862987405660498, 0.9770175651747988, 0.9778520464721582, 0.9781512659494478, 0.9875080020708764, 0.984098099287295, 0.9849954146772911, 0.7809659532660893, 0.7422826837075494, 0.7507287728082499, 0.7671760563977873, 0.7605455519964089, 0.7573331744633285, 0.7679600916906688, 0.747325999217636, 0.7792914648411364, 0.17111748920970027, 0.3776430589145463, 0.2148095429947724, 0.2812462563154454, 0.8986407239240541, 0.19204913894860254, 0.8747754320911039, 0.875000117318375, 0.868387248003844, 0.7632216912436319, 0.706558114179277, 0.6234648388250588, 0.13136984499800142, 0.7085088269387997, 0.6506806316873934, 0.6826924943191606, 0.6992691458062947, 0.6583057288686354, 0.734243198366002, 0.13115796893246556, 0.6705233511355073, 0.7082745516843774, 0.6388044637379255, 0.1341526369084951, 0.6743382872976676, 0.5567792737889925, 0.13081659118311728, 0.31827943748047594, 9.999999999998899e-05, 0.06633577084044773, 0.5390449000464439, 0.5270845928542385, 9.999999999998899e-05, 0.4392765556044851, 0.008076823072002082, 0.26222948519668543, 0.24804397985012738, 0.36024896744948254, 0.5288676387803491, 0.157319205348598, 0.17810397592288285, 0.6509838503096024, 0.6551795148357473, 0.6692466142047369, 0.6019556617371273, 0.06668243159341114, 0.26091536276258476, 0.22968957066875362, 0.30011996004245634, 0.09151287932329799, 0.3578498530294587, 0.2206967922068861, 0.3854711628213495, 0.20182060529747137, 0.17857461789159057, 0.19558219385245745, 0.3284205134415502, 0.006407430175517814, 0.36619250372402334, 0.2259926234100389, 0.08079187747567196, 0.3566449764797007, 0.08114697349173805, 0.7344845036158891, 0.7483427178164258, 0.7486489878661621, 0.7518594363355056, 0.7634733283067978, 0.802694999760851, 0.6843882425772356, 0.7299911756040789, 0.7593858556799229, 0.07580857596923452, 0.14444118890065638, 0.10268166408293322, 0.14555068634590862, 0.1133105093208967, 0.7033352848670488, 0.1039592203854578, 0.07995791523730145, 0.10458196920510487, 0.1700282082103276, 0.6464594007522839, 0.23788986441283433, 0.24848668452709644, 0.26787452178738946, 0.19298062414556083, 0.421872478808335, 0.19843099372711004, 0.26917347133106273, 0.5491013415157248, 0.33311292285246896, 0.47831967790630825, 0.2510770234307901, 0.24692705852935903, 0.48035384518917157, 0.23665669042404747, 0.42822797182165473, 0.30575513751038663, 0.1384240955857755, 0.21920609124034363, 0.2686337200810871, 0.3370099124725975, 0.27722345291883144, 0.2798287908940785, 0.15815476806470508, 0.3293521774471102, 0.31052351305580883, 0.21880804130783393, 0.23147323015166554, 0.21474406873959928, 0.20490956936190807, 0.23457103325372197, 0.2437305802702212, 0.2149709844811336, 0.2439850908753306, 0.23335761715769676, 0.22350210307888363, 0.18574197878039322, 0.17837020396905356, 0.2155230598069725, 0.19237625339917275, 0.19959724030473103, 0.17669365044360585, 0.21076136807788703, 0.20118337457794033, 0.9214437223791965, 0.1752419304252275, 0.14813261835915315, 0.9234731888523364, 0.1891957800520545, 0.20075856307887285, 0.14236009654782922, 0.16951293172035564, 0.9211706307592998, 0.8938069567687922, 0.21337860007900866, 0.8903324751288573, 0.8659545435144563, 0.8852123370256878, 0.15603433731549, 0.7809371264146462, 0.8691346964491866, 0.8944526734985341, 0.20381020220067825, 0.1898466526025595, 0.19237450905935372, 0.17981768391588937, 0.21853539690398427, 0.19684832418329457, 0.1848171428814328, 0.22912533053187922, 0.19210062702914676, 0.09359997277557464, 0.08913187308574833, 0.07349795134290049, 0.1072000129024635, 0.10987724557902478, 0.1309134338923733, 0.0948732229011211, 0.08903264488315288, 0.0935723001019283]}, "mutation_prompt": null}
{"id": "065fd25f-c304-4cad-ba8a-c73c5858a4d4", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Slightly reduced population for efficiency\n        self.w = 0.5  # Adjusted inertia weight for better balance between exploration and exploitation\n        self.cr = 0.9  # Higher crossover rate to encourage exploration\n        self.f1 = 0.5  # Increased mutation factor for stronger primary exploration\n        self.f2 = 0.6  # Adjusted secondary mutation factor for balance\n        self.q_prob = 0.1  # New quantum probability factor for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                if np.random.rand() < self.q_prob:\n                    quantum_shift = np.random.uniform(-1, 1, self.dim)\n                    mutant = global_best + quantum_shift * (x1 - x2)\n                else:\n                    if np.random.rand() < 0.5:\n                        mutant = x0 + self.f1 * (x1 - x2) + self.f1 * (x2 - x3)\n                    else:\n                        mutant = x0 + self.f2 * (global_best - personal_best[i]) + self.f2 * (x1 - x2)\n\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n\n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.w = 0.3 + 0.3 * (1 - evaluations / self.budget)  # Dynamic inertia adjustment\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n                f_val = func(population[i])\n                evaluations += 1\n\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n\n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n        return global_best", "name": "AdaptiveQuantumHybridSwarm", "description": "An Adaptive Quantum-Inspired Hybrid Swarm Algorithm enhancing diversity and convergence through quantum mechanics concepts and adaptive dynamic techniques.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75c77c35-a246-4a87-a69a-b2a131576f2e", "metadata": {"aucs": [0.8732496514529094, 0.8573013930713151, 0.8744986549559657, 0.8537495192369189, 0.8604165374218101, 0.8715142837348789, 0.8704099284618737, 0.8739727116974925, 0.866791729775093, 0.6147791287774991, 0.5226600881736632, 0.6008666291934257, 0.6011496292940641, 0.5712684505558844, 0.6359510051857422, 0.045908637116616746, 0.01791592251565577, 0.624806402963642, 0.1413067638663884, 0.11049529921804513, 0.14184049273655452, 0.1027592472363914, 0.07083301263806674, 0.12002114502220551, 0.12881546204892624, 0.12197346576387535, 0.14062731601841005, 0.10096466446710328, 0.05413792712396226, 0.09114897185600312, 0.11617455852670533, 0.10909181187858685, 0.1132573468606426, 0.09365470587791058, 0.10954479806391282, 0.06924766798411386, 0.9775912343458948, 0.9856918600781291, 0.9862987405660498, 0.9770175651747988, 0.9778520464721582, 0.9781512659494478, 0.9875080020708764, 0.984098099287295, 0.9849954146772911, 0.7809659532660893, 0.7422826837075494, 0.7507287728082499, 0.7671760563977873, 0.7605455519964089, 0.7573331744633285, 0.7679600916906688, 0.747325999217636, 0.7792914648411364, 0.17111748920970027, 0.3776430589145463, 0.2148095429947724, 0.2812462563154454, 0.8986407239240541, 0.19204913894860254, 0.8747754320911039, 0.875000117318375, 0.868387248003844, 0.7632216912436319, 0.706558114179277, 0.6234648388250588, 0.13136984499800142, 0.7085088269387997, 0.6506806316873934, 0.6826924943191606, 0.6992691458062947, 0.6583057288686354, 0.734243198366002, 0.13115796893246556, 0.6705233511355073, 0.7082745516843774, 0.6388044637379255, 0.1341526369084951, 0.6743382872976676, 0.5567792737889925, 0.13081659118311728, 0.31827943748047594, 9.999999999998899e-05, 0.06633577084044773, 0.5390449000464439, 0.5270845928542385, 9.999999999998899e-05, 0.4392765556044851, 0.008076823072002082, 0.26222948519668543, 0.24804397985012738, 0.36024896744948254, 0.5288676387803491, 0.157319205348598, 0.17810397592288285, 0.6509838503096024, 0.6551795148357473, 0.6692466142047369, 0.6019556617371273, 0.06668243159341114, 0.26091536276258476, 0.22968957066875362, 0.30011996004245634, 0.09151287932329799, 0.3578498530294587, 0.2206967922068861, 0.3854711628213495, 0.20182060529747137, 0.17857461789159057, 0.19558219385245745, 0.3284205134415502, 0.006407430175517814, 0.36619250372402334, 0.2259926234100389, 0.08079187747567196, 0.3566449764797007, 0.08114697349173805, 0.7344845036158891, 0.7483427178164258, 0.7486489878661621, 0.7518594363355056, 0.7634733283067978, 0.802694999760851, 0.6843882425772356, 0.7299911756040789, 0.7593858556799229, 0.07580857596923452, 0.14444118890065638, 0.10268166408293322, 0.14555068634590862, 0.1133105093208967, 0.7033352848670488, 0.1039592203854578, 0.07995791523730145, 0.10458196920510487, 0.1700282082103276, 0.6464594007522839, 0.23788986441283433, 0.24848668452709644, 0.26787452178738946, 0.19298062414556083, 0.421872478808335, 0.19843099372711004, 0.26917347133106273, 0.5491013415157248, 0.33311292285246896, 0.47831967790630825, 0.2510770234307901, 0.24692705852935903, 0.48035384518917157, 0.23665669042404747, 0.42822797182165473, 0.30575513751038663, 0.1384240955857755, 0.21920609124034363, 0.2686337200810871, 0.3370099124725975, 0.27722345291883144, 0.2798287908940785, 0.15815476806470508, 0.3293521774471102, 0.31052351305580883, 0.21880804130783393, 0.23147323015166554, 0.21474406873959928, 0.20490956936190807, 0.23457103325372197, 0.2437305802702212, 0.2149709844811336, 0.2439850908753306, 0.23335761715769676, 0.22350210307888363, 0.18574197878039322, 0.17837020396905356, 0.2155230598069725, 0.19237625339917275, 0.19959724030473103, 0.17669365044360585, 0.21076136807788703, 0.20118337457794033, 0.9214437223791965, 0.1752419304252275, 0.14813261835915315, 0.9234731888523364, 0.1891957800520545, 0.20075856307887285, 0.14236009654782922, 0.16951293172035564, 0.9211706307592998, 0.8938069567687922, 0.21337860007900866, 0.8903324751288573, 0.8659545435144563, 0.8852123370256878, 0.15603433731549, 0.7809371264146462, 0.8691346964491866, 0.8944526734985341, 0.20381020220067825, 0.1898466526025595, 0.19237450905935372, 0.17981768391588937, 0.21853539690398427, 0.19684832418329457, 0.1848171428814328, 0.22912533053187922, 0.19210062702914676, 0.09359997277557464, 0.08913187308574833, 0.07349795134290049, 0.1072000129024635, 0.10987724557902478, 0.1309134338923733, 0.0948732229011211, 0.08903264488315288, 0.0935723001019283]}, "mutation_prompt": null}
{"id": "0fb40d6d-cce4-47a5-a532-94d7c9e859cd", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Slightly reduced population for efficiency\n        self.w = 0.5  # Adjusted inertia weight for better balance between exploration and exploitation\n        self.cr = 0.9  # Higher crossover rate to encourage exploration\n        self.f1 = 0.5  # Increased mutation factor for stronger primary exploration\n        self.f2 = 0.6  # Adjusted secondary mutation factor for balance\n        self.q_prob = 0.1  # New quantum probability factor for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                if np.random.rand() < self.q_prob:\n                    quantum_shift = np.random.uniform(-1, 1, self.dim)\n                    mutant = global_best + quantum_shift * (x1 - x2)\n                else:\n                    if np.random.rand() < 0.5:\n                        mutant = x0 + self.f1 * (x1 - x2) + self.f1 * (x2 - x3)\n                    else:\n                        mutant = x0 + self.f2 * (global_best - personal_best[i]) + self.f2 * (x1 - x2)\n\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n\n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.w = 0.3 + 0.3 * (1 - evaluations / self.budget)  # Dynamic inertia adjustment\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n                f_val = func(population[i])\n                evaluations += 1\n\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n\n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n        return global_best", "name": "AdaptiveQuantumHybridSwarm", "description": "An Adaptive Quantum-Inspired Hybrid Swarm Algorithm enhancing diversity and convergence through quantum mechanics concepts and adaptive dynamic techniques.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75c77c35-a246-4a87-a69a-b2a131576f2e", "metadata": {"aucs": [0.8732496514529094, 0.8573013930713151, 0.8744986549559657, 0.8537495192369189, 0.8604165374218101, 0.8715142837348789, 0.8704099284618737, 0.8739727116974925, 0.866791729775093, 0.6147791287774991, 0.5226600881736632, 0.6008666291934257, 0.6011496292940641, 0.5712684505558844, 0.6359510051857422, 0.045908637116616746, 0.01791592251565577, 0.624806402963642, 0.1413067638663884, 0.11049529921804513, 0.14184049273655452, 0.1027592472363914, 0.07083301263806674, 0.12002114502220551, 0.12881546204892624, 0.12197346576387535, 0.14062731601841005, 0.10096466446710328, 0.05413792712396226, 0.09114897185600312, 0.11617455852670533, 0.10909181187858685, 0.1132573468606426, 0.09365470587791058, 0.10954479806391282, 0.06924766798411386, 0.9775912343458948, 0.9856918600781291, 0.9862987405660498, 0.9770175651747988, 0.9778520464721582, 0.9781512659494478, 0.9875080020708764, 0.984098099287295, 0.9849954146772911, 0.7809659532660893, 0.7422826837075494, 0.7507287728082499, 0.7671760563977873, 0.7605455519964089, 0.7573331744633285, 0.7679600916906688, 0.747325999217636, 0.7792914648411364, 0.17111748920970027, 0.3776430589145463, 0.2148095429947724, 0.2812462563154454, 0.8986407239240541, 0.19204913894860254, 0.8747754320911039, 0.875000117318375, 0.868387248003844, 0.7632216912436319, 0.706558114179277, 0.6234648388250588, 0.13136984499800142, 0.7085088269387997, 0.6506806316873934, 0.6826924943191606, 0.6992691458062947, 0.6583057288686354, 0.734243198366002, 0.13115796893246556, 0.6705233511355073, 0.7082745516843774, 0.6388044637379255, 0.1341526369084951, 0.6743382872976676, 0.5567792737889925, 0.13081659118311728, 0.31827943748047594, 9.999999999998899e-05, 0.06633577084044773, 0.5390449000464439, 0.5270845928542385, 9.999999999998899e-05, 0.4392765556044851, 0.008076823072002082, 0.26222948519668543, 0.24804397985012738, 0.36024896744948254, 0.5288676387803491, 0.157319205348598, 0.17810397592288285, 0.6509838503096024, 0.6551795148357473, 0.6692466142047369, 0.6019556617371273, 0.06668243159341114, 0.26091536276258476, 0.22968957066875362, 0.30011996004245634, 0.09151287932329799, 0.3578498530294587, 0.2206967922068861, 0.3854711628213495, 0.20182060529747137, 0.17857461789159057, 0.19558219385245745, 0.3284205134415502, 0.006407430175517814, 0.36619250372402334, 0.2259926234100389, 0.08079187747567196, 0.3566449764797007, 0.08114697349173805, 0.7344845036158891, 0.7483427178164258, 0.7486489878661621, 0.7518594363355056, 0.7634733283067978, 0.802694999760851, 0.6843882425772356, 0.7299911756040789, 0.7593858556799229, 0.07580857596923452, 0.14444118890065638, 0.10268166408293322, 0.14555068634590862, 0.1133105093208967, 0.7033352848670488, 0.1039592203854578, 0.07995791523730145, 0.10458196920510487, 0.1700282082103276, 0.6464594007522839, 0.23788986441283433, 0.24848668452709644, 0.26787452178738946, 0.19298062414556083, 0.421872478808335, 0.19843099372711004, 0.26917347133106273, 0.5491013415157248, 0.33311292285246896, 0.47831967790630825, 0.2510770234307901, 0.24692705852935903, 0.48035384518917157, 0.23665669042404747, 0.42822797182165473, 0.30575513751038663, 0.1384240955857755, 0.21920609124034363, 0.2686337200810871, 0.3370099124725975, 0.27722345291883144, 0.2798287908940785, 0.15815476806470508, 0.3293521774471102, 0.31052351305580883, 0.21880804130783393, 0.23147323015166554, 0.21474406873959928, 0.20490956936190807, 0.23457103325372197, 0.2437305802702212, 0.2149709844811336, 0.2439850908753306, 0.23335761715769676, 0.22350210307888363, 0.18574197878039322, 0.17837020396905356, 0.2155230598069725, 0.19237625339917275, 0.19959724030473103, 0.17669365044360585, 0.21076136807788703, 0.20118337457794033, 0.9214437223791965, 0.1752419304252275, 0.14813261835915315, 0.9234731888523364, 0.1891957800520545, 0.20075856307887285, 0.14236009654782922, 0.16951293172035564, 0.9211706307592998, 0.8938069567687922, 0.21337860007900866, 0.8903324751288573, 0.8659545435144563, 0.8852123370256878, 0.15603433731549, 0.7809371264146462, 0.8691346964491866, 0.8944526734985341, 0.20381020220067825, 0.1898466526025595, 0.19237450905935372, 0.17981768391588937, 0.21853539690398427, 0.19684832418329457, 0.1848171428814328, 0.22912533053187922, 0.19210062702914676, 0.09359997277557464, 0.08913187308574833, 0.07349795134290049, 0.1072000129024635, 0.10987724557902478, 0.1309134338923733, 0.0948732229011211, 0.08903264488315288, 0.0935723001019283]}, "mutation_prompt": null}
{"id": "460e4d5c-f07e-4bc1-8e89-e4f41745a7d3", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Slightly reduced population for efficiency\n        self.w = 0.5  # Adjusted inertia weight for better balance between exploration and exploitation\n        self.cr = 0.9  # Higher crossover rate to encourage exploration\n        self.f1 = 0.5  # Increased mutation factor for stronger primary exploration\n        self.f2 = 0.6  # Adjusted secondary mutation factor for balance\n        self.q_prob = 0.1  # New quantum probability factor for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                if np.random.rand() < self.q_prob:\n                    quantum_shift = np.random.uniform(-1, 1, self.dim)\n                    mutant = global_best + quantum_shift * (x1 - x2)\n                else:\n                    if np.random.rand() < 0.5:\n                        mutant = x0 + self.f1 * (x1 - x2) + self.f1 * (x2 - x3)\n                    else:\n                        mutant = x0 + self.f2 * (global_best - personal_best[i]) + self.f2 * (x1 - x2)\n\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n\n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.w = 0.3 + 0.3 * (1 - evaluations / self.budget)  # Dynamic inertia adjustment\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n                f_val = func(population[i])\n                evaluations += 1\n\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n\n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n        return global_best", "name": "AdaptiveQuantumHybridSwarm", "description": "An Adaptive Quantum-Inspired Hybrid Swarm Algorithm enhancing diversity and convergence through quantum mechanics concepts and adaptive dynamic techniques.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75c77c35-a246-4a87-a69a-b2a131576f2e", "metadata": {"aucs": [0.8732496514529094, 0.8573013930713151, 0.8744986549559657, 0.8537495192369189, 0.8604165374218101, 0.8715142837348789, 0.8704099284618737, 0.8739727116974925, 0.866791729775093, 0.6147791287774991, 0.5226600881736632, 0.6008666291934257, 0.6011496292940641, 0.5712684505558844, 0.6359510051857422, 0.045908637116616746, 0.01791592251565577, 0.624806402963642, 0.1413067638663884, 0.11049529921804513, 0.14184049273655452, 0.1027592472363914, 0.07083301263806674, 0.12002114502220551, 0.12881546204892624, 0.12197346576387535, 0.14062731601841005, 0.10096466446710328, 0.05413792712396226, 0.09114897185600312, 0.11617455852670533, 0.10909181187858685, 0.1132573468606426, 0.09365470587791058, 0.10954479806391282, 0.06924766798411386, 0.9775912343458948, 0.9856918600781291, 0.9862987405660498, 0.9770175651747988, 0.9778520464721582, 0.9781512659494478, 0.9875080020708764, 0.984098099287295, 0.9849954146772911, 0.7809659532660893, 0.7422826837075494, 0.7507287728082499, 0.7671760563977873, 0.7605455519964089, 0.7573331744633285, 0.7679600916906688, 0.747325999217636, 0.7792914648411364, 0.17111748920970027, 0.3776430589145463, 0.2148095429947724, 0.2812462563154454, 0.8986407239240541, 0.19204913894860254, 0.8747754320911039, 0.875000117318375, 0.868387248003844, 0.7632216912436319, 0.706558114179277, 0.6234648388250588, 0.13136984499800142, 0.7085088269387997, 0.6506806316873934, 0.6826924943191606, 0.6992691458062947, 0.6583057288686354, 0.734243198366002, 0.13115796893246556, 0.6705233511355073, 0.7082745516843774, 0.6388044637379255, 0.1341526369084951, 0.6743382872976676, 0.5567792737889925, 0.13081659118311728, 0.31827943748047594, 9.999999999998899e-05, 0.06633577084044773, 0.5390449000464439, 0.5270845928542385, 9.999999999998899e-05, 0.4392765556044851, 0.008076823072002082, 0.26222948519668543, 0.24804397985012738, 0.36024896744948254, 0.5288676387803491, 0.157319205348598, 0.17810397592288285, 0.6509838503096024, 0.6551795148357473, 0.6692466142047369, 0.6019556617371273, 0.06668243159341114, 0.26091536276258476, 0.22968957066875362, 0.30011996004245634, 0.09151287932329799, 0.3578498530294587, 0.2206967922068861, 0.3854711628213495, 0.20182060529747137, 0.17857461789159057, 0.19558219385245745, 0.3284205134415502, 0.006407430175517814, 0.36619250372402334, 0.2259926234100389, 0.08079187747567196, 0.3566449764797007, 0.08114697349173805, 0.7344845036158891, 0.7483427178164258, 0.7486489878661621, 0.7518594363355056, 0.7634733283067978, 0.802694999760851, 0.6843882425772356, 0.7299911756040789, 0.7593858556799229, 0.07580857596923452, 0.14444118890065638, 0.10268166408293322, 0.14555068634590862, 0.1133105093208967, 0.7033352848670488, 0.1039592203854578, 0.07995791523730145, 0.10458196920510487, 0.1700282082103276, 0.6464594007522839, 0.23788986441283433, 0.24848668452709644, 0.26787452178738946, 0.19298062414556083, 0.421872478808335, 0.19843099372711004, 0.26917347133106273, 0.5491013415157248, 0.33311292285246896, 0.47831967790630825, 0.2510770234307901, 0.24692705852935903, 0.48035384518917157, 0.23665669042404747, 0.42822797182165473, 0.30575513751038663, 0.1384240955857755, 0.21920609124034363, 0.2686337200810871, 0.3370099124725975, 0.27722345291883144, 0.2798287908940785, 0.15815476806470508, 0.3293521774471102, 0.31052351305580883, 0.21880804130783393, 0.23147323015166554, 0.21474406873959928, 0.20490956936190807, 0.23457103325372197, 0.2437305802702212, 0.2149709844811336, 0.2439850908753306, 0.23335761715769676, 0.22350210307888363, 0.18574197878039322, 0.17837020396905356, 0.2155230598069725, 0.19237625339917275, 0.19959724030473103, 0.17669365044360585, 0.21076136807788703, 0.20118337457794033, 0.9214437223791965, 0.1752419304252275, 0.14813261835915315, 0.9234731888523364, 0.1891957800520545, 0.20075856307887285, 0.14236009654782922, 0.16951293172035564, 0.9211706307592998, 0.8938069567687922, 0.21337860007900866, 0.8903324751288573, 0.8659545435144563, 0.8852123370256878, 0.15603433731549, 0.7809371264146462, 0.8691346964491866, 0.8944526734985341, 0.20381020220067825, 0.1898466526025595, 0.19237450905935372, 0.17981768391588937, 0.21853539690398427, 0.19684832418329457, 0.1848171428814328, 0.22912533053187922, 0.19210062702914676, 0.09359997277557464, 0.08913187308574833, 0.07349795134290049, 0.1072000129024635, 0.10987724557902478, 0.1309134338923733, 0.0948732229011211, 0.08903264488315288, 0.0935723001019283]}, "mutation_prompt": null}
{"id": "b5606fa0-d600-41bf-8f40-8df4c297bc62", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Slightly reduced population for efficiency\n        self.w = 0.5  # Adjusted inertia weight for better balance between exploration and exploitation\n        self.cr = 0.9  # Higher crossover rate to encourage exploration\n        self.f1 = 0.5  # Increased mutation factor for stronger primary exploration\n        self.f2 = 0.6  # Adjusted secondary mutation factor for balance\n        self.q_prob = 0.1  # New quantum probability factor for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                if np.random.rand() < self.q_prob:\n                    quantum_shift = np.random.uniform(-1, 1, self.dim)\n                    mutant = global_best + quantum_shift * (x1 - x2)\n                else:\n                    if np.random.rand() < 0.5:\n                        mutant = x0 + self.f1 * (x1 - x2) + self.f1 * (x2 - x3)\n                    else:\n                        mutant = x0 + self.f2 * (global_best - personal_best[i]) + self.f2 * (x1 - x2)\n\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n\n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.w = 0.3 + 0.3 * (1 - evaluations / self.budget)  # Dynamic inertia adjustment\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n                f_val = func(population[i])\n                evaluations += 1\n\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n\n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n        return global_best", "name": "AdaptiveQuantumHybridSwarm", "description": "An Adaptive Quantum-Inspired Hybrid Swarm Algorithm enhancing diversity and convergence through quantum mechanics concepts and adaptive dynamic techniques.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75c77c35-a246-4a87-a69a-b2a131576f2e", "metadata": {"aucs": [0.8732496514529094, 0.8573013930713151, 0.8744986549559657, 0.8537495192369189, 0.8604165374218101, 0.8715142837348789, 0.8704099284618737, 0.8739727116974925, 0.866791729775093, 0.6147791287774991, 0.5226600881736632, 0.6008666291934257, 0.6011496292940641, 0.5712684505558844, 0.6359510051857422, 0.045908637116616746, 0.01791592251565577, 0.624806402963642, 0.1413067638663884, 0.11049529921804513, 0.14184049273655452, 0.1027592472363914, 0.07083301263806674, 0.12002114502220551, 0.12881546204892624, 0.12197346576387535, 0.14062731601841005, 0.10096466446710328, 0.05413792712396226, 0.09114897185600312, 0.11617455852670533, 0.10909181187858685, 0.1132573468606426, 0.09365470587791058, 0.10954479806391282, 0.06924766798411386, 0.9775912343458948, 0.9856918600781291, 0.9862987405660498, 0.9770175651747988, 0.9778520464721582, 0.9781512659494478, 0.9875080020708764, 0.984098099287295, 0.9849954146772911, 0.7809659532660893, 0.7422826837075494, 0.7507287728082499, 0.7671760563977873, 0.7605455519964089, 0.7573331744633285, 0.7679600916906688, 0.747325999217636, 0.7792914648411364, 0.17111748920970027, 0.3776430589145463, 0.2148095429947724, 0.2812462563154454, 0.8986407239240541, 0.19204913894860254, 0.8747754320911039, 0.875000117318375, 0.868387248003844, 0.7632216912436319, 0.706558114179277, 0.6234648388250588, 0.13136984499800142, 0.7085088269387997, 0.6506806316873934, 0.6826924943191606, 0.6992691458062947, 0.6583057288686354, 0.734243198366002, 0.13115796893246556, 0.6705233511355073, 0.7082745516843774, 0.6388044637379255, 0.1341526369084951, 0.6743382872976676, 0.5567792737889925, 0.13081659118311728, 0.31827943748047594, 9.999999999998899e-05, 0.06633577084044773, 0.5390449000464439, 0.5270845928542385, 9.999999999998899e-05, 0.4392765556044851, 0.008076823072002082, 0.26222948519668543, 0.24804397985012738, 0.36024896744948254, 0.5288676387803491, 0.157319205348598, 0.17810397592288285, 0.6509838503096024, 0.6551795148357473, 0.6692466142047369, 0.6019556617371273, 0.06668243159341114, 0.26091536276258476, 0.22968957066875362, 0.30011996004245634, 0.09151287932329799, 0.3578498530294587, 0.2206967922068861, 0.3854711628213495, 0.20182060529747137, 0.17857461789159057, 0.19558219385245745, 0.3284205134415502, 0.006407430175517814, 0.36619250372402334, 0.2259926234100389, 0.08079187747567196, 0.3566449764797007, 0.08114697349173805, 0.7344845036158891, 0.7483427178164258, 0.7486489878661621, 0.7518594363355056, 0.7634733283067978, 0.802694999760851, 0.6843882425772356, 0.7299911756040789, 0.7593858556799229, 0.07580857596923452, 0.14444118890065638, 0.10268166408293322, 0.14555068634590862, 0.1133105093208967, 0.7033352848670488, 0.1039592203854578, 0.07995791523730145, 0.10458196920510487, 0.1700282082103276, 0.6464594007522839, 0.23788986441283433, 0.24848668452709644, 0.26787452178738946, 0.19298062414556083, 0.421872478808335, 0.19843099372711004, 0.26917347133106273, 0.5491013415157248, 0.33311292285246896, 0.47831967790630825, 0.2510770234307901, 0.24692705852935903, 0.48035384518917157, 0.23665669042404747, 0.42822797182165473, 0.30575513751038663, 0.1384240955857755, 0.21920609124034363, 0.2686337200810871, 0.3370099124725975, 0.27722345291883144, 0.2798287908940785, 0.15815476806470508, 0.3293521774471102, 0.31052351305580883, 0.21880804130783393, 0.23147323015166554, 0.21474406873959928, 0.20490956936190807, 0.23457103325372197, 0.2437305802702212, 0.2149709844811336, 0.2439850908753306, 0.23335761715769676, 0.22350210307888363, 0.18574197878039322, 0.17837020396905356, 0.2155230598069725, 0.19237625339917275, 0.19959724030473103, 0.17669365044360585, 0.21076136807788703, 0.20118337457794033, 0.9214437223791965, 0.1752419304252275, 0.14813261835915315, 0.9234731888523364, 0.1891957800520545, 0.20075856307887285, 0.14236009654782922, 0.16951293172035564, 0.9211706307592998, 0.8938069567687922, 0.21337860007900866, 0.8903324751288573, 0.8659545435144563, 0.8852123370256878, 0.15603433731549, 0.7809371264146462, 0.8691346964491866, 0.8944526734985341, 0.20381020220067825, 0.1898466526025595, 0.19237450905935372, 0.17981768391588937, 0.21853539690398427, 0.19684832418329457, 0.1848171428814328, 0.22912533053187922, 0.19210062702914676, 0.09359997277557464, 0.08913187308574833, 0.07349795134290049, 0.1072000129024635, 0.10987724557902478, 0.1309134338923733, 0.0948732229011211, 0.08903264488315288, 0.0935723001019283]}, "mutation_prompt": null}
{"id": "0b23cfbe-6fbc-4a2c-bb28-e10ec346e4ef", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Slightly reduced population for efficiency\n        self.w = 0.5  # Adjusted inertia weight for better balance between exploration and exploitation\n        self.cr = 0.9  # Higher crossover rate to encourage exploration\n        self.f1 = 0.5  # Increased mutation factor for stronger primary exploration\n        self.f2 = 0.6  # Adjusted secondary mutation factor for balance\n        self.q_prob = 0.1  # New quantum probability factor for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                if np.random.rand() < self.q_prob:\n                    quantum_shift = np.random.uniform(-1, 1, self.dim)\n                    mutant = global_best + quantum_shift * (x1 - x2)\n                else:\n                    if np.random.rand() < 0.5:\n                        mutant = x0 + self.f1 * (x1 - x2) + self.f1 * (x2 - x3)\n                    else:\n                        mutant = x0 + self.f2 * (global_best - personal_best[i]) + self.f2 * (x1 - x2)\n\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n\n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.w = 0.3 + 0.3 * (1 - evaluations / self.budget)  # Dynamic inertia adjustment\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n                f_val = func(population[i])\n                evaluations += 1\n\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n\n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n        return global_best", "name": "AdaptiveQuantumHybridSwarm", "description": "An Adaptive Quantum-Inspired Hybrid Swarm Algorithm enhancing diversity and convergence through quantum mechanics concepts and adaptive dynamic techniques.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75c77c35-a246-4a87-a69a-b2a131576f2e", "metadata": {"aucs": [0.8732496514529094, 0.8573013930713151, 0.8744986549559657, 0.8537495192369189, 0.8604165374218101, 0.8715142837348789, 0.8704099284618737, 0.8739727116974925, 0.866791729775093, 0.6147791287774991, 0.5226600881736632, 0.6008666291934257, 0.6011496292940641, 0.5712684505558844, 0.6359510051857422, 0.045908637116616746, 0.01791592251565577, 0.624806402963642, 0.1413067638663884, 0.11049529921804513, 0.14184049273655452, 0.1027592472363914, 0.07083301263806674, 0.12002114502220551, 0.12881546204892624, 0.12197346576387535, 0.14062731601841005, 0.10096466446710328, 0.05413792712396226, 0.09114897185600312, 0.11617455852670533, 0.10909181187858685, 0.1132573468606426, 0.09365470587791058, 0.10954479806391282, 0.06924766798411386, 0.9775912343458948, 0.9856918600781291, 0.9862987405660498, 0.9770175651747988, 0.9778520464721582, 0.9781512659494478, 0.9875080020708764, 0.984098099287295, 0.9849954146772911, 0.7809659532660893, 0.7422826837075494, 0.7507287728082499, 0.7671760563977873, 0.7605455519964089, 0.7573331744633285, 0.7679600916906688, 0.747325999217636, 0.7792914648411364, 0.17111748920970027, 0.3776430589145463, 0.2148095429947724, 0.2812462563154454, 0.8986407239240541, 0.19204913894860254, 0.8747754320911039, 0.875000117318375, 0.868387248003844, 0.7632216912436319, 0.706558114179277, 0.6234648388250588, 0.13136984499800142, 0.7085088269387997, 0.6506806316873934, 0.6826924943191606, 0.6992691458062947, 0.6583057288686354, 0.734243198366002, 0.13115796893246556, 0.6705233511355073, 0.7082745516843774, 0.6388044637379255, 0.1341526369084951, 0.6743382872976676, 0.5567792737889925, 0.13081659118311728, 0.31827943748047594, 9.999999999998899e-05, 0.06633577084044773, 0.5390449000464439, 0.5270845928542385, 9.999999999998899e-05, 0.4392765556044851, 0.008076823072002082, 0.26222948519668543, 0.24804397985012738, 0.36024896744948254, 0.5288676387803491, 0.157319205348598, 0.17810397592288285, 0.6509838503096024, 0.6551795148357473, 0.6692466142047369, 0.6019556617371273, 0.06668243159341114, 0.26091536276258476, 0.22968957066875362, 0.30011996004245634, 0.09151287932329799, 0.3578498530294587, 0.2206967922068861, 0.3854711628213495, 0.20182060529747137, 0.17857461789159057, 0.19558219385245745, 0.3284205134415502, 0.006407430175517814, 0.36619250372402334, 0.2259926234100389, 0.08079187747567196, 0.3566449764797007, 0.08114697349173805, 0.7344845036158891, 0.7483427178164258, 0.7486489878661621, 0.7518594363355056, 0.7634733283067978, 0.802694999760851, 0.6843882425772356, 0.7299911756040789, 0.7593858556799229, 0.07580857596923452, 0.14444118890065638, 0.10268166408293322, 0.14555068634590862, 0.1133105093208967, 0.7033352848670488, 0.1039592203854578, 0.07995791523730145, 0.10458196920510487, 0.1700282082103276, 0.6464594007522839, 0.23788986441283433, 0.24848668452709644, 0.26787452178738946, 0.19298062414556083, 0.421872478808335, 0.19843099372711004, 0.26917347133106273, 0.5491013415157248, 0.33311292285246896, 0.47831967790630825, 0.2510770234307901, 0.24692705852935903, 0.48035384518917157, 0.23665669042404747, 0.42822797182165473, 0.30575513751038663, 0.1384240955857755, 0.21920609124034363, 0.2686337200810871, 0.3370099124725975, 0.27722345291883144, 0.2798287908940785, 0.15815476806470508, 0.3293521774471102, 0.31052351305580883, 0.21880804130783393, 0.23147323015166554, 0.21474406873959928, 0.20490956936190807, 0.23457103325372197, 0.2437305802702212, 0.2149709844811336, 0.2439850908753306, 0.23335761715769676, 0.22350210307888363, 0.18574197878039322, 0.17837020396905356, 0.2155230598069725, 0.19237625339917275, 0.19959724030473103, 0.17669365044360585, 0.21076136807788703, 0.20118337457794033, 0.9214437223791965, 0.1752419304252275, 0.14813261835915315, 0.9234731888523364, 0.1891957800520545, 0.20075856307887285, 0.14236009654782922, 0.16951293172035564, 0.9211706307592998, 0.8938069567687922, 0.21337860007900866, 0.8903324751288573, 0.8659545435144563, 0.8852123370256878, 0.15603433731549, 0.7809371264146462, 0.8691346964491866, 0.8944526734985341, 0.20381020220067825, 0.1898466526025595, 0.19237450905935372, 0.17981768391588937, 0.21853539690398427, 0.19684832418329457, 0.1848171428814328, 0.22912533053187922, 0.19210062702914676, 0.09359997277557464, 0.08913187308574833, 0.07349795134290049, 0.1072000129024635, 0.10987724557902478, 0.1309134338923733, 0.0948732229011211, 0.08903264488315288, 0.0935723001019283]}, "mutation_prompt": null}
{"id": "b717875c-f1d5-4bd6-b2a6-330d5fb831ca", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Slightly reduced population for efficiency\n        self.w = 0.5  # Adjusted inertia weight for better balance between exploration and exploitation\n        self.cr = 0.9  # Higher crossover rate to encourage exploration\n        self.f1 = 0.5  # Increased mutation factor for stronger primary exploration\n        self.f2 = 0.6  # Adjusted secondary mutation factor for balance\n        self.q_prob = 0.1  # New quantum probability factor for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                if np.random.rand() < self.q_prob:\n                    quantum_shift = np.random.uniform(-1, 1, self.dim)\n                    mutant = global_best + quantum_shift * (x1 - x2)\n                else:\n                    if np.random.rand() < 0.5:\n                        mutant = x0 + self.f1 * (x1 - x2) + self.f1 * (x2 - x3)\n                    else:\n                        mutant = x0 + self.f2 * (global_best - personal_best[i]) + self.f2 * (x1 - x2)\n\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n\n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.w = 0.3 + 0.3 * (1 - evaluations / self.budget)  # Dynamic inertia adjustment\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n                f_val = func(population[i])\n                evaluations += 1\n\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n\n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n        return global_best", "name": "AdaptiveQuantumHybridSwarm", "description": "An Adaptive Quantum-Inspired Hybrid Swarm Algorithm enhancing diversity and convergence through quantum mechanics concepts and adaptive dynamic techniques.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75c77c35-a246-4a87-a69a-b2a131576f2e", "metadata": {"aucs": [0.8732496514529094, 0.8573013930713151, 0.8744986549559657, 0.8537495192369189, 0.8604165374218101, 0.8715142837348789, 0.8704099284618737, 0.8739727116974925, 0.866791729775093, 0.6147791287774991, 0.5226600881736632, 0.6008666291934257, 0.6011496292940641, 0.5712684505558844, 0.6359510051857422, 0.045908637116616746, 0.01791592251565577, 0.624806402963642, 0.1413067638663884, 0.11049529921804513, 0.14184049273655452, 0.1027592472363914, 0.07083301263806674, 0.12002114502220551, 0.12881546204892624, 0.12197346576387535, 0.14062731601841005, 0.10096466446710328, 0.05413792712396226, 0.09114897185600312, 0.11617455852670533, 0.10909181187858685, 0.1132573468606426, 0.09365470587791058, 0.10954479806391282, 0.06924766798411386, 0.9775912343458948, 0.9856918600781291, 0.9862987405660498, 0.9770175651747988, 0.9778520464721582, 0.9781512659494478, 0.9875080020708764, 0.984098099287295, 0.9849954146772911, 0.7809659532660893, 0.7422826837075494, 0.7507287728082499, 0.7671760563977873, 0.7605455519964089, 0.7573331744633285, 0.7679600916906688, 0.747325999217636, 0.7792914648411364, 0.17111748920970027, 0.3776430589145463, 0.2148095429947724, 0.2812462563154454, 0.8986407239240541, 0.19204913894860254, 0.8747754320911039, 0.875000117318375, 0.868387248003844, 0.7632216912436319, 0.706558114179277, 0.6234648388250588, 0.13136984499800142, 0.7085088269387997, 0.6506806316873934, 0.6826924943191606, 0.6992691458062947, 0.6583057288686354, 0.734243198366002, 0.13115796893246556, 0.6705233511355073, 0.7082745516843774, 0.6388044637379255, 0.1341526369084951, 0.6743382872976676, 0.5567792737889925, 0.13081659118311728, 0.31827943748047594, 9.999999999998899e-05, 0.06633577084044773, 0.5390449000464439, 0.5270845928542385, 9.999999999998899e-05, 0.4392765556044851, 0.008076823072002082, 0.26222948519668543, 0.24804397985012738, 0.36024896744948254, 0.5288676387803491, 0.157319205348598, 0.17810397592288285, 0.6509838503096024, 0.6551795148357473, 0.6692466142047369, 0.6019556617371273, 0.06668243159341114, 0.26091536276258476, 0.22968957066875362, 0.30011996004245634, 0.09151287932329799, 0.3578498530294587, 0.2206967922068861, 0.3854711628213495, 0.20182060529747137, 0.17857461789159057, 0.19558219385245745, 0.3284205134415502, 0.006407430175517814, 0.36619250372402334, 0.2259926234100389, 0.08079187747567196, 0.3566449764797007, 0.08114697349173805, 0.7344845036158891, 0.7483427178164258, 0.7486489878661621, 0.7518594363355056, 0.7634733283067978, 0.802694999760851, 0.6843882425772356, 0.7299911756040789, 0.7593858556799229, 0.07580857596923452, 0.14444118890065638, 0.10268166408293322, 0.14555068634590862, 0.1133105093208967, 0.7033352848670488, 0.1039592203854578, 0.07995791523730145, 0.10458196920510487, 0.1700282082103276, 0.6464594007522839, 0.23788986441283433, 0.24848668452709644, 0.26787452178738946, 0.19298062414556083, 0.421872478808335, 0.19843099372711004, 0.26917347133106273, 0.5491013415157248, 0.33311292285246896, 0.47831967790630825, 0.2510770234307901, 0.24692705852935903, 0.48035384518917157, 0.23665669042404747, 0.42822797182165473, 0.30575513751038663, 0.1384240955857755, 0.21920609124034363, 0.2686337200810871, 0.3370099124725975, 0.27722345291883144, 0.2798287908940785, 0.15815476806470508, 0.3293521774471102, 0.31052351305580883, 0.21880804130783393, 0.23147323015166554, 0.21474406873959928, 0.20490956936190807, 0.23457103325372197, 0.2437305802702212, 0.2149709844811336, 0.2439850908753306, 0.23335761715769676, 0.22350210307888363, 0.18574197878039322, 0.17837020396905356, 0.2155230598069725, 0.19237625339917275, 0.19959724030473103, 0.17669365044360585, 0.21076136807788703, 0.20118337457794033, 0.9214437223791965, 0.1752419304252275, 0.14813261835915315, 0.9234731888523364, 0.1891957800520545, 0.20075856307887285, 0.14236009654782922, 0.16951293172035564, 0.9211706307592998, 0.8938069567687922, 0.21337860007900866, 0.8903324751288573, 0.8659545435144563, 0.8852123370256878, 0.15603433731549, 0.7809371264146462, 0.8691346964491866, 0.8944526734985341, 0.20381020220067825, 0.1898466526025595, 0.19237450905935372, 0.17981768391588937, 0.21853539690398427, 0.19684832418329457, 0.1848171428814328, 0.22912533053187922, 0.19210062702914676, 0.09359997277557464, 0.08913187308574833, 0.07349795134290049, 0.1072000129024635, 0.10987724557902478, 0.1309134338923733, 0.0948732229011211, 0.08903264488315288, 0.0935723001019283]}, "mutation_prompt": null}
{"id": "9aab1dc6-f8d6-49d7-b9fa-602c80892b45", "solution": "import numpy as np\n\nclass MultiStrategyQuantumDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50  # Increased population size for better exploration\n        self.f = 0.5  # Base mutation factor\n        self.cr = 0.9  # Crossover rate\n        self.q_prob = 0.15  # Increased quantum probability for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 5, replace=False)\n                x0, x1, x2, x3, x4 = population[indices]\n                if np.random.rand() < self.q_prob:\n                    quantum_shift = np.random.uniform(-1, 1, self.dim)\n                    mutant = global_best + quantum_shift * (x1 - x2)\n                else:\n                    adaptive_f = self.f + np.random.uniform(-0.1, 0.1)  # Adaptive scaling\n                    if np.random.rand() < 0.5:\n                        mutant = x0 + adaptive_f * (x1 - x2) + adaptive_f * (x2 - x3)\n                    else:\n                        mutant = x0 + adaptive_f * (x0 - personal_best[i]) + adaptive_f * (x1 - x4)\n\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n\n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n        return global_best", "name": "MultiStrategyQuantumDE", "description": "A Multi-Strategy Quantum-Enhanced Differential Evolution algorithm leveraging adaptive scaling and neighborhood learning for improved convergence.", "configspace": "", "generation": 95, "fitness": 0.13753421910826974, "feedback": "The algorithm MultiStrategyQuantumDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.18.", "error": "", "parent_id": "75c77c35-a246-4a87-a69a-b2a131576f2e", "metadata": {"aucs": [0.20231803716905394, 0.20726078313780094, 0.246642824249781, 0.19182842681147183, 0.20294054103402948, 0.21598607052897367, 0.22959726963976412, 0.19662602093588621, 0.2361925918867538, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04793831985681485, 0.0754255645128995, 0.05403530776785015, 0.05231206348356465, 0.051659061693992925, 0.049548860860535004, 0.05108429934034897, 0.044248542852309614, 0.07202814345784259, 0.04605360912266865, 0.03888184741056444, 0.04969032178791988, 0.046153350704036034, 0.04474009008292246, 0.06281078031896792, 0.04024150428900253, 0.03661952051887962, 0.04403108799209643, 0.9789013198831457, 0.9459878154616874, 0.9040237925693542, 0.9293790573375366, 0.8913133258903202, 0.9402999165199185, 0.9071579607693125, 0.9407609013710526, 0.9592057367770481, 0.09950460306176423, 0.09619295830065455, 0.0909523406028897, 0.13162588600338587, 0.11391438187785863, 0.1349236526769788, 0.09445981701493222, 0.08814512172355948, 0.10135355663368228, 0.15526266006084843, 0.20349442329228828, 0.1828400479843988, 0.1628935455733408, 0.1955653415175782, 0.11087888444022942, 0.1604964488649443, 0.1438888136072406, 0.16363820664367756, 0.012258733315816284, 0.009606019820701306, 0.05010331417773595, 9.999999999998899e-05, 0.03226195914495111, 0.05759252438030238, 0.040158437930645, 0.05202804433244024, 0.018928103614669123, 0.025485949832160792, 0.007335364048652759, 0.01276416240610867, 0.06872271536883767, 0.024396099041770647, 0.07040335909177808, 0.08251121529713712, 9.999999999998899e-05, 0.045357979486437605, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03683164216996315, 0.04429018638123183, 0.04018788410002505, 0.04156097303016126, 0.03489089593928585, 0.060377108861622064, 0.04207516648971854, 0.05877856367117784, 0.04495531681500542, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02169286210856003, 0.023484857283734173, 9.999999999998899e-05, 9.999999999998899e-05, 0.001982879687608352, 9.999999999998899e-05, 0.011385544306866002, 0.011048786888041673, 0.0007763768133408622, 0.2253917839333689, 0.24731893208836442, 0.2672099295819478, 0.2303982463096168, 0.20832856867032357, 0.2222931360778837, 0.2270208150741262, 0.23904887057639557, 0.2290812523557696, 0.06370805764275478, 0.05198538381107298, 0.05454559700767636, 0.06583069388196672, 0.049405346900280867, 0.05045846146822275, 0.05837421107259888, 0.039460708648271225, 0.057735808364077434, 0.1510825189401176, 0.12911414110507102, 0.13917916020015364, 0.1314319171056717, 0.127689922881705, 0.12670780344995858, 0.13712953504798608, 0.13177577575728883, 0.13536348481388905, 0.18329116550105995, 0.17627046818698022, 0.21202866624949845, 0.19804303071609242, 0.16899206504825837, 0.2138556209058311, 0.170150108182328, 0.18541748528345003, 0.17913975183438413, 0.11486067262772426, 0.11441493989439644, 0.15422182167984777, 0.13186881158061348, 0.12016651854437099, 0.10099566969248497, 0.12509018611316292, 0.11267841223228092, 0.13443190620798628, 0.16475678405360394, 0.1725831684398641, 0.17837419219405093, 0.16202552742346854, 0.1555037675578469, 0.1483443545224209, 0.16368116024938684, 0.1467079344586273, 0.18158264139931013, 0.14639632549442683, 0.1509386211603514, 0.1628809603277217, 0.1469775099842875, 0.14089014110067477, 0.15873403980240597, 0.16102792156758405, 0.14583751420380864, 0.147258208985658, 0.16386054856944032, 0.20212480250110598, 0.16048658023218543, 0.20066274398990025, 0.16318351651562568, 0.23568486370647612, 0.14924674073240207, 0.1602970761949759, 0.16475654506193183, 0.17858790745368425, 0.1658911978283173, 0.15912170726434705, 0.20698460824500453, 0.18272247312600964, 0.24812118721429566, 0.1690309662028483, 0.1871618923403029, 0.19394486561798285, 0.19487758542166844, 0.18342689693401615, 0.19102585853075083, 0.1841177661446416, 0.17542727048673856, 0.18834101903166522, 0.18161756405589224, 0.19599142022332805, 0.18531824930321816, 0.0526998129016949, 0.07445301156613404, 0.055020006245697695, 0.05104304933385595, 0.07325504257639837, 0.07093979772570869, 0.07286581995499453, 0.050547476094076615, 0.055676938143292665]}, "mutation_prompt": null}
{"id": "8227128a-f68f-4ac1-aaf9-9ecb248cadac", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Slightly reduced population for efficiency\n        self.w = 0.5  # Adjusted inertia weight for better balance between exploration and exploitation\n        self.cr = 0.9  # Higher crossover rate to encourage exploration\n        self.f1 = 0.5  # Increased mutation factor for stronger primary exploration\n        self.f2 = 0.6  # Adjusted secondary mutation factor for balance\n        self.q_prob = 0.1  # New quantum probability factor for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                if np.random.rand() < self.q_prob:\n                    quantum_shift = np.random.uniform(-1, 1, self.dim)\n                    mutant = global_best + quantum_shift * (x1 - x2)\n                else:\n                    if np.random.rand() < 0.5:\n                        mutant = x0 + self.f1 * (x1 - x2) + self.f1 * (x2 - x3)\n                    else:\n                        mutant = x0 + self.f2 * (global_best - personal_best[i]) + self.f2 * (x1 - x2)\n\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n\n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.w = 0.3 + 0.3 * (1 - evaluations / self.budget)  # Dynamic inertia adjustment\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n                f_val = func(population[i])\n                evaluations += 1\n\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n\n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n        return global_best", "name": "AdaptiveQuantumHybridSwarm", "description": "An Adaptive Quantum-Inspired Hybrid Swarm Algorithm enhancing diversity and convergence through quantum mechanics concepts and adaptive dynamic techniques.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75c77c35-a246-4a87-a69a-b2a131576f2e", "metadata": {"aucs": [0.8732496514529094, 0.8573013930713151, 0.8744986549559657, 0.8537495192369189, 0.8604165374218101, 0.8715142837348789, 0.8704099284618737, 0.8739727116974925, 0.866791729775093, 0.6147791287774991, 0.5226600881736632, 0.6008666291934257, 0.6011496292940641, 0.5712684505558844, 0.6359510051857422, 0.045908637116616746, 0.01791592251565577, 0.624806402963642, 0.1413067638663884, 0.11049529921804513, 0.14184049273655452, 0.1027592472363914, 0.07083301263806674, 0.12002114502220551, 0.12881546204892624, 0.12197346576387535, 0.14062731601841005, 0.10096466446710328, 0.05413792712396226, 0.09114897185600312, 0.11617455852670533, 0.10909181187858685, 0.1132573468606426, 0.09365470587791058, 0.10954479806391282, 0.06924766798411386, 0.9775912343458948, 0.9856918600781291, 0.9862987405660498, 0.9770175651747988, 0.9778520464721582, 0.9781512659494478, 0.9875080020708764, 0.984098099287295, 0.9849954146772911, 0.7809659532660893, 0.7422826837075494, 0.7507287728082499, 0.7671760563977873, 0.7605455519964089, 0.7573331744633285, 0.7679600916906688, 0.747325999217636, 0.7792914648411364, 0.17111748920970027, 0.3776430589145463, 0.2148095429947724, 0.2812462563154454, 0.8986407239240541, 0.19204913894860254, 0.8747754320911039, 0.875000117318375, 0.868387248003844, 0.7632216912436319, 0.706558114179277, 0.6234648388250588, 0.13136984499800142, 0.7085088269387997, 0.6506806316873934, 0.6826924943191606, 0.6992691458062947, 0.6583057288686354, 0.734243198366002, 0.13115796893246556, 0.6705233511355073, 0.7082745516843774, 0.6388044637379255, 0.1341526369084951, 0.6743382872976676, 0.5567792737889925, 0.13081659118311728, 0.31827943748047594, 9.999999999998899e-05, 0.06633577084044773, 0.5390449000464439, 0.5270845928542385, 9.999999999998899e-05, 0.4392765556044851, 0.008076823072002082, 0.26222948519668543, 0.24804397985012738, 0.36024896744948254, 0.5288676387803491, 0.157319205348598, 0.17810397592288285, 0.6509838503096024, 0.6551795148357473, 0.6692466142047369, 0.6019556617371273, 0.06668243159341114, 0.26091536276258476, 0.22968957066875362, 0.30011996004245634, 0.09151287932329799, 0.3578498530294587, 0.2206967922068861, 0.3854711628213495, 0.20182060529747137, 0.17857461789159057, 0.19558219385245745, 0.3284205134415502, 0.006407430175517814, 0.36619250372402334, 0.2259926234100389, 0.08079187747567196, 0.3566449764797007, 0.08114697349173805, 0.7344845036158891, 0.7483427178164258, 0.7486489878661621, 0.7518594363355056, 0.7634733283067978, 0.802694999760851, 0.6843882425772356, 0.7299911756040789, 0.7593858556799229, 0.07580857596923452, 0.14444118890065638, 0.10268166408293322, 0.14555068634590862, 0.1133105093208967, 0.7033352848670488, 0.1039592203854578, 0.07995791523730145, 0.10458196920510487, 0.1700282082103276, 0.6464594007522839, 0.23788986441283433, 0.24848668452709644, 0.26787452178738946, 0.19298062414556083, 0.421872478808335, 0.19843099372711004, 0.26917347133106273, 0.5491013415157248, 0.33311292285246896, 0.47831967790630825, 0.2510770234307901, 0.24692705852935903, 0.48035384518917157, 0.23665669042404747, 0.42822797182165473, 0.30575513751038663, 0.1384240955857755, 0.21920609124034363, 0.2686337200810871, 0.3370099124725975, 0.27722345291883144, 0.2798287908940785, 0.15815476806470508, 0.3293521774471102, 0.31052351305580883, 0.21880804130783393, 0.23147323015166554, 0.21474406873959928, 0.20490956936190807, 0.23457103325372197, 0.2437305802702212, 0.2149709844811336, 0.2439850908753306, 0.23335761715769676, 0.22350210307888363, 0.18574197878039322, 0.17837020396905356, 0.2155230598069725, 0.19237625339917275, 0.19959724030473103, 0.17669365044360585, 0.21076136807788703, 0.20118337457794033, 0.9214437223791965, 0.1752419304252275, 0.14813261835915315, 0.9234731888523364, 0.1891957800520545, 0.20075856307887285, 0.14236009654782922, 0.16951293172035564, 0.9211706307592998, 0.8938069567687922, 0.21337860007900866, 0.8903324751288573, 0.8659545435144563, 0.8852123370256878, 0.15603433731549, 0.7809371264146462, 0.8691346964491866, 0.8944526734985341, 0.20381020220067825, 0.1898466526025595, 0.19237450905935372, 0.17981768391588937, 0.21853539690398427, 0.19684832418329457, 0.1848171428814328, 0.22912533053187922, 0.19210062702914676, 0.09359997277557464, 0.08913187308574833, 0.07349795134290049, 0.1072000129024635, 0.10987724557902478, 0.1309134338923733, 0.0948732229011211, 0.08903264488315288, 0.0935723001019283]}, "mutation_prompt": null}
{"id": "319e5946-f0f0-4888-81f7-2847cc74d848", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Slightly reduced population for efficiency\n        self.w = 0.5  # Adjusted inertia weight for better balance between exploration and exploitation\n        self.cr = 0.9  # Higher crossover rate to encourage exploration\n        self.f1 = 0.5  # Increased mutation factor for stronger primary exploration\n        self.f2 = 0.6  # Adjusted secondary mutation factor for balance\n        self.q_prob = 0.1  # New quantum probability factor for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                if np.random.rand() < self.q_prob:\n                    quantum_shift = np.random.uniform(-1, 1, self.dim)\n                    mutant = global_best + quantum_shift * (x1 - x2)\n                else:\n                    if np.random.rand() < 0.5:\n                        mutant = x0 + self.f1 * (x1 - x2) + self.f1 * (x2 - x3)\n                    else:\n                        mutant = x0 + self.f2 * (global_best - personal_best[i]) + self.f2 * (x1 - x2)\n\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n\n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.w = 0.3 + 0.3 * (1 - evaluations / self.budget)  # Dynamic inertia adjustment\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n                f_val = func(population[i])\n                evaluations += 1\n\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n\n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n        return global_best", "name": "AdaptiveQuantumHybridSwarm", "description": "An Adaptive Quantum-Inspired Hybrid Swarm Algorithm enhancing diversity and convergence through quantum mechanics concepts and adaptive dynamic techniques.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75c77c35-a246-4a87-a69a-b2a131576f2e", "metadata": {"aucs": [0.8732496514529094, 0.8573013930713151, 0.8744986549559657, 0.8537495192369189, 0.8604165374218101, 0.8715142837348789, 0.8704099284618737, 0.8739727116974925, 0.866791729775093, 0.6147791287774991, 0.5226600881736632, 0.6008666291934257, 0.6011496292940641, 0.5712684505558844, 0.6359510051857422, 0.045908637116616746, 0.01791592251565577, 0.624806402963642, 0.1413067638663884, 0.11049529921804513, 0.14184049273655452, 0.1027592472363914, 0.07083301263806674, 0.12002114502220551, 0.12881546204892624, 0.12197346576387535, 0.14062731601841005, 0.10096466446710328, 0.05413792712396226, 0.09114897185600312, 0.11617455852670533, 0.10909181187858685, 0.1132573468606426, 0.09365470587791058, 0.10954479806391282, 0.06924766798411386, 0.9775912343458948, 0.9856918600781291, 0.9862987405660498, 0.9770175651747988, 0.9778520464721582, 0.9781512659494478, 0.9875080020708764, 0.984098099287295, 0.9849954146772911, 0.7809659532660893, 0.7422826837075494, 0.7507287728082499, 0.7671760563977873, 0.7605455519964089, 0.7573331744633285, 0.7679600916906688, 0.747325999217636, 0.7792914648411364, 0.17111748920970027, 0.3776430589145463, 0.2148095429947724, 0.2812462563154454, 0.8986407239240541, 0.19204913894860254, 0.8747754320911039, 0.875000117318375, 0.868387248003844, 0.7632216912436319, 0.706558114179277, 0.6234648388250588, 0.13136984499800142, 0.7085088269387997, 0.6506806316873934, 0.6826924943191606, 0.6992691458062947, 0.6583057288686354, 0.734243198366002, 0.13115796893246556, 0.6705233511355073, 0.7082745516843774, 0.6388044637379255, 0.1341526369084951, 0.6743382872976676, 0.5567792737889925, 0.13081659118311728, 0.31827943748047594, 9.999999999998899e-05, 0.06633577084044773, 0.5390449000464439, 0.5270845928542385, 9.999999999998899e-05, 0.4392765556044851, 0.008076823072002082, 0.26222948519668543, 0.24804397985012738, 0.36024896744948254, 0.5288676387803491, 0.157319205348598, 0.17810397592288285, 0.6509838503096024, 0.6551795148357473, 0.6692466142047369, 0.6019556617371273, 0.06668243159341114, 0.26091536276258476, 0.22968957066875362, 0.30011996004245634, 0.09151287932329799, 0.3578498530294587, 0.2206967922068861, 0.3854711628213495, 0.20182060529747137, 0.17857461789159057, 0.19558219385245745, 0.3284205134415502, 0.006407430175517814, 0.36619250372402334, 0.2259926234100389, 0.08079187747567196, 0.3566449764797007, 0.08114697349173805, 0.7344845036158891, 0.7483427178164258, 0.7486489878661621, 0.7518594363355056, 0.7634733283067978, 0.802694999760851, 0.6843882425772356, 0.7299911756040789, 0.7593858556799229, 0.07580857596923452, 0.14444118890065638, 0.10268166408293322, 0.14555068634590862, 0.1133105093208967, 0.7033352848670488, 0.1039592203854578, 0.07995791523730145, 0.10458196920510487, 0.1700282082103276, 0.6464594007522839, 0.23788986441283433, 0.24848668452709644, 0.26787452178738946, 0.19298062414556083, 0.421872478808335, 0.19843099372711004, 0.26917347133106273, 0.5491013415157248, 0.33311292285246896, 0.47831967790630825, 0.2510770234307901, 0.24692705852935903, 0.48035384518917157, 0.23665669042404747, 0.42822797182165473, 0.30575513751038663, 0.1384240955857755, 0.21920609124034363, 0.2686337200810871, 0.3370099124725975, 0.27722345291883144, 0.2798287908940785, 0.15815476806470508, 0.3293521774471102, 0.31052351305580883, 0.21880804130783393, 0.23147323015166554, 0.21474406873959928, 0.20490956936190807, 0.23457103325372197, 0.2437305802702212, 0.2149709844811336, 0.2439850908753306, 0.23335761715769676, 0.22350210307888363, 0.18574197878039322, 0.17837020396905356, 0.2155230598069725, 0.19237625339917275, 0.19959724030473103, 0.17669365044360585, 0.21076136807788703, 0.20118337457794033, 0.9214437223791965, 0.1752419304252275, 0.14813261835915315, 0.9234731888523364, 0.1891957800520545, 0.20075856307887285, 0.14236009654782922, 0.16951293172035564, 0.9211706307592998, 0.8938069567687922, 0.21337860007900866, 0.8903324751288573, 0.8659545435144563, 0.8852123370256878, 0.15603433731549, 0.7809371264146462, 0.8691346964491866, 0.8944526734985341, 0.20381020220067825, 0.1898466526025595, 0.19237450905935372, 0.17981768391588937, 0.21853539690398427, 0.19684832418329457, 0.1848171428814328, 0.22912533053187922, 0.19210062702914676, 0.09359997277557464, 0.08913187308574833, 0.07349795134290049, 0.1072000129024635, 0.10987724557902478, 0.1309134338923733, 0.0948732229011211, 0.08903264488315288, 0.0935723001019283]}, "mutation_prompt": null}
{"id": "e89389e1-872e-4ee7-b25a-6d9698284bd6", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Slightly reduced population for efficiency\n        self.w = 0.5  # Adjusted inertia weight for better balance between exploration and exploitation\n        self.cr = 0.9  # Higher crossover rate to encourage exploration\n        self.f1 = 0.5  # Increased mutation factor for stronger primary exploration\n        self.f2 = 0.6  # Adjusted secondary mutation factor for balance\n        self.q_prob = 0.1  # New quantum probability factor for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                if np.random.rand() < self.q_prob:\n                    quantum_shift = np.random.uniform(-1, 1, self.dim)\n                    mutant = global_best + quantum_shift * (x1 - x2)\n                else:\n                    if np.random.rand() < 0.5:\n                        mutant = x0 + self.f1 * (x1 - x2) + self.f1 * (x2 - x3)\n                    else:\n                        mutant = x0 + self.f2 * (global_best - personal_best[i]) + self.f2 * (x1 - x2)\n\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n\n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.w = 0.3 + 0.3 * (1 - evaluations / self.budget)  # Dynamic inertia adjustment\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n                f_val = func(population[i])\n                evaluations += 1\n\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n\n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n        return global_best", "name": "AdaptiveQuantumHybridSwarm", "description": "An Adaptive Quantum-Inspired Hybrid Swarm Algorithm enhancing diversity and convergence through quantum mechanics concepts and adaptive dynamic techniques.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75c77c35-a246-4a87-a69a-b2a131576f2e", "metadata": {"aucs": [0.8732496514529094, 0.8573013930713151, 0.8744986549559657, 0.8537495192369189, 0.8604165374218101, 0.8715142837348789, 0.8704099284618737, 0.8739727116974925, 0.866791729775093, 0.6147791287774991, 0.5226600881736632, 0.6008666291934257, 0.6011496292940641, 0.5712684505558844, 0.6359510051857422, 0.045908637116616746, 0.01791592251565577, 0.624806402963642, 0.1413067638663884, 0.11049529921804513, 0.14184049273655452, 0.1027592472363914, 0.07083301263806674, 0.12002114502220551, 0.12881546204892624, 0.12197346576387535, 0.14062731601841005, 0.10096466446710328, 0.05413792712396226, 0.09114897185600312, 0.11617455852670533, 0.10909181187858685, 0.1132573468606426, 0.09365470587791058, 0.10954479806391282, 0.06924766798411386, 0.9775912343458948, 0.9856918600781291, 0.9862987405660498, 0.9770175651747988, 0.9778520464721582, 0.9781512659494478, 0.9875080020708764, 0.984098099287295, 0.9849954146772911, 0.7809659532660893, 0.7422826837075494, 0.7507287728082499, 0.7671760563977873, 0.7605455519964089, 0.7573331744633285, 0.7679600916906688, 0.747325999217636, 0.7792914648411364, 0.17111748920970027, 0.3776430589145463, 0.2148095429947724, 0.2812462563154454, 0.8986407239240541, 0.19204913894860254, 0.8747754320911039, 0.875000117318375, 0.868387248003844, 0.7632216912436319, 0.706558114179277, 0.6234648388250588, 0.13136984499800142, 0.7085088269387997, 0.6506806316873934, 0.6826924943191606, 0.6992691458062947, 0.6583057288686354, 0.734243198366002, 0.13115796893246556, 0.6705233511355073, 0.7082745516843774, 0.6388044637379255, 0.1341526369084951, 0.6743382872976676, 0.5567792737889925, 0.13081659118311728, 0.31827943748047594, 9.999999999998899e-05, 0.06633577084044773, 0.5390449000464439, 0.5270845928542385, 9.999999999998899e-05, 0.4392765556044851, 0.008076823072002082, 0.26222948519668543, 0.24804397985012738, 0.36024896744948254, 0.5288676387803491, 0.157319205348598, 0.17810397592288285, 0.6509838503096024, 0.6551795148357473, 0.6692466142047369, 0.6019556617371273, 0.06668243159341114, 0.26091536276258476, 0.22968957066875362, 0.30011996004245634, 0.09151287932329799, 0.3578498530294587, 0.2206967922068861, 0.3854711628213495, 0.20182060529747137, 0.17857461789159057, 0.19558219385245745, 0.3284205134415502, 0.006407430175517814, 0.36619250372402334, 0.2259926234100389, 0.08079187747567196, 0.3566449764797007, 0.08114697349173805, 0.7344845036158891, 0.7483427178164258, 0.7486489878661621, 0.7518594363355056, 0.7634733283067978, 0.802694999760851, 0.6843882425772356, 0.7299911756040789, 0.7593858556799229, 0.07580857596923452, 0.14444118890065638, 0.10268166408293322, 0.14555068634590862, 0.1133105093208967, 0.7033352848670488, 0.1039592203854578, 0.07995791523730145, 0.10458196920510487, 0.1700282082103276, 0.6464594007522839, 0.23788986441283433, 0.24848668452709644, 0.26787452178738946, 0.19298062414556083, 0.421872478808335, 0.19843099372711004, 0.26917347133106273, 0.5491013415157248, 0.33311292285246896, 0.47831967790630825, 0.2510770234307901, 0.24692705852935903, 0.48035384518917157, 0.23665669042404747, 0.42822797182165473, 0.30575513751038663, 0.1384240955857755, 0.21920609124034363, 0.2686337200810871, 0.3370099124725975, 0.27722345291883144, 0.2798287908940785, 0.15815476806470508, 0.3293521774471102, 0.31052351305580883, 0.21880804130783393, 0.23147323015166554, 0.21474406873959928, 0.20490956936190807, 0.23457103325372197, 0.2437305802702212, 0.2149709844811336, 0.2439850908753306, 0.23335761715769676, 0.22350210307888363, 0.18574197878039322, 0.17837020396905356, 0.2155230598069725, 0.19237625339917275, 0.19959724030473103, 0.17669365044360585, 0.21076136807788703, 0.20118337457794033, 0.9214437223791965, 0.1752419304252275, 0.14813261835915315, 0.9234731888523364, 0.1891957800520545, 0.20075856307887285, 0.14236009654782922, 0.16951293172035564, 0.9211706307592998, 0.8938069567687922, 0.21337860007900866, 0.8903324751288573, 0.8659545435144563, 0.8852123370256878, 0.15603433731549, 0.7809371264146462, 0.8691346964491866, 0.8944526734985341, 0.20381020220067825, 0.1898466526025595, 0.19237450905935372, 0.17981768391588937, 0.21853539690398427, 0.19684832418329457, 0.1848171428814328, 0.22912533053187922, 0.19210062702914676, 0.09359997277557464, 0.08913187308574833, 0.07349795134290049, 0.1072000129024635, 0.10987724557902478, 0.1309134338923733, 0.0948732229011211, 0.08903264488315288, 0.0935723001019283]}, "mutation_prompt": null}
{"id": "ec29493b-5b1c-4e94-bd8b-a423f8969789", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 40  # Slightly reduced population for efficiency\n        self.w = 0.5  # Adjusted inertia weight for better balance between exploration and exploitation\n        self.cr = 0.9  # Higher crossover rate to encourage exploration\n        self.f1 = 0.5  # Increased mutation factor for stronger primary exploration\n        self.f2 = 0.6  # Adjusted secondary mutation factor for balance\n        self.q_prob = 0.1  # New quantum probability factor for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.pop_size, self.dim))\n        personal_best = population.copy()\n        personal_best_values = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best = personal_best[global_best_idx]\n\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = population[indices]\n                if np.random.rand() < self.q_prob:\n                    quantum_shift = np.random.uniform(-1, 1, self.dim)\n                    mutant = global_best + quantum_shift * (x1 - x2)\n                else:\n                    if np.random.rand() < 0.5:\n                        mutant = x0 + self.f1 * (x1 - x2) + self.f1 * (x2 - x3)\n                    else:\n                        mutant = x0 + self.f2 * (global_best - personal_best[i]) + self.f2 * (x1 - x2)\n\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                f_trial = func(trial)\n                evaluations += 1\n\n                if f_trial < personal_best_values[i]:\n                    personal_best_values[i] = f_trial\n                    personal_best[i] = trial.copy()\n\n                    if f_trial < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.w = 0.3 + 0.3 * (1 - evaluations / self.budget)  # Dynamic inertia adjustment\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.w * velocities[i] +\n                                 r1 * (personal_best[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n                f_val = func(population[i])\n                evaluations += 1\n\n                if f_val < personal_best_values[i]:\n                    personal_best_values[i] = f_val\n                    personal_best[i] = population[i].copy()\n\n                    if f_val < personal_best_values[global_best_idx]:\n                        global_best_idx = i\n                        global_best = personal_best[global_best_idx]\n\n        return global_best", "name": "AdaptiveQuantumHybridSwarm", "description": "An Adaptive Quantum-Inspired Hybrid Swarm Algorithm enhancing diversity and convergence through quantum mechanics concepts and adaptive dynamic techniques.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "75c77c35-a246-4a87-a69a-b2a131576f2e", "metadata": {"aucs": [0.8732496514529094, 0.8573013930713151, 0.8744986549559657, 0.8537495192369189, 0.8604165374218101, 0.8715142837348789, 0.8704099284618737, 0.8739727116974925, 0.866791729775093, 0.6147791287774991, 0.5226600881736632, 0.6008666291934257, 0.6011496292940641, 0.5712684505558844, 0.6359510051857422, 0.045908637116616746, 0.01791592251565577, 0.624806402963642, 0.1413067638663884, 0.11049529921804513, 0.14184049273655452, 0.1027592472363914, 0.07083301263806674, 0.12002114502220551, 0.12881546204892624, 0.12197346576387535, 0.14062731601841005, 0.10096466446710328, 0.05413792712396226, 0.09114897185600312, 0.11617455852670533, 0.10909181187858685, 0.1132573468606426, 0.09365470587791058, 0.10954479806391282, 0.06924766798411386, 0.9775912343458948, 0.9856918600781291, 0.9862987405660498, 0.9770175651747988, 0.9778520464721582, 0.9781512659494478, 0.9875080020708764, 0.984098099287295, 0.9849954146772911, 0.7809659532660893, 0.7422826837075494, 0.7507287728082499, 0.7671760563977873, 0.7605455519964089, 0.7573331744633285, 0.7679600916906688, 0.747325999217636, 0.7792914648411364, 0.17111748920970027, 0.3776430589145463, 0.2148095429947724, 0.2812462563154454, 0.8986407239240541, 0.19204913894860254, 0.8747754320911039, 0.875000117318375, 0.868387248003844, 0.7632216912436319, 0.706558114179277, 0.6234648388250588, 0.13136984499800142, 0.7085088269387997, 0.6506806316873934, 0.6826924943191606, 0.6992691458062947, 0.6583057288686354, 0.734243198366002, 0.13115796893246556, 0.6705233511355073, 0.7082745516843774, 0.6388044637379255, 0.1341526369084951, 0.6743382872976676, 0.5567792737889925, 0.13081659118311728, 0.31827943748047594, 9.999999999998899e-05, 0.06633577084044773, 0.5390449000464439, 0.5270845928542385, 9.999999999998899e-05, 0.4392765556044851, 0.008076823072002082, 0.26222948519668543, 0.24804397985012738, 0.36024896744948254, 0.5288676387803491, 0.157319205348598, 0.17810397592288285, 0.6509838503096024, 0.6551795148357473, 0.6692466142047369, 0.6019556617371273, 0.06668243159341114, 0.26091536276258476, 0.22968957066875362, 0.30011996004245634, 0.09151287932329799, 0.3578498530294587, 0.2206967922068861, 0.3854711628213495, 0.20182060529747137, 0.17857461789159057, 0.19558219385245745, 0.3284205134415502, 0.006407430175517814, 0.36619250372402334, 0.2259926234100389, 0.08079187747567196, 0.3566449764797007, 0.08114697349173805, 0.7344845036158891, 0.7483427178164258, 0.7486489878661621, 0.7518594363355056, 0.7634733283067978, 0.802694999760851, 0.6843882425772356, 0.7299911756040789, 0.7593858556799229, 0.07580857596923452, 0.14444118890065638, 0.10268166408293322, 0.14555068634590862, 0.1133105093208967, 0.7033352848670488, 0.1039592203854578, 0.07995791523730145, 0.10458196920510487, 0.1700282082103276, 0.6464594007522839, 0.23788986441283433, 0.24848668452709644, 0.26787452178738946, 0.19298062414556083, 0.421872478808335, 0.19843099372711004, 0.26917347133106273, 0.5491013415157248, 0.33311292285246896, 0.47831967790630825, 0.2510770234307901, 0.24692705852935903, 0.48035384518917157, 0.23665669042404747, 0.42822797182165473, 0.30575513751038663, 0.1384240955857755, 0.21920609124034363, 0.2686337200810871, 0.3370099124725975, 0.27722345291883144, 0.2798287908940785, 0.15815476806470508, 0.3293521774471102, 0.31052351305580883, 0.21880804130783393, 0.23147323015166554, 0.21474406873959928, 0.20490956936190807, 0.23457103325372197, 0.2437305802702212, 0.2149709844811336, 0.2439850908753306, 0.23335761715769676, 0.22350210307888363, 0.18574197878039322, 0.17837020396905356, 0.2155230598069725, 0.19237625339917275, 0.19959724030473103, 0.17669365044360585, 0.21076136807788703, 0.20118337457794033, 0.9214437223791965, 0.1752419304252275, 0.14813261835915315, 0.9234731888523364, 0.1891957800520545, 0.20075856307887285, 0.14236009654782922, 0.16951293172035564, 0.9211706307592998, 0.8938069567687922, 0.21337860007900866, 0.8903324751288573, 0.8659545435144563, 0.8852123370256878, 0.15603433731549, 0.7809371264146462, 0.8691346964491866, 0.8944526734985341, 0.20381020220067825, 0.1898466526025595, 0.19237450905935372, 0.17981768391588937, 0.21853539690398427, 0.19684832418329457, 0.1848171428814328, 0.22912533053187922, 0.19210062702914676, 0.09359997277557464, 0.08913187308574833, 0.07349795134290049, 0.1072000129024635, 0.10987724557902478, 0.1309134338923733, 0.0948732229011211, 0.08903264488315288, 0.0935723001019283]}, "mutation_prompt": null}
