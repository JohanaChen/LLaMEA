{"id": "cc2416a9-6772-4a63-9de0-4b9a0e72b4b6", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = np.clip(population[a] + self.mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Firefly algorithm component\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + self.alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "The algorithm uses a hybrid approach combining Differential Evolution and the Firefly Algorithm to efficiently explore and exploit the search space.", "configspace": "", "generation": 0, "fitness": 0.1564508105985315, "feedback": "The algorithm HybridDEFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.16.", "error": "", "parent_id": null, "metadata": {"aucs": [0.38671424945428157, 0.38671424945428157, 0.38671424945428157, 0.4114117458386485, 0.4114117458386485, 0.4114117458386485, 0.3494198852779937, 0.3494198852779937, 0.3494198852779937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07995213859166528, 0.07995213859166528, 0.07995213859166528, 0.07673325099524064, 0.07673325099524064, 0.07673325099524064, 0.07970583681358678, 0.07970583681358678, 0.07970583681358678, 0.07383804503320224, 0.07383804503320224, 0.07383804503320224, 0.05730401335524271, 0.05730401335524271, 0.05730401335524271, 0.06888982344012295, 0.06888982344012295, 0.06888982344012295, 0.7486377762319503, 0.7486377762319503, 0.7486377762319503, 0.6737881274611579, 0.6737881274611579, 0.6737881274611579, 0.8299431884002639, 0.8299431884002639, 0.8299431884002639, 0.15472327223719928, 0.15472327223719928, 0.15472327223719928, 0.14334459676327793, 0.14334459676327793, 0.14334459676327793, 0.17488856962273092, 0.17488856962273092, 0.17488856962273092, 0.17568429808026742, 0.17568429808026742, 0.17568429808026742, 0.2715017081378607, 0.2715017081378607, 0.2715017081378607, 0.1651267578152571, 0.1651267578152571, 0.1651267578152571, 0.1502586052407694, 0.1502586052407694, 0.1502586052407694, 0.10521249700509039, 0.10521249700509039, 0.10521249700509039, 0.12764902576751125, 0.12764902576751125, 0.12764902576751125, 0.06886163166904447, 0.06886163166904447, 0.06886163166904447, 0.11379502312731415, 0.11379502312731415, 0.11379502312731415, 0.08031332706986849, 0.08031332706986849, 0.08031332706986849, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0788544489426557, 0.0788544489426557, 0.0788544489426557, 0.020973199214352145, 0.020973199214352145, 0.020973199214352145, 0.0658415624009594, 0.0658415624009594, 0.0658415624009594, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.048120453688220044, 0.048120453688220044, 0.048120453688220044, 0.05365290633956321, 0.05365290633956321, 0.05365290633956321, 0.06971562461631786, 0.06971562461631786, 0.06971562461631786, 0.3229297546907369, 0.3229297546907369, 0.3229297546907369, 0.3391349955526477, 0.3391349955526477, 0.3391349955526477, 0.3132987371017727, 0.3132987371017727, 0.3132987371017727, 0.0760034942535669, 0.0760034942535669, 0.0760034942535669, 0.0576787432370236, 0.0576787432370236, 0.0576787432370236, 0.061897985250131904, 0.061897985250131904, 0.061897985250131904, 0.12000947315762156, 0.12000947315762156, 0.12000947315762156, 0.12335321079085426, 0.12335321079085426, 0.12335321079085426, 0.12204372693394072, 0.12204372693394072, 0.12204372693394072, 0.19366088438734153, 0.19366088438734153, 0.19366088438734153, 0.18381347383334623, 0.18381347383334623, 0.18381347383334623, 0.19389723460239217, 0.19389723460239217, 0.19389723460239217, 0.1626218038376297, 0.1626218038376297, 0.1626218038376297, 0.11595576335091062, 0.11595576335091062, 0.11595576335091062, 0.1344692081178659, 0.1344692081178659, 0.1344692081178659, 0.167004821199903, 0.167004821199903, 0.167004821199903, 0.14882296018189045, 0.14882296018189045, 0.14882296018189045, 0.18456497767241054, 0.18456497767241054, 0.18456497767241054, 0.14338428231364253, 0.14338428231364253, 0.14338428231364253, 0.14167011373564997, 0.14167011373564997, 0.14167011373564997, 0.16051858587490664, 0.16051858587490664, 0.16051858587490664, 0.2655112581501663, 0.2655112581501663, 0.2655112581501663, 0.1508371292387044, 0.1508371292387044, 0.1508371292387044, 0.1519798527598919, 0.1519798527598919, 0.1519798527598919, 0.15232903880630133, 0.15232903880630133, 0.15232903880630133, 0.2550247747626532, 0.2550247747626532, 0.2550247747626532, 0.18739635232072782, 0.18739635232072782, 0.18739635232072782, 0.1808333717078776, 0.1808333717078776, 0.1808333717078776, 0.185317575321721, 0.185317575321721, 0.185317575321721, 0.182408410363741, 0.182408410363741, 0.182408410363741, 0.057970346142207196, 0.057970346142207196, 0.057970346142207196, 0.06907370167513649, 0.06907370167513649, 0.06907370167513649, 0.05328673313733978, 0.05328673313733978, 0.05328673313733978]}, "mutation_prompt": null}
{"id": "854d10ee-3cdb-455a-bb75-add1b73350a0", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation with dynamic mutation factor\n                self.mutation_factor = 0.5 * (1 - budget_used / self.budget) + 0.1  # Introduce a dynamic component\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = np.clip(population[a] + self.mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Firefly algorithm component\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + self.alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Enhance exploration and exploitation balance by introducing a dynamic mutation factor in the Differential Evolution phase.", "configspace": "", "generation": 1, "fitness": 0.15544592696001047, "feedback": "The algorithm HybridDEFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.16.", "error": "", "parent_id": "cc2416a9-6772-4a63-9de0-4b9a0e72b4b6", "metadata": {"aucs": [0.3665272092755233, 0.3665272092755233, 0.3665272092755233, 0.3563451706870048, 0.3563451706870048, 0.3563451706870048, 0.3469899169790064, 0.3469899169790064, 0.3469899169790064, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0035476841551084215, 0.0035476841551084215, 0.0035476841551084215, 0.07380367061104354, 0.07380367061104354, 0.07380367061104354, 0.08887131546062721, 0.08887131546062721, 0.08887131546062721, 0.06963911536369993, 0.06963911536369993, 0.06963911536369993, 0.04884155777707888, 0.04884155777707888, 0.04884155777707888, 0.062132528255419484, 0.062132528255419484, 0.062132528255419484, 0.07763246610616203, 0.07763246610616203, 0.07763246610616203, 0.7562958210633283, 0.7562958210633283, 0.7562958210633283, 0.8047822527591626, 0.8047822527591626, 0.8047822527591626, 0.7337205997031213, 0.7337205997031213, 0.7337205997031213, 0.14932033047265136, 0.14932033047265136, 0.14932033047265136, 0.1712223553209089, 0.1712223553209089, 0.1712223553209089, 0.20962051888982192, 0.20962051888982192, 0.20962051888982192, 0.17304151469096118, 0.17304151469096118, 0.17304151469096118, 0.2203639131395535, 0.2203639131395535, 0.2203639131395535, 0.10176024720366172, 0.10176024720366172, 0.10176024720366172, 0.10100113763093177, 0.10100113763093177, 0.10100113763093177, 0.08535273742329497, 0.08535273742329497, 0.08535273742329497, 0.1381009289235282, 0.1381009289235282, 0.1381009289235282, 0.0551714733045483, 0.0551714733045483, 0.0551714733045483, 0.0978193810294159, 0.0978193810294159, 0.0978193810294159, 0.0837468770084332, 0.0837468770084332, 0.0837468770084332, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08793524159005373, 0.08793524159005373, 0.08793524159005373, 0.01924374586910471, 0.01924374586910471, 0.01924374586910471, 0.054870760324206236, 0.054870760324206236, 0.054870760324206236, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.048641781735328515, 0.048641781735328515, 0.048641781735328515, 0.06742642550912137, 0.06742642550912137, 0.06742642550912137, 0.05893668770906857, 0.05893668770906857, 0.05893668770906857, 0.3293730649270574, 0.3293730649270574, 0.3293730649270574, 0.3490848768034853, 0.3490848768034853, 0.3490848768034853, 0.2876624491182921, 0.2876624491182921, 0.2876624491182921, 0.06858296984889889, 0.06858296984889889, 0.06858296984889889, 0.09233621906650313, 0.09233621906650313, 0.09233621906650313, 0.06297238394876581, 0.06297238394876581, 0.06297238394876581, 0.14280410733020676, 0.14280410733020676, 0.14280410733020676, 0.1384499060336828, 0.1384499060336828, 0.1384499060336828, 0.13743827112668427, 0.13743827112668427, 0.13743827112668427, 0.23090989935141537, 0.23090989935141537, 0.23090989935141537, 0.23221138949301923, 0.23221138949301923, 0.23221138949301923, 0.22664106040653687, 0.22664106040653687, 0.22664106040653687, 0.15799606084403406, 0.15799606084403406, 0.15799606084403406, 0.12114404723482208, 0.12114404723482208, 0.12114404723482208, 0.11856217312955453, 0.11856217312955453, 0.11856217312955453, 0.20206561061552097, 0.20206561061552097, 0.20206561061552097, 0.16687144635224538, 0.16687144635224538, 0.16687144635224538, 0.15045262354855682, 0.15045262354855682, 0.15045262354855682, 0.13504383844257828, 0.13504383844257828, 0.13504383844257828, 0.14529597130546024, 0.14529597130546024, 0.14529597130546024, 0.13173805173855035, 0.13173805173855035, 0.13173805173855035, 0.17715379642583706, 0.17715379642583706, 0.17715379642583706, 0.16429039965100778, 0.16429039965100778, 0.16429039965100778, 0.1490275100392624, 0.1490275100392624, 0.1490275100392624, 0.16327247029176783, 0.16327247029176783, 0.16327247029176783, 0.27389299595259375, 0.27389299595259375, 0.27389299595259375, 0.19483055101815827, 0.19483055101815827, 0.19483055101815827, 0.17789660608189328, 0.17789660608189328, 0.17789660608189328, 0.1913792356649585, 0.1913792356649585, 0.1913792356649585, 0.18175320259820915, 0.18175320259820915, 0.18175320259820915, 0.05318045098218771, 0.05318045098218771, 0.05318045098218771, 0.05500556459393213, 0.05500556459393213, 0.05500556459393213, 0.06928217118419366, 0.06928217118419366, 0.06928217118419366]}, "mutation_prompt": null}
{"id": "c48f0f90-9c7b-41fd-8495-3b1b99b6a9a2", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = np.clip(population[a] + self.mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Firefly algorithm component\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + self.alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "The algorithm uses a hybrid approach combining Differential Evolution and the Firefly Algorithm to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cc2416a9-6772-4a63-9de0-4b9a0e72b4b6", "metadata": {"aucs": [0.38671424945428157, 0.38671424945428157, 0.38671424945428157, 0.4114117458386485, 0.4114117458386485, 0.4114117458386485, 0.3494198852779937, 0.3494198852779937, 0.3494198852779937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07995213859166528, 0.07995213859166528, 0.07995213859166528, 0.07673325099524064, 0.07673325099524064, 0.07673325099524064, 0.07970583681358678, 0.07970583681358678, 0.07970583681358678, 0.07383804503320224, 0.07383804503320224, 0.07383804503320224, 0.05730401335524271, 0.05730401335524271, 0.05730401335524271, 0.06888982344012295, 0.06888982344012295, 0.06888982344012295, 0.7486377762319503, 0.7486377762319503, 0.7486377762319503, 0.6737881274611579, 0.6737881274611579, 0.6737881274611579, 0.8299431884002639, 0.8299431884002639, 0.8299431884002639, 0.15472327223719928, 0.15472327223719928, 0.15472327223719928, 0.14334459676327793, 0.14334459676327793, 0.14334459676327793, 0.17488856962273092, 0.17488856962273092, 0.17488856962273092, 0.17568429808026742, 0.17568429808026742, 0.17568429808026742, 0.2715017081378607, 0.2715017081378607, 0.2715017081378607, 0.1651267578152571, 0.1651267578152571, 0.1651267578152571, 0.1502586052407694, 0.1502586052407694, 0.1502586052407694, 0.10521249700509039, 0.10521249700509039, 0.10521249700509039, 0.12764902576751125, 0.12764902576751125, 0.12764902576751125, 0.06886163166904447, 0.06886163166904447, 0.06886163166904447, 0.11379502312731415, 0.11379502312731415, 0.11379502312731415, 0.08031332706986849, 0.08031332706986849, 0.08031332706986849, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0788544489426557, 0.0788544489426557, 0.0788544489426557, 0.020973199214352145, 0.020973199214352145, 0.020973199214352145, 0.0658415624009594, 0.0658415624009594, 0.0658415624009594, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.048120453688220044, 0.048120453688220044, 0.048120453688220044, 0.05365290633956321, 0.05365290633956321, 0.05365290633956321, 0.06971562461631786, 0.06971562461631786, 0.06971562461631786, 0.3229297546907369, 0.3229297546907369, 0.3229297546907369, 0.3391349955526477, 0.3391349955526477, 0.3391349955526477, 0.3132987371017727, 0.3132987371017727, 0.3132987371017727, 0.0760034942535669, 0.0760034942535669, 0.0760034942535669, 0.0576787432370236, 0.0576787432370236, 0.0576787432370236, 0.061897985250131904, 0.061897985250131904, 0.061897985250131904, 0.12000947315762156, 0.12000947315762156, 0.12000947315762156, 0.12335321079085426, 0.12335321079085426, 0.12335321079085426, 0.12204372693394072, 0.12204372693394072, 0.12204372693394072, 0.19366088438734153, 0.19366088438734153, 0.19366088438734153, 0.18381347383334623, 0.18381347383334623, 0.18381347383334623, 0.19389723460239217, 0.19389723460239217, 0.19389723460239217, 0.1626218038376297, 0.1626218038376297, 0.1626218038376297, 0.11595576335091062, 0.11595576335091062, 0.11595576335091062, 0.1344692081178659, 0.1344692081178659, 0.1344692081178659, 0.167004821199903, 0.167004821199903, 0.167004821199903, 0.14882296018189045, 0.14882296018189045, 0.14882296018189045, 0.18456497767241054, 0.18456497767241054, 0.18456497767241054, 0.14338428231364253, 0.14338428231364253, 0.14338428231364253, 0.14167011373564997, 0.14167011373564997, 0.14167011373564997, 0.16051858587490664, 0.16051858587490664, 0.16051858587490664, 0.2655112581501663, 0.2655112581501663, 0.2655112581501663, 0.1508371292387044, 0.1508371292387044, 0.1508371292387044, 0.1519798527598919, 0.1519798527598919, 0.1519798527598919, 0.15232903880630133, 0.15232903880630133, 0.15232903880630133, 0.2550247747626532, 0.2550247747626532, 0.2550247747626532, 0.18739635232072782, 0.18739635232072782, 0.18739635232072782, 0.1808333717078776, 0.1808333717078776, 0.1808333717078776, 0.185317575321721, 0.185317575321721, 0.185317575321721, 0.182408410363741, 0.182408410363741, 0.182408410363741, 0.057970346142207196, 0.057970346142207196, 0.057970346142207196, 0.06907370167513649, 0.06907370167513649, 0.06907370167513649, 0.05328673313733978, 0.05328673313733978, 0.05328673313733978]}, "mutation_prompt": null}
{"id": "282f9254-c505-431b-a278-79c8a69a6b3d", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = np.clip(population[a] + self.mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Firefly algorithm component\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + self.alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "The algorithm uses a hybrid approach combining Differential Evolution and the Firefly Algorithm to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cc2416a9-6772-4a63-9de0-4b9a0e72b4b6", "metadata": {"aucs": [0.38671424945428157, 0.38671424945428157, 0.38671424945428157, 0.4114117458386485, 0.4114117458386485, 0.4114117458386485, 0.3494198852779937, 0.3494198852779937, 0.3494198852779937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07995213859166528, 0.07995213859166528, 0.07995213859166528, 0.07673325099524064, 0.07673325099524064, 0.07673325099524064, 0.07970583681358678, 0.07970583681358678, 0.07970583681358678, 0.07383804503320224, 0.07383804503320224, 0.07383804503320224, 0.05730401335524271, 0.05730401335524271, 0.05730401335524271, 0.06888982344012295, 0.06888982344012295, 0.06888982344012295, 0.7486377762319503, 0.7486377762319503, 0.7486377762319503, 0.6737881274611579, 0.6737881274611579, 0.6737881274611579, 0.8299431884002639, 0.8299431884002639, 0.8299431884002639, 0.15472327223719928, 0.15472327223719928, 0.15472327223719928, 0.14334459676327793, 0.14334459676327793, 0.14334459676327793, 0.17488856962273092, 0.17488856962273092, 0.17488856962273092, 0.17568429808026742, 0.17568429808026742, 0.17568429808026742, 0.2715017081378607, 0.2715017081378607, 0.2715017081378607, 0.1651267578152571, 0.1651267578152571, 0.1651267578152571, 0.1502586052407694, 0.1502586052407694, 0.1502586052407694, 0.10521249700509039, 0.10521249700509039, 0.10521249700509039, 0.12764902576751125, 0.12764902576751125, 0.12764902576751125, 0.06886163166904447, 0.06886163166904447, 0.06886163166904447, 0.11379502312731415, 0.11379502312731415, 0.11379502312731415, 0.08031332706986849, 0.08031332706986849, 0.08031332706986849, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0788544489426557, 0.0788544489426557, 0.0788544489426557, 0.020973199214352145, 0.020973199214352145, 0.020973199214352145, 0.0658415624009594, 0.0658415624009594, 0.0658415624009594, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.048120453688220044, 0.048120453688220044, 0.048120453688220044, 0.05365290633956321, 0.05365290633956321, 0.05365290633956321, 0.06971562461631786, 0.06971562461631786, 0.06971562461631786, 0.3229297546907369, 0.3229297546907369, 0.3229297546907369, 0.3391349955526477, 0.3391349955526477, 0.3391349955526477, 0.3132987371017727, 0.3132987371017727, 0.3132987371017727, 0.0760034942535669, 0.0760034942535669, 0.0760034942535669, 0.0576787432370236, 0.0576787432370236, 0.0576787432370236, 0.061897985250131904, 0.061897985250131904, 0.061897985250131904, 0.12000947315762156, 0.12000947315762156, 0.12000947315762156, 0.12335321079085426, 0.12335321079085426, 0.12335321079085426, 0.12204372693394072, 0.12204372693394072, 0.12204372693394072, 0.19366088438734153, 0.19366088438734153, 0.19366088438734153, 0.18381347383334623, 0.18381347383334623, 0.18381347383334623, 0.19389723460239217, 0.19389723460239217, 0.19389723460239217, 0.1626218038376297, 0.1626218038376297, 0.1626218038376297, 0.11595576335091062, 0.11595576335091062, 0.11595576335091062, 0.1344692081178659, 0.1344692081178659, 0.1344692081178659, 0.167004821199903, 0.167004821199903, 0.167004821199903, 0.14882296018189045, 0.14882296018189045, 0.14882296018189045, 0.18456497767241054, 0.18456497767241054, 0.18456497767241054, 0.14338428231364253, 0.14338428231364253, 0.14338428231364253, 0.14167011373564997, 0.14167011373564997, 0.14167011373564997, 0.16051858587490664, 0.16051858587490664, 0.16051858587490664, 0.2655112581501663, 0.2655112581501663, 0.2655112581501663, 0.1508371292387044, 0.1508371292387044, 0.1508371292387044, 0.1519798527598919, 0.1519798527598919, 0.1519798527598919, 0.15232903880630133, 0.15232903880630133, 0.15232903880630133, 0.2550247747626532, 0.2550247747626532, 0.2550247747626532, 0.18739635232072782, 0.18739635232072782, 0.18739635232072782, 0.1808333717078776, 0.1808333717078776, 0.1808333717078776, 0.185317575321721, 0.185317575321721, 0.185317575321721, 0.182408410363741, 0.182408410363741, 0.182408410363741, 0.057970346142207196, 0.057970346142207196, 0.057970346142207196, 0.06907370167513649, 0.06907370167513649, 0.06907370167513649, 0.05328673313733978, 0.05328673313733978, 0.05328673313733978]}, "mutation_prompt": null}
{"id": "3b6a8e3c-96d5-4861-996d-100be8181efe", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = np.clip(population[a] + self.mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Firefly algorithm component\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + self.alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "The algorithm uses a hybrid approach combining Differential Evolution and the Firefly Algorithm to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cc2416a9-6772-4a63-9de0-4b9a0e72b4b6", "metadata": {"aucs": [0.38671424945428157, 0.38671424945428157, 0.38671424945428157, 0.4114117458386485, 0.4114117458386485, 0.4114117458386485, 0.3494198852779937, 0.3494198852779937, 0.3494198852779937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07995213859166528, 0.07995213859166528, 0.07995213859166528, 0.07673325099524064, 0.07673325099524064, 0.07673325099524064, 0.07970583681358678, 0.07970583681358678, 0.07970583681358678, 0.07383804503320224, 0.07383804503320224, 0.07383804503320224, 0.05730401335524271, 0.05730401335524271, 0.05730401335524271, 0.06888982344012295, 0.06888982344012295, 0.06888982344012295, 0.7486377762319503, 0.7486377762319503, 0.7486377762319503, 0.6737881274611579, 0.6737881274611579, 0.6737881274611579, 0.8299431884002639, 0.8299431884002639, 0.8299431884002639, 0.15472327223719928, 0.15472327223719928, 0.15472327223719928, 0.14334459676327793, 0.14334459676327793, 0.14334459676327793, 0.17488856962273092, 0.17488856962273092, 0.17488856962273092, 0.17568429808026742, 0.17568429808026742, 0.17568429808026742, 0.2715017081378607, 0.2715017081378607, 0.2715017081378607, 0.1651267578152571, 0.1651267578152571, 0.1651267578152571, 0.1502586052407694, 0.1502586052407694, 0.1502586052407694, 0.10521249700509039, 0.10521249700509039, 0.10521249700509039, 0.12764902576751125, 0.12764902576751125, 0.12764902576751125, 0.06886163166904447, 0.06886163166904447, 0.06886163166904447, 0.11379502312731415, 0.11379502312731415, 0.11379502312731415, 0.08031332706986849, 0.08031332706986849, 0.08031332706986849, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0788544489426557, 0.0788544489426557, 0.0788544489426557, 0.020973199214352145, 0.020973199214352145, 0.020973199214352145, 0.0658415624009594, 0.0658415624009594, 0.0658415624009594, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.048120453688220044, 0.048120453688220044, 0.048120453688220044, 0.05365290633956321, 0.05365290633956321, 0.05365290633956321, 0.06971562461631786, 0.06971562461631786, 0.06971562461631786, 0.3229297546907369, 0.3229297546907369, 0.3229297546907369, 0.3391349955526477, 0.3391349955526477, 0.3391349955526477, 0.3132987371017727, 0.3132987371017727, 0.3132987371017727, 0.0760034942535669, 0.0760034942535669, 0.0760034942535669, 0.0576787432370236, 0.0576787432370236, 0.0576787432370236, 0.061897985250131904, 0.061897985250131904, 0.061897985250131904, 0.12000947315762156, 0.12000947315762156, 0.12000947315762156, 0.12335321079085426, 0.12335321079085426, 0.12335321079085426, 0.12204372693394072, 0.12204372693394072, 0.12204372693394072, 0.19366088438734153, 0.19366088438734153, 0.19366088438734153, 0.18381347383334623, 0.18381347383334623, 0.18381347383334623, 0.19389723460239217, 0.19389723460239217, 0.19389723460239217, 0.1626218038376297, 0.1626218038376297, 0.1626218038376297, 0.11595576335091062, 0.11595576335091062, 0.11595576335091062, 0.1344692081178659, 0.1344692081178659, 0.1344692081178659, 0.167004821199903, 0.167004821199903, 0.167004821199903, 0.14882296018189045, 0.14882296018189045, 0.14882296018189045, 0.18456497767241054, 0.18456497767241054, 0.18456497767241054, 0.14338428231364253, 0.14338428231364253, 0.14338428231364253, 0.14167011373564997, 0.14167011373564997, 0.14167011373564997, 0.16051858587490664, 0.16051858587490664, 0.16051858587490664, 0.2655112581501663, 0.2655112581501663, 0.2655112581501663, 0.1508371292387044, 0.1508371292387044, 0.1508371292387044, 0.1519798527598919, 0.1519798527598919, 0.1519798527598919, 0.15232903880630133, 0.15232903880630133, 0.15232903880630133, 0.2550247747626532, 0.2550247747626532, 0.2550247747626532, 0.18739635232072782, 0.18739635232072782, 0.18739635232072782, 0.1808333717078776, 0.1808333717078776, 0.1808333717078776, 0.185317575321721, 0.185317575321721, 0.185317575321721, 0.182408410363741, 0.182408410363741, 0.182408410363741, 0.057970346142207196, 0.057970346142207196, 0.057970346142207196, 0.06907370167513649, 0.06907370167513649, 0.06907370167513649, 0.05328673313733978, 0.05328673313733978, 0.05328673313733978]}, "mutation_prompt": null}
{"id": "9fd431e8-2f55-4a2e-bfdf-c58b1ef5515e", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = np.clip(population[a] + self.mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Firefly algorithm component\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + self.alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "The algorithm uses a hybrid approach combining Differential Evolution and the Firefly Algorithm to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cc2416a9-6772-4a63-9de0-4b9a0e72b4b6", "metadata": {"aucs": [0.38671424945428157, 0.38671424945428157, 0.38671424945428157, 0.4114117458386485, 0.4114117458386485, 0.4114117458386485, 0.3494198852779937, 0.3494198852779937, 0.3494198852779937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07995213859166528, 0.07995213859166528, 0.07995213859166528, 0.07673325099524064, 0.07673325099524064, 0.07673325099524064, 0.07970583681358678, 0.07970583681358678, 0.07970583681358678, 0.07383804503320224, 0.07383804503320224, 0.07383804503320224, 0.05730401335524271, 0.05730401335524271, 0.05730401335524271, 0.06888982344012295, 0.06888982344012295, 0.06888982344012295, 0.7486377762319503, 0.7486377762319503, 0.7486377762319503, 0.6737881274611579, 0.6737881274611579, 0.6737881274611579, 0.8299431884002639, 0.8299431884002639, 0.8299431884002639, 0.15472327223719928, 0.15472327223719928, 0.15472327223719928, 0.14334459676327793, 0.14334459676327793, 0.14334459676327793, 0.17488856962273092, 0.17488856962273092, 0.17488856962273092, 0.17568429808026742, 0.17568429808026742, 0.17568429808026742, 0.2715017081378607, 0.2715017081378607, 0.2715017081378607, 0.1651267578152571, 0.1651267578152571, 0.1651267578152571, 0.1502586052407694, 0.1502586052407694, 0.1502586052407694, 0.10521249700509039, 0.10521249700509039, 0.10521249700509039, 0.12764902576751125, 0.12764902576751125, 0.12764902576751125, 0.06886163166904447, 0.06886163166904447, 0.06886163166904447, 0.11379502312731415, 0.11379502312731415, 0.11379502312731415, 0.08031332706986849, 0.08031332706986849, 0.08031332706986849, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0788544489426557, 0.0788544489426557, 0.0788544489426557, 0.020973199214352145, 0.020973199214352145, 0.020973199214352145, 0.0658415624009594, 0.0658415624009594, 0.0658415624009594, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.048120453688220044, 0.048120453688220044, 0.048120453688220044, 0.05365290633956321, 0.05365290633956321, 0.05365290633956321, 0.06971562461631786, 0.06971562461631786, 0.06971562461631786, 0.3229297546907369, 0.3229297546907369, 0.3229297546907369, 0.3391349955526477, 0.3391349955526477, 0.3391349955526477, 0.3132987371017727, 0.3132987371017727, 0.3132987371017727, 0.0760034942535669, 0.0760034942535669, 0.0760034942535669, 0.0576787432370236, 0.0576787432370236, 0.0576787432370236, 0.061897985250131904, 0.061897985250131904, 0.061897985250131904, 0.12000947315762156, 0.12000947315762156, 0.12000947315762156, 0.12335321079085426, 0.12335321079085426, 0.12335321079085426, 0.12204372693394072, 0.12204372693394072, 0.12204372693394072, 0.19366088438734153, 0.19366088438734153, 0.19366088438734153, 0.18381347383334623, 0.18381347383334623, 0.18381347383334623, 0.19389723460239217, 0.19389723460239217, 0.19389723460239217, 0.1626218038376297, 0.1626218038376297, 0.1626218038376297, 0.11595576335091062, 0.11595576335091062, 0.11595576335091062, 0.1344692081178659, 0.1344692081178659, 0.1344692081178659, 0.167004821199903, 0.167004821199903, 0.167004821199903, 0.14882296018189045, 0.14882296018189045, 0.14882296018189045, 0.18456497767241054, 0.18456497767241054, 0.18456497767241054, 0.14338428231364253, 0.14338428231364253, 0.14338428231364253, 0.14167011373564997, 0.14167011373564997, 0.14167011373564997, 0.16051858587490664, 0.16051858587490664, 0.16051858587490664, 0.2655112581501663, 0.2655112581501663, 0.2655112581501663, 0.1508371292387044, 0.1508371292387044, 0.1508371292387044, 0.1519798527598919, 0.1519798527598919, 0.1519798527598919, 0.15232903880630133, 0.15232903880630133, 0.15232903880630133, 0.2550247747626532, 0.2550247747626532, 0.2550247747626532, 0.18739635232072782, 0.18739635232072782, 0.18739635232072782, 0.1808333717078776, 0.1808333717078776, 0.1808333717078776, 0.185317575321721, 0.185317575321721, 0.185317575321721, 0.182408410363741, 0.182408410363741, 0.182408410363741, 0.057970346142207196, 0.057970346142207196, 0.057970346142207196, 0.06907370167513649, 0.06907370167513649, 0.06907370167513649, 0.05328673313733978, 0.05328673313733978, 0.05328673313733978]}, "mutation_prompt": null}
{"id": "0a4e6ae9-7e3b-4d14-9573-1d825fdab410", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = np.clip(population[a] + self.mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Firefly algorithm component\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + self.alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "The algorithm uses a hybrid approach combining Differential Evolution and the Firefly Algorithm to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cc2416a9-6772-4a63-9de0-4b9a0e72b4b6", "metadata": {"aucs": [0.38671424945428157, 0.38671424945428157, 0.38671424945428157, 0.4114117458386485, 0.4114117458386485, 0.4114117458386485, 0.3494198852779937, 0.3494198852779937, 0.3494198852779937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07995213859166528, 0.07995213859166528, 0.07995213859166528, 0.07673325099524064, 0.07673325099524064, 0.07673325099524064, 0.07970583681358678, 0.07970583681358678, 0.07970583681358678, 0.07383804503320224, 0.07383804503320224, 0.07383804503320224, 0.05730401335524271, 0.05730401335524271, 0.05730401335524271, 0.06888982344012295, 0.06888982344012295, 0.06888982344012295, 0.7486377762319503, 0.7486377762319503, 0.7486377762319503, 0.6737881274611579, 0.6737881274611579, 0.6737881274611579, 0.8299431884002639, 0.8299431884002639, 0.8299431884002639, 0.15472327223719928, 0.15472327223719928, 0.15472327223719928, 0.14334459676327793, 0.14334459676327793, 0.14334459676327793, 0.17488856962273092, 0.17488856962273092, 0.17488856962273092, 0.17568429808026742, 0.17568429808026742, 0.17568429808026742, 0.2715017081378607, 0.2715017081378607, 0.2715017081378607, 0.1651267578152571, 0.1651267578152571, 0.1651267578152571, 0.1502586052407694, 0.1502586052407694, 0.1502586052407694, 0.10521249700509039, 0.10521249700509039, 0.10521249700509039, 0.12764902576751125, 0.12764902576751125, 0.12764902576751125, 0.06886163166904447, 0.06886163166904447, 0.06886163166904447, 0.11379502312731415, 0.11379502312731415, 0.11379502312731415, 0.08031332706986849, 0.08031332706986849, 0.08031332706986849, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0788544489426557, 0.0788544489426557, 0.0788544489426557, 0.020973199214352145, 0.020973199214352145, 0.020973199214352145, 0.0658415624009594, 0.0658415624009594, 0.0658415624009594, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.048120453688220044, 0.048120453688220044, 0.048120453688220044, 0.05365290633956321, 0.05365290633956321, 0.05365290633956321, 0.06971562461631786, 0.06971562461631786, 0.06971562461631786, 0.3229297546907369, 0.3229297546907369, 0.3229297546907369, 0.3391349955526477, 0.3391349955526477, 0.3391349955526477, 0.3132987371017727, 0.3132987371017727, 0.3132987371017727, 0.0760034942535669, 0.0760034942535669, 0.0760034942535669, 0.0576787432370236, 0.0576787432370236, 0.0576787432370236, 0.061897985250131904, 0.061897985250131904, 0.061897985250131904, 0.12000947315762156, 0.12000947315762156, 0.12000947315762156, 0.12335321079085426, 0.12335321079085426, 0.12335321079085426, 0.12204372693394072, 0.12204372693394072, 0.12204372693394072, 0.19366088438734153, 0.19366088438734153, 0.19366088438734153, 0.18381347383334623, 0.18381347383334623, 0.18381347383334623, 0.19389723460239217, 0.19389723460239217, 0.19389723460239217, 0.1626218038376297, 0.1626218038376297, 0.1626218038376297, 0.11595576335091062, 0.11595576335091062, 0.11595576335091062, 0.1344692081178659, 0.1344692081178659, 0.1344692081178659, 0.167004821199903, 0.167004821199903, 0.167004821199903, 0.14882296018189045, 0.14882296018189045, 0.14882296018189045, 0.18456497767241054, 0.18456497767241054, 0.18456497767241054, 0.14338428231364253, 0.14338428231364253, 0.14338428231364253, 0.14167011373564997, 0.14167011373564997, 0.14167011373564997, 0.16051858587490664, 0.16051858587490664, 0.16051858587490664, 0.2655112581501663, 0.2655112581501663, 0.2655112581501663, 0.1508371292387044, 0.1508371292387044, 0.1508371292387044, 0.1519798527598919, 0.1519798527598919, 0.1519798527598919, 0.15232903880630133, 0.15232903880630133, 0.15232903880630133, 0.2550247747626532, 0.2550247747626532, 0.2550247747626532, 0.18739635232072782, 0.18739635232072782, 0.18739635232072782, 0.1808333717078776, 0.1808333717078776, 0.1808333717078776, 0.185317575321721, 0.185317575321721, 0.185317575321721, 0.182408410363741, 0.182408410363741, 0.182408410363741, 0.057970346142207196, 0.057970346142207196, 0.057970346142207196, 0.06907370167513649, 0.06907370167513649, 0.06907370167513649, 0.05328673313733978, 0.05328673313733978, 0.05328673313733978]}, "mutation_prompt": null}
{"id": "4283632e-fff3-4f2d-a77e-5b6f59042480", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = np.clip(population[a] + self.mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Firefly algorithm component\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + self.alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "The algorithm uses a hybrid approach combining Differential Evolution and the Firefly Algorithm to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cc2416a9-6772-4a63-9de0-4b9a0e72b4b6", "metadata": {"aucs": [0.38671424945428157, 0.38671424945428157, 0.38671424945428157, 0.4114117458386485, 0.4114117458386485, 0.4114117458386485, 0.3494198852779937, 0.3494198852779937, 0.3494198852779937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07995213859166528, 0.07995213859166528, 0.07995213859166528, 0.07673325099524064, 0.07673325099524064, 0.07673325099524064, 0.07970583681358678, 0.07970583681358678, 0.07970583681358678, 0.07383804503320224, 0.07383804503320224, 0.07383804503320224, 0.05730401335524271, 0.05730401335524271, 0.05730401335524271, 0.06888982344012295, 0.06888982344012295, 0.06888982344012295, 0.7486377762319503, 0.7486377762319503, 0.7486377762319503, 0.6737881274611579, 0.6737881274611579, 0.6737881274611579, 0.8299431884002639, 0.8299431884002639, 0.8299431884002639, 0.15472327223719928, 0.15472327223719928, 0.15472327223719928, 0.14334459676327793, 0.14334459676327793, 0.14334459676327793, 0.17488856962273092, 0.17488856962273092, 0.17488856962273092, 0.17568429808026742, 0.17568429808026742, 0.17568429808026742, 0.2715017081378607, 0.2715017081378607, 0.2715017081378607, 0.1651267578152571, 0.1651267578152571, 0.1651267578152571, 0.1502586052407694, 0.1502586052407694, 0.1502586052407694, 0.10521249700509039, 0.10521249700509039, 0.10521249700509039, 0.12764902576751125, 0.12764902576751125, 0.12764902576751125, 0.06886163166904447, 0.06886163166904447, 0.06886163166904447, 0.11379502312731415, 0.11379502312731415, 0.11379502312731415, 0.08031332706986849, 0.08031332706986849, 0.08031332706986849, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0788544489426557, 0.0788544489426557, 0.0788544489426557, 0.020973199214352145, 0.020973199214352145, 0.020973199214352145, 0.0658415624009594, 0.0658415624009594, 0.0658415624009594, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.048120453688220044, 0.048120453688220044, 0.048120453688220044, 0.05365290633956321, 0.05365290633956321, 0.05365290633956321, 0.06971562461631786, 0.06971562461631786, 0.06971562461631786, 0.3229297546907369, 0.3229297546907369, 0.3229297546907369, 0.3391349955526477, 0.3391349955526477, 0.3391349955526477, 0.3132987371017727, 0.3132987371017727, 0.3132987371017727, 0.0760034942535669, 0.0760034942535669, 0.0760034942535669, 0.0576787432370236, 0.0576787432370236, 0.0576787432370236, 0.061897985250131904, 0.061897985250131904, 0.061897985250131904, 0.12000947315762156, 0.12000947315762156, 0.12000947315762156, 0.12335321079085426, 0.12335321079085426, 0.12335321079085426, 0.12204372693394072, 0.12204372693394072, 0.12204372693394072, 0.19366088438734153, 0.19366088438734153, 0.19366088438734153, 0.18381347383334623, 0.18381347383334623, 0.18381347383334623, 0.19389723460239217, 0.19389723460239217, 0.19389723460239217, 0.1626218038376297, 0.1626218038376297, 0.1626218038376297, 0.11595576335091062, 0.11595576335091062, 0.11595576335091062, 0.1344692081178659, 0.1344692081178659, 0.1344692081178659, 0.167004821199903, 0.167004821199903, 0.167004821199903, 0.14882296018189045, 0.14882296018189045, 0.14882296018189045, 0.18456497767241054, 0.18456497767241054, 0.18456497767241054, 0.14338428231364253, 0.14338428231364253, 0.14338428231364253, 0.14167011373564997, 0.14167011373564997, 0.14167011373564997, 0.16051858587490664, 0.16051858587490664, 0.16051858587490664, 0.2655112581501663, 0.2655112581501663, 0.2655112581501663, 0.1508371292387044, 0.1508371292387044, 0.1508371292387044, 0.1519798527598919, 0.1519798527598919, 0.1519798527598919, 0.15232903880630133, 0.15232903880630133, 0.15232903880630133, 0.2550247747626532, 0.2550247747626532, 0.2550247747626532, 0.18739635232072782, 0.18739635232072782, 0.18739635232072782, 0.1808333717078776, 0.1808333717078776, 0.1808333717078776, 0.185317575321721, 0.185317575321721, 0.185317575321721, 0.182408410363741, 0.182408410363741, 0.182408410363741, 0.057970346142207196, 0.057970346142207196, 0.057970346142207196, 0.06907370167513649, 0.06907370167513649, 0.06907370167513649, 0.05328673313733978, 0.05328673313733978, 0.05328673313733978]}, "mutation_prompt": null}
{"id": "85672eae-d266-4936-9dfb-366fc6d8af13", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = np.clip(population[a] + self.mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Firefly algorithm component\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + self.alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "The algorithm uses a hybrid approach combining Differential Evolution and the Firefly Algorithm to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cc2416a9-6772-4a63-9de0-4b9a0e72b4b6", "metadata": {"aucs": [0.38671424945428157, 0.38671424945428157, 0.38671424945428157, 0.4114117458386485, 0.4114117458386485, 0.4114117458386485, 0.3494198852779937, 0.3494198852779937, 0.3494198852779937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07995213859166528, 0.07995213859166528, 0.07995213859166528, 0.07673325099524064, 0.07673325099524064, 0.07673325099524064, 0.07970583681358678, 0.07970583681358678, 0.07970583681358678, 0.07383804503320224, 0.07383804503320224, 0.07383804503320224, 0.05730401335524271, 0.05730401335524271, 0.05730401335524271, 0.06888982344012295, 0.06888982344012295, 0.06888982344012295, 0.7486377762319503, 0.7486377762319503, 0.7486377762319503, 0.6737881274611579, 0.6737881274611579, 0.6737881274611579, 0.8299431884002639, 0.8299431884002639, 0.8299431884002639, 0.15472327223719928, 0.15472327223719928, 0.15472327223719928, 0.14334459676327793, 0.14334459676327793, 0.14334459676327793, 0.17488856962273092, 0.17488856962273092, 0.17488856962273092, 0.17568429808026742, 0.17568429808026742, 0.17568429808026742, 0.2715017081378607, 0.2715017081378607, 0.2715017081378607, 0.1651267578152571, 0.1651267578152571, 0.1651267578152571, 0.1502586052407694, 0.1502586052407694, 0.1502586052407694, 0.10521249700509039, 0.10521249700509039, 0.10521249700509039, 0.12764902576751125, 0.12764902576751125, 0.12764902576751125, 0.06886163166904447, 0.06886163166904447, 0.06886163166904447, 0.11379502312731415, 0.11379502312731415, 0.11379502312731415, 0.08031332706986849, 0.08031332706986849, 0.08031332706986849, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0788544489426557, 0.0788544489426557, 0.0788544489426557, 0.020973199214352145, 0.020973199214352145, 0.020973199214352145, 0.0658415624009594, 0.0658415624009594, 0.0658415624009594, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.048120453688220044, 0.048120453688220044, 0.048120453688220044, 0.05365290633956321, 0.05365290633956321, 0.05365290633956321, 0.06971562461631786, 0.06971562461631786, 0.06971562461631786, 0.3229297546907369, 0.3229297546907369, 0.3229297546907369, 0.3391349955526477, 0.3391349955526477, 0.3391349955526477, 0.3132987371017727, 0.3132987371017727, 0.3132987371017727, 0.0760034942535669, 0.0760034942535669, 0.0760034942535669, 0.0576787432370236, 0.0576787432370236, 0.0576787432370236, 0.061897985250131904, 0.061897985250131904, 0.061897985250131904, 0.12000947315762156, 0.12000947315762156, 0.12000947315762156, 0.12335321079085426, 0.12335321079085426, 0.12335321079085426, 0.12204372693394072, 0.12204372693394072, 0.12204372693394072, 0.19366088438734153, 0.19366088438734153, 0.19366088438734153, 0.18381347383334623, 0.18381347383334623, 0.18381347383334623, 0.19389723460239217, 0.19389723460239217, 0.19389723460239217, 0.1626218038376297, 0.1626218038376297, 0.1626218038376297, 0.11595576335091062, 0.11595576335091062, 0.11595576335091062, 0.1344692081178659, 0.1344692081178659, 0.1344692081178659, 0.167004821199903, 0.167004821199903, 0.167004821199903, 0.14882296018189045, 0.14882296018189045, 0.14882296018189045, 0.18456497767241054, 0.18456497767241054, 0.18456497767241054, 0.14338428231364253, 0.14338428231364253, 0.14338428231364253, 0.14167011373564997, 0.14167011373564997, 0.14167011373564997, 0.16051858587490664, 0.16051858587490664, 0.16051858587490664, 0.2655112581501663, 0.2655112581501663, 0.2655112581501663, 0.1508371292387044, 0.1508371292387044, 0.1508371292387044, 0.1519798527598919, 0.1519798527598919, 0.1519798527598919, 0.15232903880630133, 0.15232903880630133, 0.15232903880630133, 0.2550247747626532, 0.2550247747626532, 0.2550247747626532, 0.18739635232072782, 0.18739635232072782, 0.18739635232072782, 0.1808333717078776, 0.1808333717078776, 0.1808333717078776, 0.185317575321721, 0.185317575321721, 0.185317575321721, 0.182408410363741, 0.182408410363741, 0.182408410363741, 0.057970346142207196, 0.057970346142207196, 0.057970346142207196, 0.06907370167513649, 0.06907370167513649, 0.06907370167513649, 0.05328673313733978, 0.05328673313733978, 0.05328673313733978]}, "mutation_prompt": null}
{"id": "e200be53-8b28-46f3-8d54-09c924f5d12c", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                # Adaptive Differential Evolution mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                self.mutation_factor = 0.5 + 0.3 * (np.sin(budget_used / self.budget * np.pi) ** 2)  # Adaptive mutation\n                mutant = np.clip(population[a] + self.mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Adaptive Crossover\n                self.crossover_rate = 0.7 + 0.2 * (np.cos(budget_used / self.budget * np.pi) ** 2)  # Adaptive crossover\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Firefly algorithm component\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + self.alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Introduce adaptive parameter tuning for mutation factor and crossover rate in the HybridDEFirefly to enhance exploration and exploitation balance.", "configspace": "", "generation": 9, "fitness": 0.15432708501182726, "feedback": "The algorithm HybridDEFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.16.", "error": "", "parent_id": "cc2416a9-6772-4a63-9de0-4b9a0e72b4b6", "metadata": {"aucs": [0.3098819541677025, 0.3098819541677025, 0.3098819541677025, 0.3498647959493183, 0.3498647959493183, 0.3498647959493183, 0.3423604560434661, 0.3423604560434661, 0.3423604560434661, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0645192453981257, 0.0645192453981257, 0.0645192453981257, 0.07455204490734069, 0.07455204490734069, 0.07455204490734069, 0.0900995285551277, 0.0900995285551277, 0.0900995285551277, 0.053548850772373924, 0.053548850772373924, 0.053548850772373924, 0.05152604158840601, 0.05152604158840601, 0.05152604158840601, 0.058172786102372975, 0.058172786102372975, 0.058172786102372975, 0.7061890403005517, 0.7061890403005517, 0.7061890403005517, 0.7539118651062072, 0.7539118651062072, 0.7539118651062072, 0.8344039806935828, 0.8344039806935828, 0.8344039806935828, 0.17553166504147755, 0.17553166504147755, 0.17553166504147755, 0.12615334808956302, 0.12615334808956302, 0.12615334808956302, 0.22169265456564535, 0.22169265456564535, 0.22169265456564535, 0.17426083634225686, 0.17426083634225686, 0.17426083634225686, 0.24000449532260626, 0.24000449532260626, 0.24000449532260626, 0.14935068881883085, 0.14935068881883085, 0.14935068881883085, 0.10097433928248845, 0.10097433928248845, 0.10097433928248845, 0.1130747989117008, 0.1130747989117008, 0.1130747989117008, 0.11737753712613797, 0.11737753712613797, 0.11737753712613797, 0.031458792074898545, 0.031458792074898545, 0.031458792074898545, 0.12633558487557528, 0.12633558487557528, 0.12633558487557528, 0.09904545441428725, 0.09904545441428725, 0.09904545441428725, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08405716347681358, 0.08405716347681358, 0.08405716347681358, 0.05725905405961362, 0.05725905405961362, 0.05725905405961362, 0.07281609005727785, 0.07281609005727785, 0.07281609005727785, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04239747595397825, 0.04239747595397825, 0.04239747595397825, 0.06551272013402576, 0.06551272013402576, 0.06551272013402576, 0.0901412898597902, 0.0901412898597902, 0.0901412898597902, 0.33280570210304283, 0.33280570210304283, 0.33280570210304283, 0.3425315512340177, 0.3425315512340177, 0.3425315512340177, 0.31791152734273553, 0.31791152734273553, 0.31791152734273553, 0.0683483566932982, 0.0683483566932982, 0.0683483566932982, 0.05674055697963554, 0.05674055697963554, 0.05674055697963554, 0.07441746220877088, 0.07441746220877088, 0.07441746220877088, 0.13728184212959527, 0.13728184212959527, 0.13728184212959527, 0.13895050640289774, 0.13895050640289774, 0.13895050640289774, 0.12980262644963514, 0.12980262644963514, 0.12980262644963514, 0.1737254594537968, 0.1737254594537968, 0.1737254594537968, 0.1572408870381039, 0.1572408870381039, 0.1572408870381039, 0.1698431782177493, 0.1698431782177493, 0.1698431782177493, 0.13927970179677718, 0.13927970179677718, 0.13927970179677718, 0.1356639968387623, 0.1356639968387623, 0.1356639968387623, 0.12201014061304138, 0.12201014061304138, 0.12201014061304138, 0.1624401306542077, 0.1624401306542077, 0.1624401306542077, 0.17798689710235172, 0.17798689710235172, 0.17798689710235172, 0.16947378030049132, 0.16947378030049132, 0.16947378030049132, 0.15815693862442481, 0.15815693862442481, 0.15815693862442481, 0.1589748084180026, 0.1589748084180026, 0.1589748084180026, 0.16597562241429187, 0.16597562241429187, 0.16597562241429187, 0.17354109553791497, 0.17354109553791497, 0.17354109553791497, 0.22033214822140212, 0.22033214822140212, 0.22033214822140212, 0.1965133418600007, 0.1965133418600007, 0.1965133418600007, 0.16224064628798462, 0.16224064628798462, 0.16224064628798462, 0.21246953440865635, 0.21246953440865635, 0.21246953440865635, 0.15398387255420476, 0.15398387255420476, 0.15398387255420476, 0.1798231551592826, 0.1798231551592826, 0.1798231551592826, 0.18375952900996806, 0.18375952900996806, 0.18375952900996806, 0.18807276876925338, 0.18807276876925338, 0.18807276876925338, 0.07031637852638306, 0.07031637852638306, 0.07031637852638306, 0.05716621918198017, 0.05716621918198017, 0.05716621918198017, 0.04639518032736012, 0.04639518032736012, 0.04639518032736012]}, "mutation_prompt": null}
{"id": "8e89554f-a3cc-48fc-a064-f08bf52e1662", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = np.clip(population[a] + self.mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Firefly algorithm component\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + self.alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "The algorithm uses a hybrid approach combining Differential Evolution and the Firefly Algorithm to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cc2416a9-6772-4a63-9de0-4b9a0e72b4b6", "metadata": {"aucs": [0.38671424945428157, 0.38671424945428157, 0.38671424945428157, 0.4114117458386485, 0.4114117458386485, 0.4114117458386485, 0.3494198852779937, 0.3494198852779937, 0.3494198852779937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07995213859166528, 0.07995213859166528, 0.07995213859166528, 0.07673325099524064, 0.07673325099524064, 0.07673325099524064, 0.07970583681358678, 0.07970583681358678, 0.07970583681358678, 0.07383804503320224, 0.07383804503320224, 0.07383804503320224, 0.05730401335524271, 0.05730401335524271, 0.05730401335524271, 0.06888982344012295, 0.06888982344012295, 0.06888982344012295, 0.7486377762319503, 0.7486377762319503, 0.7486377762319503, 0.6737881274611579, 0.6737881274611579, 0.6737881274611579, 0.8299431884002639, 0.8299431884002639, 0.8299431884002639, 0.15472327223719928, 0.15472327223719928, 0.15472327223719928, 0.14334459676327793, 0.14334459676327793, 0.14334459676327793, 0.17488856962273092, 0.17488856962273092, 0.17488856962273092, 0.17568429808026742, 0.17568429808026742, 0.17568429808026742, 0.2715017081378607, 0.2715017081378607, 0.2715017081378607, 0.1651267578152571, 0.1651267578152571, 0.1651267578152571, 0.1502586052407694, 0.1502586052407694, 0.1502586052407694, 0.10521249700509039, 0.10521249700509039, 0.10521249700509039, 0.12764902576751125, 0.12764902576751125, 0.12764902576751125, 0.06886163166904447, 0.06886163166904447, 0.06886163166904447, 0.11379502312731415, 0.11379502312731415, 0.11379502312731415, 0.08031332706986849, 0.08031332706986849, 0.08031332706986849, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0788544489426557, 0.0788544489426557, 0.0788544489426557, 0.020973199214352145, 0.020973199214352145, 0.020973199214352145, 0.0658415624009594, 0.0658415624009594, 0.0658415624009594, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.048120453688220044, 0.048120453688220044, 0.048120453688220044, 0.05365290633956321, 0.05365290633956321, 0.05365290633956321, 0.06971562461631786, 0.06971562461631786, 0.06971562461631786, 0.3229297546907369, 0.3229297546907369, 0.3229297546907369, 0.3391349955526477, 0.3391349955526477, 0.3391349955526477, 0.3132987371017727, 0.3132987371017727, 0.3132987371017727, 0.0760034942535669, 0.0760034942535669, 0.0760034942535669, 0.0576787432370236, 0.0576787432370236, 0.0576787432370236, 0.061897985250131904, 0.061897985250131904, 0.061897985250131904, 0.12000947315762156, 0.12000947315762156, 0.12000947315762156, 0.12335321079085426, 0.12335321079085426, 0.12335321079085426, 0.12204372693394072, 0.12204372693394072, 0.12204372693394072, 0.19366088438734153, 0.19366088438734153, 0.19366088438734153, 0.18381347383334623, 0.18381347383334623, 0.18381347383334623, 0.19389723460239217, 0.19389723460239217, 0.19389723460239217, 0.1626218038376297, 0.1626218038376297, 0.1626218038376297, 0.11595576335091062, 0.11595576335091062, 0.11595576335091062, 0.1344692081178659, 0.1344692081178659, 0.1344692081178659, 0.167004821199903, 0.167004821199903, 0.167004821199903, 0.14882296018189045, 0.14882296018189045, 0.14882296018189045, 0.18456497767241054, 0.18456497767241054, 0.18456497767241054, 0.14338428231364253, 0.14338428231364253, 0.14338428231364253, 0.14167011373564997, 0.14167011373564997, 0.14167011373564997, 0.16051858587490664, 0.16051858587490664, 0.16051858587490664, 0.2655112581501663, 0.2655112581501663, 0.2655112581501663, 0.1508371292387044, 0.1508371292387044, 0.1508371292387044, 0.1519798527598919, 0.1519798527598919, 0.1519798527598919, 0.15232903880630133, 0.15232903880630133, 0.15232903880630133, 0.2550247747626532, 0.2550247747626532, 0.2550247747626532, 0.18739635232072782, 0.18739635232072782, 0.18739635232072782, 0.1808333717078776, 0.1808333717078776, 0.1808333717078776, 0.185317575321721, 0.185317575321721, 0.185317575321721, 0.182408410363741, 0.182408410363741, 0.182408410363741, 0.057970346142207196, 0.057970346142207196, 0.057970346142207196, 0.06907370167513649, 0.06907370167513649, 0.06907370167513649, 0.05328673313733978, 0.05328673313733978, 0.05328673313733978]}, "mutation_prompt": null}
{"id": "f1cbf3ca-8308-4cf9-83a0-5baacfe66da5", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = np.clip(population[a] + self.mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Firefly algorithm component\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + self.alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "The algorithm uses a hybrid approach combining Differential Evolution and the Firefly Algorithm to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cc2416a9-6772-4a63-9de0-4b9a0e72b4b6", "metadata": {"aucs": [0.38671424945428157, 0.38671424945428157, 0.38671424945428157, 0.4114117458386485, 0.4114117458386485, 0.4114117458386485, 0.3494198852779937, 0.3494198852779937, 0.3494198852779937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07995213859166528, 0.07995213859166528, 0.07995213859166528, 0.07673325099524064, 0.07673325099524064, 0.07673325099524064, 0.07970583681358678, 0.07970583681358678, 0.07970583681358678, 0.07383804503320224, 0.07383804503320224, 0.07383804503320224, 0.05730401335524271, 0.05730401335524271, 0.05730401335524271, 0.06888982344012295, 0.06888982344012295, 0.06888982344012295, 0.7486377762319503, 0.7486377762319503, 0.7486377762319503, 0.6737881274611579, 0.6737881274611579, 0.6737881274611579, 0.8299431884002639, 0.8299431884002639, 0.8299431884002639, 0.15472327223719928, 0.15472327223719928, 0.15472327223719928, 0.14334459676327793, 0.14334459676327793, 0.14334459676327793, 0.17488856962273092, 0.17488856962273092, 0.17488856962273092, 0.17568429808026742, 0.17568429808026742, 0.17568429808026742, 0.2715017081378607, 0.2715017081378607, 0.2715017081378607, 0.1651267578152571, 0.1651267578152571, 0.1651267578152571, 0.1502586052407694, 0.1502586052407694, 0.1502586052407694, 0.10521249700509039, 0.10521249700509039, 0.10521249700509039, 0.12764902576751125, 0.12764902576751125, 0.12764902576751125, 0.06886163166904447, 0.06886163166904447, 0.06886163166904447, 0.11379502312731415, 0.11379502312731415, 0.11379502312731415, 0.08031332706986849, 0.08031332706986849, 0.08031332706986849, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0788544489426557, 0.0788544489426557, 0.0788544489426557, 0.020973199214352145, 0.020973199214352145, 0.020973199214352145, 0.0658415624009594, 0.0658415624009594, 0.0658415624009594, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.048120453688220044, 0.048120453688220044, 0.048120453688220044, 0.05365290633956321, 0.05365290633956321, 0.05365290633956321, 0.06971562461631786, 0.06971562461631786, 0.06971562461631786, 0.3229297546907369, 0.3229297546907369, 0.3229297546907369, 0.3391349955526477, 0.3391349955526477, 0.3391349955526477, 0.3132987371017727, 0.3132987371017727, 0.3132987371017727, 0.0760034942535669, 0.0760034942535669, 0.0760034942535669, 0.0576787432370236, 0.0576787432370236, 0.0576787432370236, 0.061897985250131904, 0.061897985250131904, 0.061897985250131904, 0.12000947315762156, 0.12000947315762156, 0.12000947315762156, 0.12335321079085426, 0.12335321079085426, 0.12335321079085426, 0.12204372693394072, 0.12204372693394072, 0.12204372693394072, 0.19366088438734153, 0.19366088438734153, 0.19366088438734153, 0.18381347383334623, 0.18381347383334623, 0.18381347383334623, 0.19389723460239217, 0.19389723460239217, 0.19389723460239217, 0.1626218038376297, 0.1626218038376297, 0.1626218038376297, 0.11595576335091062, 0.11595576335091062, 0.11595576335091062, 0.1344692081178659, 0.1344692081178659, 0.1344692081178659, 0.167004821199903, 0.167004821199903, 0.167004821199903, 0.14882296018189045, 0.14882296018189045, 0.14882296018189045, 0.18456497767241054, 0.18456497767241054, 0.18456497767241054, 0.14338428231364253, 0.14338428231364253, 0.14338428231364253, 0.14167011373564997, 0.14167011373564997, 0.14167011373564997, 0.16051858587490664, 0.16051858587490664, 0.16051858587490664, 0.2655112581501663, 0.2655112581501663, 0.2655112581501663, 0.1508371292387044, 0.1508371292387044, 0.1508371292387044, 0.1519798527598919, 0.1519798527598919, 0.1519798527598919, 0.15232903880630133, 0.15232903880630133, 0.15232903880630133, 0.2550247747626532, 0.2550247747626532, 0.2550247747626532, 0.18739635232072782, 0.18739635232072782, 0.18739635232072782, 0.1808333717078776, 0.1808333717078776, 0.1808333717078776, 0.185317575321721, 0.185317575321721, 0.185317575321721, 0.182408410363741, 0.182408410363741, 0.182408410363741, 0.057970346142207196, 0.057970346142207196, 0.057970346142207196, 0.06907370167513649, 0.06907370167513649, 0.06907370167513649, 0.05328673313733978, 0.05328673313733978, 0.05328673313733978]}, "mutation_prompt": null}
{"id": "79fe4075-7427-4b54-ab15-ea3158df75f0", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = np.clip(population[a] + self.mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Firefly algorithm component\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + self.alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "The algorithm uses a hybrid approach combining Differential Evolution and the Firefly Algorithm to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cc2416a9-6772-4a63-9de0-4b9a0e72b4b6", "metadata": {"aucs": [0.38671424945428157, 0.38671424945428157, 0.38671424945428157, 0.4114117458386485, 0.4114117458386485, 0.4114117458386485, 0.3494198852779937, 0.3494198852779937, 0.3494198852779937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07995213859166528, 0.07995213859166528, 0.07995213859166528, 0.07673325099524064, 0.07673325099524064, 0.07673325099524064, 0.07970583681358678, 0.07970583681358678, 0.07970583681358678, 0.07383804503320224, 0.07383804503320224, 0.07383804503320224, 0.05730401335524271, 0.05730401335524271, 0.05730401335524271, 0.06888982344012295, 0.06888982344012295, 0.06888982344012295, 0.7486377762319503, 0.7486377762319503, 0.7486377762319503, 0.6737881274611579, 0.6737881274611579, 0.6737881274611579, 0.8299431884002639, 0.8299431884002639, 0.8299431884002639, 0.15472327223719928, 0.15472327223719928, 0.15472327223719928, 0.14334459676327793, 0.14334459676327793, 0.14334459676327793, 0.17488856962273092, 0.17488856962273092, 0.17488856962273092, 0.17568429808026742, 0.17568429808026742, 0.17568429808026742, 0.2715017081378607, 0.2715017081378607, 0.2715017081378607, 0.1651267578152571, 0.1651267578152571, 0.1651267578152571, 0.1502586052407694, 0.1502586052407694, 0.1502586052407694, 0.10521249700509039, 0.10521249700509039, 0.10521249700509039, 0.12764902576751125, 0.12764902576751125, 0.12764902576751125, 0.06886163166904447, 0.06886163166904447, 0.06886163166904447, 0.11379502312731415, 0.11379502312731415, 0.11379502312731415, 0.08031332706986849, 0.08031332706986849, 0.08031332706986849, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0788544489426557, 0.0788544489426557, 0.0788544489426557, 0.020973199214352145, 0.020973199214352145, 0.020973199214352145, 0.0658415624009594, 0.0658415624009594, 0.0658415624009594, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.048120453688220044, 0.048120453688220044, 0.048120453688220044, 0.05365290633956321, 0.05365290633956321, 0.05365290633956321, 0.06971562461631786, 0.06971562461631786, 0.06971562461631786, 0.3229297546907369, 0.3229297546907369, 0.3229297546907369, 0.3391349955526477, 0.3391349955526477, 0.3391349955526477, 0.3132987371017727, 0.3132987371017727, 0.3132987371017727, 0.0760034942535669, 0.0760034942535669, 0.0760034942535669, 0.0576787432370236, 0.0576787432370236, 0.0576787432370236, 0.061897985250131904, 0.061897985250131904, 0.061897985250131904, 0.12000947315762156, 0.12000947315762156, 0.12000947315762156, 0.12335321079085426, 0.12335321079085426, 0.12335321079085426, 0.12204372693394072, 0.12204372693394072, 0.12204372693394072, 0.19366088438734153, 0.19366088438734153, 0.19366088438734153, 0.18381347383334623, 0.18381347383334623, 0.18381347383334623, 0.19389723460239217, 0.19389723460239217, 0.19389723460239217, 0.1626218038376297, 0.1626218038376297, 0.1626218038376297, 0.11595576335091062, 0.11595576335091062, 0.11595576335091062, 0.1344692081178659, 0.1344692081178659, 0.1344692081178659, 0.167004821199903, 0.167004821199903, 0.167004821199903, 0.14882296018189045, 0.14882296018189045, 0.14882296018189045, 0.18456497767241054, 0.18456497767241054, 0.18456497767241054, 0.14338428231364253, 0.14338428231364253, 0.14338428231364253, 0.14167011373564997, 0.14167011373564997, 0.14167011373564997, 0.16051858587490664, 0.16051858587490664, 0.16051858587490664, 0.2655112581501663, 0.2655112581501663, 0.2655112581501663, 0.1508371292387044, 0.1508371292387044, 0.1508371292387044, 0.1519798527598919, 0.1519798527598919, 0.1519798527598919, 0.15232903880630133, 0.15232903880630133, 0.15232903880630133, 0.2550247747626532, 0.2550247747626532, 0.2550247747626532, 0.18739635232072782, 0.18739635232072782, 0.18739635232072782, 0.1808333717078776, 0.1808333717078776, 0.1808333717078776, 0.185317575321721, 0.185317575321721, 0.185317575321721, 0.182408410363741, 0.182408410363741, 0.182408410363741, 0.057970346142207196, 0.057970346142207196, 0.057970346142207196, 0.06907370167513649, 0.06907370167513649, 0.06907370167513649, 0.05328673313733978, 0.05328673313733978, 0.05328673313733978]}, "mutation_prompt": null}
{"id": "b77f7102-dc35-452d-8abd-be64452c1303", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = np.clip(population[a] + self.mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        # Adaptive alpha for dynamic search balance\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "The algorithm refines the firefly movement by introducing adaptive parameters for dynamic exploration and exploitation balance.", "configspace": "", "generation": 13, "fitness": 0.17532699720715939, "feedback": "The algorithm HybridDEFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.16.", "error": "", "parent_id": "cc2416a9-6772-4a63-9de0-4b9a0e72b4b6", "metadata": {"aucs": [0.43034525025240866, 0.43034525025240866, 0.43034525025240866, 0.41528520260179913, 0.41528520260179913, 0.41528520260179913, 0.39977466533200834, 0.39977466533200834, 0.39977466533200834, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004119568910518456, 0.004119568910518456, 0.004119568910518456, 0.08149760728859123, 0.08149760728859123, 0.08149760728859123, 0.07532999829995568, 0.07532999829995568, 0.07532999829995568, 0.12635663116096274, 0.12635663116096274, 0.12635663116096274, 0.06882010584011644, 0.06882010584011644, 0.06882010584011644, 0.0578767175818482, 0.0578767175818482, 0.0578767175818482, 0.09845259455055944, 0.09845259455055944, 0.09845259455055944, 0.7239850225001536, 0.7239850225001536, 0.7239850225001536, 0.7066139557223978, 0.7066139557223978, 0.7066139557223978, 0.7467187395255817, 0.7467187395255817, 0.7467187395255817, 0.23022130382232542, 0.23022130382232542, 0.23022130382232542, 0.22710158650090417, 0.22710158650090417, 0.22710158650090417, 0.2544524091659589, 0.2544524091659589, 0.2544524091659589, 0.1958901428930898, 0.1958901428930898, 0.1958901428930898, 0.5600513132571818, 0.5600513132571818, 0.5600513132571818, 0.19368619477770133, 0.19368619477770133, 0.19368619477770133, 0.10504633701752664, 0.10504633701752664, 0.10504633701752664, 0.15703655974667707, 0.15703655974667707, 0.15703655974667707, 0.07549857737526422, 0.07549857737526422, 0.07549857737526422, 0.0876297647477089, 0.0876297647477089, 0.0876297647477089, 0.12202598560538502, 0.12202598560538502, 0.12202598560538502, 0.11348462614464438, 0.11348462614464438, 0.11348462614464438, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09668845567441786, 0.09668845567441786, 0.09668845567441786, 0.030780363452960757, 0.030780363452960757, 0.030780363452960757, 0.04449523187326099, 0.04449523187326099, 0.04449523187326099, 0.010297844879786466, 0.010297844879786466, 0.010297844879786466, 0.004345605504175731, 0.004345605504175731, 0.004345605504175731, 0.007240836523382477, 0.007240836523382477, 0.007240836523382477, 0.06183016734757296, 0.06183016734757296, 0.06183016734757296, 0.06284778716535677, 0.06284778716535677, 0.06284778716535677, 0.10267620226638396, 0.10267620226638396, 0.10267620226638396, 0.3658928707430037, 0.3658928707430037, 0.3658928707430037, 0.37399749008547056, 0.37399749008547056, 0.37399749008547056, 0.394033456069004, 0.394033456069004, 0.394033456069004, 0.09505476853589412, 0.09505476853589412, 0.09505476853589412, 0.09648754908944535, 0.09648754908944535, 0.09648754908944535, 0.06707593629722175, 0.06707593629722175, 0.06707593629722175, 0.13815570143111922, 0.13815570143111922, 0.13815570143111922, 0.15063636310783457, 0.15063636310783457, 0.15063636310783457, 0.12290220087183001, 0.12290220087183001, 0.12290220087183001, 0.2439597018222034, 0.2439597018222034, 0.2439597018222034, 0.19213529519595118, 0.19213529519595118, 0.19213529519595118, 0.20811732822560192, 0.20811732822560192, 0.20811732822560192, 0.1562282023889695, 0.1562282023889695, 0.1562282023889695, 0.1088292654065055, 0.1088292654065055, 0.1088292654065055, 0.16477009326940573, 0.16477009326940573, 0.16477009326940573, 0.18503783753286618, 0.18503783753286618, 0.18503783753286618, 0.16258543820233184, 0.16258543820233184, 0.16258543820233184, 0.15953962583572046, 0.15953962583572046, 0.15953962583572046, 0.15709399324567908, 0.15709399324567908, 0.15709399324567908, 0.1444947422683157, 0.1444947422683157, 0.1444947422683157, 0.14717931544393614, 0.14717931544393614, 0.14717931544393614, 0.16760733665423355, 0.16760733665423355, 0.16760733665423355, 0.44368234200766643, 0.44368234200766643, 0.44368234200766643, 0.1420438970405692, 0.1420438970405692, 0.1420438970405692, 0.15668427695759068, 0.15668427695759068, 0.15668427695759068, 0.24884397963521643, 0.24884397963521643, 0.24884397963521643, 0.18927436750662197, 0.18927436750662197, 0.18927436750662197, 0.1920161100092902, 0.1920161100092902, 0.1920161100092902, 0.18246028782996992, 0.18246028782996992, 0.18246028782996992, 0.19783099364838186, 0.19783099364838186, 0.19783099364838186, 0.06537788578959802, 0.06537788578959802, 0.06537788578959802, 0.05836175346882788, 0.05836175346882788, 0.05836175346882788, 0.06615003799063157, 0.06615003799063157, 0.06615003799063157]}, "mutation_prompt": null}
{"id": "7301764e-5bd1-4787-9e97-ce26f9e81624", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n        population_size = self.initial_population_size\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(population_size):\n                # Differential Evolution mutation\n                indices = list(range(population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = np.clip(population[a] + self.mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(population_size):\n                for j in range(population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        # Adaptive alpha for dynamic search balance\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n\n            # Adjust population size dynamically\n            if budget_used < self.budget / 2:\n                population_size = min(population_size + 2, self.initial_population_size * 2)\n            else:\n                population_size = max(population_size - 2, self.initial_population_size // 2)\n\n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "The algorithm incorporates a dynamic population size adjustment mechanism to improve convergence speed.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 21 is out of bounds for axis 0 with size 20').", "error": "IndexError('index 21 is out of bounds for axis 0 with size 20')", "parent_id": "b77f7102-dc35-452d-8abd-be64452c1303", "metadata": {}, "mutation_prompt": null}
{"id": "861cf8a1-382d-4cb2-9454-d3d755cdce95", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = np.clip(population[a] + self.mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        # Adaptive alpha for dynamic search balance\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            # Adjust population size based on fitness diversity\n            if np.std(fitness) < 1e-3:  # Population converged\n                self.population_size = max(10, self.population_size - 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Introduce fitness-based dynamic population size adjustment to enhance convergence speed and resource utilization.", "configspace": "", "generation": 15, "fitness": 0.1753969249766837, "feedback": "The algorithm HybridDEFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.16.", "error": "", "parent_id": "b77f7102-dc35-452d-8abd-be64452c1303", "metadata": {"aucs": [0.4344554765751051, 0.4344554765751051, 0.4344554765751051, 0.4202151189765112, 0.4202151189765112, 0.4202151189765112, 0.39264309113022877, 0.39264309113022877, 0.39264309113022877, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004119568910518456, 0.004119568910518456, 0.004119568910518456, 0.08149760728859123, 0.08149760728859123, 0.08149760728859123, 0.07532999829995568, 0.07532999829995568, 0.07532999829995568, 0.12635663116096274, 0.12635663116096274, 0.12635663116096274, 0.06882010584011644, 0.06882010584011644, 0.06882010584011644, 0.0578767175818482, 0.0578767175818482, 0.0578767175818482, 0.09845259455055944, 0.09845259455055944, 0.09845259455055944, 0.7239850225001536, 0.7239850225001536, 0.7239850225001536, 0.7066139557223978, 0.7066139557223978, 0.7066139557223978, 0.7467187395255817, 0.7467187395255817, 0.7467187395255817, 0.2302823642644014, 0.2302823642644014, 0.2302823642644014, 0.2271013142404229, 0.2271013142404229, 0.2271013142404229, 0.2544524091659589, 0.2544524091659589, 0.2544524091659589, 0.1958901428930898, 0.1958901428930898, 0.1958901428930898, 0.5600513132571818, 0.5600513132571818, 0.5600513132571818, 0.19368619477770133, 0.19368619477770133, 0.19368619477770133, 0.10504633701752664, 0.10504633701752664, 0.10504633701752664, 0.15703655974667707, 0.15703655974667707, 0.15703655974667707, 0.07549857737526422, 0.07549857737526422, 0.07549857737526422, 0.0876297647477089, 0.0876297647477089, 0.0876297647477089, 0.12202598560538502, 0.12202598560538502, 0.12202598560538502, 0.11348462614464438, 0.11348462614464438, 0.11348462614464438, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09668845567441786, 0.09668845567441786, 0.09668845567441786, 0.030780363452960757, 0.030780363452960757, 0.030780363452960757, 0.04449523187326099, 0.04449523187326099, 0.04449523187326099, 0.010297844879786466, 0.010297844879786466, 0.010297844879786466, 0.004345605504175731, 0.004345605504175731, 0.004345605504175731, 0.007240836523382477, 0.007240836523382477, 0.007240836523382477, 0.06183016734757296, 0.06183016734757296, 0.06183016734757296, 0.06284778716535677, 0.06284778716535677, 0.06284778716535677, 0.10267620226638396, 0.10267620226638396, 0.10267620226638396, 0.36620866967124854, 0.36620866967124854, 0.36620866967124854, 0.37513013412252405, 0.37513013412252405, 0.37513013412252405, 0.3956505388692918, 0.3956505388692918, 0.3956505388692918, 0.09505476853589412, 0.09505476853589412, 0.09505476853589412, 0.09648754908944535, 0.09648754908944535, 0.09648754908944535, 0.06707593629722175, 0.06707593629722175, 0.06707593629722175, 0.13815570143111922, 0.13815570143111922, 0.13815570143111922, 0.15063636310783457, 0.15063636310783457, 0.15063636310783457, 0.12290220087183001, 0.12290220087183001, 0.12290220087183001, 0.2439597018222034, 0.2439597018222034, 0.2439597018222034, 0.19213529519595118, 0.19213529519595118, 0.19213529519595118, 0.20811732822560192, 0.20811732822560192, 0.20811732822560192, 0.1562282023889695, 0.1562282023889695, 0.1562282023889695, 0.1088292654065055, 0.1088292654065055, 0.1088292654065055, 0.16477009326940573, 0.16477009326940573, 0.16477009326940573, 0.18503783753286618, 0.18503783753286618, 0.18503783753286618, 0.16258543820233184, 0.16258543820233184, 0.16258543820233184, 0.15953962583572046, 0.15953962583572046, 0.15953962583572046, 0.15709398084947657, 0.15709398084947657, 0.15709398084947657, 0.1444947422683157, 0.1444947422683157, 0.1444947422683157, 0.14717931544393614, 0.14717931544393614, 0.14717931544393614, 0.16760733665423355, 0.16760733665423355, 0.16760733665423355, 0.44368234200766643, 0.44368234200766643, 0.44368234200766643, 0.1420438970405692, 0.1420438970405692, 0.1420438970405692, 0.15668427695759068, 0.15668427695759068, 0.15668427695759068, 0.24884397963521643, 0.24884397963521643, 0.24884397963521643, 0.18927429686576713, 0.18927429686576713, 0.18927429686576713, 0.1920161100092902, 0.1920161100092902, 0.1920161100092902, 0.18246028782996992, 0.18246028782996992, 0.18246028782996992, 0.19783099364838186, 0.19783099364838186, 0.19783099364838186, 0.06537788578959802, 0.06537788578959802, 0.06537788578959802, 0.05836175346882788, 0.05836175346882788, 0.05836175346882788, 0.06615003799063157, 0.06615003799063157, 0.06615003799063157]}, "mutation_prompt": null}
{"id": "7f72e064-86e8-4185-9422-bd42dfd1dd01", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = np.clip(population[a] + self.mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        # Adaptive alpha for dynamic search balance\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            # Adjust population size based on fitness diversity\n            if np.std(fitness) < 1e-3:  # Population converged\n                self.population_size = max(10, self.population_size - 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Introduce fitness-based dynamic population size adjustment to enhance convergence speed and resource utilization.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "861cf8a1-382d-4cb2-9454-d3d755cdce95", "metadata": {"aucs": [0.4344554765751051, 0.4344554765751051, 0.4344554765751051, 0.4202151189765112, 0.4202151189765112, 0.4202151189765112, 0.39264309113022877, 0.39264309113022877, 0.39264309113022877, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004119568910518456, 0.004119568910518456, 0.004119568910518456, 0.08149760728859123, 0.08149760728859123, 0.08149760728859123, 0.07532999829995568, 0.07532999829995568, 0.07532999829995568, 0.12635663116096274, 0.12635663116096274, 0.12635663116096274, 0.06882010584011644, 0.06882010584011644, 0.06882010584011644, 0.0578767175818482, 0.0578767175818482, 0.0578767175818482, 0.09845259455055944, 0.09845259455055944, 0.09845259455055944, 0.7239850225001536, 0.7239850225001536, 0.7239850225001536, 0.7066139557223978, 0.7066139557223978, 0.7066139557223978, 0.7467187395255817, 0.7467187395255817, 0.7467187395255817, 0.2302823642644014, 0.2302823642644014, 0.2302823642644014, 0.2271013142404229, 0.2271013142404229, 0.2271013142404229, 0.2544524091659589, 0.2544524091659589, 0.2544524091659589, 0.1958901428930898, 0.1958901428930898, 0.1958901428930898, 0.5600513132571818, 0.5600513132571818, 0.5600513132571818, 0.19368619477770133, 0.19368619477770133, 0.19368619477770133, 0.10504633701752664, 0.10504633701752664, 0.10504633701752664, 0.15703655974667707, 0.15703655974667707, 0.15703655974667707, 0.07549857737526422, 0.07549857737526422, 0.07549857737526422, 0.0876297647477089, 0.0876297647477089, 0.0876297647477089, 0.12202598560538502, 0.12202598560538502, 0.12202598560538502, 0.11348462614464438, 0.11348462614464438, 0.11348462614464438, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09668845567441786, 0.09668845567441786, 0.09668845567441786, 0.030780363452960757, 0.030780363452960757, 0.030780363452960757, 0.04449523187326099, 0.04449523187326099, 0.04449523187326099, 0.010297844879786466, 0.010297844879786466, 0.010297844879786466, 0.004345605504175731, 0.004345605504175731, 0.004345605504175731, 0.007240836523382477, 0.007240836523382477, 0.007240836523382477, 0.06183016734757296, 0.06183016734757296, 0.06183016734757296, 0.06284778716535677, 0.06284778716535677, 0.06284778716535677, 0.10267620226638396, 0.10267620226638396, 0.10267620226638396, 0.36620866967124854, 0.36620866967124854, 0.36620866967124854, 0.37513013412252405, 0.37513013412252405, 0.37513013412252405, 0.3956505388692918, 0.3956505388692918, 0.3956505388692918, 0.09505476853589412, 0.09505476853589412, 0.09505476853589412, 0.09648754908944535, 0.09648754908944535, 0.09648754908944535, 0.06707593629722175, 0.06707593629722175, 0.06707593629722175, 0.13815570143111922, 0.13815570143111922, 0.13815570143111922, 0.15063636310783457, 0.15063636310783457, 0.15063636310783457, 0.12290220087183001, 0.12290220087183001, 0.12290220087183001, 0.2439597018222034, 0.2439597018222034, 0.2439597018222034, 0.19213529519595118, 0.19213529519595118, 0.19213529519595118, 0.20811732822560192, 0.20811732822560192, 0.20811732822560192, 0.1562282023889695, 0.1562282023889695, 0.1562282023889695, 0.1088292654065055, 0.1088292654065055, 0.1088292654065055, 0.16477009326940573, 0.16477009326940573, 0.16477009326940573, 0.18503783753286618, 0.18503783753286618, 0.18503783753286618, 0.16258543820233184, 0.16258543820233184, 0.16258543820233184, 0.15953962583572046, 0.15953962583572046, 0.15953962583572046, 0.15709398084947657, 0.15709398084947657, 0.15709398084947657, 0.1444947422683157, 0.1444947422683157, 0.1444947422683157, 0.14717931544393614, 0.14717931544393614, 0.14717931544393614, 0.16760733665423355, 0.16760733665423355, 0.16760733665423355, 0.44368234200766643, 0.44368234200766643, 0.44368234200766643, 0.1420438970405692, 0.1420438970405692, 0.1420438970405692, 0.15668427695759068, 0.15668427695759068, 0.15668427695759068, 0.24884397963521643, 0.24884397963521643, 0.24884397963521643, 0.18927429686576713, 0.18927429686576713, 0.18927429686576713, 0.1920161100092902, 0.1920161100092902, 0.1920161100092902, 0.18246028782996992, 0.18246028782996992, 0.18246028782996992, 0.19783099364838186, 0.19783099364838186, 0.19783099364838186, 0.06537788578959802, 0.06537788578959802, 0.06537788578959802, 0.05836175346882788, 0.05836175346882788, 0.05836175346882788, 0.06615003799063157, 0.06615003799063157, 0.06615003799063157]}, "mutation_prompt": null}
{"id": "9f871a36-b167-41d0-a5d4-54f5421675f5", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = np.clip(population[a] + self.mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        # Adaptive alpha for dynamic search balance\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            # Adjust population size based on fitness diversity\n            if np.std(fitness) < 1e-3:  # Population converged\n                self.population_size = max(10, self.population_size - 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Introduce fitness-based dynamic population size adjustment to enhance convergence speed and resource utilization.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "861cf8a1-382d-4cb2-9454-d3d755cdce95", "metadata": {"aucs": [0.4344554765751051, 0.4344554765751051, 0.4344554765751051, 0.4202151189765112, 0.4202151189765112, 0.4202151189765112, 0.39264309113022877, 0.39264309113022877, 0.39264309113022877, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004119568910518456, 0.004119568910518456, 0.004119568910518456, 0.08149760728859123, 0.08149760728859123, 0.08149760728859123, 0.07532999829995568, 0.07532999829995568, 0.07532999829995568, 0.12635663116096274, 0.12635663116096274, 0.12635663116096274, 0.06882010584011644, 0.06882010584011644, 0.06882010584011644, 0.0578767175818482, 0.0578767175818482, 0.0578767175818482, 0.09845259455055944, 0.09845259455055944, 0.09845259455055944, 0.7239850225001536, 0.7239850225001536, 0.7239850225001536, 0.7066139557223978, 0.7066139557223978, 0.7066139557223978, 0.7467187395255817, 0.7467187395255817, 0.7467187395255817, 0.2302823642644014, 0.2302823642644014, 0.2302823642644014, 0.2271013142404229, 0.2271013142404229, 0.2271013142404229, 0.2544524091659589, 0.2544524091659589, 0.2544524091659589, 0.1958901428930898, 0.1958901428930898, 0.1958901428930898, 0.5600513132571818, 0.5600513132571818, 0.5600513132571818, 0.19368619477770133, 0.19368619477770133, 0.19368619477770133, 0.10504633701752664, 0.10504633701752664, 0.10504633701752664, 0.15703655974667707, 0.15703655974667707, 0.15703655974667707, 0.07549857737526422, 0.07549857737526422, 0.07549857737526422, 0.0876297647477089, 0.0876297647477089, 0.0876297647477089, 0.12202598560538502, 0.12202598560538502, 0.12202598560538502, 0.11348462614464438, 0.11348462614464438, 0.11348462614464438, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09668845567441786, 0.09668845567441786, 0.09668845567441786, 0.030780363452960757, 0.030780363452960757, 0.030780363452960757, 0.04449523187326099, 0.04449523187326099, 0.04449523187326099, 0.010297844879786466, 0.010297844879786466, 0.010297844879786466, 0.004345605504175731, 0.004345605504175731, 0.004345605504175731, 0.007240836523382477, 0.007240836523382477, 0.007240836523382477, 0.06183016734757296, 0.06183016734757296, 0.06183016734757296, 0.06284778716535677, 0.06284778716535677, 0.06284778716535677, 0.10267620226638396, 0.10267620226638396, 0.10267620226638396, 0.36620866967124854, 0.36620866967124854, 0.36620866967124854, 0.37513013412252405, 0.37513013412252405, 0.37513013412252405, 0.3956505388692918, 0.3956505388692918, 0.3956505388692918, 0.09505476853589412, 0.09505476853589412, 0.09505476853589412, 0.09648754908944535, 0.09648754908944535, 0.09648754908944535, 0.06707593629722175, 0.06707593629722175, 0.06707593629722175, 0.13815570143111922, 0.13815570143111922, 0.13815570143111922, 0.15063636310783457, 0.15063636310783457, 0.15063636310783457, 0.12290220087183001, 0.12290220087183001, 0.12290220087183001, 0.2439597018222034, 0.2439597018222034, 0.2439597018222034, 0.19213529519595118, 0.19213529519595118, 0.19213529519595118, 0.20811732822560192, 0.20811732822560192, 0.20811732822560192, 0.1562282023889695, 0.1562282023889695, 0.1562282023889695, 0.1088292654065055, 0.1088292654065055, 0.1088292654065055, 0.16477009326940573, 0.16477009326940573, 0.16477009326940573, 0.18503783753286618, 0.18503783753286618, 0.18503783753286618, 0.16258543820233184, 0.16258543820233184, 0.16258543820233184, 0.15953962583572046, 0.15953962583572046, 0.15953962583572046, 0.15709398084947657, 0.15709398084947657, 0.15709398084947657, 0.1444947422683157, 0.1444947422683157, 0.1444947422683157, 0.14717931544393614, 0.14717931544393614, 0.14717931544393614, 0.16760733665423355, 0.16760733665423355, 0.16760733665423355, 0.44368234200766643, 0.44368234200766643, 0.44368234200766643, 0.1420438970405692, 0.1420438970405692, 0.1420438970405692, 0.15668427695759068, 0.15668427695759068, 0.15668427695759068, 0.24884397963521643, 0.24884397963521643, 0.24884397963521643, 0.18927429686576713, 0.18927429686576713, 0.18927429686576713, 0.1920161100092902, 0.1920161100092902, 0.1920161100092902, 0.18246028782996992, 0.18246028782996992, 0.18246028782996992, 0.19783099364838186, 0.19783099364838186, 0.19783099364838186, 0.06537788578959802, 0.06537788578959802, 0.06537788578959802, 0.05836175346882788, 0.05836175346882788, 0.05836175346882788, 0.06615003799063157, 0.06615003799063157, 0.06615003799063157]}, "mutation_prompt": null}
{"id": "d0387519-84c0-44eb-b059-45d20ab86517", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = np.clip(population[a] + self.mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        # Adaptive alpha for dynamic search balance\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Random walk for exploration\n            random_walk = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n            new_population += random_walk * (1 - (budget_used / self.budget))\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            # Adjust population size based on fitness diversity\n            if np.std(fitness) < 1e-3:  # Population converged\n                self.population_size = max(10, self.population_size - 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Enhance exploration by introducing random walks for population diversity, leading to improved convergence over diverse landscapes.", "configspace": "", "generation": 18, "fitness": 0.13574227608818448, "feedback": "The algorithm HybridDEFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.12.", "error": "", "parent_id": "861cf8a1-382d-4cb2-9454-d3d755cdce95", "metadata": {"aucs": [0.28616531801036416, 0.28616531801036416, 0.28616531801036416, 0.34833931413221697, 0.34833931413221697, 0.34833931413221697, 0.3208129425547961, 0.3208129425547961, 0.3208129425547961, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06403580499389483, 0.06403580499389483, 0.06403580499389483, 0.0728296900864347, 0.0728296900864347, 0.0728296900864347, 0.07665767494082487, 0.07665767494082487, 0.07665767494082487, 0.052040230452102376, 0.052040230452102376, 0.052040230452102376, 0.05601340258568177, 0.05601340258568177, 0.05601340258568177, 0.04761091331794942, 0.04761091331794942, 0.04761091331794942, 0.21634504768751073, 0.21634504768751073, 0.21634504768751073, 0.6402618068991831, 0.6402618068991831, 0.6402618068991831, 0.6182610322751199, 0.6182610322751199, 0.6182610322751199, 0.14206983072366364, 0.14206983072366364, 0.14206983072366364, 0.2067860259821196, 0.2067860259821196, 0.2067860259821196, 0.2020958498986376, 0.2020958498986376, 0.2020958498986376, 0.10962655778384611, 0.10962655778384611, 0.10962655778384611, 0.2281689093420235, 0.2281689093420235, 0.2281689093420235, 0.1805655481654712, 0.1805655481654712, 0.1805655481654712, 0.10351903301707277, 0.10351903301707277, 0.10351903301707277, 0.08920332629426087, 0.08920332629426087, 0.08920332629426087, 0.0881768453567312, 0.0881768453567312, 0.0881768453567312, 0.05717776144488784, 0.05717776144488784, 0.05717776144488784, 0.07695338539158658, 0.07695338539158658, 0.07695338539158658, 0.06285940852731708, 0.06285940852731708, 0.06285940852731708, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07146894769002943, 0.07146894769002943, 0.07146894769002943, 0.028847687575465186, 0.028847687575465186, 0.028847687575465186, 0.08329652073339044, 0.08329652073339044, 0.08329652073339044, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0514687773793987, 0.0514687773793987, 0.0514687773793987, 0.049246077340960426, 0.049246077340960426, 0.049246077340960426, 0.051947988957674385, 0.051947988957674385, 0.051947988957674385, 0.30692741762219544, 0.30692741762219544, 0.30692741762219544, 0.3135577611501994, 0.3135577611501994, 0.3135577611501994, 0.26788928857577143, 0.26788928857577143, 0.26788928857577143, 0.07107859036836273, 0.07107859036836273, 0.07107859036836273, 0.047852289065385634, 0.047852289065385634, 0.047852289065385634, 0.08203934709322713, 0.08203934709322713, 0.08203934709322713, 0.12825335694086293, 0.12825335694086293, 0.12825335694086293, 0.12213649154546224, 0.12213649154546224, 0.12213649154546224, 0.12821089669303876, 0.12821089669303876, 0.12821089669303876, 0.21735272644869652, 0.21735272644869652, 0.21735272644869652, 0.1612439055841811, 0.1612439055841811, 0.1612439055841811, 0.1687986524424554, 0.1687986524424554, 0.1687986524424554, 0.14831006934216895, 0.14831006934216895, 0.14831006934216895, 0.13160241556383478, 0.13160241556383478, 0.13160241556383478, 0.0982825254091807, 0.0982825254091807, 0.0982825254091807, 0.1604541165375889, 0.1604541165375889, 0.1604541165375889, 0.15636691503351208, 0.15636691503351208, 0.15636691503351208, 0.17204752040732552, 0.17204752040732552, 0.17204752040732552, 0.1588912331683161, 0.1588912331683161, 0.1588912331683161, 0.1471202249197131, 0.1471202249197131, 0.1471202249197131, 0.16484000402234378, 0.16484000402234378, 0.16484000402234378, 0.1705018495740065, 0.1705018495740065, 0.1705018495740065, 0.1583714478618018, 0.1583714478618018, 0.1583714478618018, 0.13752494481185618, 0.13752494481185618, 0.13752494481185618, 0.1404022856692072, 0.1404022856692072, 0.1404022856692072, 0.20654069725197555, 0.20654069725197555, 0.20654069725197555, 0.18381127239121064, 0.18381127239121064, 0.18381127239121064, 0.19410593600032855, 0.19410593600032855, 0.19410593600032855, 0.17310643169547202, 0.17310643169547202, 0.17310643169547202, 0.1931343867602281, 0.1931343867602281, 0.1931343867602281, 0.050171216131071894, 0.050171216131071894, 0.050171216131071894, 0.06459013322653939, 0.06459013322653939, 0.06459013322653939, 0.06417586950114784, 0.06417586950114784, 0.06417586950114784]}, "mutation_prompt": null}
{"id": "cd0dce99-6f55-4e29-b749-57853ebff2bc", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation with adaptive factor\n                self.mutation_factor = 0.5 + 0.5 * (best_fitness - fitness[i]) / np.ptp(fitness)\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = np.clip(population[a] + self.mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover with adaptive rate\n                self.crossover_rate = 0.7 * (1 - (fitness[i] - best_fitness) / np.ptp(fitness))\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        # Adaptive alpha for dynamic search balance\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            # Adjust population size based on fitness diversity\n            if np.std(fitness) < 1e-3:  # Population converged\n                self.population_size = max(10, self.population_size - 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Introduce adaptive mutation and crossover rates to enhance exploitation-exploration balance and convergence performance.", "configspace": "", "generation": 19, "fitness": 0.15664996691503014, "feedback": "The algorithm HybridDEFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.15.", "error": "", "parent_id": "861cf8a1-382d-4cb2-9454-d3d755cdce95", "metadata": {"aucs": [0.3983309811444581, 0.3983309811444581, 0.3983309811444581, 0.41182102916855945, 0.41182102916855945, 0.41182102916855945, 0.44030524213098055, 0.44030524213098055, 0.44030524213098055, 0.0006941567430572837, 0.0006941567430572837, 0.0006941567430572837, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03108975525604296, 0.03108975525604296, 0.03108975525604296, 0.07364217990582711, 0.07364217990582711, 0.07364217990582711, 0.07955338402263279, 0.07955338402263279, 0.07955338402263279, 0.07152438391729699, 0.07152438391729699, 0.07152438391729699, 0.043637010718400426, 0.043637010718400426, 0.043637010718400426, 0.05534801379587917, 0.05534801379587917, 0.05534801379587917, 0.07693677920333486, 0.07693677920333486, 0.07693677920333486, 0.6850774151746037, 0.6850774151746037, 0.6850774151746037, 0.7758092520699849, 0.7758092520699849, 0.7758092520699849, 0.6943986699829454, 0.6943986699829454, 0.6943986699829454, 0.2130554609491091, 0.2130554609491091, 0.2130554609491091, 0.19187447985194062, 0.19187447985194062, 0.19187447985194062, 0.2520960465429144, 0.2520960465429144, 0.2520960465429144, 0.16042350010304474, 0.16042350010304474, 0.16042350010304474, 0.14484592278770758, 0.14484592278770758, 0.14484592278770758, 0.11687727779117285, 0.11687727779117285, 0.11687727779117285, 0.13172838629039363, 0.13172838629039363, 0.13172838629039363, 0.10026680357262907, 0.10026680357262907, 0.10026680357262907, 0.07551148192864277, 0.07551148192864277, 0.07551148192864277, 0.10003944640017193, 0.10003944640017193, 0.10003944640017193, 0.12358054829693121, 0.12358054829693121, 0.12358054829693121, 0.07099692951402836, 0.07099692951402836, 0.07099692951402836, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.034451113210967166, 0.034451113210967166, 0.034451113210967166, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06949474515853982, 0.06949474515853982, 0.06949474515853982, 0.029191811243983512, 0.029191811243983512, 0.029191811243983512, 0.04599763093169151, 0.04599763093169151, 0.04599763093169151, 0.008507678324114587, 0.008507678324114587, 0.008507678324114587, 0.008726436702709561, 0.008726436702709561, 0.008726436702709561, 0.009914809413808734, 0.009914809413808734, 0.009914809413808734, 0.04379572192633496, 0.04379572192633496, 0.04379572192633496, 0.08585464735699044, 0.08585464735699044, 0.08585464735699044, 0.08480652259957366, 0.08480652259957366, 0.08480652259957366, 0.34972782465298957, 0.34972782465298957, 0.34972782465298957, 0.34967183284216463, 0.34967183284216463, 0.34967183284216463, 0.35248286132008966, 0.35248286132008966, 0.35248286132008966, 0.07512649610753397, 0.07512649610753397, 0.07512649610753397, 0.04626920777054888, 0.04626920777054888, 0.04626920777054888, 0.05804089207784835, 0.05804089207784835, 0.05804089207784835, 0.1388766273593507, 0.1388766273593507, 0.1388766273593507, 0.13789870904601376, 0.13789870904601376, 0.13789870904601376, 0.18795570029150366, 0.18795570029150366, 0.18795570029150366, 0.1985138563105373, 0.1985138563105373, 0.1985138563105373, 0.15543697015614777, 0.15543697015614777, 0.15543697015614777, 0.14639004285125645, 0.14639004285125645, 0.14639004285125645, 0.13598115324459925, 0.13598115324459925, 0.13598115324459925, 0.16817102221677638, 0.16817102221677638, 0.16817102221677638, 0.09952092717578964, 0.09952092717578964, 0.09952092717578964, 0.18424145059544672, 0.18424145059544672, 0.18424145059544672, 0.16219174954320315, 0.16219174954320315, 0.16219174954320315, 0.1739766776603361, 0.1739766776603361, 0.1739766776603361, 0.14587588159845621, 0.14587588159845621, 0.14587588159845621, 0.14269489370696176, 0.14269489370696176, 0.14269489370696176, 0.1646880927911658, 0.1646880927911658, 0.1646880927911658, 0.17401118222880307, 0.17401118222880307, 0.17401118222880307, 0.14985405136622298, 0.14985405136622298, 0.14985405136622298, 0.12544371816343924, 0.12544371816343924, 0.12544371816343924, 0.13192311814350466, 0.13192311814350466, 0.13192311814350466, 0.16052413182782344, 0.16052413182782344, 0.16052413182782344, 0.2354800751213042, 0.2354800751213042, 0.2354800751213042, 0.17647913273583293, 0.17647913273583293, 0.17647913273583293, 0.2093629252999808, 0.2093629252999808, 0.2093629252999808, 0.20224007433636582, 0.20224007433636582, 0.20224007433636582, 0.06167401564644037, 0.06167401564644037, 0.06167401564644037, 0.07030232458631269, 0.07030232458631269, 0.07030232458631269, 0.0672643449760153, 0.0672643449760153, 0.0672643449760153]}, "mutation_prompt": null}
{"id": "d935efe7-eec7-4abe-92d3-77b00f930598", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = np.clip(population[a] + self.mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        # Adaptive alpha for dynamic search balance\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            # Adjust population size based on fitness diversity\n            if np.std(fitness) < 1e-3:  # Population converged\n                self.population_size = max(10, self.population_size - 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Introduce fitness-based dynamic population size adjustment to enhance convergence speed and resource utilization.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "861cf8a1-382d-4cb2-9454-d3d755cdce95", "metadata": {"aucs": [0.4344554765751051, 0.4344554765751051, 0.4344554765751051, 0.4202151189765112, 0.4202151189765112, 0.4202151189765112, 0.39264309113022877, 0.39264309113022877, 0.39264309113022877, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004119568910518456, 0.004119568910518456, 0.004119568910518456, 0.08149760728859123, 0.08149760728859123, 0.08149760728859123, 0.07532999829995568, 0.07532999829995568, 0.07532999829995568, 0.12635663116096274, 0.12635663116096274, 0.12635663116096274, 0.06882010584011644, 0.06882010584011644, 0.06882010584011644, 0.0578767175818482, 0.0578767175818482, 0.0578767175818482, 0.09845259455055944, 0.09845259455055944, 0.09845259455055944, 0.7239850225001536, 0.7239850225001536, 0.7239850225001536, 0.7066139557223978, 0.7066139557223978, 0.7066139557223978, 0.7467187395255817, 0.7467187395255817, 0.7467187395255817, 0.2302823642644014, 0.2302823642644014, 0.2302823642644014, 0.2271013142404229, 0.2271013142404229, 0.2271013142404229, 0.2544524091659589, 0.2544524091659589, 0.2544524091659589, 0.1958901428930898, 0.1958901428930898, 0.1958901428930898, 0.5600513132571818, 0.5600513132571818, 0.5600513132571818, 0.19368619477770133, 0.19368619477770133, 0.19368619477770133, 0.10504633701752664, 0.10504633701752664, 0.10504633701752664, 0.15703655974667707, 0.15703655974667707, 0.15703655974667707, 0.07549857737526422, 0.07549857737526422, 0.07549857737526422, 0.0876297647477089, 0.0876297647477089, 0.0876297647477089, 0.12202598560538502, 0.12202598560538502, 0.12202598560538502, 0.11348462614464438, 0.11348462614464438, 0.11348462614464438, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09668845567441786, 0.09668845567441786, 0.09668845567441786, 0.030780363452960757, 0.030780363452960757, 0.030780363452960757, 0.04449523187326099, 0.04449523187326099, 0.04449523187326099, 0.010297844879786466, 0.010297844879786466, 0.010297844879786466, 0.004345605504175731, 0.004345605504175731, 0.004345605504175731, 0.007240836523382477, 0.007240836523382477, 0.007240836523382477, 0.06183016734757296, 0.06183016734757296, 0.06183016734757296, 0.06284778716535677, 0.06284778716535677, 0.06284778716535677, 0.10267620226638396, 0.10267620226638396, 0.10267620226638396, 0.36620866967124854, 0.36620866967124854, 0.36620866967124854, 0.37513013412252405, 0.37513013412252405, 0.37513013412252405, 0.3956505388692918, 0.3956505388692918, 0.3956505388692918, 0.09505476853589412, 0.09505476853589412, 0.09505476853589412, 0.09648754908944535, 0.09648754908944535, 0.09648754908944535, 0.06707593629722175, 0.06707593629722175, 0.06707593629722175, 0.13815570143111922, 0.13815570143111922, 0.13815570143111922, 0.15063636310783457, 0.15063636310783457, 0.15063636310783457, 0.12290220087183001, 0.12290220087183001, 0.12290220087183001, 0.2439597018222034, 0.2439597018222034, 0.2439597018222034, 0.19213529519595118, 0.19213529519595118, 0.19213529519595118, 0.20811732822560192, 0.20811732822560192, 0.20811732822560192, 0.1562282023889695, 0.1562282023889695, 0.1562282023889695, 0.1088292654065055, 0.1088292654065055, 0.1088292654065055, 0.16477009326940573, 0.16477009326940573, 0.16477009326940573, 0.18503783753286618, 0.18503783753286618, 0.18503783753286618, 0.16258543820233184, 0.16258543820233184, 0.16258543820233184, 0.15953962583572046, 0.15953962583572046, 0.15953962583572046, 0.15709398084947657, 0.15709398084947657, 0.15709398084947657, 0.1444947422683157, 0.1444947422683157, 0.1444947422683157, 0.14717931544393614, 0.14717931544393614, 0.14717931544393614, 0.16760733665423355, 0.16760733665423355, 0.16760733665423355, 0.44368234200766643, 0.44368234200766643, 0.44368234200766643, 0.1420438970405692, 0.1420438970405692, 0.1420438970405692, 0.15668427695759068, 0.15668427695759068, 0.15668427695759068, 0.24884397963521643, 0.24884397963521643, 0.24884397963521643, 0.18927429686576713, 0.18927429686576713, 0.18927429686576713, 0.1920161100092902, 0.1920161100092902, 0.1920161100092902, 0.18246028782996992, 0.18246028782996992, 0.18246028782996992, 0.19783099364838186, 0.19783099364838186, 0.19783099364838186, 0.06537788578959802, 0.06537788578959802, 0.06537788578959802, 0.05836175346882788, 0.05836175346882788, 0.05836175346882788, 0.06615003799063157, 0.06615003799063157, 0.06615003799063157]}, "mutation_prompt": null}
{"id": "d9a1d780-5437-4f93-8a44-3500dadd6366", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = np.clip(population[a] + self.mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        # Adaptive alpha for dynamic search balance\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            # Adjust population size based on fitness diversity\n            if np.std(fitness) < 1e-3:  # Population converged\n                self.population_size = max(10, self.population_size - 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Introduce fitness-based dynamic population size adjustment to enhance convergence speed and resource utilization.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "861cf8a1-382d-4cb2-9454-d3d755cdce95", "metadata": {"aucs": [0.4344554765751051, 0.4344554765751051, 0.4344554765751051, 0.4202151189765112, 0.4202151189765112, 0.4202151189765112, 0.39264309113022877, 0.39264309113022877, 0.39264309113022877, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004119568910518456, 0.004119568910518456, 0.004119568910518456, 0.08149760728859123, 0.08149760728859123, 0.08149760728859123, 0.07532999829995568, 0.07532999829995568, 0.07532999829995568, 0.12635663116096274, 0.12635663116096274, 0.12635663116096274, 0.06882010584011644, 0.06882010584011644, 0.06882010584011644, 0.0578767175818482, 0.0578767175818482, 0.0578767175818482, 0.09845259455055944, 0.09845259455055944, 0.09845259455055944, 0.7239850225001536, 0.7239850225001536, 0.7239850225001536, 0.7066139557223978, 0.7066139557223978, 0.7066139557223978, 0.7467187395255817, 0.7467187395255817, 0.7467187395255817, 0.2302823642644014, 0.2302823642644014, 0.2302823642644014, 0.2271013142404229, 0.2271013142404229, 0.2271013142404229, 0.2544524091659589, 0.2544524091659589, 0.2544524091659589, 0.1958901428930898, 0.1958901428930898, 0.1958901428930898, 0.5600513132571818, 0.5600513132571818, 0.5600513132571818, 0.19368619477770133, 0.19368619477770133, 0.19368619477770133, 0.10504633701752664, 0.10504633701752664, 0.10504633701752664, 0.15703655974667707, 0.15703655974667707, 0.15703655974667707, 0.07549857737526422, 0.07549857737526422, 0.07549857737526422, 0.0876297647477089, 0.0876297647477089, 0.0876297647477089, 0.12202598560538502, 0.12202598560538502, 0.12202598560538502, 0.11348462614464438, 0.11348462614464438, 0.11348462614464438, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09668845567441786, 0.09668845567441786, 0.09668845567441786, 0.030780363452960757, 0.030780363452960757, 0.030780363452960757, 0.04449523187326099, 0.04449523187326099, 0.04449523187326099, 0.010297844879786466, 0.010297844879786466, 0.010297844879786466, 0.004345605504175731, 0.004345605504175731, 0.004345605504175731, 0.007240836523382477, 0.007240836523382477, 0.007240836523382477, 0.06183016734757296, 0.06183016734757296, 0.06183016734757296, 0.06284778716535677, 0.06284778716535677, 0.06284778716535677, 0.10267620226638396, 0.10267620226638396, 0.10267620226638396, 0.36620866967124854, 0.36620866967124854, 0.36620866967124854, 0.37513013412252405, 0.37513013412252405, 0.37513013412252405, 0.3956505388692918, 0.3956505388692918, 0.3956505388692918, 0.09505476853589412, 0.09505476853589412, 0.09505476853589412, 0.09648754908944535, 0.09648754908944535, 0.09648754908944535, 0.06707593629722175, 0.06707593629722175, 0.06707593629722175, 0.13815570143111922, 0.13815570143111922, 0.13815570143111922, 0.15063636310783457, 0.15063636310783457, 0.15063636310783457, 0.12290220087183001, 0.12290220087183001, 0.12290220087183001, 0.2439597018222034, 0.2439597018222034, 0.2439597018222034, 0.19213529519595118, 0.19213529519595118, 0.19213529519595118, 0.20811732822560192, 0.20811732822560192, 0.20811732822560192, 0.1562282023889695, 0.1562282023889695, 0.1562282023889695, 0.1088292654065055, 0.1088292654065055, 0.1088292654065055, 0.16477009326940573, 0.16477009326940573, 0.16477009326940573, 0.18503783753286618, 0.18503783753286618, 0.18503783753286618, 0.16258543820233184, 0.16258543820233184, 0.16258543820233184, 0.15953962583572046, 0.15953962583572046, 0.15953962583572046, 0.15709398084947657, 0.15709398084947657, 0.15709398084947657, 0.1444947422683157, 0.1444947422683157, 0.1444947422683157, 0.14717931544393614, 0.14717931544393614, 0.14717931544393614, 0.16760733665423355, 0.16760733665423355, 0.16760733665423355, 0.44368234200766643, 0.44368234200766643, 0.44368234200766643, 0.1420438970405692, 0.1420438970405692, 0.1420438970405692, 0.15668427695759068, 0.15668427695759068, 0.15668427695759068, 0.24884397963521643, 0.24884397963521643, 0.24884397963521643, 0.18927429686576713, 0.18927429686576713, 0.18927429686576713, 0.1920161100092902, 0.1920161100092902, 0.1920161100092902, 0.18246028782996992, 0.18246028782996992, 0.18246028782996992, 0.19783099364838186, 0.19783099364838186, 0.19783099364838186, 0.06537788578959802, 0.06537788578959802, 0.06537788578959802, 0.05836175346882788, 0.05836175346882788, 0.05836175346882788, 0.06615003799063157, 0.06615003799063157, 0.06615003799063157]}, "mutation_prompt": null}
{"id": "11a5ec6a-eaab-4081-96ec-9bda0fe6e78b", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = np.clip(population[a] + self.mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        # Adaptive alpha for dynamic search balance\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Stochastic ranking step to occasionally prioritize less-fit individuals\n            if np.random.rand() < 0.05:\n                idx = np.random.choice(self.population_size, size=2, replace=False)\n                if fitness[idx[0]] > fitness[idx[1]] and np.random.rand() < 0.5:\n                    new_population[idx[0]], new_population[idx[1]] = new_population[idx[1]], new_population[idx[0]]\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            # Adjust population size based on fitness diversity\n            if np.std(fitness) < 1e-3:  # Population converged\n                self.population_size = max(10, self.population_size - 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Incorporate stochastic ranking to balance exploration-exploitation by prioritizing less-fit individuals occasionally.", "configspace": "", "generation": 22, "fitness": 0.17164199481722112, "feedback": "The algorithm HybridDEFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.15.", "error": "", "parent_id": "861cf8a1-382d-4cb2-9454-d3d755cdce95", "metadata": {"aucs": [0.4486618326619578, 0.4486618326619578, 0.4486618326619578, 0.45608567235235364, 0.45608567235235364, 0.45608567235235364, 0.4012570432803765, 0.4012570432803765, 0.4012570432803765, 0.001923654474802583, 0.001923654474802583, 0.001923654474802583, 0.0023885971366205405, 0.0023885971366205405, 0.0023885971366205405, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08009092226912284, 0.08009092226912284, 0.08009092226912284, 0.08733468878546014, 0.08733468878546014, 0.08733468878546014, 0.09424495060233096, 0.09424495060233096, 0.09424495060233096, 0.0720463626315988, 0.0720463626315988, 0.0720463626315988, 0.056209577873275296, 0.056209577873275296, 0.056209577873275296, 0.06402294492432614, 0.06402294492432614, 0.06402294492432614, 0.6650356824060207, 0.6650356824060207, 0.6650356824060207, 0.735129768937416, 0.735129768937416, 0.735129768937416, 0.6438143200244789, 0.6438143200244789, 0.6438143200244789, 0.2324363862890193, 0.2324363862890193, 0.2324363862890193, 0.23821251694379342, 0.23821251694379342, 0.23821251694379342, 0.23968381326789978, 0.23968381326789978, 0.23968381326789978, 0.31063733318325326, 0.31063733318325326, 0.31063733318325326, 0.19767660818744826, 0.19767660818744826, 0.19767660818744826, 0.3573215619033645, 0.3573215619033645, 0.3573215619033645, 0.1396819553480798, 0.1396819553480798, 0.1396819553480798, 0.146055886718661, 0.146055886718661, 0.146055886718661, 0.13453043689154454, 0.13453043689154454, 0.13453043689154454, 0.10932409598803916, 0.10932409598803916, 0.10932409598803916, 0.12057658261941906, 0.12057658261941906, 0.12057658261941906, 0.15066494686337717, 0.15066494686337717, 0.15066494686337717, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00021002355509658344, 0.00021002355509658344, 0.00021002355509658344, 0.00117873762631171, 0.00117873762631171, 0.00117873762631171, 0.07106112090033745, 0.07106112090033745, 0.07106112090033745, 0.033504490722183644, 0.033504490722183644, 0.033504490722183644, 0.08054085862569704, 0.08054085862569704, 0.08054085862569704, 0.0022654383878927264, 0.0022654383878927264, 0.0022654383878927264, 0.008519013972198453, 0.008519013972198453, 0.008519013972198453, 0.002161028118726205, 0.002161028118726205, 0.002161028118726205, 0.05993587594942873, 0.05993587594942873, 0.05993587594942873, 0.08141272477144645, 0.08141272477144645, 0.08141272477144645, 0.08060292610213549, 0.08060292610213549, 0.08060292610213549, 0.38641771618922116, 0.38641771618922116, 0.38641771618922116, 0.3851327949348975, 0.3851327949348975, 0.3851327949348975, 0.35072805373800575, 0.35072805373800575, 0.35072805373800575, 0.08458020312342873, 0.08458020312342873, 0.08458020312342873, 0.0807911412045923, 0.0807911412045923, 0.0807911412045923, 0.0708387764338817, 0.0708387764338817, 0.0708387764338817, 0.12764479649099958, 0.12764479649099958, 0.12764479649099958, 0.12730686468485508, 0.12730686468485508, 0.12730686468485508, 0.15393630405155323, 0.15393630405155323, 0.15393630405155323, 0.22269431569437914, 0.22269431569437914, 0.22269431569437914, 0.23460920107832894, 0.23460920107832894, 0.23460920107832894, 0.19118344897915118, 0.19118344897915118, 0.19118344897915118, 0.15692863316791972, 0.15692863316791972, 0.15692863316791972, 0.13107320130278133, 0.13107320130278133, 0.13107320130278133, 0.13648689989664164, 0.13648689989664164, 0.13648689989664164, 0.18455788621407743, 0.18455788621407743, 0.18455788621407743, 0.19417417637617895, 0.19417417637617895, 0.19417417637617895, 0.17608222371262183, 0.17608222371262183, 0.17608222371262183, 0.1430487243235955, 0.1430487243235955, 0.1430487243235955, 0.15746999713645582, 0.15746999713645582, 0.15746999713645582, 0.1673645740245827, 0.1673645740245827, 0.1673645740245827, 0.17680525640137512, 0.17680525640137512, 0.17680525640137512, 0.16807634624145518, 0.16807634624145518, 0.16807634624145518, 0.2750144280979615, 0.2750144280979615, 0.2750144280979615, 0.16076569138530106, 0.16076569138530106, 0.16076569138530106, 0.1326815467925908, 0.1326815467925908, 0.1326815467925908, 0.22162488616040044, 0.22162488616040044, 0.22162488616040044, 0.18988461071130647, 0.18988461071130647, 0.18988461071130647, 0.18294458289061555, 0.18294458289061555, 0.18294458289061555, 0.1942395173116982, 0.1942395173116982, 0.1942395173116982, 0.06118258347386962, 0.06118258347386962, 0.06118258347386962, 0.05852099596280946, 0.05852099596280946, 0.05852099596280946, 0.06679286735689405, 0.06679286735689405, 0.06679286735689405]}, "mutation_prompt": null}
{"id": "962ee7bb-4608-4dbc-90fd-4f09066a8eac", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            \n            # Adaptive mutation factor and crossover rate\n            adaptation = 1 - (budget_used / self.budget)\n            self.mutation_factor = 0.4 + 0.3 * adaptation\n            self.crossover_rate = 0.6 + 0.4 * adaptation\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = np.clip(population[a] + self.mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        # Adaptive alpha for dynamic search balance\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n\n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            # Adjust population size based on fitness diversity\n            if np.std(fitness) < 1e-3:  # Population converged\n                self.population_size = max(10, self.population_size - 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Introduce adaptive crossover rate and mutation factor for enhanced exploration and convergence in dynamic environments.", "configspace": "", "generation": 23, "fitness": 0.17212139800680865, "feedback": "The algorithm HybridDEFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.16.", "error": "", "parent_id": "861cf8a1-382d-4cb2-9454-d3d755cdce95", "metadata": {"aucs": [0.3935090276284632, 0.3935090276284632, 0.3935090276284632, 0.37719108609631524, 0.37719108609631524, 0.37719108609631524, 0.3848702094480638, 0.3848702094480638, 0.3848702094480638, 0.03423804005402398, 0.03423804005402398, 0.03423804005402398, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026946642480055516, 0.026946642480055516, 0.026946642480055516, 0.09227145552932525, 0.09227145552932525, 0.09227145552932525, 0.12535984830218572, 0.12535984830218572, 0.12535984830218572, 0.07258677433952676, 0.07258677433952676, 0.07258677433952676, 0.05434820209630575, 0.05434820209630575, 0.05434820209630575, 0.06949144061551638, 0.06949144061551638, 0.06949144061551638, 0.0790573976099902, 0.0790573976099902, 0.0790573976099902, 0.6590322027884923, 0.6590322027884923, 0.6590322027884923, 0.7528521352830249, 0.7528521352830249, 0.7528521352830249, 0.7520685000718312, 0.7520685000718312, 0.7520685000718312, 0.23641690840625695, 0.23641690840625695, 0.23641690840625695, 0.20869999256079197, 0.20869999256079197, 0.20869999256079197, 0.2506687679517613, 0.2506687679517613, 0.2506687679517613, 0.15537340348220752, 0.15537340348220752, 0.15537340348220752, 0.4616886181624239, 0.4616886181624239, 0.4616886181624239, 0.5519061277401502, 0.5519061277401502, 0.5519061277401502, 0.06118219209520048, 0.06118219209520048, 0.06118219209520048, 0.1394827145286689, 0.1394827145286689, 0.1394827145286689, 0.15299056343655992, 0.15299056343655992, 0.15299056343655992, 0.07424706668253911, 0.07424706668253911, 0.07424706668253911, 0.11684705698407982, 0.11684705698407982, 0.11684705698407982, 0.12600613866245858, 0.12600613866245858, 0.12600613866245858, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0403155937709162, 0.0403155937709162, 0.0403155937709162, 0.0297341465904134, 0.0297341465904134, 0.0297341465904134, 0.059306674111785807, 0.059306674111785807, 0.059306674111785807, 0.004526705016899668, 0.004526705016899668, 0.004526705016899668, 0.0038163010910969852, 0.0038163010910969852, 0.0038163010910969852, 0.01158500444043109, 0.01158500444043109, 0.01158500444043109, 0.04354193903175496, 0.04354193903175496, 0.04354193903175496, 0.10495544960375514, 0.10495544960375514, 0.10495544960375514, 0.057964463442243375, 0.057964463442243375, 0.057964463442243375, 0.3757973710940926, 0.3757973710940926, 0.3757973710940926, 0.3849447082133085, 0.3849447082133085, 0.3849447082133085, 0.34457368129704924, 0.34457368129704924, 0.34457368129704924, 0.090220959355378, 0.090220959355378, 0.090220959355378, 0.06264125637997153, 0.06264125637997153, 0.06264125637997153, 0.06934423784081578, 0.06934423784081578, 0.06934423784081578, 0.14328882524100517, 0.14328882524100517, 0.14328882524100517, 0.11941021977505484, 0.11941021977505484, 0.11941021977505484, 0.15442312590752172, 0.15442312590752172, 0.15442312590752172, 0.18899200922685377, 0.18899200922685377, 0.18899200922685377, 0.1904037795340029, 0.1904037795340029, 0.1904037795340029, 0.17369375313504276, 0.17369375313504276, 0.17369375313504276, 0.1223436737698037, 0.1223436737698037, 0.1223436737698037, 0.18519423875290364, 0.18519423875290364, 0.18519423875290364, 0.12362983957809648, 0.12362983957809648, 0.12362983957809648, 0.1913634537991462, 0.1913634537991462, 0.1913634537991462, 0.1683372849388899, 0.1683372849388899, 0.1683372849388899, 0.17555696399936738, 0.17555696399936738, 0.17555696399936738, 0.1504351589651668, 0.1504351589651668, 0.1504351589651668, 0.14244354444462803, 0.14244354444462803, 0.14244354444462803, 0.1640497744055368, 0.1640497744055368, 0.1640497744055368, 0.407209441695344, 0.407209441695344, 0.407209441695344, 0.1378063780588713, 0.1378063780588713, 0.1378063780588713, 0.16957752187599962, 0.16957752187599962, 0.16957752187599962, 0.14399440317208412, 0.14399440317208412, 0.14399440317208412, 0.1499336092840653, 0.1499336092840653, 0.1499336092840653, 0.15368727334938082, 0.15368727334938082, 0.15368727334938082, 0.19539413672060846, 0.19539413672060846, 0.19539413672060846, 0.19738239754884523, 0.19738239754884523, 0.19738239754884523, 0.18982714227473263, 0.18982714227473263, 0.18982714227473263, 0.05313413515133447, 0.05313413515133447, 0.05313413515133447, 0.0567648598456062, 0.0567648598456062, 0.0567648598456062, 0.05146270772419792, 0.05146270772419792, 0.05146270772419792]}, "mutation_prompt": null}
{"id": "97ea3425-00c3-4943-8bf9-f0ec59f7a6a2", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation with dynamic mutation factor\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        # Adaptive alpha for dynamic search balance\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            # Adjust population size based on fitness diversity\n            if np.std(fitness) < 1e-3:  # Population converged\n                self.population_size = max(10, self.population_size - 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Integrate dynamic mutation factor adaptation in Differential Evolution to enhance exploration and exploitation balance.", "configspace": "", "generation": 24, "fitness": 0.18358311268754754, "feedback": "The algorithm HybridDEFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.17.", "error": "", "parent_id": "861cf8a1-382d-4cb2-9454-d3d755cdce95", "metadata": {"aucs": [0.4319311729983544, 0.4319311729983544, 0.4319311729983544, 0.4215352875259071, 0.4215352875259071, 0.4215352875259071, 0.4164567336260978, 0.4164567336260978, 0.4164567336260978, 0.019014994901096927, 0.019014994901096927, 0.019014994901096927, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09679538625987572, 0.09679538625987572, 0.09679538625987572, 0.10072875938875059, 0.10072875938875059, 0.10072875938875059, 0.12434120990140929, 0.12434120990140929, 0.12434120990140929, 0.07876597807445929, 0.07876597807445929, 0.07876597807445929, 0.08262370896588722, 0.08262370896588722, 0.08262370896588722, 0.04492416725366677, 0.04492416725366677, 0.04492416725366677, 0.7389422307234629, 0.7389422307234629, 0.7389422307234629, 0.7192069597106947, 0.7192069597106947, 0.7192069597106947, 0.7465628589666173, 0.7465628589666173, 0.7465628589666173, 0.2562873902477363, 0.2562873902477363, 0.2562873902477363, 0.27242010339984113, 0.27242010339984113, 0.27242010339984113, 0.2513710550890431, 0.2513710550890431, 0.2513710550890431, 0.4653274609686022, 0.4653274609686022, 0.4653274609686022, 0.16002205773709177, 0.16002205773709177, 0.16002205773709177, 0.15347997963970206, 0.15347997963970206, 0.15347997963970206, 0.11042529597747452, 0.11042529597747452, 0.11042529597747452, 0.15312748257229047, 0.15312748257229047, 0.15312748257229047, 0.13580578631686935, 0.13580578631686935, 0.13580578631686935, 0.08010268147634148, 0.08010268147634148, 0.08010268147634148, 0.08987202542825545, 0.08987202542825545, 0.08987202542825545, 0.09082782657155863, 0.09082782657155863, 0.09082782657155863, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04947053302503723, 0.04947053302503723, 0.04947053302503723, 0.026809852690875102, 0.026809852690875102, 0.026809852690875102, 0.0675316219464801, 0.0675316219464801, 0.0675316219464801, 0.008600989675169313, 0.008600989675169313, 0.008600989675169313, 0.01226050568907755, 0.01226050568907755, 0.01226050568907755, 0.004943777113542658, 0.004943777113542658, 0.004943777113542658, 0.07397836540921054, 0.07397836540921054, 0.07397836540921054, 0.07672487098044234, 0.07672487098044234, 0.07672487098044234, 0.07938415534951782, 0.07938415534951782, 0.07938415534951782, 0.37626577839165254, 0.37626577839165254, 0.37626577839165254, 0.38023983131268224, 0.38023983131268224, 0.38023983131268224, 0.3908989888507489, 0.3908989888507489, 0.3908989888507489, 0.08654788680259085, 0.08654788680259085, 0.08654788680259085, 0.06195418983406742, 0.06195418983406742, 0.06195418983406742, 0.08036200046716968, 0.08036200046716968, 0.08036200046716968, 0.1450589726964978, 0.1450589726964978, 0.1450589726964978, 0.13612425986407783, 0.13612425986407783, 0.13612425986407783, 0.1552935572358245, 0.1552935572358245, 0.1552935572358245, 0.20249661005692632, 0.20249661005692632, 0.20249661005692632, 0.2382793089185259, 0.2382793089185259, 0.2382793089185259, 0.27175484803242256, 0.27175484803242256, 0.27175484803242256, 0.1926549798820879, 0.1926549798820879, 0.1926549798820879, 0.1353437197749714, 0.1353437197749714, 0.1353437197749714, 0.17113114680970465, 0.17113114680970465, 0.17113114680970465, 0.1711590068999458, 0.1711590068999458, 0.1711590068999458, 0.1630952979689495, 0.1630952979689495, 0.1630952979689495, 0.19632706441034498, 0.19632706441034498, 0.19632706441034498, 0.1512702604935512, 0.1512702604935512, 0.1512702604935512, 0.1817262633128255, 0.1817262633128255, 0.1817262633128255, 0.15853281859830282, 0.15853281859830282, 0.15853281859830282, 0.18130060932563952, 0.18130060932563952, 0.18130060932563952, 0.5170602888683834, 0.5170602888683834, 0.5170602888683834, 0.23382127477785974, 0.23382127477785974, 0.23382127477785974, 0.15236129383243424, 0.15236129383243424, 0.15236129383243424, 0.526117796169173, 0.526117796169173, 0.526117796169173, 0.17357773354019812, 0.17357773354019812, 0.17357773354019812, 0.17848258036137976, 0.17848258036137976, 0.17848258036137976, 0.17595025711490475, 0.17595025711490475, 0.17595025711490475, 0.21145311530087418, 0.21145311530087418, 0.21145311530087418, 0.06290648594659032, 0.06290648594659032, 0.06290648594659032, 0.05449623845010387, 0.05449623845010387, 0.05449623845010387, 0.06283638360157184, 0.06283638360157184, 0.06283638360157184]}, "mutation_prompt": null}
{"id": "ffc65ebf-b9f2-430a-88a1-6a1d5073a3da", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation with dynamic mutation factor\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            # Dynamically adjust population size based on budget usage\n            if (budget_used / self.budget) > 0.5 and np.std(fitness) < 1e-3:\n                self.population_size = max(10, self.population_size - 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Enhance hybrid DE-Firefly by dynamically adapting population size based on budget usage for improved diversity.", "configspace": "", "generation": 25, "fitness": 0.18358311268754754, "feedback": "The algorithm HybridDEFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.17.", "error": "", "parent_id": "97ea3425-00c3-4943-8bf9-f0ec59f7a6a2", "metadata": {"aucs": [0.4319311729983544, 0.4319311729983544, 0.4319311729983544, 0.4215352875259071, 0.4215352875259071, 0.4215352875259071, 0.4164567336260978, 0.4164567336260978, 0.4164567336260978, 0.019014994901096927, 0.019014994901096927, 0.019014994901096927, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09679538625987572, 0.09679538625987572, 0.09679538625987572, 0.10072875938875059, 0.10072875938875059, 0.10072875938875059, 0.12434120990140929, 0.12434120990140929, 0.12434120990140929, 0.07876597807445929, 0.07876597807445929, 0.07876597807445929, 0.08262370896588722, 0.08262370896588722, 0.08262370896588722, 0.04492416725366677, 0.04492416725366677, 0.04492416725366677, 0.7389422307234629, 0.7389422307234629, 0.7389422307234629, 0.7192069597106947, 0.7192069597106947, 0.7192069597106947, 0.7465628589666173, 0.7465628589666173, 0.7465628589666173, 0.2562873902477363, 0.2562873902477363, 0.2562873902477363, 0.27242010339984113, 0.27242010339984113, 0.27242010339984113, 0.2513710550890431, 0.2513710550890431, 0.2513710550890431, 0.4653274609686022, 0.4653274609686022, 0.4653274609686022, 0.16002205773709177, 0.16002205773709177, 0.16002205773709177, 0.15347997963970206, 0.15347997963970206, 0.15347997963970206, 0.11042529597747452, 0.11042529597747452, 0.11042529597747452, 0.15312748257229047, 0.15312748257229047, 0.15312748257229047, 0.13580578631686935, 0.13580578631686935, 0.13580578631686935, 0.08010268147634148, 0.08010268147634148, 0.08010268147634148, 0.08987202542825545, 0.08987202542825545, 0.08987202542825545, 0.09082782657155863, 0.09082782657155863, 0.09082782657155863, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04947053302503723, 0.04947053302503723, 0.04947053302503723, 0.026809852690875102, 0.026809852690875102, 0.026809852690875102, 0.0675316219464801, 0.0675316219464801, 0.0675316219464801, 0.008600989675169313, 0.008600989675169313, 0.008600989675169313, 0.01226050568907755, 0.01226050568907755, 0.01226050568907755, 0.004943777113542658, 0.004943777113542658, 0.004943777113542658, 0.07397836540921054, 0.07397836540921054, 0.07397836540921054, 0.07672487098044234, 0.07672487098044234, 0.07672487098044234, 0.07938415534951782, 0.07938415534951782, 0.07938415534951782, 0.37626577839165254, 0.37626577839165254, 0.37626577839165254, 0.38023983131268224, 0.38023983131268224, 0.38023983131268224, 0.3908989888507489, 0.3908989888507489, 0.3908989888507489, 0.08654788680259085, 0.08654788680259085, 0.08654788680259085, 0.06195418983406742, 0.06195418983406742, 0.06195418983406742, 0.08036200046716968, 0.08036200046716968, 0.08036200046716968, 0.1450589726964978, 0.1450589726964978, 0.1450589726964978, 0.13612425986407783, 0.13612425986407783, 0.13612425986407783, 0.1552935572358245, 0.1552935572358245, 0.1552935572358245, 0.20249661005692632, 0.20249661005692632, 0.20249661005692632, 0.2382793089185259, 0.2382793089185259, 0.2382793089185259, 0.27175484803242256, 0.27175484803242256, 0.27175484803242256, 0.1926549798820879, 0.1926549798820879, 0.1926549798820879, 0.1353437197749714, 0.1353437197749714, 0.1353437197749714, 0.17113114680970465, 0.17113114680970465, 0.17113114680970465, 0.1711590068999458, 0.1711590068999458, 0.1711590068999458, 0.1630952979689495, 0.1630952979689495, 0.1630952979689495, 0.19632706441034498, 0.19632706441034498, 0.19632706441034498, 0.1512702604935512, 0.1512702604935512, 0.1512702604935512, 0.1817262633128255, 0.1817262633128255, 0.1817262633128255, 0.15853281859830282, 0.15853281859830282, 0.15853281859830282, 0.18130060932563952, 0.18130060932563952, 0.18130060932563952, 0.5170602888683834, 0.5170602888683834, 0.5170602888683834, 0.23382127477785974, 0.23382127477785974, 0.23382127477785974, 0.15236129383243424, 0.15236129383243424, 0.15236129383243424, 0.526117796169173, 0.526117796169173, 0.526117796169173, 0.17357773354019812, 0.17357773354019812, 0.17357773354019812, 0.17848258036137976, 0.17848258036137976, 0.17848258036137976, 0.17595025711490475, 0.17595025711490475, 0.17595025711490475, 0.21145311530087418, 0.21145311530087418, 0.21145311530087418, 0.06290648594659032, 0.06290648594659032, 0.06290648594659032, 0.05449623845010387, 0.05449623845010387, 0.05449623845010387, 0.06283638360157184, 0.06283638360157184, 0.06283638360157184]}, "mutation_prompt": null}
{"id": "e3403c31-21de-413f-8268-6ff2157cf528", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation with dynamic mutation factor\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        # Adaptive alpha for dynamic search balance\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            # Adjust population size based on fitness diversity\n            if np.std(fitness) < 1e-3:  # Population converged\n                self.population_size = max(10, self.population_size - 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Integrate dynamic mutation factor adaptation in Differential Evolution to enhance exploration and exploitation balance.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "97ea3425-00c3-4943-8bf9-f0ec59f7a6a2", "metadata": {"aucs": [0.4319311729983544, 0.4319311729983544, 0.4319311729983544, 0.4215352875259071, 0.4215352875259071, 0.4215352875259071, 0.4164567336260978, 0.4164567336260978, 0.4164567336260978, 0.019014994901096927, 0.019014994901096927, 0.019014994901096927, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09679538625987572, 0.09679538625987572, 0.09679538625987572, 0.10072875938875059, 0.10072875938875059, 0.10072875938875059, 0.12434120990140929, 0.12434120990140929, 0.12434120990140929, 0.07876597807445929, 0.07876597807445929, 0.07876597807445929, 0.08262370896588722, 0.08262370896588722, 0.08262370896588722, 0.04492416725366677, 0.04492416725366677, 0.04492416725366677, 0.7389422307234629, 0.7389422307234629, 0.7389422307234629, 0.7192069597106947, 0.7192069597106947, 0.7192069597106947, 0.7465628589666173, 0.7465628589666173, 0.7465628589666173, 0.2562873902477363, 0.2562873902477363, 0.2562873902477363, 0.27242010339984113, 0.27242010339984113, 0.27242010339984113, 0.2513710550890431, 0.2513710550890431, 0.2513710550890431, 0.4653274609686022, 0.4653274609686022, 0.4653274609686022, 0.16002205773709177, 0.16002205773709177, 0.16002205773709177, 0.15347997963970206, 0.15347997963970206, 0.15347997963970206, 0.11042529597747452, 0.11042529597747452, 0.11042529597747452, 0.15312748257229047, 0.15312748257229047, 0.15312748257229047, 0.13580578631686935, 0.13580578631686935, 0.13580578631686935, 0.08010268147634148, 0.08010268147634148, 0.08010268147634148, 0.08987202542825545, 0.08987202542825545, 0.08987202542825545, 0.09082782657155863, 0.09082782657155863, 0.09082782657155863, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04947053302503723, 0.04947053302503723, 0.04947053302503723, 0.026809852690875102, 0.026809852690875102, 0.026809852690875102, 0.0675316219464801, 0.0675316219464801, 0.0675316219464801, 0.008600989675169313, 0.008600989675169313, 0.008600989675169313, 0.01226050568907755, 0.01226050568907755, 0.01226050568907755, 0.004943777113542658, 0.004943777113542658, 0.004943777113542658, 0.07397836540921054, 0.07397836540921054, 0.07397836540921054, 0.07672487098044234, 0.07672487098044234, 0.07672487098044234, 0.07938415534951782, 0.07938415534951782, 0.07938415534951782, 0.37626577839165254, 0.37626577839165254, 0.37626577839165254, 0.38023983131268224, 0.38023983131268224, 0.38023983131268224, 0.3908989888507489, 0.3908989888507489, 0.3908989888507489, 0.08654788680259085, 0.08654788680259085, 0.08654788680259085, 0.06195418983406742, 0.06195418983406742, 0.06195418983406742, 0.08036200046716968, 0.08036200046716968, 0.08036200046716968, 0.1450589726964978, 0.1450589726964978, 0.1450589726964978, 0.13612425986407783, 0.13612425986407783, 0.13612425986407783, 0.1552935572358245, 0.1552935572358245, 0.1552935572358245, 0.20249661005692632, 0.20249661005692632, 0.20249661005692632, 0.2382793089185259, 0.2382793089185259, 0.2382793089185259, 0.27175484803242256, 0.27175484803242256, 0.27175484803242256, 0.1926549798820879, 0.1926549798820879, 0.1926549798820879, 0.1353437197749714, 0.1353437197749714, 0.1353437197749714, 0.17113114680970465, 0.17113114680970465, 0.17113114680970465, 0.1711590068999458, 0.1711590068999458, 0.1711590068999458, 0.1630952979689495, 0.1630952979689495, 0.1630952979689495, 0.19632706441034498, 0.19632706441034498, 0.19632706441034498, 0.1512702604935512, 0.1512702604935512, 0.1512702604935512, 0.1817262633128255, 0.1817262633128255, 0.1817262633128255, 0.15853281859830282, 0.15853281859830282, 0.15853281859830282, 0.18130060932563952, 0.18130060932563952, 0.18130060932563952, 0.5170602888683834, 0.5170602888683834, 0.5170602888683834, 0.23382127477785974, 0.23382127477785974, 0.23382127477785974, 0.15236129383243424, 0.15236129383243424, 0.15236129383243424, 0.526117796169173, 0.526117796169173, 0.526117796169173, 0.17357773354019812, 0.17357773354019812, 0.17357773354019812, 0.17848258036137976, 0.17848258036137976, 0.17848258036137976, 0.17595025711490475, 0.17595025711490475, 0.17595025711490475, 0.21145311530087418, 0.21145311530087418, 0.21145311530087418, 0.06290648594659032, 0.06290648594659032, 0.06290648594659032, 0.05449623845010387, 0.05449623845010387, 0.05449623845010387, 0.06283638360157184, 0.06283638360157184, 0.06283638360157184]}, "mutation_prompt": null}
{"id": "47847297-7751-4ddb-b076-5657b72725d9", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation with dynamic mutation factor\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        # Adaptive alpha for dynamic search balance\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            # Adjust population size based on fitness diversity\n            if np.std(fitness) < 1e-3:  # Population converged\n                self.population_size = max(10, self.population_size - 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Integrate dynamic mutation factor adaptation in Differential Evolution to enhance exploration and exploitation balance.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "97ea3425-00c3-4943-8bf9-f0ec59f7a6a2", "metadata": {"aucs": [0.4319311729983544, 0.4319311729983544, 0.4319311729983544, 0.4215352875259071, 0.4215352875259071, 0.4215352875259071, 0.4164567336260978, 0.4164567336260978, 0.4164567336260978, 0.019014994901096927, 0.019014994901096927, 0.019014994901096927, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09679538625987572, 0.09679538625987572, 0.09679538625987572, 0.10072875938875059, 0.10072875938875059, 0.10072875938875059, 0.12434120990140929, 0.12434120990140929, 0.12434120990140929, 0.07876597807445929, 0.07876597807445929, 0.07876597807445929, 0.08262370896588722, 0.08262370896588722, 0.08262370896588722, 0.04492416725366677, 0.04492416725366677, 0.04492416725366677, 0.7389422307234629, 0.7389422307234629, 0.7389422307234629, 0.7192069597106947, 0.7192069597106947, 0.7192069597106947, 0.7465628589666173, 0.7465628589666173, 0.7465628589666173, 0.2562873902477363, 0.2562873902477363, 0.2562873902477363, 0.27242010339984113, 0.27242010339984113, 0.27242010339984113, 0.2513710550890431, 0.2513710550890431, 0.2513710550890431, 0.4653274609686022, 0.4653274609686022, 0.4653274609686022, 0.16002205773709177, 0.16002205773709177, 0.16002205773709177, 0.15347997963970206, 0.15347997963970206, 0.15347997963970206, 0.11042529597747452, 0.11042529597747452, 0.11042529597747452, 0.15312748257229047, 0.15312748257229047, 0.15312748257229047, 0.13580578631686935, 0.13580578631686935, 0.13580578631686935, 0.08010268147634148, 0.08010268147634148, 0.08010268147634148, 0.08987202542825545, 0.08987202542825545, 0.08987202542825545, 0.09082782657155863, 0.09082782657155863, 0.09082782657155863, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04947053302503723, 0.04947053302503723, 0.04947053302503723, 0.026809852690875102, 0.026809852690875102, 0.026809852690875102, 0.0675316219464801, 0.0675316219464801, 0.0675316219464801, 0.008600989675169313, 0.008600989675169313, 0.008600989675169313, 0.01226050568907755, 0.01226050568907755, 0.01226050568907755, 0.004943777113542658, 0.004943777113542658, 0.004943777113542658, 0.07397836540921054, 0.07397836540921054, 0.07397836540921054, 0.07672487098044234, 0.07672487098044234, 0.07672487098044234, 0.07938415534951782, 0.07938415534951782, 0.07938415534951782, 0.37626577839165254, 0.37626577839165254, 0.37626577839165254, 0.38023983131268224, 0.38023983131268224, 0.38023983131268224, 0.3908989888507489, 0.3908989888507489, 0.3908989888507489, 0.08654788680259085, 0.08654788680259085, 0.08654788680259085, 0.06195418983406742, 0.06195418983406742, 0.06195418983406742, 0.08036200046716968, 0.08036200046716968, 0.08036200046716968, 0.1450589726964978, 0.1450589726964978, 0.1450589726964978, 0.13612425986407783, 0.13612425986407783, 0.13612425986407783, 0.1552935572358245, 0.1552935572358245, 0.1552935572358245, 0.20249661005692632, 0.20249661005692632, 0.20249661005692632, 0.2382793089185259, 0.2382793089185259, 0.2382793089185259, 0.27175484803242256, 0.27175484803242256, 0.27175484803242256, 0.1926549798820879, 0.1926549798820879, 0.1926549798820879, 0.1353437197749714, 0.1353437197749714, 0.1353437197749714, 0.17113114680970465, 0.17113114680970465, 0.17113114680970465, 0.1711590068999458, 0.1711590068999458, 0.1711590068999458, 0.1630952979689495, 0.1630952979689495, 0.1630952979689495, 0.19632706441034498, 0.19632706441034498, 0.19632706441034498, 0.1512702604935512, 0.1512702604935512, 0.1512702604935512, 0.1817262633128255, 0.1817262633128255, 0.1817262633128255, 0.15853281859830282, 0.15853281859830282, 0.15853281859830282, 0.18130060932563952, 0.18130060932563952, 0.18130060932563952, 0.5170602888683834, 0.5170602888683834, 0.5170602888683834, 0.23382127477785974, 0.23382127477785974, 0.23382127477785974, 0.15236129383243424, 0.15236129383243424, 0.15236129383243424, 0.526117796169173, 0.526117796169173, 0.526117796169173, 0.17357773354019812, 0.17357773354019812, 0.17357773354019812, 0.17848258036137976, 0.17848258036137976, 0.17848258036137976, 0.17595025711490475, 0.17595025711490475, 0.17595025711490475, 0.21145311530087418, 0.21145311530087418, 0.21145311530087418, 0.06290648594659032, 0.06290648594659032, 0.06290648594659032, 0.05449623845010387, 0.05449623845010387, 0.05449623845010387, 0.06283638360157184, 0.06283638360157184, 0.06283638360157184]}, "mutation_prompt": null}
{"id": "0520b510-4661-4807-bbdf-02504b5e0f3a", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            # Update crossover rate based on fitness variance\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation with dynamic mutation factor\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover with adaptive crossover rate\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        # Adaptive alpha for dynamic search balance\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            # Adjust population size based on fitness diversity\n            if np.std(fitness) < 1e-3:  # Population converged\n                self.population_size = max(10, self.population_size - 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Enhance convergence by incorporating an adaptive crossover rate based on fitness variance to balance exploration and exploitation.", "configspace": "", "generation": 28, "fitness": 0.18574124444408108, "feedback": "The algorithm HybridDEFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.15.", "error": "", "parent_id": "97ea3425-00c3-4943-8bf9-f0ec59f7a6a2", "metadata": {"aucs": [0.4183535868245727, 0.4183535868245727, 0.4183535868245727, 0.43540809559786353, 0.43540809559786353, 0.43540809559786353, 0.41673559934389437, 0.41673559934389437, 0.41673559934389437, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05507920991965953, 0.05507920991965953, 0.05507920991965953, 0.13113157831097666, 0.13113157831097666, 0.13113157831097666, 0.09402026387822571, 0.09402026387822571, 0.09402026387822571, 0.10383951031519978, 0.10383951031519978, 0.10383951031519978, 0.09647772017078937, 0.09647772017078937, 0.09647772017078937, 0.04351509705185996, 0.04351509705185996, 0.04351509705185996, 0.03879913956562264, 0.03879913956562264, 0.03879913956562264, 0.250602238569553, 0.250602238569553, 0.250602238569553, 0.4389296393017156, 0.4389296393017156, 0.4389296393017156, 0.7315625251173798, 0.7315625251173798, 0.7315625251173798, 0.2617770901761002, 0.2617770901761002, 0.2617770901761002, 0.24852620413936688, 0.24852620413936688, 0.24852620413936688, 0.28516427790921073, 0.28516427790921073, 0.28516427790921073, 0.19603393969272898, 0.19603393969272898, 0.19603393969272898, 0.19505274225663283, 0.19505274225663283, 0.19505274225663283, 0.14352231214436562, 0.14352231214436562, 0.14352231214436562, 0.1481650072359525, 0.1481650072359525, 0.1481650072359525, 0.1001564737819226, 0.1001564737819226, 0.1001564737819226, 0.1342097414372866, 0.1342097414372866, 0.1342097414372866, 0.08016155038080108, 0.08016155038080108, 0.08016155038080108, 0.10247289304837937, 0.10247289304837937, 0.10247289304837937, 0.15180356513533622, 0.15180356513533622, 0.15180356513533622, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011058026426246426, 0.011058026426246426, 0.011058026426246426, 0.064528015383706, 0.064528015383706, 0.064528015383706, 0.04812740878492028, 0.04812740878492028, 0.04812740878492028, 0.07516452941521568, 0.07516452941521568, 0.07516452941521568, 0.02667014894434283, 0.02667014894434283, 0.02667014894434283, 0.007866166277180509, 0.007866166277180509, 0.007866166277180509, 0.013839861798787711, 0.013839861798787711, 0.013839861798787711, 0.10636860526861458, 0.10636860526861458, 0.10636860526861458, 0.10482867394278816, 0.10482867394278816, 0.10482867394278816, 0.11176726320159691, 0.11176726320159691, 0.11176726320159691, 0.4029681542983977, 0.4029681542983977, 0.4029681542983977, 0.400315330547486, 0.400315330547486, 0.400315330547486, 0.38525761656881685, 0.38525761656881685, 0.38525761656881685, 0.11306550230590418, 0.11306550230590418, 0.11306550230590418, 0.055107574270968684, 0.055107574270968684, 0.055107574270968684, 0.061072024999065055, 0.061072024999065055, 0.061072024999065055, 0.13817316002001934, 0.13817316002001934, 0.13817316002001934, 0.16975195245584018, 0.16975195245584018, 0.16975195245584018, 0.15061809668801873, 0.15061809668801873, 0.15061809668801873, 0.28576327048278816, 0.28576327048278816, 0.28576327048278816, 0.2661539866363547, 0.2661539866363547, 0.2661539866363547, 0.20499127345683166, 0.20499127345683166, 0.20499127345683166, 0.1956702980703483, 0.1956702980703483, 0.1956702980703483, 0.13311161051582132, 0.13311161051582132, 0.13311161051582132, 0.17748305368889217, 0.17748305368889217, 0.17748305368889217, 0.1815626507752215, 0.1815626507752215, 0.1815626507752215, 0.18582203525322694, 0.18582203525322694, 0.18582203525322694, 0.176653235964655, 0.176653235964655, 0.176653235964655, 0.17172269841553278, 0.17172269841553278, 0.17172269841553278, 0.19870249769282733, 0.19870249769282733, 0.19870249769282733, 0.16802499144946048, 0.16802499144946048, 0.16802499144946048, 0.45402129611814857, 0.45402129611814857, 0.45402129611814857, 0.17372088797812923, 0.17372088797812923, 0.17372088797812923, 0.5728314811330169, 0.5728314811330169, 0.5728314811330169, 0.48174084539061834, 0.48174084539061834, 0.48174084539061834, 0.4648937917821331, 0.4648937917821331, 0.4648937917821331, 0.3984398711993372, 0.3984398711993372, 0.3984398711993372, 0.1836402145535918, 0.1836402145535918, 0.1836402145535918, 0.17963976882064925, 0.17963976882064925, 0.17963976882064925, 0.18107550637262482, 0.18107550637262482, 0.18107550637262482, 0.0641063584213647, 0.0641063584213647, 0.0641063584213647, 0.06973916907073019, 0.06973916907073019, 0.06973916907073019, 0.055410693828220836, 0.055410693828220836, 0.055410693828220836]}, "mutation_prompt": null}
{"id": "3a5c09ae-6955-4ffc-9444-cfab99775bf1", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            # Update crossover rate based on fitness variance\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation with dynamic mutation factor\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover with adaptive crossover rate\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        adaptive_gamma = self.gamma * (1 - np.tanh((budget_used - self.budget) / self.budget))\n                        beta = np.exp(-adaptive_gamma * r**2)\n                        # Adaptive alpha for dynamic search balance\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            # Adjust population size based on fitness diversity\n            if np.std(fitness) < 1e-3:  # Population converged\n                self.population_size = max(10, self.population_size - 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Introduce adaptive light absorption to enhance convergence speed by adjusting gamma dynamically based on fitness improvement rate.", "configspace": "", "generation": 29, "fitness": 0.17882509601915164, "feedback": "The algorithm HybridDEFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.15.", "error": "", "parent_id": "0520b510-4661-4807-bbdf-02504b5e0f3a", "metadata": {"aucs": [0.4095518665362431, 0.4095518665362431, 0.4095518665362431, 0.4010151225484436, 0.4010151225484436, 0.4010151225484436, 0.4198329924295703, 0.4198329924295703, 0.4198329924295703, 0.022542276540615247, 0.022542276540615247, 0.022542276540615247, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04382595994747629, 0.04382595994747629, 0.04382595994747629, 0.10144839590861177, 0.10144839590861177, 0.10144839590861177, 0.09848085898398751, 0.09848085898398751, 0.09848085898398751, 0.08364473623828705, 0.08364473623828705, 0.08364473623828705, 0.0749619242546059, 0.0749619242546059, 0.0749619242546059, 0.045095111782383124, 0.045095111782383124, 0.045095111782383124, 0.0704358763083821, 0.0704358763083821, 0.0704358763083821, 0.34387963078904815, 0.34387963078904815, 0.34387963078904815, 0.589634544602011, 0.589634544602011, 0.589634544602011, 0.7418230952181808, 0.7418230952181808, 0.7418230952181808, 0.2626810279991848, 0.2626810279991848, 0.2626810279991848, 0.23781123739383037, 0.23781123739383037, 0.23781123739383037, 0.28860012128541923, 0.28860012128541923, 0.28860012128541923, 0.09097682743703772, 0.09097682743703772, 0.09097682743703772, 0.5546395259793383, 0.5546395259793383, 0.5546395259793383, 0.13568441375404894, 0.13568441375404894, 0.13568441375404894, 0.140174566348923, 0.140174566348923, 0.140174566348923, 0.13907008787010455, 0.13907008787010455, 0.13907008787010455, 0.10819450215121673, 0.10819450215121673, 0.10819450215121673, 0.10057670023568721, 0.10057670023568721, 0.10057670023568721, 0.12777537279210738, 0.12777537279210738, 0.12777537279210738, 0.1330114728665549, 0.1330114728665549, 0.1330114728665549, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0006998945081084784, 0.0006998945081084784, 0.0006998945081084784, 0.002492503989564243, 0.002492503989564243, 0.002492503989564243, 0.08478537242500084, 0.08478537242500084, 0.08478537242500084, 0.06690509489901653, 0.06690509489901653, 0.06690509489901653, 0.10234667656098939, 0.10234667656098939, 0.10234667656098939, 0.00623832587967299, 0.00623832587967299, 0.00623832587967299, 0.010405256037973598, 0.010405256037973598, 0.010405256037973598, 0.013102272321896424, 0.013102272321896424, 0.013102272321896424, 0.07051155088306371, 0.07051155088306371, 0.07051155088306371, 0.09644472394266501, 0.09644472394266501, 0.09644472394266501, 0.06532712457119139, 0.06532712457119139, 0.06532712457119139, 0.4048634420071898, 0.4048634420071898, 0.4048634420071898, 0.3825859703061708, 0.3825859703061708, 0.3825859703061708, 0.3738215819615852, 0.3738215819615852, 0.3738215819615852, 0.08674410962998613, 0.08674410962998613, 0.08674410962998613, 0.08669163189153894, 0.08669163189153894, 0.08669163189153894, 0.055509995000500245, 0.055509995000500245, 0.055509995000500245, 0.17312473156559116, 0.17312473156559116, 0.17312473156559116, 0.1529619963892479, 0.1529619963892479, 0.1529619963892479, 0.17553343689542578, 0.17553343689542578, 0.17553343689542578, 0.19186711074279073, 0.19186711074279073, 0.19186711074279073, 0.2653560797545178, 0.2653560797545178, 0.2653560797545178, 0.29150870005858753, 0.29150870005858753, 0.29150870005858753, 0.19284687779519527, 0.19284687779519527, 0.19284687779519527, 0.17228299160776173, 0.17228299160776173, 0.17228299160776173, 0.16999247838501685, 0.16999247838501685, 0.16999247838501685, 0.17689657906908907, 0.17689657906908907, 0.17689657906908907, 0.18779365761319555, 0.18779365761319555, 0.18779365761319555, 0.21190815742861457, 0.21190815742861457, 0.21190815742861457, 0.17746016199664205, 0.17746016199664205, 0.17746016199664205, 0.19253305234614015, 0.19253305234614015, 0.19253305234614015, 0.16889367665304944, 0.16889367665304944, 0.16889367665304944, 0.17448257065219663, 0.17448257065219663, 0.17448257065219663, 0.17222671199691886, 0.17222671199691886, 0.17222671199691886, 0.4911897553845188, 0.4911897553845188, 0.4911897553845188, 0.14557276194494184, 0.14557276194494184, 0.14557276194494184, 0.3962417515454726, 0.3962417515454726, 0.3962417515454726, 0.17889976661584184, 0.17889976661584184, 0.17889976661584184, 0.1786324669358108, 0.1786324669358108, 0.1786324669358108, 0.18933025118459335, 0.18933025118459335, 0.18933025118459335, 0.19078358614484403, 0.19078358614484403, 0.19078358614484403, 0.060799407553992935, 0.060799407553992935, 0.060799407553992935, 0.05737794553517506, 0.05737794553517506, 0.05737794553517506, 0.06386647456633432, 0.06386647456633432, 0.06386647456633432]}, "mutation_prompt": null}
{"id": "9ac96bc1-2f3f-402a-82ad-bbc001cade85", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            # Update crossover rate based on fitness variance\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation with dynamic mutation factor\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover with adaptive crossover rate\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        # Adaptive alpha for dynamic search balance\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        improvement = (fitness[i] - fitness[j]) / (1 + abs(fitness[i] - fitness[j]))  # Dynamic learning rate\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * improvement * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            # Adjust population size based on fitness diversity\n            if np.std(fitness) < 1e-3:  # Population converged\n                self.population_size = max(10, self.population_size - 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Improve convergence speed by introducing a dynamic learning rate in the Firefly component based on fitness improvement.", "configspace": "", "generation": 30, "fitness": 0.1236178845835657, "feedback": "The algorithm HybridDEFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.07.", "error": "", "parent_id": "0520b510-4661-4807-bbdf-02504b5e0f3a", "metadata": {"aucs": [0.18931666126215807, 0.18931666126215807, 0.18931666126215807, 0.17226456287930503, 0.17226456287930503, 0.17226456287930503, 0.1569189529243007, 0.1569189529243007, 0.1569189529243007, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02123495484612503, 0.02123495484612503, 0.02123495484612503, 0.10854809794719145, 0.10854809794719145, 0.10854809794719145, 0.08475215901904198, 0.08475215901904198, 0.08475215901904198, 0.09072041979769707, 0.09072041979769707, 0.09072041979769707, 0.07859241854837984, 0.07859241854837984, 0.07859241854837984, 0.031518119557106594, 0.031518119557106594, 0.031518119557106594, 0.057197093137338895, 0.057197093137338895, 0.057197093137338895, 0.07686545673424638, 0.07686545673424638, 0.07686545673424638, 0.08907537396212883, 0.08907537396212883, 0.08907537396212883, 0.10942709047205157, 0.10942709047205157, 0.10942709047205157, 0.06857086092372389, 0.06857086092372389, 0.06857086092372389, 0.0485243024411498, 0.0485243024411498, 0.0485243024411498, 0.07833438669198711, 0.07833438669198711, 0.07833438669198711, 0.1769478621771594, 0.1769478621771594, 0.1769478621771594, 0.17945350595685994, 0.17945350595685994, 0.17945350595685994, 0.2437386373859597, 0.2437386373859597, 0.2437386373859597, 0.10811913975552956, 0.10811913975552956, 0.10811913975552956, 0.13924498622479964, 0.13924498622479964, 0.13924498622479964, 0.10562357014111079, 0.10562357014111079, 0.10562357014111079, 0.10155151592812872, 0.10155151592812872, 0.10155151592812872, 0.23632563981804777, 0.23632563981804777, 0.23632563981804777, 0.10727750952029202, 0.10727750952029202, 0.10727750952029202, 0.03934943697291382, 0.03934943697291382, 0.03934943697291382, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.001057100537143918, 0.001057100537143918, 0.001057100537143918, 0.08019155499524255, 0.08019155499524255, 0.08019155499524255, 0.045758508180651414, 0.045758508180651414, 0.045758508180651414, 0.0941524608429376, 0.0941524608429376, 0.0941524608429376, 0.008257179838895845, 0.008257179838895845, 0.008257179838895845, 0.015200419509958207, 0.015200419509958207, 0.015200419509958207, 0.019956635892457553, 0.019956635892457553, 0.019956635892457553, 0.05216134747106793, 0.05216134747106793, 0.05216134747106793, 0.13711287260894567, 0.13711287260894567, 0.13711287260894567, 0.09444656063183643, 0.09444656063183643, 0.09444656063183643, 0.24964567860098874, 0.24964567860098874, 0.24964567860098874, 0.20113192760066156, 0.20113192760066156, 0.20113192760066156, 0.20547224770237937, 0.20547224770237937, 0.20547224770237937, 0.09249436049094073, 0.09249436049094073, 0.09249436049094073, 0.11260980296331469, 0.11260980296331469, 0.11260980296331469, 0.06115387612640988, 0.06115387612640988, 0.06115387612640988, 0.11316019451335757, 0.11316019451335757, 0.11316019451335757, 0.14072818844360913, 0.14072818844360913, 0.14072818844360913, 0.1278400168162378, 0.1278400168162378, 0.1278400168162378, 0.17611428154635866, 0.17611428154635866, 0.17611428154635866, 0.15781223865340088, 0.15781223865340088, 0.15781223865340088, 0.16053026391899472, 0.16053026391899472, 0.16053026391899472, 0.18665113646346287, 0.18665113646346287, 0.18665113646346287, 0.17719017393467074, 0.17719017393467074, 0.17719017393467074, 0.20808243806524995, 0.20808243806524995, 0.20808243806524995, 0.18841355977989727, 0.18841355977989727, 0.18841355977989727, 0.19494549351775736, 0.19494549351775736, 0.19494549351775736, 0.18658006944790118, 0.18658006944790118, 0.18658006944790118, 0.1446846260833181, 0.1446846260833181, 0.1446846260833181, 0.1859514075402291, 0.1859514075402291, 0.1859514075402291, 0.15999913003267052, 0.15999913003267052, 0.15999913003267052, 0.1836140437659426, 0.1836140437659426, 0.1836140437659426, 0.16466936130928045, 0.16466936130928045, 0.16466936130928045, 0.34610658705412345, 0.34610658705412345, 0.34610658705412345, 0.14863111218121428, 0.14863111218121428, 0.14863111218121428, 0.2054174910874853, 0.2054174910874853, 0.2054174910874853, 0.16814641790346707, 0.16814641790346707, 0.16814641790346707, 0.18285996673958738, 0.18285996673958738, 0.18285996673958738, 0.18117826957105565, 0.18117826957105565, 0.18117826957105565, 0.20853205317951096, 0.20853205317951096, 0.20853205317951096, 0.07797229436162689, 0.07797229436162689, 0.07797229436162689, 0.07681255976218004, 0.07681255976218004, 0.07681255976218004, 0.07726906532557387, 0.07726906532557387, 0.07726906532557387]}, "mutation_prompt": null}
{"id": "e46c9b67-ff8a-427e-8f40-9cb35179604d", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n        self.success_history = []\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            # Update crossover rate based on fitness variance\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation with dynamic mutation factor\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:  # Adapt mutation factor based on success history\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover with adaptive crossover rate\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(0.1)  # Record success\n                else:\n                    self.success_history.append(-0.1)\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        # Adaptive alpha for dynamic search balance\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            # Adjust population size based on fitness diversity\n            if np.std(fitness) < 1e-3:  # Population converged\n                self.population_size = max(10, self.population_size - 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Introduce a mutation strategy based on success history to improve adaptability and ensure robust exploration.", "configspace": "", "generation": 31, "fitness": 0.1881228074235016, "feedback": "The algorithm HybridDEFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.17.", "error": "", "parent_id": "0520b510-4661-4807-bbdf-02504b5e0f3a", "metadata": {"aucs": [0.4418200410432245, 0.4418200410432245, 0.4418200410432245, 0.4217665546150817, 0.4217665546150817, 0.4217665546150817, 0.40527422068216257, 0.40527422068216257, 0.40527422068216257, 0.028532069031713347, 0.028532069031713347, 0.028532069031713347, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.039531225577675855, 0.039531225577675855, 0.039531225577675855, 0.08728454753950332, 0.08728454753950332, 0.08728454753950332, 0.09693725270102782, 0.09693725270102782, 0.09693725270102782, 0.09158762346257643, 0.09158762346257643, 0.09158762346257643, 0.07735024182410433, 0.07735024182410433, 0.07735024182410433, 0.08678547212285903, 0.08678547212285903, 0.08678547212285903, 0.08028430275436571, 0.08028430275436571, 0.08028430275436571, 0.6820988542308967, 0.6820988542308967, 0.6820988542308967, 0.6805424781973158, 0.6805424781973158, 0.6805424781973158, 0.7302517078985535, 0.7302517078985535, 0.7302517078985535, 0.26718795392276384, 0.26718795392276384, 0.26718795392276384, 0.26323878233985554, 0.26323878233985554, 0.26323878233985554, 0.2919722914049717, 0.2919722914049717, 0.2919722914049717, 0.12471594910095285, 0.12471594910095285, 0.12471594910095285, 0.46105336991312085, 0.46105336991312085, 0.46105336991312085, 0.10151175916995925, 0.10151175916995925, 0.10151175916995925, 0.10891778964255305, 0.10891778964255305, 0.10891778964255305, 0.14973758113973146, 0.14973758113973146, 0.14973758113973146, 0.10566033461483271, 0.10566033461483271, 0.10566033461483271, 0.12513329913438098, 0.12513329913438098, 0.12513329913438098, 0.15754966202884968, 0.15754966202884968, 0.15754966202884968, 0.16043621789362728, 0.16043621789362728, 0.16043621789362728, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012541357940420883, 0.012541357940420883, 0.012541357940420883, 0.013690220610890869, 0.013690220610890869, 0.013690220610890869, 0.06820595477458924, 0.06820595477458924, 0.06820595477458924, 0.04969733430862633, 0.04969733430862633, 0.04969733430862633, 0.0785298959601125, 0.0785298959601125, 0.0785298959601125, 0.015342070101057259, 0.015342070101057259, 0.015342070101057259, 0.010950636064003483, 0.010950636064003483, 0.010950636064003483, 0.008178122179740455, 0.008178122179740455, 0.008178122179740455, 0.03777108429549847, 0.03777108429549847, 0.03777108429549847, 0.08348823266928507, 0.08348823266928507, 0.08348823266928507, 0.07365795331362956, 0.07365795331362956, 0.07365795331362956, 0.3864751860311392, 0.3864751860311392, 0.3864751860311392, 0.38403496823851235, 0.38403496823851235, 0.38403496823851235, 0.3660060262339697, 0.3660060262339697, 0.3660060262339697, 0.09308243037701214, 0.09308243037701214, 0.09308243037701214, 0.089609468573836, 0.089609468573836, 0.089609468573836, 0.0629427839085609, 0.0629427839085609, 0.0629427839085609, 0.14158291724646932, 0.14158291724646932, 0.14158291724646932, 0.18094916192793098, 0.18094916192793098, 0.18094916192793098, 0.15904977865468461, 0.15904977865468461, 0.15904977865468461, 0.2182021300876299, 0.2182021300876299, 0.2182021300876299, 0.16708509824611484, 0.16708509824611484, 0.16708509824611484, 0.2672056234088729, 0.2672056234088729, 0.2672056234088729, 0.16194424212444536, 0.16194424212444536, 0.16194424212444536, 0.1462426800787514, 0.1462426800787514, 0.1462426800787514, 0.10727393109062344, 0.10727393109062344, 0.10727393109062344, 0.18917481593134466, 0.18917481593134466, 0.18917481593134466, 0.1755590450393174, 0.1755590450393174, 0.1755590450393174, 0.19145722365842843, 0.19145722365842843, 0.19145722365842843, 0.16768736809447804, 0.16768736809447804, 0.16768736809447804, 0.17468121819179905, 0.17468121819179905, 0.17468121819179905, 0.1501349250146854, 0.1501349250146854, 0.1501349250146854, 0.6163075971032527, 0.6163075971032527, 0.6163075971032527, 0.17337638462382254, 0.17337638462382254, 0.17337638462382254, 0.5817286651398476, 0.5817286651398476, 0.5817286651398476, 0.14176045177026864, 0.14176045177026864, 0.14176045177026864, 0.3449081489230035, 0.3449081489230035, 0.3449081489230035, 0.19718409031201334, 0.19718409031201334, 0.19718409031201334, 0.1919284319723954, 0.1919284319723954, 0.1919284319723954, 0.19137252970873653, 0.19137252970873653, 0.19137252970873653, 0.1832689920511058, 0.1832689920511058, 0.1832689920511058, 0.07489947165618638, 0.07489947165618638, 0.07489947165618638, 0.08116966741223719, 0.08116966741223719, 0.08116966741223719, 0.06714223745612558, 0.06714223745612558, 0.06714223745612558]}, "mutation_prompt": null}
{"id": "e09c9f65-656c-4290-a89b-bed98f1994f5", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n        self.success_history = []\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            # Update crossover rate based on fitness variance\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation with dynamic mutation factor\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:  # Adapt mutation factor based on success history\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n                \n                # Adjust mutation factor based on rank\n                rank = np.argsort(fitness)[i]\n                dynamic_mutation_factor *= 1 + (rank / self.population_size)\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover with adaptive crossover rate\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(0.1)  # Record success\n                else:\n                    self.success_history.append(-0.1)\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        # Adaptive alpha for dynamic search balance\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            # Adjust population size based on fitness diversity\n            if np.std(fitness) < 1e-3:  # Population converged\n                self.population_size = max(10, self.population_size - 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Improve exploration by dynamically adjusting the mutation factor based on current fitness rank.", "configspace": "", "generation": 32, "fitness": 0.17508301355289882, "feedback": "The algorithm HybridDEFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.16.", "error": "", "parent_id": "e46c9b67-ff8a-427e-8f40-9cb35179604d", "metadata": {"aucs": [0.4220758049266873, 0.4220758049266873, 0.4220758049266873, 0.38913688838730764, 0.38913688838730764, 0.38913688838730764, 0.40232421164998045, 0.40232421164998045, 0.40232421164998045, 0.0035130901741459164, 0.0035130901741459164, 0.0035130901741459164, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09280032493571766, 0.09280032493571766, 0.09280032493571766, 0.05574445340093148, 0.05574445340093148, 0.05574445340093148, 0.08639817341428002, 0.08639817341428002, 0.08639817341428002, 0.060140847485681825, 0.060140847485681825, 0.060140847485681825, 0.07694681999511599, 0.07694681999511599, 0.07694681999511599, 0.0763815943837286, 0.0763815943837286, 0.0763815943837286, 0.47943157716615736, 0.47943157716615736, 0.47943157716615736, 0.8569592534151743, 0.8569592534151743, 0.8569592534151743, 0.808118705485471, 0.808118705485471, 0.808118705485471, 0.26135628934057886, 0.26135628934057886, 0.26135628934057886, 0.2563145086837709, 0.2563145086837709, 0.2563145086837709, 0.28671639670120763, 0.28671639670120763, 0.28671639670120763, 0.1375585308540661, 0.1375585308540661, 0.1375585308540661, 0.20098715587913396, 0.20098715587913396, 0.20098715587913396, 0.09401798913843051, 0.09401798913843051, 0.09401798913843051, 0.14725290358237175, 0.14725290358237175, 0.14725290358237175, 0.10544339441335449, 0.10544339441335449, 0.10544339441335449, 0.1620820430448785, 0.1620820430448785, 0.1620820430448785, 0.15322972177649985, 0.15322972177649985, 0.15322972177649985, 0.11898228168479486, 0.11898228168479486, 0.11898228168479486, 0.13473112490265016, 0.13473112490265016, 0.13473112490265016, 0.004450083568366403, 0.004450083568366403, 0.004450083568366403, 0.0004016313590070597, 0.0004016313590070597, 0.0004016313590070597, 0.00011082284588337377, 0.00011082284588337377, 0.00011082284588337377, 0.1160566703911502, 0.1160566703911502, 0.1160566703911502, 0.048445530529171776, 0.048445530529171776, 0.048445530529171776, 0.07272884289125325, 0.07272884289125325, 0.07272884289125325, 0.002535418303453829, 0.002535418303453829, 0.002535418303453829, 0.007518732146738705, 0.007518732146738705, 0.007518732146738705, 0.00665097359173672, 0.00665097359173672, 0.00665097359173672, 0.04841798580547041, 0.04841798580547041, 0.04841798580547041, 0.044077956483460023, 0.044077956483460023, 0.044077956483460023, 0.09841893367120935, 0.09841893367120935, 0.09841893367120935, 0.3924228417773833, 0.3924228417773833, 0.3924228417773833, 0.35907229014511755, 0.35907229014511755, 0.35907229014511755, 0.361618266975261, 0.361618266975261, 0.361618266975261, 0.11430006624508748, 0.11430006624508748, 0.11430006624508748, 0.06168479901562218, 0.06168479901562218, 0.06168479901562218, 0.10256765228151676, 0.10256765228151676, 0.10256765228151676, 0.15608669093618532, 0.15608669093618532, 0.15608669093618532, 0.14082650328219748, 0.14082650328219748, 0.14082650328219748, 0.15589997679051903, 0.15589997679051903, 0.15589997679051903, 0.27323855206890735, 0.27323855206890735, 0.27323855206890735, 0.17963013372971726, 0.17963013372971726, 0.17963013372971726, 0.1889609330643265, 0.1889609330643265, 0.1889609330643265, 0.18536311034112474, 0.18536311034112474, 0.18536311034112474, 0.11733063581617242, 0.11733063581617242, 0.11733063581617242, 0.13178795287913303, 0.13178795287913303, 0.13178795287913303, 0.16739648351264436, 0.16739648351264436, 0.16739648351264436, 0.19178810453703388, 0.19178810453703388, 0.19178810453703388, 0.189906587297209, 0.189906587297209, 0.189906587297209, 0.19452453816119886, 0.19452453816119886, 0.19452453816119886, 0.18210941217502785, 0.18210941217502785, 0.18210941217502785, 0.1733701258615996, 0.1733701258615996, 0.1733701258615996, 0.5135346083380422, 0.5135346083380422, 0.5135346083380422, 0.17084378714026238, 0.17084378714026238, 0.17084378714026238, 0.18488986807255203, 0.18488986807255203, 0.18488986807255203, 0.1421870343051691, 0.1421870343051691, 0.1421870343051691, 0.2965747309406176, 0.2965747309406176, 0.2965747309406176, 0.19029783361685526, 0.19029783361685526, 0.19029783361685526, 0.19826822400496502, 0.19826822400496502, 0.19826822400496502, 0.1878449365864382, 0.1878449365864382, 0.1878449365864382, 0.2060767025231759, 0.2060767025231759, 0.2060767025231759, 0.053542272441622685, 0.053542272441622685, 0.053542272441622685, 0.06157336522879375, 0.06157336522879375, 0.06157336522879375, 0.06180028930821824, 0.06180028930821824, 0.06180028930821824]}, "mutation_prompt": null}
{"id": "819d0442-ea1b-412e-bf6f-1a4235ca7d39", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n        self.success_history = []\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            # Update crossover rate based on fitness variance\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation with dynamic mutation factor\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:  # Adapt mutation factor based on success history\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                # Utilize best solution in mutation strategy for improved convergence\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c] + best_solution - population[i]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover with adaptive crossover rate\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(0.1)  # Record success\n                else:\n                    self.success_history.append(-0.1)\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        # Adaptive alpha for dynamic search balance\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            # Adjust population size based on fitness diversity\n            if np.std(fitness) < 1e-3:  # Population converged\n                self.population_size = max(10, self.population_size - 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Adjust the mutation strategy to utilize the best solution found for improved convergence.", "configspace": "", "generation": 33, "fitness": 0.18475249333316282, "feedback": "The algorithm HybridDEFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": "e46c9b67-ff8a-427e-8f40-9cb35179604d", "metadata": {"aucs": [0.41727161747155284, 0.41727161747155284, 0.41727161747155284, 0.4116445630389063, 0.4116445630389063, 0.4116445630389063, 0.4172635630430326, 0.4172635630430326, 0.4172635630430326, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010611111818022656, 0.010611111818022656, 0.010611111818022656, 0.09134966680764334, 0.09134966680764334, 0.09134966680764334, 0.08448211734405775, 0.08448211734405775, 0.08448211734405775, 0.10221699537942874, 0.10221699537942874, 0.10221699537942874, 0.04049930785785616, 0.04049930785785616, 0.04049930785785616, 0.09664389936137574, 0.09664389936137574, 0.09664389936137574, 0.060904329702619164, 0.060904329702619164, 0.060904329702619164, 0.8525498908660069, 0.8525498908660069, 0.8525498908660069, 0.8720657559104728, 0.8720657559104728, 0.8720657559104728, 0.8842737413344572, 0.8842737413344572, 0.8842737413344572, 0.2562190631220894, 0.2562190631220894, 0.2562190631220894, 0.24385092209628634, 0.24385092209628634, 0.24385092209628634, 0.25118367341727177, 0.25118367341727177, 0.25118367341727177, 0.08909584679206195, 0.08909584679206195, 0.08909584679206195, 0.5356319738356264, 0.5356319738356264, 0.5356319738356264, 0.45930873247392523, 0.45930873247392523, 0.45930873247392523, 0.10833723561534392, 0.10833723561534392, 0.10833723561534392, 0.1420216658948702, 0.1420216658948702, 0.1420216658948702, 0.1617510706030333, 0.1617510706030333, 0.1617510706030333, 0.148524506279752, 0.148524506279752, 0.148524506279752, 0.06612566255309282, 0.06612566255309282, 0.06612566255309282, 0.12472427184777302, 0.12472427184777302, 0.12472427184777302, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020397972448665147, 0.020397972448665147, 0.020397972448665147, 0.0871775495425613, 0.0871775495425613, 0.0871775495425613, 0.08624789482359774, 0.08624789482359774, 0.08624789482359774, 0.07619540852618789, 0.07619540852618789, 0.07619540852618789, 0.002926422098686432, 0.002926422098686432, 0.002926422098686432, 0.006696595801561678, 0.006696595801561678, 0.006696595801561678, 0.005416581766930717, 0.005416581766930717, 0.005416581766930717, 0.06510956526153877, 0.06510956526153877, 0.06510956526153877, 0.07950438520231451, 0.07950438520231451, 0.07950438520231451, 0.11727445234558731, 0.11727445234558731, 0.11727445234558731, 0.4099641325471741, 0.4099641325471741, 0.4099641325471741, 0.3893349367952724, 0.3893349367952724, 0.3893349367952724, 0.35884752726970814, 0.35884752726970814, 0.35884752726970814, 0.09826945353392091, 0.09826945353392091, 0.09826945353392091, 0.07376165574149651, 0.07376165574149651, 0.07376165574149651, 0.0799385640431326, 0.0799385640431326, 0.0799385640431326, 0.12616067319113988, 0.12616067319113988, 0.12616067319113988, 0.13145515337187152, 0.13145515337187152, 0.13145515337187152, 0.14332934405544806, 0.14332934405544806, 0.14332934405544806, 0.2569205364281324, 0.2569205364281324, 0.2569205364281324, 0.1871522103394203, 0.1871522103394203, 0.1871522103394203, 0.1960469604463827, 0.1960469604463827, 0.1960469604463827, 0.21108639685600528, 0.21108639685600528, 0.21108639685600528, 0.14751683513455316, 0.14751683513455316, 0.14751683513455316, 0.19151432488993192, 0.19151432488993192, 0.19151432488993192, 0.1657149111387367, 0.1657149111387367, 0.1657149111387367, 0.16412568247132708, 0.16412568247132708, 0.16412568247132708, 0.16906339120516, 0.16906339120516, 0.16906339120516, 0.15169226372613231, 0.15169226372613231, 0.15169226372613231, 0.15941543508665423, 0.15941543508665423, 0.15941543508665423, 0.16749283901741185, 0.16749283901741185, 0.16749283901741185, 0.22447831241799554, 0.22447831241799554, 0.22447831241799554, 0.16221791095947735, 0.16221791095947735, 0.16221791095947735, 0.16258975178202706, 0.16258975178202706, 0.16258975178202706, 0.16098156735613356, 0.16098156735613356, 0.16098156735613356, 0.17844074013948052, 0.17844074013948052, 0.17844074013948052, 0.19253759890212085, 0.19253759890212085, 0.19253759890212085, 0.1928033093208832, 0.1928033093208832, 0.1928033093208832, 0.18487265850266388, 0.18487265850266388, 0.18487265850266388, 0.17869278110435238, 0.17869278110435238, 0.17869278110435238, 0.06378727119236405, 0.06378727119236405, 0.06378727119236405, 0.07259749547154037, 0.07259749547154037, 0.07259749547154037, 0.07347888326548324, 0.07347888326548324, 0.07347888326548324]}, "mutation_prompt": null}
{"id": "fb37f6aa-75c2-4ad4-a876-94d93cb39575", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n        self.success_history = []\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Introduce a dynamic boundary scaling factor\n        scaling_factor = 1.0 + 0.1 * np.sin(budget_used / self.budget * np.pi)\n        \n        # Initialize population with scaling factor\n        population = np.random.uniform(self.lower_bound * scaling_factor, \n                                       self.upper_bound * scaling_factor, \n                                       (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            # Update crossover rate based on fitness variance\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation with dynamic mutation factor\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:  # Adapt mutation factor based on success history\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover with adaptive crossover rate\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(0.1)  # Record success\n                else:\n                    self.success_history.append(-0.1)\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        # Adaptive alpha for dynamic search balance\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            # Adjust population size based on fitness diversity\n            if np.std(fitness) < 1e-3:  # Population converged\n                self.population_size = max(10, self.population_size - 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Enhance exploration by introducing a dynamic boundary scaling factor influencing population initialization and mutation.", "configspace": "", "generation": 34, "fitness": 0.1881228074235016, "feedback": "The algorithm HybridDEFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.17.", "error": "", "parent_id": "e46c9b67-ff8a-427e-8f40-9cb35179604d", "metadata": {"aucs": [0.4418200410432245, 0.4418200410432245, 0.4418200410432245, 0.4217665546150817, 0.4217665546150817, 0.4217665546150817, 0.40527422068216257, 0.40527422068216257, 0.40527422068216257, 0.028532069031713347, 0.028532069031713347, 0.028532069031713347, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.039531225577675855, 0.039531225577675855, 0.039531225577675855, 0.08728454753950332, 0.08728454753950332, 0.08728454753950332, 0.09693725270102782, 0.09693725270102782, 0.09693725270102782, 0.09158762346257643, 0.09158762346257643, 0.09158762346257643, 0.07735024182410433, 0.07735024182410433, 0.07735024182410433, 0.08678547212285903, 0.08678547212285903, 0.08678547212285903, 0.08028430275436571, 0.08028430275436571, 0.08028430275436571, 0.6820988542308967, 0.6820988542308967, 0.6820988542308967, 0.6805424781973158, 0.6805424781973158, 0.6805424781973158, 0.7302517078985535, 0.7302517078985535, 0.7302517078985535, 0.26718795392276384, 0.26718795392276384, 0.26718795392276384, 0.26323878233985554, 0.26323878233985554, 0.26323878233985554, 0.2919722914049717, 0.2919722914049717, 0.2919722914049717, 0.12471594910095285, 0.12471594910095285, 0.12471594910095285, 0.46105336991312085, 0.46105336991312085, 0.46105336991312085, 0.10151175916995925, 0.10151175916995925, 0.10151175916995925, 0.10891778964255305, 0.10891778964255305, 0.10891778964255305, 0.14973758113973146, 0.14973758113973146, 0.14973758113973146, 0.10566033461483271, 0.10566033461483271, 0.10566033461483271, 0.12513329913438098, 0.12513329913438098, 0.12513329913438098, 0.15754966202884968, 0.15754966202884968, 0.15754966202884968, 0.16043621789362728, 0.16043621789362728, 0.16043621789362728, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012541357940420883, 0.012541357940420883, 0.012541357940420883, 0.013690220610890869, 0.013690220610890869, 0.013690220610890869, 0.06820595477458924, 0.06820595477458924, 0.06820595477458924, 0.04969733430862633, 0.04969733430862633, 0.04969733430862633, 0.0785298959601125, 0.0785298959601125, 0.0785298959601125, 0.015342070101057259, 0.015342070101057259, 0.015342070101057259, 0.010950636064003483, 0.010950636064003483, 0.010950636064003483, 0.008178122179740455, 0.008178122179740455, 0.008178122179740455, 0.03777108429549847, 0.03777108429549847, 0.03777108429549847, 0.08348823266928507, 0.08348823266928507, 0.08348823266928507, 0.07365795331362956, 0.07365795331362956, 0.07365795331362956, 0.3864751860311392, 0.3864751860311392, 0.3864751860311392, 0.38403496823851235, 0.38403496823851235, 0.38403496823851235, 0.3660060262339697, 0.3660060262339697, 0.3660060262339697, 0.09308243037701214, 0.09308243037701214, 0.09308243037701214, 0.089609468573836, 0.089609468573836, 0.089609468573836, 0.0629427839085609, 0.0629427839085609, 0.0629427839085609, 0.14158291724646932, 0.14158291724646932, 0.14158291724646932, 0.18094916192793098, 0.18094916192793098, 0.18094916192793098, 0.15904977865468461, 0.15904977865468461, 0.15904977865468461, 0.2182021300876299, 0.2182021300876299, 0.2182021300876299, 0.16708509824611484, 0.16708509824611484, 0.16708509824611484, 0.2672056234088729, 0.2672056234088729, 0.2672056234088729, 0.16194424212444536, 0.16194424212444536, 0.16194424212444536, 0.1462426800787514, 0.1462426800787514, 0.1462426800787514, 0.10727393109062344, 0.10727393109062344, 0.10727393109062344, 0.18917481593134466, 0.18917481593134466, 0.18917481593134466, 0.1755590450393174, 0.1755590450393174, 0.1755590450393174, 0.19145722365842843, 0.19145722365842843, 0.19145722365842843, 0.16768736809447804, 0.16768736809447804, 0.16768736809447804, 0.17468121819179905, 0.17468121819179905, 0.17468121819179905, 0.1501349250146854, 0.1501349250146854, 0.1501349250146854, 0.6163075971032527, 0.6163075971032527, 0.6163075971032527, 0.17337638462382254, 0.17337638462382254, 0.17337638462382254, 0.5817286651398476, 0.5817286651398476, 0.5817286651398476, 0.14176045177026864, 0.14176045177026864, 0.14176045177026864, 0.3449081489230035, 0.3449081489230035, 0.3449081489230035, 0.19718409031201334, 0.19718409031201334, 0.19718409031201334, 0.1919284319723954, 0.1919284319723954, 0.1919284319723954, 0.19137252970873653, 0.19137252970873653, 0.19137252970873653, 0.1832689920511058, 0.1832689920511058, 0.1832689920511058, 0.07489947165618638, 0.07489947165618638, 0.07489947165618638, 0.08116966741223719, 0.08116966741223719, 0.08116966741223719, 0.06714223745612558, 0.06714223745612558, 0.06714223745612558]}, "mutation_prompt": null}
{"id": "724c1f2d-a4ec-40b9-b0d9-2973985cfe0c", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n        self.success_history = []\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            # Update crossover rate based on fitness variance\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation with dynamic mutation factor\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:  # Adapt mutation factor based on success history\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover with adaptive crossover rate\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(0.1)  # Record success\n                else:\n                    self.success_history.append(-0.1)\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        # Adaptive alpha for dynamic search balance\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            # Adjust population size based on fitness diversity\n            if np.std(fitness) < 1e-3:  # Population converged\n                self.population_size = max(10, self.population_size - 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Introduce a mutation strategy based on success history to improve adaptability and ensure robust exploration.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e46c9b67-ff8a-427e-8f40-9cb35179604d", "metadata": {"aucs": [0.4418200410432245, 0.4418200410432245, 0.4418200410432245, 0.4217665546150817, 0.4217665546150817, 0.4217665546150817, 0.40527422068216257, 0.40527422068216257, 0.40527422068216257, 0.028532069031713347, 0.028532069031713347, 0.028532069031713347, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.039531225577675855, 0.039531225577675855, 0.039531225577675855, 0.08728454753950332, 0.08728454753950332, 0.08728454753950332, 0.09693725270102782, 0.09693725270102782, 0.09693725270102782, 0.09158762346257643, 0.09158762346257643, 0.09158762346257643, 0.07735024182410433, 0.07735024182410433, 0.07735024182410433, 0.08678547212285903, 0.08678547212285903, 0.08678547212285903, 0.08028430275436571, 0.08028430275436571, 0.08028430275436571, 0.6820988542308967, 0.6820988542308967, 0.6820988542308967, 0.6805424781973158, 0.6805424781973158, 0.6805424781973158, 0.7302517078985535, 0.7302517078985535, 0.7302517078985535, 0.26718795392276384, 0.26718795392276384, 0.26718795392276384, 0.26323878233985554, 0.26323878233985554, 0.26323878233985554, 0.2919722914049717, 0.2919722914049717, 0.2919722914049717, 0.12471594910095285, 0.12471594910095285, 0.12471594910095285, 0.46105336991312085, 0.46105336991312085, 0.46105336991312085, 0.10151175916995925, 0.10151175916995925, 0.10151175916995925, 0.10891778964255305, 0.10891778964255305, 0.10891778964255305, 0.14973758113973146, 0.14973758113973146, 0.14973758113973146, 0.10566033461483271, 0.10566033461483271, 0.10566033461483271, 0.12513329913438098, 0.12513329913438098, 0.12513329913438098, 0.15754966202884968, 0.15754966202884968, 0.15754966202884968, 0.16043621789362728, 0.16043621789362728, 0.16043621789362728, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012541357940420883, 0.012541357940420883, 0.012541357940420883, 0.013690220610890869, 0.013690220610890869, 0.013690220610890869, 0.06820595477458924, 0.06820595477458924, 0.06820595477458924, 0.04969733430862633, 0.04969733430862633, 0.04969733430862633, 0.0785298959601125, 0.0785298959601125, 0.0785298959601125, 0.015342070101057259, 0.015342070101057259, 0.015342070101057259, 0.010950636064003483, 0.010950636064003483, 0.010950636064003483, 0.008178122179740455, 0.008178122179740455, 0.008178122179740455, 0.03777108429549847, 0.03777108429549847, 0.03777108429549847, 0.08348823266928507, 0.08348823266928507, 0.08348823266928507, 0.07365795331362956, 0.07365795331362956, 0.07365795331362956, 0.3864751860311392, 0.3864751860311392, 0.3864751860311392, 0.38403496823851235, 0.38403496823851235, 0.38403496823851235, 0.3660060262339697, 0.3660060262339697, 0.3660060262339697, 0.09308243037701214, 0.09308243037701214, 0.09308243037701214, 0.089609468573836, 0.089609468573836, 0.089609468573836, 0.0629427839085609, 0.0629427839085609, 0.0629427839085609, 0.14158291724646932, 0.14158291724646932, 0.14158291724646932, 0.18094916192793098, 0.18094916192793098, 0.18094916192793098, 0.15904977865468461, 0.15904977865468461, 0.15904977865468461, 0.2182021300876299, 0.2182021300876299, 0.2182021300876299, 0.16708509824611484, 0.16708509824611484, 0.16708509824611484, 0.2672056234088729, 0.2672056234088729, 0.2672056234088729, 0.16194424212444536, 0.16194424212444536, 0.16194424212444536, 0.1462426800787514, 0.1462426800787514, 0.1462426800787514, 0.10727393109062344, 0.10727393109062344, 0.10727393109062344, 0.18917481593134466, 0.18917481593134466, 0.18917481593134466, 0.1755590450393174, 0.1755590450393174, 0.1755590450393174, 0.19145722365842843, 0.19145722365842843, 0.19145722365842843, 0.16768736809447804, 0.16768736809447804, 0.16768736809447804, 0.17468121819179905, 0.17468121819179905, 0.17468121819179905, 0.1501349250146854, 0.1501349250146854, 0.1501349250146854, 0.6163075971032527, 0.6163075971032527, 0.6163075971032527, 0.17337638462382254, 0.17337638462382254, 0.17337638462382254, 0.5817286651398476, 0.5817286651398476, 0.5817286651398476, 0.14176045177026864, 0.14176045177026864, 0.14176045177026864, 0.3449081489230035, 0.3449081489230035, 0.3449081489230035, 0.19718409031201334, 0.19718409031201334, 0.19718409031201334, 0.1919284319723954, 0.1919284319723954, 0.1919284319723954, 0.19137252970873653, 0.19137252970873653, 0.19137252970873653, 0.1832689920511058, 0.1832689920511058, 0.1832689920511058, 0.07489947165618638, 0.07489947165618638, 0.07489947165618638, 0.08116966741223719, 0.08116966741223719, 0.08116966741223719, 0.06714223745612558, 0.06714223745612558, 0.06714223745612558]}, "mutation_prompt": null}
{"id": "f741eee6-26d9-4213-b4bd-37c2e213e3de", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n        self.success_history = []\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            # Update crossover rate based on fitness variance\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation with dynamic mutation factor\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:  # Adapt mutation factor based on success history\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover with adaptive crossover rate\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(0.1)  # Record success\n                else:\n                    self.success_history.append(-0.1)\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        # Adaptive alpha for dynamic search balance\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            # Adjust population size based on fitness diversity\n            fitness_std = np.std(fitness)\n            if fitness_std < 1e-3:  # Population converged\n                self.population_size = max(10, self.population_size - 2)\n            else:\n                self.population_size = min(30, self.population_size + 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Introduce a dynamic population size adaptation based on diversity to maintain exploration and avoid premature convergence.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 20 is out of bounds for axis 0 with size 20').", "error": "IndexError('index 20 is out of bounds for axis 0 with size 20')", "parent_id": "e46c9b67-ff8a-427e-8f40-9cb35179604d", "metadata": {}, "mutation_prompt": null}
{"id": "aba33a22-eeba-4cb5-993a-6a973becbcd9", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n        self.success_history = []\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            # Update crossover rate based on fitness variance\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation with dynamic mutation factor\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:  # Adapt mutation factor based on success history\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover with adaptive crossover rate\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(0.1)  # Record success\n                else:\n                    self.success_history.append(-0.1)\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        # Adaptive alpha for dynamic search balance\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            # Adjust population size based on fitness improvement rate\n            improvement_rate = np.mean([max(0, -val) for val in self.success_history[-self.population_size:]])\n            self.population_size = min(30, self.population_size + int(improvement_rate * 5))\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Introduce adaptive population size scaling based on fitness improvement rate to enhance exploration and convergence balance.", "configspace": "", "generation": 37, "fitness": 0.18790232265848014, "feedback": "The algorithm HybridDEFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.17.", "error": "", "parent_id": "e46c9b67-ff8a-427e-8f40-9cb35179604d", "metadata": {"aucs": [0.44068068765845314, 0.44068068765845314, 0.44068068765845314, 0.425241036942422, 0.425241036942422, 0.425241036942422, 0.4044664669278677, 0.4044664669278677, 0.4044664669278677, 0.028532069031713347, 0.028532069031713347, 0.028532069031713347, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.039531225577675855, 0.039531225577675855, 0.039531225577675855, 0.08728454753950332, 0.08728454753950332, 0.08728454753950332, 0.09693725270102782, 0.09693725270102782, 0.09693725270102782, 0.09158762346257643, 0.09158762346257643, 0.09158762346257643, 0.07735024182410433, 0.07735024182410433, 0.07735024182410433, 0.08678547212285903, 0.08678547212285903, 0.08678547212285903, 0.08028430275436571, 0.08028430275436571, 0.08028430275436571, 0.6820988542308967, 0.6820988542308967, 0.6820988542308967, 0.6805424781973158, 0.6805424781973158, 0.6805424781973158, 0.7302517078985535, 0.7302517078985535, 0.7302517078985535, 0.267327626914705, 0.267327626914705, 0.267327626914705, 0.2633420351644805, 0.2633420351644805, 0.2633420351644805, 0.2920540377587807, 0.2920540377587807, 0.2920540377587807, 0.12471594910095285, 0.12471594910095285, 0.12471594910095285, 0.46105336991312085, 0.46105336991312085, 0.46105336991312085, 0.10151175916995925, 0.10151175916995925, 0.10151175916995925, 0.10891778964255305, 0.10891778964255305, 0.10891778964255305, 0.14973758113973146, 0.14973758113973146, 0.14973758113973146, 0.10566033461483271, 0.10566033461483271, 0.10566033461483271, 0.12513329913438098, 0.12513329913438098, 0.12513329913438098, 0.15754966202884968, 0.15754966202884968, 0.15754966202884968, 0.16043621789362728, 0.16043621789362728, 0.16043621789362728, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012541357940420883, 0.012541357940420883, 0.012541357940420883, 0.013690220610890869, 0.013690220610890869, 0.013690220610890869, 0.06820595477458924, 0.06820595477458924, 0.06820595477458924, 0.04969733430862633, 0.04969733430862633, 0.04969733430862633, 0.0785298959601125, 0.0785298959601125, 0.0785298959601125, 0.015342070101057259, 0.015342070101057259, 0.015342070101057259, 0.010950636064003483, 0.010950636064003483, 0.010950636064003483, 0.008178122179740455, 0.008178122179740455, 0.008178122179740455, 0.03777108429549847, 0.03777108429549847, 0.03777108429549847, 0.08348823266928507, 0.08348823266928507, 0.08348823266928507, 0.07365795331362956, 0.07365795331362956, 0.07365795331362956, 0.3865382738103521, 0.3865382738103521, 0.3865382738103521, 0.3846279194878838, 0.3846279194878838, 0.3846279194878838, 0.3689292343991809, 0.3689292343991809, 0.3689292343991809, 0.09308243037701214, 0.09308243037701214, 0.09308243037701214, 0.089609468573836, 0.089609468573836, 0.089609468573836, 0.0629427839085609, 0.0629427839085609, 0.0629427839085609, 0.14158291724646932, 0.14158291724646932, 0.14158291724646932, 0.18094916192793098, 0.18094916192793098, 0.18094916192793098, 0.15904977865468461, 0.15904977865468461, 0.15904977865468461, 0.2182021300876299, 0.2182021300876299, 0.2182021300876299, 0.16708509824611484, 0.16708509824611484, 0.16708509824611484, 0.2672056234088729, 0.2672056234088729, 0.2672056234088729, 0.16194424212444536, 0.16194424212444536, 0.16194424212444536, 0.1462426800787514, 0.1462426800787514, 0.1462426800787514, 0.10727393109062344, 0.10727393109062344, 0.10727393109062344, 0.18917481593134466, 0.18917481593134466, 0.18917481593134466, 0.1755590450393174, 0.1755590450393174, 0.1755590450393174, 0.19145722365842843, 0.19145722365842843, 0.19145722365842843, 0.16768736599416334, 0.16768736599416334, 0.16768736599416334, 0.17468149897298846, 0.17468149897298846, 0.17468149897298846, 0.15013491258354228, 0.15013491258354228, 0.15013491258354228, 0.6318625353622301, 0.6318625353622301, 0.6318625353622301, 0.1733773344689853, 0.1733773344689853, 0.1733773344689853, 0.5603628409295243, 0.5603628409295243, 0.5603628409295243, 0.14176038178654526, 0.14176038178654526, 0.14176038178654526, 0.3294128846939267, 0.3294128846939267, 0.3294128846939267, 0.1971828967472785, 0.1971828967472785, 0.1971828967472785, 0.1919284319723954, 0.1919284319723954, 0.1919284319723954, 0.19137252970873653, 0.19137252970873653, 0.19137252970873653, 0.1832689920511058, 0.1832689920511058, 0.1832689920511058, 0.07489947165618638, 0.07489947165618638, 0.07489947165618638, 0.08116966741223719, 0.08116966741223719, 0.08116966741223719, 0.06714223745612558, 0.06714223745612558, 0.06714223745612558]}, "mutation_prompt": null}
{"id": "52bb9469-bf85-4de0-94c7-8f03d5a9c328", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n        self.success_history = []\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            # Update crossover rate based on fitness variance\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation with dynamic mutation factor\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:  # Adapt mutation factor based on success history\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover with adaptive crossover rate\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(0.1)  # Record success\n                else:\n                    self.success_history.append(-0.1)\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        # Adaptive alpha for dynamic search balance\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            # Adjust population size based on fitness diversity\n            if np.std(fitness) < 1e-3:  # Population converged\n                self.population_size = max(10, self.population_size - 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Introduce a mutation strategy based on success history to improve adaptability and ensure robust exploration.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e46c9b67-ff8a-427e-8f40-9cb35179604d", "metadata": {"aucs": [0.4418200410432245, 0.4418200410432245, 0.4418200410432245, 0.4217665546150817, 0.4217665546150817, 0.4217665546150817, 0.40527422068216257, 0.40527422068216257, 0.40527422068216257, 0.028532069031713347, 0.028532069031713347, 0.028532069031713347, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.039531225577675855, 0.039531225577675855, 0.039531225577675855, 0.08728454753950332, 0.08728454753950332, 0.08728454753950332, 0.09693725270102782, 0.09693725270102782, 0.09693725270102782, 0.09158762346257643, 0.09158762346257643, 0.09158762346257643, 0.07735024182410433, 0.07735024182410433, 0.07735024182410433, 0.08678547212285903, 0.08678547212285903, 0.08678547212285903, 0.08028430275436571, 0.08028430275436571, 0.08028430275436571, 0.6820988542308967, 0.6820988542308967, 0.6820988542308967, 0.6805424781973158, 0.6805424781973158, 0.6805424781973158, 0.7302517078985535, 0.7302517078985535, 0.7302517078985535, 0.26718795392276384, 0.26718795392276384, 0.26718795392276384, 0.26323878233985554, 0.26323878233985554, 0.26323878233985554, 0.2919722914049717, 0.2919722914049717, 0.2919722914049717, 0.12471594910095285, 0.12471594910095285, 0.12471594910095285, 0.46105336991312085, 0.46105336991312085, 0.46105336991312085, 0.10151175916995925, 0.10151175916995925, 0.10151175916995925, 0.10891778964255305, 0.10891778964255305, 0.10891778964255305, 0.14973758113973146, 0.14973758113973146, 0.14973758113973146, 0.10566033461483271, 0.10566033461483271, 0.10566033461483271, 0.12513329913438098, 0.12513329913438098, 0.12513329913438098, 0.15754966202884968, 0.15754966202884968, 0.15754966202884968, 0.16043621789362728, 0.16043621789362728, 0.16043621789362728, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012541357940420883, 0.012541357940420883, 0.012541357940420883, 0.013690220610890869, 0.013690220610890869, 0.013690220610890869, 0.06820595477458924, 0.06820595477458924, 0.06820595477458924, 0.04969733430862633, 0.04969733430862633, 0.04969733430862633, 0.0785298959601125, 0.0785298959601125, 0.0785298959601125, 0.015342070101057259, 0.015342070101057259, 0.015342070101057259, 0.010950636064003483, 0.010950636064003483, 0.010950636064003483, 0.008178122179740455, 0.008178122179740455, 0.008178122179740455, 0.03777108429549847, 0.03777108429549847, 0.03777108429549847, 0.08348823266928507, 0.08348823266928507, 0.08348823266928507, 0.07365795331362956, 0.07365795331362956, 0.07365795331362956, 0.3864751860311392, 0.3864751860311392, 0.3864751860311392, 0.38403496823851235, 0.38403496823851235, 0.38403496823851235, 0.3660060262339697, 0.3660060262339697, 0.3660060262339697, 0.09308243037701214, 0.09308243037701214, 0.09308243037701214, 0.089609468573836, 0.089609468573836, 0.089609468573836, 0.0629427839085609, 0.0629427839085609, 0.0629427839085609, 0.14158291724646932, 0.14158291724646932, 0.14158291724646932, 0.18094916192793098, 0.18094916192793098, 0.18094916192793098, 0.15904977865468461, 0.15904977865468461, 0.15904977865468461, 0.2182021300876299, 0.2182021300876299, 0.2182021300876299, 0.16708509824611484, 0.16708509824611484, 0.16708509824611484, 0.2672056234088729, 0.2672056234088729, 0.2672056234088729, 0.16194424212444536, 0.16194424212444536, 0.16194424212444536, 0.1462426800787514, 0.1462426800787514, 0.1462426800787514, 0.10727393109062344, 0.10727393109062344, 0.10727393109062344, 0.18917481593134466, 0.18917481593134466, 0.18917481593134466, 0.1755590450393174, 0.1755590450393174, 0.1755590450393174, 0.19145722365842843, 0.19145722365842843, 0.19145722365842843, 0.16768736809447804, 0.16768736809447804, 0.16768736809447804, 0.17468121819179905, 0.17468121819179905, 0.17468121819179905, 0.1501349250146854, 0.1501349250146854, 0.1501349250146854, 0.6163075971032527, 0.6163075971032527, 0.6163075971032527, 0.17337638462382254, 0.17337638462382254, 0.17337638462382254, 0.5817286651398476, 0.5817286651398476, 0.5817286651398476, 0.14176045177026864, 0.14176045177026864, 0.14176045177026864, 0.3449081489230035, 0.3449081489230035, 0.3449081489230035, 0.19718409031201334, 0.19718409031201334, 0.19718409031201334, 0.1919284319723954, 0.1919284319723954, 0.1919284319723954, 0.19137252970873653, 0.19137252970873653, 0.19137252970873653, 0.1832689920511058, 0.1832689920511058, 0.1832689920511058, 0.07489947165618638, 0.07489947165618638, 0.07489947165618638, 0.08116966741223719, 0.08116966741223719, 0.08116966741223719, 0.06714223745612558, 0.06714223745612558, 0.06714223745612558]}, "mutation_prompt": null}
{"id": "1981fa5d-5a79-489f-97fb-1f2fc1092afe", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n        self.success_history = []\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            # Update crossover rate based on fitness variance\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation with dynamic mutation factor\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                mean_success = np.mean(self.success_history) if self.success_history else 0\n                dynamic_mutation_factor *= (1 + mean_success - np.abs(mean_success))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover with adaptive crossover rate\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(0.1)  # Record success\n                else:\n                    self.success_history.append(-0.1)\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            population = new_population\n            \n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            improvement_rate = np.mean(self.success_history[-self.population_size:])  # Evaluate recent improvement\n            if improvement_rate > 0.05:  # Adaptive population size increase\n                self.population_size = min(40, self.population_size + 2)\n            elif np.std(fitness) < 1e-3:  # Adaptive population size decrease\n                self.population_size = max(10, self.population_size - 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Implement an adaptive population size mechanism based on improvement rate and enhance mutation strategy by considering both historical success and failure rates.", "configspace": "", "generation": 39, "fitness": 0.17931044921822087, "feedback": "The algorithm HybridDEFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.15.", "error": "", "parent_id": "e46c9b67-ff8a-427e-8f40-9cb35179604d", "metadata": {"aucs": [0.4174031233573485, 0.4174031233573485, 0.4174031233573485, 0.4338305780202679, 0.4338305780202679, 0.4338305780202679, 0.41503625357889073, 0.41503625357889073, 0.41503625357889073, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.022822233732435193, 0.022822233732435193, 0.022822233732435193, 0.11669025611003658, 0.11669025611003658, 0.11669025611003658, 0.07569250536413419, 0.07569250536413419, 0.07569250536413419, 0.09000990933169573, 0.09000990933169573, 0.09000990933169573, 0.0746464707832658, 0.0746464707832658, 0.0746464707832658, 0.03685831011522678, 0.03685831011522678, 0.03685831011522678, 0.06914927679198357, 0.06914927679198357, 0.06914927679198357, 0.09707351938590159, 0.09707351938590159, 0.09707351938590159, 0.4765256690299159, 0.4765256690299159, 0.4765256690299159, 0.7739082669009142, 0.7739082669009142, 0.7739082669009142, 0.30028471192645734, 0.30028471192645734, 0.30028471192645734, 0.2538312194647455, 0.2538312194647455, 0.2538312194647455, 0.29112645806174886, 0.29112645806174886, 0.29112645806174886, 0.1779713677582978, 0.1779713677582978, 0.1779713677582978, 0.1929350136003949, 0.1929350136003949, 0.1929350136003949, 0.10927753043917054, 0.10927753043917054, 0.10927753043917054, 0.13369801283140859, 0.13369801283140859, 0.13369801283140859, 0.08292041526149929, 0.08292041526149929, 0.08292041526149929, 0.16691958003480245, 0.16691958003480245, 0.16691958003480245, 0.18063077828753626, 0.18063077828753626, 0.18063077828753626, 0.1599009763023458, 0.1599009763023458, 0.1599009763023458, 0.18179968736679197, 0.18179968736679197, 0.18179968736679197, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0003117008925206388, 0.0003117008925206388, 0.0003117008925206388, 0.008168288803616974, 0.008168288803616974, 0.008168288803616974, 0.08893839051700958, 0.08893839051700958, 0.08893839051700958, 0.02717381339244107, 0.02717381339244107, 0.02717381339244107, 0.08039507722059547, 0.08039507722059547, 0.08039507722059547, 0.008075983726052227, 0.008075983726052227, 0.008075983726052227, 0.005118117664990152, 0.005118117664990152, 0.005118117664990152, 0.007209888909372242, 0.007209888909372242, 0.007209888909372242, 0.06705458211305504, 0.06705458211305504, 0.06705458211305504, 0.07527174794731639, 0.07527174794731639, 0.07527174794731639, 0.11277902843695187, 0.11277902843695187, 0.11277902843695187, 0.40041915509343384, 0.40041915509343384, 0.40041915509343384, 0.40461781963724286, 0.40461781963724286, 0.40461781963724286, 0.39357960723627816, 0.39357960723627816, 0.39357960723627816, 0.0974294716460572, 0.0974294716460572, 0.0974294716460572, 0.07313526217100375, 0.07313526217100375, 0.07313526217100375, 0.0901844742103245, 0.0901844742103245, 0.0901844742103245, 0.15330169417782147, 0.15330169417782147, 0.15330169417782147, 0.1555375530456995, 0.1555375530456995, 0.1555375530456995, 0.15310689079240913, 0.15310689079240913, 0.15310689079240913, 0.2815918620731024, 0.2815918620731024, 0.2815918620731024, 0.2127699099506506, 0.2127699099506506, 0.2127699099506506, 0.2899509635114177, 0.2899509635114177, 0.2899509635114177, 0.1452047091940405, 0.1452047091940405, 0.1452047091940405, 0.12425127090491095, 0.12425127090491095, 0.12425127090491095, 0.17970777858817533, 0.17970777858817533, 0.17970777858817533, 0.18485325906575922, 0.18485325906575922, 0.18485325906575922, 0.2001391595100156, 0.2001391595100156, 0.2001391595100156, 0.18163424765749092, 0.18163424765749092, 0.18163424765749092, 0.1824085858597848, 0.1824085858597848, 0.1824085858597848, 0.17067282972018005, 0.17067282972018005, 0.17067282972018005, 0.16608239945747194, 0.16608239945747194, 0.16608239945747194, 0.6023992112737844, 0.6023992112737844, 0.6023992112737844, 0.1714232540208801, 0.1714232540208801, 0.1714232540208801, 0.6349084586324374, 0.6349084586324374, 0.6349084586324374, 0.1453685094710656, 0.1453685094710656, 0.1453685094710656, 0.32109463963139695, 0.32109463963139695, 0.32109463963139695, 0.1912110881127672, 0.1912110881127672, 0.1912110881127672, 0.1828631156555991, 0.1828631156555991, 0.1828631156555991, 0.18310911664209573, 0.18310911664209573, 0.18310911664209573, 0.18901820801815206, 0.18901820801815206, 0.18901820801815206, 0.07512474776604927, 0.07512474776604927, 0.07512474776604927, 0.09152144116453542, 0.09152144116453542, 0.09152144116453542, 0.06999290635873079, 0.06999290635873079, 0.06999290635873079]}, "mutation_prompt": null}
{"id": "adac1cfd-ad58-485e-9d55-eaa324c78f73", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.alpha = 0.5\n        self.gamma = 1.0\n        self.success_history = []\n\n    def __call__(self, func):\n        np.random.seed(42)\n        budget_used = 0\n\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n            diversity_factor = np.std(fitness) / np.mean(fitness)\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget)) * (1 + diversity_factor)\n                if self.success_history:\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(0.1)\n                else:\n                    self.success_history.append(-0.1)\n\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget)) * (1 + diversity_factor)\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            population = new_population\n            \n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if np.std(fitness) < 1e-3:\n                self.population_size = max(10, self.population_size - 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Enhance adaptability by introducing dynamic scaling of mutation factor and firefly attraction based on fitness diversity.", "configspace": "", "generation": 40, "fitness": 0.15910778145046314, "feedback": "The algorithm HybridDEFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.14.", "error": "", "parent_id": "e46c9b67-ff8a-427e-8f40-9cb35179604d", "metadata": {"aucs": [0.44635873978841334, 0.44635873978841334, 0.44635873978841334, 0.41605485657051855, 0.41605485657051855, 0.41605485657051855, 0.4229735239795861, 0.4229735239795861, 0.4229735239795861, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12429228499119072, 0.12429228499119072, 0.12429228499119072, 0.07499116449064513, 0.07499116449064513, 0.07499116449064513, 0.08147088145076764, 0.08147088145076764, 0.08147088145076764, 0.06184397111686846, 0.06184397111686846, 0.06184397111686846, 0.08268678440616839, 0.08268678440616839, 0.08268678440616839, 0.0666220312706024, 0.0666220312706024, 0.0666220312706024, 0.6696318785375571, 0.6696318785375571, 0.6696318785375571, 0.106769320037294, 0.106769320037294, 0.106769320037294, 0.31859205233545695, 0.31859205233545695, 0.31859205233545695, 0.1879444302449138, 0.1879444302449138, 0.1879444302449138, 0.22248830625862648, 0.22248830625862648, 0.22248830625862648, 0.19624975847159554, 0.19624975847159554, 0.19624975847159554, 0.14012721126806305, 0.14012721126806305, 0.14012721126806305, 0.17332602699379562, 0.17332602699379562, 0.17332602699379562, 0.15606949974550477, 0.15606949974550477, 0.15606949974550477, 0.0984680653722948, 0.0984680653722948, 0.0984680653722948, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11947709330095202, 0.11947709330095202, 0.11947709330095202, 0.08578399813992288, 0.08578399813992288, 0.08578399813992288, 0.08431789057809269, 0.08431789057809269, 0.08431789057809269, 0.11937999839599522, 0.11937999839599522, 0.11937999839599522, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04844615847274092, 0.04844615847274092, 0.04844615847274092, 0.02539758951114257, 0.02539758951114257, 0.02539758951114257, 0.05508372406297857, 0.05508372406297857, 0.05508372406297857, 0.0008644351274429418, 0.0008644351274429418, 0.0008644351274429418, 0.010675960236240511, 0.010675960236240511, 0.010675960236240511, 0.0032715340912978785, 0.0032715340912978785, 0.0032715340912978785, 0.05178053610469524, 0.05178053610469524, 0.05178053610469524, 0.04923829729971785, 0.04923829729971785, 0.04923829729971785, 0.08555844402753177, 0.08555844402753177, 0.08555844402753177, 0.38566503081159687, 0.38566503081159687, 0.38566503081159687, 0.3945173208100564, 0.3945173208100564, 0.3945173208100564, 0.3809423911208868, 0.3809423911208868, 0.3809423911208868, 0.1213061017356728, 0.1213061017356728, 0.1213061017356728, 0.06274833609727071, 0.06274833609727071, 0.06274833609727071, 0.05498739610246972, 0.05498739610246972, 0.05498739610246972, 0.11540372458104453, 0.11540372458104453, 0.11540372458104453, 0.13287930086043231, 0.13287930086043231, 0.13287930086043231, 0.14057813088343396, 0.14057813088343396, 0.14057813088343396, 0.2775115446027784, 0.2775115446027784, 0.2775115446027784, 0.22324869834397865, 0.22324869834397865, 0.22324869834397865, 0.2038538772458045, 0.2038538772458045, 0.2038538772458045, 0.11958744986532932, 0.11958744986532932, 0.11958744986532932, 0.1867092987161929, 0.1867092987161929, 0.1867092987161929, 0.2098391451107655, 0.2098391451107655, 0.2098391451107655, 0.18522079252055101, 0.18522079252055101, 0.18522079252055101, 0.20084324879849025, 0.20084324879849025, 0.20084324879849025, 0.19185480039893854, 0.19185480039893854, 0.19185480039893854, 0.14320350618361422, 0.14320350618361422, 0.14320350618361422, 0.13170168957685524, 0.13170168957685524, 0.13170168957685524, 0.15189144310293667, 0.15189144310293667, 0.15189144310293667, 0.1681197824646723, 0.1681197824646723, 0.1681197824646723, 0.17693660073180106, 0.17693660073180106, 0.17693660073180106, 0.512679626191668, 0.512679626191668, 0.512679626191668, 0.16740346409465723, 0.16740346409465723, 0.16740346409465723, 0.3836010043753315, 0.3836010043753315, 0.3836010043753315, 0.4842833011828316, 0.4842833011828316, 0.4842833011828316, 0.19133194522982844, 0.19133194522982844, 0.19133194522982844, 0.19019171357036269, 0.19019171357036269, 0.19019171357036269, 0.18950306736522582, 0.18950306736522582, 0.18950306736522582, 0.06011251464656375, 0.06011251464656375, 0.06011251464656375, 0.0636758375534704, 0.0636758375534704, 0.0636758375534704, 0.06649173287922039, 0.06649173287922039, 0.06649173287922039]}, "mutation_prompt": null}
{"id": "a44d126b-8428-4828-a406-7d6ff4ff6939", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.alpha = 0.5\n        self.gamma = 1.0\n        self.success_history = []\n\n    def __call__(self, func):\n        np.random.seed(42)\n        budget_used = 0\n\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(0.1)\n                else:\n                    self.success_history.append(-0.1)\n\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            population = new_population\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if np.std(fitness) < 1e-3 or np.mean(self.success_history[-10:]) > 0.05:\n                self.population_size = min(self.initial_population_size * 2, self.population_size + 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Introduce dynamic adaptation of population size based on diversity and exploitative success to enhance convergence.", "configspace": "", "generation": 41, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 20 is out of bounds for axis 0 with size 20').", "error": "IndexError('index 20 is out of bounds for axis 0 with size 20')", "parent_id": "e46c9b67-ff8a-427e-8f40-9cb35179604d", "metadata": {}, "mutation_prompt": null}
{"id": "53b4f840-6d06-4ed6-bb54-b47e73d27487", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n        self.success_history = []\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            # Update crossover rate based on fitness variance\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation with dynamic mutation factor\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:  # Adapt mutation factor based on success history\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover with adaptive crossover rate\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(0.1)  # Record success\n                else:\n                    self.success_history.append(-0.1)\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        # Adaptive alpha for dynamic search balance\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            # Adjust population size based on fitness diversity\n            if np.std(fitness) < 1e-3:  # Population converged\n                self.population_size = max(10, self.population_size - 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Introduce a mutation strategy based on success history to improve adaptability and ensure robust exploration.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e46c9b67-ff8a-427e-8f40-9cb35179604d", "metadata": {"aucs": [0.4418200410432245, 0.4418200410432245, 0.4418200410432245, 0.4217665546150817, 0.4217665546150817, 0.4217665546150817, 0.40527422068216257, 0.40527422068216257, 0.40527422068216257, 0.028532069031713347, 0.028532069031713347, 0.028532069031713347, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.039531225577675855, 0.039531225577675855, 0.039531225577675855, 0.08728454753950332, 0.08728454753950332, 0.08728454753950332, 0.09693725270102782, 0.09693725270102782, 0.09693725270102782, 0.09158762346257643, 0.09158762346257643, 0.09158762346257643, 0.07735024182410433, 0.07735024182410433, 0.07735024182410433, 0.08678547212285903, 0.08678547212285903, 0.08678547212285903, 0.08028430275436571, 0.08028430275436571, 0.08028430275436571, 0.6820988542308967, 0.6820988542308967, 0.6820988542308967, 0.6805424781973158, 0.6805424781973158, 0.6805424781973158, 0.7302517078985535, 0.7302517078985535, 0.7302517078985535, 0.26718795392276384, 0.26718795392276384, 0.26718795392276384, 0.26323878233985554, 0.26323878233985554, 0.26323878233985554, 0.2919722914049717, 0.2919722914049717, 0.2919722914049717, 0.12471594910095285, 0.12471594910095285, 0.12471594910095285, 0.46105336991312085, 0.46105336991312085, 0.46105336991312085, 0.10151175916995925, 0.10151175916995925, 0.10151175916995925, 0.10891778964255305, 0.10891778964255305, 0.10891778964255305, 0.14973758113973146, 0.14973758113973146, 0.14973758113973146, 0.10566033461483271, 0.10566033461483271, 0.10566033461483271, 0.12513329913438098, 0.12513329913438098, 0.12513329913438098, 0.15754966202884968, 0.15754966202884968, 0.15754966202884968, 0.16043621789362728, 0.16043621789362728, 0.16043621789362728, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012541357940420883, 0.012541357940420883, 0.012541357940420883, 0.013690220610890869, 0.013690220610890869, 0.013690220610890869, 0.06820595477458924, 0.06820595477458924, 0.06820595477458924, 0.04969733430862633, 0.04969733430862633, 0.04969733430862633, 0.0785298959601125, 0.0785298959601125, 0.0785298959601125, 0.015342070101057259, 0.015342070101057259, 0.015342070101057259, 0.010950636064003483, 0.010950636064003483, 0.010950636064003483, 0.008178122179740455, 0.008178122179740455, 0.008178122179740455, 0.03777108429549847, 0.03777108429549847, 0.03777108429549847, 0.08348823266928507, 0.08348823266928507, 0.08348823266928507, 0.07365795331362956, 0.07365795331362956, 0.07365795331362956, 0.3864751860311392, 0.3864751860311392, 0.3864751860311392, 0.38403496823851235, 0.38403496823851235, 0.38403496823851235, 0.3660060262339697, 0.3660060262339697, 0.3660060262339697, 0.09308243037701214, 0.09308243037701214, 0.09308243037701214, 0.089609468573836, 0.089609468573836, 0.089609468573836, 0.0629427839085609, 0.0629427839085609, 0.0629427839085609, 0.14158291724646932, 0.14158291724646932, 0.14158291724646932, 0.18094916192793098, 0.18094916192793098, 0.18094916192793098, 0.15904977865468461, 0.15904977865468461, 0.15904977865468461, 0.2182021300876299, 0.2182021300876299, 0.2182021300876299, 0.16708509824611484, 0.16708509824611484, 0.16708509824611484, 0.2672056234088729, 0.2672056234088729, 0.2672056234088729, 0.16194424212444536, 0.16194424212444536, 0.16194424212444536, 0.1462426800787514, 0.1462426800787514, 0.1462426800787514, 0.10727393109062344, 0.10727393109062344, 0.10727393109062344, 0.18917481593134466, 0.18917481593134466, 0.18917481593134466, 0.1755590450393174, 0.1755590450393174, 0.1755590450393174, 0.19145722365842843, 0.19145722365842843, 0.19145722365842843, 0.16768736809447804, 0.16768736809447804, 0.16768736809447804, 0.17468121819179905, 0.17468121819179905, 0.17468121819179905, 0.1501349250146854, 0.1501349250146854, 0.1501349250146854, 0.6163075971032527, 0.6163075971032527, 0.6163075971032527, 0.17337638462382254, 0.17337638462382254, 0.17337638462382254, 0.5817286651398476, 0.5817286651398476, 0.5817286651398476, 0.14176045177026864, 0.14176045177026864, 0.14176045177026864, 0.3449081489230035, 0.3449081489230035, 0.3449081489230035, 0.19718409031201334, 0.19718409031201334, 0.19718409031201334, 0.1919284319723954, 0.1919284319723954, 0.1919284319723954, 0.19137252970873653, 0.19137252970873653, 0.19137252970873653, 0.1832689920511058, 0.1832689920511058, 0.1832689920511058, 0.07489947165618638, 0.07489947165618638, 0.07489947165618638, 0.08116966741223719, 0.08116966741223719, 0.08116966741223719, 0.06714223745612558, 0.06714223745612558, 0.06714223745612558]}, "mutation_prompt": null}
{"id": "ee127fa5-b79e-4c98-99d1-27af5db3704b", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n        self.success_history = []\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            # Update crossover rate based on fitness variance\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation with dynamic mutation factor\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:  # Adapt mutation factor based on success history\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover with adaptive crossover rate\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(0.1)  # Record success\n                else:\n                    self.success_history.append(-0.1)\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        # Adaptive alpha for dynamic search balance\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            # Adjust population size based on fitness diversity\n            if np.std(fitness) < 1e-3:  # Population converged\n                self.population_size = max(10, self.population_size - 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Introduce a mutation strategy based on success history to improve adaptability and ensure robust exploration.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e46c9b67-ff8a-427e-8f40-9cb35179604d", "metadata": {"aucs": [0.4418200410432245, 0.4418200410432245, 0.4418200410432245, 0.4217665546150817, 0.4217665546150817, 0.4217665546150817, 0.40527422068216257, 0.40527422068216257, 0.40527422068216257, 0.028532069031713347, 0.028532069031713347, 0.028532069031713347, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.039531225577675855, 0.039531225577675855, 0.039531225577675855, 0.08728454753950332, 0.08728454753950332, 0.08728454753950332, 0.09693725270102782, 0.09693725270102782, 0.09693725270102782, 0.09158762346257643, 0.09158762346257643, 0.09158762346257643, 0.07735024182410433, 0.07735024182410433, 0.07735024182410433, 0.08678547212285903, 0.08678547212285903, 0.08678547212285903, 0.08028430275436571, 0.08028430275436571, 0.08028430275436571, 0.6820988542308967, 0.6820988542308967, 0.6820988542308967, 0.6805424781973158, 0.6805424781973158, 0.6805424781973158, 0.7302517078985535, 0.7302517078985535, 0.7302517078985535, 0.26718795392276384, 0.26718795392276384, 0.26718795392276384, 0.26323878233985554, 0.26323878233985554, 0.26323878233985554, 0.2919722914049717, 0.2919722914049717, 0.2919722914049717, 0.12471594910095285, 0.12471594910095285, 0.12471594910095285, 0.46105336991312085, 0.46105336991312085, 0.46105336991312085, 0.10151175916995925, 0.10151175916995925, 0.10151175916995925, 0.10891778964255305, 0.10891778964255305, 0.10891778964255305, 0.14973758113973146, 0.14973758113973146, 0.14973758113973146, 0.10566033461483271, 0.10566033461483271, 0.10566033461483271, 0.12513329913438098, 0.12513329913438098, 0.12513329913438098, 0.15754966202884968, 0.15754966202884968, 0.15754966202884968, 0.16043621789362728, 0.16043621789362728, 0.16043621789362728, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012541357940420883, 0.012541357940420883, 0.012541357940420883, 0.013690220610890869, 0.013690220610890869, 0.013690220610890869, 0.06820595477458924, 0.06820595477458924, 0.06820595477458924, 0.04969733430862633, 0.04969733430862633, 0.04969733430862633, 0.0785298959601125, 0.0785298959601125, 0.0785298959601125, 0.015342070101057259, 0.015342070101057259, 0.015342070101057259, 0.010950636064003483, 0.010950636064003483, 0.010950636064003483, 0.008178122179740455, 0.008178122179740455, 0.008178122179740455, 0.03777108429549847, 0.03777108429549847, 0.03777108429549847, 0.08348823266928507, 0.08348823266928507, 0.08348823266928507, 0.07365795331362956, 0.07365795331362956, 0.07365795331362956, 0.3864751860311392, 0.3864751860311392, 0.3864751860311392, 0.38403496823851235, 0.38403496823851235, 0.38403496823851235, 0.3660060262339697, 0.3660060262339697, 0.3660060262339697, 0.09308243037701214, 0.09308243037701214, 0.09308243037701214, 0.089609468573836, 0.089609468573836, 0.089609468573836, 0.0629427839085609, 0.0629427839085609, 0.0629427839085609, 0.14158291724646932, 0.14158291724646932, 0.14158291724646932, 0.18094916192793098, 0.18094916192793098, 0.18094916192793098, 0.15904977865468461, 0.15904977865468461, 0.15904977865468461, 0.2182021300876299, 0.2182021300876299, 0.2182021300876299, 0.16708509824611484, 0.16708509824611484, 0.16708509824611484, 0.2672056234088729, 0.2672056234088729, 0.2672056234088729, 0.16194424212444536, 0.16194424212444536, 0.16194424212444536, 0.1462426800787514, 0.1462426800787514, 0.1462426800787514, 0.10727393109062344, 0.10727393109062344, 0.10727393109062344, 0.18917481593134466, 0.18917481593134466, 0.18917481593134466, 0.1755590450393174, 0.1755590450393174, 0.1755590450393174, 0.19145722365842843, 0.19145722365842843, 0.19145722365842843, 0.16768736809447804, 0.16768736809447804, 0.16768736809447804, 0.17468121819179905, 0.17468121819179905, 0.17468121819179905, 0.1501349250146854, 0.1501349250146854, 0.1501349250146854, 0.6163075971032527, 0.6163075971032527, 0.6163075971032527, 0.17337638462382254, 0.17337638462382254, 0.17337638462382254, 0.5817286651398476, 0.5817286651398476, 0.5817286651398476, 0.14176045177026864, 0.14176045177026864, 0.14176045177026864, 0.3449081489230035, 0.3449081489230035, 0.3449081489230035, 0.19718409031201334, 0.19718409031201334, 0.19718409031201334, 0.1919284319723954, 0.1919284319723954, 0.1919284319723954, 0.19137252970873653, 0.19137252970873653, 0.19137252970873653, 0.1832689920511058, 0.1832689920511058, 0.1832689920511058, 0.07489947165618638, 0.07489947165618638, 0.07489947165618638, 0.08116966741223719, 0.08116966741223719, 0.08116966741223719, 0.06714223745612558, 0.06714223745612558, 0.06714223745612558]}, "mutation_prompt": null}
{"id": "91670e04-ca0c-42d6-aa3a-76e78225a259", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n        self.success_history = []\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            # Update crossover rate based on fitness variance\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation with dynamic mutation factor\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:  # Adapt mutation factor based on success history\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover with adaptive crossover rate\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(0.1)  # Record success\n                else:\n                    self.success_history.append(-0.1)\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        # Adaptive alpha for dynamic search balance\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            # Adjust population size based on fitness diversity\n            if np.std(fitness) < 1e-3:  # Population converged\n                self.population_size = max(10, self.population_size - 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Introduce a mutation strategy based on success history to improve adaptability and ensure robust exploration.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e46c9b67-ff8a-427e-8f40-9cb35179604d", "metadata": {"aucs": [0.4418200410432245, 0.4418200410432245, 0.4418200410432245, 0.4217665546150817, 0.4217665546150817, 0.4217665546150817, 0.40527422068216257, 0.40527422068216257, 0.40527422068216257, 0.028532069031713347, 0.028532069031713347, 0.028532069031713347, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.039531225577675855, 0.039531225577675855, 0.039531225577675855, 0.08728454753950332, 0.08728454753950332, 0.08728454753950332, 0.09693725270102782, 0.09693725270102782, 0.09693725270102782, 0.09158762346257643, 0.09158762346257643, 0.09158762346257643, 0.07735024182410433, 0.07735024182410433, 0.07735024182410433, 0.08678547212285903, 0.08678547212285903, 0.08678547212285903, 0.08028430275436571, 0.08028430275436571, 0.08028430275436571, 0.6820988542308967, 0.6820988542308967, 0.6820988542308967, 0.6805424781973158, 0.6805424781973158, 0.6805424781973158, 0.7302517078985535, 0.7302517078985535, 0.7302517078985535, 0.26718795392276384, 0.26718795392276384, 0.26718795392276384, 0.26323878233985554, 0.26323878233985554, 0.26323878233985554, 0.2919722914049717, 0.2919722914049717, 0.2919722914049717, 0.12471594910095285, 0.12471594910095285, 0.12471594910095285, 0.46105336991312085, 0.46105336991312085, 0.46105336991312085, 0.10151175916995925, 0.10151175916995925, 0.10151175916995925, 0.10891778964255305, 0.10891778964255305, 0.10891778964255305, 0.14973758113973146, 0.14973758113973146, 0.14973758113973146, 0.10566033461483271, 0.10566033461483271, 0.10566033461483271, 0.12513329913438098, 0.12513329913438098, 0.12513329913438098, 0.15754966202884968, 0.15754966202884968, 0.15754966202884968, 0.16043621789362728, 0.16043621789362728, 0.16043621789362728, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012541357940420883, 0.012541357940420883, 0.012541357940420883, 0.013690220610890869, 0.013690220610890869, 0.013690220610890869, 0.06820595477458924, 0.06820595477458924, 0.06820595477458924, 0.04969733430862633, 0.04969733430862633, 0.04969733430862633, 0.0785298959601125, 0.0785298959601125, 0.0785298959601125, 0.015342070101057259, 0.015342070101057259, 0.015342070101057259, 0.010950636064003483, 0.010950636064003483, 0.010950636064003483, 0.008178122179740455, 0.008178122179740455, 0.008178122179740455, 0.03777108429549847, 0.03777108429549847, 0.03777108429549847, 0.08348823266928507, 0.08348823266928507, 0.08348823266928507, 0.07365795331362956, 0.07365795331362956, 0.07365795331362956, 0.3864751860311392, 0.3864751860311392, 0.3864751860311392, 0.38403496823851235, 0.38403496823851235, 0.38403496823851235, 0.3660060262339697, 0.3660060262339697, 0.3660060262339697, 0.09308243037701214, 0.09308243037701214, 0.09308243037701214, 0.089609468573836, 0.089609468573836, 0.089609468573836, 0.0629427839085609, 0.0629427839085609, 0.0629427839085609, 0.14158291724646932, 0.14158291724646932, 0.14158291724646932, 0.18094916192793098, 0.18094916192793098, 0.18094916192793098, 0.15904977865468461, 0.15904977865468461, 0.15904977865468461, 0.2182021300876299, 0.2182021300876299, 0.2182021300876299, 0.16708509824611484, 0.16708509824611484, 0.16708509824611484, 0.2672056234088729, 0.2672056234088729, 0.2672056234088729, 0.16194424212444536, 0.16194424212444536, 0.16194424212444536, 0.1462426800787514, 0.1462426800787514, 0.1462426800787514, 0.10727393109062344, 0.10727393109062344, 0.10727393109062344, 0.18917481593134466, 0.18917481593134466, 0.18917481593134466, 0.1755590450393174, 0.1755590450393174, 0.1755590450393174, 0.19145722365842843, 0.19145722365842843, 0.19145722365842843, 0.16768736809447804, 0.16768736809447804, 0.16768736809447804, 0.17468121819179905, 0.17468121819179905, 0.17468121819179905, 0.1501349250146854, 0.1501349250146854, 0.1501349250146854, 0.6163075971032527, 0.6163075971032527, 0.6163075971032527, 0.17337638462382254, 0.17337638462382254, 0.17337638462382254, 0.5817286651398476, 0.5817286651398476, 0.5817286651398476, 0.14176045177026864, 0.14176045177026864, 0.14176045177026864, 0.3449081489230035, 0.3449081489230035, 0.3449081489230035, 0.19718409031201334, 0.19718409031201334, 0.19718409031201334, 0.1919284319723954, 0.1919284319723954, 0.1919284319723954, 0.19137252970873653, 0.19137252970873653, 0.19137252970873653, 0.1832689920511058, 0.1832689920511058, 0.1832689920511058, 0.07489947165618638, 0.07489947165618638, 0.07489947165618638, 0.08116966741223719, 0.08116966741223719, 0.08116966741223719, 0.06714223745612558, 0.06714223745612558, 0.06714223745612558]}, "mutation_prompt": null}
{"id": "969afd50-dc1d-4c13-8c98-47b76e41af80", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n        self.success_history = []\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            # Update crossover rate based on fitness variance\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation with dynamic mutation factor\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:  # Adapt mutation factor based on success history\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover with adaptive crossover rate\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(0.1)  # Record success\n                else:\n                    self.success_history.append(-0.1)\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        # Introduce success-based gamma adaptation\n                        adaptive_gamma = self.gamma * (1 + np.mean(self.success_history))\n                        beta = np.exp(-adaptive_gamma * r**2)\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            # Adjust population size based on fitness diversity\n            if np.std(fitness) < 1e-3:  # Population converged\n                self.population_size = max(10, self.population_size - 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Introduce a success-based adaptive gamma parameter to further balance exploration and exploitation.", "configspace": "", "generation": 45, "fitness": 0.18057197147829154, "feedback": "The algorithm HybridDEFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.15.", "error": "", "parent_id": "e46c9b67-ff8a-427e-8f40-9cb35179604d", "metadata": {"aucs": [0.4627602255752832, 0.4627602255752832, 0.4627602255752832, 0.4216530439505627, 0.4216530439505627, 0.4216530439505627, 0.419786374215425, 0.419786374215425, 0.419786374215425, 0.04147241943656521, 0.04147241943656521, 0.04147241943656521, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009514387156847826, 0.009514387156847826, 0.009514387156847826, 0.09005459354245471, 0.09005459354245471, 0.09005459354245471, 0.08409274555606083, 0.08409274555606083, 0.08409274555606083, 0.05450511379901579, 0.05450511379901579, 0.05450511379901579, 0.06747661655337722, 0.06747661655337722, 0.06747661655337722, 0.05737283951879746, 0.05737283951879746, 0.05737283951879746, 0.0787449106135466, 0.0787449106135466, 0.0787449106135466, 0.6931125076944319, 0.6931125076944319, 0.6931125076944319, 0.11634055611341443, 0.11634055611341443, 0.11634055611341443, 0.6998626537434274, 0.6998626537434274, 0.6998626537434274, 0.28157918194398657, 0.28157918194398657, 0.28157918194398657, 0.264596270695319, 0.264596270695319, 0.264596270695319, 0.3001885217413054, 0.3001885217413054, 0.3001885217413054, 0.18651106764474068, 0.18651106764474068, 0.18651106764474068, 0.17206636214306203, 0.17206636214306203, 0.17206636214306203, 0.11832037596275824, 0.11832037596275824, 0.11832037596275824, 0.1448086702019149, 0.1448086702019149, 0.1448086702019149, 0.14557560109180923, 0.14557560109180923, 0.14557560109180923, 0.10622782995957791, 0.10622782995957791, 0.10622782995957791, 0.1503674279151359, 0.1503674279151359, 0.1503674279151359, 0.1669803133183153, 0.1669803133183153, 0.1669803133183153, 0.1538457917806687, 0.1538457917806687, 0.1538457917806687, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011536960102515703, 0.011536960102515703, 0.011536960102515703, 0.01645295386854073, 0.01645295386854073, 0.01645295386854073, 0.11021928018100702, 0.11021928018100702, 0.11021928018100702, 0.05913953519782522, 0.05913953519782522, 0.05913953519782522, 0.08076731582297703, 0.08076731582297703, 0.08076731582297703, 0.007544953690151623, 0.007544953690151623, 0.007544953690151623, 0.01640949033548733, 0.01640949033548733, 0.01640949033548733, 0.0077821505272895886, 0.0077821505272895886, 0.0077821505272895886, 0.08830776014545594, 0.08830776014545594, 0.08830776014545594, 0.07934534491235479, 0.07934534491235479, 0.07934534491235479, 0.10002055813021848, 0.10002055813021848, 0.10002055813021848, 0.4020068215836995, 0.4020068215836995, 0.4020068215836995, 0.3812942058836598, 0.3812942058836598, 0.3812942058836598, 0.36982852693114987, 0.36982852693114987, 0.36982852693114987, 0.10311111238399284, 0.10311111238399284, 0.10311111238399284, 0.12018506305489862, 0.12018506305489862, 0.12018506305489862, 0.0792748145787664, 0.0792748145787664, 0.0792748145787664, 0.15051725646812464, 0.15051725646812464, 0.15051725646812464, 0.20447454022550837, 0.20447454022550837, 0.20447454022550837, 0.20042948780086545, 0.20042948780086545, 0.20042948780086545, 0.2612666451984512, 0.2612666451984512, 0.2612666451984512, 0.2016722837836077, 0.2016722837836077, 0.2016722837836077, 0.2846524717096901, 0.2846524717096901, 0.2846524717096901, 0.21008164430340237, 0.21008164430340237, 0.21008164430340237, 0.17263686805923062, 0.17263686805923062, 0.17263686805923062, 0.13616209583995464, 0.13616209583995464, 0.13616209583995464, 0.19811422720069916, 0.19811422720069916, 0.19811422720069916, 0.18338545961063268, 0.18338545961063268, 0.18338545961063268, 0.2135679149636941, 0.2135679149636941, 0.2135679149636941, 0.18428847964462103, 0.18428847964462103, 0.18428847964462103, 0.15606241670528476, 0.15606241670528476, 0.15606241670528476, 0.1495820002094953, 0.1495820002094953, 0.1495820002094953, 0.16053810045212646, 0.16053810045212646, 0.16053810045212646, 0.17358910257825755, 0.17358910257825755, 0.17358910257825755, 0.5793952884068209, 0.5793952884068209, 0.5793952884068209, 0.24807603266044465, 0.24807603266044465, 0.24807603266044465, 0.4621037081080899, 0.4621037081080899, 0.4621037081080899, 0.1964918576019149, 0.1964918576019149, 0.1964918576019149, 0.18240042332287398, 0.18240042332287398, 0.18240042332287398, 0.18027560145480714, 0.18027560145480714, 0.18027560145480714, 0.18963533704009383, 0.18963533704009383, 0.18963533704009383, 0.06393251822880697, 0.06393251822880697, 0.06393251822880697, 0.0707841790656778, 0.0707841790656778, 0.0707841790656778, 0.06582275659602033, 0.06582275659602033, 0.06582275659602033]}, "mutation_prompt": null}
{"id": "78aad3f8-427f-494e-9435-0457b7257499", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n        self.success_history = []\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            # Update crossover rate based on fitness variance\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation with enhanced dynamic mutation factor\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * np.sqrt(1 - (budget_used / self.budget))\n                if self.success_history:  # Adapt mutation factor based on success history\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover with adaptive crossover rate\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(0.1)  # Record success\n                else:\n                    self.success_history.append(-0.1)\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        # Adaptive alpha for dynamic search balance\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            # Adjust population size based on fitness diversity\n            if np.std(fitness) < 1e-3:  # Population converged\n                self.population_size = max(10, self.population_size - 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Introduce a dynamic mutation factor that favors exploration during early iterations and intensifies exploitation as the budget is consumed.", "configspace": "", "generation": 46, "fitness": 0.1852235739136919, "feedback": "The algorithm HybridDEFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.16.", "error": "", "parent_id": "e46c9b67-ff8a-427e-8f40-9cb35179604d", "metadata": {"aucs": [0.4523075781468743, 0.4523075781468743, 0.4523075781468743, 0.43178590878250733, 0.43178590878250733, 0.43178590878250733, 0.3981929535736809, 0.3981929535736809, 0.3981929535736809, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09590962258044577, 0.09590962258044577, 0.09590962258044577, 0.08036687071800608, 0.08036687071800608, 0.08036687071800608, 0.102976952321854, 0.102976952321854, 0.102976952321854, 0.07048876503598744, 0.07048876503598744, 0.07048876503598744, 0.07867635247236082, 0.07867635247236082, 0.07867635247236082, 0.09854730143577739, 0.09854730143577739, 0.09854730143577739, 0.6161616118506373, 0.6161616118506373, 0.6161616118506373, 0.16254411125938006, 0.16254411125938006, 0.16254411125938006, 0.7754034904581499, 0.7754034904581499, 0.7754034904581499, 0.2563828844128275, 0.2563828844128275, 0.2563828844128275, 0.25941791332860853, 0.25941791332860853, 0.25941791332860853, 0.2907623192693254, 0.2907623192693254, 0.2907623192693254, 0.11223285885366008, 0.11223285885366008, 0.11223285885366008, 0.18783757255063416, 0.18783757255063416, 0.18783757255063416, 0.109162465411479, 0.109162465411479, 0.109162465411479, 0.13821501657442115, 0.13821501657442115, 0.13821501657442115, 0.13478914019244326, 0.13478914019244326, 0.13478914019244326, 0.15310954430122203, 0.15310954430122203, 0.15310954430122203, 0.16730626415679495, 0.16730626415679495, 0.16730626415679495, 0.13999274868013578, 0.13999274868013578, 0.13999274868013578, 0.16520941111390508, 0.16520941111390508, 0.16520941111390508, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.038637900289682725, 0.038637900289682725, 0.038637900289682725, 0.011613843691952619, 0.011613843691952619, 0.011613843691952619, 0.06254063628197404, 0.06254063628197404, 0.06254063628197404, 0.059277812735827884, 0.059277812735827884, 0.059277812735827884, 0.0741151904084194, 0.0741151904084194, 0.0741151904084194, 0.008409281649905509, 0.008409281649905509, 0.008409281649905509, 0.003049395630699836, 0.003049395630699836, 0.003049395630699836, 0.011427344565456798, 0.011427344565456798, 0.011427344565456798, 0.06056396095299055, 0.06056396095299055, 0.06056396095299055, 0.10878864956498868, 0.10878864956498868, 0.10878864956498868, 0.07512538432743965, 0.07512538432743965, 0.07512538432743965, 0.38785385459343136, 0.38785385459343136, 0.38785385459343136, 0.39978020842859874, 0.39978020842859874, 0.39978020842859874, 0.36932121806726137, 0.36932121806726137, 0.36932121806726137, 0.0778347807309887, 0.0778347807309887, 0.0778347807309887, 0.04313322934294461, 0.04313322934294461, 0.04313322934294461, 0.06973470175355034, 0.06973470175355034, 0.06973470175355034, 0.14194989778844735, 0.14194989778844735, 0.14194989778844735, 0.1392909653606621, 0.1392909653606621, 0.1392909653606621, 0.16277322050169973, 0.16277322050169973, 0.16277322050169973, 0.28130689754711913, 0.28130689754711913, 0.28130689754711913, 0.23196288698178857, 0.23196288698178857, 0.23196288698178857, 0.2752656862385744, 0.2752656862385744, 0.2752656862385744, 0.16636442833329035, 0.16636442833329035, 0.16636442833329035, 0.20287015485927884, 0.20287015485927884, 0.20287015485927884, 0.17446334351929182, 0.17446334351929182, 0.17446334351929182, 0.19703738818359362, 0.19703738818359362, 0.19703738818359362, 0.17832971995121438, 0.17832971995121438, 0.17832971995121438, 0.17937289859235717, 0.17937289859235717, 0.17937289859235717, 0.18381524675983574, 0.18381524675983574, 0.18381524675983574, 0.1680337320618024, 0.1680337320618024, 0.1680337320618024, 0.1646294777068097, 0.1646294777068097, 0.1646294777068097, 0.4896700197384233, 0.4896700197384233, 0.4896700197384233, 0.17355013471900438, 0.17355013471900438, 0.17355013471900438, 0.5200736238964538, 0.5200736238964538, 0.5200736238964538, 0.4972452536575672, 0.4972452536575672, 0.4972452536575672, 0.4964110864185928, 0.4964110864185928, 0.4964110864185928, 0.19483780578034882, 0.19483780578034882, 0.19483780578034882, 0.19379647119954102, 0.19379647119954102, 0.19379647119954102, 0.18070008133584703, 0.18070008133584703, 0.18070008133584703, 0.18226306740801357, 0.18226306740801357, 0.18226306740801357, 0.08574461993744387, 0.08574461993744387, 0.08574461993744387, 0.06714113504757058, 0.06714113504757058, 0.06714113504757058, 0.06781102776401404, 0.06781102776401404, 0.06781102776401404]}, "mutation_prompt": null}
{"id": "f9a4f9a6-76b8-484c-b798-9d076855f756", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n        self.success_history = []\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            # Update crossover rate based on fitness variance\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation with dynamic mutation factor\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:  # Adapt mutation factor based on success history\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover with adaptive crossover rate\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(0.1)  # Record success\n                else:\n                    self.success_history.append(-0.1)\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        # Adaptive alpha for dynamic search balance\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            # Adjust population size based on fitness diversity\n            if np.std(fitness) < 1e-3:  # Population converged\n                self.population_size = max(10, self.population_size - 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Introduce a mutation strategy based on success history to improve adaptability and ensure robust exploration.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e46c9b67-ff8a-427e-8f40-9cb35179604d", "metadata": {"aucs": [0.4418200410432245, 0.4418200410432245, 0.4418200410432245, 0.4217665546150817, 0.4217665546150817, 0.4217665546150817, 0.40527422068216257, 0.40527422068216257, 0.40527422068216257, 0.028532069031713347, 0.028532069031713347, 0.028532069031713347, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.039531225577675855, 0.039531225577675855, 0.039531225577675855, 0.08728454753950332, 0.08728454753950332, 0.08728454753950332, 0.09693725270102782, 0.09693725270102782, 0.09693725270102782, 0.09158762346257643, 0.09158762346257643, 0.09158762346257643, 0.07735024182410433, 0.07735024182410433, 0.07735024182410433, 0.08678547212285903, 0.08678547212285903, 0.08678547212285903, 0.08028430275436571, 0.08028430275436571, 0.08028430275436571, 0.6820988542308967, 0.6820988542308967, 0.6820988542308967, 0.6805424781973158, 0.6805424781973158, 0.6805424781973158, 0.7302517078985535, 0.7302517078985535, 0.7302517078985535, 0.26718795392276384, 0.26718795392276384, 0.26718795392276384, 0.26323878233985554, 0.26323878233985554, 0.26323878233985554, 0.2919722914049717, 0.2919722914049717, 0.2919722914049717, 0.12471594910095285, 0.12471594910095285, 0.12471594910095285, 0.46105336991312085, 0.46105336991312085, 0.46105336991312085, 0.10151175916995925, 0.10151175916995925, 0.10151175916995925, 0.10891778964255305, 0.10891778964255305, 0.10891778964255305, 0.14973758113973146, 0.14973758113973146, 0.14973758113973146, 0.10566033461483271, 0.10566033461483271, 0.10566033461483271, 0.12513329913438098, 0.12513329913438098, 0.12513329913438098, 0.15754966202884968, 0.15754966202884968, 0.15754966202884968, 0.16043621789362728, 0.16043621789362728, 0.16043621789362728, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012541357940420883, 0.012541357940420883, 0.012541357940420883, 0.013690220610890869, 0.013690220610890869, 0.013690220610890869, 0.06820595477458924, 0.06820595477458924, 0.06820595477458924, 0.04969733430862633, 0.04969733430862633, 0.04969733430862633, 0.0785298959601125, 0.0785298959601125, 0.0785298959601125, 0.015342070101057259, 0.015342070101057259, 0.015342070101057259, 0.010950636064003483, 0.010950636064003483, 0.010950636064003483, 0.008178122179740455, 0.008178122179740455, 0.008178122179740455, 0.03777108429549847, 0.03777108429549847, 0.03777108429549847, 0.08348823266928507, 0.08348823266928507, 0.08348823266928507, 0.07365795331362956, 0.07365795331362956, 0.07365795331362956, 0.3864751860311392, 0.3864751860311392, 0.3864751860311392, 0.38403496823851235, 0.38403496823851235, 0.38403496823851235, 0.3660060262339697, 0.3660060262339697, 0.3660060262339697, 0.09308243037701214, 0.09308243037701214, 0.09308243037701214, 0.089609468573836, 0.089609468573836, 0.089609468573836, 0.0629427839085609, 0.0629427839085609, 0.0629427839085609, 0.14158291724646932, 0.14158291724646932, 0.14158291724646932, 0.18094916192793098, 0.18094916192793098, 0.18094916192793098, 0.15904977865468461, 0.15904977865468461, 0.15904977865468461, 0.2182021300876299, 0.2182021300876299, 0.2182021300876299, 0.16708509824611484, 0.16708509824611484, 0.16708509824611484, 0.2672056234088729, 0.2672056234088729, 0.2672056234088729, 0.16194424212444536, 0.16194424212444536, 0.16194424212444536, 0.1462426800787514, 0.1462426800787514, 0.1462426800787514, 0.10727393109062344, 0.10727393109062344, 0.10727393109062344, 0.18917481593134466, 0.18917481593134466, 0.18917481593134466, 0.1755590450393174, 0.1755590450393174, 0.1755590450393174, 0.19145722365842843, 0.19145722365842843, 0.19145722365842843, 0.16768736809447804, 0.16768736809447804, 0.16768736809447804, 0.17468121819179905, 0.17468121819179905, 0.17468121819179905, 0.1501349250146854, 0.1501349250146854, 0.1501349250146854, 0.6163075971032527, 0.6163075971032527, 0.6163075971032527, 0.17337638462382254, 0.17337638462382254, 0.17337638462382254, 0.5817286651398476, 0.5817286651398476, 0.5817286651398476, 0.14176045177026864, 0.14176045177026864, 0.14176045177026864, 0.3449081489230035, 0.3449081489230035, 0.3449081489230035, 0.19718409031201334, 0.19718409031201334, 0.19718409031201334, 0.1919284319723954, 0.1919284319723954, 0.1919284319723954, 0.19137252970873653, 0.19137252970873653, 0.19137252970873653, 0.1832689920511058, 0.1832689920511058, 0.1832689920511058, 0.07489947165618638, 0.07489947165618638, 0.07489947165618638, 0.08116966741223719, 0.08116966741223719, 0.08116966741223719, 0.06714223745612558, 0.06714223745612558, 0.06714223745612558]}, "mutation_prompt": null}
{"id": "ccbda2ca-a184-4fae-89ea-b5ee481ce54d", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n        self.success_history = []\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            # Update crossover rate based on fitness variance\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation with dynamic mutation factor\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:  # Adapt mutation factor based on success history\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover with adaptive crossover rate\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(0.1)  # Record success\n                else:\n                    self.success_history.append(-0.1)\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        # Dynamically adjust gamma for better convergence\n                        adaptive_gamma = self.gamma * (1 + np.mean(self.success_history))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            # Adjust population size based on fitness diversity\n            if np.std(fitness) < 1e-3:  # Population converged\n                self.population_size = max(10, self.population_size - 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Enhance convergence by dynamically adjusting the light absorption coefficient and mutation factor based on success history and exploration balance.", "configspace": "", "generation": 48, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'adaptive_alpha' is not defined\").", "error": "NameError(\"name 'adaptive_alpha' is not defined\")", "parent_id": "e46c9b67-ff8a-427e-8f40-9cb35179604d", "metadata": {}, "mutation_prompt": null}
{"id": "f786645b-f3e5-4b98-b449-1d3e20291019", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n        self.success_history = []\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            # Update crossover rate based on fitness variance\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation with dynamic mutation factor\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:  # Adapt mutation factor based on success history\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover with adaptive crossover rate\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(0.1)  # Record success\n                else:\n                    self.success_history.append(-0.1)\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        # Adaptive alpha for dynamic search balance\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            # Adjust population size based on fitness diversity\n            if np.std(fitness) < 1e-3:  # Population converged\n                self.population_size = max(10, self.population_size - 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Introduce a mutation strategy based on success history to improve adaptability and ensure robust exploration.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e46c9b67-ff8a-427e-8f40-9cb35179604d", "metadata": {"aucs": [0.4418200410432245, 0.4418200410432245, 0.4418200410432245, 0.4217665546150817, 0.4217665546150817, 0.4217665546150817, 0.40527422068216257, 0.40527422068216257, 0.40527422068216257, 0.028532069031713347, 0.028532069031713347, 0.028532069031713347, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.039531225577675855, 0.039531225577675855, 0.039531225577675855, 0.08728454753950332, 0.08728454753950332, 0.08728454753950332, 0.09693725270102782, 0.09693725270102782, 0.09693725270102782, 0.09158762346257643, 0.09158762346257643, 0.09158762346257643, 0.07735024182410433, 0.07735024182410433, 0.07735024182410433, 0.08678547212285903, 0.08678547212285903, 0.08678547212285903, 0.08028430275436571, 0.08028430275436571, 0.08028430275436571, 0.6820988542308967, 0.6820988542308967, 0.6820988542308967, 0.6805424781973158, 0.6805424781973158, 0.6805424781973158, 0.7302517078985535, 0.7302517078985535, 0.7302517078985535, 0.26718795392276384, 0.26718795392276384, 0.26718795392276384, 0.26323878233985554, 0.26323878233985554, 0.26323878233985554, 0.2919722914049717, 0.2919722914049717, 0.2919722914049717, 0.12471594910095285, 0.12471594910095285, 0.12471594910095285, 0.46105336991312085, 0.46105336991312085, 0.46105336991312085, 0.10151175916995925, 0.10151175916995925, 0.10151175916995925, 0.10891778964255305, 0.10891778964255305, 0.10891778964255305, 0.14973758113973146, 0.14973758113973146, 0.14973758113973146, 0.10566033461483271, 0.10566033461483271, 0.10566033461483271, 0.12513329913438098, 0.12513329913438098, 0.12513329913438098, 0.15754966202884968, 0.15754966202884968, 0.15754966202884968, 0.16043621789362728, 0.16043621789362728, 0.16043621789362728, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012541357940420883, 0.012541357940420883, 0.012541357940420883, 0.013690220610890869, 0.013690220610890869, 0.013690220610890869, 0.06820595477458924, 0.06820595477458924, 0.06820595477458924, 0.04969733430862633, 0.04969733430862633, 0.04969733430862633, 0.0785298959601125, 0.0785298959601125, 0.0785298959601125, 0.015342070101057259, 0.015342070101057259, 0.015342070101057259, 0.010950636064003483, 0.010950636064003483, 0.010950636064003483, 0.008178122179740455, 0.008178122179740455, 0.008178122179740455, 0.03777108429549847, 0.03777108429549847, 0.03777108429549847, 0.08348823266928507, 0.08348823266928507, 0.08348823266928507, 0.07365795331362956, 0.07365795331362956, 0.07365795331362956, 0.3864751860311392, 0.3864751860311392, 0.3864751860311392, 0.38403496823851235, 0.38403496823851235, 0.38403496823851235, 0.3660060262339697, 0.3660060262339697, 0.3660060262339697, 0.09308243037701214, 0.09308243037701214, 0.09308243037701214, 0.089609468573836, 0.089609468573836, 0.089609468573836, 0.0629427839085609, 0.0629427839085609, 0.0629427839085609, 0.14158291724646932, 0.14158291724646932, 0.14158291724646932, 0.18094916192793098, 0.18094916192793098, 0.18094916192793098, 0.15904977865468461, 0.15904977865468461, 0.15904977865468461, 0.2182021300876299, 0.2182021300876299, 0.2182021300876299, 0.16708509824611484, 0.16708509824611484, 0.16708509824611484, 0.2672056234088729, 0.2672056234088729, 0.2672056234088729, 0.16194424212444536, 0.16194424212444536, 0.16194424212444536, 0.1462426800787514, 0.1462426800787514, 0.1462426800787514, 0.10727393109062344, 0.10727393109062344, 0.10727393109062344, 0.18917481593134466, 0.18917481593134466, 0.18917481593134466, 0.1755590450393174, 0.1755590450393174, 0.1755590450393174, 0.19145722365842843, 0.19145722365842843, 0.19145722365842843, 0.16768736809447804, 0.16768736809447804, 0.16768736809447804, 0.17468121819179905, 0.17468121819179905, 0.17468121819179905, 0.1501349250146854, 0.1501349250146854, 0.1501349250146854, 0.6163075971032527, 0.6163075971032527, 0.6163075971032527, 0.17337638462382254, 0.17337638462382254, 0.17337638462382254, 0.5817286651398476, 0.5817286651398476, 0.5817286651398476, 0.14176045177026864, 0.14176045177026864, 0.14176045177026864, 0.3449081489230035, 0.3449081489230035, 0.3449081489230035, 0.19718409031201334, 0.19718409031201334, 0.19718409031201334, 0.1919284319723954, 0.1919284319723954, 0.1919284319723954, 0.19137252970873653, 0.19137252970873653, 0.19137252970873653, 0.1832689920511058, 0.1832689920511058, 0.1832689920511058, 0.07489947165618638, 0.07489947165618638, 0.07489947165618638, 0.08116966741223719, 0.08116966741223719, 0.08116966741223719, 0.06714223745612558, 0.06714223745612558, 0.06714223745612558]}, "mutation_prompt": null}
{"id": "e37f4f43-a300-4f76-8c61-b5d8e83ce7e1", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n        self.success_history = []\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            # Update crossover rate based on fitness variance\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation with dynamic mutation factor\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:  # Adapt mutation factor based on success history\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover with adaptive crossover rate\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(0.1)  # Record success\n                else:\n                    self.success_history.append(-0.1)\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        # Adaptive alpha for dynamic search balance\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            # Adjust population size based on fitness diversity\n            if np.std(fitness) < 1e-3:  # Population converged\n                self.population_size = max(10, self.population_size - 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Introduce a mutation strategy based on success history to improve adaptability and ensure robust exploration.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e46c9b67-ff8a-427e-8f40-9cb35179604d", "metadata": {"aucs": [0.4418200410432245, 0.4418200410432245, 0.4418200410432245, 0.4217665546150817, 0.4217665546150817, 0.4217665546150817, 0.40527422068216257, 0.40527422068216257, 0.40527422068216257, 0.028532069031713347, 0.028532069031713347, 0.028532069031713347, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.039531225577675855, 0.039531225577675855, 0.039531225577675855, 0.08728454753950332, 0.08728454753950332, 0.08728454753950332, 0.09693725270102782, 0.09693725270102782, 0.09693725270102782, 0.09158762346257643, 0.09158762346257643, 0.09158762346257643, 0.07735024182410433, 0.07735024182410433, 0.07735024182410433, 0.08678547212285903, 0.08678547212285903, 0.08678547212285903, 0.08028430275436571, 0.08028430275436571, 0.08028430275436571, 0.6820988542308967, 0.6820988542308967, 0.6820988542308967, 0.6805424781973158, 0.6805424781973158, 0.6805424781973158, 0.7302517078985535, 0.7302517078985535, 0.7302517078985535, 0.26718795392276384, 0.26718795392276384, 0.26718795392276384, 0.26323878233985554, 0.26323878233985554, 0.26323878233985554, 0.2919722914049717, 0.2919722914049717, 0.2919722914049717, 0.12471594910095285, 0.12471594910095285, 0.12471594910095285, 0.46105336991312085, 0.46105336991312085, 0.46105336991312085, 0.10151175916995925, 0.10151175916995925, 0.10151175916995925, 0.10891778964255305, 0.10891778964255305, 0.10891778964255305, 0.14973758113973146, 0.14973758113973146, 0.14973758113973146, 0.10566033461483271, 0.10566033461483271, 0.10566033461483271, 0.12513329913438098, 0.12513329913438098, 0.12513329913438098, 0.15754966202884968, 0.15754966202884968, 0.15754966202884968, 0.16043621789362728, 0.16043621789362728, 0.16043621789362728, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012541357940420883, 0.012541357940420883, 0.012541357940420883, 0.013690220610890869, 0.013690220610890869, 0.013690220610890869, 0.06820595477458924, 0.06820595477458924, 0.06820595477458924, 0.04969733430862633, 0.04969733430862633, 0.04969733430862633, 0.0785298959601125, 0.0785298959601125, 0.0785298959601125, 0.015342070101057259, 0.015342070101057259, 0.015342070101057259, 0.010950636064003483, 0.010950636064003483, 0.010950636064003483, 0.008178122179740455, 0.008178122179740455, 0.008178122179740455, 0.03777108429549847, 0.03777108429549847, 0.03777108429549847, 0.08348823266928507, 0.08348823266928507, 0.08348823266928507, 0.07365795331362956, 0.07365795331362956, 0.07365795331362956, 0.3864751860311392, 0.3864751860311392, 0.3864751860311392, 0.38403496823851235, 0.38403496823851235, 0.38403496823851235, 0.3660060262339697, 0.3660060262339697, 0.3660060262339697, 0.09308243037701214, 0.09308243037701214, 0.09308243037701214, 0.089609468573836, 0.089609468573836, 0.089609468573836, 0.0629427839085609, 0.0629427839085609, 0.0629427839085609, 0.14158291724646932, 0.14158291724646932, 0.14158291724646932, 0.18094916192793098, 0.18094916192793098, 0.18094916192793098, 0.15904977865468461, 0.15904977865468461, 0.15904977865468461, 0.2182021300876299, 0.2182021300876299, 0.2182021300876299, 0.16708509824611484, 0.16708509824611484, 0.16708509824611484, 0.2672056234088729, 0.2672056234088729, 0.2672056234088729, 0.16194424212444536, 0.16194424212444536, 0.16194424212444536, 0.1462426800787514, 0.1462426800787514, 0.1462426800787514, 0.10727393109062344, 0.10727393109062344, 0.10727393109062344, 0.18917481593134466, 0.18917481593134466, 0.18917481593134466, 0.1755590450393174, 0.1755590450393174, 0.1755590450393174, 0.19145722365842843, 0.19145722365842843, 0.19145722365842843, 0.16768736809447804, 0.16768736809447804, 0.16768736809447804, 0.17468121819179905, 0.17468121819179905, 0.17468121819179905, 0.1501349250146854, 0.1501349250146854, 0.1501349250146854, 0.6163075971032527, 0.6163075971032527, 0.6163075971032527, 0.17337638462382254, 0.17337638462382254, 0.17337638462382254, 0.5817286651398476, 0.5817286651398476, 0.5817286651398476, 0.14176045177026864, 0.14176045177026864, 0.14176045177026864, 0.3449081489230035, 0.3449081489230035, 0.3449081489230035, 0.19718409031201334, 0.19718409031201334, 0.19718409031201334, 0.1919284319723954, 0.1919284319723954, 0.1919284319723954, 0.19137252970873653, 0.19137252970873653, 0.19137252970873653, 0.1832689920511058, 0.1832689920511058, 0.1832689920511058, 0.07489947165618638, 0.07489947165618638, 0.07489947165618638, 0.08116966741223719, 0.08116966741223719, 0.08116966741223719, 0.06714223745612558, 0.06714223745612558, 0.06714223745612558]}, "mutation_prompt": null}
{"id": "78fca364-b91c-4c44-8a7b-3f974e13aac5", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n        self.success_history = []\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            # Update crossover rate based on fitness variance\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation with dynamic mutation factor\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:  # Adapt mutation factor based on success history\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover with adaptive crossover rate\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(0.1)  # Record success\n                else:\n                    self.success_history.append(-0.1)\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        # Adaptive alpha for dynamic search balance\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            # Adjust population size based on fitness diversity\n            if np.std(fitness) < 1e-3:  # Population converged\n                self.population_size = max(10, self.population_size - 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Introduce a mutation strategy based on success history to improve adaptability and ensure robust exploration.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e46c9b67-ff8a-427e-8f40-9cb35179604d", "metadata": {"aucs": [0.4418200410432245, 0.4418200410432245, 0.4418200410432245, 0.4217665546150817, 0.4217665546150817, 0.4217665546150817, 0.40527422068216257, 0.40527422068216257, 0.40527422068216257, 0.028532069031713347, 0.028532069031713347, 0.028532069031713347, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.039531225577675855, 0.039531225577675855, 0.039531225577675855, 0.08728454753950332, 0.08728454753950332, 0.08728454753950332, 0.09693725270102782, 0.09693725270102782, 0.09693725270102782, 0.09158762346257643, 0.09158762346257643, 0.09158762346257643, 0.07735024182410433, 0.07735024182410433, 0.07735024182410433, 0.08678547212285903, 0.08678547212285903, 0.08678547212285903, 0.08028430275436571, 0.08028430275436571, 0.08028430275436571, 0.6820988542308967, 0.6820988542308967, 0.6820988542308967, 0.6805424781973158, 0.6805424781973158, 0.6805424781973158, 0.7302517078985535, 0.7302517078985535, 0.7302517078985535, 0.26718795392276384, 0.26718795392276384, 0.26718795392276384, 0.26323878233985554, 0.26323878233985554, 0.26323878233985554, 0.2919722914049717, 0.2919722914049717, 0.2919722914049717, 0.12471594910095285, 0.12471594910095285, 0.12471594910095285, 0.46105336991312085, 0.46105336991312085, 0.46105336991312085, 0.10151175916995925, 0.10151175916995925, 0.10151175916995925, 0.10891778964255305, 0.10891778964255305, 0.10891778964255305, 0.14973758113973146, 0.14973758113973146, 0.14973758113973146, 0.10566033461483271, 0.10566033461483271, 0.10566033461483271, 0.12513329913438098, 0.12513329913438098, 0.12513329913438098, 0.15754966202884968, 0.15754966202884968, 0.15754966202884968, 0.16043621789362728, 0.16043621789362728, 0.16043621789362728, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012541357940420883, 0.012541357940420883, 0.012541357940420883, 0.013690220610890869, 0.013690220610890869, 0.013690220610890869, 0.06820595477458924, 0.06820595477458924, 0.06820595477458924, 0.04969733430862633, 0.04969733430862633, 0.04969733430862633, 0.0785298959601125, 0.0785298959601125, 0.0785298959601125, 0.015342070101057259, 0.015342070101057259, 0.015342070101057259, 0.010950636064003483, 0.010950636064003483, 0.010950636064003483, 0.008178122179740455, 0.008178122179740455, 0.008178122179740455, 0.03777108429549847, 0.03777108429549847, 0.03777108429549847, 0.08348823266928507, 0.08348823266928507, 0.08348823266928507, 0.07365795331362956, 0.07365795331362956, 0.07365795331362956, 0.3864751860311392, 0.3864751860311392, 0.3864751860311392, 0.38403496823851235, 0.38403496823851235, 0.38403496823851235, 0.3660060262339697, 0.3660060262339697, 0.3660060262339697, 0.09308243037701214, 0.09308243037701214, 0.09308243037701214, 0.089609468573836, 0.089609468573836, 0.089609468573836, 0.0629427839085609, 0.0629427839085609, 0.0629427839085609, 0.14158291724646932, 0.14158291724646932, 0.14158291724646932, 0.18094916192793098, 0.18094916192793098, 0.18094916192793098, 0.15904977865468461, 0.15904977865468461, 0.15904977865468461, 0.2182021300876299, 0.2182021300876299, 0.2182021300876299, 0.16708509824611484, 0.16708509824611484, 0.16708509824611484, 0.2672056234088729, 0.2672056234088729, 0.2672056234088729, 0.16194424212444536, 0.16194424212444536, 0.16194424212444536, 0.1462426800787514, 0.1462426800787514, 0.1462426800787514, 0.10727393109062344, 0.10727393109062344, 0.10727393109062344, 0.18917481593134466, 0.18917481593134466, 0.18917481593134466, 0.1755590450393174, 0.1755590450393174, 0.1755590450393174, 0.19145722365842843, 0.19145722365842843, 0.19145722365842843, 0.16768736809447804, 0.16768736809447804, 0.16768736809447804, 0.17468121819179905, 0.17468121819179905, 0.17468121819179905, 0.1501349250146854, 0.1501349250146854, 0.1501349250146854, 0.6163075971032527, 0.6163075971032527, 0.6163075971032527, 0.17337638462382254, 0.17337638462382254, 0.17337638462382254, 0.5817286651398476, 0.5817286651398476, 0.5817286651398476, 0.14176045177026864, 0.14176045177026864, 0.14176045177026864, 0.3449081489230035, 0.3449081489230035, 0.3449081489230035, 0.19718409031201334, 0.19718409031201334, 0.19718409031201334, 0.1919284319723954, 0.1919284319723954, 0.1919284319723954, 0.19137252970873653, 0.19137252970873653, 0.19137252970873653, 0.1832689920511058, 0.1832689920511058, 0.1832689920511058, 0.07489947165618638, 0.07489947165618638, 0.07489947165618638, 0.08116966741223719, 0.08116966741223719, 0.08116966741223719, 0.06714223745612558, 0.06714223745612558, 0.06714223745612558]}, "mutation_prompt": null}
{"id": "5a1c3096-8c5f-4528-88f3-67601a6405e4", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n        self.success_history = []\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            # Update crossover rate based on fitness variance\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation with dynamic mutation factor\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:  # Adapt mutation factor based on success history\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover with adaptive crossover rate\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(0.1)  # Record success\n                else:\n                    self.success_history.append(-0.1)\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        # Adaptive alpha for dynamic search balance\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            # Adjust population size based on fitness diversity\n            if np.std(fitness) < 1e-3:  # Population converged\n                self.population_size = max(10, self.population_size - 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Introduce a mutation strategy based on success history to improve adaptability and ensure robust exploration.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e46c9b67-ff8a-427e-8f40-9cb35179604d", "metadata": {"aucs": [0.4418200410432245, 0.4418200410432245, 0.4418200410432245, 0.4217665546150817, 0.4217665546150817, 0.4217665546150817, 0.40527422068216257, 0.40527422068216257, 0.40527422068216257, 0.028532069031713347, 0.028532069031713347, 0.028532069031713347, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.039531225577675855, 0.039531225577675855, 0.039531225577675855, 0.08728454753950332, 0.08728454753950332, 0.08728454753950332, 0.09693725270102782, 0.09693725270102782, 0.09693725270102782, 0.09158762346257643, 0.09158762346257643, 0.09158762346257643, 0.07735024182410433, 0.07735024182410433, 0.07735024182410433, 0.08678547212285903, 0.08678547212285903, 0.08678547212285903, 0.08028430275436571, 0.08028430275436571, 0.08028430275436571, 0.6820988542308967, 0.6820988542308967, 0.6820988542308967, 0.6805424781973158, 0.6805424781973158, 0.6805424781973158, 0.7302517078985535, 0.7302517078985535, 0.7302517078985535, 0.26718795392276384, 0.26718795392276384, 0.26718795392276384, 0.26323878233985554, 0.26323878233985554, 0.26323878233985554, 0.2919722914049717, 0.2919722914049717, 0.2919722914049717, 0.12471594910095285, 0.12471594910095285, 0.12471594910095285, 0.46105336991312085, 0.46105336991312085, 0.46105336991312085, 0.10151175916995925, 0.10151175916995925, 0.10151175916995925, 0.10891778964255305, 0.10891778964255305, 0.10891778964255305, 0.14973758113973146, 0.14973758113973146, 0.14973758113973146, 0.10566033461483271, 0.10566033461483271, 0.10566033461483271, 0.12513329913438098, 0.12513329913438098, 0.12513329913438098, 0.15754966202884968, 0.15754966202884968, 0.15754966202884968, 0.16043621789362728, 0.16043621789362728, 0.16043621789362728, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012541357940420883, 0.012541357940420883, 0.012541357940420883, 0.013690220610890869, 0.013690220610890869, 0.013690220610890869, 0.06820595477458924, 0.06820595477458924, 0.06820595477458924, 0.04969733430862633, 0.04969733430862633, 0.04969733430862633, 0.0785298959601125, 0.0785298959601125, 0.0785298959601125, 0.015342070101057259, 0.015342070101057259, 0.015342070101057259, 0.010950636064003483, 0.010950636064003483, 0.010950636064003483, 0.008178122179740455, 0.008178122179740455, 0.008178122179740455, 0.03777108429549847, 0.03777108429549847, 0.03777108429549847, 0.08348823266928507, 0.08348823266928507, 0.08348823266928507, 0.07365795331362956, 0.07365795331362956, 0.07365795331362956, 0.3864751860311392, 0.3864751860311392, 0.3864751860311392, 0.38403496823851235, 0.38403496823851235, 0.38403496823851235, 0.3660060262339697, 0.3660060262339697, 0.3660060262339697, 0.09308243037701214, 0.09308243037701214, 0.09308243037701214, 0.089609468573836, 0.089609468573836, 0.089609468573836, 0.0629427839085609, 0.0629427839085609, 0.0629427839085609, 0.14158291724646932, 0.14158291724646932, 0.14158291724646932, 0.18094916192793098, 0.18094916192793098, 0.18094916192793098, 0.15904977865468461, 0.15904977865468461, 0.15904977865468461, 0.2182021300876299, 0.2182021300876299, 0.2182021300876299, 0.16708509824611484, 0.16708509824611484, 0.16708509824611484, 0.2672056234088729, 0.2672056234088729, 0.2672056234088729, 0.16194424212444536, 0.16194424212444536, 0.16194424212444536, 0.1462426800787514, 0.1462426800787514, 0.1462426800787514, 0.10727393109062344, 0.10727393109062344, 0.10727393109062344, 0.18917481593134466, 0.18917481593134466, 0.18917481593134466, 0.1755590450393174, 0.1755590450393174, 0.1755590450393174, 0.19145722365842843, 0.19145722365842843, 0.19145722365842843, 0.16768736809447804, 0.16768736809447804, 0.16768736809447804, 0.17468121819179905, 0.17468121819179905, 0.17468121819179905, 0.1501349250146854, 0.1501349250146854, 0.1501349250146854, 0.6163075971032527, 0.6163075971032527, 0.6163075971032527, 0.17337638462382254, 0.17337638462382254, 0.17337638462382254, 0.5817286651398476, 0.5817286651398476, 0.5817286651398476, 0.14176045177026864, 0.14176045177026864, 0.14176045177026864, 0.3449081489230035, 0.3449081489230035, 0.3449081489230035, 0.19718409031201334, 0.19718409031201334, 0.19718409031201334, 0.1919284319723954, 0.1919284319723954, 0.1919284319723954, 0.19137252970873653, 0.19137252970873653, 0.19137252970873653, 0.1832689920511058, 0.1832689920511058, 0.1832689920511058, 0.07489947165618638, 0.07489947165618638, 0.07489947165618638, 0.08116966741223719, 0.08116966741223719, 0.08116966741223719, 0.06714223745612558, 0.06714223745612558, 0.06714223745612558]}, "mutation_prompt": null}
{"id": "0c87e09a-1566-4859-b577-758e988afcce", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n        self.success_history = []\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            # Update crossover rate based on fitness variance\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation with dynamic mutation factor\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:  # Adapt mutation factor based on success history\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover with adaptive crossover rate\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(0.1)  # Record success\n                else:\n                    self.success_history.append(-0.1)\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        # Adaptive alpha for dynamic search balance\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            # Adjust population size based on fitness diversity\n            if np.std(fitness) < 1e-3:  # Population converged\n                self.population_size = max(10, self.population_size - 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Introduce a mutation strategy based on success history to improve adaptability and ensure robust exploration.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e46c9b67-ff8a-427e-8f40-9cb35179604d", "metadata": {"aucs": [0.4418200410432245, 0.4418200410432245, 0.4418200410432245, 0.4217665546150817, 0.4217665546150817, 0.4217665546150817, 0.40527422068216257, 0.40527422068216257, 0.40527422068216257, 0.028532069031713347, 0.028532069031713347, 0.028532069031713347, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.039531225577675855, 0.039531225577675855, 0.039531225577675855, 0.08728454753950332, 0.08728454753950332, 0.08728454753950332, 0.09693725270102782, 0.09693725270102782, 0.09693725270102782, 0.09158762346257643, 0.09158762346257643, 0.09158762346257643, 0.07735024182410433, 0.07735024182410433, 0.07735024182410433, 0.08678547212285903, 0.08678547212285903, 0.08678547212285903, 0.08028430275436571, 0.08028430275436571, 0.08028430275436571, 0.6820988542308967, 0.6820988542308967, 0.6820988542308967, 0.6805424781973158, 0.6805424781973158, 0.6805424781973158, 0.7302517078985535, 0.7302517078985535, 0.7302517078985535, 0.26718795392276384, 0.26718795392276384, 0.26718795392276384, 0.26323878233985554, 0.26323878233985554, 0.26323878233985554, 0.2919722914049717, 0.2919722914049717, 0.2919722914049717, 0.12471594910095285, 0.12471594910095285, 0.12471594910095285, 0.46105336991312085, 0.46105336991312085, 0.46105336991312085, 0.10151175916995925, 0.10151175916995925, 0.10151175916995925, 0.10891778964255305, 0.10891778964255305, 0.10891778964255305, 0.14973758113973146, 0.14973758113973146, 0.14973758113973146, 0.10566033461483271, 0.10566033461483271, 0.10566033461483271, 0.12513329913438098, 0.12513329913438098, 0.12513329913438098, 0.15754966202884968, 0.15754966202884968, 0.15754966202884968, 0.16043621789362728, 0.16043621789362728, 0.16043621789362728, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012541357940420883, 0.012541357940420883, 0.012541357940420883, 0.013690220610890869, 0.013690220610890869, 0.013690220610890869, 0.06820595477458924, 0.06820595477458924, 0.06820595477458924, 0.04969733430862633, 0.04969733430862633, 0.04969733430862633, 0.0785298959601125, 0.0785298959601125, 0.0785298959601125, 0.015342070101057259, 0.015342070101057259, 0.015342070101057259, 0.010950636064003483, 0.010950636064003483, 0.010950636064003483, 0.008178122179740455, 0.008178122179740455, 0.008178122179740455, 0.03777108429549847, 0.03777108429549847, 0.03777108429549847, 0.08348823266928507, 0.08348823266928507, 0.08348823266928507, 0.07365795331362956, 0.07365795331362956, 0.07365795331362956, 0.3864751860311392, 0.3864751860311392, 0.3864751860311392, 0.38403496823851235, 0.38403496823851235, 0.38403496823851235, 0.3660060262339697, 0.3660060262339697, 0.3660060262339697, 0.09308243037701214, 0.09308243037701214, 0.09308243037701214, 0.089609468573836, 0.089609468573836, 0.089609468573836, 0.0629427839085609, 0.0629427839085609, 0.0629427839085609, 0.14158291724646932, 0.14158291724646932, 0.14158291724646932, 0.18094916192793098, 0.18094916192793098, 0.18094916192793098, 0.15904977865468461, 0.15904977865468461, 0.15904977865468461, 0.2182021300876299, 0.2182021300876299, 0.2182021300876299, 0.16708509824611484, 0.16708509824611484, 0.16708509824611484, 0.2672056234088729, 0.2672056234088729, 0.2672056234088729, 0.16194424212444536, 0.16194424212444536, 0.16194424212444536, 0.1462426800787514, 0.1462426800787514, 0.1462426800787514, 0.10727393109062344, 0.10727393109062344, 0.10727393109062344, 0.18917481593134466, 0.18917481593134466, 0.18917481593134466, 0.1755590450393174, 0.1755590450393174, 0.1755590450393174, 0.19145722365842843, 0.19145722365842843, 0.19145722365842843, 0.16768736809447804, 0.16768736809447804, 0.16768736809447804, 0.17468121819179905, 0.17468121819179905, 0.17468121819179905, 0.1501349250146854, 0.1501349250146854, 0.1501349250146854, 0.6163075971032527, 0.6163075971032527, 0.6163075971032527, 0.17337638462382254, 0.17337638462382254, 0.17337638462382254, 0.5817286651398476, 0.5817286651398476, 0.5817286651398476, 0.14176045177026864, 0.14176045177026864, 0.14176045177026864, 0.3449081489230035, 0.3449081489230035, 0.3449081489230035, 0.19718409031201334, 0.19718409031201334, 0.19718409031201334, 0.1919284319723954, 0.1919284319723954, 0.1919284319723954, 0.19137252970873653, 0.19137252970873653, 0.19137252970873653, 0.1832689920511058, 0.1832689920511058, 0.1832689920511058, 0.07489947165618638, 0.07489947165618638, 0.07489947165618638, 0.08116966741223719, 0.08116966741223719, 0.08116966741223719, 0.06714223745612558, 0.06714223745612558, 0.06714223745612558]}, "mutation_prompt": null}
{"id": "1b944093-6ce8-4fdc-bc85-c2366e4b9ed4", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n        self.success_history = []\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            # Update crossover rate based on fitness variance\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation with dynamic mutation factor\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:  # Adapt mutation factor based on success history\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover with adaptive crossover rate\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(0.1)  # Record success\n                else:\n                    self.success_history.append(-0.1)\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        # Adaptive alpha for dynamic search balance\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            # Adjust population size based on fitness diversity\n            if np.std(fitness) < 1e-3:  # Population converged\n                self.population_size = max(10, self.population_size - 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Introduce a mutation strategy based on success history to improve adaptability and ensure robust exploration.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e46c9b67-ff8a-427e-8f40-9cb35179604d", "metadata": {"aucs": [0.4418200410432245, 0.4418200410432245, 0.4418200410432245, 0.4217665546150817, 0.4217665546150817, 0.4217665546150817, 0.40527422068216257, 0.40527422068216257, 0.40527422068216257, 0.028532069031713347, 0.028532069031713347, 0.028532069031713347, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.039531225577675855, 0.039531225577675855, 0.039531225577675855, 0.08728454753950332, 0.08728454753950332, 0.08728454753950332, 0.09693725270102782, 0.09693725270102782, 0.09693725270102782, 0.09158762346257643, 0.09158762346257643, 0.09158762346257643, 0.07735024182410433, 0.07735024182410433, 0.07735024182410433, 0.08678547212285903, 0.08678547212285903, 0.08678547212285903, 0.08028430275436571, 0.08028430275436571, 0.08028430275436571, 0.6820988542308967, 0.6820988542308967, 0.6820988542308967, 0.6805424781973158, 0.6805424781973158, 0.6805424781973158, 0.7302517078985535, 0.7302517078985535, 0.7302517078985535, 0.26718795392276384, 0.26718795392276384, 0.26718795392276384, 0.26323878233985554, 0.26323878233985554, 0.26323878233985554, 0.2919722914049717, 0.2919722914049717, 0.2919722914049717, 0.12471594910095285, 0.12471594910095285, 0.12471594910095285, 0.46105336991312085, 0.46105336991312085, 0.46105336991312085, 0.10151175916995925, 0.10151175916995925, 0.10151175916995925, 0.10891778964255305, 0.10891778964255305, 0.10891778964255305, 0.14973758113973146, 0.14973758113973146, 0.14973758113973146, 0.10566033461483271, 0.10566033461483271, 0.10566033461483271, 0.12513329913438098, 0.12513329913438098, 0.12513329913438098, 0.15754966202884968, 0.15754966202884968, 0.15754966202884968, 0.16043621789362728, 0.16043621789362728, 0.16043621789362728, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012541357940420883, 0.012541357940420883, 0.012541357940420883, 0.013690220610890869, 0.013690220610890869, 0.013690220610890869, 0.06820595477458924, 0.06820595477458924, 0.06820595477458924, 0.04969733430862633, 0.04969733430862633, 0.04969733430862633, 0.0785298959601125, 0.0785298959601125, 0.0785298959601125, 0.015342070101057259, 0.015342070101057259, 0.015342070101057259, 0.010950636064003483, 0.010950636064003483, 0.010950636064003483, 0.008178122179740455, 0.008178122179740455, 0.008178122179740455, 0.03777108429549847, 0.03777108429549847, 0.03777108429549847, 0.08348823266928507, 0.08348823266928507, 0.08348823266928507, 0.07365795331362956, 0.07365795331362956, 0.07365795331362956, 0.3864751860311392, 0.3864751860311392, 0.3864751860311392, 0.38403496823851235, 0.38403496823851235, 0.38403496823851235, 0.3660060262339697, 0.3660060262339697, 0.3660060262339697, 0.09308243037701214, 0.09308243037701214, 0.09308243037701214, 0.089609468573836, 0.089609468573836, 0.089609468573836, 0.0629427839085609, 0.0629427839085609, 0.0629427839085609, 0.14158291724646932, 0.14158291724646932, 0.14158291724646932, 0.18094916192793098, 0.18094916192793098, 0.18094916192793098, 0.15904977865468461, 0.15904977865468461, 0.15904977865468461, 0.2182021300876299, 0.2182021300876299, 0.2182021300876299, 0.16708509824611484, 0.16708509824611484, 0.16708509824611484, 0.2672056234088729, 0.2672056234088729, 0.2672056234088729, 0.16194424212444536, 0.16194424212444536, 0.16194424212444536, 0.1462426800787514, 0.1462426800787514, 0.1462426800787514, 0.10727393109062344, 0.10727393109062344, 0.10727393109062344, 0.18917481593134466, 0.18917481593134466, 0.18917481593134466, 0.1755590450393174, 0.1755590450393174, 0.1755590450393174, 0.19145722365842843, 0.19145722365842843, 0.19145722365842843, 0.16768736809447804, 0.16768736809447804, 0.16768736809447804, 0.17468121819179905, 0.17468121819179905, 0.17468121819179905, 0.1501349250146854, 0.1501349250146854, 0.1501349250146854, 0.6163075971032527, 0.6163075971032527, 0.6163075971032527, 0.17337638462382254, 0.17337638462382254, 0.17337638462382254, 0.5817286651398476, 0.5817286651398476, 0.5817286651398476, 0.14176045177026864, 0.14176045177026864, 0.14176045177026864, 0.3449081489230035, 0.3449081489230035, 0.3449081489230035, 0.19718409031201334, 0.19718409031201334, 0.19718409031201334, 0.1919284319723954, 0.1919284319723954, 0.1919284319723954, 0.19137252970873653, 0.19137252970873653, 0.19137252970873653, 0.1832689920511058, 0.1832689920511058, 0.1832689920511058, 0.07489947165618638, 0.07489947165618638, 0.07489947165618638, 0.08116966741223719, 0.08116966741223719, 0.08116966741223719, 0.06714223745612558, 0.06714223745612558, 0.06714223745612558]}, "mutation_prompt": null}
{"id": "7afb83c3-7b8b-470c-b464-16e093bb19d2", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n        self.success_history = []\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            # Update crossover rate based on fitness variance\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation with dynamic mutation factor\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:  # Adapt mutation factor based on success history\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover with adaptive crossover rate\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector with an adaptive fitness threshold\n                trial_fitness = func(trial)\n                adaptive_threshold = best_fitness * (1 + 0.05)  # Adaptive threshold\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i] and trial_fitness < adaptive_threshold:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(0.1)  # Record success\n                else:\n                    self.success_history.append(-0.1)\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        # Adaptive alpha for dynamic search balance\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            # Adjust population size based on fitness diversity\n            if np.std(fitness) < 1e-3:  # Population converged\n                self.population_size = max(10, self.population_size - 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Enhance mutation selection by incorporating an adaptive threshold based on the best solution.", "configspace": "", "generation": 55, "fitness": 0.11573202840908638, "feedback": "The algorithm HybridDEFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.11.", "error": "", "parent_id": "e46c9b67-ff8a-427e-8f40-9cb35179604d", "metadata": {"aucs": [0.3930435794743705, 0.3930435794743705, 0.3930435794743705, 0.4244870119404198, 0.4244870119404198, 0.4244870119404198, 0.11217148409171607, 0.11217148409171607, 0.11217148409171607, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.043672505403706596, 0.043672505403706596, 0.043672505403706596, 0.04269525771399296, 0.04269525771399296, 0.04269525771399296, 0.039496928083034955, 0.039496928083034955, 0.039496928083034955, 0.012893328187593922, 0.012893328187593922, 0.012893328187593922, 0.02076005846281659, 0.02076005846281659, 0.02076005846281659, 0.05016268802599011, 0.05016268802599011, 0.05016268802599011, 0.341127596517118, 0.341127596517118, 0.341127596517118, 0.11541268696972606, 0.11541268696972606, 0.11541268696972606, 0.6115393533352365, 0.6115393533352365, 0.6115393533352365, 0.08360920847612963, 0.08360920847612963, 0.08360920847612963, 0.13604178716668225, 0.13604178716668225, 0.13604178716668225, 0.055365505365692846, 0.055365505365692846, 0.055365505365692846, 0.12238342709387795, 0.12238342709387795, 0.12238342709387795, 0.10528876492659378, 0.10528876492659378, 0.10528876492659378, 0.09975445283417106, 0.09975445283417106, 0.09975445283417106, 0.08070454133840244, 0.08070454133840244, 0.08070454133840244, 0.047644023534088586, 0.047644023534088586, 0.047644023534088586, 0.05435057794367981, 0.05435057794367981, 0.05435057794367981, 0.0831117931978892, 0.0831117931978892, 0.0831117931978892, 0.10137768431617422, 0.10137768431617422, 0.10137768431617422, 0.04548656631368575, 0.04548656631368575, 0.04548656631368575, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0427346564506359, 0.0427346564506359, 0.0427346564506359, 0.018763161982938814, 0.018763161982938814, 0.018763161982938814, 0.022900695897770884, 0.022900695897770884, 0.022900695897770884, 0.0024234538943719297, 0.0024234538943719297, 0.0024234538943719297, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005879439424959498, 0.005879439424959498, 0.005879439424959498, 0.02087985402034742, 0.02087985402034742, 0.02087985402034742, 0.0496467324173705, 0.0496467324173705, 0.0496467324173705, 0.03980946337087132, 0.03980946337087132, 0.03980946337087132, 0.17842090562731028, 0.17842090562731028, 0.17842090562731028, 0.1513904694412337, 0.1513904694412337, 0.1513904694412337, 0.367339996959559, 0.367339996959559, 0.367339996959559, 0.10768142530981217, 0.10768142530981217, 0.10768142530981217, 0.03483648882490564, 0.03483648882490564, 0.03483648882490564, 0.05170285395047447, 0.05170285395047447, 0.05170285395047447, 0.13310687976696678, 0.13310687976696678, 0.13310687976696678, 0.13053141323971018, 0.13053141323971018, 0.13053141323971018, 0.13443852970711645, 0.13443852970711645, 0.13443852970711645, 0.1326647609791769, 0.1326647609791769, 0.1326647609791769, 0.20195578004103942, 0.20195578004103942, 0.20195578004103942, 0.26537309836626166, 0.26537309836626166, 0.26537309836626166, 0.10991931003443056, 0.10991931003443056, 0.10991931003443056, 0.11295686554456208, 0.11295686554456208, 0.11295686554456208, 0.12278603171987346, 0.12278603171987346, 0.12278603171987346, 0.12259286290954219, 0.12259286290954219, 0.12259286290954219, 0.16891463979096277, 0.16891463979096277, 0.16891463979096277, 0.22583027606465855, 0.22583027606465855, 0.22583027606465855, 0.07391283593421472, 0.07391283593421472, 0.07391283593421472, 0.07290301360390805, 0.07290301360390805, 0.07290301360390805, 0.11195453202202132, 0.11195453202202132, 0.11195453202202132, 0.37342056302755877, 0.37342056302755877, 0.37342056302755877, 0.19495987049120556, 0.19495987049120556, 0.19495987049120556, 0.18672224979117302, 0.18672224979117302, 0.18672224979117302, 0.14705830677672982, 0.14705830677672982, 0.14705830677672982, 0.1461053932361729, 0.1461053932361729, 0.1461053932361729, 0.1469384585083897, 0.1469384585083897, 0.1469384585083897, 0.20469975975921884, 0.20469975975921884, 0.20469975975921884, 0.18624230966436495, 0.18624230966436495, 0.18624230966436495, 0.18384266956179451, 0.18384266956179451, 0.18384266956179451, 0.04553634882067348, 0.04553634882067348, 0.04553634882067348, 0.04214885232369603, 0.04214885232369603, 0.04214885232369603, 0.03750002548344433, 0.03750002548344433, 0.03750002548344433]}, "mutation_prompt": null}
{"id": "04005d29-e2c4-4b08-8f6b-2e2e6c431a8a", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n        self.success_history = []\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            # Update crossover rate based on fitness variance\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation with dynamic mutation factor\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:  # Adapt mutation factor based on success history\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover with adaptive crossover rate\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(0.1)  # Record success\n                else:\n                    self.success_history.append(-0.1)\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        # Adaptive alpha for dynamic search balance\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            # Adjust population size based on fitness diversity\n            if np.std(fitness) < 1e-3:  # Population converged\n                self.population_size = max(10, self.population_size - 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Introduce a mutation strategy based on success history to improve adaptability and ensure robust exploration.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e46c9b67-ff8a-427e-8f40-9cb35179604d", "metadata": {"aucs": [0.4418200410432245, 0.4418200410432245, 0.4418200410432245, 0.4217665546150817, 0.4217665546150817, 0.4217665546150817, 0.40527422068216257, 0.40527422068216257, 0.40527422068216257, 0.028532069031713347, 0.028532069031713347, 0.028532069031713347, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.039531225577675855, 0.039531225577675855, 0.039531225577675855, 0.08728454753950332, 0.08728454753950332, 0.08728454753950332, 0.09693725270102782, 0.09693725270102782, 0.09693725270102782, 0.09158762346257643, 0.09158762346257643, 0.09158762346257643, 0.07735024182410433, 0.07735024182410433, 0.07735024182410433, 0.08678547212285903, 0.08678547212285903, 0.08678547212285903, 0.08028430275436571, 0.08028430275436571, 0.08028430275436571, 0.6820988542308967, 0.6820988542308967, 0.6820988542308967, 0.6805424781973158, 0.6805424781973158, 0.6805424781973158, 0.7302517078985535, 0.7302517078985535, 0.7302517078985535, 0.26718795392276384, 0.26718795392276384, 0.26718795392276384, 0.26323878233985554, 0.26323878233985554, 0.26323878233985554, 0.2919722914049717, 0.2919722914049717, 0.2919722914049717, 0.12471594910095285, 0.12471594910095285, 0.12471594910095285, 0.46105336991312085, 0.46105336991312085, 0.46105336991312085, 0.10151175916995925, 0.10151175916995925, 0.10151175916995925, 0.10891778964255305, 0.10891778964255305, 0.10891778964255305, 0.14973758113973146, 0.14973758113973146, 0.14973758113973146, 0.10566033461483271, 0.10566033461483271, 0.10566033461483271, 0.12513329913438098, 0.12513329913438098, 0.12513329913438098, 0.15754966202884968, 0.15754966202884968, 0.15754966202884968, 0.16043621789362728, 0.16043621789362728, 0.16043621789362728, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012541357940420883, 0.012541357940420883, 0.012541357940420883, 0.013690220610890869, 0.013690220610890869, 0.013690220610890869, 0.06820595477458924, 0.06820595477458924, 0.06820595477458924, 0.04969733430862633, 0.04969733430862633, 0.04969733430862633, 0.0785298959601125, 0.0785298959601125, 0.0785298959601125, 0.015342070101057259, 0.015342070101057259, 0.015342070101057259, 0.010950636064003483, 0.010950636064003483, 0.010950636064003483, 0.008178122179740455, 0.008178122179740455, 0.008178122179740455, 0.03777108429549847, 0.03777108429549847, 0.03777108429549847, 0.08348823266928507, 0.08348823266928507, 0.08348823266928507, 0.07365795331362956, 0.07365795331362956, 0.07365795331362956, 0.3864751860311392, 0.3864751860311392, 0.3864751860311392, 0.38403496823851235, 0.38403496823851235, 0.38403496823851235, 0.3660060262339697, 0.3660060262339697, 0.3660060262339697, 0.09308243037701214, 0.09308243037701214, 0.09308243037701214, 0.089609468573836, 0.089609468573836, 0.089609468573836, 0.0629427839085609, 0.0629427839085609, 0.0629427839085609, 0.14158291724646932, 0.14158291724646932, 0.14158291724646932, 0.18094916192793098, 0.18094916192793098, 0.18094916192793098, 0.15904977865468461, 0.15904977865468461, 0.15904977865468461, 0.2182021300876299, 0.2182021300876299, 0.2182021300876299, 0.16708509824611484, 0.16708509824611484, 0.16708509824611484, 0.2672056234088729, 0.2672056234088729, 0.2672056234088729, 0.16194424212444536, 0.16194424212444536, 0.16194424212444536, 0.1462426800787514, 0.1462426800787514, 0.1462426800787514, 0.10727393109062344, 0.10727393109062344, 0.10727393109062344, 0.18917481593134466, 0.18917481593134466, 0.18917481593134466, 0.1755590450393174, 0.1755590450393174, 0.1755590450393174, 0.19145722365842843, 0.19145722365842843, 0.19145722365842843, 0.16768736809447804, 0.16768736809447804, 0.16768736809447804, 0.17468121819179905, 0.17468121819179905, 0.17468121819179905, 0.1501349250146854, 0.1501349250146854, 0.1501349250146854, 0.6163075971032527, 0.6163075971032527, 0.6163075971032527, 0.17337638462382254, 0.17337638462382254, 0.17337638462382254, 0.5817286651398476, 0.5817286651398476, 0.5817286651398476, 0.14176045177026864, 0.14176045177026864, 0.14176045177026864, 0.3449081489230035, 0.3449081489230035, 0.3449081489230035, 0.19718409031201334, 0.19718409031201334, 0.19718409031201334, 0.1919284319723954, 0.1919284319723954, 0.1919284319723954, 0.19137252970873653, 0.19137252970873653, 0.19137252970873653, 0.1832689920511058, 0.1832689920511058, 0.1832689920511058, 0.07489947165618638, 0.07489947165618638, 0.07489947165618638, 0.08116966741223719, 0.08116966741223719, 0.08116966741223719, 0.06714223745612558, 0.06714223745612558, 0.06714223745612558]}, "mutation_prompt": null}
{"id": "819425f1-d729-413f-aa11-1b7fbfab23c7", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n        self.success_history = []\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            # Update crossover rate based on fitness variance\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation with dynamic mutation factor\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:  # Adapt mutation factor based on success history\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover with adaptive crossover rate\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(0.1)  # Record success\n                else:\n                    self.success_history.append(-0.1)\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        # Adaptive alpha for dynamic search balance\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            # Adjust population size based on fitness diversity\n            if np.std(fitness) < 1e-3:  # Population converged\n                self.population_size = max(10, self.population_size - 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Introduce a mutation strategy based on success history to improve adaptability and ensure robust exploration.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e46c9b67-ff8a-427e-8f40-9cb35179604d", "metadata": {"aucs": [0.4418200410432245, 0.4418200410432245, 0.4418200410432245, 0.4217665546150817, 0.4217665546150817, 0.4217665546150817, 0.40527422068216257, 0.40527422068216257, 0.40527422068216257, 0.028532069031713347, 0.028532069031713347, 0.028532069031713347, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.039531225577675855, 0.039531225577675855, 0.039531225577675855, 0.08728454753950332, 0.08728454753950332, 0.08728454753950332, 0.09693725270102782, 0.09693725270102782, 0.09693725270102782, 0.09158762346257643, 0.09158762346257643, 0.09158762346257643, 0.07735024182410433, 0.07735024182410433, 0.07735024182410433, 0.08678547212285903, 0.08678547212285903, 0.08678547212285903, 0.08028430275436571, 0.08028430275436571, 0.08028430275436571, 0.6820988542308967, 0.6820988542308967, 0.6820988542308967, 0.6805424781973158, 0.6805424781973158, 0.6805424781973158, 0.7302517078985535, 0.7302517078985535, 0.7302517078985535, 0.26718795392276384, 0.26718795392276384, 0.26718795392276384, 0.26323878233985554, 0.26323878233985554, 0.26323878233985554, 0.2919722914049717, 0.2919722914049717, 0.2919722914049717, 0.12471594910095285, 0.12471594910095285, 0.12471594910095285, 0.46105336991312085, 0.46105336991312085, 0.46105336991312085, 0.10151175916995925, 0.10151175916995925, 0.10151175916995925, 0.10891778964255305, 0.10891778964255305, 0.10891778964255305, 0.14973758113973146, 0.14973758113973146, 0.14973758113973146, 0.10566033461483271, 0.10566033461483271, 0.10566033461483271, 0.12513329913438098, 0.12513329913438098, 0.12513329913438098, 0.15754966202884968, 0.15754966202884968, 0.15754966202884968, 0.16043621789362728, 0.16043621789362728, 0.16043621789362728, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012541357940420883, 0.012541357940420883, 0.012541357940420883, 0.013690220610890869, 0.013690220610890869, 0.013690220610890869, 0.06820595477458924, 0.06820595477458924, 0.06820595477458924, 0.04969733430862633, 0.04969733430862633, 0.04969733430862633, 0.0785298959601125, 0.0785298959601125, 0.0785298959601125, 0.015342070101057259, 0.015342070101057259, 0.015342070101057259, 0.010950636064003483, 0.010950636064003483, 0.010950636064003483, 0.008178122179740455, 0.008178122179740455, 0.008178122179740455, 0.03777108429549847, 0.03777108429549847, 0.03777108429549847, 0.08348823266928507, 0.08348823266928507, 0.08348823266928507, 0.07365795331362956, 0.07365795331362956, 0.07365795331362956, 0.3864751860311392, 0.3864751860311392, 0.3864751860311392, 0.38403496823851235, 0.38403496823851235, 0.38403496823851235, 0.3660060262339697, 0.3660060262339697, 0.3660060262339697, 0.09308243037701214, 0.09308243037701214, 0.09308243037701214, 0.089609468573836, 0.089609468573836, 0.089609468573836, 0.0629427839085609, 0.0629427839085609, 0.0629427839085609, 0.14158291724646932, 0.14158291724646932, 0.14158291724646932, 0.18094916192793098, 0.18094916192793098, 0.18094916192793098, 0.15904977865468461, 0.15904977865468461, 0.15904977865468461, 0.2182021300876299, 0.2182021300876299, 0.2182021300876299, 0.16708509824611484, 0.16708509824611484, 0.16708509824611484, 0.2672056234088729, 0.2672056234088729, 0.2672056234088729, 0.16194424212444536, 0.16194424212444536, 0.16194424212444536, 0.1462426800787514, 0.1462426800787514, 0.1462426800787514, 0.10727393109062344, 0.10727393109062344, 0.10727393109062344, 0.18917481593134466, 0.18917481593134466, 0.18917481593134466, 0.1755590450393174, 0.1755590450393174, 0.1755590450393174, 0.19145722365842843, 0.19145722365842843, 0.19145722365842843, 0.16768736809447804, 0.16768736809447804, 0.16768736809447804, 0.17468121819179905, 0.17468121819179905, 0.17468121819179905, 0.1501349250146854, 0.1501349250146854, 0.1501349250146854, 0.6163075971032527, 0.6163075971032527, 0.6163075971032527, 0.17337638462382254, 0.17337638462382254, 0.17337638462382254, 0.5817286651398476, 0.5817286651398476, 0.5817286651398476, 0.14176045177026864, 0.14176045177026864, 0.14176045177026864, 0.3449081489230035, 0.3449081489230035, 0.3449081489230035, 0.19718409031201334, 0.19718409031201334, 0.19718409031201334, 0.1919284319723954, 0.1919284319723954, 0.1919284319723954, 0.19137252970873653, 0.19137252970873653, 0.19137252970873653, 0.1832689920511058, 0.1832689920511058, 0.1832689920511058, 0.07489947165618638, 0.07489947165618638, 0.07489947165618638, 0.08116966741223719, 0.08116966741223719, 0.08116966741223719, 0.06714223745612558, 0.06714223745612558, 0.06714223745612558]}, "mutation_prompt": null}
{"id": "e4d11db4-240f-4a55-987d-0d204e633710", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n        self.success_history = []\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            # Update crossover rate based on fitness variance\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation with dynamic mutation factor\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:  # Adapt mutation factor based on success history\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover with adaptive crossover rate\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(0.1)  # Record success\n                else:\n                    self.success_history.append(-0.1)\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        # Adaptive alpha for dynamic search balance\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            # Adjust population size based on fitness diversity\n            if np.std(fitness) < 1e-3:  # Population converged\n                self.population_size = max(10, self.population_size - 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Introduce a mutation strategy based on success history to improve adaptability and ensure robust exploration.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e46c9b67-ff8a-427e-8f40-9cb35179604d", "metadata": {"aucs": [0.4418200410432245, 0.4418200410432245, 0.4418200410432245, 0.4217665546150817, 0.4217665546150817, 0.4217665546150817, 0.40527422068216257, 0.40527422068216257, 0.40527422068216257, 0.028532069031713347, 0.028532069031713347, 0.028532069031713347, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.039531225577675855, 0.039531225577675855, 0.039531225577675855, 0.08728454753950332, 0.08728454753950332, 0.08728454753950332, 0.09693725270102782, 0.09693725270102782, 0.09693725270102782, 0.09158762346257643, 0.09158762346257643, 0.09158762346257643, 0.07735024182410433, 0.07735024182410433, 0.07735024182410433, 0.08678547212285903, 0.08678547212285903, 0.08678547212285903, 0.08028430275436571, 0.08028430275436571, 0.08028430275436571, 0.6820988542308967, 0.6820988542308967, 0.6820988542308967, 0.6805424781973158, 0.6805424781973158, 0.6805424781973158, 0.7302517078985535, 0.7302517078985535, 0.7302517078985535, 0.26718795392276384, 0.26718795392276384, 0.26718795392276384, 0.26323878233985554, 0.26323878233985554, 0.26323878233985554, 0.2919722914049717, 0.2919722914049717, 0.2919722914049717, 0.12471594910095285, 0.12471594910095285, 0.12471594910095285, 0.46105336991312085, 0.46105336991312085, 0.46105336991312085, 0.10151175916995925, 0.10151175916995925, 0.10151175916995925, 0.10891778964255305, 0.10891778964255305, 0.10891778964255305, 0.14973758113973146, 0.14973758113973146, 0.14973758113973146, 0.10566033461483271, 0.10566033461483271, 0.10566033461483271, 0.12513329913438098, 0.12513329913438098, 0.12513329913438098, 0.15754966202884968, 0.15754966202884968, 0.15754966202884968, 0.16043621789362728, 0.16043621789362728, 0.16043621789362728, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012541357940420883, 0.012541357940420883, 0.012541357940420883, 0.013690220610890869, 0.013690220610890869, 0.013690220610890869, 0.06820595477458924, 0.06820595477458924, 0.06820595477458924, 0.04969733430862633, 0.04969733430862633, 0.04969733430862633, 0.0785298959601125, 0.0785298959601125, 0.0785298959601125, 0.015342070101057259, 0.015342070101057259, 0.015342070101057259, 0.010950636064003483, 0.010950636064003483, 0.010950636064003483, 0.008178122179740455, 0.008178122179740455, 0.008178122179740455, 0.03777108429549847, 0.03777108429549847, 0.03777108429549847, 0.08348823266928507, 0.08348823266928507, 0.08348823266928507, 0.07365795331362956, 0.07365795331362956, 0.07365795331362956, 0.3864751860311392, 0.3864751860311392, 0.3864751860311392, 0.38403496823851235, 0.38403496823851235, 0.38403496823851235, 0.3660060262339697, 0.3660060262339697, 0.3660060262339697, 0.09308243037701214, 0.09308243037701214, 0.09308243037701214, 0.089609468573836, 0.089609468573836, 0.089609468573836, 0.0629427839085609, 0.0629427839085609, 0.0629427839085609, 0.14158291724646932, 0.14158291724646932, 0.14158291724646932, 0.18094916192793098, 0.18094916192793098, 0.18094916192793098, 0.15904977865468461, 0.15904977865468461, 0.15904977865468461, 0.2182021300876299, 0.2182021300876299, 0.2182021300876299, 0.16708509824611484, 0.16708509824611484, 0.16708509824611484, 0.2672056234088729, 0.2672056234088729, 0.2672056234088729, 0.16194424212444536, 0.16194424212444536, 0.16194424212444536, 0.1462426800787514, 0.1462426800787514, 0.1462426800787514, 0.10727393109062344, 0.10727393109062344, 0.10727393109062344, 0.18917481593134466, 0.18917481593134466, 0.18917481593134466, 0.1755590450393174, 0.1755590450393174, 0.1755590450393174, 0.19145722365842843, 0.19145722365842843, 0.19145722365842843, 0.16768736809447804, 0.16768736809447804, 0.16768736809447804, 0.17468121819179905, 0.17468121819179905, 0.17468121819179905, 0.1501349250146854, 0.1501349250146854, 0.1501349250146854, 0.6163075971032527, 0.6163075971032527, 0.6163075971032527, 0.17337638462382254, 0.17337638462382254, 0.17337638462382254, 0.5817286651398476, 0.5817286651398476, 0.5817286651398476, 0.14176045177026864, 0.14176045177026864, 0.14176045177026864, 0.3449081489230035, 0.3449081489230035, 0.3449081489230035, 0.19718409031201334, 0.19718409031201334, 0.19718409031201334, 0.1919284319723954, 0.1919284319723954, 0.1919284319723954, 0.19137252970873653, 0.19137252970873653, 0.19137252970873653, 0.1832689920511058, 0.1832689920511058, 0.1832689920511058, 0.07489947165618638, 0.07489947165618638, 0.07489947165618638, 0.08116966741223719, 0.08116966741223719, 0.08116966741223719, 0.06714223745612558, 0.06714223745612558, 0.06714223745612558]}, "mutation_prompt": null}
{"id": "dd4c2f90-ba42-457b-9267-2d001e78a197", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n        self.success_history = []\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            # Update crossover rate based on fitness variance\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation with dynamic mutation factor\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:  # Adapt mutation factor based on success history\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover with adaptive crossover rate\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(0.1)  # Record success\n                else:\n                    self.success_history.append(-0.1)\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        # Adaptive alpha for dynamic search balance\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            # Adjust population size based on fitness diversity\n            if np.std(fitness) < 1e-3:  # Population converged\n                self.population_size = max(10, self.population_size - 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Introduce a mutation strategy based on success history to improve adaptability and ensure robust exploration.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e46c9b67-ff8a-427e-8f40-9cb35179604d", "metadata": {"aucs": [0.4418200410432245, 0.4418200410432245, 0.4418200410432245, 0.4217665546150817, 0.4217665546150817, 0.4217665546150817, 0.40527422068216257, 0.40527422068216257, 0.40527422068216257, 0.028532069031713347, 0.028532069031713347, 0.028532069031713347, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.039531225577675855, 0.039531225577675855, 0.039531225577675855, 0.08728454753950332, 0.08728454753950332, 0.08728454753950332, 0.09693725270102782, 0.09693725270102782, 0.09693725270102782, 0.09158762346257643, 0.09158762346257643, 0.09158762346257643, 0.07735024182410433, 0.07735024182410433, 0.07735024182410433, 0.08678547212285903, 0.08678547212285903, 0.08678547212285903, 0.08028430275436571, 0.08028430275436571, 0.08028430275436571, 0.6820988542308967, 0.6820988542308967, 0.6820988542308967, 0.6805424781973158, 0.6805424781973158, 0.6805424781973158, 0.7302517078985535, 0.7302517078985535, 0.7302517078985535, 0.26718795392276384, 0.26718795392276384, 0.26718795392276384, 0.26323878233985554, 0.26323878233985554, 0.26323878233985554, 0.2919722914049717, 0.2919722914049717, 0.2919722914049717, 0.12471594910095285, 0.12471594910095285, 0.12471594910095285, 0.46105336991312085, 0.46105336991312085, 0.46105336991312085, 0.10151175916995925, 0.10151175916995925, 0.10151175916995925, 0.10891778964255305, 0.10891778964255305, 0.10891778964255305, 0.14973758113973146, 0.14973758113973146, 0.14973758113973146, 0.10566033461483271, 0.10566033461483271, 0.10566033461483271, 0.12513329913438098, 0.12513329913438098, 0.12513329913438098, 0.15754966202884968, 0.15754966202884968, 0.15754966202884968, 0.16043621789362728, 0.16043621789362728, 0.16043621789362728, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012541357940420883, 0.012541357940420883, 0.012541357940420883, 0.013690220610890869, 0.013690220610890869, 0.013690220610890869, 0.06820595477458924, 0.06820595477458924, 0.06820595477458924, 0.04969733430862633, 0.04969733430862633, 0.04969733430862633, 0.0785298959601125, 0.0785298959601125, 0.0785298959601125, 0.015342070101057259, 0.015342070101057259, 0.015342070101057259, 0.010950636064003483, 0.010950636064003483, 0.010950636064003483, 0.008178122179740455, 0.008178122179740455, 0.008178122179740455, 0.03777108429549847, 0.03777108429549847, 0.03777108429549847, 0.08348823266928507, 0.08348823266928507, 0.08348823266928507, 0.07365795331362956, 0.07365795331362956, 0.07365795331362956, 0.3864751860311392, 0.3864751860311392, 0.3864751860311392, 0.38403496823851235, 0.38403496823851235, 0.38403496823851235, 0.3660060262339697, 0.3660060262339697, 0.3660060262339697, 0.09308243037701214, 0.09308243037701214, 0.09308243037701214, 0.089609468573836, 0.089609468573836, 0.089609468573836, 0.0629427839085609, 0.0629427839085609, 0.0629427839085609, 0.14158291724646932, 0.14158291724646932, 0.14158291724646932, 0.18094916192793098, 0.18094916192793098, 0.18094916192793098, 0.15904977865468461, 0.15904977865468461, 0.15904977865468461, 0.2182021300876299, 0.2182021300876299, 0.2182021300876299, 0.16708509824611484, 0.16708509824611484, 0.16708509824611484, 0.2672056234088729, 0.2672056234088729, 0.2672056234088729, 0.16194424212444536, 0.16194424212444536, 0.16194424212444536, 0.1462426800787514, 0.1462426800787514, 0.1462426800787514, 0.10727393109062344, 0.10727393109062344, 0.10727393109062344, 0.18917481593134466, 0.18917481593134466, 0.18917481593134466, 0.1755590450393174, 0.1755590450393174, 0.1755590450393174, 0.19145722365842843, 0.19145722365842843, 0.19145722365842843, 0.16768736809447804, 0.16768736809447804, 0.16768736809447804, 0.17468121819179905, 0.17468121819179905, 0.17468121819179905, 0.1501349250146854, 0.1501349250146854, 0.1501349250146854, 0.6163075971032527, 0.6163075971032527, 0.6163075971032527, 0.17337638462382254, 0.17337638462382254, 0.17337638462382254, 0.5817286651398476, 0.5817286651398476, 0.5817286651398476, 0.14176045177026864, 0.14176045177026864, 0.14176045177026864, 0.3449081489230035, 0.3449081489230035, 0.3449081489230035, 0.19718409031201334, 0.19718409031201334, 0.19718409031201334, 0.1919284319723954, 0.1919284319723954, 0.1919284319723954, 0.19137252970873653, 0.19137252970873653, 0.19137252970873653, 0.1832689920511058, 0.1832689920511058, 0.1832689920511058, 0.07489947165618638, 0.07489947165618638, 0.07489947165618638, 0.08116966741223719, 0.08116966741223719, 0.08116966741223719, 0.06714223745612558, 0.06714223745612558, 0.06714223745612558]}, "mutation_prompt": null}
{"id": "b9014d17-850d-48f8-8b7c-3b9d1d71a930", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n        self.success_history = []\n        self.learning_rate = 0.01  # Introduced learning rate for adaptability \n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            # Update crossover rate based on fitness variance\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation with dynamic mutation factor\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:  # Adapt mutation factor based on success history\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover with adaptive crossover rate\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(self.learning_rate)  # Adjust success weight\n                else:\n                    self.success_history.append(-self.learning_rate)\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        # Adaptive alpha for dynamic search balance\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            # Adjust population size based on fitness diversity\n            if np.std(fitness) < 1e-3:  # Population converged\n                self.population_size = max(10, self.population_size - 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Introduce dynamic strategy with success-based learning rate to enhance adaptive search.", "configspace": "", "generation": 60, "fitness": 0.19103050213298026, "feedback": "The algorithm HybridDEFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.17.", "error": "", "parent_id": "e46c9b67-ff8a-427e-8f40-9cb35179604d", "metadata": {"aucs": [0.40959088894964457, 0.40959088894964457, 0.40959088894964457, 0.4335061198810507, 0.4335061198810507, 0.4335061198810507, 0.4157170350827255, 0.4157170350827255, 0.4157170350827255, 0.0007487320778982731, 0.0007487320778982731, 0.0007487320778982731, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.036755123399678236, 0.036755123399678236, 0.036755123399678236, 0.105929124906886, 0.105929124906886, 0.105929124906886, 0.10915195280178414, 0.10915195280178414, 0.10915195280178414, 0.07458004233195081, 0.07458004233195081, 0.07458004233195081, 0.051646841238568775, 0.051646841238568775, 0.051646841238568775, 0.08567543929878552, 0.08567543929878552, 0.08567543929878552, 0.027586075482045502, 0.027586075482045502, 0.027586075482045502, 0.10889444655256886, 0.10889444655256886, 0.10889444655256886, 0.7029584282198529, 0.7029584282198529, 0.7029584282198529, 0.7734815697578562, 0.7734815697578562, 0.7734815697578562, 0.28700759310020685, 0.28700759310020685, 0.28700759310020685, 0.25767327540282015, 0.25767327540282015, 0.25767327540282015, 0.2887975098913296, 0.2887975098913296, 0.2887975098913296, 0.1416131579316494, 0.1416131579316494, 0.1416131579316494, 0.17752549808622176, 0.17752549808622176, 0.17752549808622176, 0.20739549858808548, 0.20739549858808548, 0.20739549858808548, 0.16555214246534888, 0.16555214246534888, 0.16555214246534888, 0.1320635265460629, 0.1320635265460629, 0.1320635265460629, 0.15490494521394083, 0.15490494521394083, 0.15490494521394083, 0.10378564265407642, 0.10378564265407642, 0.10378564265407642, 0.14353028560240833, 0.14353028560240833, 0.14353028560240833, 0.14444582720468246, 0.14444582720468246, 0.14444582720468246, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03221542911019826, 0.03221542911019826, 0.03221542911019826, 0.007027457411631466, 0.007027457411631466, 0.007027457411631466, 0.07023000239267241, 0.07023000239267241, 0.07023000239267241, 0.024365317163340672, 0.024365317163340672, 0.024365317163340672, 0.08633433599740603, 0.08633433599740603, 0.08633433599740603, 0.01665861948074454, 0.01665861948074454, 0.01665861948074454, 0.0109233251036579, 0.0109233251036579, 0.0109233251036579, 0.012332516644685931, 0.012332516644685931, 0.012332516644685931, 0.08603994253043434, 0.08603994253043434, 0.08603994253043434, 0.09908482588110523, 0.09908482588110523, 0.09908482588110523, 0.10083970070392156, 0.10083970070392156, 0.10083970070392156, 0.383385322307235, 0.383385322307235, 0.383385322307235, 0.3997589145366409, 0.3997589145366409, 0.3997589145366409, 0.39822229950002763, 0.39822229950002763, 0.39822229950002763, 0.09529085541199911, 0.09529085541199911, 0.09529085541199911, 0.11585988810488812, 0.11585988810488812, 0.11585988810488812, 0.12415475249614605, 0.12415475249614605, 0.12415475249614605, 0.12764384611517776, 0.12764384611517776, 0.12764384611517776, 0.14505401424099218, 0.14505401424099218, 0.14505401424099218, 0.1508553367709019, 0.1508553367709019, 0.1508553367709019, 0.2882344069386781, 0.2882344069386781, 0.2882344069386781, 0.1863569632198374, 0.1863569632198374, 0.1863569632198374, 0.2825581533360362, 0.2825581533360362, 0.2825581533360362, 0.17506716947531242, 0.17506716947531242, 0.17506716947531242, 0.1230206999321325, 0.1230206999321325, 0.1230206999321325, 0.1356136719142922, 0.1356136719142922, 0.1356136719142922, 0.19547468518908673, 0.19547468518908673, 0.19547468518908673, 0.1914821002699979, 0.1914821002699979, 0.1914821002699979, 0.16510572399349144, 0.16510572399349144, 0.16510572399349144, 0.1710688433936428, 0.1710688433936428, 0.1710688433936428, 0.17743118224022913, 0.17743118224022913, 0.17743118224022913, 0.18594299248741486, 0.18594299248741486, 0.18594299248741486, 0.521961754417724, 0.521961754417724, 0.521961754417724, 0.5698680401792828, 0.5698680401792828, 0.5698680401792828, 0.5629473750008801, 0.5629473750008801, 0.5629473750008801, 0.4837824156737093, 0.4837824156737093, 0.4837824156737093, 0.31973407676698573, 0.31973407676698573, 0.31973407676698573, 0.19740538285541087, 0.19740538285541087, 0.19740538285541087, 0.18270902558243673, 0.18270902558243673, 0.18270902558243673, 0.18800348573477366, 0.18800348573477366, 0.18800348573477366, 0.2034621638408607, 0.2034621638408607, 0.2034621638408607, 0.07379263696788074, 0.07379263696788074, 0.07379263696788074, 0.08701700788379418, 0.08701700788379418, 0.08701700788379418, 0.05916277170875073, 0.05916277170875073, 0.05916277170875073]}, "mutation_prompt": null}
{"id": "37b60388-75c2-40c7-abe9-cb8b222bcb59", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n        self.success_history = []\n        self.learning_rate = 0.01  # Introduced learning rate for adaptability\n        self.momentum = 0.9  # Momentum factor\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population and velocities\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros_like(population)  # Initialize velocities for momentum\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            # Update crossover rate based on fitness variance\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation with dynamic mutation factor\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:  # Adapt mutation factor based on success history\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover with adaptive crossover rate\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(self.learning_rate)  # Adjust success weight\n                else:\n                    self.success_history.append(-self.learning_rate)\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        # Adaptive alpha for dynamic search balance\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        velocities[i] = self.momentum * velocities[i] + beta * (new_population[j] - new_population[i])\n                        new_population[i] += velocities[i] + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            # Adjust population size based on fitness diversity\n            if np.std(fitness) < 1e-3:  # Population converged\n                self.population_size = max(10, self.population_size - 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Integrate momentum-based adaptation to enhance convergence speed and stability.", "configspace": "", "generation": 61, "fitness": 0.16388246371822687, "feedback": "The algorithm HybridDEFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.16.", "error": "", "parent_id": "b9014d17-850d-48f8-8b7c-3b9d1d71a930", "metadata": {"aucs": [0.30659926558920525, 0.30659926558920525, 0.30659926558920525, 0.31534798510548157, 0.31534798510548157, 0.31534798510548157, 0.2828691552175161, 0.2828691552175161, 0.2828691552175161, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0807454353663023, 0.0807454353663023, 0.0807454353663023, 0.08288643272245699, 0.08288643272245699, 0.08288643272245699, 0.06786184272811102, 0.06786184272811102, 0.06786184272811102, 0.04046509002170917, 0.04046509002170917, 0.04046509002170917, 0.08042261362142311, 0.08042261362142311, 0.08042261362142311, 0.03706623865886027, 0.03706623865886027, 0.03706623865886027, 0.7396835099427981, 0.7396835099427981, 0.7396835099427981, 0.7856929526150127, 0.7856929526150127, 0.7856929526150127, 0.8628141061323588, 0.8628141061323588, 0.8628141061323588, 0.15787422698802134, 0.15787422698802134, 0.15787422698802134, 0.16420336153995563, 0.16420336153995563, 0.16420336153995563, 0.16651353741417352, 0.16651353741417352, 0.16651353741417352, 0.1756141715925913, 0.1756141715925913, 0.1756141715925913, 0.19187417797670703, 0.19187417797670703, 0.19187417797670703, 0.25380295341519277, 0.25380295341519277, 0.25380295341519277, 0.1334583372490582, 0.1334583372490582, 0.1334583372490582, 0.10240365635955095, 0.10240365635955095, 0.10240365635955095, 0.1049046096341264, 0.1049046096341264, 0.1049046096341264, 0.08203466617164012, 0.08203466617164012, 0.08203466617164012, 0.10677449192457511, 0.10677449192457511, 0.10677449192457511, 0.10297628139163295, 0.10297628139163295, 0.10297628139163295, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.022817709183791002, 0.022817709183791002, 0.022817709183791002, 0.0005147014631587954, 0.0005147014631587954, 0.0005147014631587954, 0.057191813142741244, 0.057191813142741244, 0.057191813142741244, 0.03481465405969031, 0.03481465405969031, 0.03481465405969031, 0.09097411076050499, 0.09097411076050499, 0.09097411076050499, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.052589252010549536, 0.052589252010549536, 0.052589252010549536, 0.05861090621394072, 0.05861090621394072, 0.05861090621394072, 0.02989547324441233, 0.02989547324441233, 0.02989547324441233, 0.3130202964162929, 0.3130202964162929, 0.3130202964162929, 0.3128345027257998, 0.3128345027257998, 0.3128345027257998, 0.31244753058950814, 0.31244753058950814, 0.31244753058950814, 0.08211226154203488, 0.08211226154203488, 0.08211226154203488, 0.06656614046440268, 0.06656614046440268, 0.06656614046440268, 0.07867698045833438, 0.07867698045833438, 0.07867698045833438, 0.12474722924988113, 0.12474722924988113, 0.12474722924988113, 0.1395956605102907, 0.1395956605102907, 0.1395956605102907, 0.16963242095250064, 0.16963242095250064, 0.16963242095250064, 0.2236301677859579, 0.2236301677859579, 0.2236301677859579, 0.1921610506992517, 0.1921610506992517, 0.1921610506992517, 0.18493182280575027, 0.18493182280575027, 0.18493182280575027, 0.16048617552290667, 0.16048617552290667, 0.16048617552290667, 0.1547367500183212, 0.1547367500183212, 0.1547367500183212, 0.14695026256373311, 0.14695026256373311, 0.14695026256373311, 0.1689295385521844, 0.1689295385521844, 0.1689295385521844, 0.1819090915222703, 0.1819090915222703, 0.1819090915222703, 0.17430818952927207, 0.17430818952927207, 0.17430818952927207, 0.15125302850034406, 0.15125302850034406, 0.15125302850034406, 0.15598072488389447, 0.15598072488389447, 0.15598072488389447, 0.15066454926154327, 0.15066454926154327, 0.15066454926154327, 0.3843639278366381, 0.3843639278366381, 0.3843639278366381, 0.17153983389533767, 0.17153983389533767, 0.17153983389533767, 0.491801352908369, 0.491801352908369, 0.491801352908369, 0.17423093008720802, 0.17423093008720802, 0.17423093008720802, 0.2336462262112574, 0.2336462262112574, 0.2336462262112574, 0.1858899123070874, 0.1858899123070874, 0.1858899123070874, 0.1743672883150048, 0.1743672883150048, 0.1743672883150048, 0.18377061153495355, 0.18377061153495355, 0.18377061153495355, 0.18943001140751525, 0.18943001140751525, 0.18943001140751525, 0.05604086950515719, 0.05604086950515719, 0.05604086950515719, 0.07501558806580721, 0.07501558806580721, 0.07501558806580721, 0.06086874162627487, 0.06086874162627487, 0.06086874162627487]}, "mutation_prompt": null}
{"id": "a7622c9f-2c9d-4d01-971d-259dbd42ac5e", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.alpha = 0.5\n        self.gamma = 1.0\n        self.success_history = []\n        self.learning_rate = 0.01\n\n    def logistic_map(self, size, r=3.9):\n        x = np.random.rand(size)\n        for _ in range(100):  # Iterate to reach chaotic state\n            x = r * x * (1 - x)\n        return x\n\n    def __call__(self, func):\n        np.random.seed(42)\n        budget_used = 0\n\n        # Initialize population using chaotic map\n        chaotic_vector = self.logistic_map(self.population_size * self.dim)\n        population = self.lower_bound + chaotic_vector.reshape(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(self.learning_rate)\n                else:\n                    self.success_history.append(-self.learning_rate)\n\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            population = new_population\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if np.std(fitness) < 1e-3:\n                self.population_size = max(10, self.population_size - 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Enhance exploration by introducing chaotic maps for initial population generation and adaptively adjusting parameters based on chaotic sequences.", "configspace": "", "generation": 62, "fitness": 0.16986421856827197, "feedback": "The algorithm HybridDEFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.15.", "error": "", "parent_id": "b9014d17-850d-48f8-8b7c-3b9d1d71a930", "metadata": {"aucs": [0.42590524537679253, 0.42590524537679253, 0.42590524537679253, 0.4294183820355394, 0.4294183820355394, 0.4294183820355394, 0.432052724994189, 0.432052724994189, 0.432052724994189, 0.005898248994657296, 0.005898248994657296, 0.005898248994657296, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.059880204135233206, 0.059880204135233206, 0.059880204135233206, 0.08056879153355878, 0.08056879153355878, 0.08056879153355878, 0.09047225784964064, 0.09047225784964064, 0.09047225784964064, 0.08064038123884254, 0.08064038123884254, 0.08064038123884254, 0.0755004015189088, 0.0755004015189088, 0.0755004015189088, 0.04763326149371894, 0.04763326149371894, 0.04763326149371894, 0.7218654898607482, 0.7218654898607482, 0.7218654898607482, 0.5587314607919835, 0.5587314607919835, 0.5587314607919835, 0.6855364469845446, 0.6855364469845446, 0.6855364469845446, 0.29599281121825516, 0.29599281121825516, 0.29599281121825516, 0.27914994169153984, 0.27914994169153984, 0.27914994169153984, 0.30014944348329065, 0.30014944348329065, 0.30014944348329065, 0.1627469439801318, 0.1627469439801318, 0.1627469439801318, 0.09623393382548473, 0.09623393382548473, 0.09623393382548473, 0.21656798692249435, 0.21656798692249435, 0.21656798692249435, 0.1798536783778132, 0.1798536783778132, 0.1798536783778132, 0.1531481876170665, 0.1531481876170665, 0.1531481876170665, 0.08055088911262043, 0.08055088911262043, 0.08055088911262043, 0.11123428538242319, 0.11123428538242319, 0.11123428538242319, 0.13032899569144407, 0.13032899569144407, 0.13032899569144407, 0.10299183874430817, 0.10299183874430817, 0.10299183874430817, 0.0041794771360220695, 0.0041794771360220695, 0.0041794771360220695, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08411196489835404, 0.08411196489835404, 0.08411196489835404, 0.07926836026714046, 0.07926836026714046, 0.07926836026714046, 0.06628480771232703, 0.06628480771232703, 0.06628480771232703, 0.014352675889298006, 0.014352675889298006, 0.014352675889298006, 0.0271251190027455, 0.0271251190027455, 0.0271251190027455, 0.026438393593253062, 0.026438393593253062, 0.026438393593253062, 0.10737956196131948, 0.10737956196131948, 0.10737956196131948, 0.06741566951055178, 0.06741566951055178, 0.06741566951055178, 0.08676894072680674, 0.08676894072680674, 0.08676894072680674, 0.3892506540151818, 0.3892506540151818, 0.3892506540151818, 0.40059230934827705, 0.40059230934827705, 0.40059230934827705, 0.3952751373856739, 0.3952751373856739, 0.3952751373856739, 0.08253663910701603, 0.08253663910701603, 0.08253663910701603, 0.08178790681730919, 0.08178790681730919, 0.08178790681730919, 0.09907133916644595, 0.09907133916644595, 0.09907133916644595, 0.12356118759881918, 0.12356118759881918, 0.12356118759881918, 0.15429973831902555, 0.15429973831902555, 0.15429973831902555, 0.14849350615792123, 0.14849350615792123, 0.14849350615792123, 0.16249495162897942, 0.16249495162897942, 0.16249495162897942, 0.28020050033693333, 0.28020050033693333, 0.28020050033693333, 0.16169418473455122, 0.16169418473455122, 0.16169418473455122, 0.1502104165932555, 0.1502104165932555, 0.1502104165932555, 0.12584028543575254, 0.12584028543575254, 0.12584028543575254, 0.14769300326772317, 0.14769300326772317, 0.14769300326772317, 0.1849717761123999, 0.1849717761123999, 0.1849717761123999, 0.18149972972878237, 0.18149972972878237, 0.18149972972878237, 0.17639177480323087, 0.17639177480323087, 0.17639177480323087, 0.1671975604902758, 0.1671975604902758, 0.1671975604902758, 0.15819222323371562, 0.15819222323371562, 0.15819222323371562, 0.18080297933401202, 0.18080297933401202, 0.18080297933401202, 0.15440938649335534, 0.15440938649335534, 0.15440938649335534, 0.1374875131902723, 0.1374875131902723, 0.1374875131902723, 0.17629480051512514, 0.17629480051512514, 0.17629480051512514, 0.1350159265762888, 0.1350159265762888, 0.1350159265762888, 0.14694324697708994, 0.14694324697708994, 0.14694324697708994, 0.3688300864290369, 0.3688300864290369, 0.3688300864290369, 0.18650224562526996, 0.18650224562526996, 0.18650224562526996, 0.18160306448137775, 0.18160306448137775, 0.18160306448137775, 0.2061608668046706, 0.2061608668046706, 0.2061608668046706, 0.07484761292659436, 0.07484761292659436, 0.07484761292659436, 0.07872704031153066, 0.07872704031153066, 0.07872704031153066, 0.06456693941664149, 0.06456693941664149, 0.06456693941664149]}, "mutation_prompt": null}
{"id": "404490c3-309e-46d0-ae7b-4571f7307d41", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n        self.success_history = []\n        self.learning_rate = 0.01  # Introduced learning rate for adaptability \n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            # Update crossover rate based on fitness variance\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation with dynamic mutation factor\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:  # Adapt mutation factor based on success history\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                # Rotate vector b to generate mutant\n                rotation_matrix = np.eye(self.dim) + 0.1 * np.random.randn(self.dim, self.dim)\n                rotated_b = np.dot(rotation_matrix, population[b])\n                mutant = np.clip(rotated_b + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover with adaptive crossover rate\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(self.learning_rate)  # Adjust success weight\n                else:\n                    self.success_history.append(-self.learning_rate)\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        # Adaptive alpha for dynamic search balance\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            # Adjust population size based on fitness diversity\n            if np.std(fitness) < 1e-3:  # Population converged\n                self.population_size = max(10, self.population_size - 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Refine mutation operation by introducing a rotation-based mechanism to enhance exploration capabilities.", "configspace": "", "generation": 63, "fitness": 0.15205248719431433, "feedback": "The algorithm HybridDEFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.15.", "error": "", "parent_id": "b9014d17-850d-48f8-8b7c-3b9d1d71a930", "metadata": {"aucs": [0.41190781574748603, 0.41190781574748603, 0.41190781574748603, 0.36706521878391163, 0.36706521878391163, 0.36706521878391163, 0.41468358769967584, 0.41468358769967584, 0.41468358769967584, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08017841441585183, 0.08017841441585183, 0.08017841441585183, 0.07550680067720406, 0.07550680067720406, 0.07550680067720406, 0.04047512581108126, 0.04047512581108126, 0.04047512581108126, 0.025021777714611004, 0.025021777714611004, 0.025021777714611004, 0.036801988453385226, 0.036801988453385226, 0.036801988453385226, 0.04873679316401791, 0.04873679316401791, 0.04873679316401791, 0.6177481589855767, 0.6177481589855767, 0.6177481589855767, 0.7657386586068735, 0.7657386586068735, 0.7657386586068735, 0.5406131877939604, 0.5406131877939604, 0.5406131877939604, 0.24681360398372443, 0.24681360398372443, 0.24681360398372443, 0.2819554057289929, 0.2819554057289929, 0.2819554057289929, 0.21385653514368164, 0.21385653514368164, 0.21385653514368164, 0.1003225411568417, 0.1003225411568417, 0.1003225411568417, 0.17092786494790757, 0.17092786494790757, 0.17092786494790757, 0.36749806655010975, 0.36749806655010975, 0.36749806655010975, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10439434387405055, 0.10439434387405055, 0.10439434387405055, 0.13740059785674508, 0.13740059785674508, 0.13740059785674508, 0.0914290981538588, 0.0914290981538588, 0.0914290981538588, 0.05039623160660067, 0.05039623160660067, 0.05039623160660067, 0.09444631080614851, 0.09444631080614851, 0.09444631080614851, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06309198699509544, 0.06309198699509544, 0.06309198699509544, 0.023482437422291724, 0.023482437422291724, 0.023482437422291724, 0.04073948955100182, 0.04073948955100182, 0.04073948955100182, 0.003478461942964195, 0.003478461942964195, 0.003478461942964195, 0.0066936585420537265, 0.0066936585420537265, 0.0066936585420537265, 0.009165708486794766, 0.009165708486794766, 0.009165708486794766, 0.08881864158075292, 0.08881864158075292, 0.08881864158075292, 0.04669762553040324, 0.04669762553040324, 0.04669762553040324, 0.046411748748036, 0.046411748748036, 0.046411748748036, 0.37384466747211154, 0.37384466747211154, 0.37384466747211154, 0.3593635941085599, 0.3593635941085599, 0.3593635941085599, 0.3204813028602185, 0.3204813028602185, 0.3204813028602185, 0.07293878252420216, 0.07293878252420216, 0.07293878252420216, 0.06699837658248053, 0.06699837658248053, 0.06699837658248053, 0.03537628566648432, 0.03537628566648432, 0.03537628566648432, 0.1429499160552672, 0.1429499160552672, 0.1429499160552672, 0.154184431645211, 0.154184431645211, 0.154184431645211, 0.20112500027821412, 0.20112500027821412, 0.20112500027821412, 0.1495966869947455, 0.1495966869947455, 0.1495966869947455, 0.16324501194848706, 0.16324501194848706, 0.16324501194848706, 0.26389969019556525, 0.26389969019556525, 0.26389969019556525, 0.08355511499701185, 0.08355511499701185, 0.08355511499701185, 0.16588590026998395, 0.16588590026998395, 0.16588590026998395, 0.13839331792626453, 0.13839331792626453, 0.13839331792626453, 0.1368688786152119, 0.1368688786152119, 0.1368688786152119, 0.1630326499289465, 0.1630326499289465, 0.1630326499289465, 0.15840429476425033, 0.15840429476425033, 0.15840429476425033, 0.14589521031659514, 0.14589521031659514, 0.14589521031659514, 0.14615733265268682, 0.14615733265268682, 0.14615733265268682, 0.16799441767240364, 0.16799441767240364, 0.16799441767240364, 0.3384619555117957, 0.3384619555117957, 0.3384619555117957, 0.13699698680439087, 0.13699698680439087, 0.13699698680439087, 0.136995609017861, 0.136995609017861, 0.136995609017861, 0.11577585697757364, 0.11577585697757364, 0.11577585697757364, 0.08285032757756161, 0.08285032757756161, 0.08285032757756161, 0.19076433000609883, 0.19076433000609883, 0.19076433000609883, 0.18729509332168492, 0.18729509332168492, 0.18729509332168492, 0.1833638566205883, 0.1833638566205883, 0.1833638566205883, 0.19894920327997956, 0.19894920327997956, 0.19894920327997956, 0.049856944070479026, 0.049856944070479026, 0.049856944070479026, 0.04476650436276064, 0.04476650436276064, 0.04476650436276064, 0.05831366050326492, 0.05831366050326492, 0.05831366050326492]}, "mutation_prompt": null}
{"id": "0ac808c4-0e74-46fa-ab8b-00b4ae15c199", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n        self.success_history = []\n        self.learning_rate = 0.01  # Introduced learning rate for adaptability \n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            # Update crossover rate based on fitness variance\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation with dynamic mutation factor\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:  # Adapt mutation factor based on success history\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n                \n                # New mutation factor scaling with global best\n                global_influence = np.linalg.norm(population[a] - best_solution)\n                dynamic_mutation_factor *= 1 + np.exp(-global_influence)\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover with adaptive crossover rate\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(self.learning_rate)  # Adjust success weight\n                else:\n                    self.success_history.append(-self.learning_rate)\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        # Adaptive alpha for dynamic search balance\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            # Adjust population size based on fitness diversity\n            if np.std(fitness) < 1e-3:  # Population converged\n                self.population_size = max(10, self.population_size - 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Introduce variable mutation factor scaling with global best to enhance exploration-exploitation balance.", "configspace": "", "generation": 64, "fitness": 0.16291624673948876, "feedback": "The algorithm HybridDEFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.13.", "error": "", "parent_id": "b9014d17-850d-48f8-8b7c-3b9d1d71a930", "metadata": {"aucs": [0.4255148606863114, 0.4255148606863114, 0.4255148606863114, 0.41589078337713636, 0.41589078337713636, 0.41589078337713636, 0.4066213543075735, 0.4066213543075735, 0.4066213543075735, 0.020938775722868952, 0.020938775722868952, 0.020938775722868952, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004181113597819475, 0.004181113597819475, 0.004181113597819475, 0.08241724229680514, 0.08241724229680514, 0.08241724229680514, 0.07044491236220751, 0.07044491236220751, 0.07044491236220751, 0.10263362022784772, 0.10263362022784772, 0.10263362022784772, 0.04367538591433018, 0.04367538591433018, 0.04367538591433018, 0.05273270327867918, 0.05273270327867918, 0.05273270327867918, 0.06901855246208433, 0.06901855246208433, 0.06901855246208433, 0.10988914566442876, 0.10988914566442876, 0.10988914566442876, 0.47488445119340883, 0.47488445119340883, 0.47488445119340883, 0.644861581257691, 0.644861581257691, 0.644861581257691, 0.2555080699588087, 0.2555080699588087, 0.2555080699588087, 0.2534029080595096, 0.2534029080595096, 0.2534029080595096, 0.28063447213970627, 0.28063447213970627, 0.28063447213970627, 0.2865381801680932, 0.2865381801680932, 0.2865381801680932, 0.24371457607272662, 0.24371457607272662, 0.24371457607272662, 0.1389828254326123, 0.1389828254326123, 0.1389828254326123, 0.1587806268265325, 0.1587806268265325, 0.1587806268265325, 0.13849152420876543, 0.13849152420876543, 0.13849152420876543, 0.12358439439696556, 0.12358439439696556, 0.12358439439696556, 0.09563329758732875, 0.09563329758732875, 0.09563329758732875, 0.14718404578121191, 0.14718404578121191, 0.14718404578121191, 0.12639915332677953, 0.12639915332677953, 0.12639915332677953, 0.00011216752466169932, 0.00011216752466169932, 0.00011216752466169932, 0.000604357114950993, 0.000604357114950993, 0.000604357114950993, 0.03576551264271388, 0.03576551264271388, 0.03576551264271388, 0.0603897493236667, 0.0603897493236667, 0.0603897493236667, 0.040033390888961407, 0.040033390888961407, 0.040033390888961407, 0.0722515945814759, 0.0722515945814759, 0.0722515945814759, 0.010638510463656714, 0.010638510463656714, 0.010638510463656714, 0.003972932088378012, 0.003972932088378012, 0.003972932088378012, 0.010047677428345891, 0.010047677428345891, 0.010047677428345891, 0.047652767072920876, 0.047652767072920876, 0.047652767072920876, 0.08053228140195967, 0.08053228140195967, 0.08053228140195967, 0.06774218330571491, 0.06774218330571491, 0.06774218330571491, 0.39200273183595835, 0.39200273183595835, 0.39200273183595835, 0.3926910884141155, 0.3926910884141155, 0.3926910884141155, 0.372387118683536, 0.372387118683536, 0.372387118683536, 0.11793148749901794, 0.11793148749901794, 0.11793148749901794, 0.04744159504813139, 0.04744159504813139, 0.04744159504813139, 0.0823470310395118, 0.0823470310395118, 0.0823470310395118, 0.1495926404826552, 0.1495926404826552, 0.1495926404826552, 0.15368675589501923, 0.15368675589501923, 0.15368675589501923, 0.15392831327435674, 0.15392831327435674, 0.15392831327435674, 0.273695402172193, 0.273695402172193, 0.273695402172193, 0.1723470776705619, 0.1723470776705619, 0.1723470776705619, 0.18114707896593396, 0.18114707896593396, 0.18114707896593396, 0.15006136592125785, 0.15006136592125785, 0.15006136592125785, 0.1466190658755664, 0.1466190658755664, 0.1466190658755664, 0.15247970629948904, 0.15247970629948904, 0.15247970629948904, 0.19267080700564232, 0.19267080700564232, 0.19267080700564232, 0.18398583120735146, 0.18398583120735146, 0.18398583120735146, 0.18148040491207162, 0.18148040491207162, 0.18148040491207162, 0.15774892643420735, 0.15774892643420735, 0.15774892643420735, 0.15920778634275579, 0.15920778634275579, 0.15920778634275579, 0.15903943967119505, 0.15903943967119505, 0.15903943967119505, 0.15692332878383963, 0.15692332878383963, 0.15692332878383963, 0.1692762232507785, 0.1692762232507785, 0.1692762232507785, 0.40716723579698166, 0.40716723579698166, 0.40716723579698166, 0.17984772694912332, 0.17984772694912332, 0.17984772694912332, 0.27129154744981265, 0.27129154744981265, 0.27129154744981265, 0.17663293072372455, 0.17663293072372455, 0.17663293072372455, 0.21448099767897277, 0.21448099767897277, 0.21448099767897277, 0.18256896087609997, 0.18256896087609997, 0.18256896087609997, 0.2013189800209264, 0.2013189800209264, 0.2013189800209264, 0.06852971579837175, 0.06852971579837175, 0.06852971579837175, 0.06053252465892489, 0.06053252465892489, 0.06053252465892489, 0.06650625845946656, 0.06650625845946656, 0.06650625845946656]}, "mutation_prompt": null}
{"id": "374a476f-b824-49d4-b3fa-ccdf84997bad", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.alpha = 0.5\n        self.gamma = 1.0\n        self.success_history = []\n        self.learning_rate = 0.01\n\n    def __call__(self, func):\n        np.random.seed(42)\n        budget_used = 0\n\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget)) * (1.1 if budget_used % 2 == 0 else 0.9)\n\n                if self.success_history:\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(self.learning_rate)\n                else:\n                    self.success_history.append(-self.learning_rate)\n\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            population = new_population\n            \n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if np.std(fitness) < 1e-3:  \n                self.population_size = max(10, int(self.population_size * 0.9))\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Enhance dynamic mutation factor and adapt population size more responsively for better convergence.", "configspace": "", "generation": 65, "fitness": 0.18287881495860273, "feedback": "The algorithm HybridDEFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.16.", "error": "", "parent_id": "b9014d17-850d-48f8-8b7c-3b9d1d71a930", "metadata": {"aucs": [0.4407457710395296, 0.4407457710395296, 0.4407457710395296, 0.41892627953348305, 0.41892627953348305, 0.41892627953348305, 0.41379810779535964, 0.41379810779535964, 0.41379810779535964, 0.032644451441805944, 0.032644451441805944, 0.032644451441805944, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.032662119069837736, 0.032662119069837736, 0.032662119069837736, 0.11109396685444117, 0.11109396685444117, 0.11109396685444117, 0.1091646374026648, 0.1091646374026648, 0.1091646374026648, 0.09488558837292382, 0.09488558837292382, 0.09488558837292382, 0.08061575233418661, 0.08061575233418661, 0.08061575233418661, 0.07691737492048867, 0.07691737492048867, 0.07691737492048867, 0.08034083850817442, 0.08034083850817442, 0.08034083850817442, 0.09161990492578953, 0.09161990492578953, 0.09161990492578953, 0.1081321388805856, 0.1081321388805856, 0.1081321388805856, 0.7359192262570662, 0.7359192262570662, 0.7359192262570662, 0.289512700708878, 0.289512700708878, 0.289512700708878, 0.25101007807465936, 0.25101007807465936, 0.25101007807465936, 0.2805889048861463, 0.2805889048861463, 0.2805889048861463, 0.1938355108799522, 0.1938355108799522, 0.1938355108799522, 0.5382277299287765, 0.5382277299287765, 0.5382277299287765, 0.13308044902477267, 0.13308044902477267, 0.13308044902477267, 0.2128732088017652, 0.2128732088017652, 0.2128732088017652, 0.08241768132517446, 0.08241768132517446, 0.08241768132517446, 0.10436349261071776, 0.10436349261071776, 0.10436349261071776, 0.10160351209938867, 0.10160351209938867, 0.10160351209938867, 0.14582899012712947, 0.14582899012712947, 0.14582899012712947, 0.1431914207571281, 0.1431914207571281, 0.1431914207571281, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05632451808081074, 0.05632451808081074, 0.05632451808081074, 0.039749703772666733, 0.039749703772666733, 0.039749703772666733, 0.053099667326783506, 0.053099667326783506, 0.053099667326783506, 0.0031933394807112103, 0.0031933394807112103, 0.0031933394807112103, 0.009832821140264403, 0.009832821140264403, 0.009832821140264403, 0.0044176867605423276, 0.0044176867605423276, 0.0044176867605423276, 0.07405459178849672, 0.07405459178849672, 0.07405459178849672, 0.06774631618524107, 0.06774631618524107, 0.06774631618524107, 0.12044886941971467, 0.12044886941971467, 0.12044886941971467, 0.39397681901470905, 0.39397681901470905, 0.39397681901470905, 0.39139575007478256, 0.39139575007478256, 0.39139575007478256, 0.38366470728847624, 0.38366470728847624, 0.38366470728847624, 0.08312839447107467, 0.08312839447107467, 0.08312839447107467, 0.07955109096991642, 0.07955109096991642, 0.07955109096991642, 0.09376273983891747, 0.09376273983891747, 0.09376273983891747, 0.22377028087310702, 0.22377028087310702, 0.22377028087310702, 0.16034745541819162, 0.16034745541819162, 0.16034745541819162, 0.11886680238055036, 0.11886680238055036, 0.11886680238055036, 0.25579184507603636, 0.25579184507603636, 0.25579184507603636, 0.19595917432938914, 0.19595917432938914, 0.19595917432938914, 0.21508571481472172, 0.21508571481472172, 0.21508571481472172, 0.1950671793470259, 0.1950671793470259, 0.1950671793470259, 0.11844289764863569, 0.11844289764863569, 0.11844289764863569, 0.1389309027344452, 0.1389309027344452, 0.1389309027344452, 0.1770961101327987, 0.1770961101327987, 0.1770961101327987, 0.18334517653439142, 0.18334517653439142, 0.18334517653439142, 0.18025091714718877, 0.18025091714718877, 0.18025091714718877, 0.17211241818905387, 0.17211241818905387, 0.17211241818905387, 0.16490091021138198, 0.16490091021138198, 0.16490091021138198, 0.1861463959551869, 0.1861463959551869, 0.1861463959551869, 0.3600997036560234, 0.3600997036560234, 0.3600997036560234, 0.5368098732189369, 0.5368098732189369, 0.5368098732189369, 0.5971310062499722, 0.5971310062499722, 0.5971310062499722, 0.38775399495128704, 0.38775399495128704, 0.38775399495128704, 0.5380442697525583, 0.5380442697525583, 0.5380442697525583, 0.14838241689308107, 0.14838241689308107, 0.14838241689308107, 0.17640069518490287, 0.17640069518490287, 0.17640069518490287, 0.17541395294301398, 0.17541395294301398, 0.17541395294301398, 0.1996862182986977, 0.1996862182986977, 0.1996862182986977, 0.07076643444099973, 0.07076643444099973, 0.07076643444099973, 0.07040084661770818, 0.07040084661770818, 0.07040084661770818, 0.061524231846179056, 0.061524231846179056, 0.061524231846179056]}, "mutation_prompt": null}
{"id": "c9eef12c-a7b1-470a-bfa7-55c35e8d090c", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # Initial population size\n        self.mutation_factor = 0.5  # Differential evolution parameter\n        self.crossover_rate = 0.7  # Crossover probability\n        self.alpha = 0.5  # Firefly algorithm parameter\n        self.gamma = 1.0  # Light absorption coefficient\n        self.success_history = []\n        self.learning_rate = 0.01  # Introduced learning rate for adaptability \n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        budget_used = 0\n\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            # Update crossover rate based on fitness variance\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation with dynamic mutation factor\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:  # Adapt mutation factor based on success history\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n                \n                # Introduce diversity-based mutation scaling\n                diversity_scale = 1.0 + np.std(population) / self.dim\n                dynamic_mutation_factor *= diversity_scale\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover with adaptive crossover rate\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(self.learning_rate)  # Adjust success weight\n                else:\n                    self.success_history.append(-self.learning_rate)\n\n            # Firefly algorithm component with adaptive parameters\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        # Adaptive alpha for dynamic search balance\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        # Bound check\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            # Update population\n            population = new_population\n            \n            # Update best solution\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            # Adjust population size based on fitness diversity\n            if np.std(fitness) < 1e-3:  # Population converged\n                self.population_size = max(10, self.population_size - 2)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Enhance adaptive exploration by introducing diversity-based mutation scaling for improved convergence.", "configspace": "", "generation": 66, "fitness": 0.1610378800451491, "feedback": "The algorithm HybridDEFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.13.", "error": "", "parent_id": "b9014d17-850d-48f8-8b7c-3b9d1d71a930", "metadata": {"aucs": [0.4136235981084757, 0.4136235981084757, 0.4136235981084757, 0.42348366946848903, 0.42348366946848903, 0.42348366946848903, 0.4010135565983304, 0.4010135565983304, 0.4010135565983304, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016083396952363938, 0.016083396952363938, 0.016083396952363938, 0.10060494615886095, 0.10060494615886095, 0.10060494615886095, 0.11676207343090972, 0.11676207343090972, 0.11676207343090972, 0.06418764088186923, 0.06418764088186923, 0.06418764088186923, 0.053780917597702094, 0.053780917597702094, 0.053780917597702094, 0.06617447066954718, 0.06617447066954718, 0.06617447066954718, 0.055994112514088146, 0.055994112514088146, 0.055994112514088146, 0.2939641992484129, 0.2939641992484129, 0.2939641992484129, 0.12071310053046813, 0.12071310053046813, 0.12071310053046813, 0.7294439619065126, 0.7294439619065126, 0.7294439619065126, 0.23899557880216726, 0.23899557880216726, 0.23899557880216726, 0.24694757283551183, 0.24694757283551183, 0.24694757283551183, 0.27063323248711424, 0.27063323248711424, 0.27063323248711424, 0.12733185290584403, 0.12733185290584403, 0.12733185290584403, 0.17575005798452892, 0.17575005798452892, 0.17575005798452892, 0.1592701243653668, 0.1592701243653668, 0.1592701243653668, 0.10327644618209886, 0.10327644618209886, 0.10327644618209886, 0.13349466877480554, 0.13349466877480554, 0.13349466877480554, 0.14587853342594392, 0.14587853342594392, 0.14587853342594392, 0.1040146447675494, 0.1040146447675494, 0.1040146447675494, 0.14960996011536443, 0.14960996011536443, 0.14960996011536443, 0.11401148276121187, 0.11401148276121187, 0.11401148276121187, 0.026373767435292628, 0.026373767435292628, 0.026373767435292628, 0.00020241267558651632, 0.00020241267558651632, 0.00020241267558651632, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08175187232700332, 0.08175187232700332, 0.08175187232700332, 0.017681452999810277, 0.017681452999810277, 0.017681452999810277, 0.10074257132650144, 0.10074257132650144, 0.10074257132650144, 0.007261799367988764, 0.007261799367988764, 0.007261799367988764, 0.00769027072052364, 0.00769027072052364, 0.00769027072052364, 0.013095051878099784, 0.013095051878099784, 0.013095051878099784, 0.07382800861470062, 0.07382800861470062, 0.07382800861470062, 0.09513211952667555, 0.09513211952667555, 0.09513211952667555, 0.08550215786774285, 0.08550215786774285, 0.08550215786774285, 0.38544924251688495, 0.38544924251688495, 0.38544924251688495, 0.3789904019499273, 0.3789904019499273, 0.3789904019499273, 0.34930353750757714, 0.34930353750757714, 0.34930353750757714, 0.08461917938387564, 0.08461917938387564, 0.08461917938387564, 0.07496669229163266, 0.07496669229163266, 0.07496669229163266, 0.06254998120900512, 0.06254998120900512, 0.06254998120900512, 0.13503021011252148, 0.13503021011252148, 0.13503021011252148, 0.12665574552012926, 0.12665574552012926, 0.12665574552012926, 0.15010751658011723, 0.15010751658011723, 0.15010751658011723, 0.20400199729487056, 0.20400199729487056, 0.20400199729487056, 0.24164888031562137, 0.24164888031562137, 0.24164888031562137, 0.1816185746496657, 0.1816185746496657, 0.1816185746496657, 0.1355284323433309, 0.1355284323433309, 0.1355284323433309, 0.17192099307190623, 0.17192099307190623, 0.17192099307190623, 0.17736760532815965, 0.17736760532815965, 0.17736760532815965, 0.1510890829620981, 0.1510890829620981, 0.1510890829620981, 0.1604083507232641, 0.1604083507232641, 0.1604083507232641, 0.1735446210531436, 0.1735446210531436, 0.1735446210531436, 0.14770127296706392, 0.14770127296706392, 0.14770127296706392, 0.16888909432214128, 0.16888909432214128, 0.16888909432214128, 0.1617906860513615, 0.1617906860513615, 0.1617906860513615, 0.5488584465822524, 0.5488584465822524, 0.5488584465822524, 0.16145335228434055, 0.16145335228434055, 0.16145335228434055, 0.1740966320947207, 0.1740966320947207, 0.1740966320947207, 0.32231656448013735, 0.32231656448013735, 0.32231656448013735, 0.24945672618525017, 0.24945672618525017, 0.24945672618525017, 0.19037143051399785, 0.19037143051399785, 0.19037143051399785, 0.20053306950389382, 0.20053306950389382, 0.20053306950389382, 0.18677107279941096, 0.18677107279941096, 0.18677107279941096, 0.17578667241567436, 0.17578667241567436, 0.17578667241567436, 0.07655811408752067, 0.07655811408752067, 0.07655811408752067, 0.08420969822616386, 0.08420969822616386, 0.08420969822616386, 0.06652820170961282, 0.06652820170961282, 0.06652820170961282]}, "mutation_prompt": null}
{"id": "b87de65e-9acd-4e7d-9be1-d72200db0f3b", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.alpha = 0.5\n        self.gamma = 1.0\n        self.success_history = []\n        self.learning_rate = 0.01\n\n    def __call__(self, func):\n        np.random.seed(42)\n        budget_used = 0\n\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(self.learning_rate)\n                else:\n                    self.success_history.append(-self.learning_rate)\n\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            population = new_population\n            \n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if np.std(fitness) < 1e-3:\n                self.population_size = max(10, self.population_size - 3)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Refine convergence by enhancing adaptive mutation and reducing premature convergence through fitness diversity management.", "configspace": "", "generation": 67, "fitness": 0.19127216682096637, "feedback": "The algorithm HybridDEFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.17.", "error": "", "parent_id": "b9014d17-850d-48f8-8b7c-3b9d1d71a930", "metadata": {"aucs": [0.39863334251338334, 0.39863334251338334, 0.39863334251338334, 0.4066538852094912, 0.4066538852094912, 0.4066538852094912, 0.4343198418977341, 0.4343198418977341, 0.4343198418977341, 0.0007487320778982731, 0.0007487320778982731, 0.0007487320778982731, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.036755123399678236, 0.036755123399678236, 0.036755123399678236, 0.105929124906886, 0.105929124906886, 0.105929124906886, 0.10915195280178414, 0.10915195280178414, 0.10915195280178414, 0.07458004233195081, 0.07458004233195081, 0.07458004233195081, 0.051646841238568775, 0.051646841238568775, 0.051646841238568775, 0.08567543929878552, 0.08567543929878552, 0.08567543929878552, 0.027586075482045502, 0.027586075482045502, 0.027586075482045502, 0.10889444655256886, 0.10889444655256886, 0.10889444655256886, 0.7029584282198529, 0.7029584282198529, 0.7029584282198529, 0.7734815697578562, 0.7734815697578562, 0.7734815697578562, 0.2864337541478481, 0.2864337541478481, 0.2864337541478481, 0.25749003086369093, 0.25749003086369093, 0.25749003086369093, 0.288765339557277, 0.288765339557277, 0.288765339557277, 0.1416131579316494, 0.1416131579316494, 0.1416131579316494, 0.17752549808622176, 0.17752549808622176, 0.17752549808622176, 0.20739549858808548, 0.20739549858808548, 0.20739549858808548, 0.16555214246534888, 0.16555214246534888, 0.16555214246534888, 0.1320635265460629, 0.1320635265460629, 0.1320635265460629, 0.15490494521394083, 0.15490494521394083, 0.15490494521394083, 0.10378564265407642, 0.10378564265407642, 0.10378564265407642, 0.14353028560240833, 0.14353028560240833, 0.14353028560240833, 0.14444582720468246, 0.14444582720468246, 0.14444582720468246, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03221542911019826, 0.03221542911019826, 0.03221542911019826, 0.007027457411631466, 0.007027457411631466, 0.007027457411631466, 0.07023000239267241, 0.07023000239267241, 0.07023000239267241, 0.024365317163340672, 0.024365317163340672, 0.024365317163340672, 0.08633433599740603, 0.08633433599740603, 0.08633433599740603, 0.01665861948074454, 0.01665861948074454, 0.01665861948074454, 0.0109233251036579, 0.0109233251036579, 0.0109233251036579, 0.012332516644685931, 0.012332516644685931, 0.012332516644685931, 0.08603994253043434, 0.08603994253043434, 0.08603994253043434, 0.09908482588110523, 0.09908482588110523, 0.09908482588110523, 0.10083970070392156, 0.10083970070392156, 0.10083970070392156, 0.3809129826045433, 0.3809129826045433, 0.3809129826045433, 0.3980241596352503, 0.3980241596352503, 0.3980241596352503, 0.39390203626484777, 0.39390203626484777, 0.39390203626484777, 0.09529085541199911, 0.09529085541199911, 0.09529085541199911, 0.11585988810488812, 0.11585988810488812, 0.11585988810488812, 0.12415475249614605, 0.12415475249614605, 0.12415475249614605, 0.12764384611517776, 0.12764384611517776, 0.12764384611517776, 0.14505401424099218, 0.14505401424099218, 0.14505401424099218, 0.1508553367709019, 0.1508553367709019, 0.1508553367709019, 0.2882344069386781, 0.2882344069386781, 0.2882344069386781, 0.1863569632198374, 0.1863569632198374, 0.1863569632198374, 0.2825581533360362, 0.2825581533360362, 0.2825581533360362, 0.17506716947531242, 0.17506716947531242, 0.17506716947531242, 0.1230206999321325, 0.1230206999321325, 0.1230206999321325, 0.1356136719142922, 0.1356136719142922, 0.1356136719142922, 0.19547468518908673, 0.19547468518908673, 0.19547468518908673, 0.1914821002699979, 0.1914821002699979, 0.1914821002699979, 0.16510572399349144, 0.16510572399349144, 0.16510572399349144, 0.17106885167509278, 0.17106885167509278, 0.17106885167509278, 0.1774311856550208, 0.1774311856550208, 0.1774311856550208, 0.18594299269645376, 0.18594299269645376, 0.18594299269645376, 0.5233485770012858, 0.5233485770012858, 0.5233485770012858, 0.6012738008787226, 0.6012738008787226, 0.6012738008787226, 0.5528077856791676, 0.5528077856791676, 0.5528077856791676, 0.5022861422862444, 0.5022861422862444, 0.5022861422862444, 0.3245007877804995, 0.3245007877804995, 0.3245007877804995, 0.19740538285541087, 0.19740538285541087, 0.19740538285541087, 0.18270902558243673, 0.18270902558243673, 0.18270902558243673, 0.18800348573477366, 0.18800348573477366, 0.18800348573477366, 0.2034621638408607, 0.2034621638408607, 0.2034621638408607, 0.07379263696788074, 0.07379263696788074, 0.07379263696788074, 0.08701700788379418, 0.08701700788379418, 0.08701700788379418, 0.05916277170875073, 0.05916277170875073, 0.05916277170875073]}, "mutation_prompt": null}
{"id": "dffd0023-fcab-48c6-9ee1-b91c6a05ed37", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.alpha = 0.5\n        self.gamma = 1.0\n        self.success_history = []\n        self.learning_rate = 0.01\n\n    def __call__(self, func):\n        np.random.seed(42)\n        budget_used = 0\n\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(self.learning_rate)\n                else:\n                    self.success_history.append(-self.learning_rate)\n\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            population = new_population\n            \n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if np.std(fitness) < 1e-3:\n                self.population_size = max(10, self.population_size - 3)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Refine convergence by enhancing adaptive mutation and reducing premature convergence through fitness diversity management.", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b87de65e-9acd-4e7d-9be1-d72200db0f3b", "metadata": {"aucs": [0.39863334251338334, 0.39863334251338334, 0.39863334251338334, 0.4066538852094912, 0.4066538852094912, 0.4066538852094912, 0.4343198418977341, 0.4343198418977341, 0.4343198418977341, 0.0007487320778982731, 0.0007487320778982731, 0.0007487320778982731, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.036755123399678236, 0.036755123399678236, 0.036755123399678236, 0.105929124906886, 0.105929124906886, 0.105929124906886, 0.10915195280178414, 0.10915195280178414, 0.10915195280178414, 0.07458004233195081, 0.07458004233195081, 0.07458004233195081, 0.051646841238568775, 0.051646841238568775, 0.051646841238568775, 0.08567543929878552, 0.08567543929878552, 0.08567543929878552, 0.027586075482045502, 0.027586075482045502, 0.027586075482045502, 0.10889444655256886, 0.10889444655256886, 0.10889444655256886, 0.7029584282198529, 0.7029584282198529, 0.7029584282198529, 0.7734815697578562, 0.7734815697578562, 0.7734815697578562, 0.2864337541478481, 0.2864337541478481, 0.2864337541478481, 0.25749003086369093, 0.25749003086369093, 0.25749003086369093, 0.288765339557277, 0.288765339557277, 0.288765339557277, 0.1416131579316494, 0.1416131579316494, 0.1416131579316494, 0.17752549808622176, 0.17752549808622176, 0.17752549808622176, 0.20739549858808548, 0.20739549858808548, 0.20739549858808548, 0.16555214246534888, 0.16555214246534888, 0.16555214246534888, 0.1320635265460629, 0.1320635265460629, 0.1320635265460629, 0.15490494521394083, 0.15490494521394083, 0.15490494521394083, 0.10378564265407642, 0.10378564265407642, 0.10378564265407642, 0.14353028560240833, 0.14353028560240833, 0.14353028560240833, 0.14444582720468246, 0.14444582720468246, 0.14444582720468246, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03221542911019826, 0.03221542911019826, 0.03221542911019826, 0.007027457411631466, 0.007027457411631466, 0.007027457411631466, 0.07023000239267241, 0.07023000239267241, 0.07023000239267241, 0.024365317163340672, 0.024365317163340672, 0.024365317163340672, 0.08633433599740603, 0.08633433599740603, 0.08633433599740603, 0.01665861948074454, 0.01665861948074454, 0.01665861948074454, 0.0109233251036579, 0.0109233251036579, 0.0109233251036579, 0.012332516644685931, 0.012332516644685931, 0.012332516644685931, 0.08603994253043434, 0.08603994253043434, 0.08603994253043434, 0.09908482588110523, 0.09908482588110523, 0.09908482588110523, 0.10083970070392156, 0.10083970070392156, 0.10083970070392156, 0.3809129826045433, 0.3809129826045433, 0.3809129826045433, 0.3980241596352503, 0.3980241596352503, 0.3980241596352503, 0.39390203626484777, 0.39390203626484777, 0.39390203626484777, 0.09529085541199911, 0.09529085541199911, 0.09529085541199911, 0.11585988810488812, 0.11585988810488812, 0.11585988810488812, 0.12415475249614605, 0.12415475249614605, 0.12415475249614605, 0.12764384611517776, 0.12764384611517776, 0.12764384611517776, 0.14505401424099218, 0.14505401424099218, 0.14505401424099218, 0.1508553367709019, 0.1508553367709019, 0.1508553367709019, 0.2882344069386781, 0.2882344069386781, 0.2882344069386781, 0.1863569632198374, 0.1863569632198374, 0.1863569632198374, 0.2825581533360362, 0.2825581533360362, 0.2825581533360362, 0.17506716947531242, 0.17506716947531242, 0.17506716947531242, 0.1230206999321325, 0.1230206999321325, 0.1230206999321325, 0.1356136719142922, 0.1356136719142922, 0.1356136719142922, 0.19547468518908673, 0.19547468518908673, 0.19547468518908673, 0.1914821002699979, 0.1914821002699979, 0.1914821002699979, 0.16510572399349144, 0.16510572399349144, 0.16510572399349144, 0.17106885167509278, 0.17106885167509278, 0.17106885167509278, 0.1774311856550208, 0.1774311856550208, 0.1774311856550208, 0.18594299269645376, 0.18594299269645376, 0.18594299269645376, 0.5233485770012858, 0.5233485770012858, 0.5233485770012858, 0.6012738008787226, 0.6012738008787226, 0.6012738008787226, 0.5528077856791676, 0.5528077856791676, 0.5528077856791676, 0.5022861422862444, 0.5022861422862444, 0.5022861422862444, 0.3245007877804995, 0.3245007877804995, 0.3245007877804995, 0.19740538285541087, 0.19740538285541087, 0.19740538285541087, 0.18270902558243673, 0.18270902558243673, 0.18270902558243673, 0.18800348573477366, 0.18800348573477366, 0.18800348573477366, 0.2034621638408607, 0.2034621638408607, 0.2034621638408607, 0.07379263696788074, 0.07379263696788074, 0.07379263696788074, 0.08701700788379418, 0.08701700788379418, 0.08701700788379418, 0.05916277170875073, 0.05916277170875073, 0.05916277170875073]}, "mutation_prompt": null}
{"id": "0c3294e9-bade-4495-ae92-ce6305530b75", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.alpha = 0.5\n        self.gamma = 1.0\n        self.success_history = []\n        self.learning_rate = 0.01\n\n    def __call__(self, func):\n        np.random.seed(42)\n        budget_used = 0\n\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(self.learning_rate)\n                else:\n                    self.success_history.append(-self.learning_rate)\n\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            population = new_population\n            \n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if np.std(fitness) < 1e-3:\n                self.population_size = max(10, self.population_size - 3)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Refine convergence by enhancing adaptive mutation and reducing premature convergence through fitness diversity management.", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b87de65e-9acd-4e7d-9be1-d72200db0f3b", "metadata": {"aucs": [0.39863334251338334, 0.39863334251338334, 0.39863334251338334, 0.4066538852094912, 0.4066538852094912, 0.4066538852094912, 0.4343198418977341, 0.4343198418977341, 0.4343198418977341, 0.0007487320778982731, 0.0007487320778982731, 0.0007487320778982731, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.036755123399678236, 0.036755123399678236, 0.036755123399678236, 0.105929124906886, 0.105929124906886, 0.105929124906886, 0.10915195280178414, 0.10915195280178414, 0.10915195280178414, 0.07458004233195081, 0.07458004233195081, 0.07458004233195081, 0.051646841238568775, 0.051646841238568775, 0.051646841238568775, 0.08567543929878552, 0.08567543929878552, 0.08567543929878552, 0.027586075482045502, 0.027586075482045502, 0.027586075482045502, 0.10889444655256886, 0.10889444655256886, 0.10889444655256886, 0.7029584282198529, 0.7029584282198529, 0.7029584282198529, 0.7734815697578562, 0.7734815697578562, 0.7734815697578562, 0.2864337541478481, 0.2864337541478481, 0.2864337541478481, 0.25749003086369093, 0.25749003086369093, 0.25749003086369093, 0.288765339557277, 0.288765339557277, 0.288765339557277, 0.1416131579316494, 0.1416131579316494, 0.1416131579316494, 0.17752549808622176, 0.17752549808622176, 0.17752549808622176, 0.20739549858808548, 0.20739549858808548, 0.20739549858808548, 0.16555214246534888, 0.16555214246534888, 0.16555214246534888, 0.1320635265460629, 0.1320635265460629, 0.1320635265460629, 0.15490494521394083, 0.15490494521394083, 0.15490494521394083, 0.10378564265407642, 0.10378564265407642, 0.10378564265407642, 0.14353028560240833, 0.14353028560240833, 0.14353028560240833, 0.14444582720468246, 0.14444582720468246, 0.14444582720468246, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03221542911019826, 0.03221542911019826, 0.03221542911019826, 0.007027457411631466, 0.007027457411631466, 0.007027457411631466, 0.07023000239267241, 0.07023000239267241, 0.07023000239267241, 0.024365317163340672, 0.024365317163340672, 0.024365317163340672, 0.08633433599740603, 0.08633433599740603, 0.08633433599740603, 0.01665861948074454, 0.01665861948074454, 0.01665861948074454, 0.0109233251036579, 0.0109233251036579, 0.0109233251036579, 0.012332516644685931, 0.012332516644685931, 0.012332516644685931, 0.08603994253043434, 0.08603994253043434, 0.08603994253043434, 0.09908482588110523, 0.09908482588110523, 0.09908482588110523, 0.10083970070392156, 0.10083970070392156, 0.10083970070392156, 0.3809129826045433, 0.3809129826045433, 0.3809129826045433, 0.3980241596352503, 0.3980241596352503, 0.3980241596352503, 0.39390203626484777, 0.39390203626484777, 0.39390203626484777, 0.09529085541199911, 0.09529085541199911, 0.09529085541199911, 0.11585988810488812, 0.11585988810488812, 0.11585988810488812, 0.12415475249614605, 0.12415475249614605, 0.12415475249614605, 0.12764384611517776, 0.12764384611517776, 0.12764384611517776, 0.14505401424099218, 0.14505401424099218, 0.14505401424099218, 0.1508553367709019, 0.1508553367709019, 0.1508553367709019, 0.2882344069386781, 0.2882344069386781, 0.2882344069386781, 0.1863569632198374, 0.1863569632198374, 0.1863569632198374, 0.2825581533360362, 0.2825581533360362, 0.2825581533360362, 0.17506716947531242, 0.17506716947531242, 0.17506716947531242, 0.1230206999321325, 0.1230206999321325, 0.1230206999321325, 0.1356136719142922, 0.1356136719142922, 0.1356136719142922, 0.19547468518908673, 0.19547468518908673, 0.19547468518908673, 0.1914821002699979, 0.1914821002699979, 0.1914821002699979, 0.16510572399349144, 0.16510572399349144, 0.16510572399349144, 0.17106885167509278, 0.17106885167509278, 0.17106885167509278, 0.1774311856550208, 0.1774311856550208, 0.1774311856550208, 0.18594299269645376, 0.18594299269645376, 0.18594299269645376, 0.5233485770012858, 0.5233485770012858, 0.5233485770012858, 0.6012738008787226, 0.6012738008787226, 0.6012738008787226, 0.5528077856791676, 0.5528077856791676, 0.5528077856791676, 0.5022861422862444, 0.5022861422862444, 0.5022861422862444, 0.3245007877804995, 0.3245007877804995, 0.3245007877804995, 0.19740538285541087, 0.19740538285541087, 0.19740538285541087, 0.18270902558243673, 0.18270902558243673, 0.18270902558243673, 0.18800348573477366, 0.18800348573477366, 0.18800348573477366, 0.2034621638408607, 0.2034621638408607, 0.2034621638408607, 0.07379263696788074, 0.07379263696788074, 0.07379263696788074, 0.08701700788379418, 0.08701700788379418, 0.08701700788379418, 0.05916277170875073, 0.05916277170875073, 0.05916277170875073]}, "mutation_prompt": null}
{"id": "942379f2-795a-4d2c-a9c9-ede1fe50a423", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.alpha = 0.5\n        self.gamma = 1.0\n        self.success_history = []\n        self.learning_rate = 0.01\n\n    def __call__(self, func):\n        np.random.seed(42)\n        budget_used = 0\n\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(self.learning_rate * np.random.rand())\n                else:\n                    self.success_history.append(-self.learning_rate * np.random.rand())\n\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            population = new_population\n            \n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if np.std(fitness) < 1e-3:\n                self.population_size = max(10, self.population_size - 3)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Refine convergence by introducing stochastic adaptive learning rate to enhance global exploration and diversity.", "configspace": "", "generation": 70, "fitness": 0.1920101902466348, "feedback": "The algorithm HybridDEFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.16.", "error": "", "parent_id": "b87de65e-9acd-4e7d-9be1-d72200db0f3b", "metadata": {"aucs": [0.4316324779008963, 0.4316324779008963, 0.4316324779008963, 0.4398310658013598, 0.4398310658013598, 0.4398310658013598, 0.474673678009655, 0.474673678009655, 0.474673678009655, 0.04456333248430622, 0.04456333248430622, 0.04456333248430622, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11822986331965624, 0.11822986331965624, 0.11822986331965624, 0.09164497827853324, 0.09164497827853324, 0.09164497827853324, 0.0908636064158167, 0.0908636064158167, 0.0908636064158167, 0.056211033215752826, 0.056211033215752826, 0.056211033215752826, 0.06963770071126196, 0.06963770071126196, 0.06963770071126196, 0.06267493469288687, 0.06267493469288687, 0.06267493469288687, 0.7914905691714824, 0.7914905691714824, 0.7914905691714824, 0.4641310908934111, 0.4641310908934111, 0.4641310908934111, 0.12063358030336657, 0.12063358030336657, 0.12063358030336657, 0.275038132570418, 0.275038132570418, 0.275038132570418, 0.25800275984318044, 0.25800275984318044, 0.25800275984318044, 0.2828331037421219, 0.2828331037421219, 0.2828331037421219, 0.546148739517615, 0.546148739517615, 0.546148739517615, 0.49315404315195943, 0.49315404315195943, 0.49315404315195943, 0.12092865580081091, 0.12092865580081091, 0.12092865580081091, 0.15657466284802435, 0.15657466284802435, 0.15657466284802435, 0.1804585139809013, 0.1804585139809013, 0.1804585139809013, 0.14432521485423855, 0.14432521485423855, 0.14432521485423855, 0.16024207820954994, 0.16024207820954994, 0.16024207820954994, 0.15013688245464196, 0.15013688245464196, 0.15013688245464196, 0.19907065109987732, 0.19907065109987732, 0.19907065109987732, 0.031729437177347775, 0.031729437177347775, 0.031729437177347775, 0.028998388520592222, 0.028998388520592222, 0.028998388520592222, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08362624935201035, 0.08362624935201035, 0.08362624935201035, 0.026425201363172723, 0.026425201363172723, 0.026425201363172723, 0.06519401048334916, 0.06519401048334916, 0.06519401048334916, 0.01433911361584106, 0.01433911361584106, 0.01433911361584106, 0.00769537993512881, 0.00769537993512881, 0.00769537993512881, 0.010672672204237843, 0.010672672204237843, 0.010672672204237843, 0.059988656179477906, 0.059988656179477906, 0.059988656179477906, 0.0719538127449929, 0.0719538127449929, 0.0719538127449929, 0.12445086477063416, 0.12445086477063416, 0.12445086477063416, 0.4300796449516281, 0.4300796449516281, 0.4300796449516281, 0.41390419414102964, 0.41390419414102964, 0.41390419414102964, 0.4006953206652003, 0.4006953206652003, 0.4006953206652003, 0.08439171442247262, 0.08439171442247262, 0.08439171442247262, 0.10349533107671194, 0.10349533107671194, 0.10349533107671194, 0.0966051784144325, 0.0966051784144325, 0.0966051784144325, 0.1821114128508161, 0.1821114128508161, 0.1821114128508161, 0.13169165430578655, 0.13169165430578655, 0.13169165430578655, 0.12619252740933895, 0.12619252740933895, 0.12619252740933895, 0.1900519975436027, 0.1900519975436027, 0.1900519975436027, 0.2768870409019287, 0.2768870409019287, 0.2768870409019287, 0.2502306362202801, 0.2502306362202801, 0.2502306362202801, 0.1626236108685689, 0.1626236108685689, 0.1626236108685689, 0.19966827225050665, 0.19966827225050665, 0.19966827225050665, 0.1513681333485729, 0.1513681333485729, 0.1513681333485729, 0.19446153617568185, 0.19446153617568185, 0.19446153617568185, 0.21986928713464082, 0.21986928713464082, 0.21986928713464082, 0.18059021773131412, 0.18059021773131412, 0.18059021773131412, 0.1666662635160162, 0.1666662635160162, 0.1666662635160162, 0.1879675952038391, 0.1879675952038391, 0.1879675952038391, 0.16564311194612635, 0.16564311194612635, 0.16564311194612635, 0.5901935543397198, 0.5901935543397198, 0.5901935543397198, 0.15138270376521756, 0.15138270376521756, 0.15138270376521756, 0.47012941168044886, 0.47012941168044886, 0.47012941168044886, 0.279290080562398, 0.279290080562398, 0.279290080562398, 0.363666351089849, 0.363666351089849, 0.363666351089849, 0.14576118837238505, 0.14576118837238505, 0.14576118837238505, 0.19347004645180377, 0.19347004645180377, 0.19347004645180377, 0.18188146747909306, 0.18188146747909306, 0.18188146747909306, 0.18945171911003622, 0.18945171911003622, 0.18945171911003622, 0.06473514223413601, 0.06473514223413601, 0.06473514223413601, 0.0623151630178439, 0.0623151630178439, 0.0623151630178439, 0.06875705295777046, 0.06875705295777046, 0.06875705295777046]}, "mutation_prompt": null}
{"id": "a47b2e20-f894-4e0f-9845-640b09c84bb9", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.alpha = 0.5\n        self.gamma = 1.0\n        self.success_history = []\n        self.learning_rate = 0.01\n\n    def __call__(self, func):\n        np.random.seed(42)\n        budget_used = 0\n\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(self.learning_rate * np.random.rand())\n                else:\n                    self.success_history.append(-self.learning_rate * np.random.rand())\n\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            population = new_population\n            \n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if np.std(fitness) < 1e-3:\n                self.population_size = max(10, self.population_size - 3)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Refine convergence by introducing stochastic adaptive learning rate to enhance global exploration and diversity.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "942379f2-795a-4d2c-a9c9-ede1fe50a423", "metadata": {"aucs": [0.4316324779008963, 0.4316324779008963, 0.4316324779008963, 0.4398310658013598, 0.4398310658013598, 0.4398310658013598, 0.474673678009655, 0.474673678009655, 0.474673678009655, 0.04456333248430622, 0.04456333248430622, 0.04456333248430622, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11822986331965624, 0.11822986331965624, 0.11822986331965624, 0.09164497827853324, 0.09164497827853324, 0.09164497827853324, 0.0908636064158167, 0.0908636064158167, 0.0908636064158167, 0.056211033215752826, 0.056211033215752826, 0.056211033215752826, 0.06963770071126196, 0.06963770071126196, 0.06963770071126196, 0.06267493469288687, 0.06267493469288687, 0.06267493469288687, 0.7914905691714824, 0.7914905691714824, 0.7914905691714824, 0.4641310908934111, 0.4641310908934111, 0.4641310908934111, 0.12063358030336657, 0.12063358030336657, 0.12063358030336657, 0.275038132570418, 0.275038132570418, 0.275038132570418, 0.25800275984318044, 0.25800275984318044, 0.25800275984318044, 0.2828331037421219, 0.2828331037421219, 0.2828331037421219, 0.546148739517615, 0.546148739517615, 0.546148739517615, 0.49315404315195943, 0.49315404315195943, 0.49315404315195943, 0.12092865580081091, 0.12092865580081091, 0.12092865580081091, 0.15657466284802435, 0.15657466284802435, 0.15657466284802435, 0.1804585139809013, 0.1804585139809013, 0.1804585139809013, 0.14432521485423855, 0.14432521485423855, 0.14432521485423855, 0.16024207820954994, 0.16024207820954994, 0.16024207820954994, 0.15013688245464196, 0.15013688245464196, 0.15013688245464196, 0.19907065109987732, 0.19907065109987732, 0.19907065109987732, 0.031729437177347775, 0.031729437177347775, 0.031729437177347775, 0.028998388520592222, 0.028998388520592222, 0.028998388520592222, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08362624935201035, 0.08362624935201035, 0.08362624935201035, 0.026425201363172723, 0.026425201363172723, 0.026425201363172723, 0.06519401048334916, 0.06519401048334916, 0.06519401048334916, 0.01433911361584106, 0.01433911361584106, 0.01433911361584106, 0.00769537993512881, 0.00769537993512881, 0.00769537993512881, 0.010672672204237843, 0.010672672204237843, 0.010672672204237843, 0.059988656179477906, 0.059988656179477906, 0.059988656179477906, 0.0719538127449929, 0.0719538127449929, 0.0719538127449929, 0.12445086477063416, 0.12445086477063416, 0.12445086477063416, 0.4300796449516281, 0.4300796449516281, 0.4300796449516281, 0.41390419414102964, 0.41390419414102964, 0.41390419414102964, 0.4006953206652003, 0.4006953206652003, 0.4006953206652003, 0.08439171442247262, 0.08439171442247262, 0.08439171442247262, 0.10349533107671194, 0.10349533107671194, 0.10349533107671194, 0.0966051784144325, 0.0966051784144325, 0.0966051784144325, 0.1821114128508161, 0.1821114128508161, 0.1821114128508161, 0.13169165430578655, 0.13169165430578655, 0.13169165430578655, 0.12619252740933895, 0.12619252740933895, 0.12619252740933895, 0.1900519975436027, 0.1900519975436027, 0.1900519975436027, 0.2768870409019287, 0.2768870409019287, 0.2768870409019287, 0.2502306362202801, 0.2502306362202801, 0.2502306362202801, 0.1626236108685689, 0.1626236108685689, 0.1626236108685689, 0.19966827225050665, 0.19966827225050665, 0.19966827225050665, 0.1513681333485729, 0.1513681333485729, 0.1513681333485729, 0.19446153617568185, 0.19446153617568185, 0.19446153617568185, 0.21986928713464082, 0.21986928713464082, 0.21986928713464082, 0.18059021773131412, 0.18059021773131412, 0.18059021773131412, 0.1666662635160162, 0.1666662635160162, 0.1666662635160162, 0.1879675952038391, 0.1879675952038391, 0.1879675952038391, 0.16564311194612635, 0.16564311194612635, 0.16564311194612635, 0.5901935543397198, 0.5901935543397198, 0.5901935543397198, 0.15138270376521756, 0.15138270376521756, 0.15138270376521756, 0.47012941168044886, 0.47012941168044886, 0.47012941168044886, 0.279290080562398, 0.279290080562398, 0.279290080562398, 0.363666351089849, 0.363666351089849, 0.363666351089849, 0.14576118837238505, 0.14576118837238505, 0.14576118837238505, 0.19347004645180377, 0.19347004645180377, 0.19347004645180377, 0.18188146747909306, 0.18188146747909306, 0.18188146747909306, 0.18945171911003622, 0.18945171911003622, 0.18945171911003622, 0.06473514223413601, 0.06473514223413601, 0.06473514223413601, 0.0623151630178439, 0.0623151630178439, 0.0623151630178439, 0.06875705295777046, 0.06875705295777046, 0.06875705295777046]}, "mutation_prompt": null}
{"id": "9e3d7839-96d2-499c-9b90-88573f23ed30", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.alpha = 0.5\n        self.gamma = 1.0\n        self.success_history = []\n        self.learning_rate = 0.01\n\n    def __call__(self, func):\n        np.random.seed(42)\n        budget_used = 0\n\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget) * np.std(fitness))\n                if self.success_history:\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(self.learning_rate * np.random.rand())\n                else:\n                    self.success_history.append(-self.learning_rate * np.random.rand())\n\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            population = new_population\n            \n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if np.std(fitness) < 1e-3:\n                self.population_size = max(10, self.population_size - 3)\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Enhance global search by dynamically adjusting the mutation factor using fitness diversity and adaptive learning.", "configspace": "", "generation": 72, "fitness": 0.14239085448784083, "feedback": "The algorithm HybridDEFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.17.", "error": "", "parent_id": "942379f2-795a-4d2c-a9c9-ede1fe50a423", "metadata": {"aucs": [0.4385055982478453, 0.4385055982478453, 0.4385055982478453, 0.43255629303297816, 0.43255629303297816, 0.43255629303297816, 0.44686255860735113, 0.44686255860735113, 0.44686255860735113, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09608018659388473, 0.09608018659388473, 0.09608018659388473, 0.030477174941401564, 0.030477174941401564, 0.030477174941401564, 0.022515430667774172, 0.022515430667774172, 0.022515430667774172, 0.003830279073446907, 0.003830279073446907, 0.003830279073446907, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.4529185275669829, 0.4529185275669829, 0.4529185275669829, 0.5633855954768221, 0.5633855954768221, 0.5633855954768221, 0.4919661006719267, 0.4919661006719267, 0.4919661006719267, 0.252251394409742, 0.252251394409742, 0.252251394409742, 0.13984559793834672, 0.13984559793834672, 0.13984559793834672, 0.04669884321820705, 0.04669884321820705, 0.04669884321820705, 0.05816143503238769, 0.05816143503238769, 0.05816143503238769, 0.08067887781991845, 0.08067887781991845, 0.08067887781991845, 0.0863437793811821, 0.0863437793811821, 0.0863437793811821, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04448984406081313, 0.04448984406081313, 0.04448984406081313, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.048519158062056755, 0.048519158062056755, 0.048519158062056755, 0.029660017931601, 0.029660017931601, 0.029660017931601, 0.019578791189195033, 0.019578791189195033, 0.019578791189195033, 0.001468275871011393, 0.001468275871011393, 0.001468275871011393, 0.02349039166955591, 0.02349039166955591, 0.02349039166955591, 0.005356734935307972, 0.005356734935307972, 0.005356734935307972, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03158998877537411, 0.03158998877537411, 0.03158998877537411, 0.41591039493346116, 0.41591039493346116, 0.41591039493346116, 0.391538126253143, 0.391538126253143, 0.391538126253143, 0.41453125870729757, 0.41453125870729757, 0.41453125870729757, 0.07616212236181819, 0.07616212236181819, 0.07616212236181819, 0.03501469417487568, 0.03501469417487568, 0.03501469417487568, 0.07514846403348163, 0.07514846403348163, 0.07514846403348163, 0.22314279194227893, 0.22314279194227893, 0.22314279194227893, 0.19869437377670074, 0.19869437377670074, 0.19869437377670074, 0.2398796256701159, 0.2398796256701159, 0.2398796256701159, 0.19671313823347358, 0.19671313823347358, 0.19671313823347358, 0.25836424037218, 0.25836424037218, 0.25836424037218, 0.2910504279674021, 0.2910504279674021, 0.2910504279674021, 0.10970747902652278, 0.10970747902652278, 0.10970747902652278, 0.09938875912035583, 0.09938875912035583, 0.09938875912035583, 0.12868986347223876, 0.12868986347223876, 0.12868986347223876, 0.17701392571135732, 0.17701392571135732, 0.17701392571135732, 0.19197192740770808, 0.19197192740770808, 0.19197192740770808, 0.19008775478723372, 0.19008775478723372, 0.19008775478723372, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.5526454954240309, 0.5526454954240309, 0.5526454954240309, 0.15304186325673363, 0.15304186325673363, 0.15304186325673363, 0.6249986188429202, 0.6249986188429202, 0.6249986188429202, 0.28253676217257584, 0.28253676217257584, 0.28253676217257584, 0.19124077206924106, 0.19124077206924106, 0.19124077206924106, 0.15574051557889013, 0.15574051557889013, 0.15574051557889013, 0.18153529339806118, 0.18153529339806118, 0.18153529339806118, 0.17904073032411705, 0.17904073032411705, 0.17904073032411705, 0.1765624781048185, 0.1765624781048185, 0.1765624781048185, 0.07115449631349291, 0.07115449631349291, 0.07115449631349291, 0.05928553684346061, 0.05928553684346061, 0.05928553684346061, 0.06231871766944119, 0.06231871766944119, 0.06231871766944119]}, "mutation_prompt": null}
{"id": "42f2c192-a816-418e-8b6c-b471a4f913ff", "solution": "import numpy as np\n\nclass HybridDEFireflyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.alpha = 0.5\n        self.gamma = 1.0\n        self.success_history = []\n        self.learning_rate = 0.01\n\n    def __call__(self, func):\n        np.random.seed(42)\n        budget_used = 0\n\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < adaptive_crossover_rate:\n                    cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n                    trial = np.where(cross_points, mutant, population[i])\n                else:\n                    trial = population[i]\n\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(self.learning_rate * np.random.rand())\n                else:\n                    self.success_history.append(-self.learning_rate * np.random.rand())\n\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget)) * (1 + np.std(fitness))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            population = new_population\n            \n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if np.std(fitness) < 1e-3:\n                self.population_size = max(10, self.population_size - 3)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFireflyEnhanced", "description": "HybridDEFirefly-Enhanced: Introduce adaptive alpha scaling and selective crossover to improve convergence efficiency.", "configspace": "", "generation": 73, "fitness": 0.13822873572634273, "feedback": "The algorithm HybridDEFireflyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.18.", "error": "", "parent_id": "942379f2-795a-4d2c-a9c9-ede1fe50a423", "metadata": {"aucs": [0.34755608636487345, 0.34755608636487345, 0.34755608636487345, 0.35453254701686854, 0.35453254701686854, 0.35453254701686854, 0.3829426707183484, 0.3829426707183484, 0.3829426707183484, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.037469925128132076, 0.037469925128132076, 0.037469925128132076, 0.04714580426022896, 0.04714580426022896, 0.04714580426022896, 0.045154346381781174, 0.045154346381781174, 0.045154346381781174, 0.029207610005539397, 0.029207610005539397, 0.029207610005539397, 0.022290472014003138, 0.022290472014003138, 0.022290472014003138, 0.028047214633697748, 0.028047214633697748, 0.028047214633697748, 0.8925149061130583, 0.8925149061130583, 0.8925149061130583, 0.5913443829582851, 0.5913443829582851, 0.5913443829582851, 0.9229845746171366, 0.9229845746171366, 0.9229845746171366, 0.0676109015825157, 0.0676109015825157, 0.0676109015825157, 0.04847345345358589, 0.04847345345358589, 0.04847345345358589, 0.05974594417524737, 0.05974594417524737, 0.05974594417524737, 0.1255613309610646, 0.1255613309610646, 0.1255613309610646, 0.19006445151319284, 0.19006445151319284, 0.19006445151319284, 0.11052157386996164, 0.11052157386996164, 0.11052157386996164, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.047266925590935704, 0.047266925590935704, 0.047266925590935704, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.37198645880122627, 0.37198645880122627, 0.37198645880122627, 0.3707339473016389, 0.3707339473016389, 0.3707339473016389, 0.3787462027829913, 0.3787462027829913, 0.3787462027829913, 0.03586788281345221, 0.03586788281345221, 0.03586788281345221, 0.04080012094937557, 0.04080012094937557, 0.04080012094937557, 0.054475691397309456, 0.054475691397309456, 0.054475691397309456, 0.13746802854800844, 0.13746802854800844, 0.13746802854800844, 0.1543678341579502, 0.1543678341579502, 0.1543678341579502, 0.14680337944878352, 0.14680337944878352, 0.14680337944878352, 0.1952558454218769, 0.1952558454218769, 0.1952558454218769, 0.24446470560901024, 0.24446470560901024, 0.24446470560901024, 0.27094665457775535, 0.27094665457775535, 0.27094665457775535, 0.12859577285164014, 0.12859577285164014, 0.12859577285164014, 0.1612179390147752, 0.1612179390147752, 0.1612179390147752, 0.1490533236270034, 0.1490533236270034, 0.1490533236270034, 0.159757880623149, 0.159757880623149, 0.159757880623149, 0.161559257593208, 0.161559257593208, 0.161559257593208, 0.18017240581875282, 0.18017240581875282, 0.18017240581875282, 0.004898432609100611, 0.004898432609100611, 0.004898432609100611, 0.0715401213143606, 0.0715401213143606, 0.0715401213143606, 0.0838688776355937, 0.0838688776355937, 0.0838688776355937, 0.4083566973430829, 0.4083566973430829, 0.4083566973430829, 0.16050500058865258, 0.16050500058865258, 0.16050500058865258, 0.23655414737647218, 0.23655414737647218, 0.23655414737647218, 0.19757903873496185, 0.19757903873496185, 0.19757903873496185, 0.15265642312382421, 0.15265642312382421, 0.15265642312382421, 0.19945109701974228, 0.19945109701974228, 0.19945109701974228, 0.19575729288253085, 0.19575729288253085, 0.19575729288253085, 0.18015739724397895, 0.18015739724397895, 0.18015739724397895, 0.20806501988683757, 0.20806501988683757, 0.20806501988683757, 0.0574536550038276, 0.0574536550038276, 0.0574536550038276, 0.047170284668377804, 0.047170284668377804, 0.047170284668377804, 0.05374703416896953, 0.05374703416896953, 0.05374703416896953]}, "mutation_prompt": null}
{"id": "d81f9e90-fbde-44e3-9b50-f76a8bd0a7e8", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.alpha = 0.5\n        self.gamma = 1.0\n        self.success_history = []\n        self.learning_rate = 0.01\n\n    def __call__(self, func):\n        np.random.seed(42)\n        budget_used = 0\n\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(self.learning_rate * np.random.rand())\n                else:\n                    self.success_history.append(-self.learning_rate * np.random.rand())\n\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            population = new_population\n            \n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if np.std(fitness) < 1e-3:\n                self.population_size = max(10, self.population_size - 3)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Refine convergence by introducing stochastic adaptive learning rate to enhance global exploration and diversity.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "942379f2-795a-4d2c-a9c9-ede1fe50a423", "metadata": {"aucs": [0.4316324779008963, 0.4316324779008963, 0.4316324779008963, 0.4398310658013598, 0.4398310658013598, 0.4398310658013598, 0.474673678009655, 0.474673678009655, 0.474673678009655, 0.04456333248430622, 0.04456333248430622, 0.04456333248430622, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11822986331965624, 0.11822986331965624, 0.11822986331965624, 0.09164497827853324, 0.09164497827853324, 0.09164497827853324, 0.0908636064158167, 0.0908636064158167, 0.0908636064158167, 0.056211033215752826, 0.056211033215752826, 0.056211033215752826, 0.06963770071126196, 0.06963770071126196, 0.06963770071126196, 0.06267493469288687, 0.06267493469288687, 0.06267493469288687, 0.7914905691714824, 0.7914905691714824, 0.7914905691714824, 0.4641310908934111, 0.4641310908934111, 0.4641310908934111, 0.12063358030336657, 0.12063358030336657, 0.12063358030336657, 0.275038132570418, 0.275038132570418, 0.275038132570418, 0.25800275984318044, 0.25800275984318044, 0.25800275984318044, 0.2828331037421219, 0.2828331037421219, 0.2828331037421219, 0.546148739517615, 0.546148739517615, 0.546148739517615, 0.49315404315195943, 0.49315404315195943, 0.49315404315195943, 0.12092865580081091, 0.12092865580081091, 0.12092865580081091, 0.15657466284802435, 0.15657466284802435, 0.15657466284802435, 0.1804585139809013, 0.1804585139809013, 0.1804585139809013, 0.14432521485423855, 0.14432521485423855, 0.14432521485423855, 0.16024207820954994, 0.16024207820954994, 0.16024207820954994, 0.15013688245464196, 0.15013688245464196, 0.15013688245464196, 0.19907065109987732, 0.19907065109987732, 0.19907065109987732, 0.031729437177347775, 0.031729437177347775, 0.031729437177347775, 0.028998388520592222, 0.028998388520592222, 0.028998388520592222, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08362624935201035, 0.08362624935201035, 0.08362624935201035, 0.026425201363172723, 0.026425201363172723, 0.026425201363172723, 0.06519401048334916, 0.06519401048334916, 0.06519401048334916, 0.01433911361584106, 0.01433911361584106, 0.01433911361584106, 0.00769537993512881, 0.00769537993512881, 0.00769537993512881, 0.010672672204237843, 0.010672672204237843, 0.010672672204237843, 0.059988656179477906, 0.059988656179477906, 0.059988656179477906, 0.0719538127449929, 0.0719538127449929, 0.0719538127449929, 0.12445086477063416, 0.12445086477063416, 0.12445086477063416, 0.4300796449516281, 0.4300796449516281, 0.4300796449516281, 0.41390419414102964, 0.41390419414102964, 0.41390419414102964, 0.4006953206652003, 0.4006953206652003, 0.4006953206652003, 0.08439171442247262, 0.08439171442247262, 0.08439171442247262, 0.10349533107671194, 0.10349533107671194, 0.10349533107671194, 0.0966051784144325, 0.0966051784144325, 0.0966051784144325, 0.1821114128508161, 0.1821114128508161, 0.1821114128508161, 0.13169165430578655, 0.13169165430578655, 0.13169165430578655, 0.12619252740933895, 0.12619252740933895, 0.12619252740933895, 0.1900519975436027, 0.1900519975436027, 0.1900519975436027, 0.2768870409019287, 0.2768870409019287, 0.2768870409019287, 0.2502306362202801, 0.2502306362202801, 0.2502306362202801, 0.1626236108685689, 0.1626236108685689, 0.1626236108685689, 0.19966827225050665, 0.19966827225050665, 0.19966827225050665, 0.1513681333485729, 0.1513681333485729, 0.1513681333485729, 0.19446153617568185, 0.19446153617568185, 0.19446153617568185, 0.21986928713464082, 0.21986928713464082, 0.21986928713464082, 0.18059021773131412, 0.18059021773131412, 0.18059021773131412, 0.1666662635160162, 0.1666662635160162, 0.1666662635160162, 0.1879675952038391, 0.1879675952038391, 0.1879675952038391, 0.16564311194612635, 0.16564311194612635, 0.16564311194612635, 0.5901935543397198, 0.5901935543397198, 0.5901935543397198, 0.15138270376521756, 0.15138270376521756, 0.15138270376521756, 0.47012941168044886, 0.47012941168044886, 0.47012941168044886, 0.279290080562398, 0.279290080562398, 0.279290080562398, 0.363666351089849, 0.363666351089849, 0.363666351089849, 0.14576118837238505, 0.14576118837238505, 0.14576118837238505, 0.19347004645180377, 0.19347004645180377, 0.19347004645180377, 0.18188146747909306, 0.18188146747909306, 0.18188146747909306, 0.18945171911003622, 0.18945171911003622, 0.18945171911003622, 0.06473514223413601, 0.06473514223413601, 0.06473514223413601, 0.0623151630178439, 0.0623151630178439, 0.0623151630178439, 0.06875705295777046, 0.06875705295777046, 0.06875705295777046]}, "mutation_prompt": null}
{"id": "8a6b4c06-9f48-41b8-b064-f3b9f9b8f871", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.alpha = 0.5\n        self.gamma = 1.0\n        self.success_history = []\n        self.learning_rate = 0.01\n\n    def __call__(self, func):\n        np.random.seed(42)\n        budget_used = 0\n\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(self.learning_rate * np.random.rand())\n                else:\n                    self.success_history.append(-self.learning_rate * np.random.rand())\n\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            population = new_population\n            \n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            # Randomized reinitialization mechanism\n            if np.std(fitness) < 1e-3 and np.random.rand() < 0.1:\n                reinit_indices = np.random.choice(self.population_size, size=2, replace=False)\n                for idx in reinit_indices:\n                    population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    fitness[idx] = func(population[idx])\n                    budget_used += 1\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Introduce a randomized reinitialization mechanism to escape local optima and improve convergence.", "configspace": "", "generation": 75, "fitness": 0.191988809132896, "feedback": "The algorithm HybridDEFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.16.", "error": "", "parent_id": "942379f2-795a-4d2c-a9c9-ede1fe50a423", "metadata": {"aucs": [0.4262845608942284, 0.4262845608942284, 0.4262845608942284, 0.42901820786702327, 0.42901820786702327, 0.42901820786702327, 0.47422923548169194, 0.47422923548169194, 0.47422923548169194, 0.04456333248430622, 0.04456333248430622, 0.04456333248430622, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11822986331965624, 0.11822986331965624, 0.11822986331965624, 0.09164497827853324, 0.09164497827853324, 0.09164497827853324, 0.0908636064158167, 0.0908636064158167, 0.0908636064158167, 0.056211033215752826, 0.056211033215752826, 0.056211033215752826, 0.06963770071126196, 0.06963770071126196, 0.06963770071126196, 0.06267493469288687, 0.06267493469288687, 0.06267493469288687, 0.7914905691714824, 0.7914905691714824, 0.7914905691714824, 0.4641310908934111, 0.4641310908934111, 0.4641310908934111, 0.12063358030336657, 0.12063358030336657, 0.12063358030336657, 0.27501504745512995, 0.27501504745512995, 0.27501504745512995, 0.25821246606711246, 0.25821246606711246, 0.25821246606711246, 0.2822878408704168, 0.2822878408704168, 0.2822878408704168, 0.546148739517615, 0.546148739517615, 0.546148739517615, 0.49315404315195943, 0.49315404315195943, 0.49315404315195943, 0.12848175805296236, 0.12848175805296236, 0.12848175805296236, 0.15657466284802435, 0.15657466284802435, 0.15657466284802435, 0.1804585139809013, 0.1804585139809013, 0.1804585139809013, 0.14432521485423855, 0.14432521485423855, 0.14432521485423855, 0.16024207820954994, 0.16024207820954994, 0.16024207820954994, 0.15013688245464196, 0.15013688245464196, 0.15013688245464196, 0.19907065109987732, 0.19907065109987732, 0.19907065109987732, 0.031729437177347775, 0.031729437177347775, 0.031729437177347775, 0.028998388520592222, 0.028998388520592222, 0.028998388520592222, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08362624935201035, 0.08362624935201035, 0.08362624935201035, 0.026425201363172723, 0.026425201363172723, 0.026425201363172723, 0.06519401048334916, 0.06519401048334916, 0.06519401048334916, 0.01433911361584106, 0.01433911361584106, 0.01433911361584106, 0.00769537993512881, 0.00769537993512881, 0.00769537993512881, 0.010672672204237843, 0.010672672204237843, 0.010672672204237843, 0.059988656179477906, 0.059988656179477906, 0.059988656179477906, 0.0719538127449929, 0.0719538127449929, 0.0719538127449929, 0.12445086477063416, 0.12445086477063416, 0.12445086477063416, 0.4316860976928657, 0.4316860976928657, 0.4316860976928657, 0.4160528634040497, 0.4160528634040497, 0.4160528634040497, 0.40135785522709444, 0.40135785522709444, 0.40135785522709444, 0.08439171442247262, 0.08439171442247262, 0.08439171442247262, 0.10349533107671194, 0.10349533107671194, 0.10349533107671194, 0.0966051784144325, 0.0966051784144325, 0.0966051784144325, 0.1821114128508161, 0.1821114128508161, 0.1821114128508161, 0.13169165430578655, 0.13169165430578655, 0.13169165430578655, 0.12619252740933895, 0.12619252740933895, 0.12619252740933895, 0.1900519975436027, 0.1900519975436027, 0.1900519975436027, 0.2768870409019287, 0.2768870409019287, 0.2768870409019287, 0.2502306362202801, 0.2502306362202801, 0.2502306362202801, 0.1626236108685689, 0.1626236108685689, 0.1626236108685689, 0.19966827225050665, 0.19966827225050665, 0.19966827225050665, 0.1513681333485729, 0.1513681333485729, 0.1513681333485729, 0.19446153617568185, 0.19446153617568185, 0.19446153617568185, 0.21986928713464082, 0.21986928713464082, 0.21986928713464082, 0.18059021773131412, 0.18059021773131412, 0.18059021773131412, 0.166666261755258, 0.166666261755258, 0.166666261755258, 0.18796758633542332, 0.18796758633542332, 0.18796758633542332, 0.1656431034261937, 0.1656431034261937, 0.1656431034261937, 0.5913535324155734, 0.5913535324155734, 0.5913535324155734, 0.15138229846304763, 0.15138229846304763, 0.15138229846304763, 0.46011805334237343, 0.46011805334237343, 0.46011805334237343, 0.279290080562398, 0.279290080562398, 0.279290080562398, 0.3759715933566071, 0.3759715933566071, 0.3759715933566071, 0.14576141104365814, 0.14576141104365814, 0.14576141104365814, 0.19347004645180377, 0.19347004645180377, 0.19347004645180377, 0.18188146747909306, 0.18188146747909306, 0.18188146747909306, 0.18945171911003622, 0.18945171911003622, 0.18945171911003622, 0.06473514223413601, 0.06473514223413601, 0.06473514223413601, 0.0623151630178439, 0.0623151630178439, 0.0623151630178439, 0.06875705295777046, 0.06875705295777046, 0.06875705295777046]}, "mutation_prompt": null}
{"id": "92f0820b-72ed-42bc-9986-128a80ba7eef", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.alpha = 0.5\n        self.gamma = 1.0\n        self.success_history = []\n        self.learning_rate = 0.01\n\n    def __call__(self, func):\n        np.random.seed(42)\n        budget_used = 0\n\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(self.learning_rate * np.random.rand())\n                else:\n                    self.success_history.append(-self.learning_rate * np.random.rand())\n\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n                            population[i] = new_population[i]  # Incorporate local elitism\n\n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if np.std(fitness) < 1e-3:\n                self.population_size = max(10, self.population_size - 3)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Incorporate local elitism and adaptive mutation scaling to enhance exploitation while maintaining exploration.", "configspace": "", "generation": 76, "fitness": 0.19086997290197194, "feedback": "The algorithm HybridDEFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.15.", "error": "", "parent_id": "942379f2-795a-4d2c-a9c9-ede1fe50a423", "metadata": {"aucs": [0.46379761365021754, 0.46379761365021754, 0.46379761365021754, 0.45298922815319886, 0.45298922815319886, 0.45298922815319886, 0.4310901560835557, 0.4310901560835557, 0.4310901560835557, 0.026963549162930533, 0.026963549162930533, 0.026963549162930533, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020985854678799987, 0.020985854678799987, 0.020985854678799987, 0.09391822829757823, 0.09391822829757823, 0.09391822829757823, 0.068038043850983, 0.068038043850983, 0.068038043850983, 0.0819404740543408, 0.0819404740543408, 0.0819404740543408, 0.056357929850401334, 0.056357929850401334, 0.056357929850401334, 0.05170478124060551, 0.05170478124060551, 0.05170478124060551, 0.04789367765696084, 0.04789367765696084, 0.04789367765696084, 0.4126139318742478, 0.4126139318742478, 0.4126139318742478, 0.4058066902264127, 0.4058066902264127, 0.4058066902264127, 0.5826580699958571, 0.5826580699958571, 0.5826580699958571, 0.28801155812403223, 0.28801155812403223, 0.28801155812403223, 0.2624732606564557, 0.2624732606564557, 0.2624732606564557, 0.28065061414219916, 0.28065061414219916, 0.28065061414219916, 0.3918924778292697, 0.3918924778292697, 0.3918924778292697, 0.5949452727842988, 0.5949452727842988, 0.5949452727842988, 0.15865592006371465, 0.15865592006371465, 0.15865592006371465, 0.1503307593514117, 0.1503307593514117, 0.1503307593514117, 0.16639958171047387, 0.16639958171047387, 0.16639958171047387, 0.15621710382600462, 0.15621710382600462, 0.15621710382600462, 0.19260187323241795, 0.19260187323241795, 0.19260187323241795, 0.1363294241620604, 0.1363294241620604, 0.1363294241620604, 0.1450378734310951, 0.1450378734310951, 0.1450378734310951, 0.04274085050157739, 0.04274085050157739, 0.04274085050157739, 0.00013751811475326559, 0.00013751811475326559, 0.00013751811475326559, 0.01391146802910348, 0.01391146802910348, 0.01391146802910348, 0.12302562570739506, 0.12302562570739506, 0.12302562570739506, 0.14717933044162468, 0.14717933044162468, 0.14717933044162468, 0.12290934246170215, 0.12290934246170215, 0.12290934246170215, 0.02732195913273716, 0.02732195913273716, 0.02732195913273716, 0.019331170429477074, 0.019331170429477074, 0.019331170429477074, 0.007479921713873461, 0.007479921713873461, 0.007479921713873461, 0.05322235930823371, 0.05322235930823371, 0.05322235930823371, 0.0664450756620536, 0.0664450756620536, 0.0664450756620536, 0.09457675942473653, 0.09457675942473653, 0.09457675942473653, 0.41367517651247565, 0.41367517651247565, 0.41367517651247565, 0.40139564277790074, 0.40139564277790074, 0.40139564277790074, 0.3965061613436406, 0.3965061613436406, 0.3965061613436406, 0.07224771943122033, 0.07224771943122033, 0.07224771943122033, 0.11854433715094714, 0.11854433715094714, 0.11854433715094714, 0.07233423125792282, 0.07233423125792282, 0.07233423125792282, 0.19758908583619927, 0.19758908583619927, 0.19758908583619927, 0.18034423115481857, 0.18034423115481857, 0.18034423115481857, 0.1784318921760849, 0.1784318921760849, 0.1784318921760849, 0.23750587109767463, 0.23750587109767463, 0.23750587109767463, 0.1778372161381312, 0.1778372161381312, 0.1778372161381312, 0.245451481764408, 0.245451481764408, 0.245451481764408, 0.09585863421442742, 0.09585863421442742, 0.09585863421442742, 0.12357082426970578, 0.12357082426970578, 0.12357082426970578, 0.1348488141948364, 0.1348488141948364, 0.1348488141948364, 0.17200602542661292, 0.17200602542661292, 0.17200602542661292, 0.16777044650588557, 0.16777044650588557, 0.16777044650588557, 0.15674773301369938, 0.15674773301369938, 0.15674773301369938, 0.17490318769782276, 0.17490318769782276, 0.17490318769782276, 0.1548985888354637, 0.1548985888354637, 0.1548985888354637, 0.17717282991043337, 0.17717282991043337, 0.17717282991043337, 0.621948048616725, 0.621948048616725, 0.621948048616725, 0.47670487416669827, 0.47670487416669827, 0.47670487416669827, 0.30890463202981977, 0.30890463202981977, 0.30890463202981977, 0.38855399699977244, 0.38855399699977244, 0.38855399699977244, 0.1740894560512104, 0.1740894560512104, 0.1740894560512104, 0.14888233017877028, 0.14888233017877028, 0.14888233017877028, 0.19012104717329292, 0.19012104717329292, 0.19012104717329292, 0.18364221398661162, 0.18364221398661162, 0.18364221398661162, 0.1867842420939715, 0.1867842420939715, 0.1867842420939715, 0.0637200930266314, 0.0637200930266314, 0.0637200930266314, 0.053135365193110906, 0.053135365193110906, 0.053135365193110906, 0.05782628969826187, 0.05782628969826187, 0.05782628969826187]}, "mutation_prompt": null}
{"id": "d7f7bc15-a87a-495b-8959-5ff45b34b220", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.alpha = 0.5\n        self.gamma = 1.0\n        self.success_history = []\n        self.learning_rate = 0.01\n\n    def __call__(self, func):\n        np.random.seed(42)\n        budget_used = 0\n\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(self.learning_rate * np.random.rand())\n                else:\n                    self.success_history.append(-self.learning_rate * np.random.rand())\n\n            pop_diversity = np.mean(np.std(new_population, axis=0))\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget)) * pop_diversity\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            population = new_population\n            \n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if np.std(fitness) < 1e-3:\n                self.population_size = max(10, self.population_size - 3)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Enhance convergence by incorporating adaptive scaling of firefly influence based on population diversity.", "configspace": "", "generation": 77, "fitness": 0.18342104869915665, "feedback": "The algorithm HybridDEFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": "942379f2-795a-4d2c-a9c9-ede1fe50a423", "metadata": {"aucs": [0.7874388826658315, 0.7874388826658315, 0.7874388826658315, 0.5043282810108071, 0.5043282810108071, 0.5043282810108071, 0.3326807343568703, 0.3326807343568703, 0.3326807343568703, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006470941700027266, 0.006470941700027266, 0.006470941700027266, 0.07285315818077653, 0.07285315818077653, 0.07285315818077653, 0.06800361644835051, 0.06800361644835051, 0.06800361644835051, 0.08024961870745917, 0.08024961870745917, 0.08024961870745917, 0.059947790725538685, 0.059947790725538685, 0.059947790725538685, 0.0780256645608226, 0.0780256645608226, 0.0780256645608226, 0.07673373109312576, 0.07673373109312576, 0.07673373109312576, 0.7792960069199371, 0.7792960069199371, 0.7792960069199371, 0.7526857020788447, 0.7526857020788447, 0.7526857020788447, 0.7348398488923958, 0.7348398488923958, 0.7348398488923958, 0.12313794405598177, 0.12313794405598177, 0.12313794405598177, 0.05423374228830957, 0.05423374228830957, 0.05423374228830957, 0.0804729197687577, 0.0804729197687577, 0.0804729197687577, 0.14686413894132633, 0.14686413894132633, 0.14686413894132633, 0.22283768458946784, 0.22283768458946784, 0.22283768458946784, 0.1326052010175185, 0.1326052010175185, 0.1326052010175185, 0.19453918433307382, 0.19453918433307382, 0.19453918433307382, 0.08061500910582675, 0.08061500910582675, 0.08061500910582675, 0.11604800811648297, 0.11604800811648297, 0.11604800811648297, 0.1035788202084974, 0.1035788202084974, 0.1035788202084974, 0.09211016727813803, 0.09211016727813803, 0.09211016727813803, 0.11750901166376293, 0.11750901166376293, 0.11750901166376293, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0028168479847489047, 0.0028168479847489047, 0.0028168479847489047, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0438672994211583, 0.0438672994211583, 0.0438672994211583, 0.05655402458546488, 0.05655402458546488, 0.05655402458546488, 0.04940767061651363, 0.04940767061651363, 0.04940767061651363, 0.020651841083348832, 0.020651841083348832, 0.020651841083348832, 0.0771786019147932, 0.0771786019147932, 0.0771786019147932, 0.12239131729210984, 0.12239131729210984, 0.12239131729210984, 0.017720584913250792, 0.017720584913250792, 0.017720584913250792, 0.08920646509931007, 0.08920646509931007, 0.08920646509931007, 0.26166154794601637, 0.26166154794601637, 0.26166154794601637, 0.45037203530433434, 0.45037203530433434, 0.45037203530433434, 0.502922178410157, 0.502922178410157, 0.502922178410157, 0.43387920028439275, 0.43387920028439275, 0.43387920028439275, 0.07943716560017511, 0.07943716560017511, 0.07943716560017511, 0.08229045923514189, 0.08229045923514189, 0.08229045923514189, 0.06942530199859553, 0.06942530199859553, 0.06942530199859553, 0.13374098462201234, 0.13374098462201234, 0.13374098462201234, 0.1640898339021445, 0.1640898339021445, 0.1640898339021445, 0.12591043238151867, 0.12591043238151867, 0.12591043238151867, 0.233356658536222, 0.233356658536222, 0.233356658536222, 0.2774749853593983, 0.2774749853593983, 0.2774749853593983, 0.19866462485864422, 0.19866462485864422, 0.19866462485864422, 0.1798317088099597, 0.1798317088099597, 0.1798317088099597, 0.1347045573648742, 0.1347045573648742, 0.1347045573648742, 0.24760536384321197, 0.24760536384321197, 0.24760536384321197, 0.1693606774526797, 0.1693606774526797, 0.1693606774526797, 0.1716428429610587, 0.1716428429610587, 0.1716428429610587, 0.18533553673028302, 0.18533553673028302, 0.18533553673028302, 0.16554767973000417, 0.16554767973000417, 0.16554767973000417, 0.17740630019503056, 0.17740630019503056, 0.17740630019503056, 0.1836332542281789, 0.1836332542281789, 0.1836332542281789, 0.16235761211573585, 0.16235761211573585, 0.16235761211573585, 0.2935109141281872, 0.2935109141281872, 0.2935109141281872, 0.5291822125230912, 0.5291822125230912, 0.5291822125230912, 0.2360150509795631, 0.2360150509795631, 0.2360150509795631, 0.17262021378132253, 0.17262021378132253, 0.17262021378132253, 0.1820928352111899, 0.1820928352111899, 0.1820928352111899, 0.18099411540438992, 0.18099411540438992, 0.18099411540438992, 0.19286408429205726, 0.19286408429205726, 0.19286408429205726, 0.1801435746207879, 0.1801435746207879, 0.1801435746207879, 0.05818640295664934, 0.05818640295664934, 0.05818640295664934, 0.05778444529642457, 0.05778444529642457, 0.05778444529642457, 0.05397025365721786, 0.05397025365721786, 0.05397025365721786]}, "mutation_prompt": null}
{"id": "fcdbaff1-a823-4ea0-b95a-7ce991ab1d9f", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.alpha = 0.5\n        self.gamma = 1.0\n        self.success_history = []\n        self.learning_rate = 0.01\n\n    def __call__(self, func):\n        np.random.seed(42)\n        budget_used = 0\n\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(self.learning_rate * np.random.rand())\n                else:\n                    self.success_history.append(-self.learning_rate * np.random.rand())\n\n            diversity = np.std(new_population, axis=0)\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        perturbation = adaptive_alpha * diversity * (np.random.rand(self.dim) - 0.5)\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + perturbation\n\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            population = new_population\n            \n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if np.std(fitness) < 1e-3:\n                self.population_size = max(10, self.population_size - 3)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Improve local search by introducing adaptive perturbation based on population diversity to enhance convergence.", "configspace": "", "generation": 78, "fitness": 0.14728837222311497, "feedback": "The algorithm HybridDEFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.10.", "error": "", "parent_id": "942379f2-795a-4d2c-a9c9-ede1fe50a423", "metadata": {"aucs": [0.4175695140018598, 0.4175695140018598, 0.4175695140018598, 0.21868765100001997, 0.21868765100001997, 0.21868765100001997, 0.3029008315206526, 0.3029008315206526, 0.3029008315206526, 0.15618970407403754, 0.15618970407403754, 0.15618970407403754, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11633617975818855, 0.11633617975818855, 0.11633617975818855, 0.09122066541897422, 0.09122066541897422, 0.09122066541897422, 0.09285832696014318, 0.09285832696014318, 0.09285832696014318, 0.05308986432660645, 0.05308986432660645, 0.05308986432660645, 0.05066632415200689, 0.05066632415200689, 0.05066632415200689, 0.0747764504323315, 0.0747764504323315, 0.0747764504323315, 0.05544655687609923, 0.05544655687609923, 0.05544655687609923, 0.1906174583203396, 0.1906174583203396, 0.1906174583203396, 0.13325140885753695, 0.13325140885753695, 0.13325140885753695, 0.1328001994724849, 0.1328001994724849, 0.1328001994724849, 0.11573921696703271, 0.11573921696703271, 0.11573921696703271, 0.1332763763955216, 0.1332763763955216, 0.1332763763955216, 0.13124127498837246, 0.13124127498837246, 0.13124127498837246, 0.20213880263015194, 0.20213880263015194, 0.20213880263015194, 0.18932995802201136, 0.18932995802201136, 0.18932995802201136, 0.17114528676806917, 0.17114528676806917, 0.17114528676806917, 0.10860450554689394, 0.10860450554689394, 0.10860450554689394, 0.15845173601128082, 0.15845173601128082, 0.15845173601128082, 0.09380379910639636, 0.09380379910639636, 0.09380379910639636, 0.10856696567085566, 0.10856696567085566, 0.10856696567085566, 0.07775617101835197, 0.07775617101835197, 0.07775617101835197, 0.09077102474738408, 0.09077102474738408, 0.09077102474738408, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.002490360113394985, 0.002490360113394985, 0.002490360113394985, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07865550923586562, 0.07865550923586562, 0.07865550923586562, 0.04990066074647859, 0.04990066074647859, 0.04990066074647859, 0.09809571798916639, 0.09809571798916639, 0.09809571798916639, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08455126975243732, 0.08455126975243732, 0.08455126975243732, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07221187081241842, 0.07221187081241842, 0.07221187081241842, 0.10772386214370167, 0.10772386214370167, 0.10772386214370167, 0.05923218085142978, 0.05923218085142978, 0.05923218085142978, 0.42426521441469944, 0.42426521441469944, 0.42426521441469944, 0.3043163691677775, 0.3043163691677775, 0.3043163691677775, 0.3970468636827782, 0.3970468636827782, 0.3970468636827782, 0.08448141483879468, 0.08448141483879468, 0.08448141483879468, 0.09864336326787104, 0.09864336326787104, 0.09864336326787104, 0.09974225835301387, 0.09974225835301387, 0.09974225835301387, 0.13040446665750127, 0.13040446665750127, 0.13040446665750127, 0.15413964393491808, 0.15413964393491808, 0.15413964393491808, 0.16555977744505912, 0.16555977744505912, 0.16555977744505912, 0.22081517604656198, 0.22081517604656198, 0.22081517604656198, 0.22517552861840018, 0.22517552861840018, 0.22517552861840018, 0.23525774170161973, 0.23525774170161973, 0.23525774170161973, 0.15128716303839684, 0.15128716303839684, 0.15128716303839684, 0.14318735362269197, 0.14318735362269197, 0.14318735362269197, 0.1398747937331427, 0.1398747937331427, 0.1398747937331427, 0.18476189089791428, 0.18476189089791428, 0.18476189089791428, 0.16848240389546754, 0.16848240389546754, 0.16848240389546754, 0.1759659954300834, 0.1759659954300834, 0.1759659954300834, 0.18471846667701997, 0.18471846667701997, 0.18471846667701997, 0.16328508824160437, 0.16328508824160437, 0.16328508824160437, 0.17936582305030824, 0.17936582305030824, 0.17936582305030824, 0.375319054256369, 0.375319054256369, 0.375319054256369, 0.4639254557946042, 0.4639254557946042, 0.4639254557946042, 0.14155800903594806, 0.14155800903594806, 0.14155800903594806, 0.24853709471998553, 0.24853709471998553, 0.24853709471998553, 0.16287897669585583, 0.16287897669585583, 0.16287897669585583, 0.21359073233131298, 0.21359073233131298, 0.21359073233131298, 0.17595895660630545, 0.17595895660630545, 0.17595895660630545, 0.18284063677074103, 0.18284063677074103, 0.18284063677074103, 0.18576923847235094, 0.18576923847235094, 0.18576923847235094, 0.07913321424264086, 0.07913321424264086, 0.07913321424264086, 0.05965714921001197, 0.05965714921001197, 0.05965714921001197, 0.0642198005240312, 0.0642198005240312, 0.0642198005240312]}, "mutation_prompt": null}
{"id": "a88db0d6-35a3-4efd-9f0d-1cb3b66709d2", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.alpha = 0.5\n        self.gamma = 1.0\n        self.success_history = []\n        self.learning_rate = 0.01\n\n    def __call__(self, func):\n        np.random.seed(42)\n        budget_used = 0\n\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            # Calculate trend-based adjustment factor\n            success_trend_factor = 1 + np.tanh(np.mean(self.success_history[-10:]) if self.success_history else 0)\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:\n                    dynamic_mutation_factor *= success_trend_factor\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(self.learning_rate * np.random.rand())\n                else:\n                    self.success_history.append(-self.learning_rate * np.random.rand())\n\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            population = new_population\n            \n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if np.std(fitness) < 1e-3:\n                self.population_size = max(10, self.population_size - 3)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Introduce an adaptive mutation step size based on the success history trend to enhance convergence efficiency.", "configspace": "", "generation": 79, "fitness": 0.1792669293305526, "feedback": "The algorithm HybridDEFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.15.", "error": "", "parent_id": "942379f2-795a-4d2c-a9c9-ede1fe50a423", "metadata": {"aucs": [0.4188888023963223, 0.4188888023963223, 0.4188888023963223, 0.41889534147222807, 0.41889534147222807, 0.41889534147222807, 0.4445135018087999, 0.4445135018087999, 0.4445135018087999, 0.05779377192745905, 0.05779377192745905, 0.05779377192745905, 0.0011435104341338542, 0.0011435104341338542, 0.0011435104341338542, 0.04013288706577767, 0.04013288706577767, 0.04013288706577767, 0.10592563697170099, 0.10592563697170099, 0.10592563697170099, 0.09304085961699315, 0.09304085961699315, 0.09304085961699315, 0.07568573174678206, 0.07568573174678206, 0.07568573174678206, 0.07104017507272053, 0.07104017507272053, 0.07104017507272053, 0.06213989628143246, 0.06213989628143246, 0.06213989628143246, 0.033664397372923816, 0.033664397372923816, 0.033664397372923816, 0.754112587437744, 0.754112587437744, 0.754112587437744, 0.5243867515971641, 0.5243867515971641, 0.5243867515971641, 0.1436694810607172, 0.1436694810607172, 0.1436694810607172, 0.2908028591737948, 0.2908028591737948, 0.2908028591737948, 0.2618684046212536, 0.2618684046212536, 0.2618684046212536, 0.27753532787627133, 0.27753532787627133, 0.27753532787627133, 0.18578259685599663, 0.18578259685599663, 0.18578259685599663, 0.23905337630074863, 0.23905337630074863, 0.23905337630074863, 0.1259744501915948, 0.1259744501915948, 0.1259744501915948, 0.16871018697974882, 0.16871018697974882, 0.16871018697974882, 0.2177968147989493, 0.2177968147989493, 0.2177968147989493, 0.10136626772949853, 0.10136626772949853, 0.10136626772949853, 0.16270416508720753, 0.16270416508720753, 0.16270416508720753, 0.1687791932213648, 0.1687791932213648, 0.1687791932213648, 0.23580605371761487, 0.23580605371761487, 0.23580605371761487, 0.00013431309621703136, 0.00013431309621703136, 0.00013431309621703136, 0.004514962508013198, 0.004514962508013198, 0.004514962508013198, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0836985105497664, 0.0836985105497664, 0.0836985105497664, 0.031817500307638746, 0.031817500307638746, 0.031817500307638746, 0.1026213590583187, 0.1026213590583187, 0.1026213590583187, 0.035109313918944784, 0.035109313918944784, 0.035109313918944784, 0.007157043624707926, 0.007157043624707926, 0.007157043624707926, 0.0051282519216742095, 0.0051282519216742095, 0.0051282519216742095, 0.10650289264290658, 0.10650289264290658, 0.10650289264290658, 0.0816740881102187, 0.0816740881102187, 0.0816740881102187, 0.11536662283946575, 0.11536662283946575, 0.11536662283946575, 0.4270655907678531, 0.4270655907678531, 0.4270655907678531, 0.41042176023609056, 0.41042176023609056, 0.41042176023609056, 0.3954942715395984, 0.3954942715395984, 0.3954942715395984, 0.12681002166264044, 0.12681002166264044, 0.12681002166264044, 0.08626499457603187, 0.08626499457603187, 0.08626499457603187, 0.10098348409329061, 0.10098348409329061, 0.10098348409329061, 0.1458914274385963, 0.1458914274385963, 0.1458914274385963, 0.1406280011520099, 0.1406280011520099, 0.1406280011520099, 0.13209825485736382, 0.13209825485736382, 0.13209825485736382, 0.19322983442094033, 0.19322983442094033, 0.19322983442094033, 0.20096821810765308, 0.20096821810765308, 0.20096821810765308, 0.2835857091577938, 0.2835857091577938, 0.2835857091577938, 0.1490231124467566, 0.1490231124467566, 0.1490231124467566, 0.12899939696892437, 0.12899939696892437, 0.12899939696892437, 0.14046486138561998, 0.14046486138561998, 0.14046486138561998, 0.17620885950471943, 0.17620885950471943, 0.17620885950471943, 0.19468910632048486, 0.19468910632048486, 0.19468910632048486, 0.1909991763315505, 0.1909991763315505, 0.1909991763315505, 0.1705501189010853, 0.1705501189010853, 0.1705501189010853, 0.17508609114137308, 0.17508609114137308, 0.17508609114137308, 0.17327499144873182, 0.17327499144873182, 0.17327499144873182, 0.6136053892676832, 0.6136053892676832, 0.6136053892676832, 0.14311863338326836, 0.14311863338326836, 0.14311863338326836, 0.52190428690794, 0.52190428690794, 0.52190428690794, 0.16593749105797373, 0.16593749105797373, 0.16593749105797373, 0.15413342048624212, 0.15413342048624212, 0.15413342048624212, 0.14707688000497587, 0.14707688000497587, 0.14707688000497587, 0.17762516226355363, 0.17762516226355363, 0.17762516226355363, 0.18394015645976314, 0.18394015645976314, 0.18394015645976314, 0.17471764277575108, 0.17471764277575108, 0.17471764277575108, 0.06991617653748472, 0.06991617653748472, 0.06991617653748472, 0.08815572642904479, 0.08815572642904479, 0.08815572642904479, 0.0693127763721848, 0.0693127763721848, 0.0693127763721848]}, "mutation_prompt": null}
{"id": "1ad87db1-b3fa-4392-9fa5-d5dcbf41f2df", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.alpha = 0.5\n        self.gamma = 1.0\n        self.success_history = []\n        self.learning_rate = 0.01\n\n    def __call__(self, func):\n        np.random.seed(42)\n        budget_used = 0\n\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(self.learning_rate * np.random.rand())\n                else:\n                    self.success_history.append(-self.learning_rate * np.random.rand())\n\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n                        \n                        # Adding adaptive random walks\n                        if np.random.rand() < 0.1 * np.abs(np.mean(self.success_history)):\n                            new_population[i] += np.random.normal(0, 0.1, self.dim)\n\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            population = new_population\n            \n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if np.std(fitness) < 1e-3:\n                self.population_size = max(10, self.population_size - 3)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Enhance diversity control by incorporating adaptive random walks based on success history to further improve exploration.", "configspace": "", "generation": 80, "fitness": 0.18925935064398663, "feedback": "The algorithm HybridDEFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.16.", "error": "", "parent_id": "942379f2-795a-4d2c-a9c9-ede1fe50a423", "metadata": {"aucs": [0.435927320396549, 0.435927320396549, 0.435927320396549, 0.4008111282834511, 0.4008111282834511, 0.4008111282834511, 0.42198986118377857, 0.42198986118377857, 0.42198986118377857, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0738007884174996, 0.0738007884174996, 0.0738007884174996, 0.12173776761566346, 0.12173776761566346, 0.12173776761566346, 0.12192739174164668, 0.12192739174164668, 0.12192739174164668, 0.07152196892914275, 0.07152196892914275, 0.07152196892914275, 0.07378038166366518, 0.07378038166366518, 0.07378038166366518, 0.05541709321251764, 0.05541709321251764, 0.05541709321251764, 0.05536193120739119, 0.05536193120739119, 0.05536193120739119, 0.143893666869379, 0.143893666869379, 0.143893666869379, 0.8118709906062196, 0.8118709906062196, 0.8118709906062196, 0.6184263898331372, 0.6184263898331372, 0.6184263898331372, 0.2809922001453571, 0.2809922001453571, 0.2809922001453571, 0.26889197037470025, 0.26889197037470025, 0.26889197037470025, 0.32276966924046757, 0.32276966924046757, 0.32276966924046757, 0.20912266751092623, 0.20912266751092623, 0.20912266751092623, 0.266480138483848, 0.266480138483848, 0.266480138483848, 0.5748986949330113, 0.5748986949330113, 0.5748986949330113, 0.1416886856176265, 0.1416886856176265, 0.1416886856176265, 0.11028931110207318, 0.11028931110207318, 0.11028931110207318, 0.12610619916242738, 0.12610619916242738, 0.12610619916242738, 0.14010153082088272, 0.14010153082088272, 0.14010153082088272, 0.09652847826555877, 0.09652847826555877, 0.09652847826555877, 0.16872694026604274, 0.16872694026604274, 0.16872694026604274, 0.004514703881466464, 0.004514703881466464, 0.004514703881466464, 0.018732205015091652, 0.018732205015091652, 0.018732205015091652, 0.02865714211100512, 0.02865714211100512, 0.02865714211100512, 0.09251248098189735, 0.09251248098189735, 0.09251248098189735, 0.0584241595760302, 0.0584241595760302, 0.0584241595760302, 0.07808020237928925, 0.07808020237928925, 0.07808020237928925, 0.006590004023647844, 0.006590004023647844, 0.006590004023647844, 0.009856777417137308, 0.009856777417137308, 0.009856777417137308, 0.007200040181718603, 0.007200040181718603, 0.007200040181718603, 0.05512811520545058, 0.05512811520545058, 0.05512811520545058, 0.10809370746806157, 0.10809370746806157, 0.10809370746806157, 0.08500678218188984, 0.08500678218188984, 0.08500678218188984, 0.39820416704000305, 0.39820416704000305, 0.39820416704000305, 0.3792359258412794, 0.3792359258412794, 0.3792359258412794, 0.4157277638411856, 0.4157277638411856, 0.4157277638411856, 0.12271027891390496, 0.12271027891390496, 0.12271027891390496, 0.058418932599120454, 0.058418932599120454, 0.058418932599120454, 0.07663202166305527, 0.07663202166305527, 0.07663202166305527, 0.1382513521743549, 0.1382513521743549, 0.1382513521743549, 0.16454395158476431, 0.16454395158476431, 0.16454395158476431, 0.127991895741275, 0.127991895741275, 0.127991895741275, 0.1485647266203448, 0.1485647266203448, 0.1485647266203448, 0.2757294101683273, 0.2757294101683273, 0.2757294101683273, 0.2052289493174213, 0.2052289493174213, 0.2052289493174213, 0.1829545378573474, 0.1829545378573474, 0.1829545378573474, 0.12359263585334646, 0.12359263585334646, 0.12359263585334646, 0.18978588122086326, 0.18978588122086326, 0.18978588122086326, 0.16904863729930442, 0.16904863729930442, 0.16904863729930442, 0.1796955923590351, 0.1796955923590351, 0.1796955923590351, 0.18503691862622884, 0.18503691862622884, 0.18503691862622884, 0.17886134463826653, 0.17886134463826653, 0.17886134463826653, 0.1726640460973795, 0.1726640460973795, 0.1726640460973795, 0.2041592334767156, 0.2041592334767156, 0.2041592334767156, 0.5816896459552283, 0.5816896459552283, 0.5816896459552283, 0.48111665976751317, 0.48111665976751317, 0.48111665976751317, 0.14526803770088537, 0.14526803770088537, 0.14526803770088537, 0.2246106404139021, 0.2246106404139021, 0.2246106404139021, 0.18215985991864436, 0.18215985991864436, 0.18215985991864436, 0.5062991451352061, 0.5062991451352061, 0.5062991451352061, 0.17839302113243571, 0.17839302113243571, 0.17839302113243571, 0.17561903234254916, 0.17561903234254916, 0.17561903234254916, 0.18837724042480408, 0.18837724042480408, 0.18837724042480408, 0.06439908798046179, 0.06439908798046179, 0.06439908798046179, 0.058733691244547526, 0.058733691244547526, 0.058733691244547526, 0.0769094951116891, 0.0769094951116891, 0.0769094951116891]}, "mutation_prompt": null}
{"id": "d971cc4b-d3ab-41c2-b6ce-3c1341de728d", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.alpha = 0.5\n        self.gamma = 1.0\n        self.success_history = []\n        self.learning_rate = 0.01\n\n    def logistic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def __call__(self, func):\n        np.random.seed(42)\n        budget_used = 0\n\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        chaotic_factor = 0.3  # Initial value for chaotic sequence\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(self.learning_rate * np.random.rand())\n                else:\n                    self.success_history.append(-self.learning_rate * np.random.rand())\n\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            chaotic_factor = self.logistic_map(chaotic_factor)\n            self.crossover_rate = 0.6 + 0.4 * chaotic_factor\n\n            population = new_population\n            \n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if np.std(fitness) < 1e-3:\n                self.population_size = max(10, self.population_size - 3)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Enhance exploration by introducing chaotic maps in parameter tuning to maintain diversity and convergence speed.", "configspace": "", "generation": 81, "fitness": 0.18833504344582716, "feedback": "The algorithm HybridDEFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.16.", "error": "", "parent_id": "942379f2-795a-4d2c-a9c9-ede1fe50a423", "metadata": {"aucs": [0.4161467425674328, 0.4161467425674328, 0.4161467425674328, 0.43870990030619317, 0.43870990030619317, 0.43870990030619317, 0.4326202522599101, 0.4326202522599101, 0.4326202522599101, 0.04456318820041705, 0.04456318820041705, 0.04456318820041705, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11791519990900778, 0.11791519990900778, 0.11791519990900778, 0.0916563835217763, 0.0916563835217763, 0.0916563835217763, 0.09098008932524748, 0.09098008932524748, 0.09098008932524748, 0.056232462158113394, 0.056232462158113394, 0.056232462158113394, 0.0696465684703822, 0.0696465684703822, 0.0696465684703822, 0.06268592421441699, 0.06268592421441699, 0.06268592421441699, 0.7914905691714824, 0.7914905691714824, 0.7914905691714824, 0.5800394078394604, 0.5800394078394604, 0.5800394078394604, 0.11530721962947521, 0.11530721962947521, 0.11530721962947521, 0.2768471398418979, 0.2768471398418979, 0.2768471398418979, 0.25949512315756096, 0.25949512315756096, 0.25949512315756096, 0.28127875925441426, 0.28127875925441426, 0.28127875925441426, 0.19431982516763346, 0.19431982516763346, 0.19431982516763346, 0.5005365347308144, 0.5005365347308144, 0.5005365347308144, 0.12092993080553738, 0.12092993080553738, 0.12092993080553738, 0.15417734193130195, 0.15417734193130195, 0.15417734193130195, 0.1808140020819916, 0.1808140020819916, 0.1808140020819916, 0.14261921904987107, 0.14261921904987107, 0.14261921904987107, 0.16428428382725901, 0.16428428382725901, 0.16428428382725901, 0.15867550284254484, 0.15867550284254484, 0.15867550284254484, 0.1966080343505534, 0.1966080343505534, 0.1966080343505534, 0.03173214480072495, 0.03173214480072495, 0.03173214480072495, 0.0289963065976383, 0.0289963065976383, 0.0289963065976383, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08362624935201035, 0.08362624935201035, 0.08362624935201035, 0.026425201363172723, 0.026425201363172723, 0.026425201363172723, 0.06519401048334916, 0.06519401048334916, 0.06519401048334916, 0.01433911361584106, 0.01433911361584106, 0.01433911361584106, 0.00769537993512881, 0.00769537993512881, 0.00769537993512881, 0.010672672204237843, 0.010672672204237843, 0.010672672204237843, 0.05998933771917614, 0.05998933771917614, 0.05998933771917614, 0.07192818429814529, 0.07192818429814529, 0.07192818429814529, 0.12445086475634526, 0.12445086475634526, 0.12445086475634526, 0.4190994404253563, 0.4190994404253563, 0.4190994404253563, 0.45006480232560653, 0.45006480232560653, 0.45006480232560653, 0.37821938284050416, 0.37821938284050416, 0.37821938284050416, 0.08434284214595245, 0.08434284214595245, 0.08434284214595245, 0.10349337537917114, 0.10349337537917114, 0.10349337537917114, 0.09651380153318001, 0.09651380153318001, 0.09651380153318001, 0.18217561500065915, 0.18217561500065915, 0.18217561500065915, 0.13166188325550587, 0.13166188325550587, 0.13166188325550587, 0.12619252740933895, 0.12619252740933895, 0.12619252740933895, 0.1884783138598366, 0.1884783138598366, 0.1884783138598366, 0.23814557273128356, 0.23814557273128356, 0.23814557273128356, 0.25335515314859747, 0.25335515314859747, 0.25335515314859747, 0.16183877397175006, 0.16183877397175006, 0.16183877397175006, 0.20160766506573413, 0.20160766506573413, 0.20160766506573413, 0.14996905581249242, 0.14996905581249242, 0.14996905581249242, 0.19446153617568185, 0.19446153617568185, 0.19446153617568185, 0.21986928713464082, 0.21986928713464082, 0.21986928713464082, 0.18059021773131412, 0.18059021773131412, 0.18059021773131412, 0.1672400013756291, 0.1672400013756291, 0.1672400013756291, 0.1886720024943498, 0.1886720024943498, 0.1886720024943498, 0.16518342776807682, 0.16518342776807682, 0.16518342776807682, 0.6078882062762836, 0.6078882062762836, 0.6078882062762836, 0.15137485045186327, 0.15137485045186327, 0.15137485045186327, 0.4703624654387425, 0.4703624654387425, 0.4703624654387425, 0.29608033756085295, 0.29608033756085295, 0.29608033756085295, 0.37848745648320725, 0.37848745648320725, 0.37848745648320725, 0.1457709443591464, 0.1457709443591464, 0.1457709443591464, 0.19347004645180377, 0.19347004645180377, 0.19347004645180377, 0.19755008678486308, 0.19755008678486308, 0.19755008678486308, 0.17822762875791465, 0.17822762875791465, 0.17822762875791465, 0.06473514223413601, 0.06473514223413601, 0.06473514223413601, 0.0623151630178439, 0.0623151630178439, 0.0623151630178439, 0.06875705295777046, 0.06875705295777046, 0.06875705295777046]}, "mutation_prompt": null}
{"id": "efa7ff06-687b-417d-99d9-088ba46e996f", "solution": "import numpy as np\n\nclass HybridDEFireflyOptimized:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.alpha = 0.5\n        self.gamma = 1.0\n        self.success_history = []\n        self.learning_rate = 0.01\n\n    def __call__(self, func):\n        np.random.seed(42)\n        budget_used = 0\n\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history)) ** 0.5  # Adjusted mutation factor\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(self.learning_rate * np.random.rand())\n                else:\n                    self.success_history.append(-self.learning_rate * np.random.rand())\n\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            population = new_population\n            \n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if np.std(fitness) < 1e-3:\n                self.population_size = max(10, self.population_size - 5)  # Reduced noise faster\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFireflyOptimized", "description": "Enhance convergence by adjusting mutation factor based on historical success rate and reducing dimensional noise faster.", "configspace": "", "generation": 82, "fitness": 0.18382251866614113, "feedback": "The algorithm HybridDEFireflyOptimized got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.16.", "error": "", "parent_id": "942379f2-795a-4d2c-a9c9-ede1fe50a423", "metadata": {"aucs": [0.42373074261754196, 0.42373074261754196, 0.42373074261754196, 0.4213928483117594, 0.4213928483117594, 0.4213928483117594, 0.426836201835181, 0.426836201835181, 0.426836201835181, 0.049927107234630785, 0.049927107234630785, 0.049927107234630785, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01896411391227648, 0.01896411391227648, 0.01896411391227648, 0.10943865073076353, 0.10943865073076353, 0.10943865073076353, 0.0972627460718617, 0.0972627460718617, 0.0972627460718617, 0.11065415619211127, 0.11065415619211127, 0.11065415619211127, 0.07970605681030851, 0.07970605681030851, 0.07970605681030851, 0.06874449574690567, 0.06874449574690567, 0.06874449574690567, 0.054427540762065796, 0.054427540762065796, 0.054427540762065796, 0.7589136151186894, 0.7589136151186894, 0.7589136151186894, 0.6253879602167256, 0.6253879602167256, 0.6253879602167256, 0.14970670820231535, 0.14970670820231535, 0.14970670820231535, 0.2596169966918346, 0.2596169966918346, 0.2596169966918346, 0.2794157727400126, 0.2794157727400126, 0.2794157727400126, 0.27763111290115894, 0.27763111290115894, 0.27763111290115894, 0.20488520942992772, 0.20488520942992772, 0.20488520942992772, 0.5417286469036728, 0.5417286469036728, 0.5417286469036728, 0.1478593315552924, 0.1478593315552924, 0.1478593315552924, 0.1426159694573622, 0.1426159694573622, 0.1426159694573622, 0.1907763998239398, 0.1907763998239398, 0.1907763998239398, 0.09640312936340267, 0.09640312936340267, 0.09640312936340267, 0.14010439132475672, 0.14010439132475672, 0.14010439132475672, 0.1538040272406097, 0.1538040272406097, 0.1538040272406097, 0.21770514106150074, 0.21770514106150074, 0.21770514106150074, 0.017474363593292797, 0.017474363593292797, 0.017474363593292797, 0.031006601976107384, 0.031006601976107384, 0.031006601976107384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09868530979932677, 0.09868530979932677, 0.09868530979932677, 0.04086258579639912, 0.04086258579639912, 0.04086258579639912, 0.06368089988131964, 0.06368089988131964, 0.06368089988131964, 0.006651252733932411, 0.006651252733932411, 0.006651252733932411, 0.020170237040981198, 0.020170237040981198, 0.020170237040981198, 0.004730113968970939, 0.004730113968970939, 0.004730113968970939, 0.09112003349026399, 0.09112003349026399, 0.09112003349026399, 0.05579612855353244, 0.05579612855353244, 0.05579612855353244, 0.11125816293110036, 0.11125816293110036, 0.11125816293110036, 0.4330187275194757, 0.4330187275194757, 0.4330187275194757, 0.4137037746681965, 0.4137037746681965, 0.4137037746681965, 0.39719361659914654, 0.39719361659914654, 0.39719361659914654, 0.08278946416005073, 0.08278946416005073, 0.08278946416005073, 0.07787240815621954, 0.07787240815621954, 0.07787240815621954, 0.09660469141233952, 0.09660469141233952, 0.09660469141233952, 0.16954226564625896, 0.16954226564625896, 0.16954226564625896, 0.14321449618014026, 0.14321449618014026, 0.14321449618014026, 0.15020329024572476, 0.15020329024572476, 0.15020329024572476, 0.17462799839647125, 0.17462799839647125, 0.17462799839647125, 0.15107431866891308, 0.15107431866891308, 0.15107431866891308, 0.1857954507177526, 0.1857954507177526, 0.1857954507177526, 0.21532504526099838, 0.21532504526099838, 0.21532504526099838, 0.12398431518545328, 0.12398431518545328, 0.12398431518545328, 0.18311883182352162, 0.18311883182352162, 0.18311883182352162, 0.1979716135866092, 0.1979716135866092, 0.1979716135866092, 0.19460937743262385, 0.19460937743262385, 0.19460937743262385, 0.15883827594027788, 0.15883827594027788, 0.15883827594027788, 0.16613106760808982, 0.16613106760808982, 0.16613106760808982, 0.18920537130627413, 0.18920537130627413, 0.18920537130627413, 0.17720146264808923, 0.17720146264808923, 0.17720146264808923, 0.5401800811790671, 0.5401800811790671, 0.5401800811790671, 0.15362466243192352, 0.15362466243192352, 0.15362466243192352, 0.52497264449827, 0.52497264449827, 0.52497264449827, 0.1731434292173355, 0.1731434292173355, 0.1731434292173355, 0.26091914120889315, 0.26091914120889315, 0.26091914120889315, 0.14719631681758583, 0.14719631681758583, 0.14719631681758583, 0.18578618157609805, 0.18578618157609805, 0.18578618157609805, 0.18153047977336723, 0.18153047977336723, 0.18153047977336723, 0.17980784235779024, 0.17980784235779024, 0.17980784235779024, 0.07118777675392485, 0.07118777675392485, 0.07118777675392485, 0.0766940407762089, 0.0766940407762089, 0.0766940407762089, 0.06887812218723521, 0.06887812218723521, 0.06887812218723521]}, "mutation_prompt": null}
{"id": "4b25d67f-aa34-40e8-be0e-9e2c3e93d346", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.alpha = 0.5\n        self.gamma = 1.0\n        self.success_history = []\n        self.learning_rate = 0.01\n\n    def __call__(self, func):\n        np.random.seed(42)\n        budget_used = 0\n\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                diversity_factor = np.std(population, axis=0).mean()\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget)) * (1 + diversity_factor)\n                if self.success_history:\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(self.learning_rate * np.random.rand())\n                else:\n                    self.success_history.append(-self.learning_rate * np.random.rand())\n\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            population = new_population\n            \n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if np.std(fitness) < 1e-3:\n                self.population_size = max(10, self.population_size - 3)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Introduce adaptive mutation and crossover based on population diversity to enhance convergence and exploration balance.", "configspace": "", "generation": 83, "fitness": 0.1407793520440853, "feedback": "The algorithm HybridDEFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.16.", "error": "", "parent_id": "942379f2-795a-4d2c-a9c9-ede1fe50a423", "metadata": {"aucs": [0.3231919491574886, 0.3231919491574886, 0.3231919491574886, 0.3986723420466304, 0.3986723420466304, 0.3986723420466304, 0.3500072421264746, 0.3500072421264746, 0.3500072421264746, 0.002908090192671575, 0.002908090192671575, 0.002908090192671575, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011188832499014145, 0.011188832499014145, 0.011188832499014145, 0.07789421999848456, 0.07789421999848456, 0.07789421999848456, 0.061692787324032494, 0.061692787324032494, 0.061692787324032494, 0.06549371553936345, 0.06549371553936345, 0.06549371553936345, 0.022653192135734024, 0.022653192135734024, 0.022653192135734024, 0.01858242111128472, 0.01858242111128472, 0.01858242111128472, 0.024505274308856295, 0.024505274308856295, 0.024505274308856295, 0.7063323704754623, 0.7063323704754623, 0.7063323704754623, 0.8122689106501747, 0.8122689106501747, 0.8122689106501747, 0.7714445222419637, 0.7714445222419637, 0.7714445222419637, 0.24756769854293714, 0.24756769854293714, 0.24756769854293714, 0.13557371726977274, 0.13557371726977274, 0.13557371726977274, 0.18701779115777195, 0.18701779115777195, 0.18701779115777195, 0.13977663228152526, 0.13977663228152526, 0.13977663228152526, 0.16335824449135905, 0.16335824449135905, 0.16335824449135905, 0.08664845679765454, 0.08664845679765454, 0.08664845679765454, 0.06023367826063841, 0.06023367826063841, 0.06023367826063841, 0.06657215052715515, 0.06657215052715515, 0.06657215052715515, 0.10613681702349309, 0.10613681702349309, 0.10613681702349309, 0.10493287570555498, 0.10493287570555498, 0.10493287570555498, 0.08358821769837255, 0.08358821769837255, 0.08358821769837255, 0.003641971791909948, 0.003641971791909948, 0.003641971791909948, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05209656888052161, 0.05209656888052161, 0.05209656888052161, 0.007779686095663596, 0.007779686095663596, 0.007779686095663596, 0.044624327704144484, 0.044624327704144484, 0.044624327704144484, 0.0040172989880715715, 0.0040172989880715715, 0.0040172989880715715, 0.015092528518148352, 0.015092528518148352, 0.015092528518148352, 0.010496349167014918, 0.010496349167014918, 0.010496349167014918, 0.06633021408196615, 0.06633021408196615, 0.06633021408196615, 0.08027096639702269, 0.08027096639702269, 0.08027096639702269, 0.0608402679721175, 0.0608402679721175, 0.0608402679721175, 0.3393377942468978, 0.3393377942468978, 0.3393377942468978, 0.303729836136413, 0.303729836136413, 0.303729836136413, 0.28003820207143504, 0.28003820207143504, 0.28003820207143504, 0.07473900975809578, 0.07473900975809578, 0.07473900975809578, 0.045025774382514316, 0.045025774382514316, 0.045025774382514316, 0.059095067127071355, 0.059095067127071355, 0.059095067127071355, 0.13831351300902683, 0.13831351300902683, 0.13831351300902683, 0.15899015065504207, 0.15899015065504207, 0.15899015065504207, 0.19272007422661808, 0.19272007422661808, 0.19272007422661808, 0.18587604027014748, 0.18587604027014748, 0.18587604027014748, 0.14569975878824204, 0.14569975878824204, 0.14569975878824204, 0.18661205974372164, 0.18661205974372164, 0.18661205974372164, 0.1163401610690098, 0.1163401610690098, 0.1163401610690098, 0.103577223433296, 0.103577223433296, 0.103577223433296, 0.14047496337771137, 0.14047496337771137, 0.14047496337771137, 0.14153956246928412, 0.14153956246928412, 0.14153956246928412, 0.153484366528148, 0.153484366528148, 0.153484366528148, 0.1376038137987382, 0.1376038137987382, 0.1376038137987382, 0.1081896794659235, 0.1081896794659235, 0.1081896794659235, 0.11569563411878847, 0.11569563411878847, 0.11569563411878847, 0.10007708169161489, 0.10007708169161489, 0.10007708169161489, 0.16292861154288474, 0.16292861154288474, 0.16292861154288474, 0.1709208974789561, 0.1709208974789561, 0.1709208974789561, 0.12126745185689725, 0.12126745185689725, 0.12126745185689725, 0.15529199963268092, 0.15529199963268092, 0.15529199963268092, 0.1014148584010669, 0.1014148584010669, 0.1014148584010669, 0.16550183787095663, 0.16550183787095663, 0.16550183787095663, 0.18308275235086147, 0.18308275235086147, 0.18308275235086147, 0.1743753852226979, 0.1743753852226979, 0.1743753852226979, 0.1820042809474709, 0.1820042809474709, 0.1820042809474709, 0.03987165766127343, 0.03987165766127343, 0.03987165766127343, 0.03610882420564554, 0.03610882420564554, 0.03610882420564554, 0.042352694474556696, 0.042352694474556696, 0.042352694474556696]}, "mutation_prompt": null}
{"id": "840b75b4-19be-416c-a4e6-e391858be050", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.alpha = 0.5\n        self.gamma = 1.0\n        self.success_history = []\n        self.learning_rate = 0.01\n\n    def __call__(self, func):\n        np.random.seed(42)\n        budget_used = 0\n\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(self.learning_rate * np.random.rand())\n                else:\n                    self.success_history.append(-self.learning_rate * np.random.rand())\n\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            population = new_population\n            \n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if np.std(fitness) < 1e-3:\n                self.population_size = max(10, self.population_size - 3)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Refine convergence by introducing stochastic adaptive learning rate to enhance global exploration and diversity.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "942379f2-795a-4d2c-a9c9-ede1fe50a423", "metadata": {"aucs": [0.4316324779008963, 0.4316324779008963, 0.4316324779008963, 0.4398310658013598, 0.4398310658013598, 0.4398310658013598, 0.474673678009655, 0.474673678009655, 0.474673678009655, 0.04456333248430622, 0.04456333248430622, 0.04456333248430622, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11822986331965624, 0.11822986331965624, 0.11822986331965624, 0.09164497827853324, 0.09164497827853324, 0.09164497827853324, 0.0908636064158167, 0.0908636064158167, 0.0908636064158167, 0.056211033215752826, 0.056211033215752826, 0.056211033215752826, 0.06963770071126196, 0.06963770071126196, 0.06963770071126196, 0.06267493469288687, 0.06267493469288687, 0.06267493469288687, 0.7914905691714824, 0.7914905691714824, 0.7914905691714824, 0.4641310908934111, 0.4641310908934111, 0.4641310908934111, 0.12063358030336657, 0.12063358030336657, 0.12063358030336657, 0.275038132570418, 0.275038132570418, 0.275038132570418, 0.25800275984318044, 0.25800275984318044, 0.25800275984318044, 0.2828331037421219, 0.2828331037421219, 0.2828331037421219, 0.546148739517615, 0.546148739517615, 0.546148739517615, 0.49315404315195943, 0.49315404315195943, 0.49315404315195943, 0.12092865580081091, 0.12092865580081091, 0.12092865580081091, 0.15657466284802435, 0.15657466284802435, 0.15657466284802435, 0.1804585139809013, 0.1804585139809013, 0.1804585139809013, 0.14432521485423855, 0.14432521485423855, 0.14432521485423855, 0.16024207820954994, 0.16024207820954994, 0.16024207820954994, 0.15013688245464196, 0.15013688245464196, 0.15013688245464196, 0.19907065109987732, 0.19907065109987732, 0.19907065109987732, 0.031729437177347775, 0.031729437177347775, 0.031729437177347775, 0.028998388520592222, 0.028998388520592222, 0.028998388520592222, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08362624935201035, 0.08362624935201035, 0.08362624935201035, 0.026425201363172723, 0.026425201363172723, 0.026425201363172723, 0.06519401048334916, 0.06519401048334916, 0.06519401048334916, 0.01433911361584106, 0.01433911361584106, 0.01433911361584106, 0.00769537993512881, 0.00769537993512881, 0.00769537993512881, 0.010672672204237843, 0.010672672204237843, 0.010672672204237843, 0.059988656179477906, 0.059988656179477906, 0.059988656179477906, 0.0719538127449929, 0.0719538127449929, 0.0719538127449929, 0.12445086477063416, 0.12445086477063416, 0.12445086477063416, 0.4300796449516281, 0.4300796449516281, 0.4300796449516281, 0.41390419414102964, 0.41390419414102964, 0.41390419414102964, 0.4006953206652003, 0.4006953206652003, 0.4006953206652003, 0.08439171442247262, 0.08439171442247262, 0.08439171442247262, 0.10349533107671194, 0.10349533107671194, 0.10349533107671194, 0.0966051784144325, 0.0966051784144325, 0.0966051784144325, 0.1821114128508161, 0.1821114128508161, 0.1821114128508161, 0.13169165430578655, 0.13169165430578655, 0.13169165430578655, 0.12619252740933895, 0.12619252740933895, 0.12619252740933895, 0.1900519975436027, 0.1900519975436027, 0.1900519975436027, 0.2768870409019287, 0.2768870409019287, 0.2768870409019287, 0.2502306362202801, 0.2502306362202801, 0.2502306362202801, 0.1626236108685689, 0.1626236108685689, 0.1626236108685689, 0.19966827225050665, 0.19966827225050665, 0.19966827225050665, 0.1513681333485729, 0.1513681333485729, 0.1513681333485729, 0.19446153617568185, 0.19446153617568185, 0.19446153617568185, 0.21986928713464082, 0.21986928713464082, 0.21986928713464082, 0.18059021773131412, 0.18059021773131412, 0.18059021773131412, 0.1666662635160162, 0.1666662635160162, 0.1666662635160162, 0.1879675952038391, 0.1879675952038391, 0.1879675952038391, 0.16564311194612635, 0.16564311194612635, 0.16564311194612635, 0.5901935543397198, 0.5901935543397198, 0.5901935543397198, 0.15138270376521756, 0.15138270376521756, 0.15138270376521756, 0.47012941168044886, 0.47012941168044886, 0.47012941168044886, 0.279290080562398, 0.279290080562398, 0.279290080562398, 0.363666351089849, 0.363666351089849, 0.363666351089849, 0.14576118837238505, 0.14576118837238505, 0.14576118837238505, 0.19347004645180377, 0.19347004645180377, 0.19347004645180377, 0.18188146747909306, 0.18188146747909306, 0.18188146747909306, 0.18945171911003622, 0.18945171911003622, 0.18945171911003622, 0.06473514223413601, 0.06473514223413601, 0.06473514223413601, 0.0623151630178439, 0.0623151630178439, 0.0623151630178439, 0.06875705295777046, 0.06875705295777046, 0.06875705295777046]}, "mutation_prompt": null}
{"id": "0c3f2ccb-21b2-48e4-b269-92ef05ccb95b", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.alpha = 0.5\n        self.gamma = 1.0\n        self.success_history = []\n        self.learning_rate = 0.01\n\n    def __call__(self, func):\n        np.random.seed(42)\n        budget_used = 0\n\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n            epoch_variance = np.mean(np.abs(np.gradient(fitness)))\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(self.learning_rate * np.random.rand() * epoch_variance)\n                else:\n                    self.success_history.append(-self.learning_rate * np.random.rand() * epoch_variance)\n\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            population = new_population\n            \n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if np.std(fitness) < 1e-3:\n                self.population_size = max(10, self.population_size - 3)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Enhance crossover by using a dynamic learning rate influenced by epoch variance to improve exploration and convergence.", "configspace": "", "generation": 85, "fitness": 0.15286960423341012, "feedback": "The algorithm HybridDEFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.16.", "error": "", "parent_id": "942379f2-795a-4d2c-a9c9-ede1fe50a423", "metadata": {"aucs": [0.42752635532913463, 0.42752635532913463, 0.42752635532913463, 0.40725392575905417, 0.40725392575905417, 0.40725392575905417, 0.419989809882246, 0.419989809882246, 0.419989809882246, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11508784438926067, 0.11508784438926067, 0.11508784438926067, 0.10368219679444757, 0.10368219679444757, 0.10368219679444757, 0.07886844922466041, 0.07886844922466041, 0.07886844922466041, 0.04271265970250204, 0.04271265970250204, 0.04271265970250204, 0.07972604134955541, 0.07972604134955541, 0.07972604134955541, 0.09184890145539759, 0.09184890145539759, 0.09184890145539759, 0.4966448577083383, 0.4966448577083383, 0.4966448577083383, 0.5999792077198416, 0.5999792077198416, 0.5999792077198416, 0.11795480129837921, 0.11795480129837921, 0.11795480129837921, 0.26095570023889114, 0.26095570023889114, 0.26095570023889114, 0.1924912132821187, 0.1924912132821187, 0.1924912132821187, 0.02343591127017952, 0.02343591127017952, 0.02343591127017952, 0.21246084916060382, 0.21246084916060382, 0.21246084916060382, 0.20040583093533437, 0.20040583093533437, 0.20040583093533437, 0.13394957201048185, 0.13394957201048185, 0.13394957201048185, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.060754832198802844, 0.060754832198802844, 0.060754832198802844, 0.044586321429858744, 0.044586321429858744, 0.044586321429858744, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04468777941838231, 0.04468777941838231, 0.04468777941838231, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.049134322260791286, 0.049134322260791286, 0.049134322260791286, 0.027523730831138904, 0.027523730831138904, 0.027523730831138904, 0.04550376001697054, 0.04550376001697054, 0.04550376001697054, 0.0011727865186045294, 0.0011727865186045294, 0.0011727865186045294, 0.00701119169391462, 0.00701119169391462, 0.00701119169391462, 0.006190485672671109, 0.006190485672671109, 0.006190485672671109, 0.06385238406582316, 0.06385238406582316, 0.06385238406582316, 0.06677940017752548, 0.06677940017752548, 0.06677940017752548, 0.10661763021068604, 0.10661763021068604, 0.10661763021068604, 0.4256110619604353, 0.4256110619604353, 0.4256110619604353, 0.40164905416806074, 0.40164905416806074, 0.40164905416806074, 0.4082206134871622, 0.4082206134871622, 0.4082206134871622, 0.08644610227239269, 0.08644610227239269, 0.08644610227239269, 0.10139023680889947, 0.10139023680889947, 0.10139023680889947, 0.06495207175901452, 0.06495207175901452, 0.06495207175901452, 0.16411314535655852, 0.16411314535655852, 0.16411314535655852, 0.15104583540172012, 0.15104583540172012, 0.15104583540172012, 0.13603342834119758, 0.13603342834119758, 0.13603342834119758, 0.17860776977543213, 0.17860776977543213, 0.17860776977543213, 0.17068463752283247, 0.17068463752283247, 0.17068463752283247, 0.2814794277138579, 0.2814794277138579, 0.2814794277138579, 0.22817450301983644, 0.22817450301983644, 0.22817450301983644, 0.12111390045414316, 0.12111390045414316, 0.12111390045414316, 0.18447227977470793, 0.18447227977470793, 0.18447227977470793, 0.17167308788666547, 0.17167308788666547, 0.17167308788666547, 0.17999115503758967, 0.17999115503758967, 0.17999115503758967, 0.19072533547919535, 0.19072533547919535, 0.19072533547919535, 0.003671497172674565, 0.003671497172674565, 0.003671497172674565, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.15743134029622619, 0.15743134029622619, 0.15743134029622619, 0.6430920563780747, 0.6430920563780747, 0.6430920563780747, 0.35406953635768135, 0.35406953635768135, 0.35406953635768135, 0.5422327643801219, 0.5422327643801219, 0.5422327643801219, 0.18844074592514448, 0.18844074592514448, 0.18844074592514448, 0.14993657365908253, 0.14993657365908253, 0.14993657365908253, 0.1821491751489389, 0.1821491751489389, 0.1821491751489389, 0.20245651381047158, 0.20245651381047158, 0.20245651381047158, 0.18236791336681046, 0.18236791336681046, 0.18236791336681046, 0.06718364666304211, 0.06718364666304211, 0.06718364666304211, 0.09243694833278882, 0.09243694833278882, 0.09243694833278882, 0.0648703950891737, 0.0648703950891737, 0.0648703950891737]}, "mutation_prompt": null}
{"id": "925ccebd-196a-48d9-a8f6-7f8df8eee2ab", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.alpha = 0.5\n        self.gamma = 1.0\n        self.success_history = []\n        self.learning_rate = 0.01\n\n    def __call__(self, func):\n        np.random.seed(42)\n        budget_used = 0\n\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(self.learning_rate * np.random.rand())\n                else:\n                    self.success_history.append(-self.learning_rate * np.random.rand())\n\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            population = new_population\n            \n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if np.std(fitness) < 1e-3:\n                self.population_size = max(10, self.population_size - 3)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Refine convergence by introducing stochastic adaptive learning rate to enhance global exploration and diversity.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "942379f2-795a-4d2c-a9c9-ede1fe50a423", "metadata": {"aucs": [0.4316324779008963, 0.4316324779008963, 0.4316324779008963, 0.4398310658013598, 0.4398310658013598, 0.4398310658013598, 0.474673678009655, 0.474673678009655, 0.474673678009655, 0.04456333248430622, 0.04456333248430622, 0.04456333248430622, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11822986331965624, 0.11822986331965624, 0.11822986331965624, 0.09164497827853324, 0.09164497827853324, 0.09164497827853324, 0.0908636064158167, 0.0908636064158167, 0.0908636064158167, 0.056211033215752826, 0.056211033215752826, 0.056211033215752826, 0.06963770071126196, 0.06963770071126196, 0.06963770071126196, 0.06267493469288687, 0.06267493469288687, 0.06267493469288687, 0.7914905691714824, 0.7914905691714824, 0.7914905691714824, 0.4641310908934111, 0.4641310908934111, 0.4641310908934111, 0.12063358030336657, 0.12063358030336657, 0.12063358030336657, 0.275038132570418, 0.275038132570418, 0.275038132570418, 0.25800275984318044, 0.25800275984318044, 0.25800275984318044, 0.2828331037421219, 0.2828331037421219, 0.2828331037421219, 0.546148739517615, 0.546148739517615, 0.546148739517615, 0.49315404315195943, 0.49315404315195943, 0.49315404315195943, 0.12092865580081091, 0.12092865580081091, 0.12092865580081091, 0.15657466284802435, 0.15657466284802435, 0.15657466284802435, 0.1804585139809013, 0.1804585139809013, 0.1804585139809013, 0.14432521485423855, 0.14432521485423855, 0.14432521485423855, 0.16024207820954994, 0.16024207820954994, 0.16024207820954994, 0.15013688245464196, 0.15013688245464196, 0.15013688245464196, 0.19907065109987732, 0.19907065109987732, 0.19907065109987732, 0.031729437177347775, 0.031729437177347775, 0.031729437177347775, 0.028998388520592222, 0.028998388520592222, 0.028998388520592222, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08362624935201035, 0.08362624935201035, 0.08362624935201035, 0.026425201363172723, 0.026425201363172723, 0.026425201363172723, 0.06519401048334916, 0.06519401048334916, 0.06519401048334916, 0.01433911361584106, 0.01433911361584106, 0.01433911361584106, 0.00769537993512881, 0.00769537993512881, 0.00769537993512881, 0.010672672204237843, 0.010672672204237843, 0.010672672204237843, 0.059988656179477906, 0.059988656179477906, 0.059988656179477906, 0.0719538127449929, 0.0719538127449929, 0.0719538127449929, 0.12445086477063416, 0.12445086477063416, 0.12445086477063416, 0.4300796449516281, 0.4300796449516281, 0.4300796449516281, 0.41390419414102964, 0.41390419414102964, 0.41390419414102964, 0.4006953206652003, 0.4006953206652003, 0.4006953206652003, 0.08439171442247262, 0.08439171442247262, 0.08439171442247262, 0.10349533107671194, 0.10349533107671194, 0.10349533107671194, 0.0966051784144325, 0.0966051784144325, 0.0966051784144325, 0.1821114128508161, 0.1821114128508161, 0.1821114128508161, 0.13169165430578655, 0.13169165430578655, 0.13169165430578655, 0.12619252740933895, 0.12619252740933895, 0.12619252740933895, 0.1900519975436027, 0.1900519975436027, 0.1900519975436027, 0.2768870409019287, 0.2768870409019287, 0.2768870409019287, 0.2502306362202801, 0.2502306362202801, 0.2502306362202801, 0.1626236108685689, 0.1626236108685689, 0.1626236108685689, 0.19966827225050665, 0.19966827225050665, 0.19966827225050665, 0.1513681333485729, 0.1513681333485729, 0.1513681333485729, 0.19446153617568185, 0.19446153617568185, 0.19446153617568185, 0.21986928713464082, 0.21986928713464082, 0.21986928713464082, 0.18059021773131412, 0.18059021773131412, 0.18059021773131412, 0.1666662635160162, 0.1666662635160162, 0.1666662635160162, 0.1879675952038391, 0.1879675952038391, 0.1879675952038391, 0.16564311194612635, 0.16564311194612635, 0.16564311194612635, 0.5901935543397198, 0.5901935543397198, 0.5901935543397198, 0.15138270376521756, 0.15138270376521756, 0.15138270376521756, 0.47012941168044886, 0.47012941168044886, 0.47012941168044886, 0.279290080562398, 0.279290080562398, 0.279290080562398, 0.363666351089849, 0.363666351089849, 0.363666351089849, 0.14576118837238505, 0.14576118837238505, 0.14576118837238505, 0.19347004645180377, 0.19347004645180377, 0.19347004645180377, 0.18188146747909306, 0.18188146747909306, 0.18188146747909306, 0.18945171911003622, 0.18945171911003622, 0.18945171911003622, 0.06473514223413601, 0.06473514223413601, 0.06473514223413601, 0.0623151630178439, 0.0623151630178439, 0.0623151630178439, 0.06875705295777046, 0.06875705295777046, 0.06875705295777046]}, "mutation_prompt": null}
{"id": "68cb1232-270f-490f-afcf-827d019d7e1a", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.alpha = 0.5\n        self.gamma = 1.0\n        self.success_history = []\n        self.learning_rate = 0.01\n\n    def __call__(self, func):\n        np.random.seed(42)\n        budget_used = 0\n\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(self.learning_rate * np.random.rand())\n                else:\n                    self.success_history.append(-self.learning_rate * np.random.rand())\n\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            population = new_population\n            \n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if np.std(fitness) < 1e-3:\n                self.population_size = max(10, self.population_size - 3)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Refine convergence by introducing stochastic adaptive learning rate to enhance global exploration and diversity.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "942379f2-795a-4d2c-a9c9-ede1fe50a423", "metadata": {"aucs": [0.4316324779008963, 0.4316324779008963, 0.4316324779008963, 0.4398310658013598, 0.4398310658013598, 0.4398310658013598, 0.474673678009655, 0.474673678009655, 0.474673678009655, 0.04456333248430622, 0.04456333248430622, 0.04456333248430622, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11822986331965624, 0.11822986331965624, 0.11822986331965624, 0.09164497827853324, 0.09164497827853324, 0.09164497827853324, 0.0908636064158167, 0.0908636064158167, 0.0908636064158167, 0.056211033215752826, 0.056211033215752826, 0.056211033215752826, 0.06963770071126196, 0.06963770071126196, 0.06963770071126196, 0.06267493469288687, 0.06267493469288687, 0.06267493469288687, 0.7914905691714824, 0.7914905691714824, 0.7914905691714824, 0.4641310908934111, 0.4641310908934111, 0.4641310908934111, 0.12063358030336657, 0.12063358030336657, 0.12063358030336657, 0.275038132570418, 0.275038132570418, 0.275038132570418, 0.25800275984318044, 0.25800275984318044, 0.25800275984318044, 0.2828331037421219, 0.2828331037421219, 0.2828331037421219, 0.546148739517615, 0.546148739517615, 0.546148739517615, 0.49315404315195943, 0.49315404315195943, 0.49315404315195943, 0.12092865580081091, 0.12092865580081091, 0.12092865580081091, 0.15657466284802435, 0.15657466284802435, 0.15657466284802435, 0.1804585139809013, 0.1804585139809013, 0.1804585139809013, 0.14432521485423855, 0.14432521485423855, 0.14432521485423855, 0.16024207820954994, 0.16024207820954994, 0.16024207820954994, 0.15013688245464196, 0.15013688245464196, 0.15013688245464196, 0.19907065109987732, 0.19907065109987732, 0.19907065109987732, 0.031729437177347775, 0.031729437177347775, 0.031729437177347775, 0.028998388520592222, 0.028998388520592222, 0.028998388520592222, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08362624935201035, 0.08362624935201035, 0.08362624935201035, 0.026425201363172723, 0.026425201363172723, 0.026425201363172723, 0.06519401048334916, 0.06519401048334916, 0.06519401048334916, 0.01433911361584106, 0.01433911361584106, 0.01433911361584106, 0.00769537993512881, 0.00769537993512881, 0.00769537993512881, 0.010672672204237843, 0.010672672204237843, 0.010672672204237843, 0.059988656179477906, 0.059988656179477906, 0.059988656179477906, 0.0719538127449929, 0.0719538127449929, 0.0719538127449929, 0.12445086477063416, 0.12445086477063416, 0.12445086477063416, 0.4300796449516281, 0.4300796449516281, 0.4300796449516281, 0.41390419414102964, 0.41390419414102964, 0.41390419414102964, 0.4006953206652003, 0.4006953206652003, 0.4006953206652003, 0.08439171442247262, 0.08439171442247262, 0.08439171442247262, 0.10349533107671194, 0.10349533107671194, 0.10349533107671194, 0.0966051784144325, 0.0966051784144325, 0.0966051784144325, 0.1821114128508161, 0.1821114128508161, 0.1821114128508161, 0.13169165430578655, 0.13169165430578655, 0.13169165430578655, 0.12619252740933895, 0.12619252740933895, 0.12619252740933895, 0.1900519975436027, 0.1900519975436027, 0.1900519975436027, 0.2768870409019287, 0.2768870409019287, 0.2768870409019287, 0.2502306362202801, 0.2502306362202801, 0.2502306362202801, 0.1626236108685689, 0.1626236108685689, 0.1626236108685689, 0.19966827225050665, 0.19966827225050665, 0.19966827225050665, 0.1513681333485729, 0.1513681333485729, 0.1513681333485729, 0.19446153617568185, 0.19446153617568185, 0.19446153617568185, 0.21986928713464082, 0.21986928713464082, 0.21986928713464082, 0.18059021773131412, 0.18059021773131412, 0.18059021773131412, 0.1666662635160162, 0.1666662635160162, 0.1666662635160162, 0.1879675952038391, 0.1879675952038391, 0.1879675952038391, 0.16564311194612635, 0.16564311194612635, 0.16564311194612635, 0.5901935543397198, 0.5901935543397198, 0.5901935543397198, 0.15138270376521756, 0.15138270376521756, 0.15138270376521756, 0.47012941168044886, 0.47012941168044886, 0.47012941168044886, 0.279290080562398, 0.279290080562398, 0.279290080562398, 0.363666351089849, 0.363666351089849, 0.363666351089849, 0.14576118837238505, 0.14576118837238505, 0.14576118837238505, 0.19347004645180377, 0.19347004645180377, 0.19347004645180377, 0.18188146747909306, 0.18188146747909306, 0.18188146747909306, 0.18945171911003622, 0.18945171911003622, 0.18945171911003622, 0.06473514223413601, 0.06473514223413601, 0.06473514223413601, 0.0623151630178439, 0.0623151630178439, 0.0623151630178439, 0.06875705295777046, 0.06875705295777046, 0.06875705295777046]}, "mutation_prompt": null}
{"id": "18ad7d2f-5eea-4ab8-a5a9-01831e7482ad", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.alpha = 0.5\n        self.gamma = 1.0\n        self.success_history = []\n        self.learning_rate = 0.01\n\n    def __call__(self, func):\n        np.random.seed(42)\n        budget_used = 0\n\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(self.learning_rate * np.random.rand())\n                else:\n                    self.success_history.append(-self.learning_rate * np.random.rand())\n\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            population = new_population\n            \n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if np.std(fitness) < 1e-3:\n                self.population_size = max(10, self.population_size - 3)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Refine convergence by introducing stochastic adaptive learning rate to enhance global exploration and diversity.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "942379f2-795a-4d2c-a9c9-ede1fe50a423", "metadata": {"aucs": [0.4316324779008963, 0.4316324779008963, 0.4316324779008963, 0.4398310658013598, 0.4398310658013598, 0.4398310658013598, 0.474673678009655, 0.474673678009655, 0.474673678009655, 0.04456333248430622, 0.04456333248430622, 0.04456333248430622, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11822986331965624, 0.11822986331965624, 0.11822986331965624, 0.09164497827853324, 0.09164497827853324, 0.09164497827853324, 0.0908636064158167, 0.0908636064158167, 0.0908636064158167, 0.056211033215752826, 0.056211033215752826, 0.056211033215752826, 0.06963770071126196, 0.06963770071126196, 0.06963770071126196, 0.06267493469288687, 0.06267493469288687, 0.06267493469288687, 0.7914905691714824, 0.7914905691714824, 0.7914905691714824, 0.4641310908934111, 0.4641310908934111, 0.4641310908934111, 0.12063358030336657, 0.12063358030336657, 0.12063358030336657, 0.275038132570418, 0.275038132570418, 0.275038132570418, 0.25800275984318044, 0.25800275984318044, 0.25800275984318044, 0.2828331037421219, 0.2828331037421219, 0.2828331037421219, 0.546148739517615, 0.546148739517615, 0.546148739517615, 0.49315404315195943, 0.49315404315195943, 0.49315404315195943, 0.12092865580081091, 0.12092865580081091, 0.12092865580081091, 0.15657466284802435, 0.15657466284802435, 0.15657466284802435, 0.1804585139809013, 0.1804585139809013, 0.1804585139809013, 0.14432521485423855, 0.14432521485423855, 0.14432521485423855, 0.16024207820954994, 0.16024207820954994, 0.16024207820954994, 0.15013688245464196, 0.15013688245464196, 0.15013688245464196, 0.19907065109987732, 0.19907065109987732, 0.19907065109987732, 0.031729437177347775, 0.031729437177347775, 0.031729437177347775, 0.028998388520592222, 0.028998388520592222, 0.028998388520592222, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08362624935201035, 0.08362624935201035, 0.08362624935201035, 0.026425201363172723, 0.026425201363172723, 0.026425201363172723, 0.06519401048334916, 0.06519401048334916, 0.06519401048334916, 0.01433911361584106, 0.01433911361584106, 0.01433911361584106, 0.00769537993512881, 0.00769537993512881, 0.00769537993512881, 0.010672672204237843, 0.010672672204237843, 0.010672672204237843, 0.059988656179477906, 0.059988656179477906, 0.059988656179477906, 0.0719538127449929, 0.0719538127449929, 0.0719538127449929, 0.12445086477063416, 0.12445086477063416, 0.12445086477063416, 0.4300796449516281, 0.4300796449516281, 0.4300796449516281, 0.41390419414102964, 0.41390419414102964, 0.41390419414102964, 0.4006953206652003, 0.4006953206652003, 0.4006953206652003, 0.08439171442247262, 0.08439171442247262, 0.08439171442247262, 0.10349533107671194, 0.10349533107671194, 0.10349533107671194, 0.0966051784144325, 0.0966051784144325, 0.0966051784144325, 0.1821114128508161, 0.1821114128508161, 0.1821114128508161, 0.13169165430578655, 0.13169165430578655, 0.13169165430578655, 0.12619252740933895, 0.12619252740933895, 0.12619252740933895, 0.1900519975436027, 0.1900519975436027, 0.1900519975436027, 0.2768870409019287, 0.2768870409019287, 0.2768870409019287, 0.2502306362202801, 0.2502306362202801, 0.2502306362202801, 0.1626236108685689, 0.1626236108685689, 0.1626236108685689, 0.19966827225050665, 0.19966827225050665, 0.19966827225050665, 0.1513681333485729, 0.1513681333485729, 0.1513681333485729, 0.19446153617568185, 0.19446153617568185, 0.19446153617568185, 0.21986928713464082, 0.21986928713464082, 0.21986928713464082, 0.18059021773131412, 0.18059021773131412, 0.18059021773131412, 0.1666662635160162, 0.1666662635160162, 0.1666662635160162, 0.1879675952038391, 0.1879675952038391, 0.1879675952038391, 0.16564311194612635, 0.16564311194612635, 0.16564311194612635, 0.5901935543397198, 0.5901935543397198, 0.5901935543397198, 0.15138270376521756, 0.15138270376521756, 0.15138270376521756, 0.47012941168044886, 0.47012941168044886, 0.47012941168044886, 0.279290080562398, 0.279290080562398, 0.279290080562398, 0.363666351089849, 0.363666351089849, 0.363666351089849, 0.14576118837238505, 0.14576118837238505, 0.14576118837238505, 0.19347004645180377, 0.19347004645180377, 0.19347004645180377, 0.18188146747909306, 0.18188146747909306, 0.18188146747909306, 0.18945171911003622, 0.18945171911003622, 0.18945171911003622, 0.06473514223413601, 0.06473514223413601, 0.06473514223413601, 0.0623151630178439, 0.0623151630178439, 0.0623151630178439, 0.06875705295777046, 0.06875705295777046, 0.06875705295777046]}, "mutation_prompt": null}
{"id": "b940a937-cb77-4aa4-bc3c-543229464873", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.alpha = 0.5\n        self.gamma = 1.0\n        self.success_history = []\n        self.learning_rate = 0.01\n\n    def __call__(self, func):\n        np.random.seed(42)\n        budget_used = 0\n\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * np.exp(-fitness_variance / (1 + fitness_variance))\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:\n                    dynamic_mutation_factor *= (1 + np.var(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(self.learning_rate * np.random.rand())\n                else:\n                    self.success_history.append(-self.learning_rate * np.random.rand())\n\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            population = new_population\n            \n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if np.std(fitness) < 1e-3:\n                self.population_size = max(10, self.population_size - 3)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Enhance exploration by introducing dynamically adaptive mutation factor based on success history variance and improve convergence with exponential crossover reduction.", "configspace": "", "generation": 89, "fitness": 0.14810524629162333, "feedback": "The algorithm HybridDEFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.13.", "error": "", "parent_id": "942379f2-795a-4d2c-a9c9-ede1fe50a423", "metadata": {"aucs": [0.43956084192300027, 0.43956084192300027, 0.43956084192300027, 0.3889379924802129, 0.3889379924802129, 0.3889379924802129, 0.3990283535408754, 0.3990283535408754, 0.3990283535408754, 0.013170919619350019, 0.013170919619350019, 0.013170919619350019, 0.00014342814688828032, 0.00014342814688828032, 0.00014342814688828032, 0.013978229169402945, 0.013978229169402945, 0.013978229169402945, 0.0804034701174815, 0.0804034701174815, 0.0804034701174815, 0.15976507672250206, 0.15976507672250206, 0.15976507672250206, 0.08738271365250916, 0.08738271365250916, 0.08738271365250916, 0.04897656207196055, 0.04897656207196055, 0.04897656207196055, 0.05526194576676002, 0.05526194576676002, 0.05526194576676002, 0.11030252818189978, 0.11030252818189978, 0.11030252818189978, 0.5977260010972817, 0.5977260010972817, 0.5977260010972817, 0.5242530837609001, 0.5242530837609001, 0.5242530837609001, 0.6501160080159927, 0.6501160080159927, 0.6501160080159927, 0.10309631564228383, 0.10309631564228383, 0.10309631564228383, 0.13591335288630257, 0.13591335288630257, 0.13591335288630257, 0.10332868822997954, 0.10332868822997954, 0.10332868822997954, 0.1168336882910429, 0.1168336882910429, 0.1168336882910429, 0.24039657902187805, 0.24039657902187805, 0.24039657902187805, 0.1369077356609696, 0.1369077356609696, 0.1369077356609696, 0.13136389141451343, 0.13136389141451343, 0.13136389141451343, 0.07616635800531601, 0.07616635800531601, 0.07616635800531601, 0.12056452295876119, 0.12056452295876119, 0.12056452295876119, 0.07525884078555078, 0.07525884078555078, 0.07525884078555078, 0.10069524319357792, 0.10069524319357792, 0.10069524319357792, 0.08212533232768815, 0.08212533232768815, 0.08212533232768815, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06562021044907373, 0.06562021044907373, 0.06562021044907373, 0.09331983170266611, 0.09331983170266611, 0.09331983170266611, 0.04804609952595362, 0.04804609952595362, 0.04804609952595362, 0.002918771794526265, 0.002918771794526265, 0.002918771794526265, 0.007097451363567209, 0.007097451363567209, 0.007097451363567209, 0.006997154930118432, 0.006997154930118432, 0.006997154930118432, 0.07255096373492254, 0.07255096373492254, 0.07255096373492254, 0.04433777403307426, 0.04433777403307426, 0.04433777403307426, 0.1034747074903053, 0.1034747074903053, 0.1034747074903053, 0.34641869281107907, 0.34641869281107907, 0.34641869281107907, 0.3510177070704713, 0.3510177070704713, 0.3510177070704713, 0.3217780137840778, 0.3217780137840778, 0.3217780137840778, 0.08289384127238886, 0.08289384127238886, 0.08289384127238886, 0.05673373152386063, 0.05673373152386063, 0.05673373152386063, 0.07195384328662291, 0.07195384328662291, 0.07195384328662291, 0.1289241668838529, 0.1289241668838529, 0.1289241668838529, 0.1532068219702043, 0.1532068219702043, 0.1532068219702043, 0.13114488948970482, 0.13114488948970482, 0.13114488948970482, 0.15007816132510066, 0.15007816132510066, 0.15007816132510066, 0.1818858605388134, 0.1818858605388134, 0.1818858605388134, 0.17194142307862403, 0.17194142307862403, 0.17194142307862403, 0.09097893431508086, 0.09097893431508086, 0.09097893431508086, 0.16305761139654373, 0.16305761139654373, 0.16305761139654373, 0.11772925903591058, 0.11772925903591058, 0.11772925903591058, 0.1511753895200162, 0.1511753895200162, 0.1511753895200162, 0.15925612319823645, 0.15925612319823645, 0.15925612319823645, 0.15303754415912896, 0.15303754415912896, 0.15303754415912896, 0.16877717534059067, 0.16877717534059067, 0.16877717534059067, 0.16415593456620503, 0.16415593456620503, 0.16415593456620503, 0.17836454271297097, 0.17836454271297097, 0.17836454271297097, 0.17168385164841982, 0.17168385164841982, 0.17168385164841982, 0.17710498059908986, 0.17710498059908986, 0.17710498059908986, 0.15835724475215907, 0.15835724475215907, 0.15835724475215907, 0.12191665328460255, 0.12191665328460255, 0.12191665328460255, 0.16686360972773218, 0.16686360972773218, 0.16686360972773218, 0.20567078113068693, 0.20567078113068693, 0.20567078113068693, 0.19890220808660097, 0.19890220808660097, 0.19890220808660097, 0.18213745838616868, 0.18213745838616868, 0.18213745838616868, 0.18103156408331122, 0.18103156408331122, 0.18103156408331122, 0.05822146360019487, 0.05822146360019487, 0.05822146360019487, 0.06635218326722747, 0.06635218326722747, 0.06635218326722747, 0.04450539944211396, 0.04450539944211396, 0.04450539944211396]}, "mutation_prompt": null}
{"id": "dc06466c-7bb3-4502-9d98-007328a02ab2", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.alpha = 0.5\n        self.gamma = 1.0\n        self.success_history = []\n        self.learning_rate = 0.01\n\n    def __call__(self, func):\n        np.random.seed(42)\n        budget_used = 0\n\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n                \n                # Dynamically adjust mutation factor based on fitness improvement\n                if len(self.success_history) > 1 and self.success_history[-1] > self.success_history[-2]:\n                    dynamic_mutation_factor *= 1.05\n                \n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(self.learning_rate * np.random.rand())\n                else:\n                    self.success_history.append(-self.learning_rate * np.random.rand())\n\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            population = new_population\n            \n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if np.std(fitness) < 1e-3:\n                self.population_size = max(10, self.population_size - 3)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Enhance exploitation by dynamically adjusting the mutation factor based on individual fitness trends to improve fine-tuning.", "configspace": "", "generation": 90, "fitness": 0.18204320372812946, "feedback": "The algorithm HybridDEFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.15.", "error": "", "parent_id": "942379f2-795a-4d2c-a9c9-ede1fe50a423", "metadata": {"aucs": [0.4140710567851852, 0.4140710567851852, 0.4140710567851852, 0.40883596060440097, 0.40883596060440097, 0.40883596060440097, 0.4328130826473804, 0.4328130826473804, 0.4328130826473804, 0.04489098782128642, 0.04489098782128642, 0.04489098782128642, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10211254910181256, 0.10211254910181256, 0.10211254910181256, 0.0792945833223142, 0.0792945833223142, 0.0792945833223142, 0.06612866295325037, 0.06612866295325037, 0.06612866295325037, 0.056836609109481295, 0.056836609109481295, 0.056836609109481295, 0.11296103617056708, 0.11296103617056708, 0.11296103617056708, 0.07924749688890564, 0.07924749688890564, 0.07924749688890564, 0.6882851716797704, 0.6882851716797704, 0.6882851716797704, 0.7786179174936882, 0.7786179174936882, 0.7786179174936882, 0.11293650522122733, 0.11293650522122733, 0.11293650522122733, 0.26728137393196816, 0.26728137393196816, 0.26728137393196816, 0.2885507353604181, 0.2885507353604181, 0.2885507353604181, 0.2767331987385344, 0.2767331987385344, 0.2767331987385344, 0.5027824026315881, 0.5027824026315881, 0.5027824026315881, 0.1929997343172103, 0.1929997343172103, 0.1929997343172103, 0.17212490319480767, 0.17212490319480767, 0.17212490319480767, 0.15373503092314333, 0.15373503092314333, 0.15373503092314333, 0.09513683753081292, 0.09513683753081292, 0.09513683753081292, 0.14908027614750863, 0.14908027614750863, 0.14908027614750863, 0.14551794323505596, 0.14551794323505596, 0.14551794323505596, 0.15642594154138734, 0.15642594154138734, 0.15642594154138734, 0.15249775357124928, 0.15249775357124928, 0.15249775357124928, 0.021205203470371248, 0.021205203470371248, 0.021205203470371248, 0.04270688773413911, 0.04270688773413911, 0.04270688773413911, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11009795964467661, 0.11009795964467661, 0.11009795964467661, 0.039040760470172575, 0.039040760470172575, 0.039040760470172575, 0.07337224661002306, 0.07337224661002306, 0.07337224661002306, 0.016598664505875216, 0.016598664505875216, 0.016598664505875216, 0.01885908656688151, 0.01885908656688151, 0.01885908656688151, 0.019232694537197337, 0.019232694537197337, 0.019232694537197337, 0.07898669591167495, 0.07898669591167495, 0.07898669591167495, 0.10421837582447169, 0.10421837582447169, 0.10421837582447169, 0.0658916029831016, 0.0658916029831016, 0.0658916029831016, 0.41143835771714343, 0.41143835771714343, 0.41143835771714343, 0.399014138441118, 0.399014138441118, 0.399014138441118, 0.40876363406862026, 0.40876363406862026, 0.40876363406862026, 0.08989454552306309, 0.08989454552306309, 0.08989454552306309, 0.11963998999658831, 0.11963998999658831, 0.11963998999658831, 0.12045262050810801, 0.12045262050810801, 0.12045262050810801, 0.1384379782114653, 0.1384379782114653, 0.1384379782114653, 0.15512122616322, 0.15512122616322, 0.15512122616322, 0.11805289810454911, 0.11805289810454911, 0.11805289810454911, 0.18425658258031385, 0.18425658258031385, 0.18425658258031385, 0.24757799067851993, 0.24757799067851993, 0.24757799067851993, 0.28025219829339043, 0.28025219829339043, 0.28025219829339043, 0.17265488878746305, 0.17265488878746305, 0.17265488878746305, 0.1537219024732991, 0.1537219024732991, 0.1537219024732991, 0.21065250468594365, 0.21065250468594365, 0.21065250468594365, 0.1991858480729074, 0.1991858480729074, 0.1991858480729074, 0.1720794493738964, 0.1720794493738964, 0.1720794493738964, 0.16956933574462452, 0.16956933574462452, 0.16956933574462452, 0.1640846443564804, 0.1640846443564804, 0.1640846443564804, 0.16931414261768152, 0.16931414261768152, 0.16931414261768152, 0.1768491311066115, 0.1768491311066115, 0.1768491311066115, 0.17270660227119383, 0.17270660227119383, 0.17270660227119383, 0.14334636259067557, 0.14334636259067557, 0.14334636259067557, 0.4877640876528353, 0.4877640876528353, 0.4877640876528353, 0.41462455831616907, 0.41462455831616907, 0.41462455831616907, 0.18765117231855433, 0.18765117231855433, 0.18765117231855433, 0.14749052343004865, 0.14749052343004865, 0.14749052343004865, 0.1810401487067641, 0.1810401487067641, 0.1810401487067641, 0.18674544897290069, 0.18674544897290069, 0.18674544897290069, 0.1821444288665981, 0.1821444288665981, 0.1821444288665981, 0.0680154256829012, 0.0680154256829012, 0.0680154256829012, 0.08281485724672, 0.08281485724672, 0.08281485724672, 0.07134511568341184, 0.07134511568341184, 0.07134511568341184]}, "mutation_prompt": null}
{"id": "868a7090-15a0-44fc-a28c-a800a05b8f41", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.alpha = 0.5\n        self.gamma = 1.0\n        self.success_history = []\n        self.learning_rate = 0.01\n\n    def __call__(self, func):\n        np.random.seed(42)\n        budget_used = 0\n\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(self.learning_rate * np.random.rand())\n                else:\n                    self.success_history.append(-self.learning_rate * np.random.rand())\n\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            population = new_population\n            \n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if np.std(fitness) < 1e-3:\n                self.population_size = max(10, self.population_size - 3)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Refine convergence by introducing stochastic adaptive learning rate to enhance global exploration and diversity.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "942379f2-795a-4d2c-a9c9-ede1fe50a423", "metadata": {"aucs": [0.4316324779008963, 0.4316324779008963, 0.4316324779008963, 0.4398310658013598, 0.4398310658013598, 0.4398310658013598, 0.474673678009655, 0.474673678009655, 0.474673678009655, 0.04456333248430622, 0.04456333248430622, 0.04456333248430622, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11822986331965624, 0.11822986331965624, 0.11822986331965624, 0.09164497827853324, 0.09164497827853324, 0.09164497827853324, 0.0908636064158167, 0.0908636064158167, 0.0908636064158167, 0.056211033215752826, 0.056211033215752826, 0.056211033215752826, 0.06963770071126196, 0.06963770071126196, 0.06963770071126196, 0.06267493469288687, 0.06267493469288687, 0.06267493469288687, 0.7914905691714824, 0.7914905691714824, 0.7914905691714824, 0.4641310908934111, 0.4641310908934111, 0.4641310908934111, 0.12063358030336657, 0.12063358030336657, 0.12063358030336657, 0.275038132570418, 0.275038132570418, 0.275038132570418, 0.25800275984318044, 0.25800275984318044, 0.25800275984318044, 0.2828331037421219, 0.2828331037421219, 0.2828331037421219, 0.546148739517615, 0.546148739517615, 0.546148739517615, 0.49315404315195943, 0.49315404315195943, 0.49315404315195943, 0.12092865580081091, 0.12092865580081091, 0.12092865580081091, 0.15657466284802435, 0.15657466284802435, 0.15657466284802435, 0.1804585139809013, 0.1804585139809013, 0.1804585139809013, 0.14432521485423855, 0.14432521485423855, 0.14432521485423855, 0.16024207820954994, 0.16024207820954994, 0.16024207820954994, 0.15013688245464196, 0.15013688245464196, 0.15013688245464196, 0.19907065109987732, 0.19907065109987732, 0.19907065109987732, 0.031729437177347775, 0.031729437177347775, 0.031729437177347775, 0.028998388520592222, 0.028998388520592222, 0.028998388520592222, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08362624935201035, 0.08362624935201035, 0.08362624935201035, 0.026425201363172723, 0.026425201363172723, 0.026425201363172723, 0.06519401048334916, 0.06519401048334916, 0.06519401048334916, 0.01433911361584106, 0.01433911361584106, 0.01433911361584106, 0.00769537993512881, 0.00769537993512881, 0.00769537993512881, 0.010672672204237843, 0.010672672204237843, 0.010672672204237843, 0.059988656179477906, 0.059988656179477906, 0.059988656179477906, 0.0719538127449929, 0.0719538127449929, 0.0719538127449929, 0.12445086477063416, 0.12445086477063416, 0.12445086477063416, 0.4300796449516281, 0.4300796449516281, 0.4300796449516281, 0.41390419414102964, 0.41390419414102964, 0.41390419414102964, 0.4006953206652003, 0.4006953206652003, 0.4006953206652003, 0.08439171442247262, 0.08439171442247262, 0.08439171442247262, 0.10349533107671194, 0.10349533107671194, 0.10349533107671194, 0.0966051784144325, 0.0966051784144325, 0.0966051784144325, 0.1821114128508161, 0.1821114128508161, 0.1821114128508161, 0.13169165430578655, 0.13169165430578655, 0.13169165430578655, 0.12619252740933895, 0.12619252740933895, 0.12619252740933895, 0.1900519975436027, 0.1900519975436027, 0.1900519975436027, 0.2768870409019287, 0.2768870409019287, 0.2768870409019287, 0.2502306362202801, 0.2502306362202801, 0.2502306362202801, 0.1626236108685689, 0.1626236108685689, 0.1626236108685689, 0.19966827225050665, 0.19966827225050665, 0.19966827225050665, 0.1513681333485729, 0.1513681333485729, 0.1513681333485729, 0.19446153617568185, 0.19446153617568185, 0.19446153617568185, 0.21986928713464082, 0.21986928713464082, 0.21986928713464082, 0.18059021773131412, 0.18059021773131412, 0.18059021773131412, 0.1666662635160162, 0.1666662635160162, 0.1666662635160162, 0.1879675952038391, 0.1879675952038391, 0.1879675952038391, 0.16564311194612635, 0.16564311194612635, 0.16564311194612635, 0.5901935543397198, 0.5901935543397198, 0.5901935543397198, 0.15138270376521756, 0.15138270376521756, 0.15138270376521756, 0.47012941168044886, 0.47012941168044886, 0.47012941168044886, 0.279290080562398, 0.279290080562398, 0.279290080562398, 0.363666351089849, 0.363666351089849, 0.363666351089849, 0.14576118837238505, 0.14576118837238505, 0.14576118837238505, 0.19347004645180377, 0.19347004645180377, 0.19347004645180377, 0.18188146747909306, 0.18188146747909306, 0.18188146747909306, 0.18945171911003622, 0.18945171911003622, 0.18945171911003622, 0.06473514223413601, 0.06473514223413601, 0.06473514223413601, 0.0623151630178439, 0.0623151630178439, 0.0623151630178439, 0.06875705295777046, 0.06875705295777046, 0.06875705295777046]}, "mutation_prompt": null}
{"id": "68d31e0d-f14c-4f9b-b0d5-af672a8388a1", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.alpha = 0.5\n        self.gamma = 1.0\n        self.success_history = []\n        self.learning_rate = 0.01\n\n    def __call__(self, func):\n        np.random.seed(42)\n        budget_used = 0\n\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(self.learning_rate * np.random.rand())\n                else:\n                    self.success_history.append(-self.learning_rate * np.random.rand())\n\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + (adaptive_alpha * np.var(self.success_history)) * (np.random.rand(self.dim) - 0.5)\n\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            population = new_population\n            \n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if np.std(fitness) < 1e-3:\n                self.population_size = max(10, self.population_size - 3)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Enhance exploitation in local search by dynamically adjusting learning rate based on success history variance.", "configspace": "", "generation": 92, "fitness": 0.0998692115398061, "feedback": "The algorithm HybridDEFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.07.", "error": "", "parent_id": "942379f2-795a-4d2c-a9c9-ede1fe50a423", "metadata": {"aucs": [0.22356950253567898, 0.22356950253567898, 0.22356950253567898, 0.12720023077926979, 0.12720023077926979, 0.12720023077926979, 0.21659964708574042, 0.21659964708574042, 0.21659964708574042, 0.03926800559560639, 0.03926800559560639, 0.03926800559560639, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10276578908167211, 0.10276578908167211, 0.10276578908167211, 0.04132068474306161, 0.04132068474306161, 0.04132068474306161, 0.06000191695988377, 0.06000191695988377, 0.06000191695988377, 0.0405265470696089, 0.0405265470696089, 0.0405265470696089, 0.061878742211480486, 0.061878742211480486, 0.061878742211480486, 0.025737555569883774, 0.025737555569883774, 0.025737555569883774, 0.06359470994636818, 0.06359470994636818, 0.06359470994636818, 0.11384338545937467, 0.11384338545937467, 0.11384338545937467, 0.08489797270192734, 0.08489797270192734, 0.08489797270192734, 0.08948716317519301, 0.08948716317519301, 0.08948716317519301, 0.0464979818479605, 0.0464979818479605, 0.0464979818479605, 0.0272343619246751, 0.0272343619246751, 0.0272343619246751, 0.18171973592223345, 0.18171973592223345, 0.18171973592223345, 0.15747415355840544, 0.15747415355840544, 0.15747415355840544, 0.08332904462168222, 0.08332904462168222, 0.08332904462168222, 0.013144984763486023, 0.013144984763486023, 0.013144984763486023, 0.09218057742270869, 0.09218057742270869, 0.09218057742270869, 0.11401870074581455, 0.11401870074581455, 0.11401870074581455, 0.06182018727776051, 0.06182018727776051, 0.06182018727776051, 0.004953159092958459, 0.004953159092958459, 0.004953159092958459, 0.07595897393490636, 0.07595897393490636, 0.07595897393490636, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06924249416846906, 0.06924249416846906, 0.06924249416846906, 0.057388440866759094, 0.057388440866759094, 0.057388440866759094, 0.17831443899475963, 0.17831443899475963, 0.17831443899475963, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.018976665737946652, 0.018976665737946652, 0.018976665737946652, 0.05892508598753288, 0.05892508598753288, 0.05892508598753288, 0.28991665518926335, 0.28991665518926335, 0.28991665518926335, 0.25063069903991786, 0.25063069903991786, 0.25063069903991786, 0.16789516716927988, 0.16789516716927988, 0.16789516716927988, 0.06057274999346807, 0.06057274999346807, 0.06057274999346807, 0.06304764566064402, 0.06304764566064402, 0.06304764566064402, 0.07284031500469901, 0.07284031500469901, 0.07284031500469901, 0.09724814280301419, 0.09724814280301419, 0.09724814280301419, 0.1088319668277431, 0.1088319668277431, 0.1088319668277431, 0.09880331320019209, 0.09880331320019209, 0.09880331320019209, 0.1606632569748112, 0.1606632569748112, 0.1606632569748112, 0.20229988140804767, 0.20229988140804767, 0.20229988140804767, 0.1701528901544478, 0.1701528901544478, 0.1701528901544478, 0.10196438251325868, 0.10196438251325868, 0.10196438251325868, 0.1156875869951457, 0.1156875869951457, 0.1156875869951457, 0.11139886721635917, 0.11139886721635917, 0.11139886721635917, 0.17435832883375857, 0.17435832883375857, 0.17435832883375857, 0.15397480653089046, 0.15397480653089046, 0.15397480653089046, 0.20894974414913192, 0.20894974414913192, 0.20894974414913192, 0.15612547396628595, 0.15612547396628595, 0.15612547396628595, 0.15679431489454276, 0.15679431489454276, 0.15679431489454276, 0.1603718721578844, 0.1603718721578844, 0.1603718721578844, 0.1543354233725075, 0.1543354233725075, 0.1543354233725075, 0.11537537176202417, 0.11537537176202417, 0.11537537176202417, 0.11577933377467564, 0.11577933377467564, 0.11577933377467564, 0.2773675161793987, 0.2773675161793987, 0.2773675161793987, 0.12309173596089462, 0.12309173596089462, 0.12309173596089462, 0.11771111209419272, 0.11771111209419272, 0.11771111209419272, 0.16234724354877328, 0.16234724354877328, 0.16234724354877328, 0.1787417060701877, 0.1787417060701877, 0.1787417060701877, 0.15666802793667645, 0.15666802793667645, 0.15666802793667645, 0.052163945954712077, 0.052163945954712077, 0.052163945954712077, 0.06801185786192598, 0.06801185786192598, 0.06801185786192598, 0.05369105588447687, 0.05369105588447687, 0.05369105588447687]}, "mutation_prompt": null}
{"id": "7a387146-ac26-40b6-a973-e01a31749030", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.alpha = 0.5\n        self.gamma = 1.0\n        self.success_history = []\n        self.learning_rate = 0.01\n\n    def __call__(self, func):\n        np.random.seed(42)\n        budget_used = 0\n\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(self.learning_rate * np.random.rand())\n                else:\n                    self.success_history.append(-self.learning_rate * np.random.rand())\n\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            population = new_population\n            \n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if np.std(fitness) < 1e-3:\n                self.population_size = max(10, self.population_size - 3)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Refine convergence by introducing stochastic adaptive learning rate to enhance global exploration and diversity.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "942379f2-795a-4d2c-a9c9-ede1fe50a423", "metadata": {"aucs": [0.4316324779008963, 0.4316324779008963, 0.4316324779008963, 0.4398310658013598, 0.4398310658013598, 0.4398310658013598, 0.474673678009655, 0.474673678009655, 0.474673678009655, 0.04456333248430622, 0.04456333248430622, 0.04456333248430622, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11822986331965624, 0.11822986331965624, 0.11822986331965624, 0.09164497827853324, 0.09164497827853324, 0.09164497827853324, 0.0908636064158167, 0.0908636064158167, 0.0908636064158167, 0.056211033215752826, 0.056211033215752826, 0.056211033215752826, 0.06963770071126196, 0.06963770071126196, 0.06963770071126196, 0.06267493469288687, 0.06267493469288687, 0.06267493469288687, 0.7914905691714824, 0.7914905691714824, 0.7914905691714824, 0.4641310908934111, 0.4641310908934111, 0.4641310908934111, 0.12063358030336657, 0.12063358030336657, 0.12063358030336657, 0.275038132570418, 0.275038132570418, 0.275038132570418, 0.25800275984318044, 0.25800275984318044, 0.25800275984318044, 0.2828331037421219, 0.2828331037421219, 0.2828331037421219, 0.546148739517615, 0.546148739517615, 0.546148739517615, 0.49315404315195943, 0.49315404315195943, 0.49315404315195943, 0.12092865580081091, 0.12092865580081091, 0.12092865580081091, 0.15657466284802435, 0.15657466284802435, 0.15657466284802435, 0.1804585139809013, 0.1804585139809013, 0.1804585139809013, 0.14432521485423855, 0.14432521485423855, 0.14432521485423855, 0.16024207820954994, 0.16024207820954994, 0.16024207820954994, 0.15013688245464196, 0.15013688245464196, 0.15013688245464196, 0.19907065109987732, 0.19907065109987732, 0.19907065109987732, 0.031729437177347775, 0.031729437177347775, 0.031729437177347775, 0.028998388520592222, 0.028998388520592222, 0.028998388520592222, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08362624935201035, 0.08362624935201035, 0.08362624935201035, 0.026425201363172723, 0.026425201363172723, 0.026425201363172723, 0.06519401048334916, 0.06519401048334916, 0.06519401048334916, 0.01433911361584106, 0.01433911361584106, 0.01433911361584106, 0.00769537993512881, 0.00769537993512881, 0.00769537993512881, 0.010672672204237843, 0.010672672204237843, 0.010672672204237843, 0.059988656179477906, 0.059988656179477906, 0.059988656179477906, 0.0719538127449929, 0.0719538127449929, 0.0719538127449929, 0.12445086477063416, 0.12445086477063416, 0.12445086477063416, 0.4300796449516281, 0.4300796449516281, 0.4300796449516281, 0.41390419414102964, 0.41390419414102964, 0.41390419414102964, 0.4006953206652003, 0.4006953206652003, 0.4006953206652003, 0.08439171442247262, 0.08439171442247262, 0.08439171442247262, 0.10349533107671194, 0.10349533107671194, 0.10349533107671194, 0.0966051784144325, 0.0966051784144325, 0.0966051784144325, 0.1821114128508161, 0.1821114128508161, 0.1821114128508161, 0.13169165430578655, 0.13169165430578655, 0.13169165430578655, 0.12619252740933895, 0.12619252740933895, 0.12619252740933895, 0.1900519975436027, 0.1900519975436027, 0.1900519975436027, 0.2768870409019287, 0.2768870409019287, 0.2768870409019287, 0.2502306362202801, 0.2502306362202801, 0.2502306362202801, 0.1626236108685689, 0.1626236108685689, 0.1626236108685689, 0.19966827225050665, 0.19966827225050665, 0.19966827225050665, 0.1513681333485729, 0.1513681333485729, 0.1513681333485729, 0.19446153617568185, 0.19446153617568185, 0.19446153617568185, 0.21986928713464082, 0.21986928713464082, 0.21986928713464082, 0.18059021773131412, 0.18059021773131412, 0.18059021773131412, 0.1666662635160162, 0.1666662635160162, 0.1666662635160162, 0.1879675952038391, 0.1879675952038391, 0.1879675952038391, 0.16564311194612635, 0.16564311194612635, 0.16564311194612635, 0.5901935543397198, 0.5901935543397198, 0.5901935543397198, 0.15138270376521756, 0.15138270376521756, 0.15138270376521756, 0.47012941168044886, 0.47012941168044886, 0.47012941168044886, 0.279290080562398, 0.279290080562398, 0.279290080562398, 0.363666351089849, 0.363666351089849, 0.363666351089849, 0.14576118837238505, 0.14576118837238505, 0.14576118837238505, 0.19347004645180377, 0.19347004645180377, 0.19347004645180377, 0.18188146747909306, 0.18188146747909306, 0.18188146747909306, 0.18945171911003622, 0.18945171911003622, 0.18945171911003622, 0.06473514223413601, 0.06473514223413601, 0.06473514223413601, 0.0623151630178439, 0.0623151630178439, 0.0623151630178439, 0.06875705295777046, 0.06875705295777046, 0.06875705295777046]}, "mutation_prompt": null}
{"id": "e1b99ec0-7a77-4974-a4f9-656b6325b1f0", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.alpha = 0.5\n        self.gamma = 1.0\n        self.success_history = []\n        self.learning_rate = 0.01\n\n    def __call__(self, func):\n        np.random.seed(42)\n        budget_used = 0\n\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(self.learning_rate * np.random.rand())\n                else:\n                    self.success_history.append(-self.learning_rate * np.random.rand())\n\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n                        \n                        # Introduce neighborhood-based perturbation\n                        perturbation = np.random.normal(0, adaptive_alpha, self.dim)\n                        new_population[i] += perturbation\n\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            population = new_population\n            \n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if np.std(fitness) < 1e-3:\n                self.population_size = max(10, self.population_size - 3)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Introduce neighborhood-based perturbation to enhance local search exploitation and convergence speed.", "configspace": "", "generation": 94, "fitness": 0.15618545924377825, "feedback": "The algorithm HybridDEFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.15.", "error": "", "parent_id": "942379f2-795a-4d2c-a9c9-ede1fe50a423", "metadata": {"aucs": [0.31753301183784277, 0.31753301183784277, 0.31753301183784277, 0.3319476309511308, 0.3319476309511308, 0.3319476309511308, 0.3232124827927695, 0.3232124827927695, 0.3232124827927695, 0.005460426641192173, 0.005460426641192173, 0.005460426641192173, 0.003468932672017533, 0.003468932672017533, 0.003468932672017533, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0665097322570507, 0.0665097322570507, 0.0665097322570507, 0.07858917216795147, 0.07858917216795147, 0.07858917216795147, 0.06681384082695441, 0.06681384082695441, 0.06681384082695441, 0.05738440137717804, 0.05738440137717804, 0.05738440137717804, 0.05993461375118658, 0.05993461375118658, 0.05993461375118658, 0.056066812131044585, 0.056066812131044585, 0.056066812131044585, 0.6581512476704394, 0.6581512476704394, 0.6581512476704394, 0.5852166767343139, 0.5852166767343139, 0.5852166767343139, 0.8703643713069524, 0.8703643713069524, 0.8703643713069524, 0.18975844542343667, 0.18975844542343667, 0.18975844542343667, 0.16874348101986647, 0.16874348101986647, 0.16874348101986647, 0.12076131978808302, 0.12076131978808302, 0.12076131978808302, 0.2797499285552866, 0.2797499285552866, 0.2797499285552866, 0.19803523933754685, 0.19803523933754685, 0.19803523933754685, 0.14270629680987423, 0.14270629680987423, 0.14270629680987423, 0.06976617311139466, 0.06976617311139466, 0.06976617311139466, 0.055998751751753506, 0.055998751751753506, 0.055998751751753506, 0.07972170543346435, 0.07972170543346435, 0.07972170543346435, 0.07939156811025694, 0.07939156811025694, 0.07939156811025694, 0.0899615171820467, 0.0899615171820467, 0.0899615171820467, 0.02622006277010258, 0.02622006277010258, 0.02622006277010258, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004879042924540999, 0.004879042924540999, 0.004879042924540999, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05794322131897789, 0.05794322131897789, 0.05794322131897789, 0.046032102819479226, 0.046032102819479226, 0.046032102819479226, 0.06300341410083388, 0.06300341410083388, 0.06300341410083388, 0.0007816454176902132, 0.0007816454176902132, 0.0007816454176902132, 0.0021896746460633443, 0.0021896746460633443, 0.0021896746460633443, 0.0021234282505624424, 0.0021234282505624424, 0.0021234282505624424, 0.03469504777588028, 0.03469504777588028, 0.03469504777588028, 0.049208631501681754, 0.049208631501681754, 0.049208631501681754, 0.036306114742708395, 0.036306114742708395, 0.036306114742708395, 0.3193565624449729, 0.3193565624449729, 0.3193565624449729, 0.2993376184355484, 0.2993376184355484, 0.2993376184355484, 0.29409125797670577, 0.29409125797670577, 0.29409125797670577, 0.0722688828167164, 0.0722688828167164, 0.0722688828167164, 0.06678203271605976, 0.06678203271605976, 0.06678203271605976, 0.052914828934433555, 0.052914828934433555, 0.052914828934433555, 0.14280424667357927, 0.14280424667357927, 0.14280424667357927, 0.1501353101389532, 0.1501353101389532, 0.1501353101389532, 0.1788289515104743, 0.1788289515104743, 0.1788289515104743, 0.2231645630633453, 0.2231645630633453, 0.2231645630633453, 0.215782155308752, 0.215782155308752, 0.215782155308752, 0.23339985503728256, 0.23339985503728256, 0.23339985503728256, 0.17646763511714436, 0.17646763511714436, 0.17646763511714436, 0.16112473268554717, 0.16112473268554717, 0.16112473268554717, 0.14621480905947226, 0.14621480905947226, 0.14621480905947226, 0.1707216184573599, 0.1707216184573599, 0.1707216184573599, 0.1545394978773782, 0.1545394978773782, 0.1545394978773782, 0.15336253177371395, 0.15336253177371395, 0.15336253177371395, 0.14663182451705048, 0.14663182451705048, 0.14663182451705048, 0.14692669338994657, 0.14692669338994657, 0.14692669338994657, 0.15149622838416477, 0.15149622838416477, 0.15149622838416477, 0.374582191679797, 0.374582191679797, 0.374582191679797, 0.2928928717914434, 0.2928928717914434, 0.2928928717914434, 0.36189270762132786, 0.36189270762132786, 0.36189270762132786, 0.18345322678292875, 0.18345322678292875, 0.18345322678292875, 0.2242641397877576, 0.2242641397877576, 0.2242641397877576, 0.12708158982641893, 0.12708158982641893, 0.12708158982641893, 0.18275592161507648, 0.18275592161507648, 0.18275592161507648, 0.18021301018121538, 0.18021301018121538, 0.18021301018121538, 0.17779600000359097, 0.17779600000359097, 0.17779600000359097, 0.06513407173365171, 0.06513407173365171, 0.06513407173365171, 0.07220616899124344, 0.07220616899124344, 0.07220616899124344, 0.06779916330942504, 0.06779916330942504, 0.06779916330942504]}, "mutation_prompt": null}
{"id": "a55ecbdb-914d-4534-8416-d5a25b9245dd", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.alpha = 0.5\n        self.gamma = 1.0\n        self.success_history = []\n        self.learning_rate = 0.01\n\n    def __call__(self, func):\n        np.random.seed(42)\n        budget_used = 0\n\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(self.learning_rate * np.random.rand())\n                else:\n                    self.success_history.append(-self.learning_rate * np.random.rand())\n\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            population = new_population\n            \n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if np.std(fitness) < 1e-3:\n                self.population_size = max(10, self.population_size - 3)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Refine convergence by introducing stochastic adaptive learning rate to enhance global exploration and diversity.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "942379f2-795a-4d2c-a9c9-ede1fe50a423", "metadata": {"aucs": [0.4316324779008963, 0.4316324779008963, 0.4316324779008963, 0.4398310658013598, 0.4398310658013598, 0.4398310658013598, 0.474673678009655, 0.474673678009655, 0.474673678009655, 0.04456333248430622, 0.04456333248430622, 0.04456333248430622, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11822986331965624, 0.11822986331965624, 0.11822986331965624, 0.09164497827853324, 0.09164497827853324, 0.09164497827853324, 0.0908636064158167, 0.0908636064158167, 0.0908636064158167, 0.056211033215752826, 0.056211033215752826, 0.056211033215752826, 0.06963770071126196, 0.06963770071126196, 0.06963770071126196, 0.06267493469288687, 0.06267493469288687, 0.06267493469288687, 0.7914905691714824, 0.7914905691714824, 0.7914905691714824, 0.4641310908934111, 0.4641310908934111, 0.4641310908934111, 0.12063358030336657, 0.12063358030336657, 0.12063358030336657, 0.275038132570418, 0.275038132570418, 0.275038132570418, 0.25800275984318044, 0.25800275984318044, 0.25800275984318044, 0.2828331037421219, 0.2828331037421219, 0.2828331037421219, 0.546148739517615, 0.546148739517615, 0.546148739517615, 0.49315404315195943, 0.49315404315195943, 0.49315404315195943, 0.12092865580081091, 0.12092865580081091, 0.12092865580081091, 0.15657466284802435, 0.15657466284802435, 0.15657466284802435, 0.1804585139809013, 0.1804585139809013, 0.1804585139809013, 0.14432521485423855, 0.14432521485423855, 0.14432521485423855, 0.16024207820954994, 0.16024207820954994, 0.16024207820954994, 0.15013688245464196, 0.15013688245464196, 0.15013688245464196, 0.19907065109987732, 0.19907065109987732, 0.19907065109987732, 0.031729437177347775, 0.031729437177347775, 0.031729437177347775, 0.028998388520592222, 0.028998388520592222, 0.028998388520592222, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08362624935201035, 0.08362624935201035, 0.08362624935201035, 0.026425201363172723, 0.026425201363172723, 0.026425201363172723, 0.06519401048334916, 0.06519401048334916, 0.06519401048334916, 0.01433911361584106, 0.01433911361584106, 0.01433911361584106, 0.00769537993512881, 0.00769537993512881, 0.00769537993512881, 0.010672672204237843, 0.010672672204237843, 0.010672672204237843, 0.059988656179477906, 0.059988656179477906, 0.059988656179477906, 0.0719538127449929, 0.0719538127449929, 0.0719538127449929, 0.12445086477063416, 0.12445086477063416, 0.12445086477063416, 0.4300796449516281, 0.4300796449516281, 0.4300796449516281, 0.41390419414102964, 0.41390419414102964, 0.41390419414102964, 0.4006953206652003, 0.4006953206652003, 0.4006953206652003, 0.08439171442247262, 0.08439171442247262, 0.08439171442247262, 0.10349533107671194, 0.10349533107671194, 0.10349533107671194, 0.0966051784144325, 0.0966051784144325, 0.0966051784144325, 0.1821114128508161, 0.1821114128508161, 0.1821114128508161, 0.13169165430578655, 0.13169165430578655, 0.13169165430578655, 0.12619252740933895, 0.12619252740933895, 0.12619252740933895, 0.1900519975436027, 0.1900519975436027, 0.1900519975436027, 0.2768870409019287, 0.2768870409019287, 0.2768870409019287, 0.2502306362202801, 0.2502306362202801, 0.2502306362202801, 0.1626236108685689, 0.1626236108685689, 0.1626236108685689, 0.19966827225050665, 0.19966827225050665, 0.19966827225050665, 0.1513681333485729, 0.1513681333485729, 0.1513681333485729, 0.19446153617568185, 0.19446153617568185, 0.19446153617568185, 0.21986928713464082, 0.21986928713464082, 0.21986928713464082, 0.18059021773131412, 0.18059021773131412, 0.18059021773131412, 0.1666662635160162, 0.1666662635160162, 0.1666662635160162, 0.1879675952038391, 0.1879675952038391, 0.1879675952038391, 0.16564311194612635, 0.16564311194612635, 0.16564311194612635, 0.5901935543397198, 0.5901935543397198, 0.5901935543397198, 0.15138270376521756, 0.15138270376521756, 0.15138270376521756, 0.47012941168044886, 0.47012941168044886, 0.47012941168044886, 0.279290080562398, 0.279290080562398, 0.279290080562398, 0.363666351089849, 0.363666351089849, 0.363666351089849, 0.14576118837238505, 0.14576118837238505, 0.14576118837238505, 0.19347004645180377, 0.19347004645180377, 0.19347004645180377, 0.18188146747909306, 0.18188146747909306, 0.18188146747909306, 0.18945171911003622, 0.18945171911003622, 0.18945171911003622, 0.06473514223413601, 0.06473514223413601, 0.06473514223413601, 0.0623151630178439, 0.0623151630178439, 0.0623151630178439, 0.06875705295777046, 0.06875705295777046, 0.06875705295777046]}, "mutation_prompt": null}
{"id": "5cd71bba-13d9-46dd-82ec-52192adfa3a8", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.alpha = 0.5\n        self.gamma = 1.0\n        self.success_history = []\n        self.learning_rate = 0.01\n\n    def __call__(self, func):\n        np.random.seed(42)\n        budget_used = 0\n\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(self.learning_rate * np.random.rand())\n                else:\n                    self.success_history.append(-self.learning_rate * np.random.rand())\n\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            population = new_population\n            \n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if np.std(fitness) < 1e-3:\n                self.population_size = max(10, self.population_size - 3)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Refine convergence by introducing stochastic adaptive learning rate to enhance global exploration and diversity.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "942379f2-795a-4d2c-a9c9-ede1fe50a423", "metadata": {"aucs": [0.4316324779008963, 0.4316324779008963, 0.4316324779008963, 0.4398310658013598, 0.4398310658013598, 0.4398310658013598, 0.474673678009655, 0.474673678009655, 0.474673678009655, 0.04456333248430622, 0.04456333248430622, 0.04456333248430622, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11822986331965624, 0.11822986331965624, 0.11822986331965624, 0.09164497827853324, 0.09164497827853324, 0.09164497827853324, 0.0908636064158167, 0.0908636064158167, 0.0908636064158167, 0.056211033215752826, 0.056211033215752826, 0.056211033215752826, 0.06963770071126196, 0.06963770071126196, 0.06963770071126196, 0.06267493469288687, 0.06267493469288687, 0.06267493469288687, 0.7914905691714824, 0.7914905691714824, 0.7914905691714824, 0.4641310908934111, 0.4641310908934111, 0.4641310908934111, 0.12063358030336657, 0.12063358030336657, 0.12063358030336657, 0.275038132570418, 0.275038132570418, 0.275038132570418, 0.25800275984318044, 0.25800275984318044, 0.25800275984318044, 0.2828331037421219, 0.2828331037421219, 0.2828331037421219, 0.546148739517615, 0.546148739517615, 0.546148739517615, 0.49315404315195943, 0.49315404315195943, 0.49315404315195943, 0.12092865580081091, 0.12092865580081091, 0.12092865580081091, 0.15657466284802435, 0.15657466284802435, 0.15657466284802435, 0.1804585139809013, 0.1804585139809013, 0.1804585139809013, 0.14432521485423855, 0.14432521485423855, 0.14432521485423855, 0.16024207820954994, 0.16024207820954994, 0.16024207820954994, 0.15013688245464196, 0.15013688245464196, 0.15013688245464196, 0.19907065109987732, 0.19907065109987732, 0.19907065109987732, 0.031729437177347775, 0.031729437177347775, 0.031729437177347775, 0.028998388520592222, 0.028998388520592222, 0.028998388520592222, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08362624935201035, 0.08362624935201035, 0.08362624935201035, 0.026425201363172723, 0.026425201363172723, 0.026425201363172723, 0.06519401048334916, 0.06519401048334916, 0.06519401048334916, 0.01433911361584106, 0.01433911361584106, 0.01433911361584106, 0.00769537993512881, 0.00769537993512881, 0.00769537993512881, 0.010672672204237843, 0.010672672204237843, 0.010672672204237843, 0.059988656179477906, 0.059988656179477906, 0.059988656179477906, 0.0719538127449929, 0.0719538127449929, 0.0719538127449929, 0.12445086477063416, 0.12445086477063416, 0.12445086477063416, 0.4300796449516281, 0.4300796449516281, 0.4300796449516281, 0.41390419414102964, 0.41390419414102964, 0.41390419414102964, 0.4006953206652003, 0.4006953206652003, 0.4006953206652003, 0.08439171442247262, 0.08439171442247262, 0.08439171442247262, 0.10349533107671194, 0.10349533107671194, 0.10349533107671194, 0.0966051784144325, 0.0966051784144325, 0.0966051784144325, 0.1821114128508161, 0.1821114128508161, 0.1821114128508161, 0.13169165430578655, 0.13169165430578655, 0.13169165430578655, 0.12619252740933895, 0.12619252740933895, 0.12619252740933895, 0.1900519975436027, 0.1900519975436027, 0.1900519975436027, 0.2768870409019287, 0.2768870409019287, 0.2768870409019287, 0.2502306362202801, 0.2502306362202801, 0.2502306362202801, 0.1626236108685689, 0.1626236108685689, 0.1626236108685689, 0.19966827225050665, 0.19966827225050665, 0.19966827225050665, 0.1513681333485729, 0.1513681333485729, 0.1513681333485729, 0.19446153617568185, 0.19446153617568185, 0.19446153617568185, 0.21986928713464082, 0.21986928713464082, 0.21986928713464082, 0.18059021773131412, 0.18059021773131412, 0.18059021773131412, 0.1666662635160162, 0.1666662635160162, 0.1666662635160162, 0.1879675952038391, 0.1879675952038391, 0.1879675952038391, 0.16564311194612635, 0.16564311194612635, 0.16564311194612635, 0.5901935543397198, 0.5901935543397198, 0.5901935543397198, 0.15138270376521756, 0.15138270376521756, 0.15138270376521756, 0.47012941168044886, 0.47012941168044886, 0.47012941168044886, 0.279290080562398, 0.279290080562398, 0.279290080562398, 0.363666351089849, 0.363666351089849, 0.363666351089849, 0.14576118837238505, 0.14576118837238505, 0.14576118837238505, 0.19347004645180377, 0.19347004645180377, 0.19347004645180377, 0.18188146747909306, 0.18188146747909306, 0.18188146747909306, 0.18945171911003622, 0.18945171911003622, 0.18945171911003622, 0.06473514223413601, 0.06473514223413601, 0.06473514223413601, 0.0623151630178439, 0.0623151630178439, 0.0623151630178439, 0.06875705295777046, 0.06875705295777046, 0.06875705295777046]}, "mutation_prompt": null}
{"id": "a53ad1dc-5858-4817-9597-f8b5f20f0b05", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.alpha = 0.5\n        self.gamma = 1.0\n        self.success_history = []\n        self.learning_rate = 0.01\n\n    def __call__(self, func):\n        np.random.seed(42)\n        budget_used = 0\n\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                diversity = np.std(population)\n                dynamic_mutation_factor = self.mutation_factor * (1 + diversity) * (1 - (budget_used / self.budget))\n                if self.success_history:\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(self.learning_rate * np.random.rand())\n                else:\n                    self.success_history.append(-self.learning_rate * np.random.rand())\n\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            population = new_population\n            \n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if np.std(fitness) < 1e-3:\n                self.population_size = max(10, self.population_size - 3)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Refine convergence by incorporating dynamic control of the mutation factor based on population diversity to boost exploration when needed.", "configspace": "", "generation": 97, "fitness": 0.14119444038910964, "feedback": "The algorithm HybridDEFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.17.", "error": "", "parent_id": "942379f2-795a-4d2c-a9c9-ede1fe50a423", "metadata": {"aucs": [0.25639839656618835, 0.25639839656618835, 0.25639839656618835, 0.31620531572947175, 0.31620531572947175, 0.31620531572947175, 0.36206124949257934, 0.36206124949257934, 0.36206124949257934, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09092035171809076, 0.09092035171809076, 0.09092035171809076, 0.0433916946864652, 0.0433916946864652, 0.0433916946864652, 0.03349911577518272, 0.03349911577518272, 0.03349911577518272, 0.02208888422662092, 0.02208888422662092, 0.02208888422662092, 0.028330332266415237, 0.028330332266415237, 0.028330332266415237, 0.014328648838566327, 0.014328648838566327, 0.014328648838566327, 0.7354311817257171, 0.7354311817257171, 0.7354311817257171, 0.9389600826736665, 0.9389600826736665, 0.9389600826736665, 0.8549055196111022, 0.8549055196111022, 0.8549055196111022, 0.2013836867930361, 0.2013836867930361, 0.2013836867930361, 0.1375163062145277, 0.1375163062145277, 0.1375163062145277, 0.18501604230087187, 0.18501604230087187, 0.18501604230087187, 0.1258582999700789, 0.1258582999700789, 0.1258582999700789, 0.13398913669769885, 0.13398913669769885, 0.13398913669769885, 0.14596461663627558, 0.14596461663627558, 0.14596461663627558, 0.052188848397441534, 0.052188848397441534, 0.052188848397441534, 0.06328122403334824, 0.06328122403334824, 0.06328122403334824, 0.053141958900081554, 0.053141958900081554, 0.053141958900081554, 0.10169181058946719, 0.10169181058946719, 0.10169181058946719, 0.07052779156721078, 0.07052779156721078, 0.07052779156721078, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05630116178914413, 0.05630116178914413, 0.05630116178914413, 0.019370686086121025, 0.019370686086121025, 0.019370686086121025, 0.026387637045199752, 0.026387637045199752, 0.026387637045199752, 0.002157604155794579, 0.002157604155794579, 0.002157604155794579, 0.005821457691915555, 0.005821457691915555, 0.005821457691915555, 0.00955105900489528, 0.00955105900489528, 0.00955105900489528, 0.03191705893723995, 0.03191705893723995, 0.03191705893723995, 0.04751272268538009, 0.04751272268538009, 0.04751272268538009, 0.06555836873483734, 0.06555836873483734, 0.06555836873483734, 0.32147426056845896, 0.32147426056845896, 0.32147426056845896, 0.2921956144803993, 0.2921956144803993, 0.2921956144803993, 0.30277338029916023, 0.30277338029916023, 0.30277338029916023, 0.06325576934858002, 0.06325576934858002, 0.06325576934858002, 0.048397727349157704, 0.048397727349157704, 0.048397727349157704, 0.05957701797394588, 0.05957701797394588, 0.05957701797394588, 0.12216506989107734, 0.12216506989107734, 0.12216506989107734, 0.14523037516110016, 0.14523037516110016, 0.14523037516110016, 0.14173968714956864, 0.14173968714956864, 0.14173968714956864, 0.16018513680204072, 0.16018513680204072, 0.16018513680204072, 0.16438424174993527, 0.16438424174993527, 0.16438424174993527, 0.1739449573588836, 0.1739449573588836, 0.1739449573588836, 0.0949880322754647, 0.0949880322754647, 0.0949880322754647, 0.12047723704804503, 0.12047723704804503, 0.12047723704804503, 0.13164336638278762, 0.13164336638278762, 0.13164336638278762, 0.15325101594455537, 0.15325101594455537, 0.15325101594455537, 0.14061762952275536, 0.14061762952275536, 0.14061762952275536, 0.1432643027864282, 0.1432643027864282, 0.1432643027864282, 0.12016081201705242, 0.12016081201705242, 0.12016081201705242, 0.09002464597261184, 0.09002464597261184, 0.09002464597261184, 0.104830977891194, 0.104830977891194, 0.104830977891194, 0.4438454510375439, 0.4438454510375439, 0.4438454510375439, 0.1751084391647555, 0.1751084391647555, 0.1751084391647555, 0.1376095333829297, 0.1376095333829297, 0.1376095333829297, 0.14098952059619752, 0.14098952059619752, 0.14098952059619752, 0.1162514150796824, 0.1162514150796824, 0.1162514150796824, 0.14712648675250017, 0.14712648675250017, 0.14712648675250017, 0.17617478834393674, 0.17617478834393674, 0.17617478834393674, 0.1871062214188789, 0.1871062214188789, 0.1871062214188789, 0.1837922173919303, 0.1837922173919303, 0.1837922173919303, 0.03482597020897282, 0.03482597020897282, 0.03482597020897282, 0.04157627830137223, 0.04157627830137223, 0.04157627830137223, 0.05465387682335987, 0.05465387682335987, 0.05465387682335987]}, "mutation_prompt": null}
{"id": "1c1d1033-c8ae-4fcf-af68-58fb152baef5", "solution": "# Description: Introduce dynamic population resizing based on convergence speed to enhance exploration efficiency.\n# Code:\nimport numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.alpha = 0.5\n        self.gamma = 1.0\n        self.success_history = []\n        self.learning_rate = 0.01\n\n    def __call__(self, func):\n        np.random.seed(42)\n        budget_used = 0\n\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(self.learning_rate * np.random.rand())\n                else:\n                    self.success_history.append(-self.learning_rate * np.random.rand())\n\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            population = new_population\n            \n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if np.std(fitness) < 1e-3:\n                self.population_size = max(10, self.population_size - 3)\n            else:\n                self.population_size = min(30, self.population_size + 3)\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Introduce dynamic population resizing based on convergence speed to enhance exploration efficiency.", "configspace": "", "generation": 98, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 21 is out of bounds for axis 0 with size 20').", "error": "IndexError('index 21 is out of bounds for axis 0 with size 20')", "parent_id": "942379f2-795a-4d2c-a9c9-ede1fe50a423", "metadata": {}, "mutation_prompt": null}
{"id": "53fdd838-6860-4a3a-9c1b-790df1c5ad72", "solution": "import numpy as np\n\nclass HybridDEFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.alpha = 0.5\n        self.gamma = 1.0\n        self.success_history = []\n        self.learning_rate = 0.01\n\n    def __call__(self, func):\n        np.random.seed(42)\n        budget_used = 0\n\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while budget_used < self.budget:\n            new_population = np.copy(population)\n\n            fitness_variance = np.var(fitness)\n            adaptive_crossover_rate = self.crossover_rate * (1 + np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (1 - (budget_used / self.budget))\n                if self.success_history:\n                    dynamic_mutation_factor *= (1 + np.mean(self.success_history))\n\n                mutant = np.clip(population[a] + dynamic_mutation_factor * (population[b] - population[c]),\n                                 self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                budget_used += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_history.append(self.learning_rate * np.random.rand())\n                else:\n                    self.success_history.append(-self.learning_rate * np.random.rand())\n\n            for i in range(self.population_size):\n                for j in range(self.population_size):\n                    if fitness[j] < fitness[i]:\n                        r = np.linalg.norm(new_population[i] - new_population[j])\n                        beta = np.exp(-self.gamma * r**2)\n                        adaptive_alpha = self.alpha * (1 - (budget_used / self.budget))\n                        new_population[i] += beta * (new_population[j] - new_population[i]) + adaptive_alpha * (np.random.rand(self.dim) - 0.5)\n\n                        new_population[i] = np.clip(new_population[i], self.lower_bound, self.upper_bound)\n                        new_fitness = func(new_population[i])\n                        budget_used += 1\n                        if new_fitness < fitness[i]:\n                            fitness[i] = new_fitness\n\n            population = new_population\n            \n            current_best_idx = np.argmin(fitness)\n            if fitness[current_best_idx] < best_fitness:\n                best_fitness = fitness[current_best_idx]\n                best_solution = population[current_best_idx]\n\n            if np.std(fitness) < 1e-3:\n                self.population_size = max(10, self.population_size - 3)\n\n            self.learning_rate = 0.01 * (1 + np.mean(self.success_history))  # Adjust learning rate\n\n            if budget_used >= self.budget:\n                break\n\n        return best_solution, best_fitness", "name": "HybridDEFirefly", "description": "Introduce a dynamic learning rate based on success history to better balance exploration and exploitation.", "configspace": "", "generation": 99, "fitness": 0.19065069492306505, "feedback": "The algorithm HybridDEFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.16.", "error": "", "parent_id": "942379f2-795a-4d2c-a9c9-ede1fe50a423", "metadata": {"aucs": [0.43160593688432414, 0.43160593688432414, 0.43160593688432414, 0.43983167423320724, 0.43983167423320724, 0.43983167423320724, 0.4746724040731375, 0.4746724040731375, 0.4746724040731375, 0.044563415603345535, 0.044563415603345535, 0.044563415603345535, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11823050092280885, 0.11823050092280885, 0.11823050092280885, 0.09184934260661903, 0.09184934260661903, 0.09184934260661903, 0.0903134872910839, 0.0903134872910839, 0.0903134872910839, 0.05621100230048304, 0.05621100230048304, 0.05621100230048304, 0.06963772383226874, 0.06963772383226874, 0.06963772383226874, 0.06267491157631344, 0.06267491157631344, 0.06267491157631344, 0.7914905177608513, 0.7914905177608513, 0.7914905177608513, 0.4641581902563947, 0.4641581902563947, 0.4641581902563947, 0.1206336097998576, 0.1206336097998576, 0.1206336097998576, 0.27443034893135887, 0.27443034893135887, 0.27443034893135887, 0.2564269073493214, 0.2564269073493214, 0.2564269073493214, 0.2829342449249329, 0.2829342449249329, 0.2829342449249329, 0.546148739517615, 0.546148739517615, 0.546148739517615, 0.49315404315195943, 0.49315404315195943, 0.49315404315195943, 0.12092865580081091, 0.12092865580081091, 0.12092865580081091, 0.15623121853848987, 0.15623121853848987, 0.15623121853848987, 0.18112548127772088, 0.18112548127772088, 0.18112548127772088, 0.14433818791647168, 0.14433818791647168, 0.14433818791647168, 0.16024240192751527, 0.16024240192751527, 0.16024240192751527, 0.15013685881309025, 0.15013685881309025, 0.15013685881309025, 0.1990747254804034, 0.1990747254804034, 0.1990747254804034, 0.03686279891167488, 0.03686279891167488, 0.03686279891167488, 0.02899643036521593, 0.02899643036521593, 0.02899643036521593, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08362624784741002, 0.08362624784741002, 0.08362624784741002, 0.026429639926293214, 0.026429639926293214, 0.026429639926293214, 0.07079028432893153, 0.07079028432893153, 0.07079028432893153, 0.014328683896938865, 0.014328683896938865, 0.014328683896938865, 0.007678245172359488, 0.007678245172359488, 0.007678245172359488, 0.010690469433495497, 0.010690469433495497, 0.010690469433495497, 0.060713635046092174, 0.060713635046092174, 0.060713635046092174, 0.07195347633344196, 0.07195347633344196, 0.07195347633344196, 0.12441656041028637, 0.12441656041028637, 0.12441656041028637, 0.43311272091140385, 0.43311272091140385, 0.43311272091140385, 0.41390750183227687, 0.41390750183227687, 0.41390750183227687, 0.4022544785179163, 0.4022544785179163, 0.4022544785179163, 0.08441967478929524, 0.08441967478929524, 0.08441967478929524, 0.10349604688210334, 0.10349604688210334, 0.10349604688210334, 0.06115719605142056, 0.06115719605142056, 0.06115719605142056, 0.18059241651057278, 0.18059241651057278, 0.18059241651057278, 0.12911648999463488, 0.12911648999463488, 0.12911648999463488, 0.12618761282691848, 0.12618761282691848, 0.12618761282691848, 0.19447488281197123, 0.19447488281197123, 0.19447488281197123, 0.2791519777644713, 0.2791519777644713, 0.2791519777644713, 0.2554401500155482, 0.2554401500155482, 0.2554401500155482, 0.15218680302937704, 0.15218680302937704, 0.15218680302937704, 0.19379041657727536, 0.19379041657727536, 0.19379041657727536, 0.14746600721225545, 0.14746600721225545, 0.14746600721225545, 0.17699915762238694, 0.17699915762238694, 0.17699915762238694, 0.18355982487439237, 0.18355982487439237, 0.18355982487439237, 0.16859501838684776, 0.16859501838684776, 0.16859501838684776, 0.16666583627542608, 0.16666583627542608, 0.16666583627542608, 0.18796767658905889, 0.18796767658905889, 0.18796767658905889, 0.16564309103601305, 0.16564309103601305, 0.16564309103601305, 0.590203752429493, 0.590203752429493, 0.590203752429493, 0.15138268581808734, 0.15138268581808734, 0.15138268581808734, 0.47012131799164836, 0.47012131799164836, 0.47012131799164836, 0.2803350290598844, 0.2803350290598844, 0.2803350290598844, 0.3636665130073643, 0.3636665130073643, 0.3636665130073643, 0.14575602325492132, 0.14575602325492132, 0.14575602325492132, 0.19322582195414173, 0.19322582195414173, 0.19322582195414173, 0.18475774848665172, 0.18475774848665172, 0.18475774848665172, 0.18977244960147377, 0.18977244960147377, 0.18977244960147377, 0.06151151532956278, 0.06151151532956278, 0.06151151532956278, 0.06334899326464816, 0.06334899326464816, 0.06334899326464816, 0.06875220130871751, 0.06875220130871751, 0.06875220130871751]}, "mutation_prompt": null}
