{"id": "4e366d7f-af5f-41d2-8330-dcaf9a6ec793", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Opposition-based learning\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Adaptive Differential Evolution with Opposition-Based Learning to efficiently explore and exploit the search space.", "configspace": "", "generation": 0, "fitness": 0.20029689364203018, "feedback": "The algorithm ADE_OBL got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.18.", "error": "", "parent_id": null, "metadata": {"aucs": [0.3953887654942515, 0.3673853150917803, 0.4015141419168222, 0.38691621601588355, 0.36558300916960806, 0.4078054533056549, 0.390978413505908, 0.3939860098913033, 0.39737159202174155, 0.16554857060365524, 0.14279951361767562, 0.1444461351441414, 0.16780362996903242, 0.15545250824501677, 0.18411480924601553, 0.14375692732494005, 0.15755539117616757, 0.12439084175817627, 0.07356643837521004, 0.07866507351836904, 0.08482325687926917, 0.07200814249639609, 0.07518126213305076, 0.08282286765141611, 0.09021432684285724, 0.07004591094979495, 0.0775905441051733, 0.0649686319237871, 0.06362919958941726, 0.07423678276343837, 0.07991659907937554, 0.06374969185629309, 0.07687221061589589, 0.06835397260270659, 0.07081682525205857, 0.06993858381832363, 0.890627344764051, 0.8847486214361704, 0.866347619123138, 0.7746414787496099, 0.8946355921595175, 0.8501296673269789, 0.8829343813424441, 0.7927987209046685, 0.8541346379837693, 0.17158488620476164, 0.1486191847230961, 0.1732351903540752, 0.15674566399544343, 0.1634116293298652, 0.1882016612086196, 0.167739783112682, 0.17886329208994034, 0.16901384505426853, 0.30686440428745987, 0.25087814405340125, 0.26696723562282554, 0.2536688278049203, 0.2608171755542057, 0.23803466233286852, 0.24286278963409658, 0.23546258208083704, 0.23273180387468595, 0.12502300933140686, 0.11922347167796066, 0.13235366262499215, 0.10614524428799654, 0.09372695836114076, 0.11255746570372027, 0.11333593038045042, 0.09779524801739592, 0.1170446378202229, 0.26409842554969687, 0.2541915856405833, 0.20966107550461488, 0.30480850319389774, 0.3528199471282505, 0.3075732386053657, 0.3635111928753265, 0.24596953261991528, 0.30654321800993845, 0.021707520105609945, 0.034314539124152166, 0.004023841120278648, 0.015480171594729475, 0.02816251329522601, 0.008520488698637974, 0.0493776610258132, 0.049594329625022526, 0.04216685716844826, 0.1473530797382584, 0.1046334933855565, 0.13841338914224777, 0.1295790646048579, 0.09301291294719904, 0.12707664204013125, 0.13869675554596395, 0.12662477552317364, 0.14417444586644945, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011544560095789747, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004217768571194158, 0.004203066948815781, 0.0023247573093938545, 0.0705833923396112, 0.06720968672431771, 0.07890858868259565, 0.07762140771623349, 0.06989061396305274, 0.07883463007400315, 0.060312509554366844, 0.09776386652012847, 0.08067472817706256, 0.32298375144979574, 0.3437536201145551, 0.3392201303813561, 0.3723875308901231, 0.35056836488308984, 0.3623794294296926, 0.3716555409941448, 0.35686715360954246, 0.3532102429695224, 0.06747570089169863, 0.07806850163170254, 0.0916977577207555, 0.07973452719480278, 0.08103358594515409, 0.06797217689560553, 0.07046666987550165, 0.08592555259729884, 0.08191382020400928, 0.221259178827224, 0.17989387552512015, 0.19339772339803152, 0.16449730412783115, 0.11728273808272338, 0.14487030235726028, 0.10585028279010766, 0.13877501797570024, 0.13370029434826225, 0.1961121050212704, 0.23440473552516705, 0.23937541738103296, 0.22831710711194575, 0.22093648094886165, 0.21247098632357708, 0.23711015061346374, 0.23252392387343845, 0.23377643810953797, 0.14975284935083932, 0.16097825884214, 0.16704357853006602, 0.18889952074192484, 0.17349149059467595, 0.1691686501862416, 0.15520194549672883, 0.16348990107485717, 0.17945107357168633, 0.19364739053970847, 0.15356862951293637, 0.17370250767753792, 0.20059425292310384, 0.19602090969749963, 0.14066070046978807, 0.18102813170673193, 0.16650308300720484, 0.18928849687535354, 0.1732245677531371, 0.17818101179327228, 0.16321835518312455, 0.16373601761018586, 0.17158466727112065, 0.16276296956595138, 0.1692362565674288, 0.165954182036414, 0.16586609770808058, 0.1622276765383529, 0.34395331767954784, 0.323024575714681, 0.4571018665533527, 0.5149776622469469, 0.4289540259305501, 0.3661701711208478, 0.4579527784302184, 0.19224777869399245, 0.3271757443032106, 0.2145532415980681, 0.3857806375586642, 0.19088534127060452, 0.31892286118134217, 0.1609857513492814, 0.14687505565686387, 0.5459871018788822, 0.2053014992234773, 0.16857250003754598, 0.15955366812455907, 0.16354192119690192, 0.15781934089886562, 0.18683168487806356, 0.15776603567149527, 0.16379411855922466, 0.18809064021099153, 0.16737483514063756, 0.07037073394088822, 0.08531810785188843, 0.08224504330605831, 0.06912552927297888, 0.06783775628282929, 0.08665465008178075, 0.06023481388061469, 0.05983977189544798, 0.051360474392294075]}, "mutation_prompt": null}
{"id": "acfc5b5c-7c5e-4685-a99d-e387f2eb79bd", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Opposition-based learning\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Adaptive Differential Evolution with Opposition-Based Learning to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4e366d7f-af5f-41d2-8330-dcaf9a6ec793", "metadata": {"aucs": [0.3953887654942515, 0.3673853150917803, 0.4015141419168222, 0.38691621601588355, 0.36558300916960806, 0.4078054533056549, 0.390978413505908, 0.3939860098913033, 0.39737159202174155, 0.16554857060365524, 0.14279951361767562, 0.1444461351441414, 0.16780362996903242, 0.15545250824501677, 0.18411480924601553, 0.14375692732494005, 0.15755539117616757, 0.12439084175817627, 0.07356643837521004, 0.07866507351836904, 0.08482325687926917, 0.07200814249639609, 0.07518126213305076, 0.08282286765141611, 0.09021432684285724, 0.07004591094979495, 0.0775905441051733, 0.0649686319237871, 0.06362919958941726, 0.07423678276343837, 0.07991659907937554, 0.06374969185629309, 0.07687221061589589, 0.06835397260270659, 0.07081682525205857, 0.06993858381832363, 0.890627344764051, 0.8847486214361704, 0.866347619123138, 0.7746414787496099, 0.8946355921595175, 0.8501296673269789, 0.8829343813424441, 0.7927987209046685, 0.8541346379837693, 0.17158488620476164, 0.1486191847230961, 0.1732351903540752, 0.15674566399544343, 0.1634116293298652, 0.1882016612086196, 0.167739783112682, 0.17886329208994034, 0.16901384505426853, 0.30686440428745987, 0.25087814405340125, 0.26696723562282554, 0.2536688278049203, 0.2608171755542057, 0.23803466233286852, 0.24286278963409658, 0.23546258208083704, 0.23273180387468595, 0.12502300933140686, 0.11922347167796066, 0.13235366262499215, 0.10614524428799654, 0.09372695836114076, 0.11255746570372027, 0.11333593038045042, 0.09779524801739592, 0.1170446378202229, 0.26409842554969687, 0.2541915856405833, 0.20966107550461488, 0.30480850319389774, 0.3528199471282505, 0.3075732386053657, 0.3635111928753265, 0.24596953261991528, 0.30654321800993845, 0.021707520105609945, 0.034314539124152166, 0.004023841120278648, 0.015480171594729475, 0.02816251329522601, 0.008520488698637974, 0.0493776610258132, 0.049594329625022526, 0.04216685716844826, 0.1473530797382584, 0.1046334933855565, 0.13841338914224777, 0.1295790646048579, 0.09301291294719904, 0.12707664204013125, 0.13869675554596395, 0.12662477552317364, 0.14417444586644945, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011544560095789747, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004217768571194158, 0.004203066948815781, 0.0023247573093938545, 0.0705833923396112, 0.06720968672431771, 0.07890858868259565, 0.07762140771623349, 0.06989061396305274, 0.07883463007400315, 0.060312509554366844, 0.09776386652012847, 0.08067472817706256, 0.32298375144979574, 0.3437536201145551, 0.3392201303813561, 0.3723875308901231, 0.35056836488308984, 0.3623794294296926, 0.3716555409941448, 0.35686715360954246, 0.3532102429695224, 0.06747570089169863, 0.07806850163170254, 0.0916977577207555, 0.07973452719480278, 0.08103358594515409, 0.06797217689560553, 0.07046666987550165, 0.08592555259729884, 0.08191382020400928, 0.221259178827224, 0.17989387552512015, 0.19339772339803152, 0.16449730412783115, 0.11728273808272338, 0.14487030235726028, 0.10585028279010766, 0.13877501797570024, 0.13370029434826225, 0.1961121050212704, 0.23440473552516705, 0.23937541738103296, 0.22831710711194575, 0.22093648094886165, 0.21247098632357708, 0.23711015061346374, 0.23252392387343845, 0.23377643810953797, 0.14975284935083932, 0.16097825884214, 0.16704357853006602, 0.18889952074192484, 0.17349149059467595, 0.1691686501862416, 0.15520194549672883, 0.16348990107485717, 0.17945107357168633, 0.19364739053970847, 0.15356862951293637, 0.17370250767753792, 0.20059425292310384, 0.19602090969749963, 0.14066070046978807, 0.18102813170673193, 0.16650308300720484, 0.18928849687535354, 0.1732245677531371, 0.17818101179327228, 0.16321835518312455, 0.16373601761018586, 0.17158466727112065, 0.16276296956595138, 0.1692362565674288, 0.165954182036414, 0.16586609770808058, 0.1622276765383529, 0.34395331767954784, 0.323024575714681, 0.4571018665533527, 0.5149776622469469, 0.4289540259305501, 0.3661701711208478, 0.4579527784302184, 0.19224777869399245, 0.3271757443032106, 0.2145532415980681, 0.3857806375586642, 0.19088534127060452, 0.31892286118134217, 0.1609857513492814, 0.14687505565686387, 0.5459871018788822, 0.2053014992234773, 0.16857250003754598, 0.15955366812455907, 0.16354192119690192, 0.15781934089886562, 0.18683168487806356, 0.15776603567149527, 0.16379411855922466, 0.18809064021099153, 0.16737483514063756, 0.07037073394088822, 0.08531810785188843, 0.08224504330605831, 0.06912552927297888, 0.06783775628282929, 0.08665465008178075, 0.06023481388061469, 0.05983977189544798, 0.051360474392294075]}, "mutation_prompt": null}
{"id": "ea4aeb2e-0071-4151-b3a7-ea5e8231072f", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Opposition-based learning\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Adaptive Differential Evolution with Opposition-Based Learning to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4e366d7f-af5f-41d2-8330-dcaf9a6ec793", "metadata": {"aucs": [0.3953887654942515, 0.3673853150917803, 0.4015141419168222, 0.38691621601588355, 0.36558300916960806, 0.4078054533056549, 0.390978413505908, 0.3939860098913033, 0.39737159202174155, 0.16554857060365524, 0.14279951361767562, 0.1444461351441414, 0.16780362996903242, 0.15545250824501677, 0.18411480924601553, 0.14375692732494005, 0.15755539117616757, 0.12439084175817627, 0.07356643837521004, 0.07866507351836904, 0.08482325687926917, 0.07200814249639609, 0.07518126213305076, 0.08282286765141611, 0.09021432684285724, 0.07004591094979495, 0.0775905441051733, 0.0649686319237871, 0.06362919958941726, 0.07423678276343837, 0.07991659907937554, 0.06374969185629309, 0.07687221061589589, 0.06835397260270659, 0.07081682525205857, 0.06993858381832363, 0.890627344764051, 0.8847486214361704, 0.866347619123138, 0.7746414787496099, 0.8946355921595175, 0.8501296673269789, 0.8829343813424441, 0.7927987209046685, 0.8541346379837693, 0.17158488620476164, 0.1486191847230961, 0.1732351903540752, 0.15674566399544343, 0.1634116293298652, 0.1882016612086196, 0.167739783112682, 0.17886329208994034, 0.16901384505426853, 0.30686440428745987, 0.25087814405340125, 0.26696723562282554, 0.2536688278049203, 0.2608171755542057, 0.23803466233286852, 0.24286278963409658, 0.23546258208083704, 0.23273180387468595, 0.12502300933140686, 0.11922347167796066, 0.13235366262499215, 0.10614524428799654, 0.09372695836114076, 0.11255746570372027, 0.11333593038045042, 0.09779524801739592, 0.1170446378202229, 0.26409842554969687, 0.2541915856405833, 0.20966107550461488, 0.30480850319389774, 0.3528199471282505, 0.3075732386053657, 0.3635111928753265, 0.24596953261991528, 0.30654321800993845, 0.021707520105609945, 0.034314539124152166, 0.004023841120278648, 0.015480171594729475, 0.02816251329522601, 0.008520488698637974, 0.0493776610258132, 0.049594329625022526, 0.04216685716844826, 0.1473530797382584, 0.1046334933855565, 0.13841338914224777, 0.1295790646048579, 0.09301291294719904, 0.12707664204013125, 0.13869675554596395, 0.12662477552317364, 0.14417444586644945, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011544560095789747, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004217768571194158, 0.004203066948815781, 0.0023247573093938545, 0.0705833923396112, 0.06720968672431771, 0.07890858868259565, 0.07762140771623349, 0.06989061396305274, 0.07883463007400315, 0.060312509554366844, 0.09776386652012847, 0.08067472817706256, 0.32298375144979574, 0.3437536201145551, 0.3392201303813561, 0.3723875308901231, 0.35056836488308984, 0.3623794294296926, 0.3716555409941448, 0.35686715360954246, 0.3532102429695224, 0.06747570089169863, 0.07806850163170254, 0.0916977577207555, 0.07973452719480278, 0.08103358594515409, 0.06797217689560553, 0.07046666987550165, 0.08592555259729884, 0.08191382020400928, 0.221259178827224, 0.17989387552512015, 0.19339772339803152, 0.16449730412783115, 0.11728273808272338, 0.14487030235726028, 0.10585028279010766, 0.13877501797570024, 0.13370029434826225, 0.1961121050212704, 0.23440473552516705, 0.23937541738103296, 0.22831710711194575, 0.22093648094886165, 0.21247098632357708, 0.23711015061346374, 0.23252392387343845, 0.23377643810953797, 0.14975284935083932, 0.16097825884214, 0.16704357853006602, 0.18889952074192484, 0.17349149059467595, 0.1691686501862416, 0.15520194549672883, 0.16348990107485717, 0.17945107357168633, 0.19364739053970847, 0.15356862951293637, 0.17370250767753792, 0.20059425292310384, 0.19602090969749963, 0.14066070046978807, 0.18102813170673193, 0.16650308300720484, 0.18928849687535354, 0.1732245677531371, 0.17818101179327228, 0.16321835518312455, 0.16373601761018586, 0.17158466727112065, 0.16276296956595138, 0.1692362565674288, 0.165954182036414, 0.16586609770808058, 0.1622276765383529, 0.34395331767954784, 0.323024575714681, 0.4571018665533527, 0.5149776622469469, 0.4289540259305501, 0.3661701711208478, 0.4579527784302184, 0.19224777869399245, 0.3271757443032106, 0.2145532415980681, 0.3857806375586642, 0.19088534127060452, 0.31892286118134217, 0.1609857513492814, 0.14687505565686387, 0.5459871018788822, 0.2053014992234773, 0.16857250003754598, 0.15955366812455907, 0.16354192119690192, 0.15781934089886562, 0.18683168487806356, 0.15776603567149527, 0.16379411855922466, 0.18809064021099153, 0.16737483514063756, 0.07037073394088822, 0.08531810785188843, 0.08224504330605831, 0.06912552927297888, 0.06783775628282929, 0.08665465008178075, 0.06023481388061469, 0.05983977189544798, 0.051360474392294075]}, "mutation_prompt": null}
{"id": "60de3b02-7f74-4ca6-97dd-0b0dbc45d940", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Opposition-based learning\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Adaptive Differential Evolution with Opposition-Based Learning to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4e366d7f-af5f-41d2-8330-dcaf9a6ec793", "metadata": {"aucs": [0.3953887654942515, 0.3673853150917803, 0.4015141419168222, 0.38691621601588355, 0.36558300916960806, 0.4078054533056549, 0.390978413505908, 0.3939860098913033, 0.39737159202174155, 0.16554857060365524, 0.14279951361767562, 0.1444461351441414, 0.16780362996903242, 0.15545250824501677, 0.18411480924601553, 0.14375692732494005, 0.15755539117616757, 0.12439084175817627, 0.07356643837521004, 0.07866507351836904, 0.08482325687926917, 0.07200814249639609, 0.07518126213305076, 0.08282286765141611, 0.09021432684285724, 0.07004591094979495, 0.0775905441051733, 0.0649686319237871, 0.06362919958941726, 0.07423678276343837, 0.07991659907937554, 0.06374969185629309, 0.07687221061589589, 0.06835397260270659, 0.07081682525205857, 0.06993858381832363, 0.890627344764051, 0.8847486214361704, 0.866347619123138, 0.7746414787496099, 0.8946355921595175, 0.8501296673269789, 0.8829343813424441, 0.7927987209046685, 0.8541346379837693, 0.17158488620476164, 0.1486191847230961, 0.1732351903540752, 0.15674566399544343, 0.1634116293298652, 0.1882016612086196, 0.167739783112682, 0.17886329208994034, 0.16901384505426853, 0.30686440428745987, 0.25087814405340125, 0.26696723562282554, 0.2536688278049203, 0.2608171755542057, 0.23803466233286852, 0.24286278963409658, 0.23546258208083704, 0.23273180387468595, 0.12502300933140686, 0.11922347167796066, 0.13235366262499215, 0.10614524428799654, 0.09372695836114076, 0.11255746570372027, 0.11333593038045042, 0.09779524801739592, 0.1170446378202229, 0.26409842554969687, 0.2541915856405833, 0.20966107550461488, 0.30480850319389774, 0.3528199471282505, 0.3075732386053657, 0.3635111928753265, 0.24596953261991528, 0.30654321800993845, 0.021707520105609945, 0.034314539124152166, 0.004023841120278648, 0.015480171594729475, 0.02816251329522601, 0.008520488698637974, 0.0493776610258132, 0.049594329625022526, 0.04216685716844826, 0.1473530797382584, 0.1046334933855565, 0.13841338914224777, 0.1295790646048579, 0.09301291294719904, 0.12707664204013125, 0.13869675554596395, 0.12662477552317364, 0.14417444586644945, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011544560095789747, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004217768571194158, 0.004203066948815781, 0.0023247573093938545, 0.0705833923396112, 0.06720968672431771, 0.07890858868259565, 0.07762140771623349, 0.06989061396305274, 0.07883463007400315, 0.060312509554366844, 0.09776386652012847, 0.08067472817706256, 0.32298375144979574, 0.3437536201145551, 0.3392201303813561, 0.3723875308901231, 0.35056836488308984, 0.3623794294296926, 0.3716555409941448, 0.35686715360954246, 0.3532102429695224, 0.06747570089169863, 0.07806850163170254, 0.0916977577207555, 0.07973452719480278, 0.08103358594515409, 0.06797217689560553, 0.07046666987550165, 0.08592555259729884, 0.08191382020400928, 0.221259178827224, 0.17989387552512015, 0.19339772339803152, 0.16449730412783115, 0.11728273808272338, 0.14487030235726028, 0.10585028279010766, 0.13877501797570024, 0.13370029434826225, 0.1961121050212704, 0.23440473552516705, 0.23937541738103296, 0.22831710711194575, 0.22093648094886165, 0.21247098632357708, 0.23711015061346374, 0.23252392387343845, 0.23377643810953797, 0.14975284935083932, 0.16097825884214, 0.16704357853006602, 0.18889952074192484, 0.17349149059467595, 0.1691686501862416, 0.15520194549672883, 0.16348990107485717, 0.17945107357168633, 0.19364739053970847, 0.15356862951293637, 0.17370250767753792, 0.20059425292310384, 0.19602090969749963, 0.14066070046978807, 0.18102813170673193, 0.16650308300720484, 0.18928849687535354, 0.1732245677531371, 0.17818101179327228, 0.16321835518312455, 0.16373601761018586, 0.17158466727112065, 0.16276296956595138, 0.1692362565674288, 0.165954182036414, 0.16586609770808058, 0.1622276765383529, 0.34395331767954784, 0.323024575714681, 0.4571018665533527, 0.5149776622469469, 0.4289540259305501, 0.3661701711208478, 0.4579527784302184, 0.19224777869399245, 0.3271757443032106, 0.2145532415980681, 0.3857806375586642, 0.19088534127060452, 0.31892286118134217, 0.1609857513492814, 0.14687505565686387, 0.5459871018788822, 0.2053014992234773, 0.16857250003754598, 0.15955366812455907, 0.16354192119690192, 0.15781934089886562, 0.18683168487806356, 0.15776603567149527, 0.16379411855922466, 0.18809064021099153, 0.16737483514063756, 0.07037073394088822, 0.08531810785188843, 0.08224504330605831, 0.06912552927297888, 0.06783775628282929, 0.08665465008178075, 0.06023481388061469, 0.05983977189544798, 0.051360474392294075]}, "mutation_prompt": null}
{"id": "5a240d7a-b97e-432e-bb67-66874185178d", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Opposition-based learning\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Adaptive Differential Evolution with Opposition-Based Learning to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4e366d7f-af5f-41d2-8330-dcaf9a6ec793", "metadata": {"aucs": [0.3953887654942515, 0.3673853150917803, 0.4015141419168222, 0.38691621601588355, 0.36558300916960806, 0.4078054533056549, 0.390978413505908, 0.3939860098913033, 0.39737159202174155, 0.16554857060365524, 0.14279951361767562, 0.1444461351441414, 0.16780362996903242, 0.15545250824501677, 0.18411480924601553, 0.14375692732494005, 0.15755539117616757, 0.12439084175817627, 0.07356643837521004, 0.07866507351836904, 0.08482325687926917, 0.07200814249639609, 0.07518126213305076, 0.08282286765141611, 0.09021432684285724, 0.07004591094979495, 0.0775905441051733, 0.0649686319237871, 0.06362919958941726, 0.07423678276343837, 0.07991659907937554, 0.06374969185629309, 0.07687221061589589, 0.06835397260270659, 0.07081682525205857, 0.06993858381832363, 0.890627344764051, 0.8847486214361704, 0.866347619123138, 0.7746414787496099, 0.8946355921595175, 0.8501296673269789, 0.8829343813424441, 0.7927987209046685, 0.8541346379837693, 0.17158488620476164, 0.1486191847230961, 0.1732351903540752, 0.15674566399544343, 0.1634116293298652, 0.1882016612086196, 0.167739783112682, 0.17886329208994034, 0.16901384505426853, 0.30686440428745987, 0.25087814405340125, 0.26696723562282554, 0.2536688278049203, 0.2608171755542057, 0.23803466233286852, 0.24286278963409658, 0.23546258208083704, 0.23273180387468595, 0.12502300933140686, 0.11922347167796066, 0.13235366262499215, 0.10614524428799654, 0.09372695836114076, 0.11255746570372027, 0.11333593038045042, 0.09779524801739592, 0.1170446378202229, 0.26409842554969687, 0.2541915856405833, 0.20966107550461488, 0.30480850319389774, 0.3528199471282505, 0.3075732386053657, 0.3635111928753265, 0.24596953261991528, 0.30654321800993845, 0.021707520105609945, 0.034314539124152166, 0.004023841120278648, 0.015480171594729475, 0.02816251329522601, 0.008520488698637974, 0.0493776610258132, 0.049594329625022526, 0.04216685716844826, 0.1473530797382584, 0.1046334933855565, 0.13841338914224777, 0.1295790646048579, 0.09301291294719904, 0.12707664204013125, 0.13869675554596395, 0.12662477552317364, 0.14417444586644945, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011544560095789747, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004217768571194158, 0.004203066948815781, 0.0023247573093938545, 0.0705833923396112, 0.06720968672431771, 0.07890858868259565, 0.07762140771623349, 0.06989061396305274, 0.07883463007400315, 0.060312509554366844, 0.09776386652012847, 0.08067472817706256, 0.32298375144979574, 0.3437536201145551, 0.3392201303813561, 0.3723875308901231, 0.35056836488308984, 0.3623794294296926, 0.3716555409941448, 0.35686715360954246, 0.3532102429695224, 0.06747570089169863, 0.07806850163170254, 0.0916977577207555, 0.07973452719480278, 0.08103358594515409, 0.06797217689560553, 0.07046666987550165, 0.08592555259729884, 0.08191382020400928, 0.221259178827224, 0.17989387552512015, 0.19339772339803152, 0.16449730412783115, 0.11728273808272338, 0.14487030235726028, 0.10585028279010766, 0.13877501797570024, 0.13370029434826225, 0.1961121050212704, 0.23440473552516705, 0.23937541738103296, 0.22831710711194575, 0.22093648094886165, 0.21247098632357708, 0.23711015061346374, 0.23252392387343845, 0.23377643810953797, 0.14975284935083932, 0.16097825884214, 0.16704357853006602, 0.18889952074192484, 0.17349149059467595, 0.1691686501862416, 0.15520194549672883, 0.16348990107485717, 0.17945107357168633, 0.19364739053970847, 0.15356862951293637, 0.17370250767753792, 0.20059425292310384, 0.19602090969749963, 0.14066070046978807, 0.18102813170673193, 0.16650308300720484, 0.18928849687535354, 0.1732245677531371, 0.17818101179327228, 0.16321835518312455, 0.16373601761018586, 0.17158466727112065, 0.16276296956595138, 0.1692362565674288, 0.165954182036414, 0.16586609770808058, 0.1622276765383529, 0.34395331767954784, 0.323024575714681, 0.4571018665533527, 0.5149776622469469, 0.4289540259305501, 0.3661701711208478, 0.4579527784302184, 0.19224777869399245, 0.3271757443032106, 0.2145532415980681, 0.3857806375586642, 0.19088534127060452, 0.31892286118134217, 0.1609857513492814, 0.14687505565686387, 0.5459871018788822, 0.2053014992234773, 0.16857250003754598, 0.15955366812455907, 0.16354192119690192, 0.15781934089886562, 0.18683168487806356, 0.15776603567149527, 0.16379411855922466, 0.18809064021099153, 0.16737483514063756, 0.07037073394088822, 0.08531810785188843, 0.08224504330605831, 0.06912552927297888, 0.06783775628282929, 0.08665465008178075, 0.06023481388061469, 0.05983977189544798, 0.051360474392294075]}, "mutation_prompt": null}
{"id": "fa47926e-7beb-4632-ae57-1cd81c913e5a", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Opposition-based learning\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Adaptive Differential Evolution with Opposition-Based Learning to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4e366d7f-af5f-41d2-8330-dcaf9a6ec793", "metadata": {"aucs": [0.3953887654942515, 0.3673853150917803, 0.4015141419168222, 0.38691621601588355, 0.36558300916960806, 0.4078054533056549, 0.390978413505908, 0.3939860098913033, 0.39737159202174155, 0.16554857060365524, 0.14279951361767562, 0.1444461351441414, 0.16780362996903242, 0.15545250824501677, 0.18411480924601553, 0.14375692732494005, 0.15755539117616757, 0.12439084175817627, 0.07356643837521004, 0.07866507351836904, 0.08482325687926917, 0.07200814249639609, 0.07518126213305076, 0.08282286765141611, 0.09021432684285724, 0.07004591094979495, 0.0775905441051733, 0.0649686319237871, 0.06362919958941726, 0.07423678276343837, 0.07991659907937554, 0.06374969185629309, 0.07687221061589589, 0.06835397260270659, 0.07081682525205857, 0.06993858381832363, 0.890627344764051, 0.8847486214361704, 0.866347619123138, 0.7746414787496099, 0.8946355921595175, 0.8501296673269789, 0.8829343813424441, 0.7927987209046685, 0.8541346379837693, 0.17158488620476164, 0.1486191847230961, 0.1732351903540752, 0.15674566399544343, 0.1634116293298652, 0.1882016612086196, 0.167739783112682, 0.17886329208994034, 0.16901384505426853, 0.30686440428745987, 0.25087814405340125, 0.26696723562282554, 0.2536688278049203, 0.2608171755542057, 0.23803466233286852, 0.24286278963409658, 0.23546258208083704, 0.23273180387468595, 0.12502300933140686, 0.11922347167796066, 0.13235366262499215, 0.10614524428799654, 0.09372695836114076, 0.11255746570372027, 0.11333593038045042, 0.09779524801739592, 0.1170446378202229, 0.26409842554969687, 0.2541915856405833, 0.20966107550461488, 0.30480850319389774, 0.3528199471282505, 0.3075732386053657, 0.3635111928753265, 0.24596953261991528, 0.30654321800993845, 0.021707520105609945, 0.034314539124152166, 0.004023841120278648, 0.015480171594729475, 0.02816251329522601, 0.008520488698637974, 0.0493776610258132, 0.049594329625022526, 0.04216685716844826, 0.1473530797382584, 0.1046334933855565, 0.13841338914224777, 0.1295790646048579, 0.09301291294719904, 0.12707664204013125, 0.13869675554596395, 0.12662477552317364, 0.14417444586644945, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011544560095789747, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004217768571194158, 0.004203066948815781, 0.0023247573093938545, 0.0705833923396112, 0.06720968672431771, 0.07890858868259565, 0.07762140771623349, 0.06989061396305274, 0.07883463007400315, 0.060312509554366844, 0.09776386652012847, 0.08067472817706256, 0.32298375144979574, 0.3437536201145551, 0.3392201303813561, 0.3723875308901231, 0.35056836488308984, 0.3623794294296926, 0.3716555409941448, 0.35686715360954246, 0.3532102429695224, 0.06747570089169863, 0.07806850163170254, 0.0916977577207555, 0.07973452719480278, 0.08103358594515409, 0.06797217689560553, 0.07046666987550165, 0.08592555259729884, 0.08191382020400928, 0.221259178827224, 0.17989387552512015, 0.19339772339803152, 0.16449730412783115, 0.11728273808272338, 0.14487030235726028, 0.10585028279010766, 0.13877501797570024, 0.13370029434826225, 0.1961121050212704, 0.23440473552516705, 0.23937541738103296, 0.22831710711194575, 0.22093648094886165, 0.21247098632357708, 0.23711015061346374, 0.23252392387343845, 0.23377643810953797, 0.14975284935083932, 0.16097825884214, 0.16704357853006602, 0.18889952074192484, 0.17349149059467595, 0.1691686501862416, 0.15520194549672883, 0.16348990107485717, 0.17945107357168633, 0.19364739053970847, 0.15356862951293637, 0.17370250767753792, 0.20059425292310384, 0.19602090969749963, 0.14066070046978807, 0.18102813170673193, 0.16650308300720484, 0.18928849687535354, 0.1732245677531371, 0.17818101179327228, 0.16321835518312455, 0.16373601761018586, 0.17158466727112065, 0.16276296956595138, 0.1692362565674288, 0.165954182036414, 0.16586609770808058, 0.1622276765383529, 0.34395331767954784, 0.323024575714681, 0.4571018665533527, 0.5149776622469469, 0.4289540259305501, 0.3661701711208478, 0.4579527784302184, 0.19224777869399245, 0.3271757443032106, 0.2145532415980681, 0.3857806375586642, 0.19088534127060452, 0.31892286118134217, 0.1609857513492814, 0.14687505565686387, 0.5459871018788822, 0.2053014992234773, 0.16857250003754598, 0.15955366812455907, 0.16354192119690192, 0.15781934089886562, 0.18683168487806356, 0.15776603567149527, 0.16379411855922466, 0.18809064021099153, 0.16737483514063756, 0.07037073394088822, 0.08531810785188843, 0.08224504330605831, 0.06912552927297888, 0.06783775628282929, 0.08665465008178075, 0.06023481388061469, 0.05983977189544798, 0.051360474392294075]}, "mutation_prompt": null}
{"id": "dffffc2e-7926-4769-aa8b-004e1976420e", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Opposition-based learning\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Adaptive Differential Evolution with Opposition-Based Learning to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4e366d7f-af5f-41d2-8330-dcaf9a6ec793", "metadata": {"aucs": [0.3953887654942515, 0.3673853150917803, 0.4015141419168222, 0.38691621601588355, 0.36558300916960806, 0.4078054533056549, 0.390978413505908, 0.3939860098913033, 0.39737159202174155, 0.16554857060365524, 0.14279951361767562, 0.1444461351441414, 0.16780362996903242, 0.15545250824501677, 0.18411480924601553, 0.14375692732494005, 0.15755539117616757, 0.12439084175817627, 0.07356643837521004, 0.07866507351836904, 0.08482325687926917, 0.07200814249639609, 0.07518126213305076, 0.08282286765141611, 0.09021432684285724, 0.07004591094979495, 0.0775905441051733, 0.0649686319237871, 0.06362919958941726, 0.07423678276343837, 0.07991659907937554, 0.06374969185629309, 0.07687221061589589, 0.06835397260270659, 0.07081682525205857, 0.06993858381832363, 0.890627344764051, 0.8847486214361704, 0.866347619123138, 0.7746414787496099, 0.8946355921595175, 0.8501296673269789, 0.8829343813424441, 0.7927987209046685, 0.8541346379837693, 0.17158488620476164, 0.1486191847230961, 0.1732351903540752, 0.15674566399544343, 0.1634116293298652, 0.1882016612086196, 0.167739783112682, 0.17886329208994034, 0.16901384505426853, 0.30686440428745987, 0.25087814405340125, 0.26696723562282554, 0.2536688278049203, 0.2608171755542057, 0.23803466233286852, 0.24286278963409658, 0.23546258208083704, 0.23273180387468595, 0.12502300933140686, 0.11922347167796066, 0.13235366262499215, 0.10614524428799654, 0.09372695836114076, 0.11255746570372027, 0.11333593038045042, 0.09779524801739592, 0.1170446378202229, 0.26409842554969687, 0.2541915856405833, 0.20966107550461488, 0.30480850319389774, 0.3528199471282505, 0.3075732386053657, 0.3635111928753265, 0.24596953261991528, 0.30654321800993845, 0.021707520105609945, 0.034314539124152166, 0.004023841120278648, 0.015480171594729475, 0.02816251329522601, 0.008520488698637974, 0.0493776610258132, 0.049594329625022526, 0.04216685716844826, 0.1473530797382584, 0.1046334933855565, 0.13841338914224777, 0.1295790646048579, 0.09301291294719904, 0.12707664204013125, 0.13869675554596395, 0.12662477552317364, 0.14417444586644945, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011544560095789747, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004217768571194158, 0.004203066948815781, 0.0023247573093938545, 0.0705833923396112, 0.06720968672431771, 0.07890858868259565, 0.07762140771623349, 0.06989061396305274, 0.07883463007400315, 0.060312509554366844, 0.09776386652012847, 0.08067472817706256, 0.32298375144979574, 0.3437536201145551, 0.3392201303813561, 0.3723875308901231, 0.35056836488308984, 0.3623794294296926, 0.3716555409941448, 0.35686715360954246, 0.3532102429695224, 0.06747570089169863, 0.07806850163170254, 0.0916977577207555, 0.07973452719480278, 0.08103358594515409, 0.06797217689560553, 0.07046666987550165, 0.08592555259729884, 0.08191382020400928, 0.221259178827224, 0.17989387552512015, 0.19339772339803152, 0.16449730412783115, 0.11728273808272338, 0.14487030235726028, 0.10585028279010766, 0.13877501797570024, 0.13370029434826225, 0.1961121050212704, 0.23440473552516705, 0.23937541738103296, 0.22831710711194575, 0.22093648094886165, 0.21247098632357708, 0.23711015061346374, 0.23252392387343845, 0.23377643810953797, 0.14975284935083932, 0.16097825884214, 0.16704357853006602, 0.18889952074192484, 0.17349149059467595, 0.1691686501862416, 0.15520194549672883, 0.16348990107485717, 0.17945107357168633, 0.19364739053970847, 0.15356862951293637, 0.17370250767753792, 0.20059425292310384, 0.19602090969749963, 0.14066070046978807, 0.18102813170673193, 0.16650308300720484, 0.18928849687535354, 0.1732245677531371, 0.17818101179327228, 0.16321835518312455, 0.16373601761018586, 0.17158466727112065, 0.16276296956595138, 0.1692362565674288, 0.165954182036414, 0.16586609770808058, 0.1622276765383529, 0.34395331767954784, 0.323024575714681, 0.4571018665533527, 0.5149776622469469, 0.4289540259305501, 0.3661701711208478, 0.4579527784302184, 0.19224777869399245, 0.3271757443032106, 0.2145532415980681, 0.3857806375586642, 0.19088534127060452, 0.31892286118134217, 0.1609857513492814, 0.14687505565686387, 0.5459871018788822, 0.2053014992234773, 0.16857250003754598, 0.15955366812455907, 0.16354192119690192, 0.15781934089886562, 0.18683168487806356, 0.15776603567149527, 0.16379411855922466, 0.18809064021099153, 0.16737483514063756, 0.07037073394088822, 0.08531810785188843, 0.08224504330605831, 0.06912552927297888, 0.06783775628282929, 0.08665465008178075, 0.06023481388061469, 0.05983977189544798, 0.051360474392294075]}, "mutation_prompt": null}
{"id": "5d2e9f28-a15d-4e46-8c5e-ce3a00291121", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Opposition-based learning\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Adaptive Differential Evolution with Opposition-Based Learning to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4e366d7f-af5f-41d2-8330-dcaf9a6ec793", "metadata": {"aucs": [0.3953887654942515, 0.3673853150917803, 0.4015141419168222, 0.38691621601588355, 0.36558300916960806, 0.4078054533056549, 0.390978413505908, 0.3939860098913033, 0.39737159202174155, 0.16554857060365524, 0.14279951361767562, 0.1444461351441414, 0.16780362996903242, 0.15545250824501677, 0.18411480924601553, 0.14375692732494005, 0.15755539117616757, 0.12439084175817627, 0.07356643837521004, 0.07866507351836904, 0.08482325687926917, 0.07200814249639609, 0.07518126213305076, 0.08282286765141611, 0.09021432684285724, 0.07004591094979495, 0.0775905441051733, 0.0649686319237871, 0.06362919958941726, 0.07423678276343837, 0.07991659907937554, 0.06374969185629309, 0.07687221061589589, 0.06835397260270659, 0.07081682525205857, 0.06993858381832363, 0.890627344764051, 0.8847486214361704, 0.866347619123138, 0.7746414787496099, 0.8946355921595175, 0.8501296673269789, 0.8829343813424441, 0.7927987209046685, 0.8541346379837693, 0.17158488620476164, 0.1486191847230961, 0.1732351903540752, 0.15674566399544343, 0.1634116293298652, 0.1882016612086196, 0.167739783112682, 0.17886329208994034, 0.16901384505426853, 0.30686440428745987, 0.25087814405340125, 0.26696723562282554, 0.2536688278049203, 0.2608171755542057, 0.23803466233286852, 0.24286278963409658, 0.23546258208083704, 0.23273180387468595, 0.12502300933140686, 0.11922347167796066, 0.13235366262499215, 0.10614524428799654, 0.09372695836114076, 0.11255746570372027, 0.11333593038045042, 0.09779524801739592, 0.1170446378202229, 0.26409842554969687, 0.2541915856405833, 0.20966107550461488, 0.30480850319389774, 0.3528199471282505, 0.3075732386053657, 0.3635111928753265, 0.24596953261991528, 0.30654321800993845, 0.021707520105609945, 0.034314539124152166, 0.004023841120278648, 0.015480171594729475, 0.02816251329522601, 0.008520488698637974, 0.0493776610258132, 0.049594329625022526, 0.04216685716844826, 0.1473530797382584, 0.1046334933855565, 0.13841338914224777, 0.1295790646048579, 0.09301291294719904, 0.12707664204013125, 0.13869675554596395, 0.12662477552317364, 0.14417444586644945, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011544560095789747, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004217768571194158, 0.004203066948815781, 0.0023247573093938545, 0.0705833923396112, 0.06720968672431771, 0.07890858868259565, 0.07762140771623349, 0.06989061396305274, 0.07883463007400315, 0.060312509554366844, 0.09776386652012847, 0.08067472817706256, 0.32298375144979574, 0.3437536201145551, 0.3392201303813561, 0.3723875308901231, 0.35056836488308984, 0.3623794294296926, 0.3716555409941448, 0.35686715360954246, 0.3532102429695224, 0.06747570089169863, 0.07806850163170254, 0.0916977577207555, 0.07973452719480278, 0.08103358594515409, 0.06797217689560553, 0.07046666987550165, 0.08592555259729884, 0.08191382020400928, 0.221259178827224, 0.17989387552512015, 0.19339772339803152, 0.16449730412783115, 0.11728273808272338, 0.14487030235726028, 0.10585028279010766, 0.13877501797570024, 0.13370029434826225, 0.1961121050212704, 0.23440473552516705, 0.23937541738103296, 0.22831710711194575, 0.22093648094886165, 0.21247098632357708, 0.23711015061346374, 0.23252392387343845, 0.23377643810953797, 0.14975284935083932, 0.16097825884214, 0.16704357853006602, 0.18889952074192484, 0.17349149059467595, 0.1691686501862416, 0.15520194549672883, 0.16348990107485717, 0.17945107357168633, 0.19364739053970847, 0.15356862951293637, 0.17370250767753792, 0.20059425292310384, 0.19602090969749963, 0.14066070046978807, 0.18102813170673193, 0.16650308300720484, 0.18928849687535354, 0.1732245677531371, 0.17818101179327228, 0.16321835518312455, 0.16373601761018586, 0.17158466727112065, 0.16276296956595138, 0.1692362565674288, 0.165954182036414, 0.16586609770808058, 0.1622276765383529, 0.34395331767954784, 0.323024575714681, 0.4571018665533527, 0.5149776622469469, 0.4289540259305501, 0.3661701711208478, 0.4579527784302184, 0.19224777869399245, 0.3271757443032106, 0.2145532415980681, 0.3857806375586642, 0.19088534127060452, 0.31892286118134217, 0.1609857513492814, 0.14687505565686387, 0.5459871018788822, 0.2053014992234773, 0.16857250003754598, 0.15955366812455907, 0.16354192119690192, 0.15781934089886562, 0.18683168487806356, 0.15776603567149527, 0.16379411855922466, 0.18809064021099153, 0.16737483514063756, 0.07037073394088822, 0.08531810785188843, 0.08224504330605831, 0.06912552927297888, 0.06783775628282929, 0.08665465008178075, 0.06023481388061469, 0.05983977189544798, 0.051360474392294075]}, "mutation_prompt": null}
{"id": "a9cd5045-4f63-4c44-aa24-dd6bd5bf591e", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Opposition-based learning\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Adaptive Differential Evolution with Opposition-Based Learning to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4e366d7f-af5f-41d2-8330-dcaf9a6ec793", "metadata": {"aucs": [0.3953887654942515, 0.3673853150917803, 0.4015141419168222, 0.38691621601588355, 0.36558300916960806, 0.4078054533056549, 0.390978413505908, 0.3939860098913033, 0.39737159202174155, 0.16554857060365524, 0.14279951361767562, 0.1444461351441414, 0.16780362996903242, 0.15545250824501677, 0.18411480924601553, 0.14375692732494005, 0.15755539117616757, 0.12439084175817627, 0.07356643837521004, 0.07866507351836904, 0.08482325687926917, 0.07200814249639609, 0.07518126213305076, 0.08282286765141611, 0.09021432684285724, 0.07004591094979495, 0.0775905441051733, 0.0649686319237871, 0.06362919958941726, 0.07423678276343837, 0.07991659907937554, 0.06374969185629309, 0.07687221061589589, 0.06835397260270659, 0.07081682525205857, 0.06993858381832363, 0.890627344764051, 0.8847486214361704, 0.866347619123138, 0.7746414787496099, 0.8946355921595175, 0.8501296673269789, 0.8829343813424441, 0.7927987209046685, 0.8541346379837693, 0.17158488620476164, 0.1486191847230961, 0.1732351903540752, 0.15674566399544343, 0.1634116293298652, 0.1882016612086196, 0.167739783112682, 0.17886329208994034, 0.16901384505426853, 0.30686440428745987, 0.25087814405340125, 0.26696723562282554, 0.2536688278049203, 0.2608171755542057, 0.23803466233286852, 0.24286278963409658, 0.23546258208083704, 0.23273180387468595, 0.12502300933140686, 0.11922347167796066, 0.13235366262499215, 0.10614524428799654, 0.09372695836114076, 0.11255746570372027, 0.11333593038045042, 0.09779524801739592, 0.1170446378202229, 0.26409842554969687, 0.2541915856405833, 0.20966107550461488, 0.30480850319389774, 0.3528199471282505, 0.3075732386053657, 0.3635111928753265, 0.24596953261991528, 0.30654321800993845, 0.021707520105609945, 0.034314539124152166, 0.004023841120278648, 0.015480171594729475, 0.02816251329522601, 0.008520488698637974, 0.0493776610258132, 0.049594329625022526, 0.04216685716844826, 0.1473530797382584, 0.1046334933855565, 0.13841338914224777, 0.1295790646048579, 0.09301291294719904, 0.12707664204013125, 0.13869675554596395, 0.12662477552317364, 0.14417444586644945, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011544560095789747, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004217768571194158, 0.004203066948815781, 0.0023247573093938545, 0.0705833923396112, 0.06720968672431771, 0.07890858868259565, 0.07762140771623349, 0.06989061396305274, 0.07883463007400315, 0.060312509554366844, 0.09776386652012847, 0.08067472817706256, 0.32298375144979574, 0.3437536201145551, 0.3392201303813561, 0.3723875308901231, 0.35056836488308984, 0.3623794294296926, 0.3716555409941448, 0.35686715360954246, 0.3532102429695224, 0.06747570089169863, 0.07806850163170254, 0.0916977577207555, 0.07973452719480278, 0.08103358594515409, 0.06797217689560553, 0.07046666987550165, 0.08592555259729884, 0.08191382020400928, 0.221259178827224, 0.17989387552512015, 0.19339772339803152, 0.16449730412783115, 0.11728273808272338, 0.14487030235726028, 0.10585028279010766, 0.13877501797570024, 0.13370029434826225, 0.1961121050212704, 0.23440473552516705, 0.23937541738103296, 0.22831710711194575, 0.22093648094886165, 0.21247098632357708, 0.23711015061346374, 0.23252392387343845, 0.23377643810953797, 0.14975284935083932, 0.16097825884214, 0.16704357853006602, 0.18889952074192484, 0.17349149059467595, 0.1691686501862416, 0.15520194549672883, 0.16348990107485717, 0.17945107357168633, 0.19364739053970847, 0.15356862951293637, 0.17370250767753792, 0.20059425292310384, 0.19602090969749963, 0.14066070046978807, 0.18102813170673193, 0.16650308300720484, 0.18928849687535354, 0.1732245677531371, 0.17818101179327228, 0.16321835518312455, 0.16373601761018586, 0.17158466727112065, 0.16276296956595138, 0.1692362565674288, 0.165954182036414, 0.16586609770808058, 0.1622276765383529, 0.34395331767954784, 0.323024575714681, 0.4571018665533527, 0.5149776622469469, 0.4289540259305501, 0.3661701711208478, 0.4579527784302184, 0.19224777869399245, 0.3271757443032106, 0.2145532415980681, 0.3857806375586642, 0.19088534127060452, 0.31892286118134217, 0.1609857513492814, 0.14687505565686387, 0.5459871018788822, 0.2053014992234773, 0.16857250003754598, 0.15955366812455907, 0.16354192119690192, 0.15781934089886562, 0.18683168487806356, 0.15776603567149527, 0.16379411855922466, 0.18809064021099153, 0.16737483514063756, 0.07037073394088822, 0.08531810785188843, 0.08224504330605831, 0.06912552927297888, 0.06783775628282929, 0.08665465008178075, 0.06023481388061469, 0.05983977189544798, 0.051360474392294075]}, "mutation_prompt": null}
{"id": "844d6b18-49a1-453f-9242-12734a986ba7", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Opposition-based learning\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Adaptive Differential Evolution with Opposition-Based Learning to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4e366d7f-af5f-41d2-8330-dcaf9a6ec793", "metadata": {"aucs": [0.3953887654942515, 0.3673853150917803, 0.4015141419168222, 0.38691621601588355, 0.36558300916960806, 0.4078054533056549, 0.390978413505908, 0.3939860098913033, 0.39737159202174155, 0.16554857060365524, 0.14279951361767562, 0.1444461351441414, 0.16780362996903242, 0.15545250824501677, 0.18411480924601553, 0.14375692732494005, 0.15755539117616757, 0.12439084175817627, 0.07356643837521004, 0.07866507351836904, 0.08482325687926917, 0.07200814249639609, 0.07518126213305076, 0.08282286765141611, 0.09021432684285724, 0.07004591094979495, 0.0775905441051733, 0.0649686319237871, 0.06362919958941726, 0.07423678276343837, 0.07991659907937554, 0.06374969185629309, 0.07687221061589589, 0.06835397260270659, 0.07081682525205857, 0.06993858381832363, 0.890627344764051, 0.8847486214361704, 0.866347619123138, 0.7746414787496099, 0.8946355921595175, 0.8501296673269789, 0.8829343813424441, 0.7927987209046685, 0.8541346379837693, 0.17158488620476164, 0.1486191847230961, 0.1732351903540752, 0.15674566399544343, 0.1634116293298652, 0.1882016612086196, 0.167739783112682, 0.17886329208994034, 0.16901384505426853, 0.30686440428745987, 0.25087814405340125, 0.26696723562282554, 0.2536688278049203, 0.2608171755542057, 0.23803466233286852, 0.24286278963409658, 0.23546258208083704, 0.23273180387468595, 0.12502300933140686, 0.11922347167796066, 0.13235366262499215, 0.10614524428799654, 0.09372695836114076, 0.11255746570372027, 0.11333593038045042, 0.09779524801739592, 0.1170446378202229, 0.26409842554969687, 0.2541915856405833, 0.20966107550461488, 0.30480850319389774, 0.3528199471282505, 0.3075732386053657, 0.3635111928753265, 0.24596953261991528, 0.30654321800993845, 0.021707520105609945, 0.034314539124152166, 0.004023841120278648, 0.015480171594729475, 0.02816251329522601, 0.008520488698637974, 0.0493776610258132, 0.049594329625022526, 0.04216685716844826, 0.1473530797382584, 0.1046334933855565, 0.13841338914224777, 0.1295790646048579, 0.09301291294719904, 0.12707664204013125, 0.13869675554596395, 0.12662477552317364, 0.14417444586644945, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011544560095789747, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004217768571194158, 0.004203066948815781, 0.0023247573093938545, 0.0705833923396112, 0.06720968672431771, 0.07890858868259565, 0.07762140771623349, 0.06989061396305274, 0.07883463007400315, 0.060312509554366844, 0.09776386652012847, 0.08067472817706256, 0.32298375144979574, 0.3437536201145551, 0.3392201303813561, 0.3723875308901231, 0.35056836488308984, 0.3623794294296926, 0.3716555409941448, 0.35686715360954246, 0.3532102429695224, 0.06747570089169863, 0.07806850163170254, 0.0916977577207555, 0.07973452719480278, 0.08103358594515409, 0.06797217689560553, 0.07046666987550165, 0.08592555259729884, 0.08191382020400928, 0.221259178827224, 0.17989387552512015, 0.19339772339803152, 0.16449730412783115, 0.11728273808272338, 0.14487030235726028, 0.10585028279010766, 0.13877501797570024, 0.13370029434826225, 0.1961121050212704, 0.23440473552516705, 0.23937541738103296, 0.22831710711194575, 0.22093648094886165, 0.21247098632357708, 0.23711015061346374, 0.23252392387343845, 0.23377643810953797, 0.14975284935083932, 0.16097825884214, 0.16704357853006602, 0.18889952074192484, 0.17349149059467595, 0.1691686501862416, 0.15520194549672883, 0.16348990107485717, 0.17945107357168633, 0.19364739053970847, 0.15356862951293637, 0.17370250767753792, 0.20059425292310384, 0.19602090969749963, 0.14066070046978807, 0.18102813170673193, 0.16650308300720484, 0.18928849687535354, 0.1732245677531371, 0.17818101179327228, 0.16321835518312455, 0.16373601761018586, 0.17158466727112065, 0.16276296956595138, 0.1692362565674288, 0.165954182036414, 0.16586609770808058, 0.1622276765383529, 0.34395331767954784, 0.323024575714681, 0.4571018665533527, 0.5149776622469469, 0.4289540259305501, 0.3661701711208478, 0.4579527784302184, 0.19224777869399245, 0.3271757443032106, 0.2145532415980681, 0.3857806375586642, 0.19088534127060452, 0.31892286118134217, 0.1609857513492814, 0.14687505565686387, 0.5459871018788822, 0.2053014992234773, 0.16857250003754598, 0.15955366812455907, 0.16354192119690192, 0.15781934089886562, 0.18683168487806356, 0.15776603567149527, 0.16379411855922466, 0.18809064021099153, 0.16737483514063756, 0.07037073394088822, 0.08531810785188843, 0.08224504330605831, 0.06912552927297888, 0.06783775628282929, 0.08665465008178075, 0.06023481388061469, 0.05983977189544798, 0.051360474392294075]}, "mutation_prompt": null}
{"id": "615ed87c-c104-4bb7-b6cc-b992909b8734", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Opposition-based learning\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Adaptive Differential Evolution with Opposition-Based Learning to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4e366d7f-af5f-41d2-8330-dcaf9a6ec793", "metadata": {"aucs": [0.3953887654942515, 0.3673853150917803, 0.4015141419168222, 0.38691621601588355, 0.36558300916960806, 0.4078054533056549, 0.390978413505908, 0.3939860098913033, 0.39737159202174155, 0.16554857060365524, 0.14279951361767562, 0.1444461351441414, 0.16780362996903242, 0.15545250824501677, 0.18411480924601553, 0.14375692732494005, 0.15755539117616757, 0.12439084175817627, 0.07356643837521004, 0.07866507351836904, 0.08482325687926917, 0.07200814249639609, 0.07518126213305076, 0.08282286765141611, 0.09021432684285724, 0.07004591094979495, 0.0775905441051733, 0.0649686319237871, 0.06362919958941726, 0.07423678276343837, 0.07991659907937554, 0.06374969185629309, 0.07687221061589589, 0.06835397260270659, 0.07081682525205857, 0.06993858381832363, 0.890627344764051, 0.8847486214361704, 0.866347619123138, 0.7746414787496099, 0.8946355921595175, 0.8501296673269789, 0.8829343813424441, 0.7927987209046685, 0.8541346379837693, 0.17158488620476164, 0.1486191847230961, 0.1732351903540752, 0.15674566399544343, 0.1634116293298652, 0.1882016612086196, 0.167739783112682, 0.17886329208994034, 0.16901384505426853, 0.30686440428745987, 0.25087814405340125, 0.26696723562282554, 0.2536688278049203, 0.2608171755542057, 0.23803466233286852, 0.24286278963409658, 0.23546258208083704, 0.23273180387468595, 0.12502300933140686, 0.11922347167796066, 0.13235366262499215, 0.10614524428799654, 0.09372695836114076, 0.11255746570372027, 0.11333593038045042, 0.09779524801739592, 0.1170446378202229, 0.26409842554969687, 0.2541915856405833, 0.20966107550461488, 0.30480850319389774, 0.3528199471282505, 0.3075732386053657, 0.3635111928753265, 0.24596953261991528, 0.30654321800993845, 0.021707520105609945, 0.034314539124152166, 0.004023841120278648, 0.015480171594729475, 0.02816251329522601, 0.008520488698637974, 0.0493776610258132, 0.049594329625022526, 0.04216685716844826, 0.1473530797382584, 0.1046334933855565, 0.13841338914224777, 0.1295790646048579, 0.09301291294719904, 0.12707664204013125, 0.13869675554596395, 0.12662477552317364, 0.14417444586644945, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011544560095789747, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004217768571194158, 0.004203066948815781, 0.0023247573093938545, 0.0705833923396112, 0.06720968672431771, 0.07890858868259565, 0.07762140771623349, 0.06989061396305274, 0.07883463007400315, 0.060312509554366844, 0.09776386652012847, 0.08067472817706256, 0.32298375144979574, 0.3437536201145551, 0.3392201303813561, 0.3723875308901231, 0.35056836488308984, 0.3623794294296926, 0.3716555409941448, 0.35686715360954246, 0.3532102429695224, 0.06747570089169863, 0.07806850163170254, 0.0916977577207555, 0.07973452719480278, 0.08103358594515409, 0.06797217689560553, 0.07046666987550165, 0.08592555259729884, 0.08191382020400928, 0.221259178827224, 0.17989387552512015, 0.19339772339803152, 0.16449730412783115, 0.11728273808272338, 0.14487030235726028, 0.10585028279010766, 0.13877501797570024, 0.13370029434826225, 0.1961121050212704, 0.23440473552516705, 0.23937541738103296, 0.22831710711194575, 0.22093648094886165, 0.21247098632357708, 0.23711015061346374, 0.23252392387343845, 0.23377643810953797, 0.14975284935083932, 0.16097825884214, 0.16704357853006602, 0.18889952074192484, 0.17349149059467595, 0.1691686501862416, 0.15520194549672883, 0.16348990107485717, 0.17945107357168633, 0.19364739053970847, 0.15356862951293637, 0.17370250767753792, 0.20059425292310384, 0.19602090969749963, 0.14066070046978807, 0.18102813170673193, 0.16650308300720484, 0.18928849687535354, 0.1732245677531371, 0.17818101179327228, 0.16321835518312455, 0.16373601761018586, 0.17158466727112065, 0.16276296956595138, 0.1692362565674288, 0.165954182036414, 0.16586609770808058, 0.1622276765383529, 0.34395331767954784, 0.323024575714681, 0.4571018665533527, 0.5149776622469469, 0.4289540259305501, 0.3661701711208478, 0.4579527784302184, 0.19224777869399245, 0.3271757443032106, 0.2145532415980681, 0.3857806375586642, 0.19088534127060452, 0.31892286118134217, 0.1609857513492814, 0.14687505565686387, 0.5459871018788822, 0.2053014992234773, 0.16857250003754598, 0.15955366812455907, 0.16354192119690192, 0.15781934089886562, 0.18683168487806356, 0.15776603567149527, 0.16379411855922466, 0.18809064021099153, 0.16737483514063756, 0.07037073394088822, 0.08531810785188843, 0.08224504330605831, 0.06912552927297888, 0.06783775628282929, 0.08665465008178075, 0.06023481388061469, 0.05983977189544798, 0.051360474392294075]}, "mutation_prompt": null}
{"id": "309aac27-0316-4143-9150-023e55571f6b", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Opposition-based learning\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Adaptive Differential Evolution with Opposition-Based Learning to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4e366d7f-af5f-41d2-8330-dcaf9a6ec793", "metadata": {"aucs": [0.3953887654942515, 0.3673853150917803, 0.4015141419168222, 0.38691621601588355, 0.36558300916960806, 0.4078054533056549, 0.390978413505908, 0.3939860098913033, 0.39737159202174155, 0.16554857060365524, 0.14279951361767562, 0.1444461351441414, 0.16780362996903242, 0.15545250824501677, 0.18411480924601553, 0.14375692732494005, 0.15755539117616757, 0.12439084175817627, 0.07356643837521004, 0.07866507351836904, 0.08482325687926917, 0.07200814249639609, 0.07518126213305076, 0.08282286765141611, 0.09021432684285724, 0.07004591094979495, 0.0775905441051733, 0.0649686319237871, 0.06362919958941726, 0.07423678276343837, 0.07991659907937554, 0.06374969185629309, 0.07687221061589589, 0.06835397260270659, 0.07081682525205857, 0.06993858381832363, 0.890627344764051, 0.8847486214361704, 0.866347619123138, 0.7746414787496099, 0.8946355921595175, 0.8501296673269789, 0.8829343813424441, 0.7927987209046685, 0.8541346379837693, 0.17158488620476164, 0.1486191847230961, 0.1732351903540752, 0.15674566399544343, 0.1634116293298652, 0.1882016612086196, 0.167739783112682, 0.17886329208994034, 0.16901384505426853, 0.30686440428745987, 0.25087814405340125, 0.26696723562282554, 0.2536688278049203, 0.2608171755542057, 0.23803466233286852, 0.24286278963409658, 0.23546258208083704, 0.23273180387468595, 0.12502300933140686, 0.11922347167796066, 0.13235366262499215, 0.10614524428799654, 0.09372695836114076, 0.11255746570372027, 0.11333593038045042, 0.09779524801739592, 0.1170446378202229, 0.26409842554969687, 0.2541915856405833, 0.20966107550461488, 0.30480850319389774, 0.3528199471282505, 0.3075732386053657, 0.3635111928753265, 0.24596953261991528, 0.30654321800993845, 0.021707520105609945, 0.034314539124152166, 0.004023841120278648, 0.015480171594729475, 0.02816251329522601, 0.008520488698637974, 0.0493776610258132, 0.049594329625022526, 0.04216685716844826, 0.1473530797382584, 0.1046334933855565, 0.13841338914224777, 0.1295790646048579, 0.09301291294719904, 0.12707664204013125, 0.13869675554596395, 0.12662477552317364, 0.14417444586644945, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011544560095789747, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004217768571194158, 0.004203066948815781, 0.0023247573093938545, 0.0705833923396112, 0.06720968672431771, 0.07890858868259565, 0.07762140771623349, 0.06989061396305274, 0.07883463007400315, 0.060312509554366844, 0.09776386652012847, 0.08067472817706256, 0.32298375144979574, 0.3437536201145551, 0.3392201303813561, 0.3723875308901231, 0.35056836488308984, 0.3623794294296926, 0.3716555409941448, 0.35686715360954246, 0.3532102429695224, 0.06747570089169863, 0.07806850163170254, 0.0916977577207555, 0.07973452719480278, 0.08103358594515409, 0.06797217689560553, 0.07046666987550165, 0.08592555259729884, 0.08191382020400928, 0.221259178827224, 0.17989387552512015, 0.19339772339803152, 0.16449730412783115, 0.11728273808272338, 0.14487030235726028, 0.10585028279010766, 0.13877501797570024, 0.13370029434826225, 0.1961121050212704, 0.23440473552516705, 0.23937541738103296, 0.22831710711194575, 0.22093648094886165, 0.21247098632357708, 0.23711015061346374, 0.23252392387343845, 0.23377643810953797, 0.14975284935083932, 0.16097825884214, 0.16704357853006602, 0.18889952074192484, 0.17349149059467595, 0.1691686501862416, 0.15520194549672883, 0.16348990107485717, 0.17945107357168633, 0.19364739053970847, 0.15356862951293637, 0.17370250767753792, 0.20059425292310384, 0.19602090969749963, 0.14066070046978807, 0.18102813170673193, 0.16650308300720484, 0.18928849687535354, 0.1732245677531371, 0.17818101179327228, 0.16321835518312455, 0.16373601761018586, 0.17158466727112065, 0.16276296956595138, 0.1692362565674288, 0.165954182036414, 0.16586609770808058, 0.1622276765383529, 0.34395331767954784, 0.323024575714681, 0.4571018665533527, 0.5149776622469469, 0.4289540259305501, 0.3661701711208478, 0.4579527784302184, 0.19224777869399245, 0.3271757443032106, 0.2145532415980681, 0.3857806375586642, 0.19088534127060452, 0.31892286118134217, 0.1609857513492814, 0.14687505565686387, 0.5459871018788822, 0.2053014992234773, 0.16857250003754598, 0.15955366812455907, 0.16354192119690192, 0.15781934089886562, 0.18683168487806356, 0.15776603567149527, 0.16379411855922466, 0.18809064021099153, 0.16737483514063756, 0.07037073394088822, 0.08531810785188843, 0.08224504330605831, 0.06912552927297888, 0.06783775628282929, 0.08665465008178075, 0.06023481388061469, 0.05983977189544798, 0.051360474392294075]}, "mutation_prompt": null}
{"id": "1810cdd2-fff0-4f71-9cde-dcda96675c96", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Opposition-based learning\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Adaptive Differential Evolution with Opposition-Based Learning to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4e366d7f-af5f-41d2-8330-dcaf9a6ec793", "metadata": {"aucs": [0.3953887654942515, 0.3673853150917803, 0.4015141419168222, 0.38691621601588355, 0.36558300916960806, 0.4078054533056549, 0.390978413505908, 0.3939860098913033, 0.39737159202174155, 0.16554857060365524, 0.14279951361767562, 0.1444461351441414, 0.16780362996903242, 0.15545250824501677, 0.18411480924601553, 0.14375692732494005, 0.15755539117616757, 0.12439084175817627, 0.07356643837521004, 0.07866507351836904, 0.08482325687926917, 0.07200814249639609, 0.07518126213305076, 0.08282286765141611, 0.09021432684285724, 0.07004591094979495, 0.0775905441051733, 0.0649686319237871, 0.06362919958941726, 0.07423678276343837, 0.07991659907937554, 0.06374969185629309, 0.07687221061589589, 0.06835397260270659, 0.07081682525205857, 0.06993858381832363, 0.890627344764051, 0.8847486214361704, 0.866347619123138, 0.7746414787496099, 0.8946355921595175, 0.8501296673269789, 0.8829343813424441, 0.7927987209046685, 0.8541346379837693, 0.17158488620476164, 0.1486191847230961, 0.1732351903540752, 0.15674566399544343, 0.1634116293298652, 0.1882016612086196, 0.167739783112682, 0.17886329208994034, 0.16901384505426853, 0.30686440428745987, 0.25087814405340125, 0.26696723562282554, 0.2536688278049203, 0.2608171755542057, 0.23803466233286852, 0.24286278963409658, 0.23546258208083704, 0.23273180387468595, 0.12502300933140686, 0.11922347167796066, 0.13235366262499215, 0.10614524428799654, 0.09372695836114076, 0.11255746570372027, 0.11333593038045042, 0.09779524801739592, 0.1170446378202229, 0.26409842554969687, 0.2541915856405833, 0.20966107550461488, 0.30480850319389774, 0.3528199471282505, 0.3075732386053657, 0.3635111928753265, 0.24596953261991528, 0.30654321800993845, 0.021707520105609945, 0.034314539124152166, 0.004023841120278648, 0.015480171594729475, 0.02816251329522601, 0.008520488698637974, 0.0493776610258132, 0.049594329625022526, 0.04216685716844826, 0.1473530797382584, 0.1046334933855565, 0.13841338914224777, 0.1295790646048579, 0.09301291294719904, 0.12707664204013125, 0.13869675554596395, 0.12662477552317364, 0.14417444586644945, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011544560095789747, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004217768571194158, 0.004203066948815781, 0.0023247573093938545, 0.0705833923396112, 0.06720968672431771, 0.07890858868259565, 0.07762140771623349, 0.06989061396305274, 0.07883463007400315, 0.060312509554366844, 0.09776386652012847, 0.08067472817706256, 0.32298375144979574, 0.3437536201145551, 0.3392201303813561, 0.3723875308901231, 0.35056836488308984, 0.3623794294296926, 0.3716555409941448, 0.35686715360954246, 0.3532102429695224, 0.06747570089169863, 0.07806850163170254, 0.0916977577207555, 0.07973452719480278, 0.08103358594515409, 0.06797217689560553, 0.07046666987550165, 0.08592555259729884, 0.08191382020400928, 0.221259178827224, 0.17989387552512015, 0.19339772339803152, 0.16449730412783115, 0.11728273808272338, 0.14487030235726028, 0.10585028279010766, 0.13877501797570024, 0.13370029434826225, 0.1961121050212704, 0.23440473552516705, 0.23937541738103296, 0.22831710711194575, 0.22093648094886165, 0.21247098632357708, 0.23711015061346374, 0.23252392387343845, 0.23377643810953797, 0.14975284935083932, 0.16097825884214, 0.16704357853006602, 0.18889952074192484, 0.17349149059467595, 0.1691686501862416, 0.15520194549672883, 0.16348990107485717, 0.17945107357168633, 0.19364739053970847, 0.15356862951293637, 0.17370250767753792, 0.20059425292310384, 0.19602090969749963, 0.14066070046978807, 0.18102813170673193, 0.16650308300720484, 0.18928849687535354, 0.1732245677531371, 0.17818101179327228, 0.16321835518312455, 0.16373601761018586, 0.17158466727112065, 0.16276296956595138, 0.1692362565674288, 0.165954182036414, 0.16586609770808058, 0.1622276765383529, 0.34395331767954784, 0.323024575714681, 0.4571018665533527, 0.5149776622469469, 0.4289540259305501, 0.3661701711208478, 0.4579527784302184, 0.19224777869399245, 0.3271757443032106, 0.2145532415980681, 0.3857806375586642, 0.19088534127060452, 0.31892286118134217, 0.1609857513492814, 0.14687505565686387, 0.5459871018788822, 0.2053014992234773, 0.16857250003754598, 0.15955366812455907, 0.16354192119690192, 0.15781934089886562, 0.18683168487806356, 0.15776603567149527, 0.16379411855922466, 0.18809064021099153, 0.16737483514063756, 0.07037073394088822, 0.08531810785188843, 0.08224504330605831, 0.06912552927297888, 0.06783775628282929, 0.08665465008178075, 0.06023481388061469, 0.05983977189544798, 0.051360474392294075]}, "mutation_prompt": null}
{"id": "8b2fc977-15fb-4a2a-8dfb-1b93b7b51a0e", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Opposition-based learning\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Adaptive Differential Evolution with Opposition-Based Learning to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4e366d7f-af5f-41d2-8330-dcaf9a6ec793", "metadata": {"aucs": [0.3953887654942515, 0.3673853150917803, 0.4015141419168222, 0.38691621601588355, 0.36558300916960806, 0.4078054533056549, 0.390978413505908, 0.3939860098913033, 0.39737159202174155, 0.16554857060365524, 0.14279951361767562, 0.1444461351441414, 0.16780362996903242, 0.15545250824501677, 0.18411480924601553, 0.14375692732494005, 0.15755539117616757, 0.12439084175817627, 0.07356643837521004, 0.07866507351836904, 0.08482325687926917, 0.07200814249639609, 0.07518126213305076, 0.08282286765141611, 0.09021432684285724, 0.07004591094979495, 0.0775905441051733, 0.0649686319237871, 0.06362919958941726, 0.07423678276343837, 0.07991659907937554, 0.06374969185629309, 0.07687221061589589, 0.06835397260270659, 0.07081682525205857, 0.06993858381832363, 0.890627344764051, 0.8847486214361704, 0.866347619123138, 0.7746414787496099, 0.8946355921595175, 0.8501296673269789, 0.8829343813424441, 0.7927987209046685, 0.8541346379837693, 0.17158488620476164, 0.1486191847230961, 0.1732351903540752, 0.15674566399544343, 0.1634116293298652, 0.1882016612086196, 0.167739783112682, 0.17886329208994034, 0.16901384505426853, 0.30686440428745987, 0.25087814405340125, 0.26696723562282554, 0.2536688278049203, 0.2608171755542057, 0.23803466233286852, 0.24286278963409658, 0.23546258208083704, 0.23273180387468595, 0.12502300933140686, 0.11922347167796066, 0.13235366262499215, 0.10614524428799654, 0.09372695836114076, 0.11255746570372027, 0.11333593038045042, 0.09779524801739592, 0.1170446378202229, 0.26409842554969687, 0.2541915856405833, 0.20966107550461488, 0.30480850319389774, 0.3528199471282505, 0.3075732386053657, 0.3635111928753265, 0.24596953261991528, 0.30654321800993845, 0.021707520105609945, 0.034314539124152166, 0.004023841120278648, 0.015480171594729475, 0.02816251329522601, 0.008520488698637974, 0.0493776610258132, 0.049594329625022526, 0.04216685716844826, 0.1473530797382584, 0.1046334933855565, 0.13841338914224777, 0.1295790646048579, 0.09301291294719904, 0.12707664204013125, 0.13869675554596395, 0.12662477552317364, 0.14417444586644945, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011544560095789747, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004217768571194158, 0.004203066948815781, 0.0023247573093938545, 0.0705833923396112, 0.06720968672431771, 0.07890858868259565, 0.07762140771623349, 0.06989061396305274, 0.07883463007400315, 0.060312509554366844, 0.09776386652012847, 0.08067472817706256, 0.32298375144979574, 0.3437536201145551, 0.3392201303813561, 0.3723875308901231, 0.35056836488308984, 0.3623794294296926, 0.3716555409941448, 0.35686715360954246, 0.3532102429695224, 0.06747570089169863, 0.07806850163170254, 0.0916977577207555, 0.07973452719480278, 0.08103358594515409, 0.06797217689560553, 0.07046666987550165, 0.08592555259729884, 0.08191382020400928, 0.221259178827224, 0.17989387552512015, 0.19339772339803152, 0.16449730412783115, 0.11728273808272338, 0.14487030235726028, 0.10585028279010766, 0.13877501797570024, 0.13370029434826225, 0.1961121050212704, 0.23440473552516705, 0.23937541738103296, 0.22831710711194575, 0.22093648094886165, 0.21247098632357708, 0.23711015061346374, 0.23252392387343845, 0.23377643810953797, 0.14975284935083932, 0.16097825884214, 0.16704357853006602, 0.18889952074192484, 0.17349149059467595, 0.1691686501862416, 0.15520194549672883, 0.16348990107485717, 0.17945107357168633, 0.19364739053970847, 0.15356862951293637, 0.17370250767753792, 0.20059425292310384, 0.19602090969749963, 0.14066070046978807, 0.18102813170673193, 0.16650308300720484, 0.18928849687535354, 0.1732245677531371, 0.17818101179327228, 0.16321835518312455, 0.16373601761018586, 0.17158466727112065, 0.16276296956595138, 0.1692362565674288, 0.165954182036414, 0.16586609770808058, 0.1622276765383529, 0.34395331767954784, 0.323024575714681, 0.4571018665533527, 0.5149776622469469, 0.4289540259305501, 0.3661701711208478, 0.4579527784302184, 0.19224777869399245, 0.3271757443032106, 0.2145532415980681, 0.3857806375586642, 0.19088534127060452, 0.31892286118134217, 0.1609857513492814, 0.14687505565686387, 0.5459871018788822, 0.2053014992234773, 0.16857250003754598, 0.15955366812455907, 0.16354192119690192, 0.15781934089886562, 0.18683168487806356, 0.15776603567149527, 0.16379411855922466, 0.18809064021099153, 0.16737483514063756, 0.07037073394088822, 0.08531810785188843, 0.08224504330605831, 0.06912552927297888, 0.06783775628282929, 0.08665465008178075, 0.06023481388061469, 0.05983977189544798, 0.051360474392294075]}, "mutation_prompt": null}
{"id": "a31f6104-0691-444c-8682-4df23dae0c83", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Opposition-based learning\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Adaptive Differential Evolution with Opposition-Based Learning to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4e366d7f-af5f-41d2-8330-dcaf9a6ec793", "metadata": {"aucs": [0.3953887654942515, 0.3673853150917803, 0.4015141419168222, 0.38691621601588355, 0.36558300916960806, 0.4078054533056549, 0.390978413505908, 0.3939860098913033, 0.39737159202174155, 0.16554857060365524, 0.14279951361767562, 0.1444461351441414, 0.16780362996903242, 0.15545250824501677, 0.18411480924601553, 0.14375692732494005, 0.15755539117616757, 0.12439084175817627, 0.07356643837521004, 0.07866507351836904, 0.08482325687926917, 0.07200814249639609, 0.07518126213305076, 0.08282286765141611, 0.09021432684285724, 0.07004591094979495, 0.0775905441051733, 0.0649686319237871, 0.06362919958941726, 0.07423678276343837, 0.07991659907937554, 0.06374969185629309, 0.07687221061589589, 0.06835397260270659, 0.07081682525205857, 0.06993858381832363, 0.890627344764051, 0.8847486214361704, 0.866347619123138, 0.7746414787496099, 0.8946355921595175, 0.8501296673269789, 0.8829343813424441, 0.7927987209046685, 0.8541346379837693, 0.17158488620476164, 0.1486191847230961, 0.1732351903540752, 0.15674566399544343, 0.1634116293298652, 0.1882016612086196, 0.167739783112682, 0.17886329208994034, 0.16901384505426853, 0.30686440428745987, 0.25087814405340125, 0.26696723562282554, 0.2536688278049203, 0.2608171755542057, 0.23803466233286852, 0.24286278963409658, 0.23546258208083704, 0.23273180387468595, 0.12502300933140686, 0.11922347167796066, 0.13235366262499215, 0.10614524428799654, 0.09372695836114076, 0.11255746570372027, 0.11333593038045042, 0.09779524801739592, 0.1170446378202229, 0.26409842554969687, 0.2541915856405833, 0.20966107550461488, 0.30480850319389774, 0.3528199471282505, 0.3075732386053657, 0.3635111928753265, 0.24596953261991528, 0.30654321800993845, 0.021707520105609945, 0.034314539124152166, 0.004023841120278648, 0.015480171594729475, 0.02816251329522601, 0.008520488698637974, 0.0493776610258132, 0.049594329625022526, 0.04216685716844826, 0.1473530797382584, 0.1046334933855565, 0.13841338914224777, 0.1295790646048579, 0.09301291294719904, 0.12707664204013125, 0.13869675554596395, 0.12662477552317364, 0.14417444586644945, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011544560095789747, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004217768571194158, 0.004203066948815781, 0.0023247573093938545, 0.0705833923396112, 0.06720968672431771, 0.07890858868259565, 0.07762140771623349, 0.06989061396305274, 0.07883463007400315, 0.060312509554366844, 0.09776386652012847, 0.08067472817706256, 0.32298375144979574, 0.3437536201145551, 0.3392201303813561, 0.3723875308901231, 0.35056836488308984, 0.3623794294296926, 0.3716555409941448, 0.35686715360954246, 0.3532102429695224, 0.06747570089169863, 0.07806850163170254, 0.0916977577207555, 0.07973452719480278, 0.08103358594515409, 0.06797217689560553, 0.07046666987550165, 0.08592555259729884, 0.08191382020400928, 0.221259178827224, 0.17989387552512015, 0.19339772339803152, 0.16449730412783115, 0.11728273808272338, 0.14487030235726028, 0.10585028279010766, 0.13877501797570024, 0.13370029434826225, 0.1961121050212704, 0.23440473552516705, 0.23937541738103296, 0.22831710711194575, 0.22093648094886165, 0.21247098632357708, 0.23711015061346374, 0.23252392387343845, 0.23377643810953797, 0.14975284935083932, 0.16097825884214, 0.16704357853006602, 0.18889952074192484, 0.17349149059467595, 0.1691686501862416, 0.15520194549672883, 0.16348990107485717, 0.17945107357168633, 0.19364739053970847, 0.15356862951293637, 0.17370250767753792, 0.20059425292310384, 0.19602090969749963, 0.14066070046978807, 0.18102813170673193, 0.16650308300720484, 0.18928849687535354, 0.1732245677531371, 0.17818101179327228, 0.16321835518312455, 0.16373601761018586, 0.17158466727112065, 0.16276296956595138, 0.1692362565674288, 0.165954182036414, 0.16586609770808058, 0.1622276765383529, 0.34395331767954784, 0.323024575714681, 0.4571018665533527, 0.5149776622469469, 0.4289540259305501, 0.3661701711208478, 0.4579527784302184, 0.19224777869399245, 0.3271757443032106, 0.2145532415980681, 0.3857806375586642, 0.19088534127060452, 0.31892286118134217, 0.1609857513492814, 0.14687505565686387, 0.5459871018788822, 0.2053014992234773, 0.16857250003754598, 0.15955366812455907, 0.16354192119690192, 0.15781934089886562, 0.18683168487806356, 0.15776603567149527, 0.16379411855922466, 0.18809064021099153, 0.16737483514063756, 0.07037073394088822, 0.08531810785188843, 0.08224504330605831, 0.06912552927297888, 0.06783775628282929, 0.08665465008178075, 0.06023481388061469, 0.05983977189544798, 0.051360474392294075]}, "mutation_prompt": null}
{"id": "e344f0e7-5867-440b-a2b2-83f317e0dd26", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Opposition-based learning\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Adaptive Differential Evolution with Opposition-Based Learning to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4e366d7f-af5f-41d2-8330-dcaf9a6ec793", "metadata": {"aucs": [0.3953887654942515, 0.3673853150917803, 0.4015141419168222, 0.38691621601588355, 0.36558300916960806, 0.4078054533056549, 0.390978413505908, 0.3939860098913033, 0.39737159202174155, 0.16554857060365524, 0.14279951361767562, 0.1444461351441414, 0.16780362996903242, 0.15545250824501677, 0.18411480924601553, 0.14375692732494005, 0.15755539117616757, 0.12439084175817627, 0.07356643837521004, 0.07866507351836904, 0.08482325687926917, 0.07200814249639609, 0.07518126213305076, 0.08282286765141611, 0.09021432684285724, 0.07004591094979495, 0.0775905441051733, 0.0649686319237871, 0.06362919958941726, 0.07423678276343837, 0.07991659907937554, 0.06374969185629309, 0.07687221061589589, 0.06835397260270659, 0.07081682525205857, 0.06993858381832363, 0.890627344764051, 0.8847486214361704, 0.866347619123138, 0.7746414787496099, 0.8946355921595175, 0.8501296673269789, 0.8829343813424441, 0.7927987209046685, 0.8541346379837693, 0.17158488620476164, 0.1486191847230961, 0.1732351903540752, 0.15674566399544343, 0.1634116293298652, 0.1882016612086196, 0.167739783112682, 0.17886329208994034, 0.16901384505426853, 0.30686440428745987, 0.25087814405340125, 0.26696723562282554, 0.2536688278049203, 0.2608171755542057, 0.23803466233286852, 0.24286278963409658, 0.23546258208083704, 0.23273180387468595, 0.12502300933140686, 0.11922347167796066, 0.13235366262499215, 0.10614524428799654, 0.09372695836114076, 0.11255746570372027, 0.11333593038045042, 0.09779524801739592, 0.1170446378202229, 0.26409842554969687, 0.2541915856405833, 0.20966107550461488, 0.30480850319389774, 0.3528199471282505, 0.3075732386053657, 0.3635111928753265, 0.24596953261991528, 0.30654321800993845, 0.021707520105609945, 0.034314539124152166, 0.004023841120278648, 0.015480171594729475, 0.02816251329522601, 0.008520488698637974, 0.0493776610258132, 0.049594329625022526, 0.04216685716844826, 0.1473530797382584, 0.1046334933855565, 0.13841338914224777, 0.1295790646048579, 0.09301291294719904, 0.12707664204013125, 0.13869675554596395, 0.12662477552317364, 0.14417444586644945, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011544560095789747, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004217768571194158, 0.004203066948815781, 0.0023247573093938545, 0.0705833923396112, 0.06720968672431771, 0.07890858868259565, 0.07762140771623349, 0.06989061396305274, 0.07883463007400315, 0.060312509554366844, 0.09776386652012847, 0.08067472817706256, 0.32298375144979574, 0.3437536201145551, 0.3392201303813561, 0.3723875308901231, 0.35056836488308984, 0.3623794294296926, 0.3716555409941448, 0.35686715360954246, 0.3532102429695224, 0.06747570089169863, 0.07806850163170254, 0.0916977577207555, 0.07973452719480278, 0.08103358594515409, 0.06797217689560553, 0.07046666987550165, 0.08592555259729884, 0.08191382020400928, 0.221259178827224, 0.17989387552512015, 0.19339772339803152, 0.16449730412783115, 0.11728273808272338, 0.14487030235726028, 0.10585028279010766, 0.13877501797570024, 0.13370029434826225, 0.1961121050212704, 0.23440473552516705, 0.23937541738103296, 0.22831710711194575, 0.22093648094886165, 0.21247098632357708, 0.23711015061346374, 0.23252392387343845, 0.23377643810953797, 0.14975284935083932, 0.16097825884214, 0.16704357853006602, 0.18889952074192484, 0.17349149059467595, 0.1691686501862416, 0.15520194549672883, 0.16348990107485717, 0.17945107357168633, 0.19364739053970847, 0.15356862951293637, 0.17370250767753792, 0.20059425292310384, 0.19602090969749963, 0.14066070046978807, 0.18102813170673193, 0.16650308300720484, 0.18928849687535354, 0.1732245677531371, 0.17818101179327228, 0.16321835518312455, 0.16373601761018586, 0.17158466727112065, 0.16276296956595138, 0.1692362565674288, 0.165954182036414, 0.16586609770808058, 0.1622276765383529, 0.34395331767954784, 0.323024575714681, 0.4571018665533527, 0.5149776622469469, 0.4289540259305501, 0.3661701711208478, 0.4579527784302184, 0.19224777869399245, 0.3271757443032106, 0.2145532415980681, 0.3857806375586642, 0.19088534127060452, 0.31892286118134217, 0.1609857513492814, 0.14687505565686387, 0.5459871018788822, 0.2053014992234773, 0.16857250003754598, 0.15955366812455907, 0.16354192119690192, 0.15781934089886562, 0.18683168487806356, 0.15776603567149527, 0.16379411855922466, 0.18809064021099153, 0.16737483514063756, 0.07037073394088822, 0.08531810785188843, 0.08224504330605831, 0.06912552927297888, 0.06783775628282929, 0.08665465008178075, 0.06023481388061469, 0.05983977189544798, 0.051360474392294075]}, "mutation_prompt": null}
{"id": "edcb2d61-5623-4650-a760-b88d6a17fadc", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Opposition-based learning\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Adaptive Differential Evolution with Opposition-Based Learning to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4e366d7f-af5f-41d2-8330-dcaf9a6ec793", "metadata": {"aucs": [0.3953887654942515, 0.3673853150917803, 0.4015141419168222, 0.38691621601588355, 0.36558300916960806, 0.4078054533056549, 0.390978413505908, 0.3939860098913033, 0.39737159202174155, 0.16554857060365524, 0.14279951361767562, 0.1444461351441414, 0.16780362996903242, 0.15545250824501677, 0.18411480924601553, 0.14375692732494005, 0.15755539117616757, 0.12439084175817627, 0.07356643837521004, 0.07866507351836904, 0.08482325687926917, 0.07200814249639609, 0.07518126213305076, 0.08282286765141611, 0.09021432684285724, 0.07004591094979495, 0.0775905441051733, 0.0649686319237871, 0.06362919958941726, 0.07423678276343837, 0.07991659907937554, 0.06374969185629309, 0.07687221061589589, 0.06835397260270659, 0.07081682525205857, 0.06993858381832363, 0.890627344764051, 0.8847486214361704, 0.866347619123138, 0.7746414787496099, 0.8946355921595175, 0.8501296673269789, 0.8829343813424441, 0.7927987209046685, 0.8541346379837693, 0.17158488620476164, 0.1486191847230961, 0.1732351903540752, 0.15674566399544343, 0.1634116293298652, 0.1882016612086196, 0.167739783112682, 0.17886329208994034, 0.16901384505426853, 0.30686440428745987, 0.25087814405340125, 0.26696723562282554, 0.2536688278049203, 0.2608171755542057, 0.23803466233286852, 0.24286278963409658, 0.23546258208083704, 0.23273180387468595, 0.12502300933140686, 0.11922347167796066, 0.13235366262499215, 0.10614524428799654, 0.09372695836114076, 0.11255746570372027, 0.11333593038045042, 0.09779524801739592, 0.1170446378202229, 0.26409842554969687, 0.2541915856405833, 0.20966107550461488, 0.30480850319389774, 0.3528199471282505, 0.3075732386053657, 0.3635111928753265, 0.24596953261991528, 0.30654321800993845, 0.021707520105609945, 0.034314539124152166, 0.004023841120278648, 0.015480171594729475, 0.02816251329522601, 0.008520488698637974, 0.0493776610258132, 0.049594329625022526, 0.04216685716844826, 0.1473530797382584, 0.1046334933855565, 0.13841338914224777, 0.1295790646048579, 0.09301291294719904, 0.12707664204013125, 0.13869675554596395, 0.12662477552317364, 0.14417444586644945, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011544560095789747, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004217768571194158, 0.004203066948815781, 0.0023247573093938545, 0.0705833923396112, 0.06720968672431771, 0.07890858868259565, 0.07762140771623349, 0.06989061396305274, 0.07883463007400315, 0.060312509554366844, 0.09776386652012847, 0.08067472817706256, 0.32298375144979574, 0.3437536201145551, 0.3392201303813561, 0.3723875308901231, 0.35056836488308984, 0.3623794294296926, 0.3716555409941448, 0.35686715360954246, 0.3532102429695224, 0.06747570089169863, 0.07806850163170254, 0.0916977577207555, 0.07973452719480278, 0.08103358594515409, 0.06797217689560553, 0.07046666987550165, 0.08592555259729884, 0.08191382020400928, 0.221259178827224, 0.17989387552512015, 0.19339772339803152, 0.16449730412783115, 0.11728273808272338, 0.14487030235726028, 0.10585028279010766, 0.13877501797570024, 0.13370029434826225, 0.1961121050212704, 0.23440473552516705, 0.23937541738103296, 0.22831710711194575, 0.22093648094886165, 0.21247098632357708, 0.23711015061346374, 0.23252392387343845, 0.23377643810953797, 0.14975284935083932, 0.16097825884214, 0.16704357853006602, 0.18889952074192484, 0.17349149059467595, 0.1691686501862416, 0.15520194549672883, 0.16348990107485717, 0.17945107357168633, 0.19364739053970847, 0.15356862951293637, 0.17370250767753792, 0.20059425292310384, 0.19602090969749963, 0.14066070046978807, 0.18102813170673193, 0.16650308300720484, 0.18928849687535354, 0.1732245677531371, 0.17818101179327228, 0.16321835518312455, 0.16373601761018586, 0.17158466727112065, 0.16276296956595138, 0.1692362565674288, 0.165954182036414, 0.16586609770808058, 0.1622276765383529, 0.34395331767954784, 0.323024575714681, 0.4571018665533527, 0.5149776622469469, 0.4289540259305501, 0.3661701711208478, 0.4579527784302184, 0.19224777869399245, 0.3271757443032106, 0.2145532415980681, 0.3857806375586642, 0.19088534127060452, 0.31892286118134217, 0.1609857513492814, 0.14687505565686387, 0.5459871018788822, 0.2053014992234773, 0.16857250003754598, 0.15955366812455907, 0.16354192119690192, 0.15781934089886562, 0.18683168487806356, 0.15776603567149527, 0.16379411855922466, 0.18809064021099153, 0.16737483514063756, 0.07037073394088822, 0.08531810785188843, 0.08224504330605831, 0.06912552927297888, 0.06783775628282929, 0.08665465008178075, 0.06023481388061469, 0.05983977189544798, 0.051360474392294075]}, "mutation_prompt": null}
{"id": "495d64f8-f041-43f2-818f-4766d8d54790", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Opposition-based learning\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Adaptive Differential Evolution with Opposition-Based Learning to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4e366d7f-af5f-41d2-8330-dcaf9a6ec793", "metadata": {"aucs": [0.3953887654942515, 0.3673853150917803, 0.4015141419168222, 0.38691621601588355, 0.36558300916960806, 0.4078054533056549, 0.390978413505908, 0.3939860098913033, 0.39737159202174155, 0.16554857060365524, 0.14279951361767562, 0.1444461351441414, 0.16780362996903242, 0.15545250824501677, 0.18411480924601553, 0.14375692732494005, 0.15755539117616757, 0.12439084175817627, 0.07356643837521004, 0.07866507351836904, 0.08482325687926917, 0.07200814249639609, 0.07518126213305076, 0.08282286765141611, 0.09021432684285724, 0.07004591094979495, 0.0775905441051733, 0.0649686319237871, 0.06362919958941726, 0.07423678276343837, 0.07991659907937554, 0.06374969185629309, 0.07687221061589589, 0.06835397260270659, 0.07081682525205857, 0.06993858381832363, 0.890627344764051, 0.8847486214361704, 0.866347619123138, 0.7746414787496099, 0.8946355921595175, 0.8501296673269789, 0.8829343813424441, 0.7927987209046685, 0.8541346379837693, 0.17158488620476164, 0.1486191847230961, 0.1732351903540752, 0.15674566399544343, 0.1634116293298652, 0.1882016612086196, 0.167739783112682, 0.17886329208994034, 0.16901384505426853, 0.30686440428745987, 0.25087814405340125, 0.26696723562282554, 0.2536688278049203, 0.2608171755542057, 0.23803466233286852, 0.24286278963409658, 0.23546258208083704, 0.23273180387468595, 0.12502300933140686, 0.11922347167796066, 0.13235366262499215, 0.10614524428799654, 0.09372695836114076, 0.11255746570372027, 0.11333593038045042, 0.09779524801739592, 0.1170446378202229, 0.26409842554969687, 0.2541915856405833, 0.20966107550461488, 0.30480850319389774, 0.3528199471282505, 0.3075732386053657, 0.3635111928753265, 0.24596953261991528, 0.30654321800993845, 0.021707520105609945, 0.034314539124152166, 0.004023841120278648, 0.015480171594729475, 0.02816251329522601, 0.008520488698637974, 0.0493776610258132, 0.049594329625022526, 0.04216685716844826, 0.1473530797382584, 0.1046334933855565, 0.13841338914224777, 0.1295790646048579, 0.09301291294719904, 0.12707664204013125, 0.13869675554596395, 0.12662477552317364, 0.14417444586644945, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011544560095789747, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004217768571194158, 0.004203066948815781, 0.0023247573093938545, 0.0705833923396112, 0.06720968672431771, 0.07890858868259565, 0.07762140771623349, 0.06989061396305274, 0.07883463007400315, 0.060312509554366844, 0.09776386652012847, 0.08067472817706256, 0.32298375144979574, 0.3437536201145551, 0.3392201303813561, 0.3723875308901231, 0.35056836488308984, 0.3623794294296926, 0.3716555409941448, 0.35686715360954246, 0.3532102429695224, 0.06747570089169863, 0.07806850163170254, 0.0916977577207555, 0.07973452719480278, 0.08103358594515409, 0.06797217689560553, 0.07046666987550165, 0.08592555259729884, 0.08191382020400928, 0.221259178827224, 0.17989387552512015, 0.19339772339803152, 0.16449730412783115, 0.11728273808272338, 0.14487030235726028, 0.10585028279010766, 0.13877501797570024, 0.13370029434826225, 0.1961121050212704, 0.23440473552516705, 0.23937541738103296, 0.22831710711194575, 0.22093648094886165, 0.21247098632357708, 0.23711015061346374, 0.23252392387343845, 0.23377643810953797, 0.14975284935083932, 0.16097825884214, 0.16704357853006602, 0.18889952074192484, 0.17349149059467595, 0.1691686501862416, 0.15520194549672883, 0.16348990107485717, 0.17945107357168633, 0.19364739053970847, 0.15356862951293637, 0.17370250767753792, 0.20059425292310384, 0.19602090969749963, 0.14066070046978807, 0.18102813170673193, 0.16650308300720484, 0.18928849687535354, 0.1732245677531371, 0.17818101179327228, 0.16321835518312455, 0.16373601761018586, 0.17158466727112065, 0.16276296956595138, 0.1692362565674288, 0.165954182036414, 0.16586609770808058, 0.1622276765383529, 0.34395331767954784, 0.323024575714681, 0.4571018665533527, 0.5149776622469469, 0.4289540259305501, 0.3661701711208478, 0.4579527784302184, 0.19224777869399245, 0.3271757443032106, 0.2145532415980681, 0.3857806375586642, 0.19088534127060452, 0.31892286118134217, 0.1609857513492814, 0.14687505565686387, 0.5459871018788822, 0.2053014992234773, 0.16857250003754598, 0.15955366812455907, 0.16354192119690192, 0.15781934089886562, 0.18683168487806356, 0.15776603567149527, 0.16379411855922466, 0.18809064021099153, 0.16737483514063756, 0.07037073394088822, 0.08531810785188843, 0.08224504330605831, 0.06912552927297888, 0.06783775628282929, 0.08665465008178075, 0.06023481388061469, 0.05983977189544798, 0.051360474392294075]}, "mutation_prompt": null}
{"id": "c6c1ab25-ceff-4716-9468-82f7afd7987c", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Opposition-based learning\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Adaptive Differential Evolution with Opposition-Based Learning to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4e366d7f-af5f-41d2-8330-dcaf9a6ec793", "metadata": {"aucs": [0.3953887654942515, 0.3673853150917803, 0.4015141419168222, 0.38691621601588355, 0.36558300916960806, 0.4078054533056549, 0.390978413505908, 0.3939860098913033, 0.39737159202174155, 0.16554857060365524, 0.14279951361767562, 0.1444461351441414, 0.16780362996903242, 0.15545250824501677, 0.18411480924601553, 0.14375692732494005, 0.15755539117616757, 0.12439084175817627, 0.07356643837521004, 0.07866507351836904, 0.08482325687926917, 0.07200814249639609, 0.07518126213305076, 0.08282286765141611, 0.09021432684285724, 0.07004591094979495, 0.0775905441051733, 0.0649686319237871, 0.06362919958941726, 0.07423678276343837, 0.07991659907937554, 0.06374969185629309, 0.07687221061589589, 0.06835397260270659, 0.07081682525205857, 0.06993858381832363, 0.890627344764051, 0.8847486214361704, 0.866347619123138, 0.7746414787496099, 0.8946355921595175, 0.8501296673269789, 0.8829343813424441, 0.7927987209046685, 0.8541346379837693, 0.17158488620476164, 0.1486191847230961, 0.1732351903540752, 0.15674566399544343, 0.1634116293298652, 0.1882016612086196, 0.167739783112682, 0.17886329208994034, 0.16901384505426853, 0.30686440428745987, 0.25087814405340125, 0.26696723562282554, 0.2536688278049203, 0.2608171755542057, 0.23803466233286852, 0.24286278963409658, 0.23546258208083704, 0.23273180387468595, 0.12502300933140686, 0.11922347167796066, 0.13235366262499215, 0.10614524428799654, 0.09372695836114076, 0.11255746570372027, 0.11333593038045042, 0.09779524801739592, 0.1170446378202229, 0.26409842554969687, 0.2541915856405833, 0.20966107550461488, 0.30480850319389774, 0.3528199471282505, 0.3075732386053657, 0.3635111928753265, 0.24596953261991528, 0.30654321800993845, 0.021707520105609945, 0.034314539124152166, 0.004023841120278648, 0.015480171594729475, 0.02816251329522601, 0.008520488698637974, 0.0493776610258132, 0.049594329625022526, 0.04216685716844826, 0.1473530797382584, 0.1046334933855565, 0.13841338914224777, 0.1295790646048579, 0.09301291294719904, 0.12707664204013125, 0.13869675554596395, 0.12662477552317364, 0.14417444586644945, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011544560095789747, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004217768571194158, 0.004203066948815781, 0.0023247573093938545, 0.0705833923396112, 0.06720968672431771, 0.07890858868259565, 0.07762140771623349, 0.06989061396305274, 0.07883463007400315, 0.060312509554366844, 0.09776386652012847, 0.08067472817706256, 0.32298375144979574, 0.3437536201145551, 0.3392201303813561, 0.3723875308901231, 0.35056836488308984, 0.3623794294296926, 0.3716555409941448, 0.35686715360954246, 0.3532102429695224, 0.06747570089169863, 0.07806850163170254, 0.0916977577207555, 0.07973452719480278, 0.08103358594515409, 0.06797217689560553, 0.07046666987550165, 0.08592555259729884, 0.08191382020400928, 0.221259178827224, 0.17989387552512015, 0.19339772339803152, 0.16449730412783115, 0.11728273808272338, 0.14487030235726028, 0.10585028279010766, 0.13877501797570024, 0.13370029434826225, 0.1961121050212704, 0.23440473552516705, 0.23937541738103296, 0.22831710711194575, 0.22093648094886165, 0.21247098632357708, 0.23711015061346374, 0.23252392387343845, 0.23377643810953797, 0.14975284935083932, 0.16097825884214, 0.16704357853006602, 0.18889952074192484, 0.17349149059467595, 0.1691686501862416, 0.15520194549672883, 0.16348990107485717, 0.17945107357168633, 0.19364739053970847, 0.15356862951293637, 0.17370250767753792, 0.20059425292310384, 0.19602090969749963, 0.14066070046978807, 0.18102813170673193, 0.16650308300720484, 0.18928849687535354, 0.1732245677531371, 0.17818101179327228, 0.16321835518312455, 0.16373601761018586, 0.17158466727112065, 0.16276296956595138, 0.1692362565674288, 0.165954182036414, 0.16586609770808058, 0.1622276765383529, 0.34395331767954784, 0.323024575714681, 0.4571018665533527, 0.5149776622469469, 0.4289540259305501, 0.3661701711208478, 0.4579527784302184, 0.19224777869399245, 0.3271757443032106, 0.2145532415980681, 0.3857806375586642, 0.19088534127060452, 0.31892286118134217, 0.1609857513492814, 0.14687505565686387, 0.5459871018788822, 0.2053014992234773, 0.16857250003754598, 0.15955366812455907, 0.16354192119690192, 0.15781934089886562, 0.18683168487806356, 0.15776603567149527, 0.16379411855922466, 0.18809064021099153, 0.16737483514063756, 0.07037073394088822, 0.08531810785188843, 0.08224504330605831, 0.06912552927297888, 0.06783775628282929, 0.08665465008178075, 0.06023481388061469, 0.05983977189544798, 0.051360474392294075]}, "mutation_prompt": null}
{"id": "6e298676-e625-4d77-a135-eaf862adf063", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Opposition-based learning\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Adaptive Differential Evolution with Opposition-Based Learning to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4e366d7f-af5f-41d2-8330-dcaf9a6ec793", "metadata": {"aucs": [0.3953887654942515, 0.3673853150917803, 0.4015141419168222, 0.38691621601588355, 0.36558300916960806, 0.4078054533056549, 0.390978413505908, 0.3939860098913033, 0.39737159202174155, 0.16554857060365524, 0.14279951361767562, 0.1444461351441414, 0.16780362996903242, 0.15545250824501677, 0.18411480924601553, 0.14375692732494005, 0.15755539117616757, 0.12439084175817627, 0.07356643837521004, 0.07866507351836904, 0.08482325687926917, 0.07200814249639609, 0.07518126213305076, 0.08282286765141611, 0.09021432684285724, 0.07004591094979495, 0.0775905441051733, 0.0649686319237871, 0.06362919958941726, 0.07423678276343837, 0.07991659907937554, 0.06374969185629309, 0.07687221061589589, 0.06835397260270659, 0.07081682525205857, 0.06993858381832363, 0.890627344764051, 0.8847486214361704, 0.866347619123138, 0.7746414787496099, 0.8946355921595175, 0.8501296673269789, 0.8829343813424441, 0.7927987209046685, 0.8541346379837693, 0.17158488620476164, 0.1486191847230961, 0.1732351903540752, 0.15674566399544343, 0.1634116293298652, 0.1882016612086196, 0.167739783112682, 0.17886329208994034, 0.16901384505426853, 0.30686440428745987, 0.25087814405340125, 0.26696723562282554, 0.2536688278049203, 0.2608171755542057, 0.23803466233286852, 0.24286278963409658, 0.23546258208083704, 0.23273180387468595, 0.12502300933140686, 0.11922347167796066, 0.13235366262499215, 0.10614524428799654, 0.09372695836114076, 0.11255746570372027, 0.11333593038045042, 0.09779524801739592, 0.1170446378202229, 0.26409842554969687, 0.2541915856405833, 0.20966107550461488, 0.30480850319389774, 0.3528199471282505, 0.3075732386053657, 0.3635111928753265, 0.24596953261991528, 0.30654321800993845, 0.021707520105609945, 0.034314539124152166, 0.004023841120278648, 0.015480171594729475, 0.02816251329522601, 0.008520488698637974, 0.0493776610258132, 0.049594329625022526, 0.04216685716844826, 0.1473530797382584, 0.1046334933855565, 0.13841338914224777, 0.1295790646048579, 0.09301291294719904, 0.12707664204013125, 0.13869675554596395, 0.12662477552317364, 0.14417444586644945, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011544560095789747, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004217768571194158, 0.004203066948815781, 0.0023247573093938545, 0.0705833923396112, 0.06720968672431771, 0.07890858868259565, 0.07762140771623349, 0.06989061396305274, 0.07883463007400315, 0.060312509554366844, 0.09776386652012847, 0.08067472817706256, 0.32298375144979574, 0.3437536201145551, 0.3392201303813561, 0.3723875308901231, 0.35056836488308984, 0.3623794294296926, 0.3716555409941448, 0.35686715360954246, 0.3532102429695224, 0.06747570089169863, 0.07806850163170254, 0.0916977577207555, 0.07973452719480278, 0.08103358594515409, 0.06797217689560553, 0.07046666987550165, 0.08592555259729884, 0.08191382020400928, 0.221259178827224, 0.17989387552512015, 0.19339772339803152, 0.16449730412783115, 0.11728273808272338, 0.14487030235726028, 0.10585028279010766, 0.13877501797570024, 0.13370029434826225, 0.1961121050212704, 0.23440473552516705, 0.23937541738103296, 0.22831710711194575, 0.22093648094886165, 0.21247098632357708, 0.23711015061346374, 0.23252392387343845, 0.23377643810953797, 0.14975284935083932, 0.16097825884214, 0.16704357853006602, 0.18889952074192484, 0.17349149059467595, 0.1691686501862416, 0.15520194549672883, 0.16348990107485717, 0.17945107357168633, 0.19364739053970847, 0.15356862951293637, 0.17370250767753792, 0.20059425292310384, 0.19602090969749963, 0.14066070046978807, 0.18102813170673193, 0.16650308300720484, 0.18928849687535354, 0.1732245677531371, 0.17818101179327228, 0.16321835518312455, 0.16373601761018586, 0.17158466727112065, 0.16276296956595138, 0.1692362565674288, 0.165954182036414, 0.16586609770808058, 0.1622276765383529, 0.34395331767954784, 0.323024575714681, 0.4571018665533527, 0.5149776622469469, 0.4289540259305501, 0.3661701711208478, 0.4579527784302184, 0.19224777869399245, 0.3271757443032106, 0.2145532415980681, 0.3857806375586642, 0.19088534127060452, 0.31892286118134217, 0.1609857513492814, 0.14687505565686387, 0.5459871018788822, 0.2053014992234773, 0.16857250003754598, 0.15955366812455907, 0.16354192119690192, 0.15781934089886562, 0.18683168487806356, 0.15776603567149527, 0.16379411855922466, 0.18809064021099153, 0.16737483514063756, 0.07037073394088822, 0.08531810785188843, 0.08224504330605831, 0.06912552927297888, 0.06783775628282929, 0.08665465008178075, 0.06023481388061469, 0.05983977189544798, 0.051360474392294075]}, "mutation_prompt": null}
{"id": "efa18f41-033f-4f79-a492-9e7c5635a51e", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Opposition-based learning\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Adaptive Differential Evolution with Opposition-Based Learning to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4e366d7f-af5f-41d2-8330-dcaf9a6ec793", "metadata": {"aucs": [0.3953887654942515, 0.3673853150917803, 0.4015141419168222, 0.38691621601588355, 0.36558300916960806, 0.4078054533056549, 0.390978413505908, 0.3939860098913033, 0.39737159202174155, 0.16554857060365524, 0.14279951361767562, 0.1444461351441414, 0.16780362996903242, 0.15545250824501677, 0.18411480924601553, 0.14375692732494005, 0.15755539117616757, 0.12439084175817627, 0.07356643837521004, 0.07866507351836904, 0.08482325687926917, 0.07200814249639609, 0.07518126213305076, 0.08282286765141611, 0.09021432684285724, 0.07004591094979495, 0.0775905441051733, 0.0649686319237871, 0.06362919958941726, 0.07423678276343837, 0.07991659907937554, 0.06374969185629309, 0.07687221061589589, 0.06835397260270659, 0.07081682525205857, 0.06993858381832363, 0.890627344764051, 0.8847486214361704, 0.866347619123138, 0.7746414787496099, 0.8946355921595175, 0.8501296673269789, 0.8829343813424441, 0.7927987209046685, 0.8541346379837693, 0.17158488620476164, 0.1486191847230961, 0.1732351903540752, 0.15674566399544343, 0.1634116293298652, 0.1882016612086196, 0.167739783112682, 0.17886329208994034, 0.16901384505426853, 0.30686440428745987, 0.25087814405340125, 0.26696723562282554, 0.2536688278049203, 0.2608171755542057, 0.23803466233286852, 0.24286278963409658, 0.23546258208083704, 0.23273180387468595, 0.12502300933140686, 0.11922347167796066, 0.13235366262499215, 0.10614524428799654, 0.09372695836114076, 0.11255746570372027, 0.11333593038045042, 0.09779524801739592, 0.1170446378202229, 0.26409842554969687, 0.2541915856405833, 0.20966107550461488, 0.30480850319389774, 0.3528199471282505, 0.3075732386053657, 0.3635111928753265, 0.24596953261991528, 0.30654321800993845, 0.021707520105609945, 0.034314539124152166, 0.004023841120278648, 0.015480171594729475, 0.02816251329522601, 0.008520488698637974, 0.0493776610258132, 0.049594329625022526, 0.04216685716844826, 0.1473530797382584, 0.1046334933855565, 0.13841338914224777, 0.1295790646048579, 0.09301291294719904, 0.12707664204013125, 0.13869675554596395, 0.12662477552317364, 0.14417444586644945, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011544560095789747, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004217768571194158, 0.004203066948815781, 0.0023247573093938545, 0.0705833923396112, 0.06720968672431771, 0.07890858868259565, 0.07762140771623349, 0.06989061396305274, 0.07883463007400315, 0.060312509554366844, 0.09776386652012847, 0.08067472817706256, 0.32298375144979574, 0.3437536201145551, 0.3392201303813561, 0.3723875308901231, 0.35056836488308984, 0.3623794294296926, 0.3716555409941448, 0.35686715360954246, 0.3532102429695224, 0.06747570089169863, 0.07806850163170254, 0.0916977577207555, 0.07973452719480278, 0.08103358594515409, 0.06797217689560553, 0.07046666987550165, 0.08592555259729884, 0.08191382020400928, 0.221259178827224, 0.17989387552512015, 0.19339772339803152, 0.16449730412783115, 0.11728273808272338, 0.14487030235726028, 0.10585028279010766, 0.13877501797570024, 0.13370029434826225, 0.1961121050212704, 0.23440473552516705, 0.23937541738103296, 0.22831710711194575, 0.22093648094886165, 0.21247098632357708, 0.23711015061346374, 0.23252392387343845, 0.23377643810953797, 0.14975284935083932, 0.16097825884214, 0.16704357853006602, 0.18889952074192484, 0.17349149059467595, 0.1691686501862416, 0.15520194549672883, 0.16348990107485717, 0.17945107357168633, 0.19364739053970847, 0.15356862951293637, 0.17370250767753792, 0.20059425292310384, 0.19602090969749963, 0.14066070046978807, 0.18102813170673193, 0.16650308300720484, 0.18928849687535354, 0.1732245677531371, 0.17818101179327228, 0.16321835518312455, 0.16373601761018586, 0.17158466727112065, 0.16276296956595138, 0.1692362565674288, 0.165954182036414, 0.16586609770808058, 0.1622276765383529, 0.34395331767954784, 0.323024575714681, 0.4571018665533527, 0.5149776622469469, 0.4289540259305501, 0.3661701711208478, 0.4579527784302184, 0.19224777869399245, 0.3271757443032106, 0.2145532415980681, 0.3857806375586642, 0.19088534127060452, 0.31892286118134217, 0.1609857513492814, 0.14687505565686387, 0.5459871018788822, 0.2053014992234773, 0.16857250003754598, 0.15955366812455907, 0.16354192119690192, 0.15781934089886562, 0.18683168487806356, 0.15776603567149527, 0.16379411855922466, 0.18809064021099153, 0.16737483514063756, 0.07037073394088822, 0.08531810785188843, 0.08224504330605831, 0.06912552927297888, 0.06783775628282929, 0.08665465008178075, 0.06023481388061469, 0.05983977189544798, 0.051360474392294075]}, "mutation_prompt": null}
{"id": "6370a125-0ba4-42ec-b63a-6664ecd3be92", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Opposition-based learning\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Adaptive Differential Evolution with Opposition-Based Learning to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4e366d7f-af5f-41d2-8330-dcaf9a6ec793", "metadata": {"aucs": [0.3953887654942515, 0.3673853150917803, 0.4015141419168222, 0.38691621601588355, 0.36558300916960806, 0.4078054533056549, 0.390978413505908, 0.3939860098913033, 0.39737159202174155, 0.16554857060365524, 0.14279951361767562, 0.1444461351441414, 0.16780362996903242, 0.15545250824501677, 0.18411480924601553, 0.14375692732494005, 0.15755539117616757, 0.12439084175817627, 0.07356643837521004, 0.07866507351836904, 0.08482325687926917, 0.07200814249639609, 0.07518126213305076, 0.08282286765141611, 0.09021432684285724, 0.07004591094979495, 0.0775905441051733, 0.0649686319237871, 0.06362919958941726, 0.07423678276343837, 0.07991659907937554, 0.06374969185629309, 0.07687221061589589, 0.06835397260270659, 0.07081682525205857, 0.06993858381832363, 0.890627344764051, 0.8847486214361704, 0.866347619123138, 0.7746414787496099, 0.8946355921595175, 0.8501296673269789, 0.8829343813424441, 0.7927987209046685, 0.8541346379837693, 0.17158488620476164, 0.1486191847230961, 0.1732351903540752, 0.15674566399544343, 0.1634116293298652, 0.1882016612086196, 0.167739783112682, 0.17886329208994034, 0.16901384505426853, 0.30686440428745987, 0.25087814405340125, 0.26696723562282554, 0.2536688278049203, 0.2608171755542057, 0.23803466233286852, 0.24286278963409658, 0.23546258208083704, 0.23273180387468595, 0.12502300933140686, 0.11922347167796066, 0.13235366262499215, 0.10614524428799654, 0.09372695836114076, 0.11255746570372027, 0.11333593038045042, 0.09779524801739592, 0.1170446378202229, 0.26409842554969687, 0.2541915856405833, 0.20966107550461488, 0.30480850319389774, 0.3528199471282505, 0.3075732386053657, 0.3635111928753265, 0.24596953261991528, 0.30654321800993845, 0.021707520105609945, 0.034314539124152166, 0.004023841120278648, 0.015480171594729475, 0.02816251329522601, 0.008520488698637974, 0.0493776610258132, 0.049594329625022526, 0.04216685716844826, 0.1473530797382584, 0.1046334933855565, 0.13841338914224777, 0.1295790646048579, 0.09301291294719904, 0.12707664204013125, 0.13869675554596395, 0.12662477552317364, 0.14417444586644945, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011544560095789747, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004217768571194158, 0.004203066948815781, 0.0023247573093938545, 0.0705833923396112, 0.06720968672431771, 0.07890858868259565, 0.07762140771623349, 0.06989061396305274, 0.07883463007400315, 0.060312509554366844, 0.09776386652012847, 0.08067472817706256, 0.32298375144979574, 0.3437536201145551, 0.3392201303813561, 0.3723875308901231, 0.35056836488308984, 0.3623794294296926, 0.3716555409941448, 0.35686715360954246, 0.3532102429695224, 0.06747570089169863, 0.07806850163170254, 0.0916977577207555, 0.07973452719480278, 0.08103358594515409, 0.06797217689560553, 0.07046666987550165, 0.08592555259729884, 0.08191382020400928, 0.221259178827224, 0.17989387552512015, 0.19339772339803152, 0.16449730412783115, 0.11728273808272338, 0.14487030235726028, 0.10585028279010766, 0.13877501797570024, 0.13370029434826225, 0.1961121050212704, 0.23440473552516705, 0.23937541738103296, 0.22831710711194575, 0.22093648094886165, 0.21247098632357708, 0.23711015061346374, 0.23252392387343845, 0.23377643810953797, 0.14975284935083932, 0.16097825884214, 0.16704357853006602, 0.18889952074192484, 0.17349149059467595, 0.1691686501862416, 0.15520194549672883, 0.16348990107485717, 0.17945107357168633, 0.19364739053970847, 0.15356862951293637, 0.17370250767753792, 0.20059425292310384, 0.19602090969749963, 0.14066070046978807, 0.18102813170673193, 0.16650308300720484, 0.18928849687535354, 0.1732245677531371, 0.17818101179327228, 0.16321835518312455, 0.16373601761018586, 0.17158466727112065, 0.16276296956595138, 0.1692362565674288, 0.165954182036414, 0.16586609770808058, 0.1622276765383529, 0.34395331767954784, 0.323024575714681, 0.4571018665533527, 0.5149776622469469, 0.4289540259305501, 0.3661701711208478, 0.4579527784302184, 0.19224777869399245, 0.3271757443032106, 0.2145532415980681, 0.3857806375586642, 0.19088534127060452, 0.31892286118134217, 0.1609857513492814, 0.14687505565686387, 0.5459871018788822, 0.2053014992234773, 0.16857250003754598, 0.15955366812455907, 0.16354192119690192, 0.15781934089886562, 0.18683168487806356, 0.15776603567149527, 0.16379411855922466, 0.18809064021099153, 0.16737483514063756, 0.07037073394088822, 0.08531810785188843, 0.08224504330605831, 0.06912552927297888, 0.06783775628282929, 0.08665465008178075, 0.06023481388061469, 0.05983977189544798, 0.051360474392294075]}, "mutation_prompt": null}
{"id": "b050730e-21b3-4ec2-8d58-4674badbe68e", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Opposition-based learning\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Adaptive Differential Evolution with Opposition-Based Learning to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4e366d7f-af5f-41d2-8330-dcaf9a6ec793", "metadata": {"aucs": [0.3953887654942515, 0.3673853150917803, 0.4015141419168222, 0.38691621601588355, 0.36558300916960806, 0.4078054533056549, 0.390978413505908, 0.3939860098913033, 0.39737159202174155, 0.16554857060365524, 0.14279951361767562, 0.1444461351441414, 0.16780362996903242, 0.15545250824501677, 0.18411480924601553, 0.14375692732494005, 0.15755539117616757, 0.12439084175817627, 0.07356643837521004, 0.07866507351836904, 0.08482325687926917, 0.07200814249639609, 0.07518126213305076, 0.08282286765141611, 0.09021432684285724, 0.07004591094979495, 0.0775905441051733, 0.0649686319237871, 0.06362919958941726, 0.07423678276343837, 0.07991659907937554, 0.06374969185629309, 0.07687221061589589, 0.06835397260270659, 0.07081682525205857, 0.06993858381832363, 0.890627344764051, 0.8847486214361704, 0.866347619123138, 0.7746414787496099, 0.8946355921595175, 0.8501296673269789, 0.8829343813424441, 0.7927987209046685, 0.8541346379837693, 0.17158488620476164, 0.1486191847230961, 0.1732351903540752, 0.15674566399544343, 0.1634116293298652, 0.1882016612086196, 0.167739783112682, 0.17886329208994034, 0.16901384505426853, 0.30686440428745987, 0.25087814405340125, 0.26696723562282554, 0.2536688278049203, 0.2608171755542057, 0.23803466233286852, 0.24286278963409658, 0.23546258208083704, 0.23273180387468595, 0.12502300933140686, 0.11922347167796066, 0.13235366262499215, 0.10614524428799654, 0.09372695836114076, 0.11255746570372027, 0.11333593038045042, 0.09779524801739592, 0.1170446378202229, 0.26409842554969687, 0.2541915856405833, 0.20966107550461488, 0.30480850319389774, 0.3528199471282505, 0.3075732386053657, 0.3635111928753265, 0.24596953261991528, 0.30654321800993845, 0.021707520105609945, 0.034314539124152166, 0.004023841120278648, 0.015480171594729475, 0.02816251329522601, 0.008520488698637974, 0.0493776610258132, 0.049594329625022526, 0.04216685716844826, 0.1473530797382584, 0.1046334933855565, 0.13841338914224777, 0.1295790646048579, 0.09301291294719904, 0.12707664204013125, 0.13869675554596395, 0.12662477552317364, 0.14417444586644945, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011544560095789747, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004217768571194158, 0.004203066948815781, 0.0023247573093938545, 0.0705833923396112, 0.06720968672431771, 0.07890858868259565, 0.07762140771623349, 0.06989061396305274, 0.07883463007400315, 0.060312509554366844, 0.09776386652012847, 0.08067472817706256, 0.32298375144979574, 0.3437536201145551, 0.3392201303813561, 0.3723875308901231, 0.35056836488308984, 0.3623794294296926, 0.3716555409941448, 0.35686715360954246, 0.3532102429695224, 0.06747570089169863, 0.07806850163170254, 0.0916977577207555, 0.07973452719480278, 0.08103358594515409, 0.06797217689560553, 0.07046666987550165, 0.08592555259729884, 0.08191382020400928, 0.221259178827224, 0.17989387552512015, 0.19339772339803152, 0.16449730412783115, 0.11728273808272338, 0.14487030235726028, 0.10585028279010766, 0.13877501797570024, 0.13370029434826225, 0.1961121050212704, 0.23440473552516705, 0.23937541738103296, 0.22831710711194575, 0.22093648094886165, 0.21247098632357708, 0.23711015061346374, 0.23252392387343845, 0.23377643810953797, 0.14975284935083932, 0.16097825884214, 0.16704357853006602, 0.18889952074192484, 0.17349149059467595, 0.1691686501862416, 0.15520194549672883, 0.16348990107485717, 0.17945107357168633, 0.19364739053970847, 0.15356862951293637, 0.17370250767753792, 0.20059425292310384, 0.19602090969749963, 0.14066070046978807, 0.18102813170673193, 0.16650308300720484, 0.18928849687535354, 0.1732245677531371, 0.17818101179327228, 0.16321835518312455, 0.16373601761018586, 0.17158466727112065, 0.16276296956595138, 0.1692362565674288, 0.165954182036414, 0.16586609770808058, 0.1622276765383529, 0.34395331767954784, 0.323024575714681, 0.4571018665533527, 0.5149776622469469, 0.4289540259305501, 0.3661701711208478, 0.4579527784302184, 0.19224777869399245, 0.3271757443032106, 0.2145532415980681, 0.3857806375586642, 0.19088534127060452, 0.31892286118134217, 0.1609857513492814, 0.14687505565686387, 0.5459871018788822, 0.2053014992234773, 0.16857250003754598, 0.15955366812455907, 0.16354192119690192, 0.15781934089886562, 0.18683168487806356, 0.15776603567149527, 0.16379411855922466, 0.18809064021099153, 0.16737483514063756, 0.07037073394088822, 0.08531810785188843, 0.08224504330605831, 0.06912552927297888, 0.06783775628282929, 0.08665465008178075, 0.06023481388061469, 0.05983977189544798, 0.051360474392294075]}, "mutation_prompt": null}
{"id": "3f3cc629-ab4d-418a-80c2-22730a662e00", "solution": "import numpy as np\n\nclass ADE_OBL_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population\n\n    def _chaotic_perturbation(self, individual):\n        # Introducing a simple chaotic perturbation using a logistic map\n        r = 3.99  # Chaotic parameter\n        return individual + 0.5 * (r * individual * (1 - individual)) * np.random.uniform(-1, 1, size=self.dim)\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Opposition-based learning\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                # Apply chaotic perturbation to the trial vector\n                trial = self._chaotic_perturbation(trial)\n                trial = np.clip(trial, self.bounds[0], self.bounds[1])\n                \n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL_Chaotic", "description": "Enhanced Adaptive Differential Evolution with Opposition-Based Learning and Chaotic Perturbation for improved exploration and exploitation.", "configspace": "", "generation": 23, "fitness": 0.12480299327322075, "feedback": "The algorithm ADE_OBL_Chaotic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.18.", "error": "", "parent_id": "4e366d7f-af5f-41d2-8330-dcaf9a6ec793", "metadata": {"aucs": [0.19038570025705248, 0.17692455592498513, 0.17834112592156437, 0.14688608633863154, 0.14226740895398193, 0.13204602646169228, 0.15942291819438892, 0.1274200101535784, 0.15054856908457404, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.039560277208463224, 0.038544898455458165, 0.036260445272343844, 0.04109192899336689, 0.014230173366419185, 0.03071953912110892, 0.025605240793920014, 0.03009307430206154, 0.02205214429177471, 0.042329092720469585, 0.03843773187506849, 0.04495829311116828, 0.03288461478447113, 0.034310622963173554, 0.029269570964676084, 0.02010430438801103, 0.013965379955715451, 0.025870958136803734, 0.9573553356045518, 0.9912941978265405, 0.9179526158164941, 0.9437920541588538, 0.9141364760609377, 0.965151049661815, 0.908640775706651, 0.9048492681347493, 0.9404834095696619, 0.06274794416174423, 0.031208630694990247, 0.055954543771462695, 0.0770593333910321, 0.037858425719290656, 0.0527399983488982, 0.03477933358413465, 0.03929717358671281, 0.0340081175288699, 0.196281621857056, 0.14958807905248106, 0.17380975367238494, 0.08809198490998915, 0.07863596166444664, 0.12977785288907873, 0.11840842799939177, 0.10386464084546665, 0.1073603633289073, 0.012228051001997087, 0.014566535445522777, 0.006893590995606824, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0023432104876641713, 9.999999999998899e-05, 9.999999999998899e-05, 0.1862299931543735, 0.13810583728658332, 0.1774072856193084, 0.13210226580365803, 0.12576225398059593, 0.13419539331097896, 0.17190752429244116, 0.15635455644000118, 0.167673319144243, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012145527406096535, 0.012512652709044558, 0.008686323723200218, 0.0312302477304216, 0.005947027132896299, 9.999999999998899e-05, 0.012342026067884815, 0.010025984449168801, 0.032288152834485495, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13282491761145376, 0.1425622740265522, 0.14838054695461433, 0.1691793565565547, 0.18214498256387956, 0.1750982904926094, 0.21587411497285447, 0.23378290310584038, 0.20412307623160897, 0.02796688501023259, 0.028997851191407964, 0.02527581034861215, 0.03411145018107342, 0.019969029790165904, 0.02146538189431435, 0.04321075624837556, 0.04759285733334273, 0.03730225930371611, 0.1454712955500458, 0.11068471657042589, 0.11842175776965747, 0.1440181669121826, 0.11625540143841429, 0.14250060574178447, 0.11337754219930807, 0.1391665960844123, 0.12765049667405814, 0.1478718047400962, 0.14467402948626917, 0.1639303088393872, 0.1878641942500766, 0.1942615221071735, 0.18555938917807768, 0.1468777653471547, 0.17377774300845283, 0.14835674928527165, 0.10355774640370585, 0.07919926517626541, 0.10124563559545219, 0.13703437082372072, 0.11201541227906198, 0.11774053110870897, 0.10514777115350138, 0.11163791059761752, 0.10128766030555036, 0.20176864547573947, 0.19773225737383826, 0.19852566556874385, 0.19041002599393142, 0.2769312801533874, 0.2881992076959631, 0.18834544567580158, 0.2532913512690621, 0.19666791342723955, 0.15545808990197163, 0.13872461683195292, 0.1477431732780391, 0.09803710567444157, 0.12767064051032373, 0.04641548763468595, 0.15155603781061122, 0.14967795707997944, 0.14703599488053154, 0.13517630533101088, 0.12755061052891892, 0.14522914846130242, 0.11578124428169234, 0.1207914665021157, 0.1657535824859273, 0.17751915581082756, 0.10884453602516364, 0.10290986716310913, 0.13363132913643438, 0.10659346086761401, 0.14410087180531717, 0.17975739802208823, 0.18071456979433498, 0.17988173487797698, 0.20174402796382152, 0.14323025519150323, 0.1849566925063616, 0.1829600822984001, 0.17515718455275842, 0.174549321963406, 0.16607554264685553, 0.16973185932272283, 0.18254131591080947, 0.1993950865733819, 0.16720872435930323, 0.19165531275331749, 0.054548128198750434, 0.0523263847699309, 0.06047776755776135, 0.06269156424342492, 0.047543552684896184, 0.05662588289906312, 0.048950279535606045, 0.0658974507385337, 0.046499000014266545]}, "mutation_prompt": null}
{"id": "fe6ec3d3-4fcb-4d8e-90c1-fbfe24baf2db", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Opposition-based learning\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Adaptive Differential Evolution with Opposition-Based Learning to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4e366d7f-af5f-41d2-8330-dcaf9a6ec793", "metadata": {"aucs": [0.3953887654942515, 0.3673853150917803, 0.4015141419168222, 0.38691621601588355, 0.36558300916960806, 0.4078054533056549, 0.390978413505908, 0.3939860098913033, 0.39737159202174155, 0.16554857060365524, 0.14279951361767562, 0.1444461351441414, 0.16780362996903242, 0.15545250824501677, 0.18411480924601553, 0.14375692732494005, 0.15755539117616757, 0.12439084175817627, 0.07356643837521004, 0.07866507351836904, 0.08482325687926917, 0.07200814249639609, 0.07518126213305076, 0.08282286765141611, 0.09021432684285724, 0.07004591094979495, 0.0775905441051733, 0.0649686319237871, 0.06362919958941726, 0.07423678276343837, 0.07991659907937554, 0.06374969185629309, 0.07687221061589589, 0.06835397260270659, 0.07081682525205857, 0.06993858381832363, 0.890627344764051, 0.8847486214361704, 0.866347619123138, 0.7746414787496099, 0.8946355921595175, 0.8501296673269789, 0.8829343813424441, 0.7927987209046685, 0.8541346379837693, 0.17158488620476164, 0.1486191847230961, 0.1732351903540752, 0.15674566399544343, 0.1634116293298652, 0.1882016612086196, 0.167739783112682, 0.17886329208994034, 0.16901384505426853, 0.30686440428745987, 0.25087814405340125, 0.26696723562282554, 0.2536688278049203, 0.2608171755542057, 0.23803466233286852, 0.24286278963409658, 0.23546258208083704, 0.23273180387468595, 0.12502300933140686, 0.11922347167796066, 0.13235366262499215, 0.10614524428799654, 0.09372695836114076, 0.11255746570372027, 0.11333593038045042, 0.09779524801739592, 0.1170446378202229, 0.26409842554969687, 0.2541915856405833, 0.20966107550461488, 0.30480850319389774, 0.3528199471282505, 0.3075732386053657, 0.3635111928753265, 0.24596953261991528, 0.30654321800993845, 0.021707520105609945, 0.034314539124152166, 0.004023841120278648, 0.015480171594729475, 0.02816251329522601, 0.008520488698637974, 0.0493776610258132, 0.049594329625022526, 0.04216685716844826, 0.1473530797382584, 0.1046334933855565, 0.13841338914224777, 0.1295790646048579, 0.09301291294719904, 0.12707664204013125, 0.13869675554596395, 0.12662477552317364, 0.14417444586644945, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011544560095789747, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004217768571194158, 0.004203066948815781, 0.0023247573093938545, 0.0705833923396112, 0.06720968672431771, 0.07890858868259565, 0.07762140771623349, 0.06989061396305274, 0.07883463007400315, 0.060312509554366844, 0.09776386652012847, 0.08067472817706256, 0.32298375144979574, 0.3437536201145551, 0.3392201303813561, 0.3723875308901231, 0.35056836488308984, 0.3623794294296926, 0.3716555409941448, 0.35686715360954246, 0.3532102429695224, 0.06747570089169863, 0.07806850163170254, 0.0916977577207555, 0.07973452719480278, 0.08103358594515409, 0.06797217689560553, 0.07046666987550165, 0.08592555259729884, 0.08191382020400928, 0.221259178827224, 0.17989387552512015, 0.19339772339803152, 0.16449730412783115, 0.11728273808272338, 0.14487030235726028, 0.10585028279010766, 0.13877501797570024, 0.13370029434826225, 0.1961121050212704, 0.23440473552516705, 0.23937541738103296, 0.22831710711194575, 0.22093648094886165, 0.21247098632357708, 0.23711015061346374, 0.23252392387343845, 0.23377643810953797, 0.14975284935083932, 0.16097825884214, 0.16704357853006602, 0.18889952074192484, 0.17349149059467595, 0.1691686501862416, 0.15520194549672883, 0.16348990107485717, 0.17945107357168633, 0.19364739053970847, 0.15356862951293637, 0.17370250767753792, 0.20059425292310384, 0.19602090969749963, 0.14066070046978807, 0.18102813170673193, 0.16650308300720484, 0.18928849687535354, 0.1732245677531371, 0.17818101179327228, 0.16321835518312455, 0.16373601761018586, 0.17158466727112065, 0.16276296956595138, 0.1692362565674288, 0.165954182036414, 0.16586609770808058, 0.1622276765383529, 0.34395331767954784, 0.323024575714681, 0.4571018665533527, 0.5149776622469469, 0.4289540259305501, 0.3661701711208478, 0.4579527784302184, 0.19224777869399245, 0.3271757443032106, 0.2145532415980681, 0.3857806375586642, 0.19088534127060452, 0.31892286118134217, 0.1609857513492814, 0.14687505565686387, 0.5459871018788822, 0.2053014992234773, 0.16857250003754598, 0.15955366812455907, 0.16354192119690192, 0.15781934089886562, 0.18683168487806356, 0.15776603567149527, 0.16379411855922466, 0.18809064021099153, 0.16737483514063756, 0.07037073394088822, 0.08531810785188843, 0.08224504330605831, 0.06912552927297888, 0.06783775628282929, 0.08665465008178075, 0.06023481388061469, 0.05983977189544798, 0.051360474392294075]}, "mutation_prompt": null}
{"id": "a7873dec-617d-4c46-83e2-169bbcca5dc5", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Opposition-based learning\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Adaptive Differential Evolution with Opposition-Based Learning to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4e366d7f-af5f-41d2-8330-dcaf9a6ec793", "metadata": {"aucs": [0.3953887654942515, 0.3673853150917803, 0.4015141419168222, 0.38691621601588355, 0.36558300916960806, 0.4078054533056549, 0.390978413505908, 0.3939860098913033, 0.39737159202174155, 0.16554857060365524, 0.14279951361767562, 0.1444461351441414, 0.16780362996903242, 0.15545250824501677, 0.18411480924601553, 0.14375692732494005, 0.15755539117616757, 0.12439084175817627, 0.07356643837521004, 0.07866507351836904, 0.08482325687926917, 0.07200814249639609, 0.07518126213305076, 0.08282286765141611, 0.09021432684285724, 0.07004591094979495, 0.0775905441051733, 0.0649686319237871, 0.06362919958941726, 0.07423678276343837, 0.07991659907937554, 0.06374969185629309, 0.07687221061589589, 0.06835397260270659, 0.07081682525205857, 0.06993858381832363, 0.890627344764051, 0.8847486214361704, 0.866347619123138, 0.7746414787496099, 0.8946355921595175, 0.8501296673269789, 0.8829343813424441, 0.7927987209046685, 0.8541346379837693, 0.17158488620476164, 0.1486191847230961, 0.1732351903540752, 0.15674566399544343, 0.1634116293298652, 0.1882016612086196, 0.167739783112682, 0.17886329208994034, 0.16901384505426853, 0.30686440428745987, 0.25087814405340125, 0.26696723562282554, 0.2536688278049203, 0.2608171755542057, 0.23803466233286852, 0.24286278963409658, 0.23546258208083704, 0.23273180387468595, 0.12502300933140686, 0.11922347167796066, 0.13235366262499215, 0.10614524428799654, 0.09372695836114076, 0.11255746570372027, 0.11333593038045042, 0.09779524801739592, 0.1170446378202229, 0.26409842554969687, 0.2541915856405833, 0.20966107550461488, 0.30480850319389774, 0.3528199471282505, 0.3075732386053657, 0.3635111928753265, 0.24596953261991528, 0.30654321800993845, 0.021707520105609945, 0.034314539124152166, 0.004023841120278648, 0.015480171594729475, 0.02816251329522601, 0.008520488698637974, 0.0493776610258132, 0.049594329625022526, 0.04216685716844826, 0.1473530797382584, 0.1046334933855565, 0.13841338914224777, 0.1295790646048579, 0.09301291294719904, 0.12707664204013125, 0.13869675554596395, 0.12662477552317364, 0.14417444586644945, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011544560095789747, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004217768571194158, 0.004203066948815781, 0.0023247573093938545, 0.0705833923396112, 0.06720968672431771, 0.07890858868259565, 0.07762140771623349, 0.06989061396305274, 0.07883463007400315, 0.060312509554366844, 0.09776386652012847, 0.08067472817706256, 0.32298375144979574, 0.3437536201145551, 0.3392201303813561, 0.3723875308901231, 0.35056836488308984, 0.3623794294296926, 0.3716555409941448, 0.35686715360954246, 0.3532102429695224, 0.06747570089169863, 0.07806850163170254, 0.0916977577207555, 0.07973452719480278, 0.08103358594515409, 0.06797217689560553, 0.07046666987550165, 0.08592555259729884, 0.08191382020400928, 0.221259178827224, 0.17989387552512015, 0.19339772339803152, 0.16449730412783115, 0.11728273808272338, 0.14487030235726028, 0.10585028279010766, 0.13877501797570024, 0.13370029434826225, 0.1961121050212704, 0.23440473552516705, 0.23937541738103296, 0.22831710711194575, 0.22093648094886165, 0.21247098632357708, 0.23711015061346374, 0.23252392387343845, 0.23377643810953797, 0.14975284935083932, 0.16097825884214, 0.16704357853006602, 0.18889952074192484, 0.17349149059467595, 0.1691686501862416, 0.15520194549672883, 0.16348990107485717, 0.17945107357168633, 0.19364739053970847, 0.15356862951293637, 0.17370250767753792, 0.20059425292310384, 0.19602090969749963, 0.14066070046978807, 0.18102813170673193, 0.16650308300720484, 0.18928849687535354, 0.1732245677531371, 0.17818101179327228, 0.16321835518312455, 0.16373601761018586, 0.17158466727112065, 0.16276296956595138, 0.1692362565674288, 0.165954182036414, 0.16586609770808058, 0.1622276765383529, 0.34395331767954784, 0.323024575714681, 0.4571018665533527, 0.5149776622469469, 0.4289540259305501, 0.3661701711208478, 0.4579527784302184, 0.19224777869399245, 0.3271757443032106, 0.2145532415980681, 0.3857806375586642, 0.19088534127060452, 0.31892286118134217, 0.1609857513492814, 0.14687505565686387, 0.5459871018788822, 0.2053014992234773, 0.16857250003754598, 0.15955366812455907, 0.16354192119690192, 0.15781934089886562, 0.18683168487806356, 0.15776603567149527, 0.16379411855922466, 0.18809064021099153, 0.16737483514063756, 0.07037073394088822, 0.08531810785188843, 0.08224504330605831, 0.06912552927297888, 0.06783775628282929, 0.08665465008178075, 0.06023481388061469, 0.05983977189544798, 0.051360474392294075]}, "mutation_prompt": null}
{"id": "c752eb25-d459-451d-85a2-4303e8bf4e1d", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Opposition-based learning\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Adaptive Differential Evolution with Opposition-Based Learning to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4e366d7f-af5f-41d2-8330-dcaf9a6ec793", "metadata": {"aucs": [0.3953887654942515, 0.3673853150917803, 0.4015141419168222, 0.38691621601588355, 0.36558300916960806, 0.4078054533056549, 0.390978413505908, 0.3939860098913033, 0.39737159202174155, 0.16554857060365524, 0.14279951361767562, 0.1444461351441414, 0.16780362996903242, 0.15545250824501677, 0.18411480924601553, 0.14375692732494005, 0.15755539117616757, 0.12439084175817627, 0.07356643837521004, 0.07866507351836904, 0.08482325687926917, 0.07200814249639609, 0.07518126213305076, 0.08282286765141611, 0.09021432684285724, 0.07004591094979495, 0.0775905441051733, 0.0649686319237871, 0.06362919958941726, 0.07423678276343837, 0.07991659907937554, 0.06374969185629309, 0.07687221061589589, 0.06835397260270659, 0.07081682525205857, 0.06993858381832363, 0.890627344764051, 0.8847486214361704, 0.866347619123138, 0.7746414787496099, 0.8946355921595175, 0.8501296673269789, 0.8829343813424441, 0.7927987209046685, 0.8541346379837693, 0.17158488620476164, 0.1486191847230961, 0.1732351903540752, 0.15674566399544343, 0.1634116293298652, 0.1882016612086196, 0.167739783112682, 0.17886329208994034, 0.16901384505426853, 0.30686440428745987, 0.25087814405340125, 0.26696723562282554, 0.2536688278049203, 0.2608171755542057, 0.23803466233286852, 0.24286278963409658, 0.23546258208083704, 0.23273180387468595, 0.12502300933140686, 0.11922347167796066, 0.13235366262499215, 0.10614524428799654, 0.09372695836114076, 0.11255746570372027, 0.11333593038045042, 0.09779524801739592, 0.1170446378202229, 0.26409842554969687, 0.2541915856405833, 0.20966107550461488, 0.30480850319389774, 0.3528199471282505, 0.3075732386053657, 0.3635111928753265, 0.24596953261991528, 0.30654321800993845, 0.021707520105609945, 0.034314539124152166, 0.004023841120278648, 0.015480171594729475, 0.02816251329522601, 0.008520488698637974, 0.0493776610258132, 0.049594329625022526, 0.04216685716844826, 0.1473530797382584, 0.1046334933855565, 0.13841338914224777, 0.1295790646048579, 0.09301291294719904, 0.12707664204013125, 0.13869675554596395, 0.12662477552317364, 0.14417444586644945, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011544560095789747, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004217768571194158, 0.004203066948815781, 0.0023247573093938545, 0.0705833923396112, 0.06720968672431771, 0.07890858868259565, 0.07762140771623349, 0.06989061396305274, 0.07883463007400315, 0.060312509554366844, 0.09776386652012847, 0.08067472817706256, 0.32298375144979574, 0.3437536201145551, 0.3392201303813561, 0.3723875308901231, 0.35056836488308984, 0.3623794294296926, 0.3716555409941448, 0.35686715360954246, 0.3532102429695224, 0.06747570089169863, 0.07806850163170254, 0.0916977577207555, 0.07973452719480278, 0.08103358594515409, 0.06797217689560553, 0.07046666987550165, 0.08592555259729884, 0.08191382020400928, 0.221259178827224, 0.17989387552512015, 0.19339772339803152, 0.16449730412783115, 0.11728273808272338, 0.14487030235726028, 0.10585028279010766, 0.13877501797570024, 0.13370029434826225, 0.1961121050212704, 0.23440473552516705, 0.23937541738103296, 0.22831710711194575, 0.22093648094886165, 0.21247098632357708, 0.23711015061346374, 0.23252392387343845, 0.23377643810953797, 0.14975284935083932, 0.16097825884214, 0.16704357853006602, 0.18889952074192484, 0.17349149059467595, 0.1691686501862416, 0.15520194549672883, 0.16348990107485717, 0.17945107357168633, 0.19364739053970847, 0.15356862951293637, 0.17370250767753792, 0.20059425292310384, 0.19602090969749963, 0.14066070046978807, 0.18102813170673193, 0.16650308300720484, 0.18928849687535354, 0.1732245677531371, 0.17818101179327228, 0.16321835518312455, 0.16373601761018586, 0.17158466727112065, 0.16276296956595138, 0.1692362565674288, 0.165954182036414, 0.16586609770808058, 0.1622276765383529, 0.34395331767954784, 0.323024575714681, 0.4571018665533527, 0.5149776622469469, 0.4289540259305501, 0.3661701711208478, 0.4579527784302184, 0.19224777869399245, 0.3271757443032106, 0.2145532415980681, 0.3857806375586642, 0.19088534127060452, 0.31892286118134217, 0.1609857513492814, 0.14687505565686387, 0.5459871018788822, 0.2053014992234773, 0.16857250003754598, 0.15955366812455907, 0.16354192119690192, 0.15781934089886562, 0.18683168487806356, 0.15776603567149527, 0.16379411855922466, 0.18809064021099153, 0.16737483514063756, 0.07037073394088822, 0.08531810785188843, 0.08224504330605831, 0.06912552927297888, 0.06783775628282929, 0.08665465008178075, 0.06023481388061469, 0.05983977189544798, 0.051360474392294075]}, "mutation_prompt": null}
{"id": "25050893-0e3d-48a2-83ae-810a6e9abc84", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Opposition-based learning\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Adaptive Differential Evolution with Opposition-Based Learning to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4e366d7f-af5f-41d2-8330-dcaf9a6ec793", "metadata": {"aucs": [0.3953887654942515, 0.3673853150917803, 0.4015141419168222, 0.38691621601588355, 0.36558300916960806, 0.4078054533056549, 0.390978413505908, 0.3939860098913033, 0.39737159202174155, 0.16554857060365524, 0.14279951361767562, 0.1444461351441414, 0.16780362996903242, 0.15545250824501677, 0.18411480924601553, 0.14375692732494005, 0.15755539117616757, 0.12439084175817627, 0.07356643837521004, 0.07866507351836904, 0.08482325687926917, 0.07200814249639609, 0.07518126213305076, 0.08282286765141611, 0.09021432684285724, 0.07004591094979495, 0.0775905441051733, 0.0649686319237871, 0.06362919958941726, 0.07423678276343837, 0.07991659907937554, 0.06374969185629309, 0.07687221061589589, 0.06835397260270659, 0.07081682525205857, 0.06993858381832363, 0.890627344764051, 0.8847486214361704, 0.866347619123138, 0.7746414787496099, 0.8946355921595175, 0.8501296673269789, 0.8829343813424441, 0.7927987209046685, 0.8541346379837693, 0.17158488620476164, 0.1486191847230961, 0.1732351903540752, 0.15674566399544343, 0.1634116293298652, 0.1882016612086196, 0.167739783112682, 0.17886329208994034, 0.16901384505426853, 0.30686440428745987, 0.25087814405340125, 0.26696723562282554, 0.2536688278049203, 0.2608171755542057, 0.23803466233286852, 0.24286278963409658, 0.23546258208083704, 0.23273180387468595, 0.12502300933140686, 0.11922347167796066, 0.13235366262499215, 0.10614524428799654, 0.09372695836114076, 0.11255746570372027, 0.11333593038045042, 0.09779524801739592, 0.1170446378202229, 0.26409842554969687, 0.2541915856405833, 0.20966107550461488, 0.30480850319389774, 0.3528199471282505, 0.3075732386053657, 0.3635111928753265, 0.24596953261991528, 0.30654321800993845, 0.021707520105609945, 0.034314539124152166, 0.004023841120278648, 0.015480171594729475, 0.02816251329522601, 0.008520488698637974, 0.0493776610258132, 0.049594329625022526, 0.04216685716844826, 0.1473530797382584, 0.1046334933855565, 0.13841338914224777, 0.1295790646048579, 0.09301291294719904, 0.12707664204013125, 0.13869675554596395, 0.12662477552317364, 0.14417444586644945, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011544560095789747, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004217768571194158, 0.004203066948815781, 0.0023247573093938545, 0.0705833923396112, 0.06720968672431771, 0.07890858868259565, 0.07762140771623349, 0.06989061396305274, 0.07883463007400315, 0.060312509554366844, 0.09776386652012847, 0.08067472817706256, 0.32298375144979574, 0.3437536201145551, 0.3392201303813561, 0.3723875308901231, 0.35056836488308984, 0.3623794294296926, 0.3716555409941448, 0.35686715360954246, 0.3532102429695224, 0.06747570089169863, 0.07806850163170254, 0.0916977577207555, 0.07973452719480278, 0.08103358594515409, 0.06797217689560553, 0.07046666987550165, 0.08592555259729884, 0.08191382020400928, 0.221259178827224, 0.17989387552512015, 0.19339772339803152, 0.16449730412783115, 0.11728273808272338, 0.14487030235726028, 0.10585028279010766, 0.13877501797570024, 0.13370029434826225, 0.1961121050212704, 0.23440473552516705, 0.23937541738103296, 0.22831710711194575, 0.22093648094886165, 0.21247098632357708, 0.23711015061346374, 0.23252392387343845, 0.23377643810953797, 0.14975284935083932, 0.16097825884214, 0.16704357853006602, 0.18889952074192484, 0.17349149059467595, 0.1691686501862416, 0.15520194549672883, 0.16348990107485717, 0.17945107357168633, 0.19364739053970847, 0.15356862951293637, 0.17370250767753792, 0.20059425292310384, 0.19602090969749963, 0.14066070046978807, 0.18102813170673193, 0.16650308300720484, 0.18928849687535354, 0.1732245677531371, 0.17818101179327228, 0.16321835518312455, 0.16373601761018586, 0.17158466727112065, 0.16276296956595138, 0.1692362565674288, 0.165954182036414, 0.16586609770808058, 0.1622276765383529, 0.34395331767954784, 0.323024575714681, 0.4571018665533527, 0.5149776622469469, 0.4289540259305501, 0.3661701711208478, 0.4579527784302184, 0.19224777869399245, 0.3271757443032106, 0.2145532415980681, 0.3857806375586642, 0.19088534127060452, 0.31892286118134217, 0.1609857513492814, 0.14687505565686387, 0.5459871018788822, 0.2053014992234773, 0.16857250003754598, 0.15955366812455907, 0.16354192119690192, 0.15781934089886562, 0.18683168487806356, 0.15776603567149527, 0.16379411855922466, 0.18809064021099153, 0.16737483514063756, 0.07037073394088822, 0.08531810785188843, 0.08224504330605831, 0.06912552927297888, 0.06783775628282929, 0.08665465008178075, 0.06023481388061469, 0.05983977189544798, 0.051360474392294075]}, "mutation_prompt": null}
{"id": "dab9bb71-49a1-459c-a8d8-a5f8337cb593", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Opposition-based learning\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Adaptive Differential Evolution with Opposition-Based Learning to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4e366d7f-af5f-41d2-8330-dcaf9a6ec793", "metadata": {"aucs": [0.3953887654942515, 0.3673853150917803, 0.4015141419168222, 0.38691621601588355, 0.36558300916960806, 0.4078054533056549, 0.390978413505908, 0.3939860098913033, 0.39737159202174155, 0.16554857060365524, 0.14279951361767562, 0.1444461351441414, 0.16780362996903242, 0.15545250824501677, 0.18411480924601553, 0.14375692732494005, 0.15755539117616757, 0.12439084175817627, 0.07356643837521004, 0.07866507351836904, 0.08482325687926917, 0.07200814249639609, 0.07518126213305076, 0.08282286765141611, 0.09021432684285724, 0.07004591094979495, 0.0775905441051733, 0.0649686319237871, 0.06362919958941726, 0.07423678276343837, 0.07991659907937554, 0.06374969185629309, 0.07687221061589589, 0.06835397260270659, 0.07081682525205857, 0.06993858381832363, 0.890627344764051, 0.8847486214361704, 0.866347619123138, 0.7746414787496099, 0.8946355921595175, 0.8501296673269789, 0.8829343813424441, 0.7927987209046685, 0.8541346379837693, 0.17158488620476164, 0.1486191847230961, 0.1732351903540752, 0.15674566399544343, 0.1634116293298652, 0.1882016612086196, 0.167739783112682, 0.17886329208994034, 0.16901384505426853, 0.30686440428745987, 0.25087814405340125, 0.26696723562282554, 0.2536688278049203, 0.2608171755542057, 0.23803466233286852, 0.24286278963409658, 0.23546258208083704, 0.23273180387468595, 0.12502300933140686, 0.11922347167796066, 0.13235366262499215, 0.10614524428799654, 0.09372695836114076, 0.11255746570372027, 0.11333593038045042, 0.09779524801739592, 0.1170446378202229, 0.26409842554969687, 0.2541915856405833, 0.20966107550461488, 0.30480850319389774, 0.3528199471282505, 0.3075732386053657, 0.3635111928753265, 0.24596953261991528, 0.30654321800993845, 0.021707520105609945, 0.034314539124152166, 0.004023841120278648, 0.015480171594729475, 0.02816251329522601, 0.008520488698637974, 0.0493776610258132, 0.049594329625022526, 0.04216685716844826, 0.1473530797382584, 0.1046334933855565, 0.13841338914224777, 0.1295790646048579, 0.09301291294719904, 0.12707664204013125, 0.13869675554596395, 0.12662477552317364, 0.14417444586644945, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011544560095789747, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004217768571194158, 0.004203066948815781, 0.0023247573093938545, 0.0705833923396112, 0.06720968672431771, 0.07890858868259565, 0.07762140771623349, 0.06989061396305274, 0.07883463007400315, 0.060312509554366844, 0.09776386652012847, 0.08067472817706256, 0.32298375144979574, 0.3437536201145551, 0.3392201303813561, 0.3723875308901231, 0.35056836488308984, 0.3623794294296926, 0.3716555409941448, 0.35686715360954246, 0.3532102429695224, 0.06747570089169863, 0.07806850163170254, 0.0916977577207555, 0.07973452719480278, 0.08103358594515409, 0.06797217689560553, 0.07046666987550165, 0.08592555259729884, 0.08191382020400928, 0.221259178827224, 0.17989387552512015, 0.19339772339803152, 0.16449730412783115, 0.11728273808272338, 0.14487030235726028, 0.10585028279010766, 0.13877501797570024, 0.13370029434826225, 0.1961121050212704, 0.23440473552516705, 0.23937541738103296, 0.22831710711194575, 0.22093648094886165, 0.21247098632357708, 0.23711015061346374, 0.23252392387343845, 0.23377643810953797, 0.14975284935083932, 0.16097825884214, 0.16704357853006602, 0.18889952074192484, 0.17349149059467595, 0.1691686501862416, 0.15520194549672883, 0.16348990107485717, 0.17945107357168633, 0.19364739053970847, 0.15356862951293637, 0.17370250767753792, 0.20059425292310384, 0.19602090969749963, 0.14066070046978807, 0.18102813170673193, 0.16650308300720484, 0.18928849687535354, 0.1732245677531371, 0.17818101179327228, 0.16321835518312455, 0.16373601761018586, 0.17158466727112065, 0.16276296956595138, 0.1692362565674288, 0.165954182036414, 0.16586609770808058, 0.1622276765383529, 0.34395331767954784, 0.323024575714681, 0.4571018665533527, 0.5149776622469469, 0.4289540259305501, 0.3661701711208478, 0.4579527784302184, 0.19224777869399245, 0.3271757443032106, 0.2145532415980681, 0.3857806375586642, 0.19088534127060452, 0.31892286118134217, 0.1609857513492814, 0.14687505565686387, 0.5459871018788822, 0.2053014992234773, 0.16857250003754598, 0.15955366812455907, 0.16354192119690192, 0.15781934089886562, 0.18683168487806356, 0.15776603567149527, 0.16379411855922466, 0.18809064021099153, 0.16737483514063756, 0.07037073394088822, 0.08531810785188843, 0.08224504330605831, 0.06912552927297888, 0.06783775628282929, 0.08665465008178075, 0.06023481388061469, 0.05983977189544798, 0.051360474392294075]}, "mutation_prompt": null}
{"id": "d230c41d-376b-4d0b-a66f-0cd1780ffa7a", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Opposition-based learning\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Adaptive Differential Evolution with Opposition-Based Learning to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4e366d7f-af5f-41d2-8330-dcaf9a6ec793", "metadata": {"aucs": [0.3953887654942515, 0.3673853150917803, 0.4015141419168222, 0.38691621601588355, 0.36558300916960806, 0.4078054533056549, 0.390978413505908, 0.3939860098913033, 0.39737159202174155, 0.16554857060365524, 0.14279951361767562, 0.1444461351441414, 0.16780362996903242, 0.15545250824501677, 0.18411480924601553, 0.14375692732494005, 0.15755539117616757, 0.12439084175817627, 0.07356643837521004, 0.07866507351836904, 0.08482325687926917, 0.07200814249639609, 0.07518126213305076, 0.08282286765141611, 0.09021432684285724, 0.07004591094979495, 0.0775905441051733, 0.0649686319237871, 0.06362919958941726, 0.07423678276343837, 0.07991659907937554, 0.06374969185629309, 0.07687221061589589, 0.06835397260270659, 0.07081682525205857, 0.06993858381832363, 0.890627344764051, 0.8847486214361704, 0.866347619123138, 0.7746414787496099, 0.8946355921595175, 0.8501296673269789, 0.8829343813424441, 0.7927987209046685, 0.8541346379837693, 0.17158488620476164, 0.1486191847230961, 0.1732351903540752, 0.15674566399544343, 0.1634116293298652, 0.1882016612086196, 0.167739783112682, 0.17886329208994034, 0.16901384505426853, 0.30686440428745987, 0.25087814405340125, 0.26696723562282554, 0.2536688278049203, 0.2608171755542057, 0.23803466233286852, 0.24286278963409658, 0.23546258208083704, 0.23273180387468595, 0.12502300933140686, 0.11922347167796066, 0.13235366262499215, 0.10614524428799654, 0.09372695836114076, 0.11255746570372027, 0.11333593038045042, 0.09779524801739592, 0.1170446378202229, 0.26409842554969687, 0.2541915856405833, 0.20966107550461488, 0.30480850319389774, 0.3528199471282505, 0.3075732386053657, 0.3635111928753265, 0.24596953261991528, 0.30654321800993845, 0.021707520105609945, 0.034314539124152166, 0.004023841120278648, 0.015480171594729475, 0.02816251329522601, 0.008520488698637974, 0.0493776610258132, 0.049594329625022526, 0.04216685716844826, 0.1473530797382584, 0.1046334933855565, 0.13841338914224777, 0.1295790646048579, 0.09301291294719904, 0.12707664204013125, 0.13869675554596395, 0.12662477552317364, 0.14417444586644945, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011544560095789747, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004217768571194158, 0.004203066948815781, 0.0023247573093938545, 0.0705833923396112, 0.06720968672431771, 0.07890858868259565, 0.07762140771623349, 0.06989061396305274, 0.07883463007400315, 0.060312509554366844, 0.09776386652012847, 0.08067472817706256, 0.32298375144979574, 0.3437536201145551, 0.3392201303813561, 0.3723875308901231, 0.35056836488308984, 0.3623794294296926, 0.3716555409941448, 0.35686715360954246, 0.3532102429695224, 0.06747570089169863, 0.07806850163170254, 0.0916977577207555, 0.07973452719480278, 0.08103358594515409, 0.06797217689560553, 0.07046666987550165, 0.08592555259729884, 0.08191382020400928, 0.221259178827224, 0.17989387552512015, 0.19339772339803152, 0.16449730412783115, 0.11728273808272338, 0.14487030235726028, 0.10585028279010766, 0.13877501797570024, 0.13370029434826225, 0.1961121050212704, 0.23440473552516705, 0.23937541738103296, 0.22831710711194575, 0.22093648094886165, 0.21247098632357708, 0.23711015061346374, 0.23252392387343845, 0.23377643810953797, 0.14975284935083932, 0.16097825884214, 0.16704357853006602, 0.18889952074192484, 0.17349149059467595, 0.1691686501862416, 0.15520194549672883, 0.16348990107485717, 0.17945107357168633, 0.19364739053970847, 0.15356862951293637, 0.17370250767753792, 0.20059425292310384, 0.19602090969749963, 0.14066070046978807, 0.18102813170673193, 0.16650308300720484, 0.18928849687535354, 0.1732245677531371, 0.17818101179327228, 0.16321835518312455, 0.16373601761018586, 0.17158466727112065, 0.16276296956595138, 0.1692362565674288, 0.165954182036414, 0.16586609770808058, 0.1622276765383529, 0.34395331767954784, 0.323024575714681, 0.4571018665533527, 0.5149776622469469, 0.4289540259305501, 0.3661701711208478, 0.4579527784302184, 0.19224777869399245, 0.3271757443032106, 0.2145532415980681, 0.3857806375586642, 0.19088534127060452, 0.31892286118134217, 0.1609857513492814, 0.14687505565686387, 0.5459871018788822, 0.2053014992234773, 0.16857250003754598, 0.15955366812455907, 0.16354192119690192, 0.15781934089886562, 0.18683168487806356, 0.15776603567149527, 0.16379411855922466, 0.18809064021099153, 0.16737483514063756, 0.07037073394088822, 0.08531810785188843, 0.08224504330605831, 0.06912552927297888, 0.06783775628282929, 0.08665465008178075, 0.06023481388061469, 0.05983977189544798, 0.051360474392294075]}, "mutation_prompt": null}
{"id": "5abdcdad-fe79-49a0-936e-1485cd2aaec8", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Opposition-based learning\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Adaptive Differential Evolution with Opposition-Based Learning to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4e366d7f-af5f-41d2-8330-dcaf9a6ec793", "metadata": {"aucs": [0.3953887654942515, 0.3673853150917803, 0.4015141419168222, 0.38691621601588355, 0.36558300916960806, 0.4078054533056549, 0.390978413505908, 0.3939860098913033, 0.39737159202174155, 0.16554857060365524, 0.14279951361767562, 0.1444461351441414, 0.16780362996903242, 0.15545250824501677, 0.18411480924601553, 0.14375692732494005, 0.15755539117616757, 0.12439084175817627, 0.07356643837521004, 0.07866507351836904, 0.08482325687926917, 0.07200814249639609, 0.07518126213305076, 0.08282286765141611, 0.09021432684285724, 0.07004591094979495, 0.0775905441051733, 0.0649686319237871, 0.06362919958941726, 0.07423678276343837, 0.07991659907937554, 0.06374969185629309, 0.07687221061589589, 0.06835397260270659, 0.07081682525205857, 0.06993858381832363, 0.890627344764051, 0.8847486214361704, 0.866347619123138, 0.7746414787496099, 0.8946355921595175, 0.8501296673269789, 0.8829343813424441, 0.7927987209046685, 0.8541346379837693, 0.17158488620476164, 0.1486191847230961, 0.1732351903540752, 0.15674566399544343, 0.1634116293298652, 0.1882016612086196, 0.167739783112682, 0.17886329208994034, 0.16901384505426853, 0.30686440428745987, 0.25087814405340125, 0.26696723562282554, 0.2536688278049203, 0.2608171755542057, 0.23803466233286852, 0.24286278963409658, 0.23546258208083704, 0.23273180387468595, 0.12502300933140686, 0.11922347167796066, 0.13235366262499215, 0.10614524428799654, 0.09372695836114076, 0.11255746570372027, 0.11333593038045042, 0.09779524801739592, 0.1170446378202229, 0.26409842554969687, 0.2541915856405833, 0.20966107550461488, 0.30480850319389774, 0.3528199471282505, 0.3075732386053657, 0.3635111928753265, 0.24596953261991528, 0.30654321800993845, 0.021707520105609945, 0.034314539124152166, 0.004023841120278648, 0.015480171594729475, 0.02816251329522601, 0.008520488698637974, 0.0493776610258132, 0.049594329625022526, 0.04216685716844826, 0.1473530797382584, 0.1046334933855565, 0.13841338914224777, 0.1295790646048579, 0.09301291294719904, 0.12707664204013125, 0.13869675554596395, 0.12662477552317364, 0.14417444586644945, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011544560095789747, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004217768571194158, 0.004203066948815781, 0.0023247573093938545, 0.0705833923396112, 0.06720968672431771, 0.07890858868259565, 0.07762140771623349, 0.06989061396305274, 0.07883463007400315, 0.060312509554366844, 0.09776386652012847, 0.08067472817706256, 0.32298375144979574, 0.3437536201145551, 0.3392201303813561, 0.3723875308901231, 0.35056836488308984, 0.3623794294296926, 0.3716555409941448, 0.35686715360954246, 0.3532102429695224, 0.06747570089169863, 0.07806850163170254, 0.0916977577207555, 0.07973452719480278, 0.08103358594515409, 0.06797217689560553, 0.07046666987550165, 0.08592555259729884, 0.08191382020400928, 0.221259178827224, 0.17989387552512015, 0.19339772339803152, 0.16449730412783115, 0.11728273808272338, 0.14487030235726028, 0.10585028279010766, 0.13877501797570024, 0.13370029434826225, 0.1961121050212704, 0.23440473552516705, 0.23937541738103296, 0.22831710711194575, 0.22093648094886165, 0.21247098632357708, 0.23711015061346374, 0.23252392387343845, 0.23377643810953797, 0.14975284935083932, 0.16097825884214, 0.16704357853006602, 0.18889952074192484, 0.17349149059467595, 0.1691686501862416, 0.15520194549672883, 0.16348990107485717, 0.17945107357168633, 0.19364739053970847, 0.15356862951293637, 0.17370250767753792, 0.20059425292310384, 0.19602090969749963, 0.14066070046978807, 0.18102813170673193, 0.16650308300720484, 0.18928849687535354, 0.1732245677531371, 0.17818101179327228, 0.16321835518312455, 0.16373601761018586, 0.17158466727112065, 0.16276296956595138, 0.1692362565674288, 0.165954182036414, 0.16586609770808058, 0.1622276765383529, 0.34395331767954784, 0.323024575714681, 0.4571018665533527, 0.5149776622469469, 0.4289540259305501, 0.3661701711208478, 0.4579527784302184, 0.19224777869399245, 0.3271757443032106, 0.2145532415980681, 0.3857806375586642, 0.19088534127060452, 0.31892286118134217, 0.1609857513492814, 0.14687505565686387, 0.5459871018788822, 0.2053014992234773, 0.16857250003754598, 0.15955366812455907, 0.16354192119690192, 0.15781934089886562, 0.18683168487806356, 0.15776603567149527, 0.16379411855922466, 0.18809064021099153, 0.16737483514063756, 0.07037073394088822, 0.08531810785188843, 0.08224504330605831, 0.06912552927297888, 0.06783775628282929, 0.08665465008178075, 0.06023481388061469, 0.05983977189544798, 0.051360474392294075]}, "mutation_prompt": null}
{"id": "7fbbe9af-38cc-4b65-a567-bbd9f38cc0a0", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Opposition-based learning\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Adaptive Differential Evolution with Opposition-Based Learning to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4e366d7f-af5f-41d2-8330-dcaf9a6ec793", "metadata": {"aucs": [0.3953887654942515, 0.3673853150917803, 0.4015141419168222, 0.38691621601588355, 0.36558300916960806, 0.4078054533056549, 0.390978413505908, 0.3939860098913033, 0.39737159202174155, 0.16554857060365524, 0.14279951361767562, 0.1444461351441414, 0.16780362996903242, 0.15545250824501677, 0.18411480924601553, 0.14375692732494005, 0.15755539117616757, 0.12439084175817627, 0.07356643837521004, 0.07866507351836904, 0.08482325687926917, 0.07200814249639609, 0.07518126213305076, 0.08282286765141611, 0.09021432684285724, 0.07004591094979495, 0.0775905441051733, 0.0649686319237871, 0.06362919958941726, 0.07423678276343837, 0.07991659907937554, 0.06374969185629309, 0.07687221061589589, 0.06835397260270659, 0.07081682525205857, 0.06993858381832363, 0.890627344764051, 0.8847486214361704, 0.866347619123138, 0.7746414787496099, 0.8946355921595175, 0.8501296673269789, 0.8829343813424441, 0.7927987209046685, 0.8541346379837693, 0.17158488620476164, 0.1486191847230961, 0.1732351903540752, 0.15674566399544343, 0.1634116293298652, 0.1882016612086196, 0.167739783112682, 0.17886329208994034, 0.16901384505426853, 0.30686440428745987, 0.25087814405340125, 0.26696723562282554, 0.2536688278049203, 0.2608171755542057, 0.23803466233286852, 0.24286278963409658, 0.23546258208083704, 0.23273180387468595, 0.12502300933140686, 0.11922347167796066, 0.13235366262499215, 0.10614524428799654, 0.09372695836114076, 0.11255746570372027, 0.11333593038045042, 0.09779524801739592, 0.1170446378202229, 0.26409842554969687, 0.2541915856405833, 0.20966107550461488, 0.30480850319389774, 0.3528199471282505, 0.3075732386053657, 0.3635111928753265, 0.24596953261991528, 0.30654321800993845, 0.021707520105609945, 0.034314539124152166, 0.004023841120278648, 0.015480171594729475, 0.02816251329522601, 0.008520488698637974, 0.0493776610258132, 0.049594329625022526, 0.04216685716844826, 0.1473530797382584, 0.1046334933855565, 0.13841338914224777, 0.1295790646048579, 0.09301291294719904, 0.12707664204013125, 0.13869675554596395, 0.12662477552317364, 0.14417444586644945, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011544560095789747, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004217768571194158, 0.004203066948815781, 0.0023247573093938545, 0.0705833923396112, 0.06720968672431771, 0.07890858868259565, 0.07762140771623349, 0.06989061396305274, 0.07883463007400315, 0.060312509554366844, 0.09776386652012847, 0.08067472817706256, 0.32298375144979574, 0.3437536201145551, 0.3392201303813561, 0.3723875308901231, 0.35056836488308984, 0.3623794294296926, 0.3716555409941448, 0.35686715360954246, 0.3532102429695224, 0.06747570089169863, 0.07806850163170254, 0.0916977577207555, 0.07973452719480278, 0.08103358594515409, 0.06797217689560553, 0.07046666987550165, 0.08592555259729884, 0.08191382020400928, 0.221259178827224, 0.17989387552512015, 0.19339772339803152, 0.16449730412783115, 0.11728273808272338, 0.14487030235726028, 0.10585028279010766, 0.13877501797570024, 0.13370029434826225, 0.1961121050212704, 0.23440473552516705, 0.23937541738103296, 0.22831710711194575, 0.22093648094886165, 0.21247098632357708, 0.23711015061346374, 0.23252392387343845, 0.23377643810953797, 0.14975284935083932, 0.16097825884214, 0.16704357853006602, 0.18889952074192484, 0.17349149059467595, 0.1691686501862416, 0.15520194549672883, 0.16348990107485717, 0.17945107357168633, 0.19364739053970847, 0.15356862951293637, 0.17370250767753792, 0.20059425292310384, 0.19602090969749963, 0.14066070046978807, 0.18102813170673193, 0.16650308300720484, 0.18928849687535354, 0.1732245677531371, 0.17818101179327228, 0.16321835518312455, 0.16373601761018586, 0.17158466727112065, 0.16276296956595138, 0.1692362565674288, 0.165954182036414, 0.16586609770808058, 0.1622276765383529, 0.34395331767954784, 0.323024575714681, 0.4571018665533527, 0.5149776622469469, 0.4289540259305501, 0.3661701711208478, 0.4579527784302184, 0.19224777869399245, 0.3271757443032106, 0.2145532415980681, 0.3857806375586642, 0.19088534127060452, 0.31892286118134217, 0.1609857513492814, 0.14687505565686387, 0.5459871018788822, 0.2053014992234773, 0.16857250003754598, 0.15955366812455907, 0.16354192119690192, 0.15781934089886562, 0.18683168487806356, 0.15776603567149527, 0.16379411855922466, 0.18809064021099153, 0.16737483514063756, 0.07037073394088822, 0.08531810785188843, 0.08224504330605831, 0.06912552927297888, 0.06783775628282929, 0.08665465008178075, 0.06023481388061469, 0.05983977189544798, 0.051360474392294075]}, "mutation_prompt": null}
{"id": "2bf65165-ef45-4cce-a28e-746967ecb692", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 32, "fitness": 0.21302608029193026, "feedback": "The algorithm ADE_OBL got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": "4e366d7f-af5f-41d2-8330-dcaf9a6ec793", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "53918e13-93b8-4a3a-8b71-8ff9b246a30d", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "f104073b-8b70-43c5-83c3-c1b7e61b7fe9", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "bf39e189-24c7-4811-ae19-0c4cb8b820c3", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "3b24853b-c38b-4a90-a73f-03bff9359bed", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "e94f0257-1ed1-4d74-9d88-857f7336c0b2", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "9365eb29-8a1d-4fb3-9d0d-f402d5ab0a05", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "eb06edee-f8e0-4d52-9cf9-ad395fe4f72f", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "73fd8626-6414-4b5f-9d4c-c0daa0b20c92", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "785e8d47-eacc-4d32-980e-2193558300db", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "ea4acd44-de70-4dd5-94f3-b71be3b4de36", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "14ea58a8-928d-4ddd-b591-a879544736ea", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "752f0a73-943f-40c1-9275-ed0409ca7939", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "0e08a7fe-2532-47e7-8d04-66dacf14efb4", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "b944872f-9cdd-4c7f-afa4-9bcf0112658e", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "1592430c-45f8-4166-905b-2fee703f10c9", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "0e8e69de-a1cb-41e1-9d61-90ca0b3bbe32", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "7233fda4-ebd5-4ee5-b236-e464fc534a2e", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "1b7f8c0e-d37b-4e90-b079-8bade5944b5d", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "ae844ddc-1ea4-42c6-af7e-1749488af5de", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "5ad0d583-e553-4116-8d15-29db75442afa", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "00922f71-1a17-4993-9737-246ae5fdb094", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "95c21b4d-0858-472d-b8d0-4577a82e832a", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "43c4d28d-7edd-47e2-9514-02d74b5e40c0", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "dcda9ef5-aac5-4a34-8800-6062301fa1cb", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n        self.selection_noise = 0.05  # New parameter for stochastic perturbation\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Introduce stochastic perturbation during selection\n            stochastic_fitness = combined_fitness + np.random.normal(0, self.selection_noise, combined_fitness.shape)\n\n            best_indices = np.argsort(stochastic_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Introducing stochastic perturbation in the selection phase to enhance exploration by diversifying selection pressure.", "configspace": "", "generation": 56, "fitness": 0.20338429728920152, "feedback": "The algorithm ADE_OBL got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.18.", "error": "", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.36700736419127156, 0.35749429231936125, 0.3847132313554479, 0.3959123936654707, 0.3841825657801743, 0.4076483567270609, 0.41337277733622846, 0.38961538356285896, 0.41179387531946754, 0.1331423509394568, 0.13083961358428697, 0.14778565148814737, 0.16454370916896455, 0.15161985635689812, 0.1571186913426893, 0.1374941409626066, 0.16322434739161895, 0.1384341362042234, 0.08241406934975071, 0.0782366022419988, 0.07950213658464766, 0.08247210062522137, 0.06887737769850355, 0.07791886411794491, 0.08585706454904962, 0.09636406016628352, 0.08375071387656552, 0.07762364274649969, 0.08364895365655789, 0.0704118367649551, 0.07652685353966804, 0.09113515709767639, 0.06881729069669618, 0.0670490363786117, 0.08190233171458317, 0.07387460021063785, 0.9262062287684718, 0.789587646195726, 0.8417315701090945, 0.854474553520399, 0.8803330039691077, 0.8963081568980742, 0.9587648544920488, 0.8751172276737527, 0.8933064138524293, 0.15760524829394018, 0.14975122060371227, 0.17294550053203983, 0.16708892227906236, 0.16150540585428574, 0.1831160305957702, 0.16576144586578412, 0.15681277189787657, 0.16620081722781965, 0.26114169140648724, 0.2941396757612489, 0.26329055442632976, 0.24801725337178915, 0.2292063943594883, 0.2760734720281852, 0.27235040344677763, 0.23278301441153915, 0.2524462868090518, 0.12820212190082125, 0.13601404216967716, 0.12968468721205684, 0.09793501602510646, 0.09781832653776656, 0.10797285179085048, 0.1086568868338571, 0.09125205015023241, 0.0913266119274524, 0.3034804817387081, 0.2794869693215474, 0.22195237067113482, 0.2826424850300039, 0.22561511996048744, 0.20266283641388982, 0.2750659888290796, 0.25094299094077177, 0.32622917476287727, 0.01639654925158962, 0.027530575778523914, 0.02450302564750184, 0.0295639006870535, 0.004910790346045135, 0.023118598223731746, 0.05472376020269043, 0.03496691221189596, 0.03588026939044464, 0.11001374424277821, 0.11770598380197261, 0.15741311507349243, 0.14396899172383526, 0.1181787426868336, 0.10306287560775218, 0.15686204095461598, 0.14906115572713385, 0.14949026175604563, 0.0006188995664612174, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00022572485943650467, 9.999999999998899e-05, 0.004165603451823374, 0.08435835665039171, 0.05788296868954679, 0.07680018747510164, 0.07185843943308778, 0.06386714562589801, 0.10436010073197599, 0.06619307237516114, 0.07231575913392896, 0.0713721332303836, 0.3409275828102062, 0.3556003905619094, 0.33054496874975625, 0.344484673965084, 0.3548763751788776, 0.3519405032115125, 0.36460413651249746, 0.35642581526608696, 0.36161812883361877, 0.06716302582055611, 0.07082187626356606, 0.06654295176993252, 0.06515351689781679, 0.06288527920933851, 0.07200890638455426, 0.09280037807494168, 0.0796583607690654, 0.07601632013780169, 0.19180789595944814, 0.15472881866332722, 0.17346713047398388, 0.14922933347416145, 0.16394946775624686, 0.1493482071515746, 0.14738797299061557, 0.15717478393459128, 0.16830840970847583, 0.2132012038731712, 0.2072726666361615, 0.2354341199123866, 0.2487101891789013, 0.22020569458350137, 0.23688971701111328, 0.22688516255599767, 0.23498863521236768, 0.22621332987155574, 0.17527703687719454, 0.15038685825729758, 0.14174060732816796, 0.1816466475206997, 0.17711840410711632, 0.18788278533203562, 0.161773559803561, 0.17356355711132876, 0.1660759764808094, 0.23303591083581532, 0.1921325419159503, 0.19341070638948232, 0.27626661597940494, 0.21908174123036528, 0.20019986146551016, 0.22130607285030446, 0.19287397965361142, 0.20764427627852122, 0.16285860785473438, 0.16948191239747634, 0.17039360633848977, 0.1660286584994496, 0.15857556586070698, 0.1709930814561441, 0.16201198765391023, 0.16158374605204517, 0.1755138485439851, 0.25510747280115775, 0.17034459503737398, 0.17157461039273736, 0.5899721056927523, 0.47254472127708325, 0.41638005547770285, 0.1627271552381404, 0.1714075159081161, 0.2749423787268791, 0.5092120054220287, 0.39760609803022584, 0.23386225830875151, 0.18299840349361352, 0.5407248903700298, 0.4552853206280687, 0.15738059354999545, 0.19929567024149597, 0.20455976153336353, 0.18177874084887302, 0.22314261990417528, 0.1832934100823007, 0.18266988850319654, 0.18976798630848724, 0.17832189703314016, 0.21680584585650353, 0.18484001865308142, 0.17070431609635683, 0.08370188509411469, 0.10653967156606792, 0.09341507288610051, 0.0978235449982563, 0.11372220418362744, 0.0927219769094485, 0.0887382244914543, 0.12152230804848296, 0.11013701631969275]}, "mutation_prompt": null}
{"id": "04dfc2d1-b011-49eb-9775-3889ff58c258", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "456f7c4d-596d-4615-a2e6-d4b6cc0015e5", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "bf6659e1-d690-46b6-be3f-f43c9f232dff", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "a6b97d17-fe3a-4ba8-b897-e1d75f9c6045", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "540b6eb1-ca8e-46fd-99a8-928d3bdee3b5", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "aaa4c1eb-28c0-44ab-8b53-2312354e626f", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "0fe5e028-fa2f-4936-978d-03ad0f1853b0", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "b6a4bf4b-0927-45e1-bf49-3e2080067ae7", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "fd1703f0-991b-41f9-9d98-166e3eb26779", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "9034dfe2-60ac-4006-b62c-465c12fa66f4", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "0fcd5011-4b6d-4b9c-aecc-317b6d7dfb9f", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "17c4cf2e-bbb9-4c83-a732-1219d228222c", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "78635ce1-f0b8-4a9c-bb74-17729358d0ad", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "8eee1912-7bcb-408f-8f69-5bd9b2ec9d2e", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "427fdea4-bde1-4b77-95d1-d5151942ba1f", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "060bc1d0-335d-406c-b599-6c53d9523ab2", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "e7345ee2-291e-463a-942b-c313dc390b9e", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "546d418b-4000-43c1-aae3-b556c6ab8e0b", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "68414ef6-4f1e-472e-a14e-bc6420de3909", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "ab5817c0-f61d-471a-9518-daaf1e4152ad", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "e2b7220d-1344-4abb-9570-d151413d2431", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "ebc93e43-a19e-4ae4-84f7-4f9c1edf8614", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "72adb361-185d-44ce-b53a-aa63faf47e84", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "25af2b59-4300-4d15-9ce5-12c7b6fa06a9", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "96747c1e-75c0-4c4f-9527-8865fdfd1491", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "cae4eab2-aa73-4919-be3b-de937af6cc13", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "463e2573-4946-410f-a5ff-db98df0495d1", "solution": "import numpy as np\n\nclass ADE_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n        restart_threshold = 0.1 * self.budget\n\n        while eval_count < self.budget:\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            if eval_count % restart_threshold == 0:  # Selective restart\n                population = self._initialize_population()\n                fitness = self._evaluate_population(population, func)\n                continue\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_Improved", "description": "Improved ADE with adaptive scaling and selective restart to enhance convergence speed and robustness.", "configspace": "", "generation": 83, "fitness": 0.21165730264992724, "feedback": "The algorithm ADE_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.40285664180156044, 0.3745792503054385, 0.36623664853098525, 0.3925774949361075, 0.38146481688872524, 0.4249492081610864, 0.38849756298839955, 0.4058741422017452, 0.41277120621772667, 0.1337609930575664, 0.13196018945859456, 0.15906855953267207, 0.13642304317231224, 0.19018853855699824, 0.1736576651672116, 0.11099740981525852, 0.1421446405881568, 0.1277793261912995, 0.08480331417794662, 0.08714220400676609, 0.07475268051850181, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06777418739348617, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.0630470630040052, 0.07444531150978384, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.17973348988825688, 0.1702187971766823, 0.1656104810601171, 0.1549765373482438, 0.14809433846602893, 0.16548148749156266, 0.1645487032914814, 0.16763566611642622, 0.18645219594279272, 0.27899808658096104, 0.3057665666220456, 0.26315376026406656, 0.21511989374722074, 0.2575278816487149, 0.24044742242984363, 0.2574225569927545, 0.244144879551059, 0.22247499051757924, 0.14290736156916262, 0.11678469214751841, 0.12277340783438884, 0.11493151386308142, 0.1135211252016346, 0.102509039031208, 0.09939362646514383, 0.09530587567348614, 0.09339975205295836, 0.2570362150355472, 0.2360224283941328, 0.30125507814746455, 0.2934283759988683, 0.30134090061873264, 0.31427471002265617, 0.26083209519856787, 0.2627882178705033, 0.255966495048897, 0.01689755513879032, 0.009849586503949292, 0.028362805100835442, 0.03493698800659728, 9.999999999998899e-05, 0.031059021457651603, 0.06101943218618511, 0.054962754350037724, 0.0453517609923445, 0.13778038621965238, 0.1383273852317758, 0.15573991060525438, 0.14661670248636927, 0.11980646143925, 0.10032315954781879, 0.13907207799201082, 0.13960684864862027, 0.15731525518531164, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07726547195606037, 0.06164125498578177, 0.062122226591139085, 0.06951766310748098, 0.08867636077420449, 0.07005893357696003, 0.08704759030927967, 0.07424025352762398, 0.08669118362502726, 0.32260524448346806, 0.3465089375091388, 0.33399584143132366, 0.33991318618204414, 0.3536227086947451, 0.35209636429569935, 0.34325238750654485, 0.3591696991753388, 0.34692942973740537, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06908438813043849, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1603328855201709, 0.25872319107654607, 0.1414123897220928, 0.1268792711065897, 0.15374048250567884, 0.13672447673011634, 0.15973164475365864, 0.17835169829483766, 0.22039355266566985, 0.20576632550633933, 0.21875009578465687, 0.2180505226691486, 0.22967778756857749, 0.21650710715255117, 0.23825318608175183, 0.2238998043469116, 0.24306646621299222, 0.21780049914389754, 0.15324384995200957, 0.15149058160567697, 0.17204535588573833, 0.18322578743961004, 0.1646519995845407, 0.17415455054808304, 0.16339955209699875, 0.16960322079219659, 0.16910192999501394, 0.2794350090760468, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.21924722190272405, 0.23513199333755663, 0.22275838094867917, 0.19167840988617313, 0.16009893679920684, 0.17625384512369002, 0.16233312355244012, 0.16818048227707494, 0.16003537290487602, 0.17886975432340146, 0.17162430906464143, 0.1539736708767523, 0.1674108268199419, 0.4671993093065646, 0.5301942332911582, 0.5352639377393373, 0.44804288611916065, 0.5374889294920591, 0.6109521819238197, 0.1727318030654098, 0.1549775368532169, 0.19299220509040949, 0.4768816187507968, 0.18844248307823142, 0.2663940560456507, 0.19755420580170024, 0.39400788285077737, 0.4176150005731082, 0.3813595548007038, 0.6248246074418331, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18474160114494154, 0.1887913706295501, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08742058199544611, 0.1229540786621719, 0.09134652578179359, 0.09732395560259721, 0.12319073248227796, 0.08488520861794391, 0.09523967137184153, 0.08532066591685583, 0.09391868989599583]}, "mutation_prompt": null}
{"id": "040d1545-dfbb-4017-a843-7de64593fd64", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "c29a79c6-e59f-42be-8991-85262c2907df", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "392b34b1-1e02-403c-9db7-adf3b9500f22", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "65113921-eb08-4e1b-a811-5699e7772c14", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "0db53055-cc4e-47fc-bacc-8b9924b1a6ac", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "c5a5bd42-1130-4c62-bd0b-778402201093", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "2e0f2908-bd25-47dc-aa4a-418fa01a2041", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "cccc6adf-dd23-411b-bf6d-8dabd0fbbc58", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "6b7c75b0-a2fd-4bb6-b5db-fc8f97b110d2", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "33ed4808-1940-45b7-b240-17ab222cc489", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "c889c195-3cc3-4380-898e-0bdff318138b", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "a6b38135-7a37-40bd-8069-d79780e7eafd", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "e3bca629-1545-4ee4-87b4-b07b68634e70", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "f59e7690-4762-4542-8524-a305bda19c56", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "8cf46eee-359c-4291-8edd-37afc4ff5699", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
{"id": "16032e30-3237-46ef-aa43-9088dc5dfbd9", "solution": "import numpy as np\n\nclass ADE_OBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20 + 5 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.dynamic_factor = 1.0  # New dynamic factor\n\n    def _initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def _evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def _opposite_population(self, population):\n        min_bound, max_bound = self.bounds\n        return min_bound + max_bound - population * self.dynamic_factor  # Adjusted for dynamic factor\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(population, func)\n\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adaptive opposition-based learning\n            self.dynamic_factor = 0.5 + 0.5 * (1 - eval_count / self.budget)  # Update the dynamic factor\n            opposite_population = self._opposite_population(population)\n            opposite_fitness = self._evaluate_population(opposite_population, func)\n\n            combined_population = np.vstack((population, opposite_population))\n            combined_fitness = np.hstack((fitness, opposite_fitness))\n\n            # Select the best individuals from the combined population\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            eval_count += self.population_size\n\n            if eval_count >= self.budget:\n                break\n\n            new_population = np.zeros_like(population)\n            \n            for i in range(self.population_size):\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.crossover_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "ADE_OBL", "description": "Enhanced Adaptive Differential Evolution using Dynamic Adaptive Opposition-Based Learning to optimize exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2bf65165-ef45-4cce-a28e-746967ecb692", "metadata": {"aucs": [0.4066095958530762, 0.37685282365330275, 0.3694575031317653, 0.3960045403558009, 0.38867232176189115, 0.4267617888739542, 0.3919158724654569, 0.40774861405680574, 0.41484800896221374, 0.134674918072632, 0.134612829277024, 0.1614593437327343, 0.14867050609032084, 0.1914731935809103, 0.1766399629871347, 0.11286688130181788, 0.14215221403650757, 0.13415455175033852, 0.08480331417794662, 0.08714220400676609, 0.07626839205670621, 0.0765316233115414, 0.07414714894526098, 0.07874110229510656, 0.07881159844460595, 0.07391648712196819, 0.06937907023871615, 0.07523063387448015, 0.08008618843963289, 0.07555991881786417, 0.08169421787481823, 0.06353733159869102, 0.0747707248199937, 0.06192510388588557, 0.06898297081410132, 0.07022351475284683, 0.8711081028246175, 0.9550983131137787, 0.9570878666531741, 0.8964821314693486, 0.8902254824349805, 0.8850763205785825, 0.9183313187806655, 0.8626777595036274, 0.9487204650093638, 0.18298423917844187, 0.17172613789668978, 0.1656104810601171, 0.1579792340194346, 0.15183458435162078, 0.16771763586098476, 0.1645487032914814, 0.16968202542796373, 0.18645219594279272, 0.3290230293802576, 0.3057665666220456, 0.27539233927861007, 0.21693514710951545, 0.2595834895423986, 0.24080004794856802, 0.25862584326009597, 0.244144879551059, 0.22354501371863722, 0.14290736156916262, 0.11736731063752048, 0.1239823834495628, 0.11493151386308142, 0.11548286038693056, 0.10337095860059797, 0.10038264552033271, 0.09618109382645801, 0.09453745341507802, 0.25815078909291655, 0.2366784454079799, 0.30136052445990413, 0.2945214678028314, 0.3041428109065497, 0.31427471002265617, 0.26083592339534467, 0.2627882178705033, 0.2591521363059677, 0.0192123939683142, 0.01467654605927693, 0.030828709894422213, 0.03931714484010973, 0.005208369381906386, 0.031094551551460015, 0.07020998235461284, 0.05608872579774338, 0.049109794372997895, 0.13891100073592866, 0.13841220793477205, 0.15612368916193897, 0.15211983807845242, 0.11992246066371248, 0.10032315954781879, 0.1398439842472653, 0.13979855256031148, 0.16188324652546193, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07769853780930625, 0.06250428821609477, 0.062294948743906176, 0.06951766310748098, 0.08913317454498737, 0.07046487718371386, 0.0883062516000267, 0.07445813071188456, 0.09165303021498272, 0.3239321674024964, 0.34777583537277534, 0.33399584143132366, 0.3405133149685041, 0.3568848475359113, 0.35567018204343215, 0.3449604896260028, 0.3635565739915799, 0.34931912655233377, 0.0862379970380951, 0.07424448183539767, 0.07530571126967667, 0.075890907837323, 0.06929464381942763, 0.07776013587076236, 0.06840390766140281, 0.07455564019255434, 0.07007159986950517, 0.1624082590157141, 0.25872319107654607, 0.14040583902819215, 0.1273214672069547, 0.1537567151751702, 0.13684179193758395, 0.15981044668248034, 0.17943283283338074, 0.22043302187080116, 0.20576632550633933, 0.21882441876338998, 0.2180505226691486, 0.23076939790905238, 0.21769341568426748, 0.23825318608175183, 0.22514112296953903, 0.24584512147101012, 0.21780049914389754, 0.1542036722329474, 0.15188161317302495, 0.17204535588573833, 0.1835412377766663, 0.16601177696748126, 0.17483251710493097, 0.16390049005966612, 0.16960322079219659, 0.16983710605522173, 0.2794382655834684, 0.2291600623138207, 0.20775585425944254, 0.25288833052630744, 0.23143215682377094, 0.22135605179498663, 0.23513199333755663, 0.22275838094867917, 0.19150230580368288, 0.16005549491393722, 0.17625384512369002, 0.16239397858661864, 0.16818048227707494, 0.16005916830825007, 0.17886975432340146, 0.17193759809287035, 0.1539736708767523, 0.1674108268199419, 0.46756339170391414, 0.5400288182565033, 0.5394681968579041, 0.44978624817339097, 0.5407834769704563, 0.6116518352215579, 0.1727362001244428, 0.15497849329327984, 0.1929940911293454, 0.48023911148150533, 0.18844248307823142, 0.2676560685420102, 0.19755676641436426, 0.3988322640660342, 0.42551739916076825, 0.3844139015696978, 0.6253299311455232, 0.2713052526786678, 0.19097784686542818, 0.22316769978302864, 0.1854638981513521, 0.18437021553536836, 0.18783568408730278, 0.1862385495204414, 0.18180478503298358, 0.1960813765194397, 0.18800988324373769, 0.08744573787035281, 0.12299194443514894, 0.0914123456493906, 0.09788226314066617, 0.12323215813289212, 0.08532131842335822, 0.09523967137184153, 0.0853389010316623, 0.09391870871735575]}, "mutation_prompt": null}
